/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('gemp', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model DataValue = {
  code?: string(name='code'),
  description?: string(name='description'),
  configDescription?: string(name='configDescription'),
  configCode?: string(name='configCode'),
  parentCode?: string(name='parentCode'),
  configKey?: string(name='configKey'),
  configValue?: string(name='configValue'),
  requirement?: boolean(name='requirement'),
}

model AddProblemServiceGroupRequest {
  problemId?: long(name='problemId'),
  serviceGroupIds?: [ long ](name='serviceGroupIds'),
}

model AddProblemServiceGroupResponseBody = {
  requestId?: string(name='requestId'),
}

model AddProblemServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddProblemServiceGroupResponseBody(name='body'),
}

async function addProblemServiceGroup(request: AddProblemServiceGroupRequest): AddProblemServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addProblemServiceGroupWithOptions(request, headers, runtime);
}

async function addProblemServiceGroupWithOptions(request: AddProblemServiceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddProblemServiceGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.serviceGroupIds)) {
    body['serviceGroupIds'] = request.serviceGroupIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddProblemServiceGroup',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/addServiceGroup`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BillingStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    appUserCount?: long(name='appUserCount'),
    appUserCountFree?: long(name='appUserCountFree'),
    emailSend?: long(name='emailSend'),
    emailSendFree?: long(name='emailSendFree'),
    escalationPlanCount?: long(name='escalationPlanCount'),
    escalationPlanCountFree?: long(name='escalationPlanCountFree'),
    eventReportApi?: long(name='eventReportApi'),
    eventReportApiFree?: long(name='eventReportApiFree'),
    hasScheduleServiceGroupCount?: long(name='hasScheduleServiceGroupCount'),
    hasScheduleServiceGroupCountFree?: long(name='hasScheduleServiceGroupCountFree'),
    imMsgSend?: long(name='imMsgSend'),
    imMsgSendFree?: long(name='imMsgSendFree'),
    ruleCount?: long(name='ruleCount'),
    ruleCountFree?: long(name='ruleCountFree'),
    smsSend?: long(name='smsSend'),
    smsSendFree?: long(name='smsSendFree'),
    subscriptionNotifyCount?: long(name='subscriptionNotifyCount'),
    subscriptionNotifyCountFree?: long(name='subscriptionNotifyCountFree'),
    type?: boolean(name='type'),
    voiceSend?: long(name='voiceSend'),
    voiceSendFree?: long(name='voiceSendFree'),
  }(name='data'),
}

model BillingStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BillingStatisticsResponseBody(name='body'),
}

async function billingStatistics(): BillingStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return billingStatisticsWithOptions(headers, runtime);
}

async function billingStatisticsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): BillingStatisticsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'BillingStatistics',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/charging/details`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CancelProblemRequest {
  cancelReason?: long(name='cancelReason'),
  cancelReasonDescription?: string(name='cancelReasonDescription'),
  clientToken?: string(name='clientToken'),
  problemId?: long(name='problemId'),
  problemNotifyType?: long(name='problemNotifyType'),
}

model CancelProblemResponseBody = {
  requestId?: string(name='requestId'),
}

model CancelProblemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelProblemResponseBody(name='body'),
}

async function cancelProblem(request: CancelProblemRequest): CancelProblemResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelProblemWithOptions(request, headers, runtime);
}

async function cancelProblemWithOptions(request: CancelProblemRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelProblemResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.cancelReason)) {
    body['cancelReason'] = request.cancelReason;
  }
  if (!Util.isUnset(request.cancelReasonDescription)) {
    body['cancelReasonDescription'] = request.cancelReasonDescription;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.problemNotifyType)) {
    body['problemNotifyType'] = request.problemNotifyType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CancelProblem',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/cancel`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CheckWebhookRequest {
  clientToken?: string(name='clientToken'),
  webhook?: string(name='webhook'),
  webhookType?: string(name='webhookType'),
}

model CheckWebhookResponseBody = {
  requestId?: string(name='requestId'),
}

model CheckWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckWebhookResponseBody(name='body'),
}

async function checkWebhook(request: CheckWebhookRequest): CheckWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkWebhookWithOptions(request, headers, runtime);
}

async function checkWebhookWithOptions(request: CheckWebhookRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckWebhookResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.webhook)) {
    body['webhook'] = request.webhook;
  }
  if (!Util.isUnset(request.webhookType)) {
    body['webhookType'] = request.webhookType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CheckWebhook',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/check/webhook`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ConfirmIntegrationConfigRequest {
  clientToken?: string(name='clientToken'),
  integrationConfigId?: long(name='integrationConfigId'),
}

model ConfirmIntegrationConfigResponseBody = {
  requestId?: string(name='requestId'),
}

model ConfirmIntegrationConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfirmIntegrationConfigResponseBody(name='body'),
}

async function confirmIntegrationConfig(request: ConfirmIntegrationConfigRequest): ConfirmIntegrationConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return confirmIntegrationConfigWithOptions(request, headers, runtime);
}

async function confirmIntegrationConfigWithOptions(request: ConfirmIntegrationConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ConfirmIntegrationConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.integrationConfigId)) {
    body['integrationConfigId'] = request.integrationConfigId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmIntegrationConfig',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/integrationConfig/confirm`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateEscalationPlanRequest {
  clientToken?: string(name='clientToken'),
  escalationPlanDescription?: string(name='escalationPlanDescription'),
  escalationPlanName?: string(name='escalationPlanName'),
  escalationPlanRules?: [ 
    {
      escalationPlanConditions?: [ 
        {
          effection?: string(name='effection'),
          level?: string(name='level'),
        }
      ](name='escalationPlanConditions'),
      escalationPlanStrategies?: [ 
        {
          enableWebhook?: boolean(name='enableWebhook'),
          noticeChannels?: [ string ](name='noticeChannels'),
          noticeObjects?: [ long ](name='noticeObjects'),
          noticeTime?: string(name='noticeTime'),
          serviceGroupIds?: [ long ](name='serviceGroupIds'),
        }
      ](name='escalationPlanStrategies'),
      escalationPlanType?: string(name='escalationPlanType'),
    }
  ](name='escalationPlanRules'),
  escalationPlanScopeObjects?: [ 
    {
      scope?: string(name='scope'),
      scopeObjectId?: long(name='scopeObjectId'),
    }
  ](name='escalationPlanScopeObjects'),
}

model CreateEscalationPlanResponseBody = {
  data?: {
    escalationPlanId?: long(name='escalationPlanId'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model CreateEscalationPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEscalationPlanResponseBody(name='body'),
}

async function createEscalationPlan(request: CreateEscalationPlanRequest): CreateEscalationPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createEscalationPlanWithOptions(request, headers, runtime);
}

async function createEscalationPlanWithOptions(request: CreateEscalationPlanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateEscalationPlanResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.escalationPlanDescription)) {
    body['escalationPlanDescription'] = request.escalationPlanDescription;
  }
  if (!Util.isUnset(request.escalationPlanName)) {
    body['escalationPlanName'] = request.escalationPlanName;
  }
  if (!Util.isUnset(request.escalationPlanRules)) {
    body['escalationPlanRules'] = request.escalationPlanRules;
  }
  if (!Util.isUnset(request.escalationPlanScopeObjects)) {
    body['escalationPlanScopeObjects'] = request.escalationPlanScopeObjects;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEscalationPlan',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/escalationPlan/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateIncidentRequest {
  assignUserId?: long(name='assignUserId'),
  channels?: [ string ](name='channels'),
  clientToken?: string(name='clientToken'),
  effect?: string(name='effect'),
  incidentDescription?: string(name='incidentDescription'),
  incidentLevel?: string(name='incidentLevel'),
  incidentTitle?: string(name='incidentTitle'),
  relatedServiceId?: long(name='relatedServiceId'),
  serviceGroupId?: long(name='serviceGroupId'),
}

model CreateIncidentResponseBody = {
  data?: {
    incidentId?: long(name='incidentId'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model CreateIncidentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIncidentResponseBody(name='body'),
}

async function createIncident(request: CreateIncidentRequest): CreateIncidentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIncidentWithOptions(request, headers, runtime);
}

async function createIncidentWithOptions(request: CreateIncidentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIncidentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.assignUserId)) {
    body['assignUserId'] = request.assignUserId;
  }
  if (!Util.isUnset(request.channels)) {
    body['channels'] = request.channels;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.effect)) {
    body['effect'] = request.effect;
  }
  if (!Util.isUnset(request.incidentDescription)) {
    body['incidentDescription'] = request.incidentDescription;
  }
  if (!Util.isUnset(request.incidentLevel)) {
    body['incidentLevel'] = request.incidentLevel;
  }
  if (!Util.isUnset(request.incidentTitle)) {
    body['incidentTitle'] = request.incidentTitle;
  }
  if (!Util.isUnset(request.relatedServiceId)) {
    body['relatedServiceId'] = request.relatedServiceId;
  }
  if (!Util.isUnset(request.serviceGroupId)) {
    body['serviceGroupId'] = request.serviceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIncident',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/incident/manualSave`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateIncidentSubtotalRequest {
  clientToken?: string(name='clientToken'),
  description?: string(name='description'),
  incidentId?: long(name='incidentId'),
}

model CreateIncidentSubtotalResponseBody = {
  data?: {
    subtotalId?: long(name='subtotalId'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model CreateIncidentSubtotalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIncidentSubtotalResponseBody(name='body'),
}

async function createIncidentSubtotal(request: CreateIncidentSubtotalRequest): CreateIncidentSubtotalResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIncidentSubtotalWithOptions(request, headers, runtime);
}

async function createIncidentSubtotalWithOptions(request: CreateIncidentSubtotalRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIncidentSubtotalResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.incidentId)) {
    body['incidentId'] = request.incidentId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIncidentSubtotal',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/incident/save/subtotal`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateIntegrationConfigRequest {
  clientToken?: string(name='clientToken'),
  monitorSourceId?: long(name='monitorSourceId'),
}

model CreateIntegrationConfigResponseBody = {
  data?: {
    integrationConfigId?: long(name='integrationConfigId'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model CreateIntegrationConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIntegrationConfigResponseBody(name='body'),
}

async function createIntegrationConfig(request: CreateIntegrationConfigRequest): CreateIntegrationConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIntegrationConfigWithOptions(request, headers, runtime);
}

async function createIntegrationConfigWithOptions(request: CreateIntegrationConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIntegrationConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.monitorSourceId)) {
    body['monitorSourceId'] = request.monitorSourceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIntegrationConfig',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/integrationConfig/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateProblemRequest {
  affectServiceIds?: [ long ](name='affectServiceIds'),
  clientToken?: string(name='clientToken'),
  discoverTime?: string(name='discoverTime'),
  incidentId?: long(name='incidentId'),
  mainHandlerId?: long(name='mainHandlerId'),
  preliminaryReason?: string(name='preliminaryReason'),
  problemLevel?: string(name='problemLevel'),
  problemName?: string(name='problemName'),
  problemNotifyType?: string(name='problemNotifyType'),
  problemStatus?: string(name='problemStatus'),
  progressSummary?: string(name='progressSummary'),
  progressSummaryRichTextId?: long(name='progressSummaryRichTextId'),
  recoveryTime?: string(name='recoveryTime'),
  relatedServiceId?: long(name='relatedServiceId'),
  serviceGroupIds?: [ long ](name='serviceGroupIds'),
}

model CreateProblemResponseBody = {
  data?: {
    problemId?: long(name='problemId'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model CreateProblemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProblemResponseBody(name='body'),
}

async function createProblem(request: CreateProblemRequest): CreateProblemResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProblemWithOptions(request, headers, runtime);
}

async function createProblemWithOptions(request: CreateProblemRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProblemResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.affectServiceIds)) {
    body['affectServiceIds'] = request.affectServiceIds;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.discoverTime)) {
    body['discoverTime'] = request.discoverTime;
  }
  if (!Util.isUnset(request.incidentId)) {
    body['incidentId'] = request.incidentId;
  }
  if (!Util.isUnset(request.mainHandlerId)) {
    body['mainHandlerId'] = request.mainHandlerId;
  }
  if (!Util.isUnset(request.preliminaryReason)) {
    body['preliminaryReason'] = request.preliminaryReason;
  }
  if (!Util.isUnset(request.problemLevel)) {
    body['problemLevel'] = request.problemLevel;
  }
  if (!Util.isUnset(request.problemName)) {
    body['problemName'] = request.problemName;
  }
  if (!Util.isUnset(request.problemNotifyType)) {
    body['problemNotifyType'] = request.problemNotifyType;
  }
  if (!Util.isUnset(request.problemStatus)) {
    body['problemStatus'] = request.problemStatus;
  }
  if (!Util.isUnset(request.progressSummary)) {
    body['progressSummary'] = request.progressSummary;
  }
  if (!Util.isUnset(request.progressSummaryRichTextId)) {
    body['progressSummaryRichTextId'] = request.progressSummaryRichTextId;
  }
  if (!Util.isUnset(request.recoveryTime)) {
    body['recoveryTime'] = request.recoveryTime;
  }
  if (!Util.isUnset(request.relatedServiceId)) {
    body['relatedServiceId'] = request.relatedServiceId;
  }
  if (!Util.isUnset(request.serviceGroupIds)) {
    body['serviceGroupIds'] = request.serviceGroupIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProblem',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/upgrade`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateProblemEffectionServiceRequest {
  clientToken?: string(name='clientToken'),
  description?: string(name='description'),
  level?: string(name='level'),
  pictureUrl?: [ string ](name='pictureUrl'),
  problemId?: long(name='problemId'),
  serviceId?: long(name='serviceId'),
  status?: string(name='status'),
}

model CreateProblemEffectionServiceResponseBody = {
  data?: {
    effectionServiceId?: long(name='effectionServiceId'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model CreateProblemEffectionServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProblemEffectionServiceResponseBody(name='body'),
}

async function createProblemEffectionService(request: CreateProblemEffectionServiceRequest): CreateProblemEffectionServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProblemEffectionServiceWithOptions(request, headers, runtime);
}

async function createProblemEffectionServiceWithOptions(request: CreateProblemEffectionServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProblemEffectionServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.level)) {
    body['level'] = request.level;
  }
  if (!Util.isUnset(request.pictureUrl)) {
    body['pictureUrl'] = request.pictureUrl;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.serviceId)) {
    body['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProblemEffectionService',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/process/effectionService/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateProblemMeasureRequest {
  checkStandard?: string(name='checkStandard'),
  checkUserId?: long(name='checkUserId'),
  clientToken?: string(name='clientToken'),
  content?: string(name='content'),
  directorId?: long(name='directorId'),
  planFinishTime?: string(name='planFinishTime'),
  problemId?: long(name='problemId'),
  stalkerId?: long(name='stalkerId'),
  status?: string(name='status'),
  type?: int32(name='type'),
}

model CreateProblemMeasureResponseBody = {
  data?: {
    measureId?: long(name='measureId'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model CreateProblemMeasureResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProblemMeasureResponseBody(name='body'),
}

async function createProblemMeasure(request: CreateProblemMeasureRequest): CreateProblemMeasureResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProblemMeasureWithOptions(request, headers, runtime);
}

async function createProblemMeasureWithOptions(request: CreateProblemMeasureRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProblemMeasureResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkStandard)) {
    body['checkStandard'] = request.checkStandard;
  }
  if (!Util.isUnset(request.checkUserId)) {
    body['checkUserId'] = request.checkUserId;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }
  if (!Util.isUnset(request.directorId)) {
    body['directorId'] = request.directorId;
  }
  if (!Util.isUnset(request.planFinishTime)) {
    body['planFinishTime'] = request.planFinishTime;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.stalkerId)) {
    body['stalkerId'] = request.stalkerId;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProblemMeasure',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/improvement/measure/save`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateProblemSubtotalRequest {
  clientToken?: string(name='clientToken'),
  description?: string(name='description'),
  problemId?: long(name='problemId'),
}

model CreateProblemSubtotalResponseBody = {
  data?: {
    subtotalId?: long(name='subtotalId'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model CreateProblemSubtotalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProblemSubtotalResponseBody(name='body'),
}

async function createProblemSubtotal(request: CreateProblemSubtotalRequest): CreateProblemSubtotalResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProblemSubtotalWithOptions(request, headers, runtime);
}

async function createProblemSubtotalWithOptions(request: CreateProblemSubtotalRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProblemSubtotalResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProblemSubtotal',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/save/subtotal`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateProblemTimelineRequest {
  clientToken?: string(name='clientToken'),
  content?: string(name='content'),
  keyNode?: string(name='keyNode'),
  problemId?: long(name='problemId'),
  time?: string(name='time'),
}

model CreateProblemTimelineResponseBody = {
  data?: {
    problemTimelineId?: long(name='problemTimelineId'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model CreateProblemTimelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProblemTimelineResponseBody(name='body'),
}

async function createProblemTimeline(request: CreateProblemTimelineRequest): CreateProblemTimelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProblemTimelineWithOptions(request, headers, runtime);
}

async function createProblemTimelineWithOptions(request: CreateProblemTimelineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProblemTimelineResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }
  if (!Util.isUnset(request.keyNode)) {
    body['keyNode'] = request.keyNode;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.time)) {
    body['time'] = request.time;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProblemTimeline',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/process/timeline/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateProblemTimelinesRequest {
  clientToken?: string(name='clientToken'),
  problemId?: long(name='problemId'),
  timelineNodes?: string(name='timelineNodes'),
}

model CreateProblemTimelinesResponseBody = {
  data?: {
    problemTimelineIds?: [ long ](name='problemTimelineIds'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model CreateProblemTimelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProblemTimelinesResponseBody(name='body'),
}

async function createProblemTimelines(request: CreateProblemTimelinesRequest): CreateProblemTimelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProblemTimelinesWithOptions(request, headers, runtime);
}

async function createProblemTimelinesWithOptions(request: CreateProblemTimelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProblemTimelinesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.timelineNodes)) {
    body['timelineNodes'] = request.timelineNodes;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProblemTimelines',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/process/timeline/batchCreate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateRichTextRequest {
  instanceId?: long(name='instanceId'),
  instanceType?: string(name='instanceType'),
  richText?: string(name='richText'),
}

model CreateRichTextResponseBody = {
  data?: {
    instanceId?: long(name='instanceId'),
    instanceType?: long(name='instanceType'),
    richText?: string(name='richText'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model CreateRichTextResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRichTextResponseBody(name='body'),
}

async function createRichText(request: CreateRichTextRequest): CreateRichTextResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRichTextWithOptions(request, headers, runtime);
}

async function createRichTextWithOptions(request: CreateRichTextRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRichTextResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['instanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.richText)) {
    body['richText'] = request.richText;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRichText',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/rich/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateRouteRuleRequest {
  assignObjectId?: long(name='assignObjectId'),
  assignObjectType?: string(name='assignObjectType'),
  childRuleRelation?: string(name='childRuleRelation'),
  clientToken?: string(name='clientToken'),
  effection?: string(name='effection'),
  enableStatus?: string(name='enableStatus'),
  incidentLevel?: string(name='incidentLevel'),
  matchCount?: int32(name='matchCount'),
  notifyChannels?: [ string ](name='notifyChannels'),
  relatedServiceId?: long(name='relatedServiceId'),
  routeChildRules?: [ 
    {
      childConditionRelation?: long(name='childConditionRelation'),
      conditions?: [ 
        {
          key?: string(name='key'),
          operationSymbol?: string(name='operationSymbol'),
          value?: string(name='value'),
        }
      ](name='conditions'),
      monitorSourceId?: long(name='monitorSourceId'),
    }
  ](name='routeChildRules'),
  routeType?: string(name='routeType'),
  ruleName?: string(name='ruleName'),
  timeWindow?: long(name='timeWindow'),
  timeWindowUnit?: string(name='timeWindowUnit'),
}

model CreateRouteRuleResponseBody = {
  data?: {
    routeRuleId?: long(name='routeRuleId'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model CreateRouteRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRouteRuleResponseBody(name='body'),
}

async function createRouteRule(request: CreateRouteRuleRequest): CreateRouteRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRouteRuleWithOptions(request, headers, runtime);
}

async function createRouteRuleWithOptions(request: CreateRouteRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRouteRuleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.assignObjectId)) {
    body['assignObjectId'] = request.assignObjectId;
  }
  if (!Util.isUnset(request.assignObjectType)) {
    body['assignObjectType'] = request.assignObjectType;
  }
  if (!Util.isUnset(request.childRuleRelation)) {
    body['childRuleRelation'] = request.childRuleRelation;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.effection)) {
    body['effection'] = request.effection;
  }
  if (!Util.isUnset(request.enableStatus)) {
    body['enableStatus'] = request.enableStatus;
  }
  if (!Util.isUnset(request.incidentLevel)) {
    body['incidentLevel'] = request.incidentLevel;
  }
  if (!Util.isUnset(request.matchCount)) {
    body['matchCount'] = request.matchCount;
  }
  if (!Util.isUnset(request.notifyChannels)) {
    body['notifyChannels'] = request.notifyChannels;
  }
  if (!Util.isUnset(request.relatedServiceId)) {
    body['relatedServiceId'] = request.relatedServiceId;
  }
  if (!Util.isUnset(request.routeChildRules)) {
    body['routeChildRules'] = request.routeChildRules;
  }
  if (!Util.isUnset(request.routeType)) {
    body['routeType'] = request.routeType;
  }
  if (!Util.isUnset(request.ruleName)) {
    body['ruleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.timeWindow)) {
    body['timeWindow'] = request.timeWindow;
  }
  if (!Util.isUnset(request.timeWindowUnit)) {
    body['timeWindowUnit'] = request.timeWindowUnit;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRouteRule',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/routeRule/save`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateServiceRequest {
  clientToken?: string(name='clientToken'),
  serviceDescription?: string(name='serviceDescription'),
  serviceName?: string(name='serviceName'),
}

model CreateServiceResponseBody = {
  data?: {
    serviceId?: long(name='serviceId'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model CreateServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceResponseBody(name='body'),
}

async function createService(request: CreateServiceRequest): CreateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceWithOptions(request, headers, runtime);
}

async function createServiceWithOptions(request: CreateServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.serviceDescription)) {
    body['serviceDescription'] = request.serviceDescription;
  }
  if (!Util.isUnset(request.serviceName)) {
    body['serviceName'] = request.serviceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateService',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/save`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateServiceGroupRequest {
  clientToken?: string(name='clientToken'),
  enableWebhook?: string(name='enableWebhook'),
  monitorSourceTemplates?: [ 
    {
      monitorSourceId?: long(name='monitorSourceId'),
      monitorSourceName?: string(name='monitorSourceName'),
      templateContent?: string(name='templateContent'),
      templateId?: long(name='templateId'),
    }
  ](name='monitorSourceTemplates'),
  serviceGroupDescription?: string(name='serviceGroupDescription'),
  serviceGroupName?: string(name='serviceGroupName'),
  userIds?: [ long ](name='userIds'),
  webhookLink?: string(name='webhookLink'),
  webhookType?: string(name='webhookType'),
}

model CreateServiceGroupResponseBody = {
  data?: {
    serviceGroupId?: long(name='serviceGroupId'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model CreateServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceGroupResponseBody(name='body'),
}

async function createServiceGroup(request: CreateServiceGroupRequest): CreateServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceGroupWithOptions(request, headers, runtime);
}

async function createServiceGroupWithOptions(request: CreateServiceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.enableWebhook)) {
    body['enableWebhook'] = request.enableWebhook;
  }
  if (!Util.isUnset(request.monitorSourceTemplates)) {
    body['monitorSourceTemplates'] = request.monitorSourceTemplates;
  }
  if (!Util.isUnset(request.serviceGroupDescription)) {
    body['serviceGroupDescription'] = request.serviceGroupDescription;
  }
  if (!Util.isUnset(request.serviceGroupName)) {
    body['serviceGroupName'] = request.serviceGroupName;
  }
  if (!Util.isUnset(request.userIds)) {
    body['userIds'] = request.userIds;
  }
  if (!Util.isUnset(request.webhookLink)) {
    body['webhookLink'] = request.webhookLink;
  }
  if (!Util.isUnset(request.webhookType)) {
    body['webhookType'] = request.webhookType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceGroup',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/insert`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateServiceGroupSchedulingRequest {
  clientToken?: string(name='clientToken'),
  fastScheduling?: {
    dutyPlan?: string(name='dutyPlan'),
    schedulingUsers?: [ 
      {
        schedulingOrder?: long(name='schedulingOrder'),
        schedulingUserId?: long(name='schedulingUserId'),
      }
    ](name='schedulingUsers'),
    singleDuration?: int32(name='singleDuration'),
    singleDurationUnit?: string(name='singleDurationUnit'),
  }(name='fastScheduling'),
  fineScheduling?: {
    period?: int32(name='period'),
    periodUnit?: string(name='periodUnit'),
    schedulingFineShifts?: [ 
      {
        cycleOrder?: int32(name='cycleOrder'),
        schedulingEndTime?: string(name='schedulingEndTime'),
        schedulingOrder?: int32(name='schedulingOrder'),
        schedulingStartTime?: string(name='schedulingStartTime'),
        schedulingUserId?: long(name='schedulingUserId'),
        shiftName?: string(name='shiftName'),
        skipOneDay?: boolean(name='skipOneDay'),
      }
    ](name='schedulingFineShifts'),
    schedulingTemplateFineShifts?: [ 
      {
        schedulingEndTime?: string(name='schedulingEndTime'),
        schedulingOrder?: long(name='schedulingOrder'),
        schedulingStartTime?: string(name='schedulingStartTime'),
        schedulingUserId?: long(name='schedulingUserId'),
        schedulingUserName?: string(name='schedulingUserName'),
        skipOneDay?: boolean(name='skipOneDay'),
      }
    ](name='schedulingTemplateFineShifts'),
    shiftType?: string(name='shiftType'),
  }(name='fineScheduling'),
  schedulingWay?: string(name='schedulingWay'),
  serviceGroupId?: long(name='serviceGroupId'),
}

model CreateServiceGroupSchedulingResponseBody = {
  requestId?: string(name='requestId'),
}

model CreateServiceGroupSchedulingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceGroupSchedulingResponseBody(name='body'),
}

async function createServiceGroupScheduling(request: CreateServiceGroupSchedulingRequest): CreateServiceGroupSchedulingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceGroupSchedulingWithOptions(request, headers, runtime);
}

async function createServiceGroupSchedulingWithOptions(request: CreateServiceGroupSchedulingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceGroupSchedulingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.fastScheduling)) {
    body['fastScheduling'] = request.fastScheduling;
  }
  if (!Util.isUnset(request.fineScheduling)) {
    body['fineScheduling'] = request.fineScheduling;
  }
  if (!Util.isUnset(request.schedulingWay)) {
    body['schedulingWay'] = request.schedulingWay;
  }
  if (!Util.isUnset(request.serviceGroupId)) {
    body['serviceGroupId'] = request.serviceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceGroupScheduling',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/scheduling/save`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateSubscriptionRequest {
  clientToken?: string(name='clientToken'),
  endTime?: string(name='endTime'),
  expiredType?: long(name='expiredType'),
  notifyObjectList?: [ 
    {
      notifyObjectId?: long(name='notifyObjectId'),
    }
  ](name='notifyObjectList'),
  notifyObjectType?: long(name='notifyObjectType'),
  notifyStrategyList?: [ 
    {
      channels?: string(name='channels'),
      instanceType?: long(name='instanceType'),
      periodChannel?: {
        nonWorkday?: string(name='nonWorkday'),
        workday?: string(name='workday'),
      }(name='periodChannel'),
      strategies?: [ 
        {
          conditions?: [ 
            {
              action?: string(name='action'),
              effection?: string(name='effection'),
              level?: string(name='level'),
              problemNotifyType?: string(name='problemNotifyType'),
            }
          ](name='conditions'),
        }
      ](name='strategies'),
    }
  ](name='notifyStrategyList'),
  period?: string(name='period'),
  scope?: long(name='scope'),
  scopeObjectList?: [ 
    {
      scopeObjectId?: long(name='scopeObjectId'),
    }
  ](name='scopeObjectList'),
  startTime?: string(name='startTime'),
  subscriptionTitle?: string(name='subscriptionTitle'),
}

model CreateSubscriptionResponseBody = {
  data?: {
    subscriptionId?: long(name='subscriptionId'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model CreateSubscriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSubscriptionResponseBody(name='body'),
}

async function createSubscription(request: CreateSubscriptionRequest): CreateSubscriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSubscriptionWithOptions(request, headers, runtime);
}

async function createSubscriptionWithOptions(request: CreateSubscriptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSubscriptionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.endTime)) {
    body['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.expiredType)) {
    body['expiredType'] = request.expiredType;
  }
  if (!Util.isUnset(request.notifyObjectList)) {
    body['notifyObjectList'] = request.notifyObjectList;
  }
  if (!Util.isUnset(request.notifyObjectType)) {
    body['notifyObjectType'] = request.notifyObjectType;
  }
  if (!Util.isUnset(request.notifyStrategyList)) {
    body['notifyStrategyList'] = request.notifyStrategyList;
  }
  if (!Util.isUnset(request.period)) {
    body['period'] = request.period;
  }
  if (!Util.isUnset(request.scope)) {
    body['scope'] = request.scope;
  }
  if (!Util.isUnset(request.scopeObjectList)) {
    body['scopeObjectList'] = request.scopeObjectList;
  }
  if (!Util.isUnset(request.startTime)) {
    body['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.subscriptionTitle)) {
    body['subscriptionTitle'] = request.subscriptionTitle;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSubscription',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/notify/subscription/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateTenantApplicationRequest {
  channel?: string(name='channel'),
  clientToken?: string(name='clientToken'),
}

model CreateTenantApplicationResponseBody = {
  data?: {
    openUrl?: string(name='openUrl'),
    progress?: string(name='progress'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model CreateTenantApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTenantApplicationResponseBody(name='body'),
}

async function createTenantApplication(request: CreateTenantApplicationRequest): CreateTenantApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTenantApplicationWithOptions(request, headers, runtime);
}

async function createTenantApplicationWithOptions(request: CreateTenantApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTenantApplicationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.channel)) {
    body['channel'] = request.channel;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTenantApplication',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/mobileApp/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateUserRequest {
  clientToken?: string(name='clientToken'),
  email?: string(name='email'),
  phone?: string(name='phone'),
  ramId?: long(name='ramId'),
  username?: string(name='username'),
}

model CreateUserResponseBody = {
  data?: {
    userId?: long(name='userId'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model CreateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUserResponseBody(name='body'),
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createUserWithOptions(request, headers, runtime);
}

async function createUserWithOptions(request: CreateUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.email)) {
    body['email'] = request.email;
  }
  if (!Util.isUnset(request.phone)) {
    body['phone'] = request.phone;
  }
  if (!Util.isUnset(request.ramId)) {
    body['ramId'] = request.ramId;
  }
  if (!Util.isUnset(request.username)) {
    body['username'] = request.username;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateUser',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/user/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteEscalationPlanRequest {
  clientToken?: string(name='clientToken'),
  escalationPlanId?: long(name='escalationPlanId'),
}

model DeleteEscalationPlanResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteEscalationPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEscalationPlanResponseBody(name='body'),
}

async function deleteEscalationPlan(request: DeleteEscalationPlanRequest): DeleteEscalationPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEscalationPlanWithOptions(request, headers, runtime);
}

async function deleteEscalationPlanWithOptions(request: DeleteEscalationPlanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteEscalationPlanResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.escalationPlanId)) {
    body['escalationPlanId'] = request.escalationPlanId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEscalationPlan',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/escalationPlan/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteIncidentRequest {
  clientToken?: string(name='clientToken'),
  incidentId?: long(name='incidentId'),
}

model DeleteIncidentResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteIncidentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIncidentResponseBody(name='body'),
}

async function deleteIncident(request: DeleteIncidentRequest): DeleteIncidentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteIncidentWithOptions(request, headers, runtime);
}

async function deleteIncidentWithOptions(request: DeleteIncidentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteIncidentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.incidentId)) {
    body['incidentId'] = request.incidentId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIncident',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/incident/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteIntegrationConfigRequest {
  clientToken?: string(name='clientToken'),
  integrationConfigId?: long(name='integrationConfigId'),
}

model DeleteIntegrationConfigResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteIntegrationConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIntegrationConfigResponseBody(name='body'),
}

async function deleteIntegrationConfig(request: DeleteIntegrationConfigRequest): DeleteIntegrationConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteIntegrationConfigWithOptions(request, headers, runtime);
}

async function deleteIntegrationConfigWithOptions(request: DeleteIntegrationConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteIntegrationConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.integrationConfigId)) {
    body['integrationConfigId'] = request.integrationConfigId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIntegrationConfig',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/integrationConfig/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteProblemRequest {
  clientToken?: string(name='clientToken'),
  problemId?: long(name='problemId'),
}

model DeleteProblemResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteProblemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProblemResponseBody(name='body'),
}

async function deleteProblem(request: DeleteProblemRequest): DeleteProblemResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProblemWithOptions(request, headers, runtime);
}

async function deleteProblemWithOptions(request: DeleteProblemRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProblemResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProblem',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteProblemEffectionServiceRequest {
  clientToken?: string(name='clientToken'),
  effectionServiceId?: long(name='effectionServiceId'),
  problemId?: long(name='problemId'),
}

model DeleteProblemEffectionServiceResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteProblemEffectionServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProblemEffectionServiceResponseBody(name='body'),
}

async function deleteProblemEffectionService(request: DeleteProblemEffectionServiceRequest): DeleteProblemEffectionServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProblemEffectionServiceWithOptions(request, headers, runtime);
}

async function deleteProblemEffectionServiceWithOptions(request: DeleteProblemEffectionServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProblemEffectionServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.effectionServiceId)) {
    body['effectionServiceId'] = request.effectionServiceId;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProblemEffectionService',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/process/effectionService/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteProblemMeasureRequest {
  clientToken?: string(name='clientToken'),
  measureId?: long(name='measureId'),
  problemId?: string(name='problemId'),
}

model DeleteProblemMeasureResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteProblemMeasureResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProblemMeasureResponseBody(name='body'),
}

async function deleteProblemMeasure(request: DeleteProblemMeasureRequest): DeleteProblemMeasureResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProblemMeasureWithOptions(request, headers, runtime);
}

async function deleteProblemMeasureWithOptions(request: DeleteProblemMeasureRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProblemMeasureResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.measureId)) {
    body['measureId'] = request.measureId;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProblemMeasure',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/improvement/measure/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteProblemTimelineRequest {
  clientToken?: string(name='clientToken'),
  problemId?: long(name='problemId'),
  problemTimelineId?: long(name='problemTimelineId'),
}

model DeleteProblemTimelineResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteProblemTimelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProblemTimelineResponseBody(name='body'),
}

async function deleteProblemTimeline(request: DeleteProblemTimelineRequest): DeleteProblemTimelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProblemTimelineWithOptions(request, headers, runtime);
}

async function deleteProblemTimelineWithOptions(request: DeleteProblemTimelineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProblemTimelineResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.problemTimelineId)) {
    body['problemTimelineId'] = request.problemTimelineId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProblemTimeline',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/process/timeline/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteRouteRuleRequest {
  clientToken?: string(name='clientToken'),
  routeRuleId?: long(name='routeRuleId'),
}

model DeleteRouteRuleResponseBody = {
  requestId?: long(name='requestId'),
}

model DeleteRouteRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRouteRuleResponseBody(name='body'),
}

async function deleteRouteRule(request: DeleteRouteRuleRequest): DeleteRouteRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRouteRuleWithOptions(request, headers, runtime);
}

async function deleteRouteRuleWithOptions(request: DeleteRouteRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRouteRuleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.routeRuleId)) {
    body['routeRuleId'] = request.routeRuleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRouteRule',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/routeRule/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceRequest {
  clientToken?: string(name='clientToken'),
  serviceId?: long(name='serviceId'),
}

model DeleteServiceResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceResponseBody(name='body'),
}

async function deleteService(request: DeleteServiceRequest): DeleteServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceWithOptions(request, headers, runtime);
}

async function deleteServiceWithOptions(request: DeleteServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.serviceId)) {
    body['serviceId'] = request.serviceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteService',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceGroupRequest {
  clientToken?: string(name='clientToken'),
  serviceGroupId?: long(name='serviceGroupId'),
}

model DeleteServiceGroupResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceGroupResponseBody(name='body'),
}

async function deleteServiceGroup(request: DeleteServiceGroupRequest): DeleteServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceGroupWithOptions(request, headers, runtime);
}

async function deleteServiceGroupWithOptions(request: DeleteServiceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.serviceGroupId)) {
    body['serviceGroupId'] = request.serviceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceGroup',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceGroupSchedulingResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteServiceGroupSchedulingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceGroupSchedulingResponseBody(name='body'),
}

async function deleteServiceGroupScheduling(): DeleteServiceGroupSchedulingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceGroupSchedulingWithOptions(headers, runtime);
}

async function deleteServiceGroupSchedulingWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceGroupSchedulingResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceGroupScheduling',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/scheduling/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceGroupUserRequest {
  clientToken?: string(name='clientToken'),
  newUserId?: long(name='newUserId'),
  oldUserId?: long(name='oldUserId'),
  removeUser?: boolean(name='removeUser'),
  serviceGroupId?: long(name='serviceGroupId'),
}

model DeleteServiceGroupUserResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteServiceGroupUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceGroupUserResponseBody(name='body'),
}

async function deleteServiceGroupUser(request: DeleteServiceGroupUserRequest): DeleteServiceGroupUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceGroupUserWithOptions(request, headers, runtime);
}

async function deleteServiceGroupUserWithOptions(request: DeleteServiceGroupUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceGroupUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.newUserId)) {
    body['newUserId'] = request.newUserId;
  }
  if (!Util.isUnset(request.oldUserId)) {
    body['oldUserId'] = request.oldUserId;
  }
  if (!Util.isUnset(request.removeUser)) {
    body['removeUser'] = request.removeUser;
  }
  if (!Util.isUnset(request.serviceGroupId)) {
    body['serviceGroupId'] = request.serviceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceGroupUser',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/deleteServiceGroupUser`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteSubscriptionRequest {
  subscriptionId?: long(name='subscriptionId'),
}

model DeleteSubscriptionResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteSubscriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSubscriptionResponseBody(name='body'),
}

async function deleteSubscription(request: DeleteSubscriptionRequest): DeleteSubscriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSubscriptionWithOptions(request, headers, runtime);
}

async function deleteSubscriptionWithOptions(request: DeleteSubscriptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSubscriptionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.subscriptionId)) {
    body['subscriptionId'] = request.subscriptionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSubscription',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/notify/subscription/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteUserRequest {
  clientToken?: string(name='clientToken'),
  userId?: long(name='userId'),
}

model DeleteUserResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteUserWithOptions(request, headers, runtime);
}

async function deleteUserWithOptions(request: DeleteUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.userId)) {
    body['userId'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUser',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/user/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeliverIncidentRequest {
  assignUserId?: long(name='assignUserId'),
  clientToken?: string(name='clientToken'),
  incidentId?: long(name='incidentId'),
}

model DeliverIncidentResponseBody = {
  requestId?: string(name='requestId'),
}

model DeliverIncidentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeliverIncidentResponseBody(name='body'),
}

async function deliverIncident(request: DeliverIncidentRequest): DeliverIncidentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deliverIncidentWithOptions(request, headers, runtime);
}

async function deliverIncidentWithOptions(request: DeliverIncidentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeliverIncidentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.assignUserId)) {
    body['assignUserId'] = request.assignUserId;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.incidentId)) {
    body['incidentId'] = request.incidentId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeliverIncident',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/incident/deliver`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DisableEscalationPlanRequest {
  clientToken?: string(name='clientToken'),
  escalationPlanId?: long(name='escalationPlanId'),
}

model DisableEscalationPlanResponseBody = {
  requestId?: string(name='requestId'),
}

model DisableEscalationPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableEscalationPlanResponseBody(name='body'),
}

async function disableEscalationPlan(request: DisableEscalationPlanRequest): DisableEscalationPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableEscalationPlanWithOptions(request, headers, runtime);
}

async function disableEscalationPlanWithOptions(request: DisableEscalationPlanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DisableEscalationPlanResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.escalationPlanId)) {
    body['escalationPlanId'] = request.escalationPlanId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DisableEscalationPlan',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/escalationPlan/disable`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DisableIntegrationConfigRequest {
  clientToken?: string(name='clientToken'),
  integrationConfigId?: long(name='integrationConfigId'),
}

model DisableIntegrationConfigResponseBody = {
  requestId?: string(name='requestId'),
}

model DisableIntegrationConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableIntegrationConfigResponseBody(name='body'),
}

async function disableIntegrationConfig(request: DisableIntegrationConfigRequest): DisableIntegrationConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableIntegrationConfigWithOptions(request, headers, runtime);
}

async function disableIntegrationConfigWithOptions(request: DisableIntegrationConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DisableIntegrationConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.integrationConfigId)) {
    body['integrationConfigId'] = request.integrationConfigId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DisableIntegrationConfig',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/integrationConfig/disable`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DisableRouteRuleRequest {
  clientToken?: string(name='clientToken'),
  routeRuleId?: long(name='routeRuleId'),
}

model DisableRouteRuleResponseBody = {
  data?: long(name='data'),
  requestId?: string(name='requestId'),
}

model DisableRouteRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableRouteRuleResponseBody(name='body'),
}

async function disableRouteRule(request: DisableRouteRuleRequest): DisableRouteRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableRouteRuleWithOptions(request, headers, runtime);
}

async function disableRouteRuleWithOptions(request: DisableRouteRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DisableRouteRuleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.routeRuleId)) {
    body['routeRuleId'] = request.routeRuleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DisableRouteRule',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/routeRule/disable`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DisableServiceGroupWebhookRequest {
  clientToken?: string(name='clientToken'),
  serviceGroupId?: long(name='serviceGroupId'),
}

model DisableServiceGroupWebhookResponseBody = {
  requestId?: string(name='requestId'),
}

model DisableServiceGroupWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableServiceGroupWebhookResponseBody(name='body'),
}

async function disableServiceGroupWebhook(request: DisableServiceGroupWebhookRequest): DisableServiceGroupWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableServiceGroupWebhookWithOptions(request, headers, runtime);
}

async function disableServiceGroupWebhookWithOptions(request: DisableServiceGroupWebhookRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DisableServiceGroupWebhookResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.serviceGroupId)) {
    body['serviceGroupId'] = request.serviceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DisableServiceGroupWebhook',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/disableWebhook`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DisableSubscriptionRequest {
  subscriptionId?: long(name='subscriptionId'),
}

model DisableSubscriptionResponseBody = {
  requestId?: string(name='requestId'),
}

model DisableSubscriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableSubscriptionResponseBody(name='body'),
}

async function disableSubscription(request: DisableSubscriptionRequest): DisableSubscriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableSubscriptionWithOptions(request, headers, runtime);
}

async function disableSubscriptionWithOptions(request: DisableSubscriptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DisableSubscriptionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.subscriptionId)) {
    body['subscriptionId'] = request.subscriptionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DisableSubscription',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/notify/subscription/doDisable`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model EnableEscalationPlanRequest {
  clientToken?: string(name='clientToken'),
  escalationPlanId?: long(name='escalationPlanId'),
}

model EnableEscalationPlanResponseBody = {
  requestId?: string(name='requestId'),
}

model EnableEscalationPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableEscalationPlanResponseBody(name='body'),
}

async function enableEscalationPlan(request: EnableEscalationPlanRequest): EnableEscalationPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableEscalationPlanWithOptions(request, headers, runtime);
}

async function enableEscalationPlanWithOptions(request: EnableEscalationPlanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EnableEscalationPlanResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.escalationPlanId)) {
    body['escalationPlanId'] = request.escalationPlanId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EnableEscalationPlan',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/escalationPlan/enable`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model EnableIntegrationConfigRequest {
  clientToken?: string(name='clientToken'),
  integrationConfigId?: long(name='integrationConfigId'),
}

model EnableIntegrationConfigResponseBody = {
  requestId?: string(name='requestId'),
}

model EnableIntegrationConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableIntegrationConfigResponseBody(name='body'),
}

async function enableIntegrationConfig(request: EnableIntegrationConfigRequest): EnableIntegrationConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableIntegrationConfigWithOptions(request, headers, runtime);
}

async function enableIntegrationConfigWithOptions(request: EnableIntegrationConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EnableIntegrationConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.integrationConfigId)) {
    body['integrationConfigId'] = request.integrationConfigId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EnableIntegrationConfig',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/integrationConfig/enable`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model EnableRouteRuleRequest {
  clientToken?: string(name='clientToken'),
  routeRuleId?: long(name='routeRuleId'),
}

model EnableRouteRuleResponseBody = {
  data?: int32(name='data'),
  requestId?: string(name='requestId'),
}

model EnableRouteRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableRouteRuleResponseBody(name='body'),
}

async function enableRouteRule(request: EnableRouteRuleRequest): EnableRouteRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableRouteRuleWithOptions(request, headers, runtime);
}

async function enableRouteRuleWithOptions(request: EnableRouteRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EnableRouteRuleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.routeRuleId)) {
    body['routeRuleId'] = request.routeRuleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EnableRouteRule',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/routeRule/enable`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model EnableServiceGroupWebhookRequest {
  clientToken?: string(name='clientToken'),
  serviceGroupId?: long(name='serviceGroupId'),
}

model EnableServiceGroupWebhookResponseBody = {
  requestId?: string(name='requestId'),
}

model EnableServiceGroupWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableServiceGroupWebhookResponseBody(name='body'),
}

async function enableServiceGroupWebhook(request: EnableServiceGroupWebhookRequest): EnableServiceGroupWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableServiceGroupWebhookWithOptions(request, headers, runtime);
}

async function enableServiceGroupWebhookWithOptions(request: EnableServiceGroupWebhookRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EnableServiceGroupWebhookResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.serviceGroupId)) {
    body['serviceGroupId'] = request.serviceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EnableServiceGroupWebhook',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/enableWebhook`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model EnableSubscriptionRequest {
  subscriptionId?: long(name='subscriptionId'),
}

model EnableSubscriptionResponseBody = {
  requestId?: string(name='requestId'),
}

model EnableSubscriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableSubscriptionResponseBody(name='body'),
}

async function enableSubscription(request: EnableSubscriptionRequest): EnableSubscriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableSubscriptionWithOptions(request, headers, runtime);
}

async function enableSubscriptionWithOptions(request: EnableSubscriptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EnableSubscriptionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.subscriptionId)) {
    body['subscriptionId'] = request.subscriptionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EnableSubscription',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/notify/subscription/enable`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model FinishIncidentRequest {
  clientToken?: string(name='clientToken'),
  incidentFinishReason?: int32(name='incidentFinishReason'),
  incidentFinishReasonDescription?: string(name='incidentFinishReasonDescription'),
  incidentFinishSolution?: int32(name='incidentFinishSolution'),
  incidentFinishSolutionDescription?: string(name='incidentFinishSolutionDescription'),
  incidentIds?: [ long ](name='incidentIds'),
}

model FinishIncidentResponseBody = {
  requestId?: string(name='requestId'),
}

model FinishIncidentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FinishIncidentResponseBody(name='body'),
}

async function finishIncident(request: FinishIncidentRequest): FinishIncidentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return finishIncidentWithOptions(request, headers, runtime);
}

async function finishIncidentWithOptions(request: FinishIncidentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FinishIncidentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.incidentFinishReason)) {
    body['incidentFinishReason'] = request.incidentFinishReason;
  }
  if (!Util.isUnset(request.incidentFinishReasonDescription)) {
    body['incidentFinishReasonDescription'] = request.incidentFinishReasonDescription;
  }
  if (!Util.isUnset(request.incidentFinishSolution)) {
    body['incidentFinishSolution'] = request.incidentFinishSolution;
  }
  if (!Util.isUnset(request.incidentFinishSolutionDescription)) {
    body['incidentFinishSolutionDescription'] = request.incidentFinishSolutionDescription;
  }
  if (!Util.isUnset(request.incidentIds)) {
    body['incidentIds'] = request.incidentIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FinishIncident',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/incident/finish`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model FinishProblemRequest {
  clientToken?: string(name='clientToken'),
  problemId?: long(name='problemId'),
}

model FinishProblemResponseBody = {
  requestId?: string(name='requestId'),
}

model FinishProblemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FinishProblemResponseBody(name='body'),
}

async function finishProblem(request: FinishProblemRequest): FinishProblemResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return finishProblemWithOptions(request, headers, runtime);
}

async function finishProblemWithOptions(request: FinishProblemRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FinishProblemResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FinishProblem',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/finish`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GeneratePictureLinkRequest {
  keys?: [ string ](name='keys'),
  problemId?: long(name='problemId'),
}

model GeneratePictureLinkResponseBody = {
  data?: {
    links?: [ 
      {
        key?: string(name='key'),
        link?: string(name='link'),
      }
    ](name='links'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GeneratePictureLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GeneratePictureLinkResponseBody(name='body'),
}

async function generatePictureLink(request: GeneratePictureLinkRequest): GeneratePictureLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return generatePictureLinkWithOptions(request, headers, runtime);
}

async function generatePictureLinkWithOptions(request: GeneratePictureLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GeneratePictureLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.keys)) {
    body['keys'] = request.keys;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GeneratePictureLink',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/rich/oss/getPictureLink`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GeneratePictureUploadSignRequest {
  files?: [ 
    {
      fileName?: string(name='fileName'),
      fileSize?: long(name='fileSize'),
      fileType?: string(name='fileType'),
    }
  ](name='files'),
  instanceId?: long(name='instanceId'),
  instanceType?: string(name='instanceType'),
}

model GeneratePictureUploadSignResponseBody = {
  data?: {
    accessKeyId?: string(name='accessKeyId'),
    bucketName?: string(name='bucketName'),
    files?: [ 
      {
        fileName?: string(name='fileName'),
        fileSize?: long(name='fileSize'),
        fileType?: string(name='fileType'),
        key?: string(name='key'),
      }
    ](name='files'),
    policy?: string(name='policy'),
    signature?: string(name='signature'),
    url?: string(name='url'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GeneratePictureUploadSignResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GeneratePictureUploadSignResponseBody(name='body'),
}

async function generatePictureUploadSign(request: GeneratePictureUploadSignRequest): GeneratePictureUploadSignResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return generatePictureUploadSignWithOptions(request, headers, runtime);
}

async function generatePictureUploadSignWithOptions(request: GeneratePictureUploadSignRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GeneratePictureUploadSignResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.files)) {
    body['files'] = request.files;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['instanceType'] = request.instanceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GeneratePictureUploadSign',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/rich/oss/generatePostPolicy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GenerateProblemPictureLinkRequest {
  keys?: [ string ](name='keys'),
  problemId?: string(name='problemId'),
}

model GenerateProblemPictureLinkResponseBody = {
  data?: {
    links?: [ 
      {
        key?: string(name='key'),
        link?: string(name='link'),
      }
    ](name='links'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GenerateProblemPictureLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateProblemPictureLinkResponseBody(name='body'),
}

async function generateProblemPictureLink(request: GenerateProblemPictureLinkRequest): GenerateProblemPictureLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return generateProblemPictureLinkWithOptions(request, headers, runtime);
}

async function generateProblemPictureLinkWithOptions(request: GenerateProblemPictureLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GenerateProblemPictureLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.keys)) {
    body['keys'] = request.keys;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GenerateProblemPictureLink',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/process/oss/getPresignedLink`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GenerateProblemPictureUploadSignRequest {
  fileName?: string(name='fileName'),
  fileSize?: long(name='fileSize'),
  fileType?: string(name='fileType'),
  problemId?: long(name='problemId'),
}

model GenerateProblemPictureUploadSignResponseBody = {
  data?: {
    accessKeyId?: string(name='accessKeyId'),
    bucketName?: string(name='bucketName'),
    key?: string(name='key'),
    policy?: string(name='policy'),
    signature?: string(name='signature'),
    url?: string(name='url'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GenerateProblemPictureUploadSignResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateProblemPictureUploadSignResponseBody(name='body'),
}

async function generateProblemPictureUploadSign(request: GenerateProblemPictureUploadSignRequest): GenerateProblemPictureUploadSignResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return generateProblemPictureUploadSignWithOptions(request, headers, runtime);
}

async function generateProblemPictureUploadSignWithOptions(request: GenerateProblemPictureUploadSignRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GenerateProblemPictureUploadSignResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fileName)) {
    body['fileName'] = request.fileName;
  }
  if (!Util.isUnset(request.fileSize)) {
    body['fileSize'] = request.fileSize;
  }
  if (!Util.isUnset(request.fileType)) {
    body['fileType'] = request.fileType;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GenerateProblemPictureUploadSign',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/process/oss/generatePostPolicy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetEscalationPlanRequest {
  clientToken?: string(name='clientToken'),
  escalationPlanId?: long(name='escalationPlanId'),
}

model GetEscalationPlanResponseBody = {
  data?: {
    createTime?: string(name='createTime'),
    escalationPlanDescription?: string(name='escalationPlanDescription'),
    escalationPlanId?: long(name='escalationPlanId'),
    escalationPlanName?: string(name='escalationPlanName'),
    escalationPlanRules?: [ 
      {
        escalationPlanConditions?: [ 
          {
            effection?: string(name='effection'),
            level?: string(name='level'),
          }
        ](name='escalationPlanConditions'),
        escalationPlanRuleId?: long(name='escalationPlanRuleId'),
        escalationPlanStrategies?: [ 
          {
            enableWebhook?: boolean(name='enableWebhook'),
            escalationPlanType?: string(name='escalationPlanType'),
            noticeChannels?: string(name='noticeChannels'),
            noticeObjectList?: [ 
              {
                noticeObjectId?: long(name='noticeObjectId'),
                noticeObjectName?: string(name='noticeObjectName'),
              }
            ](name='noticeObjectList'),
            noticeTime?: long(name='noticeTime'),
            serviceGroups?: [ 
              {
                id?: long(name='id'),
                serviceGroupName?: string(name='serviceGroupName'),
              }
            ](name='serviceGroups'),
          }
        ](name='escalationPlanStrategies'),
      }
    ](name='escalationPlanRules'),
    escalationPlanScopeObjects?: [ 
      {
        escalationPlanScopeObjects?: int32(name='escalationPlanScopeObjects'),
        scope?: string(name='scope'),
        scopeObjectDeletedType?: int32(name='scopeObjectDeletedType'),
        scopeObjectId?: long(name='scopeObjectId'),
        scopeObjectName?: string(name='scopeObjectName'),
      }
    ](name='escalationPlanScopeObjects'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetEscalationPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEscalationPlanResponseBody(name='body'),
}

async function getEscalationPlan(request: GetEscalationPlanRequest): GetEscalationPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEscalationPlanWithOptions(request, headers, runtime);
}

async function getEscalationPlanWithOptions(request: GetEscalationPlanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetEscalationPlanResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.escalationPlanId)) {
    body['escalationPlanId'] = request.escalationPlanId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetEscalationPlan',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/escalationPlan/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetEventRequest {
  monitorSourceId?: long(name='monitorSourceId'),
}

model GetEventResponseBody = {
  data?: {
    eventJson?: string(name='eventJson'),
    eventTime?: string(name='eventTime'),
    monitorSourceId?: long(name='monitorSourceId'),
    monitorSourceName?: string(name='monitorSourceName'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetEventResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEventResponseBody(name='body'),
}

async function getEvent(request: GetEventRequest): GetEventResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEventWithOptions(request, headers, runtime);
}

async function getEventWithOptions(request: GetEventRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetEventResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.monitorSourceId)) {
    body['monitorSourceId'] = request.monitorSourceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetEvent',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/events/getLastTimeEvent`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetHomePageGuidanceRequest {
  clientToken?: string(name='clientToken'),
}

model GetHomePageGuidanceResponseBody = {
  data?: {
    notifySubscriptionStatus?: boolean(name='notifySubscriptionStatus'),
    serviceGroupStatus?: boolean(name='serviceGroupStatus'),
    serviceStatus?: boolean(name='serviceStatus'),
    usersStatus?: boolean(name='usersStatus'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetHomePageGuidanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetHomePageGuidanceResponseBody(name='body'),
}

async function getHomePageGuidance(request: GetHomePageGuidanceRequest): GetHomePageGuidanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getHomePageGuidanceWithOptions(request, headers, runtime);
}

async function getHomePageGuidanceWithOptions(request: GetHomePageGuidanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetHomePageGuidanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetHomePageGuidance',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/guidance/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetIncidentRequest {
  clientToken?: string(name='clientToken'),
  incidentId?: long(name='incidentId'),
}

model GetIncidentResponseBody = {
  data?: {
    assignToWhoIsValid?: int32(name='assignToWhoIsValid'),
    assignUserId?: long(name='assignUserId'),
    assignUserName?: string(name='assignUserName'),
    assignUserPhone?: string(name='assignUserPhone'),
    createTime?: string(name='createTime'),
    defaultAssignToWho?: int32(name='defaultAssignToWho'),
    defaultAssignToWhoIsValid?: int32(name='defaultAssignToWhoIsValid'),
    defaultAssignToWhoName?: string(name='defaultAssignToWhoName'),
    durationTime?: long(name='durationTime'),
    effect?: string(name='effect'),
    incidentDescription?: string(name='incidentDescription'),
    incidentId?: long(name='incidentId'),
    incidentLevel?: string(name='incidentLevel'),
    incidentNumber?: string(name='incidentNumber'),
    incidentStatus?: string(name='incidentStatus'),
    incidentTitle?: string(name='incidentTitle'),
    isManual?: boolean(name='isManual'),
    isUpgrade?: boolean(name='isUpgrade'),
    notifyChannels?: [ string ](name='notifyChannels'),
    problemId?: long(name='problemId'),
    problemNumber?: string(name='problemNumber'),
    relRouteRuleDeleteType?: int32(name='relRouteRuleDeleteType'),
    relServiceDeleteType?: int32(name='relServiceDeleteType'),
    relServiceGroupIsValid?: int32(name='relServiceGroupIsValid'),
    relatedServiceDescription?: string(name='relatedServiceDescription'),
    relatedServiceGroupId?: long(name='relatedServiceGroupId'),
    relatedServiceGroupName?: string(name='relatedServiceGroupName'),
    relatedServiceId?: long(name='relatedServiceId'),
    relatedServiceName?: string(name='relatedServiceName'),
    routeRuleId?: long(name='routeRuleId'),
    routeRuleName?: string(name='routeRuleName'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetIncidentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIncidentResponseBody(name='body'),
}

async function getIncident(request: GetIncidentRequest): GetIncidentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIncidentWithOptions(request, headers, runtime);
}

async function getIncidentWithOptions(request: GetIncidentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetIncidentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.incidentId)) {
    body['incidentId'] = request.incidentId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetIncident',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/incident/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetIncidentStatisticsRequest {
  clientToken?: string(name='clientToken'),
}

model GetIncidentStatisticsResponseBody = {
  data?: {
    allFinish?: int32(name='allFinish'),
    allResponse?: int32(name='allResponse'),
    myFinish?: int32(name='myFinish'),
    myResponse?: int32(name='myResponse'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetIncidentStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIncidentStatisticsResponseBody(name='body'),
}

async function getIncidentStatistics(request: GetIncidentStatisticsRequest): GetIncidentStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIncidentStatisticsWithOptions(request, headers, runtime);
}

async function getIncidentStatisticsWithOptions(request: GetIncidentStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetIncidentStatisticsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetIncidentStatistics',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/incident/count`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetIncidentSubtotalCountRequest {
  clientToken?: string(name='clientToken'),
  incidentIds?: [ long ](name='incidentIds'),
}

model GetIncidentSubtotalCountResponseBody = {
  data?: {
    requestId?: string(name='requestId'),
    subtotalCount?: map[string]any(name='subtotalCount'),
  }(name='data'),
}

model GetIncidentSubtotalCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIncidentSubtotalCountResponseBody(name='body'),
}

async function getIncidentSubtotalCount(request: GetIncidentSubtotalCountRequest): GetIncidentSubtotalCountResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIncidentSubtotalCountWithOptions(request, headers, runtime);
}

async function getIncidentSubtotalCountWithOptions(request: GetIncidentSubtotalCountRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetIncidentSubtotalCountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.incidentIds)) {
    body['incidentIds'] = request.incidentIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetIncidentSubtotalCount',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/incident/subtotal/count`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetIntegrationConfigRequest {
  clientToken?: string(name='clientToken'),
  integrationConfigId?: long(name='integrationConfigId'),
}

model GetIntegrationConfigResponseBody = {
  data?: {
    accessKey?: string(name='accessKey'),
    integrationConfigId?: long(name='integrationConfigId'),
    isReceivedEvent?: boolean(name='isReceivedEvent'),
    monitorSourceId?: long(name='monitorSourceId'),
    monitorSourceName?: string(name='monitorSourceName'),
    monitorSourceShortName?: string(name='monitorSourceShortName'),
    status?: string(name='status'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetIntegrationConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIntegrationConfigResponseBody(name='body'),
}

async function getIntegrationConfig(request: GetIntegrationConfigRequest): GetIntegrationConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIntegrationConfigWithOptions(request, headers, runtime);
}

async function getIntegrationConfigWithOptions(request: GetIntegrationConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetIntegrationConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.integrationConfigId)) {
    body['integrationConfigId'] = request.integrationConfigId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetIntegrationConfig',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/integrationConfig/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProblemRequest {
  clientToken?: string(name='clientToken'),
  problemId?: long(name='problemId'),
}

model GetProblemResponseBody = {
  data?: {
    cancelProblemOperateLogs?: [ 
      {
        actionName?: string(name='actionName'),
        actionTime?: string(name='actionTime'),
        operator?: string(name='operator'),
        userId?: long(name='userId'),
      }
    ](name='cancelProblemOperateLogs'),
    cancelReason?: long(name='cancelReason'),
    cancelReasonDescription?: string(name='cancelReasonDescription'),
    coordinationGroups?: [ 
      {
        isValid?: long(name='isValid'),
        serviceGroupId?: long(name='serviceGroupId'),
        serviceGroupName?: string(name='serviceGroupName'),
      }
    ](name='coordinationGroups'),
    createTime?: string(name='createTime'),
    discoverTime?: string(name='discoverTime'),
    durationTime?: long(name='durationTime'),
    effectionServices?: [ 
      {
        description?: string(name='description'),
        effectionLevel?: long(name='effectionLevel'),
        effectionServiceId?: long(name='effectionServiceId'),
        effectionStatus?: int32(name='effectionStatus'),
        serviceDeleteType?: int32(name='serviceDeleteType'),
        serviceName?: string(name='serviceName'),
      }
    ](name='effectionServices'),
    feedback?: string(name='feedback'),
    handingProblemOperateLogs?: [ 
      {
        actionName?: string(name='actionName'),
        actionTime?: string(name='actionTime'),
        operator?: string(name='operator'),
        userId?: long(name='userId'),
        userIsValid?: long(name='userIsValid'),
      }
    ](name='handingProblemOperateLogs'),
    incidentId?: long(name='incidentId'),
    incidentNumber?: string(name='incidentNumber'),
    mainHandler?: long(name='mainHandler'),
    mainHandlerId?: long(name='mainHandlerId'),
    mainHandlerIsValid?: long(name='mainHandlerIsValid'),
    mainHandlerPhone?: string(name='mainHandlerPhone'),
    preliminaryReason?: string(name='preliminaryReason'),
    problemId?: long(name='problemId'),
    problemLevel?: int32(name='problemLevel'),
    problemName?: string(name='problemName'),
    problemNumber?: string(name='problemNumber'),
    problemStatus?: int32(name='problemStatus'),
    progressSummary?: string(name='progressSummary'),
    progressSummaryRichTextId?: long(name='progressSummaryRichTextId'),
    recoveryTime?: string(name='recoveryTime'),
    relatedServiceId?: long(name='relatedServiceId'),
    replayProblemOperateLogs?: [ 
      {
        actionName?: string(name='actionName'),
        actionTime?: string(name='actionTime'),
        operator?: string(name='operator'),
        userId?: long(name='userId'),
        userIsValid?: long(name='userIsValid'),
      }
    ](name='replayProblemOperateLogs'),
    replayingProblemOperateLogs?: [ 
      {
        actionName?: string(name='actionName'),
        actionTime?: string(name='actionTime'),
        operator?: string(name='operator'),
        userId?: long(name='userId'),
        userIsValid?: long(name='userIsValid'),
      }
    ](name='replayingProblemOperateLogs'),
    restoredProblemOperateLogs?: [ 
      {
        actionName?: string(name='actionName'),
        actionTime?: string(name='actionTime'),
        operator?: string(name='operator'),
        userId?: long(name='userId'),
        userIsValid?: long(name='userIsValid'),
      }
    ](name='restoredProblemOperateLogs'),
    serviceDeleteType?: int32(name='serviceDeleteType'),
    serviceName?: string(name='serviceName'),
    timelines?: [ 
      {
        keyNode?: string(name='keyNode'),
      }
    ](name='timelines'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetProblemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProblemResponseBody(name='body'),
}

async function getProblem(request: GetProblemRequest): GetProblemResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProblemWithOptions(request, headers, runtime);
}

async function getProblemWithOptions(request: GetProblemRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProblemResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetProblem',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProblemEffectionServiceRequest {
  clientToken?: string(name='clientToken'),
  effectionServiceId?: long(name='effectionServiceId'),
  problemId?: long(name='problemId'),
}

model GetProblemEffectionServiceResponseBody = {
  data?: {
    description?: string(name='description'),
    effectionServiceId?: long(name='effectionServiceId'),
    level?: long(name='level'),
    picUrl?: [ string ](name='picUrl'),
    serviceId?: long(name='serviceId'),
    serviceName?: string(name='serviceName'),
    status?: long(name='status'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetProblemEffectionServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProblemEffectionServiceResponseBody(name='body'),
}

async function getProblemEffectionService(request: GetProblemEffectionServiceRequest): GetProblemEffectionServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProblemEffectionServiceWithOptions(request, headers, runtime);
}

async function getProblemEffectionServiceWithOptions(request: GetProblemEffectionServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProblemEffectionServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.effectionServiceId)) {
    body['effectionServiceId'] = request.effectionServiceId;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetProblemEffectionService',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/process/effectionService/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProblemImprovementRequest {
  clientToken?: string(name='clientToken'),
  problemId?: string(name='problemId'),
}

model GetProblemImprovementResponseBody = {
  data?: {
    customProblemReason?: string(name='customProblemReason'),
    discoverSource?: string(name='discoverSource'),
    dutyDepartmentId?: string(name='dutyDepartmentId'),
    dutyDepartmentName?: string(name='dutyDepartmentName'),
    dutyUserId?: long(name='dutyUserId'),
    dutyUserIsValid?: long(name='dutyUserIsValid'),
    dutyUserName?: string(name='dutyUserName'),
    dutyUserPhone?: string(name='dutyUserPhone'),
    injectionMode?: string(name='injectionMode'),
    isManual?: boolean(name='isManual'),
    measureList?: [ 
      {
        checkStandard?: string(name='checkStandard'),
        checkUserId?: long(name='checkUserId'),
        checkUserIsValid?: int32(name='checkUserIsValid'),
        checkUserName?: string(name='checkUserName'),
        content?: string(name='content'),
        directorId?: long(name='directorId'),
        directorIsValid?: int32(name='directorIsValid'),
        directorName?: string(name='directorName'),
        measureId?: long(name='measureId'),
        planFinishTime?: string(name='planFinishTime'),
        stalkerId?: long(name='stalkerId'),
        stalkerIsValid?: int32(name='stalkerIsValid'),
        stalkerName?: string(name='stalkerName'),
        status?: string(name='status'),
        type?: long(name='type'),
      }
    ](name='measureList'),
    monitorSourceName?: string(name='monitorSourceName'),
    problemId?: string(name='problemId'),
    problemReason?: string(name='problemReason'),
    recentActivity?: string(name='recentActivity'),
    recoveryMode?: string(name='recoveryMode'),
    relationChanges?: string(name='relationChanges'),
    remark?: string(name='remark'),
    replayDutyUserId?: long(name='replayDutyUserId'),
    replayDutyUserIsValid?: long(name='replayDutyUserIsValid'),
    replayDutyUserName?: string(name='replayDutyUserName'),
    replayDutyUserPhone?: string(name='replayDutyUserPhone'),
    userReport?: long(name='userReport'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetProblemImprovementResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProblemImprovementResponseBody(name='body'),
}

async function getProblemImprovement(request: GetProblemImprovementRequest): GetProblemImprovementResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProblemImprovementWithOptions(request, headers, runtime);
}

async function getProblemImprovementWithOptions(request: GetProblemImprovementRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProblemImprovementResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetProblemImprovement',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/improvement/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProblemPreviewRequest {
  clientToken?: string(name='clientToken'),
  effectServiceIds?: [ long ](name='effectServiceIds'),
  incidentId?: long(name='incidentId'),
  problemId?: long(name='problemId'),
  problemLevel?: string(name='problemLevel'),
  problemNotifyType?: string(name='problemNotifyType'),
  relatedServiceId?: long(name='relatedServiceId'),
  serviceGroupIds?: [ long ](name='serviceGroupIds'),
}

model GetProblemPreviewResponseBody = {
  data?: {
    deAfterData?: string(name='deAfterData'),
    deBeforeData?: string(name='deBeforeData'),
    mail?: {
      count?: long(name='count'),
      users?: [ 
        {
          username?: string(name='username'),
        }
      ](name='users'),
    }(name='mail'),
    problem?: {
      coordinationGroups?: [ 
        {
          serviceGroupDescription?: string(name='serviceGroupDescription'),
          serviceGroupId?: long(name='serviceGroupId'),
          serviceGroupName?: string(name='serviceGroupName'),
        }
      ](name='coordinationGroups'),
      createTime?: string(name='createTime'),
      discoverTime?: string(name='discoverTime'),
      effectionServices?: [ 
        {
          serviceId?: long(name='serviceId'),
          serviceName?: string(name='serviceName'),
        }
      ](name='effectionServices'),
      isManual?: boolean(name='isManual'),
      isUpgrade?: boolean(name='isUpgrade'),
      mainHandlerId?: string(name='mainHandlerId'),
      mainHandlerName?: string(name='mainHandlerName'),
      preliminaryReason?: string(name='preliminaryReason'),
      problemId?: long(name='problemId'),
      problemLevel?: string(name='problemLevel'),
      problemName?: string(name='problemName'),
      problemStatus?: string(name='problemStatus'),
      progressSummary?: string(name='progressSummary'),
      progressSummaryRichTextId?: long(name='progressSummaryRichTextId'),
      recoveryTime?: string(name='recoveryTime'),
      relatedServiceId?: long(name='relatedServiceId'),
      serviceName?: string(name='serviceName'),
    }(name='problem'),
    sms?: {
      count?: long(name='count'),
      users?: [ 
        {
          username?: string(name='username'),
        }
      ](name='users'),
    }(name='sms'),
    upAfterData?: string(name='upAfterData'),
    upBeforeData?: string(name='upBeforeData'),
    voice?: {
      count?: long(name='count'),
      users?: [ 
        {
          username?: string(name='username'),
        }
      ](name='users'),
    }(name='voice'),
    webhook?: {
      count?: long(name='count'),
      serviceGroups?: [ 
        {
          serviceName?: string(name='serviceName'),
        }
      ](name='serviceGroups'),
    }(name='webhook'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetProblemPreviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProblemPreviewResponseBody(name='body'),
}

async function getProblemPreview(request: GetProblemPreviewRequest): GetProblemPreviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProblemPreviewWithOptions(request, headers, runtime);
}

async function getProblemPreviewWithOptions(request: GetProblemPreviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProblemPreviewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.effectServiceIds)) {
    body['effectServiceIds'] = request.effectServiceIds;
  }
  if (!Util.isUnset(request.incidentId)) {
    body['incidentId'] = request.incidentId;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.problemLevel)) {
    body['problemLevel'] = request.problemLevel;
  }
  if (!Util.isUnset(request.problemNotifyType)) {
    body['problemNotifyType'] = request.problemNotifyType;
  }
  if (!Util.isUnset(request.relatedServiceId)) {
    body['relatedServiceId'] = request.relatedServiceId;
  }
  if (!Util.isUnset(request.serviceGroupIds)) {
    body['serviceGroupIds'] = request.serviceGroupIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetProblemPreview',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/preview`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetResourceStatisticsRequest {
  clientToken?: string(name='clientToken'),
}

model GetResourceStatisticsResponseBody = {
  data?: {
    alertCount?: int32(name='alertCount'),
    incidentCount?: int32(name='incidentCount'),
    integrationCount?: int32(name='integrationCount'),
    problemCount?: int32(name='problemCount'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetResourceStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceStatisticsResponseBody(name='body'),
}

async function getResourceStatistics(request: GetResourceStatisticsRequest): GetResourceStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getResourceStatisticsWithOptions(request, headers, runtime);
}

async function getResourceStatisticsWithOptions(request: GetResourceStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetResourceStatisticsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceStatistics',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/config/resource/count`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRichTextRequest {
  instanceId?: long(name='instanceId'),
  instanceType?: string(name='instanceType'),
  richTextId?: long(name='richTextId'),
}

model GetRichTextResponseBody = {
  data?: {
    instanceId?: long(name='instanceId'),
    instanceType?: long(name='instanceType'),
    richText?: string(name='richText'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetRichTextResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRichTextResponseBody(name='body'),
}

async function getRichText(request: GetRichTextRequest): GetRichTextResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRichTextWithOptions(request, headers, runtime);
}

async function getRichTextWithOptions(request: GetRichTextRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRichTextResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['instanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.richTextId)) {
    body['richTextId'] = request.richTextId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetRichText',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/rich/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRouteRuleRequest {
  clientToken?: string(name='clientToken'),
  routeRuleId?: long(name='routeRuleId'),
}

model GetRouteRuleResponseBody = {
  data?: {
    assignObjectId?: long(name='assignObjectId'),
    assignObjectName?: string(name='assignObjectName'),
    assignObjectType?: string(name='assignObjectType'),
    childRuleRelation?: string(name='childRuleRelation'),
    createTime?: string(name='createTime'),
    effection?: string(name='effection'),
    enableStatus?: string(name='enableStatus'),
    eventRouteChildRules?: [ 
      {
        childConditionRelation?: long(name='childConditionRelation'),
        childRouteRuleId?: long(name='childRouteRuleId'),
        conditions?: [ 
          {
            key?: string(name='key'),
            operationSymbol?: string(name='operationSymbol'),
            value?: string(name='value'),
          }
        ](name='conditions'),
        isValidChildRule?: boolean(name='isValidChildRule'),
        monitorIntegrationConfigId?: long(name='monitorIntegrationConfigId'),
        monitorSourceId?: long(name='monitorSourceId'),
        monitorSourceName?: string(name='monitorSourceName'),
        parentRuleId?: long(name='parentRuleId'),
      }
    ](name='eventRouteChildRules'),
    incidentLevel?: string(name='incidentLevel'),
    matchCount?: long(name='matchCount'),
    notifyChannelNames?: [ string ](name='notifyChannelNames'),
    notifyChannels?: [ string ](name='notifyChannels'),
    relServiceDeleteType?: int32(name='relServiceDeleteType'),
    relatedServiceId?: long(name='relatedServiceId'),
    relatedServiceName?: string(name='relatedServiceName'),
    routeRuleId?: long(name='routeRuleId'),
    routeType?: string(name='routeType'),
    ruleName?: string(name='ruleName'),
    timeWindow?: int32(name='timeWindow'),
    updateTime?: string(name='updateTime'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetRouteRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRouteRuleResponseBody(name='body'),
}

async function getRouteRule(request: GetRouteRuleRequest): GetRouteRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRouteRuleWithOptions(request, headers, runtime);
}

async function getRouteRuleWithOptions(request: GetRouteRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRouteRuleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.routeRuleId)) {
    body['routeRuleId'] = request.routeRuleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetRouteRule',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/routeRule/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetServiceRequest {
  clientToken?: string(name='clientToken'),
  serviceId?: long(name='serviceId'),
}

model GetServiceResponseBody = {
  data?: {
    serviceDescription?: string(name='serviceDescription'),
    serviceId?: long(name='serviceId'),
    serviceName?: string(name='serviceName'),
    updateTime?: string(name='updateTime'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceResponseBody(name='body'),
}

async function getService(request: GetServiceRequest): GetServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceWithOptions(request, headers, runtime);
}

async function getServiceWithOptions(request: GetServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.serviceId)) {
    body['serviceId'] = request.serviceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetService',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetServiceGroupRequest {
  clientToken?: string(name='clientToken'),
  serviceGroupId?: long(name='serviceGroupId'),
}

model GetServiceGroupResponseBody = {
  data?: {
    createTime?: string(name='createTime'),
    enableWebhook?: string(name='enableWebhook'),
    serviceGroupDescription?: string(name='serviceGroupDescription'),
    serviceGroupId?: long(name='serviceGroupId'),
    serviceGroupName?: string(name='serviceGroupName'),
    updateTime?: string(name='updateTime'),
    users?: [ 
      {
        phone?: string(name='phone'),
        serviceGroupId?: long(name='serviceGroupId'),
        userId?: long(name='userId'),
        userName?: string(name='userName'),
      }
    ](name='users'),
    webhookLink?: string(name='webhookLink'),
    webhookType?: string(name='webhookType'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceGroupResponseBody(name='body'),
}

async function getServiceGroup(request: GetServiceGroupRequest): GetServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceGroupWithOptions(request, headers, runtime);
}

async function getServiceGroupWithOptions(request: GetServiceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.serviceGroupId)) {
    body['serviceGroupId'] = request.serviceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceGroup',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetServiceGroupPersonSchedulingRequest {
  clientToken?: string(name='clientToken'),
  endTime?: string(name='endTime'),
  serviceGroupId?: long(name='serviceGroupId'),
  startTime?: string(name='startTime'),
  userId?: long(name='userId'),
}

model GetServiceGroupPersonSchedulingResponseBody = {
  data?: map[string]any(name='data'),
  requestId?: string(name='requestId'),
}

model GetServiceGroupPersonSchedulingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceGroupPersonSchedulingResponseBody(name='body'),
}

async function getServiceGroupPersonScheduling(request: GetServiceGroupPersonSchedulingRequest): GetServiceGroupPersonSchedulingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceGroupPersonSchedulingWithOptions(request, headers, runtime);
}

async function getServiceGroupPersonSchedulingWithOptions(request: GetServiceGroupPersonSchedulingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceGroupPersonSchedulingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.endTime)) {
    body['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.serviceGroupId)) {
    body['serviceGroupId'] = request.serviceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    body['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.userId)) {
    body['userId'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceGroupPersonScheduling',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/scheduling/user/getScheduling`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetServiceGroupSchedulingRequest {
  clientToken?: string(name='clientToken'),
  serviceGroupId?: long(name='serviceGroupId'),
}

model GetServiceGroupSchedulingResponseBody = {
  data?: {
    fastScheduling?: {
      dutyPlan?: string(name='dutyPlan'),
      id?: long(name='id'),
      schedulingUsers?: [ 
        {
          schedulingOrder?: int32(name='schedulingOrder'),
          schedulingUserId?: long(name='schedulingUserId'),
          schedulingUserName?: string(name='schedulingUserName'),
        }
      ](name='schedulingUsers'),
      singleDuration?: int32(name='singleDuration'),
      singleDurationUnit?: string(name='singleDurationUnit'),
    }(name='fastScheduling'),
    fineScheduling?: {
      id?: long(name='id'),
      period?: int32(name='period'),
      periodUnit?: string(name='periodUnit'),
      schedulingFineShifts?: [ 
        {
          cycleOrder?: long(name='cycleOrder'),
          schedulingEndTime?: string(name='schedulingEndTime'),
          schedulingOrder?: int32(name='schedulingOrder'),
          schedulingStartTime?: string(name='schedulingStartTime'),
          schedulingUserId?: long(name='schedulingUserId'),
          schedulingUserName?: string(name='schedulingUserName'),
          shiftName?: string(name='shiftName'),
          skipOneDay?: boolean(name='skipOneDay'),
        }
      ](name='schedulingFineShifts'),
      schedulingTemplateFineShifts?: [ 
        {
          schedulingEndTime?: string(name='schedulingEndTime'),
          schedulingOrder?: long(name='schedulingOrder'),
          schedulingStartTime?: string(name='schedulingStartTime'),
          schedulingUserId?: string(name='schedulingUserId'),
          schedulingUserName?: string(name='schedulingUserName'),
          shiftName?: string(name='shiftName'),
          skipOneDay?: boolean(name='skipOneDay'),
        }
      ](name='schedulingTemplateFineShifts'),
      shiftType?: string(name='shiftType'),
    }(name='fineScheduling'),
    schedulingWay?: string(name='schedulingWay'),
    serviceGroupId?: long(name='serviceGroupId'),
    users?: [ 
      {
        userId?: long(name='userId'),
        userName?: string(name='userName'),
      }
    ](name='users'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetServiceGroupSchedulingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceGroupSchedulingResponseBody(name='body'),
}

async function getServiceGroupScheduling(request: GetServiceGroupSchedulingRequest): GetServiceGroupSchedulingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceGroupSchedulingWithOptions(request, headers, runtime);
}

async function getServiceGroupSchedulingWithOptions(request: GetServiceGroupSchedulingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceGroupSchedulingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.serviceGroupId)) {
    body['serviceGroupId'] = request.serviceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceGroupScheduling',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/scheduling/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetServiceGroupSchedulingPreviewRequest {
  clientToken?: string(name='clientToken'),
  endTime?: string(name='endTime'),
  fastScheduling?: {
    dutyPlan?: string(name='dutyPlan'),
    schedulingUsers?: [ 
      {
        schedulingOrder?: int32(name='schedulingOrder'),
        schedulingUserId?: long(name='schedulingUserId'),
      }
    ](name='schedulingUsers'),
    singleDuration?: int32(name='singleDuration'),
    singleDurationUnit?: string(name='singleDurationUnit'),
  }(name='fastScheduling'),
  fineScheduling?: {
    period?: int32(name='period'),
    periodUnit?: string(name='periodUnit'),
    schedulingFineShifts?: [ 
      {
        schedulingEndTime?: string(name='schedulingEndTime'),
        schedulingOrder?: long(name='schedulingOrder'),
        schedulingStartTime?: string(name='schedulingStartTime'),
        shiftName?: string(name='shiftName'),
      }
    ](name='schedulingFineShifts'),
    shiftType?: string(name='shiftType'),
  }(name='fineScheduling'),
  schedulingWay?: string(name='schedulingWay'),
  serviceGroupId?: long(name='serviceGroupId'),
  startTime?: string(name='startTime'),
}

model GetServiceGroupSchedulingPreviewResponseBody = {
  data?: map[string]any(name='data'),
  requestId?: string(name='requestId'),
}

model GetServiceGroupSchedulingPreviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceGroupSchedulingPreviewResponseBody(name='body'),
}

async function getServiceGroupSchedulingPreview(request: GetServiceGroupSchedulingPreviewRequest): GetServiceGroupSchedulingPreviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceGroupSchedulingPreviewWithOptions(request, headers, runtime);
}

async function getServiceGroupSchedulingPreviewWithOptions(request: GetServiceGroupSchedulingPreviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceGroupSchedulingPreviewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.endTime)) {
    body['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.fastScheduling)) {
    body['fastScheduling'] = request.fastScheduling;
  }
  if (!Util.isUnset(request.fineScheduling)) {
    body['fineScheduling'] = request.fineScheduling;
  }
  if (!Util.isUnset(request.schedulingWay)) {
    body['schedulingWay'] = request.schedulingWay;
  }
  if (!Util.isUnset(request.serviceGroupId)) {
    body['serviceGroupId'] = request.serviceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    body['startTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceGroupSchedulingPreview',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/scheduling/preview`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetServiceGroupSpecialPersonSchedulingRequest {
  clientToken?: string(name='clientToken'),
  serviceGroupId?: long(name='serviceGroupId'),
  userId?: long(name='userId'),
}

model GetServiceGroupSpecialPersonSchedulingResponseBody = {
  data?: [ 
    {
      schedulingDate?: string(name='schedulingDate'),
      schedulingEndTime?: string(name='schedulingEndTime'),
      schedulingStartTime?: string(name='schedulingStartTime'),
      schedulingUserId?: long(name='schedulingUserId'),
      serviceGroupId?: long(name='serviceGroupId'),
      serviceGroupName?: string(name='serviceGroupName'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
}

model GetServiceGroupSpecialPersonSchedulingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceGroupSpecialPersonSchedulingResponseBody(name='body'),
}

async function getServiceGroupSpecialPersonScheduling(request: GetServiceGroupSpecialPersonSchedulingRequest): GetServiceGroupSpecialPersonSchedulingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceGroupSpecialPersonSchedulingWithOptions(request, headers, runtime);
}

async function getServiceGroupSpecialPersonSchedulingWithOptions(request: GetServiceGroupSpecialPersonSchedulingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceGroupSpecialPersonSchedulingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.serviceGroupId)) {
    body['serviceGroupId'] = request.serviceGroupId;
  }
  if (!Util.isUnset(request.userId)) {
    body['userId'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceGroupSpecialPersonScheduling',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/scheduling/getUserScheduling`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetSimilarIncidentStatisticsRequest {
  clientToken?: string(name='clientToken'),
  createTime?: string(name='createTime'),
  events?: [ string ](name='events'),
  incidentId?: long(name='incidentId'),
  incidentTitle?: string(name='incidentTitle'),
  relatedServiceId?: long(name='relatedServiceId'),
}

model GetSimilarIncidentStatisticsResponseBody = {
  data?: {
    countInSevenDays?: long(name='countInSevenDays'),
    countInSixMonths?: long(name='countInSixMonths'),
    dailySimilarIncidents?: [ 
      {
        commitment?: long(name='commitment'),
        date?: string(name='date'),
        day?: long(name='day'),
        month?: long(name='month'),
        similarIncidents?: [ 
          {
            assignUserId?: long(name='assignUserId'),
            assignUserName?: string(name='assignUserName'),
            createTime?: string(name='createTime'),
            durationTime?: long(name='durationTime'),
            finishReason?: long(name='finishReason'),
            finishReasonDescription?: string(name='finishReasonDescription'),
            finishSolutionDescription?: string(name='finishSolutionDescription'),
            incidentFinishSolution?: long(name='incidentFinishSolution'),
            incidentId?: long(name='incidentId'),
            incidentNumber?: string(name='incidentNumber'),
            incidentTitle?: string(name='incidentTitle'),
            relatedRouteRuleId?: long(name='relatedRouteRuleId'),
            relatedRouteRuleName?: string(name='relatedRouteRuleName'),
            similarScore?: string(name='similarScore'),
          }
        ](name='similarIncidents'),
        week?: string(name='week'),
      }
    ](name='dailySimilarIncidents'),
    requestId?: string(name='requestId'),
    topFiveIncidents?: [ 
      {
        assignUserId?: string(name='assignUserId'),
        assignUserName?: string(name='assignUserName'),
        createTime?: string(name='createTime'),
        durationTime?: long(name='durationTime'),
        finishReason?: long(name='finishReason'),
        finishReasonDescription?: string(name='finishReasonDescription'),
        finishSolutionDescription?: string(name='finishSolutionDescription'),
        incidentFinishSolution?: long(name='incidentFinishSolution'),
        incidentId?: long(name='incidentId'),
        incidentNumber?: string(name='incidentNumber'),
        incidentTitle?: string(name='incidentTitle'),
        relatedRouteRuleId?: long(name='relatedRouteRuleId'),
        relatedRouteRuleName?: string(name='relatedRouteRuleName'),
        similarScore?: string(name='similarScore'),
      }
    ](name='topFiveIncidents'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetSimilarIncidentStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSimilarIncidentStatisticsResponseBody(name='body'),
}

async function getSimilarIncidentStatistics(request: GetSimilarIncidentStatisticsRequest): GetSimilarIncidentStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSimilarIncidentStatisticsWithOptions(request, headers, runtime);
}

async function getSimilarIncidentStatisticsWithOptions(request: GetSimilarIncidentStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetSimilarIncidentStatisticsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.createTime)) {
    body['createTime'] = request.createTime;
  }
  if (!Util.isUnset(request.events)) {
    body['events'] = request.events;
  }
  if (!Util.isUnset(request.incidentId)) {
    body['incidentId'] = request.incidentId;
  }
  if (!Util.isUnset(request.incidentTitle)) {
    body['incidentTitle'] = request.incidentTitle;
  }
  if (!Util.isUnset(request.relatedServiceId)) {
    body['relatedServiceId'] = request.relatedServiceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetSimilarIncidentStatistics',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/incident/similarIncident/statistics`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetSubscriptionRequest {
  notFilterScopeObjectDeleted?: boolean(name='notFilterScopeObjectDeleted'),
  subscriptionId?: long(name='subscriptionId'),
}

model GetSubscriptionResponseBody = {
  data?: {
    endTime?: string(name='endTime'),
    expiredType?: string(name='expiredType'),
    notifyObjectList?: [ 
      {
        id?: long(name='id'),
        name?: string(name='name'),
        notifyObjectId?: long(name='notifyObjectId'),
        notifyObjectType?: long(name='notifyObjectType'),
      }
    ](name='notifyObjectList'),
    notifyObjectType?: string(name='notifyObjectType'),
    notifyStrategyList?: [ 
      {
        instanceType?: long(name='instanceType'),
        strategies?: [ 
          {
            channels?: string(name='channels'),
            conditions?: [ 
              {
                action?: string(name='action'),
                effection?: string(name='effection'),
                level?: string(name='level'),
                problemNotifyType?: string(name='problemNotifyType'),
              }
            ](name='conditions'),
            id?: long(name='id'),
            periodChannel?: {
              nonWorkday?: string(name='nonWorkday'),
              workday?: string(name='workday'),
            }(name='periodChannel'),
          }
        ](name='strategies'),
      }
    ](name='notifyStrategyList'),
    period?: string(name='period'),
    scope?: string(name='scope'),
    scopeObjectList?: [ 
      {
        id?: long(name='id'),
        isValid?: long(name='isValid'),
        scope?: string(name='scope'),
        scopeObject?: string(name='scopeObject'),
        scopeObjectId?: long(name='scopeObjectId'),
      }
    ](name='scopeObjectList'),
    startTime?: string(name='startTime'),
    status?: string(name='status'),
    subscriptionId?: long(name='subscriptionId'),
    subscriptionTitle?: string(name='subscriptionTitle'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetSubscriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSubscriptionResponseBody(name='body'),
}

async function getSubscription(request: GetSubscriptionRequest): GetSubscriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSubscriptionWithOptions(request, headers, runtime);
}

async function getSubscriptionWithOptions(request: GetSubscriptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetSubscriptionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.notFilterScopeObjectDeleted)) {
    body['notFilterScopeObjectDeleted'] = request.notFilterScopeObjectDeleted;
  }
  if (!Util.isUnset(request.subscriptionId)) {
    body['subscriptionId'] = request.subscriptionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetSubscription',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/notify/subscription/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTenantApplicationRequest {
  clientToken?: string(name='clientToken'),
}

model GetTenantApplicationResponseBody = {
  data?: {
    bizId?: string(name='bizId'),
    channel?: string(name='channel'),
    corporationId?: string(name='corporationId'),
    progress?: string(name='progress'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetTenantApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTenantApplicationResponseBody(name='body'),
}

async function getTenantApplication(request: GetTenantApplicationRequest): GetTenantApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTenantApplicationWithOptions(request, headers, runtime);
}

async function getTenantApplicationWithOptions(request: GetTenantApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTenantApplicationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTenantApplication',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/mobileApp/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTenantStatusRequest {
  tenantRamId?: long(name='tenantRamId'),
}

model GetTenantStatusResponseBody = {
  data?: {
    tenantStatus?: int32(name='tenantStatus'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetTenantStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTenantStatusResponseBody(name='body'),
}

async function getTenantStatus(request: GetTenantStatusRequest): GetTenantStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTenantStatusWithOptions(request, headers, runtime);
}

async function getTenantStatusWithOptions(request: GetTenantStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTenantStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.tenantRamId)) {
    body['tenantRamId'] = request.tenantRamId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTenantStatus',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/tenant/getTenantStatus`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetUserRequest {
  clientToken?: string(name='clientToken'),
  userId?: long(name='userId'),
}

model GetUserResponseBody = {
  data?: {
    accountType?: string(name='accountType'),
    createTime?: string(name='createTime'),
    email?: string(name='email'),
    isEditableUser?: boolean(name='isEditableUser'),
    isRelated?: string(name='isRelated'),
    phone?: string(name='phone'),
    ramId?: string(name='ramId'),
    serviceGroups?: [ 
      {
        name?: string(name='name'),
        serviceGroupId?: long(name='serviceGroupId'),
      }
    ](name='serviceGroups'),
    userId?: long(name='userId'),
    username?: string(name='username'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model GetUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserResponseBody(name='body'),
}

async function getUser(request: GetUserRequest): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUserWithOptions(request, headers, runtime);
}

async function getUserWithOptions(request: GetUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.userId)) {
    body['userId'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetUser',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/user/getUser`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetUserGuideStatusRequest {
  clientToken?: string(name='clientToken'),
}

model GetUserGuideStatusResponseBody = {
  data?: map[string]any(name='data'),
  requestId?: string(name='requestId'),
}

model GetUserGuideStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserGuideStatusResponseBody(name='body'),
}

async function getUserGuideStatus(request: GetUserGuideStatusRequest): GetUserGuideStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUserGuideStatusWithOptions(request, headers, runtime);
}

async function getUserGuideStatusWithOptions(request: GetUserGuideStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetUserGuideStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetUserGuideStatus',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/user/guide/status`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAlertsRequest {
  alertLevel?: string(name='alertLevel'),
  alertName?: string(name='alertName'),
  alertSourceName?: string(name='alertSourceName'),
  endTime?: string(name='endTime'),
  monitorSourceId?: string(name='monitorSourceId'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  relatedServiceId?: long(name='relatedServiceId'),
  ruleName?: string(name='ruleName'),
  startTime?: string(name='startTime'),
}

model ListAlertsResponseBody = {
  data?: [ 
    {
      alertId?: long(name='alertId'),
      alertLevel?: string(name='alertLevel'),
      alertNumber?: string(name='alertNumber'),
      alertSourceName?: string(name='alertSourceName'),
      createTime?: string(name='createTime'),
      firstEventTime?: string(name='firstEventTime'),
      monitorSourceName?: string(name='monitorSourceName'),
      relServiceDeleteType?: int32(name='relServiceDeleteType'),
      relatedServiceName?: string(name='relatedServiceName'),
      routeRuleDeleteType?: int32(name='routeRuleDeleteType'),
      routeRuleId?: long(name='routeRuleId'),
      routeRuleName?: string(name='routeRuleName'),
      sourceEventCount?: long(name='sourceEventCount'),
      title?: string(name='title'),
    }
  ](name='data'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: long(name='totalCount'),
}

model ListAlertsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlertsResponseBody(name='body'),
}

async function listAlerts(request: ListAlertsRequest): ListAlertsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAlertsWithOptions(request, headers, runtime);
}

async function listAlertsWithOptions(request: ListAlertsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAlertsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alertLevel)) {
    body['alertLevel'] = request.alertLevel;
  }
  if (!Util.isUnset(request.alertName)) {
    body['alertName'] = request.alertName;
  }
  if (!Util.isUnset(request.alertSourceName)) {
    body['alertSourceName'] = request.alertSourceName;
  }
  if (!Util.isUnset(request.endTime)) {
    body['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.monitorSourceId)) {
    body['monitorSourceId'] = request.monitorSourceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.relatedServiceId)) {
    body['relatedServiceId'] = request.relatedServiceId;
  }
  if (!Util.isUnset(request.ruleName)) {
    body['ruleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.startTime)) {
    body['startTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListAlerts',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/alerts/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListByMonitorSourceIdRequest {
  monitorSourceId?: string(name='monitorSourceId'),
}

model ListByMonitorSourceIdResponseBody = {
  data?: [ 
    {
      id?: long(name='id'),
      ruleName?: string(name='ruleName'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
}

model ListByMonitorSourceIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListByMonitorSourceIdResponseBody(name='body'),
}

async function listByMonitorSourceId(request: ListByMonitorSourceIdRequest): ListByMonitorSourceIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listByMonitorSourceIdWithOptions(request, headers, runtime);
}

async function listByMonitorSourceIdWithOptions(request: ListByMonitorSourceIdRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListByMonitorSourceIdResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.monitorSourceId)) {
    body['monitorSourceId'] = request.monitorSourceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListByMonitorSourceId',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/routeRule/listByMonitorSourceId`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListChartDataForServiceGroupRequest {
  clientToken?: string(name='clientToken'),
  endTime?: string(name='endTime'),
  startTime?: string(name='startTime'),
}

model ListChartDataForServiceGroupResponseBody = {
  data?: [ 
    {
      effectionLevel?: map[string]any(name='effectionLevel'),
      escalationIncidentCount?: long(name='escalationIncidentCount'),
      incidentCount?: long(name='incidentCount'),
      meanTimeToAcknowledge?: long(name='meanTimeToAcknowledge'),
      meanTimeToRepair?: long(name='meanTimeToRepair'),
      time?: string(name='time'),
      totalMeanTimeToAcknowledge?: long(name='totalMeanTimeToAcknowledge'),
      totalMeanTimeToRepair?: long(name='totalMeanTimeToRepair'),
      unAcknowledgedEscalationIncidentCount?: long(name='unAcknowledgedEscalationIncidentCount'),
      unFinishEscalationIncidentCount?: long(name='unFinishEscalationIncidentCount'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
}

model ListChartDataForServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListChartDataForServiceGroupResponseBody(name='body'),
}

async function listChartDataForServiceGroup(request: ListChartDataForServiceGroupRequest): ListChartDataForServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listChartDataForServiceGroupWithOptions(request, headers, runtime);
}

async function listChartDataForServiceGroupWithOptions(request: ListChartDataForServiceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListChartDataForServiceGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.endTime)) {
    body['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    body['startTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListChartDataForServiceGroup',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/statistics/chartDataForServiceGroup/`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListChartDataForUserRequest {
  clientToken?: string(name='clientToken'),
  endTime?: string(name='endTime'),
  startTime?: string(name='startTime'),
}

model ListChartDataForUserResponseBody = {
  data?: [ 
    {
      effectionLevel?: map[string]any(name='effectionLevel'),
      escalationIncidentCount?: long(name='escalationIncidentCount'),
      incidentCount?: long(name='incidentCount'),
      meanTimeToAcknowledge?: long(name='meanTimeToAcknowledge'),
      meanTimeToRepair?: long(name='meanTimeToRepair'),
      time?: string(name='time'),
      totalMeanTimeToAcknowledge?: long(name='totalMeanTimeToAcknowledge'),
      totalMeanTimeToRepair?: long(name='totalMeanTimeToRepair'),
      unAcknowledgedEscalationIncidentCount?: long(name='unAcknowledgedEscalationIncidentCount'),
      unFinishEscalationIncidentCount?: long(name='unFinishEscalationIncidentCount'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
}

model ListChartDataForUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListChartDataForUserResponseBody(name='body'),
}

async function listChartDataForUser(request: ListChartDataForUserRequest): ListChartDataForUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listChartDataForUserWithOptions(request, headers, runtime);
}

async function listChartDataForUserWithOptions(request: ListChartDataForUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListChartDataForUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.endTime)) {
    body['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    body['startTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListChartDataForUser',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/statistics/chartDataForUser/`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListConfigsRequest {
  clientToken?: string(name='clientToken'),
}

model ListConfigsResponseBody = {
  data?: map[string][ DataValue   ](name='data'),
  requestId?: string(name='requestId'),
}

model ListConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConfigsResponseBody(name='body'),
}

async function listConfigs(request: ListConfigsRequest): ListConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConfigsWithOptions(request, headers, runtime);
}

async function listConfigsWithOptions(request: ListConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListConfigsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListConfigs',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/config/all`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDataReportForServiceGroupRequest {
  endTime?: string(name='endTime'),
  serviceGroupName?: string(name='serviceGroupName'),
  startTime?: string(name='startTime'),
}

model ListDataReportForServiceGroupResponseBody = {
  data?: [ 
    {
      escalationIncidentCount?: long(name='escalationIncidentCount'),
      finishIncidentCount?: long(name='finishIncidentCount'),
      finishProportion?: string(name='finishProportion'),
      incidentCount?: long(name='incidentCount'),
      meanTimeToAcknowledge?: long(name='meanTimeToAcknowledge'),
      meanTimeToRepair?: long(name='meanTimeToRepair'),
      serviceGroupId?: long(name='serviceGroupId'),
      serviceGroupName?: string(name='serviceGroupName'),
      unAcknowledgedEscalationIncidentCount?: long(name='unAcknowledgedEscalationIncidentCount'),
      unFinishEscalationIncidentCount?: long(name='unFinishEscalationIncidentCount'),
    }
  ](name='data'),
  pageNumber?: long(name='pageNumber'),
  pageSIze?: long(name='pageSIze'),
  requestId?: string(name='requestId'),
  totalCount?: long(name='totalCount'),
}

model ListDataReportForServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDataReportForServiceGroupResponseBody(name='body'),
}

async function listDataReportForServiceGroup(request: ListDataReportForServiceGroupRequest): ListDataReportForServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataReportForServiceGroupWithOptions(request, headers, runtime);
}

async function listDataReportForServiceGroupWithOptions(request: ListDataReportForServiceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataReportForServiceGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    body['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.serviceGroupName)) {
    body['serviceGroupName'] = request.serviceGroupName;
  }
  if (!Util.isUnset(request.startTime)) {
    body['startTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDataReportForServiceGroup',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/statistics/listDataReportForServiceGroup`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDataReportForUserRequest {
  endTime?: string(name='endTime'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  startTime?: string(name='startTime'),
}

model ListDataReportForUserResponseBody = {
  data?: [ 
    {
      distributionIncidentCount?: long(name='distributionIncidentCount'),
      escalationIncidentCount?: long(name='escalationIncidentCount'),
      finishIncidentNumber?: long(name='finishIncidentNumber'),
      finishProportion?: string(name='finishProportion'),
      meanTimeToAcknowledge?: string(name='meanTimeToAcknowledge'),
      meanTimeToRepair?: string(name='meanTimeToRepair'),
      unAcknowledgedEscalationIncidentCount?: long(name='unAcknowledgedEscalationIncidentCount'),
      unDistributionIncidentCount?: long(name='unDistributionIncidentCount'),
      unFinishEscalationIncidentCount?: long(name='unFinishEscalationIncidentCount'),
      userId?: long(name='userId'),
      userName?: string(name='userName'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
  totalCount?: long(name='totalCount'),
}

model ListDataReportForUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDataReportForUserResponseBody(name='body'),
}

async function listDataReportForUser(request: ListDataReportForUserRequest): ListDataReportForUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataReportForUserWithOptions(request, headers, runtime);
}

async function listDataReportForUserWithOptions(request: ListDataReportForUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataReportForUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    body['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    body['startTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDataReportForUser',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/statistics/listDataReportForUser`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDictionariesRequest {
  clientToken?: string(name='clientToken'),
}

model ListDictionariesResponseBody = {
  data?: map[string][ DataValue   ](name='data'),
  requestId?: string(name='requestId'),
}

model ListDictionariesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDictionariesResponseBody(name='body'),
}

async function listDictionaries(request: ListDictionariesRequest): ListDictionariesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDictionariesWithOptions(request, headers, runtime);
}

async function listDictionariesWithOptions(request: ListDictionariesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDictionariesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDictionaries',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/dict/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEscalationPlanServicesRequest {
  clientToken?: string(name='clientToken'),
}

model ListEscalationPlanServicesResponseBody = {
  data?: [ 
    {
      scope?: string(name='scope'),
      scopeObjectId?: long(name='scopeObjectId'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
}

model ListEscalationPlanServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEscalationPlanServicesResponseBody(name='body'),
}

async function listEscalationPlanServices(request: ListEscalationPlanServicesRequest): ListEscalationPlanServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEscalationPlanServicesWithOptions(request, headers, runtime);
}

async function listEscalationPlanServicesWithOptions(request: ListEscalationPlanServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEscalationPlanServicesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListEscalationPlanServices',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/escalationPlan/services`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEscalationPlansRequest {
  clientToken?: string(name='clientToken'),
  escalationPlanName?: string(name='escalationPlanName'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  serviceName?: string(name='serviceName'),
}

model ListEscalationPlansResponseBody = {
  data?: [ 
    {
      escalationPlanId?: long(name='escalationPlanId'),
      escalationPlanName?: string(name='escalationPlanName'),
      escalationPlanScopeObjects?: [ 
        {
          scope?: string(name='scope'),
          scopeObjectDeletedType?: int32(name='scopeObjectDeletedType'),
          scopeObjectId?: long(name='scopeObjectId'),
          scopeObjectName?: string(name='scopeObjectName'),
        }
      ](name='escalationPlanScopeObjects'),
      modifyTime?: string(name='modifyTime'),
      status?: string(name='status'),
    }
  ](name='data'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: long(name='totalCount'),
}

model ListEscalationPlansResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEscalationPlansResponseBody(name='body'),
}

async function listEscalationPlans(request: ListEscalationPlansRequest): ListEscalationPlansResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEscalationPlansWithOptions(request, headers, runtime);
}

async function listEscalationPlansWithOptions(request: ListEscalationPlansRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEscalationPlansResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.escalationPlanName)) {
    body['escalationPlanName'] = request.escalationPlanName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serviceName)) {
    body['serviceName'] = request.serviceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListEscalationPlans',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/escalationPlan/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEscalationPlansByNoticeObjectRequest {
  noticeObjectId?: long(name='noticeObjectId'),
  noticeObjectType?: long(name='noticeObjectType'),
}

model ListEscalationPlansByNoticeObjectResponseBody = {
  data?: [ 
    {
      escalationPlanId?: long(name='escalationPlanId'),
      escalationPlanName?: string(name='escalationPlanName'),
      escalationPlanScopeObjects?: [ 
        {
          scope?: string(name='scope'),
          scopeObjectDeletedType?: int32(name='scopeObjectDeletedType'),
          scopeObjectId?: long(name='scopeObjectId'),
          scopeObjectName?: string(name='scopeObjectName'),
        }
      ](name='escalationPlanScopeObjects'),
      modifyTime?: string(name='modifyTime'),
      status?: string(name='status'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
}

model ListEscalationPlansByNoticeObjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEscalationPlansByNoticeObjectResponseBody(name='body'),
}

async function listEscalationPlansByNoticeObject(request: ListEscalationPlansByNoticeObjectRequest): ListEscalationPlansByNoticeObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEscalationPlansByNoticeObjectWithOptions(request, headers, runtime);
}

async function listEscalationPlansByNoticeObjectWithOptions(request: ListEscalationPlansByNoticeObjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEscalationPlansByNoticeObjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.noticeObjectId)) {
    body['noticeObjectId'] = request.noticeObjectId;
  }
  if (!Util.isUnset(request.noticeObjectType)) {
    body['noticeObjectType'] = request.noticeObjectType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListEscalationPlansByNoticeObject',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/escalationPlan/listByNoticeObject`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListIncidentDetailEscalationPlansRequest {
  clientToken?: string(name='clientToken'),
  incidentId?: long(name='incidentId'),
}

model ListIncidentDetailEscalationPlansResponseBody = {
  data?: {
    escalationPlanId?: long(name='escalationPlanId'),
    escalationPlanName?: string(name='escalationPlanName'),
    nuAcknowledgeEscalationPlan?: [ 
      {
        escalationPlanType?: string(name='escalationPlanType'),
        noticeChannels?: [ string ](name='noticeChannels'),
        noticeObjectList?: [ 
          {
            noticeObjectId?: long(name='noticeObjectId'),
            noticeObjectName?: string(name='noticeObjectName'),
            noticeObjectPhone?: string(name='noticeObjectPhone'),
          }
        ](name='noticeObjectList'),
        noticeTime?: long(name='noticeTime'),
        serviceGroupList?: [ 
          {
            id?: long(name='id'),
            name?: string(name='name'),
          }
        ](name='serviceGroupList'),
        startTime?: long(name='startTime'),
        status?: string(name='status'),
      }
    ](name='nuAcknowledgeEscalationPlan'),
    unFinishEscalationPlan?: [ 
      {
        escalationPlanType?: string(name='escalationPlanType'),
        noticeChannels?: [ string ](name='noticeChannels'),
        noticeObjectList?: [ 
          {
            noticeObjectId?: long(name='noticeObjectId'),
            noticeObjectName?: string(name='noticeObjectName'),
            noticeObjectPhone?: string(name='noticeObjectPhone'),
          }
        ](name='noticeObjectList'),
        noticeTime?: int32(name='noticeTime'),
        serviceGroupList?: [ 
          {
            id?: long(name='id'),
            name?: string(name='name'),
          }
        ](name='serviceGroupList'),
        startTime?: long(name='startTime'),
        status?: string(name='status'),
      }
    ](name='unFinishEscalationPlan'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model ListIncidentDetailEscalationPlansResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIncidentDetailEscalationPlansResponseBody(name='body'),
}

async function listIncidentDetailEscalationPlans(request: ListIncidentDetailEscalationPlansRequest): ListIncidentDetailEscalationPlansResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIncidentDetailEscalationPlansWithOptions(request, headers, runtime);
}

async function listIncidentDetailEscalationPlansWithOptions(request: ListIncidentDetailEscalationPlansRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIncidentDetailEscalationPlansResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.incidentId)) {
    body['incidentId'] = request.incidentId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListIncidentDetailEscalationPlans',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/incident/detail/escalation`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListIncidentDetailTimelinesRequest {
  clientToken?: string(name='clientToken'),
  idSort?: string(name='idSort'),
  incidentId?: long(name='incidentId'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
}

model ListIncidentDetailTimelinesResponseBody = {
  data?: [ 
    {
      action?: string(name='action'),
      createTime?: string(name='createTime'),
      description?: string(name='description'),
      incidentId?: long(name='incidentId'),
      relRouteRuleDeleteType?: int32(name='relRouteRuleDeleteType'),
      relatedServiceName?: string(name='relatedServiceName'),
      remark?: string(name='remark'),
      snapshotData?: string(name='snapshotData'),
      title?: string(name='title'),
    }
  ](name='data'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListIncidentDetailTimelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIncidentDetailTimelinesResponseBody(name='body'),
}

async function listIncidentDetailTimelines(request: ListIncidentDetailTimelinesRequest): ListIncidentDetailTimelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIncidentDetailTimelinesWithOptions(request, headers, runtime);
}

async function listIncidentDetailTimelinesWithOptions(request: ListIncidentDetailTimelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIncidentDetailTimelinesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.idSort)) {
    body['idSort'] = request.idSort;
  }
  if (!Util.isUnset(request.incidentId)) {
    body['incidentId'] = request.incidentId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListIncidentDetailTimelines',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/incident/detail/timeline`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListIncidentSubtotalsRequest {
  clientToken?: string(name='clientToken'),
  incidentId?: long(name='incidentId'),
}

model ListIncidentSubtotalsResponseBody = {
  data?: [ 
    {
      createTime?: string(name='createTime'),
      createUserId?: long(name='createUserId'),
      createUserName?: string(name='createUserName'),
      createUserPhone?: string(name='createUserPhone'),
      description?: string(name='description'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
}

model ListIncidentSubtotalsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIncidentSubtotalsResponseBody(name='body'),
}

async function listIncidentSubtotals(request: ListIncidentSubtotalsRequest): ListIncidentSubtotalsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIncidentSubtotalsWithOptions(request, headers, runtime);
}

async function listIncidentSubtotalsWithOptions(request: ListIncidentSubtotalsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIncidentSubtotalsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.incidentId)) {
    body['incidentId'] = request.incidentId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListIncidentSubtotals',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/incident/list/subtotal`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListIncidentTimelinesRequest {
  clientToken?: string(name='clientToken'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
}

model ListIncidentTimelinesResponseBody = {
  data?: [ 
    {
      action?: string(name='action'),
      createTime?: string(name='createTime'),
      description?: long(name='description'),
      incidentId?: long(name='incidentId'),
      incidentNumber?: string(name='incidentNumber'),
      incidentTitle?: string(name='incidentTitle'),
      relRouteRuleDeleteType?: int32(name='relRouteRuleDeleteType'),
      relatedServiceName?: string(name='relatedServiceName'),
      remark?: string(name='remark'),
      snapshotData?: string(name='snapshotData'),
      title?: string(name='title'),
    }
  ](name='data'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListIncidentTimelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIncidentTimelinesResponseBody(name='body'),
}

async function listIncidentTimelines(request: ListIncidentTimelinesRequest): ListIncidentTimelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIncidentTimelinesWithOptions(request, headers, runtime);
}

async function listIncidentTimelinesWithOptions(request: ListIncidentTimelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIncidentTimelinesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListIncidentTimelines',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/incident/timeline`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListIncidentsRequest {
  clientToken?: string(name='clientToken'),
  createEndTime?: string(name='createEndTime'),
  createStartTime?: string(name='createStartTime'),
  effect?: string(name='effect'),
  incidentLevel?: string(name='incidentLevel'),
  incidentStatus?: string(name='incidentStatus'),
  me?: int32(name='me'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  relationServiceId?: long(name='relationServiceId'),
  ruleName?: string(name='ruleName'),
}

model ListIncidentsResponseBody = {
  data?: [ 
    {
      assignToWhoIsValid?: long(name='assignToWhoIsValid'),
      assignUserId?: long(name='assignUserId'),
      assignUserName?: string(name='assignUserName'),
      assignUserPhone?: string(name='assignUserPhone'),
      createTime?: string(name='createTime'),
      effect?: string(name='effect'),
      incidentId?: long(name='incidentId'),
      incidentLevel?: string(name='incidentLevel'),
      incidentNumber?: string(name='incidentNumber'),
      incidentStatus?: string(name='incidentStatus'),
      incidentTitle?: string(name='incidentTitle'),
      isManual?: boolean(name='isManual'),
      relRouteRuleDeleteType?: int32(name='relRouteRuleDeleteType'),
      relServiceDeleteType?: int32(name='relServiceDeleteType'),
      relatedServiceId?: long(name='relatedServiceId'),
      relatedServiceName?: string(name='relatedServiceName'),
      routeRuleId?: long(name='routeRuleId'),
      routeRuleName?: string(name='routeRuleName'),
    }
  ](name='data'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListIncidentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIncidentsResponseBody(name='body'),
}

async function listIncidents(request: ListIncidentsRequest): ListIncidentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIncidentsWithOptions(request, headers, runtime);
}

async function listIncidentsWithOptions(request: ListIncidentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIncidentsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.createEndTime)) {
    body['createEndTime'] = request.createEndTime;
  }
  if (!Util.isUnset(request.createStartTime)) {
    body['createStartTime'] = request.createStartTime;
  }
  if (!Util.isUnset(request.effect)) {
    body['effect'] = request.effect;
  }
  if (!Util.isUnset(request.incidentLevel)) {
    body['incidentLevel'] = request.incidentLevel;
  }
  if (!Util.isUnset(request.incidentStatus)) {
    body['incidentStatus'] = request.incidentStatus;
  }
  if (!Util.isUnset(request.me)) {
    body['me'] = request.me;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.relationServiceId)) {
    body['relationServiceId'] = request.relationServiceId;
  }
  if (!Util.isUnset(request.ruleName)) {
    body['ruleName'] = request.ruleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListIncidents',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/incident/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListIntegrationConfigTimelinesRequest {
  clientToken?: string(name='clientToken'),
  integrationConfigId?: long(name='integrationConfigId'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
}

model ListIntegrationConfigTimelinesResponseBody = {
  data?: [ 
    {
      createTime?: string(name='createTime'),
      description?: string(name='description'),
      title?: string(name='title'),
    }
  ](name='data'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: long(name='totalCount'),
}

model ListIntegrationConfigTimelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIntegrationConfigTimelinesResponseBody(name='body'),
}

async function listIntegrationConfigTimelines(request: ListIntegrationConfigTimelinesRequest): ListIntegrationConfigTimelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIntegrationConfigTimelinesWithOptions(request, headers, runtime);
}

async function listIntegrationConfigTimelinesWithOptions(request: ListIntegrationConfigTimelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIntegrationConfigTimelinesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.integrationConfigId)) {
    body['integrationConfigId'] = request.integrationConfigId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListIntegrationConfigTimelines',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/integrationConfig/timeline`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListIntegrationConfigsRequest {
  clientToken?: string(name='clientToken'),
  monitorSourceName?: string(name='monitorSourceName'),
}

model ListIntegrationConfigsResponseBody = {
  data?: [ 
    {
      integrationConfigId?: long(name='integrationConfigId'),
      isReceivedEvent?: boolean(name='isReceivedEvent'),
      monitorSourceId?: long(name='monitorSourceId'),
      monitorSourceName?: string(name='monitorSourceName'),
      monitorSourceShortName?: string(name='monitorSourceShortName'),
      status?: string(name='status'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
}

model ListIntegrationConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIntegrationConfigsResponseBody(name='body'),
}

async function listIntegrationConfigs(request: ListIntegrationConfigsRequest): ListIntegrationConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIntegrationConfigsWithOptions(request, headers, runtime);
}

async function listIntegrationConfigsWithOptions(request: ListIntegrationConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIntegrationConfigsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.monitorSourceName)) {
    body['monitorSourceName'] = request.monitorSourceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListIntegrationConfigs',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/integrationConfig/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListMonitorSourcesRequest {
  clientToken?: string(name='clientToken'),
}

model ListMonitorSourcesResponseBody = {
  data?: [ 
    {
      fieldKeys?: [ string ](name='fieldKeys'),
      monitorSourceId?: long(name='monitorSourceId'),
      monitorSourceName?: string(name='monitorSourceName'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
}

model ListMonitorSourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMonitorSourcesResponseBody(name='body'),
}

async function listMonitorSources(request: ListMonitorSourcesRequest): ListMonitorSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMonitorSourcesWithOptions(request, headers, runtime);
}

async function listMonitorSourcesWithOptions(request: ListMonitorSourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMonitorSourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMonitorSources',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/monitorSource/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProblemDetailOperationsRequest {
  clientToken?: string(name='clientToken'),
  createTimeSort?: string(name='createTimeSort'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  problemId?: long(name='problemId'),
}

model ListProblemDetailOperationsResponseBody = {
  data?: [ 
    {
      action?: string(name='action'),
      createTime?: string(name='createTime'),
      description?: string(name='description'),
      relatedServiceName?: string(name='relatedServiceName'),
      remark?: string(name='remark'),
      snapshotData?: string(name='snapshotData'),
      title?: string(name='title'),
    }
  ](name='data'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListProblemDetailOperationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProblemDetailOperationsResponseBody(name='body'),
}

async function listProblemDetailOperations(request: ListProblemDetailOperationsRequest): ListProblemDetailOperationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProblemDetailOperationsWithOptions(request, headers, runtime);
}

async function listProblemDetailOperationsWithOptions(request: ListProblemDetailOperationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProblemDetailOperationsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.createTimeSort)) {
    body['createTimeSort'] = request.createTimeSort;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListProblemDetailOperations',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/detail/operations`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProblemOperationsRequest {
  clientToken?: string(name='clientToken'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
}

model ListProblemOperationsResponseBody = {
  data?: [ 
    {
      action?: string(name='action'),
      createTime?: string(name='createTime'),
      description?: string(name='description'),
      problemId?: long(name='problemId'),
      problemName?: string(name='problemName'),
      problemNumber?: string(name='problemNumber'),
      relatedServiceName?: string(name='relatedServiceName'),
      snapshotData?: string(name='snapshotData'),
      title?: string(name='title'),
    }
  ](name='data'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListProblemOperationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProblemOperationsResponseBody(name='body'),
}

async function listProblemOperations(request: ListProblemOperationsRequest): ListProblemOperationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProblemOperationsWithOptions(request, headers, runtime);
}

async function listProblemOperationsWithOptions(request: ListProblemOperationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProblemOperationsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListProblemOperations',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/operations`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProblemSubtotalsRequest {
  clientToken?: string(name='clientToken'),
  problemId?: long(name='problemId'),
}

model ListProblemSubtotalsResponseBody = {
  data?: [ 
    {
      createRamName?: string(name='createRamName'),
      createTime?: string(name='createTime'),
      createUserId?: long(name='createUserId'),
      createUserPhone?: string(name='createUserPhone'),
      description?: string(name='description'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
}

model ListProblemSubtotalsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProblemSubtotalsResponseBody(name='body'),
}

async function listProblemSubtotals(request: ListProblemSubtotalsRequest): ListProblemSubtotalsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProblemSubtotalsWithOptions(request, headers, runtime);
}

async function listProblemSubtotalsWithOptions(request: ListProblemSubtotalsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProblemSubtotalsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListProblemSubtotals',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/list/subtotal`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProblemTimeLinesRequest {
  clientToken?: string(name='clientToken'),
  problemId?: long(name='problemId'),
}

model ListProblemTimeLinesResponseBody = {
  data?: [ 
    {
      content?: string(name='content'),
      createTime?: string(name='createTime'),
      isKey?: boolean(name='isKey'),
      keyNode?: string(name='keyNode'),
      problemTimelineId?: long(name='problemTimelineId'),
      time?: string(name='time'),
      updateTime?: string(name='updateTime'),
      usersInContent?: [ 
        {
          isValid?: long(name='isValid'),
          userId?: long(name='userId'),
          username?: string(name='username'),
        }
      ](name='usersInContent'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
}

model ListProblemTimeLinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProblemTimeLinesResponseBody(name='body'),
}

async function listProblemTimeLines(request: ListProblemTimeLinesRequest): ListProblemTimeLinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProblemTimeLinesWithOptions(request, headers, runtime);
}

async function listProblemTimeLinesWithOptions(request: ListProblemTimeLinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProblemTimeLinesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListProblemTimeLines',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/detail/timeLines`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProblemsRequest {
  affectServiceId?: long(name='affectServiceId'),
  clientToken?: string(name='clientToken'),
  discoveryEndTime?: string(name='discoveryEndTime'),
  discoveryStartTime?: string(name='discoveryStartTime'),
  mainHandlerId?: long(name='mainHandlerId'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  problemLevel?: string(name='problemLevel'),
  problemStatus?: string(name='problemStatus'),
  queryType?: string(name='queryType'),
  repeaterId?: long(name='repeaterId'),
  restoreEndTime?: string(name='restoreEndTime'),
  restoreStartTime?: string(name='restoreStartTime'),
  serviceGroupId?: long(name='serviceGroupId'),
}

model ListProblemsResponseBody = {
  data?: [ 
    {
      affectServices?: [ 
        {
          serviceDescription?: string(name='serviceDescription'),
          serviceId?: long(name='serviceId'),
          serviceName?: string(name='serviceName'),
          updateTime?: string(name='updateTime'),
        }
      ](name='affectServices'),
      cancelTime?: string(name='cancelTime'),
      createTime?: string(name='createTime'),
      discoverTime?: string(name='discoverTime'),
      finishTime?: string(name='finishTime'),
      incidentId?: long(name='incidentId'),
      isManual?: boolean(name='isManual'),
      isUpgrade?: boolean(name='isUpgrade'),
      mainHandlerId?: long(name='mainHandlerId'),
      mainHandlerIsValid?: long(name='mainHandlerIsValid'),
      mainHandlerName?: string(name='mainHandlerName'),
      problemId?: long(name='problemId'),
      problemLevel?: string(name='problemLevel'),
      problemName?: string(name='problemName'),
      problemNumber?: string(name='problemNumber'),
      problemStatus?: string(name='problemStatus'),
      recoveryTime?: string(name='recoveryTime'),
      relatedServiceId?: string(name='relatedServiceId'),
      replayTime?: string(name='replayTime'),
      serviceDeletedType?: int32(name='serviceDeletedType'),
      serviceName?: string(name='serviceName'),
      updateTime?: string(name='updateTime'),
    }
  ](name='data'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: long(name='totalCount'),
}

model ListProblemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProblemsResponseBody(name='body'),
}

async function listProblems(request: ListProblemsRequest): ListProblemsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProblemsWithOptions(request, headers, runtime);
}

async function listProblemsWithOptions(request: ListProblemsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProblemsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.affectServiceId)) {
    body['affectServiceId'] = request.affectServiceId;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.discoveryEndTime)) {
    body['discoveryEndTime'] = request.discoveryEndTime;
  }
  if (!Util.isUnset(request.discoveryStartTime)) {
    body['discoveryStartTime'] = request.discoveryStartTime;
  }
  if (!Util.isUnset(request.mainHandlerId)) {
    body['mainHandlerId'] = request.mainHandlerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.problemLevel)) {
    body['problemLevel'] = request.problemLevel;
  }
  if (!Util.isUnset(request.problemStatus)) {
    body['problemStatus'] = request.problemStatus;
  }
  if (!Util.isUnset(request.queryType)) {
    body['queryType'] = request.queryType;
  }
  if (!Util.isUnset(request.repeaterId)) {
    body['repeaterId'] = request.repeaterId;
  }
  if (!Util.isUnset(request.restoreEndTime)) {
    body['restoreEndTime'] = request.restoreEndTime;
  }
  if (!Util.isUnset(request.restoreStartTime)) {
    body['restoreStartTime'] = request.restoreStartTime;
  }
  if (!Util.isUnset(request.serviceGroupId)) {
    body['serviceGroupId'] = request.serviceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListProblems',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/listProblems`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRouteRulesRequest {
  clientToken?: string(name='clientToken'),
  notFilterRouteRuleDeleted?: boolean(name='notFilterRouteRuleDeleted'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  routeType?: long(name='routeType'),
  ruleName?: bytes(name='ruleName'),
  serviceName?: bytes(name='serviceName'),
}

model ListRouteRulesResponseBody = {
  data?: [ 
    {
      assignObjectId?: long(name='assignObjectId'),
      assignObjectType?: string(name='assignObjectType'),
      createTime?: string(name='createTime'),
      effection?: string(name='effection'),
      enableStatus?: string(name='enableStatus'),
      incidentLevel?: string(name='incidentLevel'),
      isValid?: int32(name='isValid'),
      matchCount?: long(name='matchCount'),
      monitorSourceNames?: string(name='monitorSourceNames'),
      relServiceDeleteType?: int32(name='relServiceDeleteType'),
      relatedServiceId?: long(name='relatedServiceId'),
      relatedServiceName?: string(name='relatedServiceName'),
      routeRuleId?: long(name='routeRuleId'),
      routeType?: string(name='routeType'),
      ruleName?: string(name='ruleName'),
      tenantRamId?: long(name='tenantRamId'),
      timeWindow?: long(name='timeWindow'),
      timeWindowUnit?: long(name='timeWindowUnit'),
      updateTime?: string(name='updateTime'),
    }
  ](name='data'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: long(name='totalCount'),
}

model ListRouteRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRouteRulesResponseBody(name='body'),
}

async function listRouteRules(request: ListRouteRulesRequest): ListRouteRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRouteRulesWithOptions(request, headers, runtime);
}

async function listRouteRulesWithOptions(request: ListRouteRulesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRouteRulesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.notFilterRouteRuleDeleted)) {
    body['notFilterRouteRuleDeleted'] = request.notFilterRouteRuleDeleted;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.routeType)) {
    body['routeType'] = request.routeType;
  }
  if (!Util.isUnset(request.ruleName)) {
    body['ruleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.serviceName)) {
    body['serviceName'] = request.serviceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListRouteRules',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/routeRule/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRouteRulesByAssignWhoIdRequest {
  assignWhoId?: long(name='assignWhoId'),
  assignWhoType?: long(name='assignWhoType'),
}

model ListRouteRulesByAssignWhoIdResponseBody = {
  data?: [ 
    {
      id?: long(name='id'),
      ruleName?: string(name='ruleName'),
      tenantRamId?: long(name='tenantRamId'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
}

model ListRouteRulesByAssignWhoIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRouteRulesByAssignWhoIdResponseBody(name='body'),
}

async function listRouteRulesByAssignWhoId(request: ListRouteRulesByAssignWhoIdRequest): ListRouteRulesByAssignWhoIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRouteRulesByAssignWhoIdWithOptions(request, headers, runtime);
}

async function listRouteRulesByAssignWhoIdWithOptions(request: ListRouteRulesByAssignWhoIdRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRouteRulesByAssignWhoIdResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.assignWhoId)) {
    body['assignWhoId'] = request.assignWhoId;
  }
  if (!Util.isUnset(request.assignWhoType)) {
    body['assignWhoType'] = request.assignWhoType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListRouteRulesByAssignWhoId',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/routeRule/listByAssignWhoId`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRouteRulesByServiceResponseBody = {
  data?: [ 
    {
      id?: int32(name='id'),
      ruleName?: string(name='ruleName'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListRouteRulesByServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRouteRulesByServiceResponseBody(name='body'),
}

async function listRouteRulesByService(): ListRouteRulesByServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRouteRulesByServiceWithOptions(headers, runtime);
}

async function listRouteRulesByServiceWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListRouteRulesByServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListRouteRulesByService',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/routeRule/listByService`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListServiceGroupMonitorSourceTemplatesRequest {
  clientToken?: string(name='clientToken'),
  requestId?: string(name='requestId'),
  serviceGroupId?: long(name='serviceGroupId'),
}

model ListServiceGroupMonitorSourceTemplatesResponseBody = {
  data?: [ 
    {
      fields?: [ string ](name='fields'),
      monitorSourceId?: long(name='monitorSourceId'),
      monitorSourceName?: string(name='monitorSourceName'),
      templateContent?: string(name='templateContent'),
      templateId?: long(name='templateId'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
}

model ListServiceGroupMonitorSourceTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceGroupMonitorSourceTemplatesResponseBody(name='body'),
}

async function listServiceGroupMonitorSourceTemplates(request: ListServiceGroupMonitorSourceTemplatesRequest): ListServiceGroupMonitorSourceTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServiceGroupMonitorSourceTemplatesWithOptions(request, headers, runtime);
}

async function listServiceGroupMonitorSourceTemplatesWithOptions(request: ListServiceGroupMonitorSourceTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServiceGroupMonitorSourceTemplatesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.requestId)) {
    body['requestId'] = request.requestId;
  }
  if (!Util.isUnset(request.serviceGroupId)) {
    body['serviceGroupId'] = request.serviceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceGroupMonitorSourceTemplates',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/listServiceGroupMonitorSourceTemplates`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListServiceGroupsRequest {
  clientToken?: string(name='clientToken'),
  isScheduled?: boolean(name='isScheduled'),
  orderByScheduleStatus?: boolean(name='orderByScheduleStatus'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  queryName?: string(name='queryName'),
  queryType?: string(name='queryType'),
  userId?: long(name='userId'),
}

model ListServiceGroupsResponseBody = {
  data?: [ 
    {
      enableWebhook?: string(name='enableWebhook'),
      isScheduled?: boolean(name='isScheduled'),
      serviceGroupDescription?: string(name='serviceGroupDescription'),
      serviceGroupId?: long(name='serviceGroupId'),
      serviceGroupName?: string(name='serviceGroupName'),
      updateTime?: string(name='updateTime'),
      users?: [ 
        {
          email?: string(name='email'),
          isRelated?: int32(name='isRelated'),
          phone?: string(name='phone'),
          serviceGroupId?: long(name='serviceGroupId'),
          userId?: long(name='userId'),
          userName?: string(name='userName'),
        }
      ](name='users'),
      webhookLink?: string(name='webhookLink'),
      webhookType?: string(name='webhookType'),
    }
  ](name='data'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: long(name='totalCount'),
}

model ListServiceGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceGroupsResponseBody(name='body'),
}

async function listServiceGroups(request: ListServiceGroupsRequest): ListServiceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServiceGroupsWithOptions(request, headers, runtime);
}

async function listServiceGroupsWithOptions(request: ListServiceGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServiceGroupsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.isScheduled)) {
    body['isScheduled'] = request.isScheduled;
  }
  if (!Util.isUnset(request.orderByScheduleStatus)) {
    body['orderByScheduleStatus'] = request.orderByScheduleStatus;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryName)) {
    body['queryName'] = request.queryName;
  }
  if (!Util.isUnset(request.queryType)) {
    body['queryType'] = request.queryType;
  }
  if (!Util.isUnset(request.userId)) {
    body['userId'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceGroups',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListServiceGroupsByUserIdResponseBody = {
  data?: {
    isScheduled?: boolean(name='isScheduled'),
    serviceGroupId?: long(name='serviceGroupId'),
    serviceGroupName?: string(name='serviceGroupName'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model ListServiceGroupsByUserIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceGroupsByUserIdResponseBody(name='body'),
}

async function listServiceGroupsByUserId(): ListServiceGroupsByUserIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServiceGroupsByUserIdWithOptions(headers, runtime);
}

async function listServiceGroupsByUserIdWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListServiceGroupsByUserIdResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListServiceGroupsByUserId',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/listByUserId`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListServicesRequest {
  clientToken?: string(name='clientToken'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  serviceName?: string(name='serviceName'),
}

model ListServicesResponseBody = {
  data?: [ 
    {
      isValid?: int32(name='isValid'),
      serviceDescription?: string(name='serviceDescription'),
      serviceId?: long(name='serviceId'),
      serviceName?: string(name='serviceName'),
      updateTime?: string(name='updateTime'),
    }
  ](name='data'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: long(name='totalCount'),
}

model ListServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServicesResponseBody(name='body'),
}

async function listServices(request: ListServicesRequest): ListServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServicesWithOptions(request, headers, runtime);
}

async function listServicesWithOptions(request: ListServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServicesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serviceName)) {
    body['serviceName'] = request.serviceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListServices',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSourceEventsRequest {
  clientToken?: string(name='clientToken'),
  endTime?: string(name='endTime'),
  instanceId?: long(name='instanceId'),
  instanceType?: string(name='instanceType'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  startRowKey?: string(name='startRowKey'),
  startTime?: string(name='startTime'),
  stopRowKey?: string(name='stopRowKey'),
}

model ListSourceEventsResponseBody = {
  data?: [ 
    {
      eventJson?: string(name='eventJson'),
      eventTime?: string(name='eventTime'),
      instanceId?: long(name='instanceId'),
      instanceType?: string(name='instanceType'),
      monitorSourceId?: long(name='monitorSourceId'),
      monitorSourceName?: string(name='monitorSourceName'),
      routeRuleId?: long(name='routeRuleId'),
      tenantRamId?: long(name='tenantRamId'),
    }
  ](name='data'),
  firstRowKey?: string(name='firstRowKey'),
  lastRowKey?: string(name='lastRowKey'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: long(name='totalCount'),
}

model ListSourceEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSourceEventsResponseBody(name='body'),
}

async function listSourceEvents(request: ListSourceEventsRequest): ListSourceEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSourceEventsWithOptions(request, headers, runtime);
}

async function listSourceEventsWithOptions(request: ListSourceEventsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSourceEventsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.endTime)) {
    body['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['instanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startRowKey)) {
    body['startRowKey'] = request.startRowKey;
  }
  if (!Util.isUnset(request.startTime)) {
    body['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.stopRowKey)) {
    body['stopRowKey'] = request.stopRowKey;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListSourceEvents',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/events/listOriginalEvent`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSourceEventsForMonitorSourceRequest {
  monitorSourceId?: long(name='monitorSourceId'),
}

model ListSourceEventsForMonitorSourceResponseBody = {
  data?: [ 
    {
      eventJson?: string(name='eventJson'),
      eventTime?: string(name='eventTime'),
      monitorSourceId?: boolean(name='monitorSourceId'),
      monitorSourceName?: string(name='monitorSourceName'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
}

model ListSourceEventsForMonitorSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSourceEventsForMonitorSourceResponseBody(name='body'),
}

async function listSourceEventsForMonitorSource(request: ListSourceEventsForMonitorSourceRequest): ListSourceEventsForMonitorSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSourceEventsForMonitorSourceWithOptions(request, headers, runtime);
}

async function listSourceEventsForMonitorSourceWithOptions(request: ListSourceEventsForMonitorSourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSourceEventsForMonitorSourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.monitorSourceId)) {
    body['monitorSourceId'] = request.monitorSourceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListSourceEventsForMonitorSource',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/events/queryLastestEvents`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSubscriptionServiceGroupsRequest {
  clientToken?: string(name='clientToken'),
  serviceIds?: [ long ](name='serviceIds'),
}

model ListSubscriptionServiceGroupsResponseBody = {
  data?: [ 
    {
      serviceGroupDescription?: string(name='serviceGroupDescription'),
      serviceId?: long(name='serviceId'),
      serviceName?: string(name='serviceName'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
}

model ListSubscriptionServiceGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSubscriptionServiceGroupsResponseBody(name='body'),
}

async function listSubscriptionServiceGroups(request: ListSubscriptionServiceGroupsRequest): ListSubscriptionServiceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSubscriptionServiceGroupsWithOptions(request, headers, runtime);
}

async function listSubscriptionServiceGroupsWithOptions(request: ListSubscriptionServiceGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSubscriptionServiceGroupsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.serviceIds)) {
    body['serviceIds'] = request.serviceIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListSubscriptionServiceGroups',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/serviceGroup/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSubscriptionsRequest {
  clientToken?: string(name='clientToken'),
  notFilterScopeObjectDeleted?: boolean(name='notFilterScopeObjectDeleted'),
  notifyObject?: string(name='notifyObject'),
  notifyObjectType?: string(name='notifyObjectType'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  scope?: string(name='scope'),
  scopeObject?: string(name='scopeObject'),
  subscriptionTitle?: string(name='subscriptionTitle'),
}

model ListSubscriptionsResponseBody = {
  data?: [ 
    {
      endTime?: string(name='endTime'),
      expiredType?: string(name='expiredType'),
      notifyObjectList?: [ 
        {
          id?: long(name='id'),
          isValid?: long(name='isValid'),
          name?: string(name='name'),
          notifyObjectId?: long(name='notifyObjectId'),
          notifyObjectType?: long(name='notifyObjectType'),
        }
      ](name='notifyObjectList'),
      notifyObjectType?: long(name='notifyObjectType'),
      scope?: long(name='scope'),
      scopeObjectList?: [ 
        {
          id?: long(name='id'),
          isValid?: long(name='isValid'),
          scope?: long(name='scope'),
          scopeObject?: string(name='scopeObject'),
          scopeObjectId?: long(name='scopeObjectId'),
        }
      ](name='scopeObjectList'),
      startTime?: string(name='startTime'),
      status?: string(name='status'),
      subscriptionId?: long(name='subscriptionId'),
      subscriptionTitle?: string(name='subscriptionTitle'),
    }
  ](name='data'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: long(name='totalCount'),
}

model ListSubscriptionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSubscriptionsResponseBody(name='body'),
}

async function listSubscriptions(request: ListSubscriptionsRequest): ListSubscriptionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSubscriptionsWithOptions(request, headers, runtime);
}

async function listSubscriptionsWithOptions(request: ListSubscriptionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSubscriptionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.notFilterScopeObjectDeleted)) {
    body['notFilterScopeObjectDeleted'] = request.notFilterScopeObjectDeleted;
  }
  if (!Util.isUnset(request.notifyObject)) {
    body['notifyObject'] = request.notifyObject;
  }
  if (!Util.isUnset(request.notifyObjectType)) {
    body['notifyObjectType'] = request.notifyObjectType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.scope)) {
    body['scope'] = request.scope;
  }
  if (!Util.isUnset(request.scopeObject)) {
    body['scopeObject'] = request.scopeObject;
  }
  if (!Util.isUnset(request.subscriptionTitle)) {
    body['subscriptionTitle'] = request.subscriptionTitle;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListSubscriptions',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/notify/subscription/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTrendForSourceEventRequest {
  endTime?: string(name='endTime'),
  instanceId?: long(name='instanceId'),
  instanceType?: string(name='instanceType'),
  requestId?: string(name='requestId'),
  startTime?: string(name='startTime'),
  timeUnit?: long(name='timeUnit'),
}

model ListTrendForSourceEventResponseBody = {
  data?: [ 
    {
      convergenceRate?: string(name='convergenceRate'),
      maxSustainTime?: long(name='maxSustainTime'),
      skipDay?: boolean(name='skipDay'),
      sourceEventsStatMap?: map[string]any(name='sourceEventsStatMap'),
      unit?: string(name='unit'),
    }
  ](name='data'),
  requestId?: string(name='requestId'),
}

model ListTrendForSourceEventResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTrendForSourceEventResponseBody(name='body'),
}

async function listTrendForSourceEvent(request: ListTrendForSourceEventRequest): ListTrendForSourceEventResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTrendForSourceEventWithOptions(request, headers, runtime);
}

async function listTrendForSourceEventWithOptions(request: ListTrendForSourceEventRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTrendForSourceEventResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    body['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['instanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.requestId)) {
    body['requestId'] = request.requestId;
  }
  if (!Util.isUnset(request.startTime)) {
    body['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.timeUnit)) {
    body['timeUnit'] = request.timeUnit;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListTrendForSourceEvent',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/events/querySourceEventTrend`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListUserSerivceGroupsRequest {
  clientToken?: string(name='clientToken'),
  userId?: long(name='userId'),
}

model ListUserSerivceGroupsResponseBody = {
  data?: {
    email?: string(name='email'),
    phone?: string(name='phone'),
    ramId?: long(name='ramId'),
    serviceGroups?: [ 
      {
        serviceGroupDescription?: string(name='serviceGroupDescription'),
        serviceGroupId?: long(name='serviceGroupId'),
        serviceGroupName?: string(name='serviceGroupName'),
      }
    ](name='serviceGroups'),
    userId?: long(name='userId'),
    username?: string(name='username'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model ListUserSerivceGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserSerivceGroupsResponseBody(name='body'),
}

async function listUserSerivceGroups(request: ListUserSerivceGroupsRequest): ListUserSerivceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUserSerivceGroupsWithOptions(request, headers, runtime);
}

async function listUserSerivceGroupsWithOptions(request: ListUserSerivceGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListUserSerivceGroupsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.userId)) {
    body['userId'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListUserSerivceGroups',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/user/preview/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListUsersRequest {
  clientToken?: string(name='clientToken'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  phone?: string(name='phone'),
  ramId?: string(name='ramId'),
  scene?: long(name='scene'),
  synergyChannel?: string(name='synergyChannel'),
  username?: string(name='username'),
}

model ListUsersResponseBody = {
  data?: [ 
    {
      accountType?: long(name='accountType'),
      appAccount?: string(name='appAccount'),
      email?: string(name='email'),
      isEditableUser?: long(name='isEditableUser'),
      isOperation?: int32(name='isOperation'),
      isRam?: int32(name='isRam'),
      isRelated?: string(name='isRelated'),
      phone?: string(name='phone'),
      ramId?: long(name='ramId'),
      synergyChannel?: string(name='synergyChannel'),
      userId?: long(name='userId'),
      username?: string(name='username'),
    }
  ](name='data'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: long(name='totalCount'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUsersWithOptions(request, headers, runtime);
}

async function listUsersWithOptions(request: ListUsersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.phone)) {
    body['phone'] = request.phone;
  }
  if (!Util.isUnset(request.ramId)) {
    body['ramId'] = request.ramId;
  }
  if (!Util.isUnset(request.scene)) {
    body['scene'] = request.scene;
  }
  if (!Util.isUnset(request.synergyChannel)) {
    body['synergyChannel'] = request.synergyChannel;
  }
  if (!Util.isUnset(request.username)) {
    body['username'] = request.username;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListUsers',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/user/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RecoverProblemRequest {
  problemId?: long(name='problemId'),
  problemNotifyType?: string(name='problemNotifyType'),
  recoveryTime?: string(name='recoveryTime'),
}

model RecoverProblemResponseBody = {
  requestId?: string(name='requestId'),
}

model RecoverProblemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecoverProblemResponseBody(name='body'),
}

async function recoverProblem(request: RecoverProblemRequest): RecoverProblemResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return recoverProblemWithOptions(request, headers, runtime);
}

async function recoverProblemWithOptions(request: RecoverProblemRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RecoverProblemResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.problemNotifyType)) {
    body['problemNotifyType'] = request.problemNotifyType;
  }
  if (!Util.isUnset(request.recoveryTime)) {
    body['recoveryTime'] = request.recoveryTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RecoverProblem',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/recovery`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RefreshIntegrationConfigKeyRequest {
  clientToken?: string(name='clientToken'),
  integrationConfigId?: long(name='integrationConfigId'),
}

model RefreshIntegrationConfigKeyResponseBody = {
  data?: {
    key?: string(name='key'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model RefreshIntegrationConfigKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefreshIntegrationConfigKeyResponseBody(name='body'),
}

async function refreshIntegrationConfigKey(request: RefreshIntegrationConfigKeyRequest): RefreshIntegrationConfigKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return refreshIntegrationConfigKeyWithOptions(request, headers, runtime);
}

async function refreshIntegrationConfigKeyWithOptions(request: RefreshIntegrationConfigKeyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RefreshIntegrationConfigKeyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.integrationConfigId)) {
    body['integrationConfigId'] = request.integrationConfigId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RefreshIntegrationConfigKey',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/integrationConfig/refreshKey`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RemoveIntegrationConfigRequest {
  clientToken?: string(name='clientToken'),
  integrationConfigId?: long(name='integrationConfigId'),
}

model RemoveIntegrationConfigResponseBody = {
  requestId?: string(name='requestId'),
}

model RemoveIntegrationConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveIntegrationConfigResponseBody(name='body'),
}

async function removeIntegrationConfig(request: RemoveIntegrationConfigRequest): RemoveIntegrationConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeIntegrationConfigWithOptions(request, headers, runtime);
}

async function removeIntegrationConfigWithOptions(request: RemoveIntegrationConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveIntegrationConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.integrationConfigId)) {
    body['integrationConfigId'] = request.integrationConfigId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveIntegrationConfig',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/integrationConfig/remove`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RemoveProblemServiceGroupRequest {
  problemId?: long(name='problemId'),
  serviceGroupIds?: [ long ](name='serviceGroupIds'),
}

model RemoveProblemServiceGroupResponseBody = {
  requestId?: string(name='requestId'),
}

model RemoveProblemServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveProblemServiceGroupResponseBody(name='body'),
}

async function removeProblemServiceGroup(request: RemoveProblemServiceGroupRequest): RemoveProblemServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeProblemServiceGroupWithOptions(request, headers, runtime);
}

async function removeProblemServiceGroupWithOptions(request: RemoveProblemServiceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveProblemServiceGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.serviceGroupIds)) {
    body['serviceGroupIds'] = request.serviceGroupIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveProblemServiceGroup',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/removeServiceGroup`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ReplayProblemRequest {
  clientToken?: string(name='clientToken'),
  problemId?: long(name='problemId'),
  replayDutyUserId?: long(name='replayDutyUserId'),
}

model ReplayProblemResponseBody = {
  requestId?: string(name='requestId'),
}

model ReplayProblemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReplayProblemResponseBody(name='body'),
}

async function replayProblem(request: ReplayProblemRequest): ReplayProblemResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return replayProblemWithOptions(request, headers, runtime);
}

async function replayProblemWithOptions(request: ReplayProblemRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ReplayProblemResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.replayDutyUserId)) {
    body['replayDutyUserId'] = request.replayDutyUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReplayProblem',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/replay`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RespondIncidentRequest {
  clientToken?: string(name='clientToken'),
  incidentIds?: [ long ](name='incidentIds'),
}

model RespondIncidentResponseBody = {
  requestId?: string(name='requestId'),
}

model RespondIncidentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RespondIncidentResponseBody(name='body'),
}

async function respondIncident(request: RespondIncidentRequest): RespondIncidentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return respondIncidentWithOptions(request, headers, runtime);
}

async function respondIncidentWithOptions(request: RespondIncidentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RespondIncidentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.incidentIds)) {
    body['incidentIds'] = request.incidentIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RespondIncident',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/incident/response`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RevokeProblemRecoveryRequest {
  clientToken?: string(name='clientToken'),
  problemId?: long(name='problemId'),
  problemNotifyType?: string(name='problemNotifyType'),
}

model RevokeProblemRecoveryResponseBody = {
  requestId?: string(name='requestId'),
}

model RevokeProblemRecoveryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokeProblemRecoveryResponseBody(name='body'),
}

async function revokeProblemRecovery(request: RevokeProblemRecoveryRequest): RevokeProblemRecoveryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return revokeProblemRecoveryWithOptions(request, headers, runtime);
}

async function revokeProblemRecoveryWithOptions(request: RevokeProblemRecoveryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RevokeProblemRecoveryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.problemNotifyType)) {
    body['problemNotifyType'] = request.problemNotifyType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RevokeProblemRecovery',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/revoke`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UnbindUserResponseBody = {
  requestId?: string(name='requestId'),
}

model UnbindUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindUserResponseBody(name='body'),
}

async function unbindUser(): UnbindUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unbindUserWithOptions(headers, runtime);
}

async function unbindUserWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): UnbindUserResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UnbindUser',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/user/unbind`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateEscalationPlanRequest {
  clientToken?: string(name='clientToken'),
  escalationPlanDescription?: string(name='escalationPlanDescription'),
  escalationPlanId?: long(name='escalationPlanId'),
  escalationPlanName?: string(name='escalationPlanName'),
  escalationPlanRules?: [ 
    {
      escalationPlanConditions?: [ 
        {
          effection?: string(name='effection'),
          level?: string(name='level'),
        }
      ](name='escalationPlanConditions'),
      escalationPlanStrategies?: [ 
        {
          enableWebhook?: boolean(name='enableWebhook'),
          noticeChannels?: [ string ](name='noticeChannels'),
          noticeObjects?: [ long ](name='noticeObjects'),
          noticeTime?: long(name='noticeTime'),
          serviceGroupIds?: [ long ](name='serviceGroupIds'),
        }
      ](name='escalationPlanStrategies'),
      escalationPlanType?: string(name='escalationPlanType'),
      id?: long(name='id'),
    }
  ](name='escalationPlanRules'),
  escalationPlanScopeObjects?: [ 
    {
      id?: long(name='id'),
      scope?: string(name='scope'),
      scopeObjectId?: long(name='scopeObjectId'),
    }
  ](name='escalationPlanScopeObjects'),
}

model UpdateEscalationPlanResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateEscalationPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEscalationPlanResponseBody(name='body'),
}

async function updateEscalationPlan(request: UpdateEscalationPlanRequest): UpdateEscalationPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateEscalationPlanWithOptions(request, headers, runtime);
}

async function updateEscalationPlanWithOptions(request: UpdateEscalationPlanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateEscalationPlanResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.escalationPlanDescription)) {
    body['escalationPlanDescription'] = request.escalationPlanDescription;
  }
  if (!Util.isUnset(request.escalationPlanId)) {
    body['escalationPlanId'] = request.escalationPlanId;
  }
  if (!Util.isUnset(request.escalationPlanName)) {
    body['escalationPlanName'] = request.escalationPlanName;
  }
  if (!Util.isUnset(request.escalationPlanRules)) {
    body['escalationPlanRules'] = request.escalationPlanRules;
  }
  if (!Util.isUnset(request.escalationPlanScopeObjects)) {
    body['escalationPlanScopeObjects'] = request.escalationPlanScopeObjects;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEscalationPlan',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/escalationPlan/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateIncidentRequest {
  clientToken?: string(name='clientToken'),
  effect?: string(name='effect'),
  incidentId?: long(name='incidentId'),
  incidentLevel?: string(name='incidentLevel'),
  incidentTitle?: string(name='incidentTitle'),
}

model UpdateIncidentResponseBody = {
  data?: {
    incidentId?: long(name='incidentId'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model UpdateIncidentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIncidentResponseBody(name='body'),
}

async function updateIncident(request: UpdateIncidentRequest): UpdateIncidentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateIncidentWithOptions(request, headers, runtime);
}

async function updateIncidentWithOptions(request: UpdateIncidentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateIncidentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.effect)) {
    body['effect'] = request.effect;
  }
  if (!Util.isUnset(request.incidentId)) {
    body['incidentId'] = request.incidentId;
  }
  if (!Util.isUnset(request.incidentLevel)) {
    body['incidentLevel'] = request.incidentLevel;
  }
  if (!Util.isUnset(request.incidentTitle)) {
    body['incidentTitle'] = request.incidentTitle;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIncident',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/incident/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateIntegrationConfigRequest {
  accessKey?: string(name='accessKey'),
  clientToken?: string(name='clientToken'),
  integrationConfigId?: long(name='integrationConfigId'),
}

model UpdateIntegrationConfigResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateIntegrationConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIntegrationConfigResponseBody(name='body'),
}

async function updateIntegrationConfig(request: UpdateIntegrationConfigRequest): UpdateIntegrationConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateIntegrationConfigWithOptions(request, headers, runtime);
}

async function updateIntegrationConfigWithOptions(request: UpdateIntegrationConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateIntegrationConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessKey)) {
    body['accessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.integrationConfigId)) {
    body['integrationConfigId'] = request.integrationConfigId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIntegrationConfig',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/integrationConfig/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProblemRequest {
  feedback?: string(name='feedback'),
  level?: string(name='level'),
  mainHandlerId?: long(name='mainHandlerId'),
  preliminaryReason?: string(name='preliminaryReason'),
  problemId?: long(name='problemId'),
  problemName?: string(name='problemName'),
  progressSummary?: string(name='progressSummary'),
  progressSummaryRichTextId?: long(name='progressSummaryRichTextId'),
  relatedServiceId?: long(name='relatedServiceId'),
  serviceGroupIds?: [ long ](name='serviceGroupIds'),
}

model UpdateProblemResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateProblemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProblemResponseBody(name='body'),
}

async function updateProblem(request: UpdateProblemRequest): UpdateProblemResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProblemWithOptions(request, headers, runtime);
}

async function updateProblemWithOptions(request: UpdateProblemRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProblemResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.feedback)) {
    body['feedback'] = request.feedback;
  }
  if (!Util.isUnset(request.level)) {
    body['level'] = request.level;
  }
  if (!Util.isUnset(request.mainHandlerId)) {
    body['mainHandlerId'] = request.mainHandlerId;
  }
  if (!Util.isUnset(request.preliminaryReason)) {
    body['preliminaryReason'] = request.preliminaryReason;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.problemName)) {
    body['problemName'] = request.problemName;
  }
  if (!Util.isUnset(request.progressSummary)) {
    body['progressSummary'] = request.progressSummary;
  }
  if (!Util.isUnset(request.progressSummaryRichTextId)) {
    body['progressSummaryRichTextId'] = request.progressSummaryRichTextId;
  }
  if (!Util.isUnset(request.relatedServiceId)) {
    body['relatedServiceId'] = request.relatedServiceId;
  }
  if (!Util.isUnset(request.serviceGroupIds)) {
    body['serviceGroupIds'] = request.serviceGroupIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProblem',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProblemEffectionServiceRequest {
  clientToken?: string(name='clientToken'),
  description?: string(name='description'),
  effectionServiceId?: long(name='effectionServiceId'),
  level?: string(name='level'),
  picUrl?: [ string ](name='picUrl'),
  problemId?: long(name='problemId'),
  serviceId?: long(name='serviceId'),
  status?: string(name='status'),
}

model UpdateProblemEffectionServiceResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateProblemEffectionServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProblemEffectionServiceResponseBody(name='body'),
}

async function updateProblemEffectionService(request: UpdateProblemEffectionServiceRequest): UpdateProblemEffectionServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProblemEffectionServiceWithOptions(request, headers, runtime);
}

async function updateProblemEffectionServiceWithOptions(request: UpdateProblemEffectionServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProblemEffectionServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.effectionServiceId)) {
    body['effectionServiceId'] = request.effectionServiceId;
  }
  if (!Util.isUnset(request.level)) {
    body['level'] = request.level;
  }
  if (!Util.isUnset(request.picUrl)) {
    body['picUrl'] = request.picUrl;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.serviceId)) {
    body['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProblemEffectionService',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/process/effectionService/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProblemImprovementRequest {
  clientToken?: string(name='clientToken'),
  customProblemReason?: string(name='customProblemReason'),
  discoverSource?: long(name='discoverSource'),
  dutyDepartmentId?: long(name='dutyDepartmentId'),
  dutyDepartmentName?: string(name='dutyDepartmentName'),
  dutyUserId?: long(name='dutyUserId'),
  injectionMode?: string(name='injectionMode'),
  monitorSourceName?: string(name='monitorSourceName'),
  problemId?: long(name='problemId'),
  problemReason?: string(name='problemReason'),
  recentActivity?: string(name='recentActivity'),
  recoveryMode?: string(name='recoveryMode'),
  relationChanges?: string(name='relationChanges'),
  remark?: string(name='remark'),
  replayDutyUserId?: long(name='replayDutyUserId'),
  userReport?: long(name='userReport'),
}

model UpdateProblemImprovementResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateProblemImprovementResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProblemImprovementResponseBody(name='body'),
}

async function updateProblemImprovement(request: UpdateProblemImprovementRequest): UpdateProblemImprovementResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProblemImprovementWithOptions(request, headers, runtime);
}

async function updateProblemImprovementWithOptions(request: UpdateProblemImprovementRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProblemImprovementResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.customProblemReason)) {
    body['customProblemReason'] = request.customProblemReason;
  }
  if (!Util.isUnset(request.discoverSource)) {
    body['discoverSource'] = request.discoverSource;
  }
  if (!Util.isUnset(request.dutyDepartmentId)) {
    body['dutyDepartmentId'] = request.dutyDepartmentId;
  }
  if (!Util.isUnset(request.dutyDepartmentName)) {
    body['dutyDepartmentName'] = request.dutyDepartmentName;
  }
  if (!Util.isUnset(request.dutyUserId)) {
    body['dutyUserId'] = request.dutyUserId;
  }
  if (!Util.isUnset(request.injectionMode)) {
    body['injectionMode'] = request.injectionMode;
  }
  if (!Util.isUnset(request.monitorSourceName)) {
    body['monitorSourceName'] = request.monitorSourceName;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.problemReason)) {
    body['problemReason'] = request.problemReason;
  }
  if (!Util.isUnset(request.recentActivity)) {
    body['recentActivity'] = request.recentActivity;
  }
  if (!Util.isUnset(request.recoveryMode)) {
    body['recoveryMode'] = request.recoveryMode;
  }
  if (!Util.isUnset(request.relationChanges)) {
    body['relationChanges'] = request.relationChanges;
  }
  if (!Util.isUnset(request.remark)) {
    body['remark'] = request.remark;
  }
  if (!Util.isUnset(request.replayDutyUserId)) {
    body['replayDutyUserId'] = request.replayDutyUserId;
  }
  if (!Util.isUnset(request.userReport)) {
    body['userReport'] = request.userReport;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProblemImprovement',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/improvement/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProblemMeasureRequest {
  checkStandard?: string(name='checkStandard'),
  checkUserId?: long(name='checkUserId'),
  clientToken?: string(name='clientToken'),
  content?: string(name='content'),
  directorId?: long(name='directorId'),
  measureId?: long(name='measureId'),
  planFinishTime?: string(name='planFinishTime'),
  problemId?: long(name='problemId'),
  stalkerId?: long(name='stalkerId'),
  status?: string(name='status'),
  type?: int32(name='type'),
}

model UpdateProblemMeasureResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateProblemMeasureResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProblemMeasureResponseBody(name='body'),
}

async function updateProblemMeasure(request: UpdateProblemMeasureRequest): UpdateProblemMeasureResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProblemMeasureWithOptions(request, headers, runtime);
}

async function updateProblemMeasureWithOptions(request: UpdateProblemMeasureRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProblemMeasureResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkStandard)) {
    body['checkStandard'] = request.checkStandard;
  }
  if (!Util.isUnset(request.checkUserId)) {
    body['checkUserId'] = request.checkUserId;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }
  if (!Util.isUnset(request.directorId)) {
    body['directorId'] = request.directorId;
  }
  if (!Util.isUnset(request.measureId)) {
    body['measureId'] = request.measureId;
  }
  if (!Util.isUnset(request.planFinishTime)) {
    body['planFinishTime'] = request.planFinishTime;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.stalkerId)) {
    body['stalkerId'] = request.stalkerId;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProblemMeasure',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/improvement/measure/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProblemNoticeRequest {
  clientToken?: string(name='clientToken'),
  problemId?: long(name='problemId'),
  problemNotifyType?: string(name='problemNotifyType'),
}

model UpdateProblemNoticeResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateProblemNoticeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProblemNoticeResponseBody(name='body'),
}

async function updateProblemNotice(request: UpdateProblemNoticeRequest): UpdateProblemNoticeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProblemNoticeWithOptions(request, headers, runtime);
}

async function updateProblemNoticeWithOptions(request: UpdateProblemNoticeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProblemNoticeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.problemNotifyType)) {
    body['problemNotifyType'] = request.problemNotifyType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProblemNotice',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/notify`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProblemTimelineRequest {
  clientToken?: string(name='clientToken'),
  content?: string(name='content'),
  keyNode?: string(name='keyNode'),
  problemId?: long(name='problemId'),
  problemTimelineId?: long(name='problemTimelineId'),
  time?: string(name='time'),
}

model UpdateProblemTimelineResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateProblemTimelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProblemTimelineResponseBody(name='body'),
}

async function updateProblemTimeline(request: UpdateProblemTimelineRequest): UpdateProblemTimelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProblemTimelineWithOptions(request, headers, runtime);
}

async function updateProblemTimelineWithOptions(request: UpdateProblemTimelineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProblemTimelineResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.content)) {
    body['content'] = request.content;
  }
  if (!Util.isUnset(request.keyNode)) {
    body['keyNode'] = request.keyNode;
  }
  if (!Util.isUnset(request.problemId)) {
    body['problemId'] = request.problemId;
  }
  if (!Util.isUnset(request.problemTimelineId)) {
    body['problemTimelineId'] = request.problemTimelineId;
  }
  if (!Util.isUnset(request.time)) {
    body['time'] = request.time;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProblemTimeline',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/problem/process/timeline/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateRichTextRequest {
  instanceId?: long(name='instanceId'),
  instanceType?: string(name='instanceType'),
  richText?: string(name='richText'),
  richTextId?: long(name='richTextId'),
}

model UpdateRichTextResponseBody = {
  data?: {
    id?: long(name='id'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model UpdateRichTextResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRichTextResponseBody(name='body'),
}

async function updateRichText(request: UpdateRichTextRequest): UpdateRichTextResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRichTextWithOptions(request, headers, runtime);
}

async function updateRichTextWithOptions(request: UpdateRichTextRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRichTextResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['instanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.richText)) {
    body['richText'] = request.richText;
  }
  if (!Util.isUnset(request.richTextId)) {
    body['richTextId'] = request.richTextId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRichText',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/rich/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateRouteRuleRequest {
  assignObjectId?: long(name='assignObjectId'),
  assignObjectType?: string(name='assignObjectType'),
  childRuleRelation?: string(name='childRuleRelation'),
  clientToken?: string(name='clientToken'),
  effection?: string(name='effection'),
  incidentLevel?: string(name='incidentLevel'),
  matchCount?: long(name='matchCount'),
  notifyChannels?: [ string ](name='notifyChannels'),
  relatedServiceId?: long(name='relatedServiceId'),
  routeChildRules?: [ 
    {
      childConditionRelation?: long(name='childConditionRelation'),
      childRouteRuleId?: long(name='childRouteRuleId'),
      conditions?: [ 
        {
          key?: string(name='key'),
          operationSymbol?: string(name='operationSymbol'),
          value?: string(name='value'),
        }
      ](name='conditions'),
      isValidChildRule?: boolean(name='isValidChildRule'),
      monitorSourceId?: long(name='monitorSourceId'),
    }
  ](name='routeChildRules'),
  routeRuleId?: long(name='routeRuleId'),
  routeType?: string(name='routeType'),
  ruleName?: string(name='ruleName'),
  timeWindow?: int32(name='timeWindow'),
  timeWindowUnit?: string(name='timeWindowUnit'),
}

model UpdateRouteRuleResponseBody = {
  data?: long(name='data'),
  requestId?: string(name='requestId'),
}

model UpdateRouteRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRouteRuleResponseBody(name='body'),
}

async function updateRouteRule(request: UpdateRouteRuleRequest): UpdateRouteRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRouteRuleWithOptions(request, headers, runtime);
}

async function updateRouteRuleWithOptions(request: UpdateRouteRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRouteRuleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.assignObjectId)) {
    body['assignObjectId'] = request.assignObjectId;
  }
  if (!Util.isUnset(request.assignObjectType)) {
    body['assignObjectType'] = request.assignObjectType;
  }
  if (!Util.isUnset(request.childRuleRelation)) {
    body['childRuleRelation'] = request.childRuleRelation;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.effection)) {
    body['effection'] = request.effection;
  }
  if (!Util.isUnset(request.incidentLevel)) {
    body['incidentLevel'] = request.incidentLevel;
  }
  if (!Util.isUnset(request.matchCount)) {
    body['matchCount'] = request.matchCount;
  }
  if (!Util.isUnset(request.notifyChannels)) {
    body['notifyChannels'] = request.notifyChannels;
  }
  if (!Util.isUnset(request.relatedServiceId)) {
    body['relatedServiceId'] = request.relatedServiceId;
  }
  if (!Util.isUnset(request.routeChildRules)) {
    body['routeChildRules'] = request.routeChildRules;
  }
  if (!Util.isUnset(request.routeRuleId)) {
    body['routeRuleId'] = request.routeRuleId;
  }
  if (!Util.isUnset(request.routeType)) {
    body['routeType'] = request.routeType;
  }
  if (!Util.isUnset(request.ruleName)) {
    body['ruleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.timeWindow)) {
    body['timeWindow'] = request.timeWindow;
  }
  if (!Util.isUnset(request.timeWindowUnit)) {
    body['timeWindowUnit'] = request.timeWindowUnit;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRouteRule',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/routeRule/edit`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateServiceRequest {
  clientToken?: string(name='clientToken'),
  serviceDescription?: string(name='serviceDescription'),
  serviceId?: long(name='serviceId'),
  serviceName?: string(name='serviceName'),
}

model UpdateServiceResponseBody = {
  data?: long(name='data'),
  requestId?: string(name='requestId'),
}

model UpdateServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceResponseBody(name='body'),
}

async function updateService(request: UpdateServiceRequest): UpdateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceWithOptions(request, headers, runtime);
}

async function updateServiceWithOptions(request: UpdateServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.serviceDescription)) {
    body['serviceDescription'] = request.serviceDescription;
  }
  if (!Util.isUnset(request.serviceId)) {
    body['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.serviceName)) {
    body['serviceName'] = request.serviceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateService',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateServiceGroupRequest {
  clientToken?: string(name='clientToken'),
  enableWebhook?: string(name='enableWebhook'),
  monitorSourceTemplates?: [ 
    {
      monitorSourceId?: long(name='monitorSourceId'),
      monitorSourceName?: string(name='monitorSourceName'),
      templateContent?: string(name='templateContent'),
      templateId?: long(name='templateId'),
    }
  ](name='monitorSourceTemplates'),
  serviceGroupDescription?: string(name='serviceGroupDescription'),
  serviceGroupId?: long(name='serviceGroupId'),
  serviceGroupName?: string(name='serviceGroupName'),
  userIds?: [ long ](name='userIds'),
  webhookLink?: string(name='webhookLink'),
  webhookType?: string(name='webhookType'),
}

model UpdateServiceGroupResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceGroupResponseBody(name='body'),
}

async function updateServiceGroup(request: UpdateServiceGroupRequest): UpdateServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceGroupWithOptions(request, headers, runtime);
}

async function updateServiceGroupWithOptions(request: UpdateServiceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.enableWebhook)) {
    body['enableWebhook'] = request.enableWebhook;
  }
  if (!Util.isUnset(request.monitorSourceTemplates)) {
    body['monitorSourceTemplates'] = request.monitorSourceTemplates;
  }
  if (!Util.isUnset(request.serviceGroupDescription)) {
    body['serviceGroupDescription'] = request.serviceGroupDescription;
  }
  if (!Util.isUnset(request.serviceGroupId)) {
    body['serviceGroupId'] = request.serviceGroupId;
  }
  if (!Util.isUnset(request.serviceGroupName)) {
    body['serviceGroupName'] = request.serviceGroupName;
  }
  if (!Util.isUnset(request.userIds)) {
    body['userIds'] = request.userIds;
  }
  if (!Util.isUnset(request.webhookLink)) {
    body['webhookLink'] = request.webhookLink;
  }
  if (!Util.isUnset(request.webhookType)) {
    body['webhookType'] = request.webhookType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceGroup',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/modify`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateServiceGroupSchedulingRequest {
  clientToken?: string(name='clientToken'),
  fastScheduling?: {
    dutyPlan?: string(name='dutyPlan'),
    id?: long(name='id'),
    schedulingUsers?: [ 
      {
        schedulingOrder?: int32(name='schedulingOrder'),
        schedulingUserId?: long(name='schedulingUserId'),
      }
    ](name='schedulingUsers'),
    singleDuration?: int32(name='singleDuration'),
    singleDurationUnit?: string(name='singleDurationUnit'),
  }(name='fastScheduling'),
  fineScheduling?: {
    id?: long(name='id'),
    period?: int32(name='period'),
    periodUnit?: string(name='periodUnit'),
    schedulingFineShifts?: [ 
      {
        cycleOrder?: int32(name='cycleOrder'),
        schedulingEndTime?: string(name='schedulingEndTime'),
        schedulingOrder?: long(name='schedulingOrder'),
        schedulingStartTime?: string(name='schedulingStartTime'),
        schedulingUserId?: long(name='schedulingUserId'),
        shiftName?: string(name='shiftName'),
        skipOneDay?: boolean(name='skipOneDay'),
      }
    ](name='schedulingFineShifts'),
    schedulingTemplateFineShifts?: [ 
      {
        schedulingEndTime?: string(name='schedulingEndTime'),
        schedulingOrder?: int32(name='schedulingOrder'),
        schedulingStartTime?: string(name='schedulingStartTime'),
        schedulingUserId?: long(name='schedulingUserId'),
        shiftName?: string(name='shiftName'),
        skipOneDay?: boolean(name='skipOneDay'),
      }
    ](name='schedulingTemplateFineShifts'),
    shiftType?: string(name='shiftType'),
  }(name='fineScheduling'),
  schedulingWay?: string(name='schedulingWay'),
  serviceGroupId?: long(name='serviceGroupId'),
}

model UpdateServiceGroupSchedulingResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateServiceGroupSchedulingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceGroupSchedulingResponseBody(name='body'),
}

async function updateServiceGroupScheduling(request: UpdateServiceGroupSchedulingRequest): UpdateServiceGroupSchedulingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceGroupSchedulingWithOptions(request, headers, runtime);
}

async function updateServiceGroupSchedulingWithOptions(request: UpdateServiceGroupSchedulingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceGroupSchedulingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.fastScheduling)) {
    body['fastScheduling'] = request.fastScheduling;
  }
  if (!Util.isUnset(request.fineScheduling)) {
    body['fineScheduling'] = request.fineScheduling;
  }
  if (!Util.isUnset(request.schedulingWay)) {
    body['schedulingWay'] = request.schedulingWay;
  }
  if (!Util.isUnset(request.serviceGroupId)) {
    body['serviceGroupId'] = request.serviceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceGroupScheduling',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/scheduling/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateServiceGroupSpecialDaySchedulingRequest {
  clientToken?: string(name='clientToken'),
  schedulingDate?: string(name='schedulingDate'),
  schedulingSpecialDays?: [ 
    {
      schedulingEndTime?: string(name='schedulingEndTime'),
      schedulingOrder?: int32(name='schedulingOrder'),
      schedulingStartTime?: string(name='schedulingStartTime'),
      schedulingUserId?: long(name='schedulingUserId'),
    }
  ](name='schedulingSpecialDays'),
  serviceGroupId?: long(name='serviceGroupId'),
}

model UpdateServiceGroupSpecialDaySchedulingResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateServiceGroupSpecialDaySchedulingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceGroupSpecialDaySchedulingResponseBody(name='body'),
}

async function updateServiceGroupSpecialDayScheduling(request: UpdateServiceGroupSpecialDaySchedulingRequest): UpdateServiceGroupSpecialDaySchedulingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceGroupSpecialDaySchedulingWithOptions(request, headers, runtime);
}

async function updateServiceGroupSpecialDaySchedulingWithOptions(request: UpdateServiceGroupSpecialDaySchedulingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateServiceGroupSpecialDaySchedulingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.schedulingDate)) {
    body['schedulingDate'] = request.schedulingDate;
  }
  if (!Util.isUnset(request.schedulingSpecialDays)) {
    body['schedulingSpecialDays'] = request.schedulingSpecialDays;
  }
  if (!Util.isUnset(request.serviceGroupId)) {
    body['serviceGroupId'] = request.serviceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceGroupSpecialDayScheduling',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/services/group/scheduling/updateSpecialDayScheduling`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateSubscriptionRequest {
  endTime?: string(name='endTime'),
  expiredType?: string(name='expiredType'),
  notifyObjectList?: [ 
    {
      id?: long(name='id'),
      notifyObjectId?: long(name='notifyObjectId'),
    }
  ](name='notifyObjectList'),
  notifyObjectType?: string(name='notifyObjectType'),
  notifyStrategyList?: [ 
    {
      instanceType?: long(name='instanceType'),
      strategies?: [ 
        {
          channels?: string(name='channels'),
          conditions?: [ 
            {
              action?: string(name='action'),
              effection?: string(name='effection'),
              level?: string(name='level'),
              problemNotifyType?: string(name='problemNotifyType'),
            }
          ](name='conditions'),
          id?: string(name='id'),
          periodChannel?: {
            nonWorkday?: string(name='nonWorkday'),
            workday?: string(name='workday'),
          }(name='periodChannel'),
        }
      ](name='strategies'),
    }
  ](name='notifyStrategyList'),
  period?: string(name='period'),
  scope?: string(name='scope'),
  scopeObjectList?: [ 
    {
      id?: long(name='id'),
      scopeObjectId?: long(name='scopeObjectId'),
    }
  ](name='scopeObjectList'),
  startTime?: string(name='startTime'),
  subscriptionId?: long(name='subscriptionId'),
  subscriptionTitle?: string(name='subscriptionTitle'),
}

model UpdateSubscriptionResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateSubscriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSubscriptionResponseBody(name='body'),
}

async function updateSubscription(request: UpdateSubscriptionRequest): UpdateSubscriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSubscriptionWithOptions(request, headers, runtime);
}

async function updateSubscriptionWithOptions(request: UpdateSubscriptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSubscriptionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    body['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.expiredType)) {
    body['expiredType'] = request.expiredType;
  }
  if (!Util.isUnset(request.notifyObjectList)) {
    body['notifyObjectList'] = request.notifyObjectList;
  }
  if (!Util.isUnset(request.notifyObjectType)) {
    body['notifyObjectType'] = request.notifyObjectType;
  }
  if (!Util.isUnset(request.notifyStrategyList)) {
    body['notifyStrategyList'] = request.notifyStrategyList;
  }
  if (!Util.isUnset(request.period)) {
    body['period'] = request.period;
  }
  if (!Util.isUnset(request.scope)) {
    body['scope'] = request.scope;
  }
  if (!Util.isUnset(request.scopeObjectList)) {
    body['scopeObjectList'] = request.scopeObjectList;
  }
  if (!Util.isUnset(request.startTime)) {
    body['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.subscriptionId)) {
    body['subscriptionId'] = request.subscriptionId;
  }
  if (!Util.isUnset(request.subscriptionTitle)) {
    body['subscriptionTitle'] = request.subscriptionTitle;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSubscription',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/notify/subscription/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateUserRequest {
  clientToken?: string(name='clientToken'),
  email?: string(name='email'),
  phone?: string(name='phone'),
  ramId?: long(name='ramId'),
  userId?: long(name='userId'),
  username?: string(name='username'),
}

model UpdateUserResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateUserResponseBody(name='body'),
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateUserWithOptions(request, headers, runtime);
}

async function updateUserWithOptions(request: UpdateUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.email)) {
    body['email'] = request.email;
  }
  if (!Util.isUnset(request.phone)) {
    body['phone'] = request.phone;
  }
  if (!Util.isUnset(request.ramId)) {
    body['ramId'] = request.ramId;
  }
  if (!Util.isUnset(request.userId)) {
    body['userId'] = request.userId;
  }
  if (!Util.isUnset(request.username)) {
    body['username'] = request.username;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUser',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/user/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateUserGuideStatusRequest {
  clientToken?: string(name='clientToken'),
  guideAction?: string(name='guideAction'),
}

model UpdateUserGuideStatusResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateUserGuideStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateUserGuideStatusResponseBody(name='body'),
}

async function updateUserGuideStatus(request: UpdateUserGuideStatusRequest): UpdateUserGuideStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateUserGuideStatusWithOptions(request, headers, runtime);
}

async function updateUserGuideStatusWithOptions(request: UpdateUserGuideStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateUserGuideStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.guideAction)) {
    body['guideAction'] = request.guideAction;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUserGuideStatus',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/user/update/guide/status`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model VerifyRouteRuleRequest {
  routeRuleId?: long(name='routeRuleId'),
  testSourceEvents?: [ 
    {
      eventJson?: string(name='eventJson'),
      eventTime?: string(name='eventTime'),
      monitorSourceId?: long(name='monitorSourceId'),
      monitorSourceName?: string(name='monitorSourceName'),
    }
  ](name='testSourceEvents'),
}

model VerifyRouteRuleResponseBody = {
  data?: {
    escalationPlans?: [ 
      {
        escalationPlanId?: long(name='escalationPlanId'),
        escalationPlanName?: string(name='escalationPlanName'),
      }
    ](name='escalationPlans'),
    isValidRule?: boolean(name='isValidRule'),
    monitorSourceIds?: [ long ](name='monitorSourceIds'),
    notifySubscriptionNames?: [ 
      {
        subscriptionId?: long(name='subscriptionId'),
        title?: string(name='title'),
      }
    ](name='notifySubscriptionNames'),
    routeRuleFailReason?: [ string ](name='routeRuleFailReason'),
    routeType?: string(name='routeType'),
  }(name='data'),
  requestId?: string(name='requestId'),
}

model VerifyRouteRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyRouteRuleResponseBody(name='body'),
}

async function verifyRouteRule(request: VerifyRouteRuleRequest): VerifyRouteRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return verifyRouteRuleWithOptions(request, headers, runtime);
}

async function verifyRouteRuleWithOptions(request: VerifyRouteRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VerifyRouteRuleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.routeRuleId)) {
    body['routeRuleId'] = request.routeRuleId;
  }
  if (!Util.isUnset(request.testSourceEvents)) {
    body['testSourceEvents'] = request.testSourceEvents;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'VerifyRouteRule',
    version = '2021-04-13',
    protocol = 'HTTPS',
    pathname = `/routeRule/verify`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

