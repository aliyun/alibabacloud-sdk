/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
@endpointMap = {
    cn-beijing = 'emr.aliyuncs.com',
    cn-hangzhou = 'emr.aliyuncs.com',
    cn-shanghai = 'emr.aliyuncs.com',
    cn-shenzhen = 'emr.aliyuncs.com',
    ap-southeast-1 = 'emr.aliyuncs.com',
    us-west-1 = 'emr.aliyuncs.com',
    cn-hangzhou-finance = 'emr.aliyuncs.com',
    cn-shenzhen-finance-1 = 'emr.aliyuncs.com',
    cn-shanghai-finance-1 = 'emr.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('emr', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AddClusterServiceRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  comment?: string(name='Comment'),
  clusterId?: string(name='ClusterId'),
  service?: [ 
    {
      serviceVersion?: string(name='ServiceVersion'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='Service'),
}

model AddClusterServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddClusterServiceResponse = {
  headers: map[string]string(name='headers'),
  body: AddClusterServiceResponseBody(name='body'),
}

async function addClusterServiceWithOptions(request: AddClusterServiceRequest, runtime: Util.RuntimeOptions): AddClusterServiceResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Comment"] = request.comment;
  query["ClusterId"] = request.clusterId;
  query["Service"] = request.service;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddClusterService',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addClusterService(request: AddClusterServiceRequest): AddClusterServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addClusterServiceWithOptions(request, runtime);
}

model AddScalingConfigItemV2Request {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  configItemType?: string(name='ConfigItemType'),
  configItemInformation?: string(name='ConfigItemInformation'),
}

model AddScalingConfigItemV2ResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model AddScalingConfigItemV2Response = {
  headers: map[string]string(name='headers'),
  body: AddScalingConfigItemV2ResponseBody(name='body'),
}

async function addScalingConfigItemV2WithOptions(request: AddScalingConfigItemV2Request, runtime: Util.RuntimeOptions): AddScalingConfigItemV2Response {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["ScalingGroupBizId"] = request.scalingGroupBizId;
  query["ConfigItemType"] = request.configItemType;
  query["ConfigItemInformation"] = request.configItemInformation;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddScalingConfigItemV2',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addScalingConfigItemV2(request: AddScalingConfigItemV2Request): AddScalingConfigItemV2Response {
  var runtime = new Util.RuntimeOptions{};
  return addScalingConfigItemV2WithOptions(request, runtime);
}

model AuthorizeSecurityGroupRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  bizType?: string(name='BizType'),
  bizContent?: string(name='BizContent'),
}

model AuthorizeSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AuthorizeSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeSecurityGroupResponseBody(name='body'),
}

async function authorizeSecurityGroupWithOptions(request: AuthorizeSecurityGroupRequest, runtime: Util.RuntimeOptions): AuthorizeSecurityGroupResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["BizType"] = request.bizType;
  query["BizContent"] = request.bizContent;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AuthorizeSecurityGroup',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function authorizeSecurityGroup(request: AuthorizeSecurityGroupRequest): AuthorizeSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return authorizeSecurityGroupWithOptions(request, runtime);
}

model CancelOrderRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
}

model CancelOrderResponseBody = {
  requestId?: string(name='RequestId'),
  clusterId?: string(name='clusterId'),
}

model CancelOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CancelOrderResponseBody(name='body'),
}

async function cancelOrderWithOptions(request: CancelOrderRequest, runtime: Util.RuntimeOptions): CancelOrderResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CancelOrder',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelOrder(request: CancelOrderRequest): CancelOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelOrderWithOptions(request, runtime);
}

model CloneFlowRequest {
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
}

model CloneFlowResponseBody = {
  requestId?: string(name='RequestId'),
  id?: string(name='Id'),
}

model CloneFlowResponse = {
  headers: map[string]string(name='headers'),
  body: CloneFlowResponseBody(name='body'),
}

async function cloneFlowWithOptions(request: CloneFlowRequest, runtime: Util.RuntimeOptions): CloneFlowResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["Id"] = request.id;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CloneFlow',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cloneFlow(request: CloneFlowRequest): CloneFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneFlowWithOptions(request, runtime);
}

model CloneFlowJobRequest {
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model CloneFlowJobResponseBody = {
  requestId?: string(name='RequestId'),
  id?: string(name='Id'),
}

model CloneFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: CloneFlowJobResponseBody(name='body'),
}

async function cloneFlowJobWithOptions(request: CloneFlowJobRequest, runtime: Util.RuntimeOptions): CloneFlowJobResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["Id"] = request.id;
  query["Name"] = request.name;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CloneFlowJob',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cloneFlowJob(request: CloneFlowJobRequest): CloneFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneFlowJobWithOptions(request, runtime);
}

model CreateBackupRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  backupPlanId?: string(name='BackupPlanId'),
  metadataType?: string(name='MetadataType'),
}

model CreateBackupResponseBody = {
  triggerType?: string(name='TriggerType'),
  endTime?: long(name='EndTime'),
  requestId?: string(name='RequestId'),
  gmtModified?: long(name='GmtModified'),
  startTime?: long(name='StartTime'),
  taskStatus?: string(name='TaskStatus'),
  taskDetail?: string(name='TaskDetail'),
  triggerUser?: string(name='TriggerUser'),
  gmtCreate?: long(name='GmtCreate'),
  taskProcess?: int32(name='TaskProcess'),
  clusterBizId?: string(name='ClusterBizId'),
  taskType?: string(name='TaskType'),
  bizId?: string(name='BizId'),
  dataSourceId?: long(name='DataSourceId'),
  hostName?: string(name='HostName'),
  ecmTaskId?: long(name='EcmTaskId'),
  taskResultDetail?: string(name='TaskResultDetail'),
}

model CreateBackupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBackupResponseBody(name='body'),
}

async function createBackupWithOptions(request: CreateBackupRequest, runtime: Util.RuntimeOptions): CreateBackupResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["BackupPlanId"] = request.backupPlanId;
  query["MetadataType"] = request.metadataType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateBackup',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBackup(request: CreateBackupRequest): CreateBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBackupWithOptions(request, runtime);
}

model CreateBackupPlanRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  clusterId?: string(name='ClusterId'),
  rootPath?: string(name='RootPath'),
}

model CreateBackupPlanResponseBody = {
  rootPath?: string(name='RootPath'),
  description?: string(name='Description'),
  requestId?: string(name='RequestId'),
  clusterId?: string(name='ClusterId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
}

model CreateBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBackupPlanResponseBody(name='body'),
}

async function createBackupPlanWithOptions(request: CreateBackupPlanRequest, runtime: Util.RuntimeOptions): CreateBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Name"] = request.name;
  query["Description"] = request.description;
  query["ClusterId"] = request.clusterId;
  query["RootPath"] = request.rootPath;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateBackupPlan',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBackupPlan(request: CreateBackupPlanRequest): CreateBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBackupPlanWithOptions(request, runtime);
}

model CreateClusterBootstrapActionRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  bootstrapAction?: [ 
    {
      executionFailStrategy?: string(name='ExecutionFailStrategy'),
      arg?: string(name='Arg'),
      path?: string(name='Path'),
      executionTarget?: string(name='ExecutionTarget'),
      executionMoment?: string(name='ExecutionMoment'),
      name?: string(name='Name'),
    }
  ](name='BootstrapAction'),
}

model CreateClusterBootstrapActionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateClusterBootstrapActionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterBootstrapActionResponseBody(name='body'),
}

async function createClusterBootstrapActionWithOptions(request: CreateClusterBootstrapActionRequest, runtime: Util.RuntimeOptions): CreateClusterBootstrapActionResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["BootstrapAction"] = request.bootstrapAction;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateClusterBootstrapAction',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createClusterBootstrapAction(request: CreateClusterBootstrapActionRequest): CreateClusterBootstrapActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterBootstrapActionWithOptions(request, runtime);
}

model CreateClusterTemplateRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateName?: string(name='TemplateName'),
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
  logPath?: string(name='LogPath'),
  securityGroupId?: string(name='SecurityGroupId'),
  isOpenPublicIp?: boolean(name='IsOpenPublicIp'),
  securityGroupName?: string(name='SecurityGroupName'),
  period?: int32(name='Period'),
  autoRenew?: boolean(name='AutoRenew'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  netType?: string(name='NetType'),
  userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
  emrVer?: string(name='EmrVer'),
  clusterType?: string(name='ClusterType'),
  highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
  useLocalMetaDb?: boolean(name='UseLocalMetaDb'),
  ioOptimized?: boolean(name='IoOptimized'),
  sshEnable?: boolean(name='SshEnable'),
  instanceGeneration?: string(name='InstanceGeneration'),
  masterPwd?: string(name='MasterPwd'),
  keyPairName?: string(name='KeyPairName'),
  metaStoreType?: string(name='MetaStoreType'),
  metaStoreConf?: string(name='MetaStoreConf'),
  configurations?: string(name='Configurations'),
  easEnable?: boolean(name='EasEnable'),
  depositType?: string(name='DepositType'),
  machineType?: string(name='MachineType'),
  useCustomHiveMetaDb?: boolean(name='UseCustomHiveMetaDb'),
  initCustomHiveMetaDb?: boolean(name='InitCustomHiveMetaDb'),
  resourceGroupId?: string(name='ResourceGroupId'),
  optionSoftWareList?: [ string ](name='OptionSoftWareList'),
  hostGroup?: [ 
    {
      sysDiskCapacity?: int32(name='SysDiskCapacity'),
      hostGroupType?: string(name='HostGroupType'),
      comment?: string(name='Comment'),
      multiInstanceTypes?: string(name='MultiInstanceTypes'),
      sysDiskType?: string(name='SysDiskType'),
      autoRenew?: boolean(name='AutoRenew'),
      chargeType?: string(name='ChargeType'),
      diskType?: string(name='DiskType'),
      hostGroupId?: string(name='HostGroupId'),
      instanceType?: string(name='InstanceType'),
      diskCount?: int32(name='DiskCount'),
      createType?: string(name='CreateType'),
      period?: int32(name='Period'),
      diskCapacity?: int32(name='DiskCapacity'),
      vSwitchId?: string(name='VSwitchId'),
      nodeCount?: int32(name='NodeCount'),
      hostGroupName?: string(name='HostGroupName'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='HostGroup'),
  bootstrapAction?: [ 
    {
      executionFailStrategy?: string(name='ExecutionFailStrategy'),
      arg?: string(name='Arg'),
      path?: string(name='Path'),
      executionTarget?: string(name='ExecutionTarget'),
      executionMoment?: string(name='ExecutionMoment'),
      name?: string(name='Name'),
    }
  ](name='BootstrapAction'),
  config?: [ 
    {
      configValue?: string(name='ConfigValue'),
      replace?: string(name='Replace'),
      fileName?: string(name='FileName'),
      serviceName?: string(name='ServiceName'),
      configKey?: string(name='ConfigKey'),
      encrypt?: string(name='Encrypt'),
    }
  ](name='Config'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model CreateClusterTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  clusterTemplateId?: string(name='ClusterTemplateId'),
}

model CreateClusterTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterTemplateResponseBody(name='body'),
}

async function createClusterTemplateWithOptions(request: CreateClusterTemplateRequest, runtime: Util.RuntimeOptions): CreateClusterTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TemplateName"] = request.templateName;
  query["RegionId"] = request.regionId;
  query["ZoneId"] = request.zoneId;
  query["LogPath"] = request.logPath;
  query["SecurityGroupId"] = request.securityGroupId;
  query["IsOpenPublicIp"] = request.isOpenPublicIp;
  query["SecurityGroupName"] = request.securityGroupName;
  query["Period"] = request.period;
  query["AutoRenew"] = request.autoRenew;
  query["VpcId"] = request.vpcId;
  query["VSwitchId"] = request.vSwitchId;
  query["NetType"] = request.netType;
  query["UserDefinedEmrEcsRole"] = request.userDefinedEmrEcsRole;
  query["EmrVer"] = request.emrVer;
  query["ClusterType"] = request.clusterType;
  query["HighAvailabilityEnable"] = request.highAvailabilityEnable;
  query["UseLocalMetaDb"] = request.useLocalMetaDb;
  query["IoOptimized"] = request.ioOptimized;
  query["SshEnable"] = request.sshEnable;
  query["InstanceGeneration"] = request.instanceGeneration;
  query["MasterPwd"] = request.masterPwd;
  query["KeyPairName"] = request.keyPairName;
  query["MetaStoreType"] = request.metaStoreType;
  query["MetaStoreConf"] = request.metaStoreConf;
  query["Configurations"] = request.configurations;
  query["EasEnable"] = request.easEnable;
  query["DepositType"] = request.depositType;
  query["MachineType"] = request.machineType;
  query["UseCustomHiveMetaDb"] = request.useCustomHiveMetaDb;
  query["InitCustomHiveMetaDb"] = request.initCustomHiveMetaDb;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["OptionSoftWareList"] = request.optionSoftWareList;
  query["HostGroup"] = request.hostGroup;
  query["BootstrapAction"] = request.bootstrapAction;
  query["Config"] = request.config;
  query["Tag"] = request.tag;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateClusterTemplate',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createClusterTemplate(request: CreateClusterTemplateRequest): CreateClusterTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterTemplateWithOptions(request, runtime);
}

model CreateClusterV2Request {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
  logPath?: string(name='LogPath'),
  securityGroupId?: string(name='SecurityGroupId'),
  isOpenPublicIp?: boolean(name='IsOpenPublicIp'),
  securityGroupName?: string(name='SecurityGroupName'),
  chargeType?: string(name='ChargeType'),
  period?: int32(name='Period'),
  autoRenew?: boolean(name='AutoRenew'),
  autoPayOrder?: boolean(name='AutoPayOrder'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  netType?: string(name='NetType'),
  userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
  emrVer?: string(name='EmrVer'),
  clusterType?: string(name='ClusterType'),
  highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
  useLocalMetaDb?: boolean(name='UseLocalMetaDb'),
  ioOptimized?: boolean(name='IoOptimized'),
  sshEnable?: boolean(name='SshEnable'),
  instanceGeneration?: string(name='InstanceGeneration'),
  masterPwd?: string(name='MasterPwd'),
  keyPairName?: string(name='KeyPairName'),
  metaStoreType?: string(name='MetaStoreType'),
  metaStoreConf?: string(name='MetaStoreConf'),
  clickHouseConf?: string(name='ClickHouseConf'),
  extraAttributes?: string(name='ExtraAttributes'),
  depositType?: string(name='DepositType'),
  machineType?: string(name='MachineType'),
  useCustomHiveMetaDB?: boolean(name='UseCustomHiveMetaDB'),
  initCustomHiveMetaDB?: boolean(name='InitCustomHiveMetaDB'),
  configurations?: string(name='Configurations'),
  easEnable?: boolean(name='EasEnable'),
  relatedClusterId?: string(name='RelatedClusterId'),
  whiteListType?: string(name='WhiteListType'),
  authorizeContent?: string(name='AuthorizeContent'),
  resourceGroupId?: string(name='ResourceGroupId'),
  optionSoftWareList?: [ string ](name='OptionSoftWareList'),
  userInfo?: [ 
    {
      password?: string(name='Password'),
      userId?: string(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='UserInfo'),
  hostComponentInfo?: [ 
    {
      componentNameList?: [ string ](name='ComponentNameList'),
      hostName?: string(name='HostName'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='HostComponentInfo'),
  serviceInfo?: [ 
    {
      serviceVersion?: string(name='ServiceVersion'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='ServiceInfo'),
  promotionInfo?: [ 
    {
      promotionOptionNo?: string(name='PromotionOptionNo'),
      promotionOptionCode?: string(name='PromotionOptionCode'),
      productCode?: string(name='ProductCode'),
    }
  ](name='PromotionInfo'),
  hostGroup?: [ 
    {
      sysDiskCapacity?: int32(name='SysDiskCapacity'),
      hostGroupType?: string(name='HostGroupType'),
      comment?: string(name='Comment'),
      sysDiskType?: string(name='SysDiskType'),
      autoRenew?: boolean(name='AutoRenew'),
      chargeType?: string(name='ChargeType'),
      gpuDriver?: string(name='GpuDriver'),
      diskType?: string(name='DiskType'),
      hostGroupId?: string(name='HostGroupId'),
      instanceType?: string(name='InstanceType'),
      diskCount?: int32(name='DiskCount'),
      createType?: string(name='CreateType'),
      period?: int32(name='Period'),
      diskCapacity?: int32(name='DiskCapacity'),
      vSwitchId?: string(name='VSwitchId'),
      nodeCount?: int32(name='NodeCount'),
      hostGroupName?: string(name='HostGroupName'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='HostGroup'),
  bootstrapAction?: [ 
    {
      executionFailStrategy?: string(name='ExecutionFailStrategy'),
      arg?: string(name='Arg'),
      path?: string(name='Path'),
      executionTarget?: string(name='ExecutionTarget'),
      executionMoment?: string(name='ExecutionMoment'),
      name?: string(name='Name'),
    }
  ](name='BootstrapAction'),
  config?: [ 
    {
      configValue?: string(name='ConfigValue'),
      replace?: string(name='Replace'),
      fileName?: string(name='FileName'),
      serviceName?: string(name='ServiceName'),
      configKey?: string(name='ConfigKey'),
      encrypt?: string(name='Encrypt'),
    }
  ](name='Config'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model CreateClusterV2ResponseBody = {
  masterOrderId?: string(name='MasterOrderId'),
  coreOrderId?: string(name='CoreOrderId'),
  requestId?: string(name='RequestId'),
  emrOrderId?: string(name='EmrOrderId'),
  clusterId?: string(name='ClusterId'),
}

model CreateClusterV2Response = {
  headers: map[string]string(name='headers'),
  body: CreateClusterV2ResponseBody(name='body'),
}

async function createClusterV2WithOptions(request: CreateClusterV2Request, runtime: Util.RuntimeOptions): CreateClusterV2Response {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Name"] = request.name;
  query["RegionId"] = request.regionId;
  query["ZoneId"] = request.zoneId;
  query["LogPath"] = request.logPath;
  query["SecurityGroupId"] = request.securityGroupId;
  query["IsOpenPublicIp"] = request.isOpenPublicIp;
  query["SecurityGroupName"] = request.securityGroupName;
  query["ChargeType"] = request.chargeType;
  query["Period"] = request.period;
  query["AutoRenew"] = request.autoRenew;
  query["AutoPayOrder"] = request.autoPayOrder;
  query["VpcId"] = request.vpcId;
  query["VSwitchId"] = request.vSwitchId;
  query["NetType"] = request.netType;
  query["UserDefinedEmrEcsRole"] = request.userDefinedEmrEcsRole;
  query["EmrVer"] = request.emrVer;
  query["ClusterType"] = request.clusterType;
  query["HighAvailabilityEnable"] = request.highAvailabilityEnable;
  query["UseLocalMetaDb"] = request.useLocalMetaDb;
  query["IoOptimized"] = request.ioOptimized;
  query["SshEnable"] = request.sshEnable;
  query["InstanceGeneration"] = request.instanceGeneration;
  query["MasterPwd"] = request.masterPwd;
  query["KeyPairName"] = request.keyPairName;
  query["MetaStoreType"] = request.metaStoreType;
  query["MetaStoreConf"] = request.metaStoreConf;
  query["ClickHouseConf"] = request.clickHouseConf;
  query["ExtraAttributes"] = request.extraAttributes;
  query["DepositType"] = request.depositType;
  query["MachineType"] = request.machineType;
  query["UseCustomHiveMetaDB"] = request.useCustomHiveMetaDB;
  query["InitCustomHiveMetaDB"] = request.initCustomHiveMetaDB;
  query["Configurations"] = request.configurations;
  query["EasEnable"] = request.easEnable;
  query["RelatedClusterId"] = request.relatedClusterId;
  query["WhiteListType"] = request.whiteListType;
  query["AuthorizeContent"] = request.authorizeContent;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["OptionSoftWareList"] = request.optionSoftWareList;
  query["UserInfo"] = request.userInfo;
  query["HostComponentInfo"] = request.hostComponentInfo;
  query["ServiceInfo"] = request.serviceInfo;
  query["PromotionInfo"] = request.promotionInfo;
  query["HostGroup"] = request.hostGroup;
  query["BootstrapAction"] = request.bootstrapAction;
  query["Config"] = request.config;
  query["Tag"] = request.tag;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateClusterV2',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createClusterV2(request: CreateClusterV2Request): CreateClusterV2Response {
  var runtime = new Util.RuntimeOptions{};
  return createClusterV2WithOptions(request, runtime);
}

model CreateClusterWithTemplateRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateBizId?: string(name='TemplateBizId'),
  uniqueTag?: string(name='UniqueTag'),
  clusterName?: string(name='ClusterName'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateClusterWithTemplateResponseBody = {
  masterOrderId?: string(name='MasterOrderId'),
  coreOrderId?: string(name='CoreOrderId'),
  requestId?: string(name='RequestId'),
  emrOrderId?: string(name='EmrOrderId'),
  clusterId?: string(name='ClusterId'),
}

model CreateClusterWithTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterWithTemplateResponseBody(name='body'),
}

async function createClusterWithTemplateWithOptions(request: CreateClusterWithTemplateRequest, runtime: Util.RuntimeOptions): CreateClusterWithTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TemplateBizId"] = request.templateBizId;
  query["UniqueTag"] = request.uniqueTag;
  query["ClusterName"] = request.clusterName;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateClusterWithTemplate',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createClusterWithTemplate(request: CreateClusterWithTemplateRequest): CreateClusterWithTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterWithTemplateWithOptions(request, runtime);
}

model CreateDataSourceRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  sourceType?: string(name='SourceType'),
  description?: string(name='Description'),
  conf?: string(name='Conf'),
  clusterId?: string(name='ClusterId'),
  navParentId?: string(name='NavParentId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateDataSourceResponseBody = {
  requestId?: string(name='RequestId'),
  id?: string(name='Id'),
}

model CreateDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataSourceResponseBody(name='body'),
}

async function createDataSourceWithOptions(request: CreateDataSourceRequest, runtime: Util.RuntimeOptions): CreateDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Name"] = request.name;
  query["SourceType"] = request.sourceType;
  query["Description"] = request.description;
  query["Conf"] = request.conf;
  query["ClusterId"] = request.clusterId;
  query["NavParentId"] = request.navParentId;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataSource',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDataSource(request: CreateDataSourceRequest): CreateDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataSourceWithOptions(request, runtime);
}

model CreateExecutionPlanRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  strategy?: string(name='Strategy'),
  timeInterval?: int32(name='TimeInterval'),
  startTime?: long(name='StartTime'),
  timeUnit?: string(name='TimeUnit'),
  dayOfWeek?: string(name='DayOfWeek'),
  dayOfMonth?: string(name='DayOfMonth'),
  clusterId?: string(name='ClusterId'),
  createClusterOnDemand?: boolean(name='CreateClusterOnDemand'),
  clusterName?: string(name='ClusterName'),
  zoneId?: string(name='ZoneId'),
  logEnable?: boolean(name='LogEnable'),
  logPath?: string(name='LogPath'),
  securityGroupId?: string(name='SecurityGroupId'),
  isOpenPublicIp?: boolean(name='IsOpenPublicIp'),
  emrVer?: string(name='EmrVer'),
  clusterType?: string(name='ClusterType'),
  highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
  useLocalMetaDb?: boolean(name='UseLocalMetaDb'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  netType?: string(name='NetType'),
  userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
  ioOptimized?: boolean(name='IoOptimized'),
  instanceGeneration?: string(name='InstanceGeneration'),
  useCustomHiveMetaDB?: boolean(name='UseCustomHiveMetaDB'),
  initCustomHiveMetaDB?: boolean(name='InitCustomHiveMetaDB'),
  configurations?: string(name='Configurations'),
  easEnable?: boolean(name='EasEnable'),
  workflowDefinition?: string(name='WorkflowDefinition'),
  jobIdList?: [ string ](name='JobIdList'),
  optionSoftWareList?: [ string ](name='OptionSoftWareList'),
  ecsOrder?: [ 
    {
      index?: int32(name='Index'),
      diskCapacity?: int32(name='DiskCapacity'),
      nodeType?: string(name='NodeType'),
      nodeCount?: int32(name='NodeCount'),
      diskType?: string(name='DiskType'),
      instanceType?: string(name='InstanceType'),
      diskCount?: int32(name='DiskCount'),
    }
  ](name='EcsOrder'),
  bootstrapAction?: [ 
    {
      executionFailStrategy?: string(name='ExecutionFailStrategy'),
      arg?: string(name='Arg'),
      path?: string(name='Path'),
      executionTarget?: string(name='ExecutionTarget'),
      executionMoment?: string(name='ExecutionMoment'),
      name?: string(name='Name'),
    }
  ](name='BootstrapAction'),
  config?: [ 
    {
      configValue?: string(name='ConfigValue'),
      replace?: string(name='Replace'),
      fileName?: string(name='FileName'),
      serviceName?: string(name='ServiceName'),
      configKey?: string(name='ConfigKey'),
      encrypt?: string(name='Encrypt'),
    }
  ](name='Config'),
}

model CreateExecutionPlanResponseBody = {
  requestId?: string(name='RequestId'),
  id?: string(name='Id'),
}

model CreateExecutionPlanResponse = {
  headers: map[string]string(name='headers'),
  body: CreateExecutionPlanResponseBody(name='body'),
}

async function createExecutionPlanWithOptions(request: CreateExecutionPlanRequest, runtime: Util.RuntimeOptions): CreateExecutionPlanResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Name"] = request.name;
  query["Strategy"] = request.strategy;
  query["TimeInterval"] = request.timeInterval;
  query["StartTime"] = request.startTime;
  query["TimeUnit"] = request.timeUnit;
  query["DayOfWeek"] = request.dayOfWeek;
  query["DayOfMonth"] = request.dayOfMonth;
  query["ClusterId"] = request.clusterId;
  query["CreateClusterOnDemand"] = request.createClusterOnDemand;
  query["ClusterName"] = request.clusterName;
  query["ZoneId"] = request.zoneId;
  query["LogEnable"] = request.logEnable;
  query["LogPath"] = request.logPath;
  query["SecurityGroupId"] = request.securityGroupId;
  query["IsOpenPublicIp"] = request.isOpenPublicIp;
  query["EmrVer"] = request.emrVer;
  query["ClusterType"] = request.clusterType;
  query["HighAvailabilityEnable"] = request.highAvailabilityEnable;
  query["UseLocalMetaDb"] = request.useLocalMetaDb;
  query["VpcId"] = request.vpcId;
  query["VSwitchId"] = request.vSwitchId;
  query["NetType"] = request.netType;
  query["UserDefinedEmrEcsRole"] = request.userDefinedEmrEcsRole;
  query["IoOptimized"] = request.ioOptimized;
  query["InstanceGeneration"] = request.instanceGeneration;
  query["UseCustomHiveMetaDB"] = request.useCustomHiveMetaDB;
  query["InitCustomHiveMetaDB"] = request.initCustomHiveMetaDB;
  query["Configurations"] = request.configurations;
  query["EasEnable"] = request.easEnable;
  query["WorkflowDefinition"] = request.workflowDefinition;
  query["JobIdList"] = request.jobIdList;
  query["OptionSoftWareList"] = request.optionSoftWareList;
  query["EcsOrder"] = request.ecsOrder;
  query["BootstrapAction"] = request.bootstrapAction;
  query["Config"] = request.config;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateExecutionPlan',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createExecutionPlan(request: CreateExecutionPlanRequest): CreateExecutionPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return createExecutionPlanWithOptions(request, runtime);
}

model CreateFlowRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  startSchedule?: long(name='StartSchedule'),
  endSchedule?: long(name='EndSchedule'),
  cronExpr?: string(name='CronExpr'),
  createCluster?: boolean(name='CreateCluster'),
  clusterId?: string(name='ClusterId'),
  hostName?: string(name='HostName'),
  namespace?: string(name='Namespace'),
  logArchiveLocation?: string(name='LogArchiveLocation'),
  lifecycle?: string(name='Lifecycle'),
  application?: string(name='Application'),
  alertConf?: string(name='AlertConf'),
  alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
  alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
  parentFlowList?: string(name='ParentFlowList'),
  parentCategory?: string(name='ParentCategory'),
}

model CreateFlowResponseBody = {
  requestId?: string(name='RequestId'),
  id?: string(name='Id'),
}

model CreateFlowResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowResponseBody(name='body'),
}

async function createFlowWithOptions(request: CreateFlowRequest, runtime: Util.RuntimeOptions): CreateFlowResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["Name"] = request.name;
  query["Description"] = request.description;
  query["StartSchedule"] = request.startSchedule;
  query["EndSchedule"] = request.endSchedule;
  query["CronExpr"] = request.cronExpr;
  query["CreateCluster"] = request.createCluster;
  query["ClusterId"] = request.clusterId;
  query["HostName"] = request.hostName;
  query["Namespace"] = request.namespace;
  query["LogArchiveLocation"] = request.logArchiveLocation;
  query["Lifecycle"] = request.lifecycle;
  query["Application"] = request.application;
  query["AlertConf"] = request.alertConf;
  query["AlertUserGroupBizId"] = request.alertUserGroupBizId;
  query["AlertDingDingGroupBizId"] = request.alertDingDingGroupBizId;
  query["ParentFlowList"] = request.parentFlowList;
  query["ParentCategory"] = request.parentCategory;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlow',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFlow(request: CreateFlowRequest): CreateFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowWithOptions(request, runtime);
}

model CreateFlowCategoryRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  name?: string(name='Name'),
  type?: string(name='Type'),
  parentId?: string(name='ParentId'),
}

model CreateFlowCategoryResponseBody = {
  requestId?: string(name='RequestId'),
  id?: string(name='Id'),
}

model CreateFlowCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowCategoryResponseBody(name='body'),
}

async function createFlowCategoryWithOptions(request: CreateFlowCategoryRequest, runtime: Util.RuntimeOptions): CreateFlowCategoryResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["Name"] = request.name;
  query["Type"] = request.type;
  query["ParentId"] = request.parentId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlowCategory',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFlowCategory(request: CreateFlowCategoryRequest): CreateFlowCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowCategoryWithOptions(request, runtime);
}

model CreateFlowForWebRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  startSchedule?: long(name='StartSchedule'),
  endSchedule?: long(name='EndSchedule'),
  cronExpr?: string(name='CronExpr'),
  createCluster?: boolean(name='CreateCluster'),
  clusterId?: string(name='ClusterId'),
  hostName?: string(name='HostName'),
  namespace?: string(name='Namespace'),
  logArchiveLocation?: string(name='LogArchiveLocation'),
  lifecycle?: string(name='Lifecycle'),
  graph?: string(name='Graph'),
  alertConf?: string(name='AlertConf'),
  alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
  alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
  parentFlowList?: string(name='ParentFlowList'),
  parentCategory?: string(name='ParentCategory'),
}

model CreateFlowForWebResponseBody = {
  requestId?: string(name='RequestId'),
  id?: string(name='Id'),
}

model CreateFlowForWebResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowForWebResponseBody(name='body'),
}

async function createFlowForWebWithOptions(request: CreateFlowForWebRequest, runtime: Util.RuntimeOptions): CreateFlowForWebResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["Name"] = request.name;
  query["Description"] = request.description;
  query["StartSchedule"] = request.startSchedule;
  query["EndSchedule"] = request.endSchedule;
  query["CronExpr"] = request.cronExpr;
  query["CreateCluster"] = request.createCluster;
  query["ClusterId"] = request.clusterId;
  query["HostName"] = request.hostName;
  query["Namespace"] = request.namespace;
  query["LogArchiveLocation"] = request.logArchiveLocation;
  query["Lifecycle"] = request.lifecycle;
  query["Graph"] = request.graph;
  query["AlertConf"] = request.alertConf;
  query["AlertUserGroupBizId"] = request.alertUserGroupBizId;
  query["AlertDingDingGroupBizId"] = request.alertDingDingGroupBizId;
  query["ParentFlowList"] = request.parentFlowList;
  query["ParentCategory"] = request.parentCategory;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlowForWeb',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFlowForWeb(request: CreateFlowForWebRequest): CreateFlowForWebResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowForWebWithOptions(request, runtime);
}

model CreateFlowJobRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  type?: string(name='Type'),
  failAct?: string(name='FailAct'),
  maxRetry?: int32(name='MaxRetry'),
  retryPolicy?: string(name='RetryPolicy'),
  maxRunningTimeSec?: long(name='MaxRunningTimeSec'),
  retryInterval?: long(name='RetryInterval'),
  params?: string(name='Params'),
  paramConf?: string(name='ParamConf'),
  customVariables?: string(name='CustomVariables'),
  envConf?: string(name='EnvConf'),
  runConf?: string(name='RunConf'),
  monitorConf?: string(name='MonitorConf'),
  mode?: string(name='Mode'),
  parentCategory?: string(name='ParentCategory'),
  adhoc?: boolean(name='Adhoc'),
  clusterId?: string(name='ClusterId'),
  alertConf?: string(name='AlertConf'),
  resourceList?: [ 
    {
      path?: string(name='Path'),
      alias?: string(name='Alias'),
    }
  ](name='ResourceList'),
}

model CreateFlowJobResponseBody = {
  requestId?: string(name='RequestId'),
  id?: string(name='Id'),
}

model CreateFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowJobResponseBody(name='body'),
}

async function createFlowJobWithOptions(request: CreateFlowJobRequest, runtime: Util.RuntimeOptions): CreateFlowJobResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["Name"] = request.name;
  query["Type"] = request.type;
  query["FailAct"] = request.failAct;
  query["MaxRetry"] = request.maxRetry;
  query["RetryPolicy"] = request.retryPolicy;
  query["MaxRunningTimeSec"] = request.maxRunningTimeSec;
  query["RetryInterval"] = request.retryInterval;
  query["Mode"] = request.mode;
  query["ParentCategory"] = request.parentCategory;
  query["Adhoc"] = request.adhoc;
  query["ClusterId"] = request.clusterId;
  query["AlertConf"] = request.alertConf;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlowJob',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFlowJob(request: CreateFlowJobRequest): CreateFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowJobWithOptions(request, runtime);
}

model CreateFlowProjectRequest {
  productType?: string(name='ProductType'),
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateFlowProjectResponseBody = {
  requestId?: string(name='RequestId'),
  id?: string(name='Id'),
}

model CreateFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowProjectResponseBody(name='body'),
}

async function createFlowProjectWithOptions(request: CreateFlowProjectRequest, runtime: Util.RuntimeOptions): CreateFlowProjectResponse {
  Util.validateModel(request);
  var query = {};
  query["ProductType"] = request.productType;
  query["RegionId"] = request.regionId;
  query["Name"] = request.name;
  query["Description"] = request.description;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlowProject',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFlowProject(request: CreateFlowProjectRequest): CreateFlowProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowProjectWithOptions(request, runtime);
}

model CreateFlowProjectClusterSettingRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  clusterId?: string(name='ClusterId'),
  defaultUser?: string(name='DefaultUser'),
  defaultQueue?: string(name='DefaultQueue'),
  userList?: [ string ](name='UserList'),
  queueList?: [ string ](name='QueueList'),
  hostList?: [ string ](name='HostList'),
}

model CreateFlowProjectClusterSettingResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model CreateFlowProjectClusterSettingResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowProjectClusterSettingResponseBody(name='body'),
}

async function createFlowProjectClusterSettingWithOptions(request: CreateFlowProjectClusterSettingRequest, runtime: Util.RuntimeOptions): CreateFlowProjectClusterSettingResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["ClusterId"] = request.clusterId;
  query["DefaultUser"] = request.defaultUser;
  query["DefaultQueue"] = request.defaultQueue;
  query["UserList"] = request.userList;
  query["QueueList"] = request.queueList;
  query["HostList"] = request.hostList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlowProjectClusterSetting',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFlowProjectClusterSetting(request: CreateFlowProjectClusterSettingRequest): CreateFlowProjectClusterSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowProjectClusterSettingWithOptions(request, runtime);
}

model CreateFlowProjectUserRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  user?: [ 
    {
      userId?: string(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='User'),
}

model CreateFlowProjectUserResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model CreateFlowProjectUserResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowProjectUserResponseBody(name='body'),
}

async function createFlowProjectUserWithOptions(request: CreateFlowProjectUserRequest, runtime: Util.RuntimeOptions): CreateFlowProjectUserResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["User"] = request.user;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlowProjectUser',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFlowProjectUser(request: CreateFlowProjectUserRequest): CreateFlowProjectUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowProjectUserWithOptions(request, runtime);
}

model CreateJobRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
  runParameter?: string(name='RunParameter'),
  failAct?: string(name='FailAct'),
  maxRetry?: int32(name='MaxRetry'),
  retryInterval?: int32(name='RetryInterval'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateJobResponseBody = {
  requestId?: string(name='RequestId'),
  id?: string(name='Id'),
}

model CreateJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateJobResponseBody(name='body'),
}

async function createJobWithOptions(request: CreateJobRequest, runtime: Util.RuntimeOptions): CreateJobResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Name"] = request.name;
  query["RegionId"] = request.regionId;
  query["Type"] = request.type;
  query["RunParameter"] = request.runParameter;
  query["FailAct"] = request.failAct;
  query["MaxRetry"] = request.maxRetry;
  query["RetryInterval"] = request.retryInterval;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateJob',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createJob(request: CreateJobRequest): CreateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobWithOptions(request, runtime);
}

model CreateLibraryRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
  name?: string(name='Name'),
  libraryVersion?: string(name='LibraryVersion'),
  sourceType?: string(name='SourceType'),
  sourceLocation?: string(name='SourceLocation'),
  scope?: string(name='Scope'),
  properties?: string(name='Properties'),
}

model CreateLibraryResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model CreateLibraryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLibraryResponseBody(name='body'),
}

async function createLibraryWithOptions(request: CreateLibraryRequest, runtime: Util.RuntimeOptions): CreateLibraryResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Type"] = request.type;
  query["Name"] = request.name;
  query["LibraryVersion"] = request.libraryVersion;
  query["SourceType"] = request.sourceType;
  query["SourceLocation"] = request.sourceLocation;
  query["Scope"] = request.scope;
  query["Properties"] = request.properties;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateLibrary',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLibrary(request: CreateLibraryRequest): CreateLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLibraryWithOptions(request, runtime);
}

model CreateMetaTablePreviewTaskRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  databaseId?: string(name='DatabaseId'),
  tableId?: string(name='TableId'),
  user?: string(name='User'),
  password?: string(name='Password'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateMetaTablePreviewTaskResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
}

model CreateMetaTablePreviewTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMetaTablePreviewTaskResponseBody(name='body'),
}

async function createMetaTablePreviewTaskWithOptions(request: CreateMetaTablePreviewTaskRequest, runtime: Util.RuntimeOptions): CreateMetaTablePreviewTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["DatabaseId"] = request.databaseId;
  query["TableId"] = request.tableId;
  query["User"] = request.user;
  query["Password"] = request.password;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateMetaTablePreviewTask',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMetaTablePreviewTask(request: CreateMetaTablePreviewTaskRequest): CreateMetaTablePreviewTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMetaTablePreviewTaskWithOptions(request, runtime);
}

model CreateResourcePoolRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  clusterId?: string(name='ClusterId'),
  poolType?: string(name='PoolType'),
  active?: boolean(name='Active'),
  note?: string(name='Note'),
  yarnSiteConfig?: string(name='YarnSiteConfig'),
  config?: [ 
    {
      configType?: string(name='configType'),
      configValue?: string(name='ConfigValue'),
      targetId?: string(name='TargetId'),
      note?: string(name='Note'),
      category?: string(name='Category'),
      configKey?: string(name='ConfigKey'),
    }
  ](name='Config'),
}

model CreateResourcePoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateResourcePoolResponse = {
  headers: map[string]string(name='headers'),
  body: CreateResourcePoolResponseBody(name='body'),
}

async function createResourcePoolWithOptions(request: CreateResourcePoolRequest, runtime: Util.RuntimeOptions): CreateResourcePoolResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Name"] = request.name;
  query["ClusterId"] = request.clusterId;
  query["PoolType"] = request.poolType;
  query["Active"] = request.active;
  query["Note"] = request.note;
  query["YarnSiteConfig"] = request.yarnSiteConfig;
  query["Config"] = request.config;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourcePool',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createResourcePool(request: CreateResourcePoolRequest): CreateResourcePoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return createResourcePoolWithOptions(request, runtime);
}

model CreateResourceQueueRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  qualifiedName?: string(name='QualifiedName'),
  clusterId?: string(name='ClusterId'),
  parentQueueId?: long(name='ParentQueueId'),
  leaf?: boolean(name='Leaf'),
  resourcePoolId?: long(name='ResourcePoolId'),
  config?: [ 
    {
      configValue?: string(name='ConfigValue'),
      note?: string(name='Note'),
      category?: string(name='Category'),
      configKey?: string(name='ConfigKey'),
    }
  ](name='Config'),
}

model CreateResourceQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateResourceQueueResponse = {
  headers: map[string]string(name='headers'),
  body: CreateResourceQueueResponseBody(name='body'),
}

async function createResourceQueueWithOptions(request: CreateResourceQueueRequest, runtime: Util.RuntimeOptions): CreateResourceQueueResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Name"] = request.name;
  query["QualifiedName"] = request.qualifiedName;
  query["ClusterId"] = request.clusterId;
  query["ParentQueueId"] = request.parentQueueId;
  query["Leaf"] = request.leaf;
  query["ResourcePoolId"] = request.resourcePoolId;
  query["Config"] = request.config;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourceQueue',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createResourceQueue(request: CreateResourceQueueRequest): CreateResourceQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return createResourceQueueWithOptions(request, runtime);
}

model CreateScalingGroupV2Request {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  hostGroupId?: string(name='HostGroupId'),
}

model CreateScalingGroupV2ResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model CreateScalingGroupV2Response = {
  headers: map[string]string(name='headers'),
  body: CreateScalingGroupV2ResponseBody(name='body'),
}

async function createScalingGroupV2WithOptions(request: CreateScalingGroupV2Request, runtime: Util.RuntimeOptions): CreateScalingGroupV2Response {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["Name"] = request.name;
  query["Description"] = request.description;
  query["HostGroupId"] = request.hostGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateScalingGroupV2',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createScalingGroupV2(request: CreateScalingGroupV2Request): CreateScalingGroupV2Response {
  var runtime = new Util.RuntimeOptions{};
  return createScalingGroupV2WithOptions(request, runtime);
}

model CreateScalingRuleRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostGroupId?: string(name='HostGroupId'),
  ruleCategory?: string(name='RuleCategory'),
  ruleName?: string(name='RuleName'),
  adjustmentType?: string(name='AdjustmentType'),
  adjustmentValue?: int32(name='AdjustmentValue'),
  cooldown?: int32(name='Cooldown'),
  launchTime?: string(name='LaunchTime'),
  launchExpirationTime?: int32(name='LaunchExpirationTime'),
  recurrenceType?: string(name='RecurrenceType'),
  recurrenceValue?: string(name='RecurrenceValue'),
  recurrenceEndTime?: string(name='RecurrenceEndTime'),
  withGrace?: boolean(name='WithGrace'),
  timeoutWithGrace?: long(name='TimeoutWithGrace'),
  schedulerTrigger?: [ 
    {
      launchExpirationTime?: int32(name='LaunchExpirationTime'),
      recurrenceValue?: string(name='RecurrenceValue'),
      recurrenceType?: string(name='RecurrenceType'),
      recurrenceEndTime?: string(name='RecurrenceEndTime'),
      launchTime?: string(name='LaunchTime'),
    }
  ](name='SchedulerTrigger'),
  cloudWatchTrigger?: [ 
    {
      comparisonOperator?: string(name='ComparisonOperator'),
      metricName?: string(name='MetricName'),
      evaluationCount?: string(name='EvaluationCount'),
      threshold?: string(name='Threshold'),
      period?: int32(name='Period'),
      statistics?: string(name='Statistics'),
    }
  ](name='CloudWatchTrigger'),
}

model CreateScalingRuleResponseBody = {
  requestId?: string(name='RequestId'),
  scalingRuleId?: string(name='ScalingRuleId'),
}

model CreateScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateScalingRuleResponseBody(name='body'),
}

async function createScalingRuleWithOptions(request: CreateScalingRuleRequest, runtime: Util.RuntimeOptions): CreateScalingRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["HostGroupId"] = request.hostGroupId;
  query["RuleCategory"] = request.ruleCategory;
  query["RuleName"] = request.ruleName;
  query["AdjustmentType"] = request.adjustmentType;
  query["AdjustmentValue"] = request.adjustmentValue;
  query["Cooldown"] = request.cooldown;
  query["LaunchTime"] = request.launchTime;
  query["LaunchExpirationTime"] = request.launchExpirationTime;
  query["RecurrenceType"] = request.recurrenceType;
  query["RecurrenceValue"] = request.recurrenceValue;
  query["RecurrenceEndTime"] = request.recurrenceEndTime;
  query["WithGrace"] = request.withGrace;
  query["TimeoutWithGrace"] = request.timeoutWithGrace;
  query["SchedulerTrigger"] = request.schedulerTrigger;
  query["CloudWatchTrigger"] = request.cloudWatchTrigger;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateScalingRule',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createScalingRule(request: CreateScalingRuleRequest): CreateScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createScalingRuleWithOptions(request, runtime);
}

model CreateTagRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: long(name='Id'),
  name?: string(name='Name'),
  category?: string(name='Category'),
  description?: string(name='Description'),
}

model CreateTagResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model CreateTagResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTagResponseBody(name='body'),
}

async function createTagWithOptions(request: CreateTagRequest, runtime: Util.RuntimeOptions): CreateTagResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Id"] = request.id;
  query["Name"] = request.name;
  query["Category"] = request.category;
  query["Description"] = request.description;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateTag',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTag(request: CreateTagRequest): CreateTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTagWithOptions(request, runtime);
}

model CreateUserRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  aliyunUserId?: string(name='AliyunUserId'),
  userName?: string(name='UserName'),
  userType?: string(name='UserType'),
  status?: string(name='Status'),
  description?: string(name='Description'),
  roleIdList?: [ integer ](name='RoleIdList'),
  groupIdList?: [ integer ](name='GroupIdList'),
  userAccountParamList?: [ 
    {
      authType?: string(name='AuthType'),
      accountPassword?: string(name='AccountPassword'),
      accountType?: string(name='AccountType'),
    }
  ](name='UserAccountParamList'),
}

model CreateUserResponseBody = {
  requestId?: string(name='RequestId'),
  paging?: boolean(name='Paging'),
  data?: boolean(name='Data'),
}

model CreateUserResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUserResponseBody(name='body'),
}

async function createUserWithOptions(request: CreateUserRequest, runtime: Util.RuntimeOptions): CreateUserResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["AliyunUserId"] = request.aliyunUserId;
  query["UserName"] = request.userName;
  query["UserType"] = request.userType;
  query["Status"] = request.status;
  query["Description"] = request.description;
  query["RoleIdList"] = request.roleIdList;
  query["GroupIdList"] = request.groupIdList;
  query["UserAccountParamList"] = request.userAccountParamList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateUser',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserWithOptions(request, runtime);
}

model CreateUsersRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  userInfo?: [ 
    {
      type?: string(name='Type'),
      userId?: string(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='UserInfo'),
}

model CreateUsersResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateUsersResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUsersResponseBody(name='body'),
}

async function createUsersWithOptions(request: CreateUsersRequest, runtime: Util.RuntimeOptions): CreateUsersResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["UserInfo"] = request.userInfo;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateUsers',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUsers(request: CreateUsersRequest): CreateUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUsersWithOptions(request, runtime);
}

model DecommissionHostComponentRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostInstanceId?: string(name='HostInstanceId'),
  serviceName?: string(name='ServiceName'),
  componentName?: string(name='ComponentName'),
  timeoutSeconds?: long(name='TimeoutSeconds'),
}

model DecommissionHostComponentResponseBody = {
  requestId?: string(name='RequestId'),
}

model DecommissionHostComponentResponse = {
  headers: map[string]string(name='headers'),
  body: DecommissionHostComponentResponseBody(name='body'),
}

async function decommissionHostComponentWithOptions(request: DecommissionHostComponentRequest, runtime: Util.RuntimeOptions): DecommissionHostComponentResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["HostInstanceId"] = request.hostInstanceId;
  query["ServiceName"] = request.serviceName;
  query["ComponentName"] = request.componentName;
  query["TimeoutSeconds"] = request.timeoutSeconds;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DecommissionHostComponent',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function decommissionHostComponent(request: DecommissionHostComponentRequest): DecommissionHostComponentResponse {
  var runtime = new Util.RuntimeOptions{};
  return decommissionHostComponentWithOptions(request, runtime);
}

model DeleteClusterTemplateRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  bizId?: string(name='BizId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DeleteClusterTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteClusterTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterTemplateResponseBody(name='body'),
}

async function deleteClusterTemplateWithOptions(request: DeleteClusterTemplateRequest, runtime: Util.RuntimeOptions): DeleteClusterTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["BizId"] = request.bizId;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteClusterTemplate',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteClusterTemplate(request: DeleteClusterTemplateRequest): DeleteClusterTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterTemplateWithOptions(request, runtime);
}

model DeleteExecutionPlanRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: string(name='Id'),
}

model DeleteExecutionPlanResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExecutionPlanResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExecutionPlanResponseBody(name='body'),
}

async function deleteExecutionPlanWithOptions(request: DeleteExecutionPlanRequest, runtime: Util.RuntimeOptions): DeleteExecutionPlanResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Id"] = request.id;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteExecutionPlan',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteExecutionPlan(request: DeleteExecutionPlanRequest): DeleteExecutionPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExecutionPlanWithOptions(request, runtime);
}

model DeleteFlowRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model DeleteFlowResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model DeleteFlowResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowResponseBody(name='body'),
}

async function deleteFlowWithOptions(request: DeleteFlowRequest, runtime: Util.RuntimeOptions): DeleteFlowResponse {
  Util.validateModel(request);
  var query = {};
  query["Id"] = request.id;
  query["ProjectId"] = request.projectId;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlow',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFlow(request: DeleteFlowRequest): DeleteFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowWithOptions(request, runtime);
}

model DeleteFlowCategoryRequest {
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
}

model DeleteFlowCategoryResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model DeleteFlowCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowCategoryResponseBody(name='body'),
}

async function deleteFlowCategoryWithOptions(request: DeleteFlowCategoryRequest, runtime: Util.RuntimeOptions): DeleteFlowCategoryResponse {
  Util.validateModel(request);
  var query = {};
  query["Id"] = request.id;
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlowCategory',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFlowCategory(request: DeleteFlowCategoryRequest): DeleteFlowCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowCategoryWithOptions(request, runtime);
}

model DeleteFlowJobRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
}

model DeleteFlowJobResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model DeleteFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowJobResponseBody(name='body'),
}

async function deleteFlowJobWithOptions(request: DeleteFlowJobRequest, runtime: Util.RuntimeOptions): DeleteFlowJobResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["Id"] = request.id;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlowJob',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFlowJob(request: DeleteFlowJobRequest): DeleteFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowJobWithOptions(request, runtime);
}

model DeleteFlowProjectRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
}

model DeleteFlowProjectResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model DeleteFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowProjectResponseBody(name='body'),
}

async function deleteFlowProjectWithOptions(request: DeleteFlowProjectRequest, runtime: Util.RuntimeOptions): DeleteFlowProjectResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlowProject',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFlowProject(request: DeleteFlowProjectRequest): DeleteFlowProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowProjectWithOptions(request, runtime);
}

model DeleteFlowProjectClusterSettingRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  clusterId?: string(name='ClusterId'),
}

model DeleteFlowProjectClusterSettingResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model DeleteFlowProjectClusterSettingResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowProjectClusterSettingResponseBody(name='body'),
}

async function deleteFlowProjectClusterSettingWithOptions(request: DeleteFlowProjectClusterSettingRequest, runtime: Util.RuntimeOptions): DeleteFlowProjectClusterSettingResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["ClusterId"] = request.clusterId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlowProjectClusterSetting',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFlowProjectClusterSetting(request: DeleteFlowProjectClusterSettingRequest): DeleteFlowProjectClusterSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowProjectClusterSettingWithOptions(request, runtime);
}

model DeleteFlowProjectUserRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  userName?: string(name='UserName'),
}

model DeleteFlowProjectUserResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model DeleteFlowProjectUserResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowProjectUserResponseBody(name='body'),
}

async function deleteFlowProjectUserWithOptions(request: DeleteFlowProjectUserRequest, runtime: Util.RuntimeOptions): DeleteFlowProjectUserResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["UserName"] = request.userName;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlowProjectUser',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFlowProjectUser(request: DeleteFlowProjectUserRequest): DeleteFlowProjectUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowProjectUserWithOptions(request, runtime);
}

model DeleteJobRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DeleteJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteJobResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteJobResponseBody(name='body'),
}

async function deleteJobWithOptions(request: DeleteJobRequest, runtime: Util.RuntimeOptions): DeleteJobResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Id"] = request.id;
  query["RegionId"] = request.regionId;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteJob',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteJob(request: DeleteJobRequest): DeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteJobWithOptions(request, runtime);
}

model DeleteLibrariesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  libraryBizIdList?: [ string ](name='LibraryBizIdList'),
}

model DeleteLibrariesResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model DeleteLibrariesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLibrariesResponseBody(name='body'),
}

async function deleteLibrariesWithOptions(request: DeleteLibrariesRequest, runtime: Util.RuntimeOptions): DeleteLibrariesResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["LibraryBizIdList"] = request.libraryBizIdList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLibraries',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLibraries(request: DeleteLibrariesRequest): DeleteLibrariesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLibrariesWithOptions(request, runtime);
}

model DeleteResourcePoolRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourcePoolId?: string(name='ResourcePoolId'),
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
}

model DeleteResourcePoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteResourcePoolResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteResourcePoolResponseBody(name='body'),
}

async function deleteResourcePoolWithOptions(request: DeleteResourcePoolRequest, runtime: Util.RuntimeOptions): DeleteResourcePoolResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["ResourcePoolId"] = request.resourcePoolId;
  query["ClusterId"] = request.clusterId;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourcePool',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteResourcePool(request: DeleteResourcePoolRequest): DeleteResourcePoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteResourcePoolWithOptions(request, runtime);
}

model DeleteResourceQueueRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceQueueId?: string(name='ResourceQueueId'),
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
}

model DeleteResourceQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteResourceQueueResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteResourceQueueResponseBody(name='body'),
}

async function deleteResourceQueueWithOptions(request: DeleteResourceQueueRequest, runtime: Util.RuntimeOptions): DeleteResourceQueueResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["ResourceQueueId"] = request.resourceQueueId;
  query["ClusterId"] = request.clusterId;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceQueue',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteResourceQueue(request: DeleteResourceQueueRequest): DeleteResourceQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteResourceQueueWithOptions(request, runtime);
}

model DeleteScalingRuleRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostGroupId?: string(name='HostGroupId'),
  scalingRuleId?: string(name='ScalingRuleId'),
}

model DeleteScalingRuleResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model DeleteScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteScalingRuleResponseBody(name='body'),
}

async function deleteScalingRuleWithOptions(request: DeleteScalingRuleRequest, runtime: Util.RuntimeOptions): DeleteScalingRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["HostGroupId"] = request.hostGroupId;
  query["ScalingRuleId"] = request.scalingRuleId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteScalingRule',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteScalingRule(request: DeleteScalingRuleRequest): DeleteScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteScalingRuleWithOptions(request, runtime);
}

model DeleteTagRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: long(name='Id'),
  name?: string(name='Name'),
  category?: string(name='Category'),
  description?: string(name='Description'),
}

model DeleteTagResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model DeleteTagResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTagResponseBody(name='body'),
}

async function deleteTagWithOptions(request: DeleteTagRequest, runtime: Util.RuntimeOptions): DeleteTagResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Id"] = request.id;
  query["Name"] = request.name;
  query["Category"] = request.category;
  query["Description"] = request.description;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTag',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTag(request: DeleteTagRequest): DeleteTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTagWithOptions(request, runtime);
}

model DeleteUserRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  userId?: string(name='UserId'),
  type?: string(name='Type'),
}

model DeleteUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUserWithOptions(request: DeleteUserRequest, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["UserId"] = request.userId;
  query["Type"] = request.type;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUser',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserWithOptions(request, runtime);
}

model DescribeClusterBasicInfoRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
}

model DescribeClusterBasicInfoResponseBody = {
  clusterInfo?: {
    vpcId?: string(name='VpcId'),
    logEnable?: boolean(name='LogEnable'),
    taskNodeInService?: int32(name='TaskNodeInService'),
    autoScalingSpotWithLimitAllowed?: boolean(name='AutoScalingSpotWithLimitAllowed'),
    chargeType?: string(name='ChargeType'),
    userId?: string(name='UserId'),
    stopTime?: long(name='StopTime'),
    createType?: string(name='CreateType'),
    depositType?: string(name='DepositType'),
    relateClusterInfo?: {
      status?: string(name='Status'),
      clusterType?: string(name='ClusterType'),
      clusterName?: string(name='ClusterName'),
      clusterId?: string(name='ClusterId'),
    }(name='RelateClusterInfo'),
    relateClusterId?: string(name='RelateClusterId'),
    securityGroupName?: string(name='SecurityGroupName'),
    resizeDiskEnable?: boolean(name='ResizeDiskEnable'),
    imageId?: string(name='ImageId'),
    failReason?: {
      requestId?: string(name='RequestId'),
      errorCode?: string(name='ErrorCode'),
      errorMsg?: string(name='ErrorMsg'),
    }(name='FailReason'),
    clusterId?: string(name='ClusterId'),
    userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
    metaStoreType?: string(name='MetaStoreType'),
    softwareInfo?: {
      emrVer?: string(name='EmrVer'),
      clusterType?: string(name='ClusterType'),
      softwares?: {
        software?: [ 
        {
          displayName?: string(name='DisplayName'),
          startTpe?: int32(name='StartTpe'),
          version?: string(name='Version'),
          onlyDisplay?: boolean(name='OnlyDisplay'),
          name?: string(name='Name'),
        }
      ](name='Software')
      }(name='Softwares'),
    }(name='SoftwareInfo'),
    startTime?: long(name='StartTime'),
    configurations?: string(name='Configurations'),
    logPath?: string(name='LogPath'),
    autoScalingVersion?: string(name='AutoScalingVersion'),
    netType?: string(name='NetType'),
    zoneId?: string(name='ZoneId'),
    accessInfo?: {
      ZKLinks?: {
        ZKLink?: [ 
        {
          link?: string(name='Link'),
          port?: string(name='Port'),
        }
      ](name='ZKLink')
      }(name='ZKLinks'),
    }(name='AccessInfo'),
    createResource?: string(name='CreateResource'),
    status?: string(name='Status'),
    runningTime?: int32(name='RunningTime'),
    highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
    securityGroupId?: string(name='SecurityGroupId'),
    autoScalingAllowed?: boolean(name='AutoScalingAllowed'),
    masterNodeInService?: int32(name='MasterNodeInService'),
    autoScalingEnable?: boolean(name='AutoScalingEnable'),
    operationId?: string(name='OperationId'),
    autoScalingWithGraceAllowed?: boolean(name='AutoScalingWithGraceAllowed'),
    showSoftwareInterface?: boolean(name='ShowSoftwareInterface'),
    coreNodeInService?: int32(name='CoreNodeInService'),
    autoScalingByLoadAllowed?: boolean(name='AutoScalingByLoadAllowed'),
    k8sClusterId?: string(name='K8sClusterId'),
    localMetaDb?: boolean(name='LocalMetaDb'),
    bootstrapActionList?: {
      bootstrapAction?: [ 
      {
        arg?: string(name='Arg'),
        path?: string(name='Path'),
        name?: string(name='Name'),
      }
    ](name='BootstrapAction')
    }(name='BootstrapActionList'),
    gatewayClusterInfoList?: {
      gatewayClusterInfo?: [ 
      {
        status?: string(name='Status'),
        clusterName?: string(name='ClusterName'),
        clusterId?: string(name='ClusterId'),
      }
    ](name='GatewayClusterInfo')
    }(name='GatewayClusterInfoList'),
    instanceGeneration?: string(name='InstanceGeneration'),
    name?: string(name='Name'),
    easEnable?: boolean(name='EasEnable'),
    machineType?: string(name='MachineType'),
    hostPoolInfo?: {
      hpBizId?: string(name='HpBizId'),
      hpName?: string(name='HpName'),
    }(name='HostPoolInfo'),
    masterNodeTotal?: int32(name='MasterNodeTotal'),
    regionId?: string(name='RegionId'),
    period?: int32(name='Period'),
    extraInfo?: string(name='ExtraInfo'),
    ioOptimized?: boolean(name='IoOptimized'),
    vSwitchId?: string(name='VSwitchId'),
    expiredTime?: long(name='ExpiredTime'),
    coreNodeTotal?: int32(name='CoreNodeTotal'),
    gatewayClusterIds?: string(name='GatewayClusterIds'),
    bootstrapFailed?: boolean(name='BootstrapFailed'),
    taskNodeTotal?: int32(name='TaskNodeTotal'),
  }(name='ClusterInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterBasicInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterBasicInfoResponseBody(name='body'),
}

async function describeClusterBasicInfoWithOptions(request: DescribeClusterBasicInfoRequest, runtime: Util.RuntimeOptions): DescribeClusterBasicInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterBasicInfo',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterBasicInfo(request: DescribeClusterBasicInfoRequest): DescribeClusterBasicInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterBasicInfoWithOptions(request, runtime);
}

model DescribeClusterMetaCollectRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
}

model DescribeClusterMetaCollectResponseBody = {
  status?: string(name='Status'),
  requestId?: string(name='RequestId'),
  clusterId?: string(name='ClusterId'),
  metaStoreType?: string(name='MetaStoreType'),
}

model DescribeClusterMetaCollectResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterMetaCollectResponseBody(name='body'),
}

async function describeClusterMetaCollectWithOptions(request: DescribeClusterMetaCollectRequest, runtime: Util.RuntimeOptions): DescribeClusterMetaCollectResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterMetaCollect',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterMetaCollect(request: DescribeClusterMetaCollectRequest): DescribeClusterMetaCollectResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterMetaCollectWithOptions(request, runtime);
}

model DescribeClusterOperationHostTaskLogRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  operationId?: string(name='OperationId'),
  hostId?: string(name='HostId'),
  taskId?: string(name='TaskId'),
  status?: string(name='Status'),
}

model DescribeClusterOperationHostTaskLogResponseBody = {
  stderr?: string(name='Stderr'),
  requestId?: string(name='RequestId'),
  stdout?: string(name='Stdout'),
}

model DescribeClusterOperationHostTaskLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterOperationHostTaskLogResponseBody(name='body'),
}

async function describeClusterOperationHostTaskLogWithOptions(request: DescribeClusterOperationHostTaskLogRequest, runtime: Util.RuntimeOptions): DescribeClusterOperationHostTaskLogResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["OperationId"] = request.operationId;
  query["HostId"] = request.hostId;
  query["TaskId"] = request.taskId;
  query["Status"] = request.status;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterOperationHostTaskLog',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterOperationHostTaskLog(request: DescribeClusterOperationHostTaskLogRequest): DescribeClusterOperationHostTaskLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterOperationHostTaskLogWithOptions(request, runtime);
}

model DescribeClusterResourcePoolSchedulerTypeRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
}

model DescribeClusterResourcePoolSchedulerTypeResponseBody = {
  requestId?: string(name='RequestId'),
  currentSchedulerType?: string(name='CurrentSchedulerType'),
  supportSchedulerType?: string(name='SupportSchedulerType'),
  defaultSchedulerType?: string(name='DefaultSchedulerType'),
}

model DescribeClusterResourcePoolSchedulerTypeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterResourcePoolSchedulerTypeResponseBody(name='body'),
}

async function describeClusterResourcePoolSchedulerTypeWithOptions(request: DescribeClusterResourcePoolSchedulerTypeRequest, runtime: Util.RuntimeOptions): DescribeClusterResourcePoolSchedulerTypeResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterResourcePoolSchedulerType',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterResourcePoolSchedulerType(request: DescribeClusterResourcePoolSchedulerTypeRequest): DescribeClusterResourcePoolSchedulerTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterResourcePoolSchedulerTypeWithOptions(request, runtime);
}

model DescribeClusterServiceRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
}

model DescribeClusterServiceResponseBody = {
  serviceInfo?: {
    needRestartInfo?: string(name='NeedRestartInfo'),
    needRestartHostIdList?: {
      service?: [ string ](name='Service')
    }(name='NeedRestartHostIdList'),
    clusterServiceSummaryList?: {
      clusterServiceSummary?: [ 
      {
        key?: string(name='Key'),
        displayName?: string(name='DisplayName'),
        status?: string(name='Status'),
        type?: string(name='Type'),
        value?: string(name='Value'),
        desiredStoppedValue?: int32(name='DesiredStoppedValue'),
        alertInfo?: string(name='AlertInfo'),
        category?: string(name='Category'),
      }
    ](name='ClusterServiceSummary')
    }(name='ClusterServiceSummaryList'),
    serviceActionList?: {
      serviceAction?: [ 
      {
        displayName?: string(name='DisplayName'),
        componentName?: string(name='ComponentName'),
        command?: string(name='Command'),
        actionName?: string(name='ActionName'),
        serviceName?: string(name='ServiceName'),
      }
    ](name='ServiceAction')
    }(name='ServiceActionList'),
    needRestartNum?: int32(name='NeedRestartNum'),
    needRestartComponentNameList?: {
      service?: [ string ](name='Service')
    }(name='NeedRestartComponentNameList'),
    serviceVersion?: string(name='ServiceVersion'),
    serviceStatus?: string(name='ServiceStatus'),
    serviceName?: string(name='ServiceName'),
  }(name='ServiceInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterServiceResponseBody(name='body'),
}

async function describeClusterServiceWithOptions(request: DescribeClusterServiceRequest, runtime: Util.RuntimeOptions): DescribeClusterServiceResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["ServiceName"] = request.serviceName;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterService',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterService(request: DescribeClusterServiceRequest): DescribeClusterServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterServiceWithOptions(request, runtime);
}

model DescribeClusterServiceConfigRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
  configVersion?: string(name='ConfigVersion'),
  groupId?: string(name='GroupId'),
  hostInstanceId?: string(name='HostInstanceId'),
  tagValue?: string(name='TagValue'),
}

model DescribeClusterServiceConfigResponseBody = {
  requestId?: string(name='RequestId'),
  config?: {
    applied?: string(name='Applied'),
    comment?: string(name='Comment'),
    createTime?: string(name='CreateTime'),
    configVersion?: string(name='ConfigVersion'),
    configValueList?: {
      configValue?: [ 
      {
        configName?: string(name='ConfigName'),
        scopeId?: long(name='ScopeId'),
        configItemValueList?: {
          configItemValue?: [ 
          {
            value?: string(name='Value'),
            description?: string(name='Description'),
            itemName?: string(name='ItemName'),
            isCustom?: boolean(name='IsCustom'),
          }
        ](name='ConfigItemValue')
        }(name='ConfigItemValueList'),
        allowCustom?: boolean(name='AllowCustom'),
        scope?: string(name='Scope'),
      }
    ](name='ConfigValue')
    }(name='ConfigValueList'),
    author?: string(name='Author'),
    propertyInfoList?: {
      propertyInfo?: [ 
      {
        displayName?: string(name='DisplayName'),
        value?: string(name='Value'),
        propertyTypes?: {
          propertyType?: [ string ](name='propertyType')
        }(name='PropertyTypes'),
        description?: string(name='Description'),
        effectWay?: {
          effectType?: string(name='EffectType'),
          invokeServiceName?: string(name='InvokeServiceName'),
        }(name='EffectWay'),
        component?: string(name='Component'),
        propertyValueAttributes?: {
          type?: string(name='Type'),
          maximum?: string(name='Maximum'),
          unit?: string(name='Unit'),
          hidden?: boolean(name='Hidden'),
          incrememtStep?: string(name='IncrememtStep'),
          readOnly?: boolean(name='ReadOnly'),
          entries?: {
            valueEntryInfo?: [ 
            {
              value?: string(name='Value'),
              description?: string(name='Description'),
              label?: string(name='Label'),
            }
          ](name='ValueEntryInfo')
          }(name='Entries'),
          mimimum?: string(name='Mimimum'),
        }(name='PropertyValueAttributes'),
        fileName?: string(name='FileName'),
        name?: string(name='Name'),
        serviceName?: string(name='ServiceName'),
      }
    ](name='PropertyInfo')
    }(name='PropertyInfoList'),
    serviceName?: string(name='ServiceName'),
  }(name='Config'),
}

model DescribeClusterServiceConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterServiceConfigResponseBody(name='body'),
}

async function describeClusterServiceConfigWithOptions(request: DescribeClusterServiceConfigRequest, runtime: Util.RuntimeOptions): DescribeClusterServiceConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["ServiceName"] = request.serviceName;
  query["ConfigVersion"] = request.configVersion;
  query["GroupId"] = request.groupId;
  query["HostInstanceId"] = request.hostInstanceId;
  query["TagValue"] = request.tagValue;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterServiceConfig',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterServiceConfig(request: DescribeClusterServiceConfigRequest): DescribeClusterServiceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterServiceConfigWithOptions(request, runtime);
}

model DescribeClusterServiceConfigHistoryRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
  configVersion?: string(name='ConfigVersion'),
}

model DescribeClusterServiceConfigHistoryResponseBody = {
  requestId?: string(name='RequestId'),
  config?: {
    applied?: boolean(name='Applied'),
    comment?: string(name='Comment'),
    createTime?: string(name='CreateTime'),
    configVersion?: string(name='ConfigVersion'),
    configValueList?: {
      configValue?: [ 
      {
        configName?: string(name='ConfigName'),
        configItemValueList?: {
          configItemValue?: [ 
          {
            value?: string(name='Value'),
            oldValue?: string(name='OldValue'),
            itemName?: string(name='ItemName'),
            changeType?: string(name='ChangeType'),
          }
        ](name='ConfigItemValue')
        }(name='ConfigItemValueList'),
      }
    ](name='ConfigValue')
    }(name='ConfigValueList'),
    author?: string(name='Author'),
    serviceName?: string(name='ServiceName'),
  }(name='Config'),
}

model DescribeClusterServiceConfigHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterServiceConfigHistoryResponseBody(name='body'),
}

async function describeClusterServiceConfigHistoryWithOptions(request: DescribeClusterServiceConfigHistoryRequest, runtime: Util.RuntimeOptions): DescribeClusterServiceConfigHistoryResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["ServiceName"] = request.serviceName;
  query["ConfigVersion"] = request.configVersion;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterServiceConfigHistory',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterServiceConfigHistory(request: DescribeClusterServiceConfigHistoryRequest): DescribeClusterServiceConfigHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterServiceConfigHistoryWithOptions(request, runtime);
}

model DescribeClusterServiceConfigTagRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
  configTag?: string(name='ConfigTag'),
}

model DescribeClusterServiceConfigTagResponseBody = {
  configTagList?: {
    configTag?: [ 
    {
      valueList?: {
        value?: [ 
        {
          value?: string(name='Value'),
          valueDesc?: string(name='ValueDesc'),
        }
      ](name='Value')
      }(name='ValueList'),
      tag?: string(name='Tag'),
      tagDesc?: string(name='TagDesc'),
    }
  ](name='ConfigTag')
  }(name='ConfigTagList'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterServiceConfigTagResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterServiceConfigTagResponseBody(name='body'),
}

async function describeClusterServiceConfigTagWithOptions(request: DescribeClusterServiceConfigTagRequest, runtime: Util.RuntimeOptions): DescribeClusterServiceConfigTagResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["ServiceName"] = request.serviceName;
  query["ConfigTag"] = request.configTag;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterServiceConfigTag',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterServiceConfigTag(request: DescribeClusterServiceConfigTagRequest): DescribeClusterServiceConfigTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterServiceConfigTagWithOptions(request, runtime);
}

model DescribeClusterTemplateRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  bizId?: string(name='BizId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeClusterTemplateResponseBody = {
  templateInfo?: {
    vpcId?: string(name='VpcId'),
    keyPairName?: string(name='KeyPairName'),
    logEnable?: boolean(name='LogEnable'),
    sshEnable?: boolean(name='SshEnable'),
    highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
    securityGroupId?: string(name='SecurityGroupId'),
    masterPwd?: string(name='MasterPwd'),
    userId?: string(name='UserId'),
    hostGroupList?: {
      hostGroup?: [ 
      {
        sysDiskCapacity?: int32(name='SysDiskCapacity'),
        hostGroupType?: string(name='HostGroupType'),
        sysDiskType?: string(name='SysDiskType'),
        multiInstanceTypes?: string(name='MultiInstanceTypes'),
        chargeType?: string(name='ChargeType'),
        diskType?: string(name='DiskType'),
        hostGroupId?: string(name='HostGroupId'),
        instanceType?: string(name='InstanceType'),
        diskCount?: int32(name='DiskCount'),
        period?: string(name='Period'),
        diskCapacity?: int32(name='DiskCapacity'),
        nodeCount?: int32(name='NodeCount'),
        hostGroupName?: string(name='HostGroupName'),
      }
    ](name='HostGroup')
    }(name='HostGroupList'),
    tags?: {
      tag?: [ 
      {
        tagValue?: string(name='TagValue'),
        tagKey?: string(name='TagKey'),
      }
    ](name='Tag')
    }(name='Tags'),
    gmtModified?: long(name='GmtModified'),
    templateName?: string(name='TemplateName'),
    allowNotebook?: boolean(name='AllowNotebook'),
    isOpenPublicIp?: boolean(name='IsOpenPublicIp'),
    depositType?: string(name='DepositType'),
    securityGroupName?: string(name='SecurityGroupName'),
    configList?: {
      config?: [ 
      {
        configValue?: string(name='ConfigValue'),
        replace?: string(name='Replace'),
        fileName?: string(name='FileName'),
        serviceName?: string(name='ServiceName'),
        configKey?: string(name='ConfigKey'),
        encrypt?: string(name='Encrypt'),
      }
    ](name='Config')
    }(name='ConfigList'),
    bootstrapActionList?: {
      bootstrapAction?: [ 
      {
        arg?: string(name='Arg'),
        path?: string(name='Path'),
        name?: string(name='Name'),
      }
    ](name='BootstrapAction')
    }(name='BootstrapActionList'),
    softwareInfoList?: {
      softwareInfo?: [ string ](name='SoftwareInfo')
    }(name='SoftwareInfoList'),
    instanceGeneration?: string(name='InstanceGeneration'),
    createSource?: string(name='CreateSource'),
    easEnable?: boolean(name='EasEnable'),
    useCustomHiveMetaDb?: boolean(name='UseCustomHiveMetaDb'),
    userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
    metaStoreType?: string(name='MetaStoreType'),
    machineType?: string(name='MachineType'),
    useLocalMetaDb?: boolean(name='UseLocalMetaDb'),
    masterNodeTotal?: int32(name='MasterNodeTotal'),
    initCustomHiveMetaDb?: boolean(name='InitCustomHiveMetaDb'),
    ioOptimized?: boolean(name='IoOptimized'),
    metaStoreConf?: string(name='MetaStoreConf'),
    vSwitchId?: string(name='VSwitchId'),
    configurations?: string(name='Configurations'),
    emrVer?: string(name='EmrVer'),
    logPath?: string(name='LogPath'),
    clusterType?: string(name='ClusterType'),
    netType?: string(name='NetType'),
    zoneId?: string(name='ZoneId'),
    gmtCreate?: long(name='GmtCreate'),
    id?: string(name='Id'),
  }(name='TemplateInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterTemplateResponseBody(name='body'),
}

async function describeClusterTemplateWithOptions(request: DescribeClusterTemplateRequest, runtime: Util.RuntimeOptions): DescribeClusterTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["BizId"] = request.bizId;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterTemplate',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterTemplate(request: DescribeClusterTemplateRequest): DescribeClusterTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterTemplateWithOptions(request, runtime);
}

model DescribeClusterV2Request {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: string(name='Id'),
}

model DescribeClusterV2ResponseBody = {
  clusterInfo?: {
    vpcId?: string(name='VpcId'),
    logEnable?: boolean(name='LogEnable'),
    taskNodeInService?: int32(name='TaskNodeInService'),
    autoScalingSpotWithLimitAllowed?: boolean(name='AutoScalingSpotWithLimitAllowed'),
    chargeType?: string(name='ChargeType'),
    userId?: string(name='UserId'),
    stopTime?: long(name='StopTime'),
    createType?: string(name='CreateType'),
    depositType?: string(name='DepositType'),
    relateClusterInfo?: {
      status?: string(name='Status'),
      clusterType?: string(name='ClusterType'),
      clusterName?: string(name='ClusterName'),
      clusterId?: string(name='ClusterId'),
    }(name='RelateClusterInfo'),
    relateClusterId?: string(name='RelateClusterId'),
    securityGroupName?: string(name='SecurityGroupName'),
    resizeDiskEnable?: boolean(name='ResizeDiskEnable'),
    imageId?: string(name='ImageId'),
    failReason?: {
      requestId?: string(name='RequestId'),
      errorCode?: string(name='ErrorCode'),
      errorMsg?: string(name='ErrorMsg'),
    }(name='FailReason'),
    userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
    metaStoreType?: string(name='MetaStoreType'),
    softwareInfo?: {
      emrVer?: string(name='EmrVer'),
      clusterType?: string(name='ClusterType'),
      softwares?: {
        software?: [ 
        {
          displayName?: string(name='DisplayName'),
          startTpe?: int32(name='StartTpe'),
          version?: string(name='Version'),
          onlyDisplay?: boolean(name='OnlyDisplay'),
          name?: string(name='Name'),
        }
      ](name='Software')
      }(name='Softwares'),
    }(name='SoftwareInfo'),
    startTime?: long(name='StartTime'),
    configurations?: string(name='Configurations'),
    logPath?: string(name='LogPath'),
    autoScalingVersion?: string(name='AutoScalingVersion'),
    netType?: string(name='NetType'),
    zoneId?: string(name='ZoneId'),
    accessInfo?: {
      ZKLinks?: {
        ZKLink?: [ 
        {
          link?: string(name='Link'),
          port?: string(name='Port'),
        }
      ](name='ZKLink')
      }(name='ZKLinks'),
    }(name='AccessInfo'),
    createResource?: string(name='CreateResource'),
    status?: string(name='Status'),
    runningTime?: int32(name='RunningTime'),
    highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
    securityGroupId?: string(name='SecurityGroupId'),
    autoScalingAllowed?: boolean(name='AutoScalingAllowed'),
    hostGroupList?: {
      hostGroup?: [ 
      {
        nodes?: {
          node?: [ 
          {
            status?: string(name='Status'),
            supportIpV6?: boolean(name='SupportIpV6'),
            innerIp?: string(name='InnerIp'),
            expiredTime?: string(name='ExpiredTime'),
            createTime?: string(name='CreateTime'),
            zoneId?: string(name='ZoneId'),
            instanceId?: string(name='InstanceId'),
            diskInfos?: {
              diskInfo?: [ 
              {
                type?: string(name='Type'),
                size?: int32(name='Size'),
                device?: string(name='Device'),
                diskName?: string(name='DiskName'),
                diskId?: string(name='DiskId'),
              }
            ](name='DiskInfo')
            }(name='DiskInfos'),
            emrExpiredTime?: string(name='EmrExpiredTime'),
            pubIp?: string(name='PubIp'),
            daemonInfos?: {
              daemonInfo?: [ 
              {
                name?: string(name='Name'),
              }
            ](name='DaemonInfo')
            }(name='DaemonInfos'),
          }
        ](name='Node')
        }(name='Nodes'),
        lockType?: string(name='LockType'),
        hostGroupType?: string(name='HostGroupType'),
        hostGroupSubType?: string(name='HostGroupSubType'),
        hostGroupChangeStatus?: string(name='HostGroupChangeStatus'),
        chargeType?: string(name='ChargeType'),
        diskType?: string(name='DiskType'),
        lockReason?: string(name='LockReason'),
        hostGroupId?: string(name='HostGroupId'),
        instanceType?: string(name='InstanceType'),
        bandWidth?: string(name='BandWidth'),
        diskCount?: int32(name='DiskCount'),
        period?: string(name='Period'),
        diskCapacity?: int32(name='DiskCapacity'),
        cpuCore?: int32(name='CpuCore'),
        memoryCapacity?: int32(name='MemoryCapacity'),
        nodeCount?: int32(name='NodeCount'),
        hostGroupChangeType?: string(name='HostGroupChangeType'),
        hostGroupName?: string(name='HostGroupName'),
      }
    ](name='HostGroup')
    }(name='HostGroupList'),
    masterNodeInService?: int32(name='MasterNodeInService'),
    autoScalingEnable?: boolean(name='AutoScalingEnable'),
    autoScalingWithGraceAllowed?: boolean(name='AutoScalingWithGraceAllowed'),
    showSoftwareInterface?: boolean(name='ShowSoftwareInterface'),
    coreNodeInService?: int32(name='CoreNodeInService'),
    autoScalingByLoadAllowed?: boolean(name='AutoScalingByLoadAllowed'),
    k8sClusterId?: string(name='K8sClusterId'),
    localMetaDb?: boolean(name='LocalMetaDb'),
    bootstrapActionList?: {
      bootstrapAction?: [ 
      {
        arg?: string(name='Arg'),
        path?: string(name='Path'),
        name?: string(name='Name'),
      }
    ](name='BootstrapAction')
    }(name='BootstrapActionList'),
    gatewayClusterInfoList?: {
      gatewayClusterInfo?: [ 
      {
        status?: string(name='Status'),
        clusterName?: string(name='ClusterName'),
        clusterId?: string(name='ClusterId'),
      }
    ](name='GatewayClusterInfo')
    }(name='GatewayClusterInfoList'),
    instanceGeneration?: string(name='InstanceGeneration'),
    name?: string(name='Name'),
    easEnable?: boolean(name='EasEnable'),
    machineType?: string(name='MachineType'),
    hostPoolInfo?: {
      hpBizId?: string(name='HpBizId'),
      hpName?: string(name='HpName'),
    }(name='HostPoolInfo'),
    masterNodeTotal?: int32(name='MasterNodeTotal'),
    regionId?: string(name='RegionId'),
    period?: int32(name='Period'),
    extraInfo?: string(name='ExtraInfo'),
    ioOptimized?: boolean(name='IoOptimized'),
    vSwitchId?: string(name='VSwitchId'),
    expiredTime?: long(name='ExpiredTime'),
    coreNodeTotal?: int32(name='CoreNodeTotal'),
    gatewayClusterIds?: string(name='GatewayClusterIds'),
    bootstrapFailed?: boolean(name='BootstrapFailed'),
    id?: string(name='Id'),
    taskNodeTotal?: int32(name='TaskNodeTotal'),
  }(name='ClusterInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterV2Response = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterV2ResponseBody(name='body'),
}

async function describeClusterV2WithOptions(request: DescribeClusterV2Request, runtime: Util.RuntimeOptions): DescribeClusterV2Response {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Id"] = request.id;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterV2',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterV2(request: DescribeClusterV2Request): DescribeClusterV2Response {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterV2WithOptions(request, runtime);
}

model DescribeDataSourceRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: string(name='Id'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeDataSourceResponseBody = {
  status?: string(name='Status'),
  categoryId?: string(name='CategoryId'),
  description?: string(name='Description'),
  conf?: string(name='Conf'),
  requestId?: string(name='RequestId'),
  clusterId?: string(name='ClusterId'),
  sourceType?: string(name='SourceType'),
  gmtModified?: long(name='GmtModified'),
  creator?: string(name='Creator'),
  createFrom?: string(name='CreateFrom'),
  name?: string(name='Name'),
  gmtCreate?: long(name='GmtCreate'),
  id?: string(name='Id'),
  modifier?: string(name='Modifier'),
}

model DescribeDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDataSourceResponseBody(name='body'),
}

async function describeDataSourceWithOptions(request: DescribeDataSourceRequest, runtime: Util.RuntimeOptions): DescribeDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Id"] = request.id;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDataSource',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDataSource(request: DescribeDataSourceRequest): DescribeDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDataSourceWithOptions(request, runtime);
}

model DescribeExecutionPlanRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: string(name='Id'),
}

model DescribeExecutionPlanResponseBody = {
  status?: string(name='Status'),
  workflowApp?: string(name='WorkflowApp'),
  dayOfWeek?: string(name='DayOfWeek'),
  timeInterval?: int32(name='TimeInterval'),
  requestId?: string(name='RequestId'),
  clusterId?: string(name='ClusterId'),
  dayOfMonth?: string(name='DayOfMonth'),
  executionPlanVersion?: long(name='ExecutionPlanVersion'),
  startTime?: long(name='StartTime'),
  name?: string(name='Name'),
  jobInfoList?: {
    jobInfo?: [ 
    {
      type?: string(name='Type'),
      failAct?: string(name='FailAct'),
      name?: string(name='Name'),
      runParameter?: string(name='RunParameter'),
      id?: string(name='Id'),
    }
  ](name='JobInfo')
  }(name='JobInfoList'),
  clusterInfo?: {
    vpcId?: string(name='VpcId'),
    useCustomHiveMetaDB?: boolean(name='UseCustomHiveMetaDB'),
    logEnable?: boolean(name='LogEnable'),
    userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
    highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
    securityGroupId?: string(name='SecurityGroupId'),
    useLocalMetaDb?: boolean(name='UseLocalMetaDb'),
    softwareInfo?: {
      emrVer?: string(name='EmrVer'),
      clusterType?: string(name='ClusterType'),
      softwares?: {
        software?: [ 
        {
          displayName?: string(name='DisplayName'),
          startTpe?: int32(name='StartTpe'),
          version?: string(name='Version'),
          onlyDisplay?: boolean(name='OnlyDisplay'),
          optional?: boolean(name='Optional'),
          name?: string(name='Name'),
        }
      ](name='Software')
      }(name='Softwares'),
    }(name='SoftwareInfo'),
    ioOptimized?: boolean(name='IoOptimized'),
    vSwitchId?: string(name='VSwitchId'),
    configurations?: string(name='Configurations'),
    ecsOrders?: {
      ecsOrderInfo?: [ 
      {
        index?: int32(name='Index'),
        diskCapacity?: int32(name='DiskCapacity'),
        nodeType?: string(name='NodeType'),
        nodeCount?: int32(name='NodeCount'),
        diskType?: string(name='DiskType'),
        instanceType?: string(name='InstanceType'),
        diskCount?: int32(name='DiskCount'),
      }
    ](name='EcsOrderInfo')
    }(name='EcsOrders'),
    emrVer?: string(name='EmrVer'),
    logPath?: string(name='LogPath'),
    clusterType?: string(name='ClusterType'),
    initCustomHiveMetaDB?: boolean(name='InitCustomHiveMetaDB'),
    netType?: string(name='NetType'),
    zoneId?: string(name='ZoneId'),
    configList?: {
      config?: [ 
      {
        configValue?: string(name='ConfigValue'),
        fileName?: string(name='FileName'),
        serviceName?: string(name='ServiceName'),
        configKey?: string(name='ConfigKey'),
        encrypt?: string(name='Encrypt'),
      }
    ](name='Config')
    }(name='ConfigList'),
    bootstrapActionList?: {
      bootstrapAction?: [ 
      {
        arg?: string(name='Arg'),
        path?: string(name='Path'),
        name?: string(name='Name'),
      }
    ](name='BootstrapAction')
    }(name='BootstrapActionList'),
    instanceGeneration?: string(name='InstanceGeneration'),
    name?: string(name='Name'),
    easEnable?: boolean(name='EasEnable'),
  }(name='ClusterInfo'),
  timeUnit?: string(name='TimeUnit'),
  strategy?: string(name='Strategy'),
  clusterName?: string(name='ClusterName'),
  id?: string(name='Id'),
  createClusterOnDemand?: boolean(name='CreateClusterOnDemand'),
}

model DescribeExecutionPlanResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeExecutionPlanResponseBody(name='body'),
}

async function describeExecutionPlanWithOptions(request: DescribeExecutionPlanRequest, runtime: Util.RuntimeOptions): DescribeExecutionPlanResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Id"] = request.id;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExecutionPlan',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeExecutionPlan(request: DescribeExecutionPlanRequest): DescribeExecutionPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExecutionPlanWithOptions(request, runtime);
}

model DescribeFlowRequest {
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowResponseBody = {
  categoryId?: string(name='CategoryId'),
  description?: string(name='Description'),
  gmtModified?: long(name='GmtModified'),
  periodic?: boolean(name='Periodic'),
  cronExpr?: string(name='CronExpr'),
  alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
  name?: string(name='Name'),
  alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
  logArchiveLocation?: string(name='LogArchiveLocation'),
  endSchedule?: long(name='EndSchedule'),
  hostName?: string(name='HostName'),
  status?: string(name='Status'),
  startSchedule?: long(name='StartSchedule'),
  requestId?: string(name='RequestId'),
  clusterId?: string(name='ClusterId'),
  lifecycle?: string(name='Lifecycle'),
  editLockDetail?: string(name='EditLockDetail'),
  namespace?: string(name='Namespace'),
  type?: string(name='Type'),
  gmtCreate?: long(name='GmtCreate'),
  graph?: string(name='Graph'),
  id?: string(name='Id'),
  application?: string(name='Application'),
  createCluster?: boolean(name='CreateCluster'),
  alertConf?: string(name='AlertConf'),
  parentFlowList?: {
    parentFlow?: [ 
    {
      projectName?: string(name='ProjectName'),
      projectId?: string(name='ProjectId'),
      parentFlowName?: string(name='ParentFlowName'),
      parentFlowId?: string(name='ParentFlowId'),
    }
  ](name='ParentFlow')
  }(name='ParentFlowList'),
}

model DescribeFlowResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowResponseBody(name='body'),
}

async function describeFlowWithOptions(request: DescribeFlowRequest, runtime: Util.RuntimeOptions): DescribeFlowResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["Id"] = request.id;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlow',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlow(request: DescribeFlowRequest): DescribeFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowWithOptions(request, runtime);
}

model DescribeFlowCategoryRequest {
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowCategoryResponseBody = {
  parentId?: string(name='ParentId'),
  objectType?: string(name='ObjectType'),
  type?: string(name='Type'),
  gmtCreate?: long(name='GmtCreate'),
  requestId?: string(name='RequestId'),
  objectId?: string(name='ObjectId'),
  projectId?: string(name='ProjectId'),
  gmtModified?: long(name='GmtModified'),
  categoryType?: string(name='CategoryType'),
  id?: string(name='Id'),
  name?: string(name='Name'),
}

model DescribeFlowCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowCategoryResponseBody(name='body'),
}

async function describeFlowCategoryWithOptions(request: DescribeFlowCategoryRequest, runtime: Util.RuntimeOptions): DescribeFlowCategoryResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["Id"] = request.id;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlowCategory',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlowCategory(request: DescribeFlowCategoryRequest): DescribeFlowCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowCategoryWithOptions(request, runtime);
}

model DescribeFlowCategoryTreeRequest {
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
  mode?: string(name='Mode'),
  keyword?: string(name='Keyword'),
  categoryId?: string(name='CategoryId'),
}

model DescribeFlowCategoryTreeResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model DescribeFlowCategoryTreeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowCategoryTreeResponseBody(name='body'),
}

async function describeFlowCategoryTreeWithOptions(request: DescribeFlowCategoryTreeRequest, runtime: Util.RuntimeOptions): DescribeFlowCategoryTreeResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["RegionId"] = request.regionId;
  query["Type"] = request.type;
  query["Mode"] = request.mode;
  query["Keyword"] = request.keyword;
  query["CategoryId"] = request.categoryId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlowCategoryTree',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlowCategoryTree(request: DescribeFlowCategoryTreeRequest): DescribeFlowCategoryTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowCategoryTreeWithOptions(request, runtime);
}

model DescribeFlowInstanceRequest {
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowInstanceResponseBody = {
  status?: string(name='Status'),
  hasNodeFailed?: boolean(name='HasNodeFailed'),
  endTime?: long(name='EndTime'),
  requestId?: string(name='RequestId'),
  clusterId?: string(name='ClusterId'),
  lifecycle?: string(name='Lifecycle'),
  projectId?: string(name='ProjectId'),
  gmtModified?: long(name='GmtModified'),
  startTime?: long(name='StartTime'),
  duration?: long(name='Duration'),
  namespace?: string(name='Namespace'),
  flowId?: string(name='FlowId'),
  gmtCreate?: long(name='GmtCreate'),
  graph?: string(name='Graph'),
  scheduleTime?: long(name='ScheduleTime'),
  flowName?: string(name='FlowName'),
  cronExpression?: string(name='CronExpression'),
  logArchiveLocation?: string(name='LogArchiveLocation'),
  id?: string(name='Id'),
  nodeInstance?: {
    nodeInstance?: [ 
    {
      type?: string(name='Type'),
      status?: string(name='Status'),
      failAct?: string(name='FailAct'),
      retryInterval?: string(name='RetryInterval'),
      projectId?: string(name='ProjectId'),
      jobType?: string(name='JobType'),
      hostName?: string(name='HostName'),
      gmtModified?: long(name='GmtModified'),
      externalInfo?: string(name='ExternalInfo'),
      retries?: int32(name='Retries'),
      endTime?: long(name='EndTime'),
      startTime?: long(name='StartTime'),
      externalStatus?: string(name='ExternalStatus'),
      jobName?: string(name='JobName'),
      nodeName?: string(name='NodeName'),
      jobId?: string(name='JobId'),
      gmtCreate?: long(name='GmtCreate'),
      externalId?: string(name='ExternalId'),
      duration?: long(name='Duration'),
      id?: string(name='Id'),
      pending?: boolean(name='Pending'),
      clusterId?: string(name='ClusterId'),
      maxRetry?: string(name='MaxRetry'),
    }
  ](name='NodeInstance')
  }(name='NodeInstance'),
  dependencyFlowList?: {
    parentFlow?: [ 
    {
      scheduleKey?: string(name='ScheduleKey'),
      bizDate?: long(name='BizDate'),
      dependencyInstanceId?: string(name='DependencyInstanceId'),
      dependencyFlowId?: string(name='DependencyFlowId'),
      meet?: boolean(name='Meet'),
      flowInstanceId?: string(name='FlowInstanceId'),
      projectId?: string(name='ProjectId'),
      flowId?: string(name='FlowId'),
    }
  ](name='ParentFlow')
  }(name='DependencyFlowList'),
}

model DescribeFlowInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowInstanceResponseBody(name='body'),
}

async function describeFlowInstanceWithOptions(request: DescribeFlowInstanceRequest, runtime: Util.RuntimeOptions): DescribeFlowInstanceResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["Id"] = request.id;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlowInstance',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlowInstance(request: DescribeFlowInstanceRequest): DescribeFlowInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowInstanceWithOptions(request, runtime);
}

model DescribeFlowJobRequest {
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowJobResponseBody = {
  failAct?: string(name='FailAct'),
  categoryId?: string(name='CategoryId'),
  description?: string(name='Description'),
  gmtModified?: long(name='GmtModified'),
  name?: string(name='Name'),
  paramConf?: string(name='ParamConf'),
  mode?: string(name='mode'),
  adhoc?: string(name='Adhoc'),
  requestId?: string(name='RequestId'),
  lastInstanceId?: string(name='LastInstanceId'),
  params?: string(name='Params'),
  maxRetry?: int32(name='MaxRetry'),
  maxRunningTimeSec?: long(name='MaxRunningTimeSec'),
  editLockDetail?: string(name='EditLockDetail'),
  type?: string(name='Type'),
  gmtCreate?: long(name='GmtCreate'),
  resourceList?: {
    resource?: [ 
    {
      path?: string(name='Path'),
      alias?: string(name='Alias'),
    }
  ](name='Resource')
  }(name='ResourceList'),
  envConf?: string(name='EnvConf'),
  monitorConf?: string(name='MonitorConf'),
  retryInterval?: long(name='RetryInterval'),
  runConf?: string(name='RunConf'),
  id?: string(name='Id'),
  retryPolicy?: string(name='RetryPolicy'),
  customVariables?: string(name='CustomVariables'),
  alertConf?: string(name='AlertConf'),
}

model DescribeFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowJobResponseBody(name='body'),
}

async function describeFlowJobWithOptions(request: DescribeFlowJobRequest, runtime: Util.RuntimeOptions): DescribeFlowJobResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["Id"] = request.id;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlowJob',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlowJob(request: DescribeFlowJobRequest): DescribeFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowJobWithOptions(request, runtime);
}

model DescribeFlowNodeInstanceRequest {
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowNodeInstanceResponseBody = {
  failAct?: string(name='FailAct'),
  endTime?: long(name='EndTime'),
  nodeName?: string(name='NodeName'),
  gmtModified?: long(name='GmtModified'),
  jobName?: string(name='JobName'),
  externalStatus?: string(name='ExternalStatus'),
  paramConf?: string(name='ParamConf'),
  flowId?: string(name='FlowId'),
  externalInfo?: string(name='ExternalInfo'),
  retries?: int32(name='Retries'),
  clusterName?: string(name='ClusterName'),
  adhoc?: boolean(name='Adhoc'),
  jobParams?: string(name='JobParams'),
  hostName?: string(name='HostName'),
  jobId?: string(name='JobId'),
  status?: string(name='Status'),
  requestId?: string(name='RequestId'),
  clusterId?: string(name='ClusterId'),
  mode?: string(name='Mode'),
  externalId?: string(name='ExternalId'),
  projectId?: string(name='ProjectId'),
  startTime?: long(name='StartTime'),
  flowInstanceId?: string(name='FlowInstanceId'),
  duration?: long(name='Duration'),
  maxRetry?: string(name='MaxRetry'),
  externalSubId?: string(name='ExternalSubId'),
  type?: string(name='Type'),
  gmtCreate?: long(name='GmtCreate'),
  envConf?: string(name='EnvConf'),
  jobType?: string(name='JobType'),
  externalChildIds?: string(name='ExternalChildIds'),
  monitorConf?: string(name='MonitorConf'),
  retryInterval?: string(name='RetryInterval'),
  runConf?: string(name='RunConf'),
  id?: string(name='Id'),
  retryPolicy?: string(name='RetryPolicy'),
  pending?: boolean(name='Pending'),
}

model DescribeFlowNodeInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowNodeInstanceResponseBody(name='body'),
}

async function describeFlowNodeInstanceWithOptions(request: DescribeFlowNodeInstanceRequest, runtime: Util.RuntimeOptions): DescribeFlowNodeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["Id"] = request.id;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlowNodeInstance',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlowNodeInstance(request: DescribeFlowNodeInstanceRequest): DescribeFlowNodeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowNodeInstanceWithOptions(request, runtime);
}

model DescribeFlowNodeInstanceContainerLogRequest {
  offset?: int32(name='Offset'),
  length?: int32(name='Length'),
  nodeInstanceId?: string(name='NodeInstanceId'),
  appId?: string(name='AppId'),
  containerId?: string(name='ContainerId'),
  logName?: string(name='LogName'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowNodeInstanceContainerLogResponseBody = {
  requestId?: string(name='RequestId'),
  logEnd?: boolean(name='LogEnd'),
  logEntrys?: {
    logEntry?: [ 
    {
      content?: string(name='Content'),
    }
  ](name='LogEntry')
  }(name='LogEntrys'),
}

model DescribeFlowNodeInstanceContainerLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowNodeInstanceContainerLogResponseBody(name='body'),
}

async function describeFlowNodeInstanceContainerLogWithOptions(request: DescribeFlowNodeInstanceContainerLogRequest, runtime: Util.RuntimeOptions): DescribeFlowNodeInstanceContainerLogResponse {
  Util.validateModel(request);
  var query = {};
  query["Offset"] = request.offset;
  query["Length"] = request.length;
  query["NodeInstanceId"] = request.nodeInstanceId;
  query["AppId"] = request.appId;
  query["ContainerId"] = request.containerId;
  query["LogName"] = request.logName;
  query["ProjectId"] = request.projectId;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlowNodeInstanceContainerLog',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlowNodeInstanceContainerLog(request: DescribeFlowNodeInstanceContainerLogRequest): DescribeFlowNodeInstanceContainerLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowNodeInstanceContainerLogWithOptions(request, runtime);
}

model DescribeFlowNodeInstanceLauncherLogRequest {
  start?: int32(name='Start'),
  lines?: int32(name='Lines'),
  offset?: int32(name='Offset'),
  length?: int32(name='Length'),
  reverse?: boolean(name='Reverse'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  nodeInstanceId?: string(name='NodeInstanceId'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowNodeInstanceLauncherLogResponseBody = {
  requestId?: string(name='RequestId'),
  logEnd?: boolean(name='LogEnd'),
  logEntrys?: {
    logEntry?: [ 
    {
      content?: string(name='Content'),
    }
  ](name='LogEntry')
  }(name='LogEntrys'),
}

model DescribeFlowNodeInstanceLauncherLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowNodeInstanceLauncherLogResponseBody(name='body'),
}

async function describeFlowNodeInstanceLauncherLogWithOptions(request: DescribeFlowNodeInstanceLauncherLogRequest, runtime: Util.RuntimeOptions): DescribeFlowNodeInstanceLauncherLogResponse {
  Util.validateModel(request);
  var query = {};
  query["Start"] = request.start;
  query["Lines"] = request.lines;
  query["Offset"] = request.offset;
  query["Length"] = request.length;
  query["Reverse"] = request.reverse;
  query["StartTime"] = request.startTime;
  query["EndTime"] = request.endTime;
  query["NodeInstanceId"] = request.nodeInstanceId;
  query["ProjectId"] = request.projectId;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlowNodeInstanceLauncherLog',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlowNodeInstanceLauncherLog(request: DescribeFlowNodeInstanceLauncherLogRequest): DescribeFlowNodeInstanceLauncherLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowNodeInstanceLauncherLogWithOptions(request, runtime);
}

model DescribeFlowProjectRequest {
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowProjectResponseBody = {
  gmtCreate?: long(name='GmtCreate'),
  description?: string(name='Description'),
  requestId?: string(name='RequestId'),
  userId?: string(name='UserId'),
  gmtModified?: long(name='GmtModified'),
  id?: string(name='Id'),
  name?: string(name='Name'),
}

model DescribeFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowProjectResponseBody(name='body'),
}

async function describeFlowProjectWithOptions(request: DescribeFlowProjectRequest, runtime: Util.RuntimeOptions): DescribeFlowProjectResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlowProject',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlowProject(request: DescribeFlowProjectRequest): DescribeFlowProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowProjectWithOptions(request, runtime);
}

model DescribeFlowProjectClusterSettingRequest {
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
}

model DescribeFlowProjectClusterSettingResponseBody = {
  gmtCreate?: long(name='GmtCreate'),
  defaultUser?: string(name='DefaultUser'),
  requestId?: string(name='RequestId'),
  defaultQueue?: string(name='DefaultQueue'),
  clusterId?: string(name='ClusterId'),
  projectId?: string(name='ProjectId'),
  gmtModified?: long(name='GmtModified'),
  hostList?: {
    host?: [ string ](name='Host')
  }(name='HostList'),
  userList?: {
    user?: [ string ](name='User')
  }(name='UserList'),
  k8sClusterId?: string(name='K8sClusterId'),
  queueList?: {
    queue?: [ string ](name='Queue')
  }(name='QueueList'),
}

model DescribeFlowProjectClusterSettingResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowProjectClusterSettingResponseBody(name='body'),
}

async function describeFlowProjectClusterSettingWithOptions(request: DescribeFlowProjectClusterSettingRequest, runtime: Util.RuntimeOptions): DescribeFlowProjectClusterSettingResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlowProjectClusterSetting',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlowProjectClusterSetting(request: DescribeFlowProjectClusterSettingRequest): DescribeFlowProjectClusterSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowProjectClusterSettingWithOptions(request, runtime);
}

model DescribeJobRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeJobResponseBody = {
  failAct?: string(name='FailAct'),
  type?: string(name='Type'),
  runParameter?: string(name='RunParameter'),
  requestId?: string(name='RequestId'),
  retryInterval?: int32(name='RetryInterval'),
  id?: string(name='Id'),
  maxRetry?: int32(name='MaxRetry'),
  name?: string(name='Name'),
}

model DescribeJobResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeJobResponseBody(name='body'),
}

async function describeJobWithOptions(request: DescribeJobRequest, runtime: Util.RuntimeOptions): DescribeJobResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Id"] = request.id;
  query["RegionId"] = request.regionId;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeJob',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeJob(request: DescribeJobRequest): DescribeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJobWithOptions(request, runtime);
}

model DescribeLibraryDetailRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  libraryBizId?: string(name='LibraryBizId'),
}

model DescribeLibraryDetailResponseBody = {
  sourceLocation?: string(name='SourceLocation'),
  type?: string(name='Type'),
  requestId?: string(name='RequestId'),
  scope?: string(name='Scope'),
  userId?: string(name='UserId'),
  createTime?: long(name='CreateTime'),
  sourceType?: string(name='SourceType'),
  libraryVersion?: string(name='LibraryVersion'),
  properties?: string(name='Properties'),
  bizId?: string(name='BizId'),
  name?: string(name='Name'),
}

model DescribeLibraryDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLibraryDetailResponseBody(name='body'),
}

async function describeLibraryDetailWithOptions(request: DescribeLibraryDetailRequest, runtime: Util.RuntimeOptions): DescribeLibraryDetailResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["LibraryBizId"] = request.libraryBizId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLibraryDetail',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLibraryDetail(request: DescribeLibraryDetailRequest): DescribeLibraryDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLibraryDetailWithOptions(request, runtime);
}

model DescribeLibraryInstallTaskDetailRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  taskBizId?: string(name='TaskBizId'),
}

model DescribeLibraryInstallTaskDetailResponseBody = {
  taskId?: string(name='TaskId'),
  endTime?: long(name='EndTime'),
  requestId?: string(name='RequestId'),
  taskGroupId?: string(name='TaskGroupId'),
  executeTime?: long(name='ExecuteTime'),
  hostname?: string(name='Hostname'),
  startTime?: long(name='StartTime'),
  taskStatus?: string(name='TaskStatus'),
  libraryBizId?: string(name='LibraryBizId'),
  taskProcess?: int32(name='TaskProcess'),
  clusterBizId?: string(name='ClusterBizId'),
  taskType?: string(name='TaskType'),
  detail?: string(name='Detail'),
}

model DescribeLibraryInstallTaskDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLibraryInstallTaskDetailResponseBody(name='body'),
}

async function describeLibraryInstallTaskDetailWithOptions(request: DescribeLibraryInstallTaskDetailRequest, runtime: Util.RuntimeOptions): DescribeLibraryInstallTaskDetailResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["TaskBizId"] = request.taskBizId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLibraryInstallTaskDetail',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLibraryInstallTaskDetail(request: DescribeLibraryInstallTaskDetailRequest): DescribeLibraryInstallTaskDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLibraryInstallTaskDetailWithOptions(request, runtime);
}

model DescribeMetaTablePreviewTaskRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  taskId?: string(name='TaskId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeMetaTablePreviewTaskResponseBody = {
  taskId?: string(name='TaskId'),
  endTime?: long(name='EndTime'),
  requestId?: string(name='RequestId'),
  taskProcess?: int32(name='TaskProcess'),
  executeTime?: long(name='ExecuteTime'),
  startTime?: long(name='StartTime'),
  data?: {
    rows?: {
      row?: [ 
      {
        columns?: {
          column?: [ string ](name='Column')
        }(name='Columns'),
      }
    ](name='Row')
    }(name='Rows'),
    headers?: {
      header?: [ string ](name='Header')
    }(name='Headers'),
  }(name='Data'),
  taskStatus?: string(name='TaskStatus'),
}

model DescribeMetaTablePreviewTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMetaTablePreviewTaskResponseBody(name='body'),
}

async function describeMetaTablePreviewTaskWithOptions(request: DescribeMetaTablePreviewTaskRequest, runtime: Util.RuntimeOptions): DescribeMetaTablePreviewTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["TaskId"] = request.taskId;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetaTablePreviewTask',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMetaTablePreviewTask(request: DescribeMetaTablePreviewTaskRequest): DescribeMetaTablePreviewTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetaTablePreviewTaskWithOptions(request, runtime);
}

model DescribeScalingActivityRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostGroupId?: string(name='HostGroupId'),
  scalingActivityId?: string(name='ScalingActivityId'),
}

model DescribeScalingActivityResponseBody = {
  status?: string(name='Status'),
  description?: string(name='Description'),
  endTime?: long(name='EndTime'),
  requestId?: string(name='RequestId'),
  expectNum?: int32(name='ExpectNum'),
  cause?: string(name='Cause'),
  startTime?: long(name='StartTime'),
  scalingRuleId?: string(name='ScalingRuleId'),
  transition?: string(name='Transition'),
  totalCapacity?: int32(name='TotalCapacity'),
  instanceIds?: string(name='InstanceIds'),
  bizId?: string(name='BizId'),
}

model DescribeScalingActivityResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeScalingActivityResponseBody(name='body'),
}

async function describeScalingActivityWithOptions(request: DescribeScalingActivityRequest, runtime: Util.RuntimeOptions): DescribeScalingActivityResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["HostGroupId"] = request.hostGroupId;
  query["ScalingActivityId"] = request.scalingActivityId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScalingActivity',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeScalingActivity(request: DescribeScalingActivityRequest): DescribeScalingActivityResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScalingActivityWithOptions(request, runtime);
}

model DescribeScalingCommonConfigRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeScalingCommonConfigResponseBody = {
  autoScalingHookHeartbeatDefaultTime?: int32(name='AutoScalingHookHeartbeatDefaultTime'),
  autoScalingRuleAlarmDelayLimit?: int32(name='AutoScalingRuleAlarmDelayLimit'),
  requestId?: string(name='RequestId'),
  autoScalingGroupMaxSizeLimit?: int32(name='AutoScalingGroupMaxSizeLimit'),
  autoScalingMNSScalingThreadSleepTime?: long(name='AutoScalingMNSScalingThreadSleepTime'),
  autoScalingConfigDecommissionQueryInterval?: long(name='AutoScalingConfigDecommissionQueryInterval'),
  autoScalingCoolDownTime?: int32(name='AutoScalingCoolDownTime'),
  autoScalingRuleMinDelayLimit?: int32(name='AutoScalingRuleMinDelayLimit'),
  autoScalingRuleAlarmSilentTime?: int32(name='AutoScalingRuleAlarmSilentTime'),
  autoScalingConfigSystemDiskSize?: int32(name='AutoScalingConfigSystemDiskSize'),
  autoScalingGroupMinSizeLimit?: int32(name='AutoScalingGroupMinSizeLimit'),
}

model DescribeScalingCommonConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeScalingCommonConfigResponseBody(name='body'),
}

async function describeScalingCommonConfigWithOptions(request: DescribeScalingCommonConfigRequest, runtime: Util.RuntimeOptions): DescribeScalingCommonConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScalingCommonConfig',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeScalingCommonConfig(request: DescribeScalingCommonConfigRequest): DescribeScalingCommonConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScalingCommonConfigWithOptions(request, runtime);
}

model DescribeScalingConfigItemV2Request {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  configItemType?: string(name='ConfigItemType'),
  scalingConfigItemId?: string(name='ScalingConfigItemId'),
}

model DescribeScalingConfigItemV2ResponseBody = {
  requestId?: string(name='RequestId'),
  scalingConfigItemBizId?: string(name='ScalingConfigItemBizId'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  configItemInformation?: string(name='ConfigItemInformation'),
  configItemType?: string(name='ConfigItemType'),
}

model DescribeScalingConfigItemV2Response = {
  headers: map[string]string(name='headers'),
  body: DescribeScalingConfigItemV2ResponseBody(name='body'),
}

async function describeScalingConfigItemV2WithOptions(request: DescribeScalingConfigItemV2Request, runtime: Util.RuntimeOptions): DescribeScalingConfigItemV2Response {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["ScalingGroupBizId"] = request.scalingGroupBizId;
  query["ConfigItemType"] = request.configItemType;
  query["ScalingConfigItemId"] = request.scalingConfigItemId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScalingConfigItemV2',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeScalingConfigItemV2(request: DescribeScalingConfigItemV2Request): DescribeScalingConfigItemV2Response {
  var runtime = new Util.RuntimeOptions{};
  return describeScalingConfigItemV2WithOptions(request, runtime);
}

model DescribeScalingGroupInstanceV2Request {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  hostGroupBizId?: string(name='HostGroupBizId'),
}

model DescribeScalingGroupInstanceV2ResponseBody = {
  scalingConfig?: {
    dataDiskCategory?: string(name='DataDiskCategory'),
    dataDiskCount?: int32(name='DataDiskCount'),
    instanceTypeList?: {
      instanceType?: [ string ](name='InstanceType')
    }(name='InstanceTypeList'),
    payType?: string(name='PayType'),
    dataDiskSize?: int32(name='DataDiskSize'),
    sysDiskCategory?: string(name='SysDiskCategory'),
    spotPriceLimits?: {
      spotPriceLimit?: [ 
      {
        priceLimit?: float(name='PriceLimit'),
        instanceType?: string(name='InstanceType'),
      }
    ](name='SpotPriceLimit')
    }(name='SpotPriceLimits'),
    spotStrategy?: string(name='SpotStrategy'),
    sysDiskSize?: int32(name='SysDiskSize'),
  }(name='ScalingConfig'),
  activeRuleCategory?: string(name='ActiveRuleCategory'),
  requestId?: string(name='RequestId'),
  timeoutWithGrace?: long(name='TimeoutWithGrace'),
  scalingGroupId?: string(name='ScalingGroupId'),
  maxSize?: int32(name='MaxSize'),
  multiAvailablePolicyParam?: string(name='MultiAvailablePolicyParam'),
  minSize?: int32(name='MinSize'),
  defaultCooldown?: int32(name='DefaultCooldown'),
  hostGroupId?: string(name='HostGroupId'),
  withGrace?: boolean(name='WithGrace'),
  multiAvailablePolicy?: string(name='MultiAvailablePolicy'),
  scalingRuleList?: {
    scalingRule?: [ 
    {
      cloudWatchTrigger?: {
        comparisonOperator?: string(name='ComparisonOperator'),
        metricName?: string(name='MetricName'),
        evaluationCount?: string(name='EvaluationCount'),
        unit?: string(name='Unit'),
        metricDisplayName?: string(name='MetricDisplayName'),
        threshold?: string(name='Threshold'),
        period?: int32(name='Period'),
        statistics?: string(name='Statistics'),
      }(name='CloudWatchTrigger'),
      status?: string(name='Status'),
      adjustmentType?: string(name='AdjustmentType'),
      recurrenceValue?: string(name='RecurrenceValue'),
      recurrenceType?: string(name='RecurrenceType'),
      timeoutWithGrace?: long(name='TimeoutWithGrace'),
      recurrenceEndTime?: string(name='RecurrenceEndTime'),
      ruleName?: string(name='RuleName'),
      scalingGroupId?: long(name='ScalingGroupId'),
      ruleCategory?: string(name='RuleCategory'),
      launchExpirationTime?: int32(name='LaunchExpirationTime'),
      cooldown?: int32(name='Cooldown'),
      adjustmentValue?: int32(name='AdjustmentValue'),
      schedulerTrigger?: {
        launchExpirationTime?: int32(name='LaunchExpirationTime'),
        recurrenceValue?: string(name='RecurrenceValue'),
        recurrenceType?: string(name='RecurrenceType'),
        recurrenceEndTime?: long(name='RecurrenceEndTime'),
        launchTime?: long(name='LaunchTime'),
      }(name='SchedulerTrigger'),
      launchTime?: string(name='LaunchTime'),
      withGrace?: boolean(name='WithGrace'),
      essScalingRuleId?: string(name='EssScalingRuleId'),
    }
  ](name='ScalingRule')
  }(name='ScalingRuleList'),
}

model DescribeScalingGroupInstanceV2Response = {
  headers: map[string]string(name='headers'),
  body: DescribeScalingGroupInstanceV2ResponseBody(name='body'),
}

async function describeScalingGroupInstanceV2WithOptions(request: DescribeScalingGroupInstanceV2Request, runtime: Util.RuntimeOptions): DescribeScalingGroupInstanceV2Response {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["ScalingGroupBizId"] = request.scalingGroupBizId;
  query["HostGroupBizId"] = request.hostGroupBizId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScalingGroupInstanceV2',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeScalingGroupInstanceV2(request: DescribeScalingGroupInstanceV2Request): DescribeScalingGroupInstanceV2Response {
  var runtime = new Util.RuntimeOptions{};
  return describeScalingGroupInstanceV2WithOptions(request, runtime);
}

model DescribeScalingGroupV2Request {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  hostGroupBizId?: string(name='HostGroupBizId'),
}

model DescribeScalingGroupV2ResponseBody = {
  description?: string(name='Description'),
  hostGroupBizId?: string(name='HostGroupBizId'),
  requestId?: string(name='RequestId'),
  configState?: string(name='ConfigState'),
  scalingInMode?: string(name='ScalingInMode'),
  scalingGroupId?: string(name='ScalingGroupId'),
  scalingMaxSize?: int32(name='ScalingMaxSize'),
  scalingMinSize?: int32(name='ScalingMinSize'),
  name?: string(name='Name'),
  activeStatus?: string(name='ActiveStatus'),
}

model DescribeScalingGroupV2Response = {
  headers: map[string]string(name='headers'),
  body: DescribeScalingGroupV2ResponseBody(name='body'),
}

async function describeScalingGroupV2WithOptions(request: DescribeScalingGroupV2Request, runtime: Util.RuntimeOptions): DescribeScalingGroupV2Response {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["ScalingGroupBizId"] = request.scalingGroupBizId;
  query["HostGroupBizId"] = request.hostGroupBizId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScalingGroupV2',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeScalingGroupV2(request: DescribeScalingGroupV2Request): DescribeScalingGroupV2Response {
  var runtime = new Util.RuntimeOptions{};
  return describeScalingGroupV2WithOptions(request, runtime);
}

model DescribeScalingRuleRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostGroupId?: string(name='HostGroupId'),
  scalingRuleId?: string(name='ScalingRuleId'),
}

model DescribeScalingRuleResponseBody = {
  status?: string(name='Status'),
  timeoutWithGrace?: long(name='TimeoutWithGrace'),
  requestId?: string(name='RequestId'),
  cooldown?: int32(name='Cooldown'),
  cloudWatchTrigger?: {
    comparisonOperator?: string(name='ComparisonOperator'),
    metricName?: string(name='MetricName'),
    evaluationCount?: string(name='EvaluationCount'),
    unit?: string(name='Unit'),
    metricDisplayName?: string(name='MetricDisplayName'),
    threshold?: string(name='Threshold'),
    period?: int32(name='Period'),
    statistics?: string(name='Statistics'),
  }(name='CloudWatchTrigger'),
  gmtModified?: string(name='GmtModified'),
  adjustmentType?: string(name='AdjustmentType'),
  gmtCreate?: string(name='GmtCreate'),
  adjustmentValue?: int32(name='AdjustmentValue'),
  schedulerTrigger?: {
    launchExpirationTime?: int32(name='LaunchExpirationTime'),
    recurrenceValue?: string(name='RecurrenceValue'),
    recurrenceType?: string(name='RecurrenceType'),
    recurrenceEndTime?: long(name='RecurrenceEndTime'),
    launchTime?: long(name='LaunchTime'),
  }(name='SchedulerTrigger'),
  withGrace?: boolean(name='WithGrace'),
  id?: string(name='Id'),
  ruleName?: string(name='RuleName'),
  ruleCategory?: string(name='RuleCategory'),
}

model DescribeScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeScalingRuleResponseBody(name='body'),
}

async function describeScalingRuleWithOptions(request: DescribeScalingRuleRequest, runtime: Util.RuntimeOptions): DescribeScalingRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["HostGroupId"] = request.hostGroupId;
  query["ScalingRuleId"] = request.scalingRuleId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScalingRule',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeScalingRule(request: DescribeScalingRuleRequest): DescribeScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScalingRuleWithOptions(request, runtime);
}

model DescribeSecurityGroupAttributeRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeSecurityGroupAttributeResponseBody = {
  requestId?: string(name='RequestId'),
  availableGroupList?: {
    securityGroup?: [ 
    {
      vpcId?: string(name='VpcId'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupName?: string(name='SecurityGroupName'),
      ecsCount?: int32(name='EcsCount'),
      availableInstanceAmount?: int32(name='AvailableInstanceAmount'),
    }
  ](name='SecurityGroup')
  }(name='AvailableGroupList'),
  securityGroupAttributeList?: {
    securityGroupAttribute?: [ 
    {
      bizContent?: string(name='BizContent'),
      bizType?: string(name='BizType'),
    }
  ](name='SecurityGroupAttribute')
  }(name='SecurityGroupAttributeList'),
}

model DescribeSecurityGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityGroupAttributeResponseBody(name='body'),
}

async function describeSecurityGroupAttributeWithOptions(request: DescribeSecurityGroupAttributeRequest, runtime: Util.RuntimeOptions): DescribeSecurityGroupAttributeResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityGroupAttribute',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSecurityGroupAttribute(request: DescribeSecurityGroupAttributeRequest): DescribeSecurityGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityGroupAttributeWithOptions(request, runtime);
}

model DetachAndReleaseClusterEniRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  targetClusterId?: string(name='TargetClusterId'),
  vswitchId?: string(name='VswitchId'),
}

model DetachAndReleaseClusterEniResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachAndReleaseClusterEniResponse = {
  headers: map[string]string(name='headers'),
  body: DetachAndReleaseClusterEniResponseBody(name='body'),
}

async function detachAndReleaseClusterEniWithOptions(request: DetachAndReleaseClusterEniRequest, runtime: Util.RuntimeOptions): DetachAndReleaseClusterEniResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["TargetClusterId"] = request.targetClusterId;
  query["VswitchId"] = request.vswitchId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetachAndReleaseClusterEni',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachAndReleaseClusterEni(request: DetachAndReleaseClusterEniRequest): DetachAndReleaseClusterEniResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachAndReleaseClusterEniWithOptions(request, runtime);
}

model GetHdfsCapacityStatisticInfoRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  fromDatetime?: string(name='FromDatetime'),
  toDatetime?: string(name='ToDatetime'),
}

model GetHdfsCapacityStatisticInfoResponseBody = {
  requestId?: string(name='RequestId'),
  hdfsCapacityList?: {
    clusterStatHdfsCapacity?: [ 
    {
      capacityUsedNonDfs?: long(name='CapacityUsedNonDfs'),
      capacityTotal?: long(name='CapacityTotal'),
      capacityTotalGB?: long(name='CapacityTotalGB'),
      capacityRemaining?: long(name='CapacityRemaining'),
      capacityUsed?: long(name='CapacityUsed'),
      clusterBizId?: string(name='ClusterBizId'),
      capacityUsedGB?: long(name='CapacityUsedGB'),
      dateTime?: string(name='DateTime'),
      capacityRemainingGB?: long(name='CapacityRemainingGB'),
    }
  ](name='ClusterStatHdfsCapacity')
  }(name='HdfsCapacityList'),
}

model GetHdfsCapacityStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetHdfsCapacityStatisticInfoResponseBody(name='body'),
}

async function getHdfsCapacityStatisticInfoWithOptions(request: GetHdfsCapacityStatisticInfoRequest, runtime: Util.RuntimeOptions): GetHdfsCapacityStatisticInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["FromDatetime"] = request.fromDatetime;
  query["ToDatetime"] = request.toDatetime;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetHdfsCapacityStatisticInfo',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHdfsCapacityStatisticInfo(request: GetHdfsCapacityStatisticInfoRequest): GetHdfsCapacityStatisticInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHdfsCapacityStatisticInfoWithOptions(request, runtime);
}

model GetJobInputStatisticInfoRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  fromDatetime?: string(name='FromDatetime'),
  toDatetime?: string(name='ToDatetime'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
}

model GetJobInputStatisticInfoResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  jobInputList?: {
    clusterStatJobInput?: [ 
    {
      startTime?: long(name='StartTime'),
      finishTime?: long(name='FinishTime'),
      state?: string(name='State'),
      bytesInput?: long(name='BytesInput'),
      jobId?: string(name='JobId'),
      user?: string(name='User'),
      queue?: string(name='Queue'),
      name?: string(name='Name'),
      applicationId?: string(name='ApplicationId'),
    }
  ](name='ClusterStatJobInput')
  }(name='JobInputList'),
  total?: int32(name='Total'),
}

model GetJobInputStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobInputStatisticInfoResponseBody(name='body'),
}

async function getJobInputStatisticInfoWithOptions(request: GetJobInputStatisticInfoRequest, runtime: Util.RuntimeOptions): GetJobInputStatisticInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["FromDatetime"] = request.fromDatetime;
  query["ToDatetime"] = request.toDatetime;
  query["PageSize"] = request.pageSize;
  query["PageNumber"] = request.pageNumber;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetJobInputStatisticInfo',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJobInputStatisticInfo(request: GetJobInputStatisticInfoRequest): GetJobInputStatisticInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobInputStatisticInfoWithOptions(request, runtime);
}

model GetJobOutputStatisticInfoRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  fromDatetime?: string(name='FromDatetime'),
  toDatetime?: string(name='ToDatetime'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
}

model GetJobOutputStatisticInfoResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  jobOutputList?: {
    clusterStatJobOutput?: [ 
    {
      startTime?: long(name='StartTime'),
      finishTime?: long(name='FinishTime'),
      state?: string(name='State'),
      jobId?: string(name='JobId'),
      user?: string(name='User'),
      queue?: string(name='Queue'),
      bytesOutput?: long(name='BytesOutput'),
      name?: string(name='Name'),
      applicationId?: string(name='ApplicationId'),
    }
  ](name='ClusterStatJobOutput')
  }(name='JobOutputList'),
}

model GetJobOutputStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobOutputStatisticInfoResponseBody(name='body'),
}

async function getJobOutputStatisticInfoWithOptions(request: GetJobOutputStatisticInfoRequest, runtime: Util.RuntimeOptions): GetJobOutputStatisticInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["FromDatetime"] = request.fromDatetime;
  query["ToDatetime"] = request.toDatetime;
  query["PageSize"] = request.pageSize;
  query["PageNumber"] = request.pageNumber;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetJobOutputStatisticInfo',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJobOutputStatisticInfo(request: GetJobOutputStatisticInfoRequest): GetJobOutputStatisticInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobOutputStatisticInfoWithOptions(request, runtime);
}

model GetJobRunningTimeStatisticInfoRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  fromDatetime?: string(name='FromDatetime'),
  toDatetime?: string(name='ToDatetime'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
}

model GetJobRunningTimeStatisticInfoResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  runningTimeList?: {
    clusterStatJobRunningTime?: [ 
    {
      startTime?: long(name='StartTime'),
      runningTime?: long(name='RunningTime'),
      finishTime?: long(name='FinishTime'),
      state?: string(name='State'),
      jobId?: string(name='JobId'),
      user?: string(name='User'),
      queue?: string(name='Queue'),
      name?: string(name='Name'),
      applicationId?: string(name='ApplicationId'),
    }
  ](name='ClusterStatJobRunningTime')
  }(name='RunningTimeList'),
}

model GetJobRunningTimeStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobRunningTimeStatisticInfoResponseBody(name='body'),
}

async function getJobRunningTimeStatisticInfoWithOptions(request: GetJobRunningTimeStatisticInfoRequest, runtime: Util.RuntimeOptions): GetJobRunningTimeStatisticInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["FromDatetime"] = request.fromDatetime;
  query["ToDatetime"] = request.toDatetime;
  query["PageSize"] = request.pageSize;
  query["PageNumber"] = request.pageNumber;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetJobRunningTimeStatisticInfo',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJobRunningTimeStatisticInfo(request: GetJobRunningTimeStatisticInfoRequest): GetJobRunningTimeStatisticInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobRunningTimeStatisticInfoWithOptions(request, runtime);
}

model GetQueueInputStatisticInfoRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  fromDatetime?: string(name='FromDatetime'),
  toDatetime?: string(name='ToDatetime'),
}

model GetQueueInputStatisticInfoResponseBody = {
  requestId?: string(name='RequestId'),
  queueInputList?: {
    clusterStatQueueInput?: [ 
    {
      bytesInput?: long(name='BytesInput'),
      queue?: string(name='Queue'),
    }
  ](name='ClusterStatQueueInput')
  }(name='QueueInputList'),
}

model GetQueueInputStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetQueueInputStatisticInfoResponseBody(name='body'),
}

async function getQueueInputStatisticInfoWithOptions(request: GetQueueInputStatisticInfoRequest, runtime: Util.RuntimeOptions): GetQueueInputStatisticInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["FromDatetime"] = request.fromDatetime;
  query["ToDatetime"] = request.toDatetime;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetQueueInputStatisticInfo',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getQueueInputStatisticInfo(request: GetQueueInputStatisticInfoRequest): GetQueueInputStatisticInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQueueInputStatisticInfoWithOptions(request, runtime);
}

model GetQueueOutputStatisticInfoRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  fromDatetime?: string(name='FromDatetime'),
  toDatetime?: string(name='ToDatetime'),
}

model GetQueueOutputStatisticInfoResponseBody = {
  requestId?: string(name='RequestId'),
  queueOutputList?: {
    clusterStatQueueOutput?: [ 
    {
      queue?: string(name='Queue'),
      bytesOutput?: long(name='BytesOutput'),
    }
  ](name='ClusterStatQueueOutput')
  }(name='QueueOutputList'),
}

model GetQueueOutputStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetQueueOutputStatisticInfoResponseBody(name='body'),
}

async function getQueueOutputStatisticInfoWithOptions(request: GetQueueOutputStatisticInfoRequest, runtime: Util.RuntimeOptions): GetQueueOutputStatisticInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["FromDatetime"] = request.fromDatetime;
  query["ToDatetime"] = request.toDatetime;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetQueueOutputStatisticInfo',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getQueueOutputStatisticInfo(request: GetQueueOutputStatisticInfoRequest): GetQueueOutputStatisticInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQueueOutputStatisticInfoWithOptions(request, runtime);
}

model GetQueueSubmissionStatisticInfoRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  fromDatetime?: string(name='FromDatetime'),
  toDatetime?: string(name='ToDatetime'),
  applicationType?: string(name='ApplicationType'),
  finalStatus?: string(name='FinalStatus'),
}

model GetQueueSubmissionStatisticInfoResponseBody = {
  requestId?: string(name='RequestId'),
  queueSubmissionList?: {
    clusterStatQueueSubmission?: [ 
    {
      submission?: long(name='Submission'),
      queue?: string(name='Queue'),
    }
  ](name='ClusterStatQueueSubmission')
  }(name='QueueSubmissionList'),
}

model GetQueueSubmissionStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetQueueSubmissionStatisticInfoResponseBody(name='body'),
}

async function getQueueSubmissionStatisticInfoWithOptions(request: GetQueueSubmissionStatisticInfoRequest, runtime: Util.RuntimeOptions): GetQueueSubmissionStatisticInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["FromDatetime"] = request.fromDatetime;
  query["ToDatetime"] = request.toDatetime;
  query["ApplicationType"] = request.applicationType;
  query["FinalStatus"] = request.finalStatus;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetQueueSubmissionStatisticInfo',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getQueueSubmissionStatisticInfo(request: GetQueueSubmissionStatisticInfoRequest): GetQueueSubmissionStatisticInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQueueSubmissionStatisticInfoWithOptions(request, runtime);
}

model GetUserInputStatisticInfoRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  fromDatetime?: string(name='FromDatetime'),
  toDatetime?: string(name='ToDatetime'),
}

model GetUserInputStatisticInfoResponseBody = {
  requestId?: string(name='RequestId'),
  userInputList?: {
    clusterStatUserInput?: [ 
    {
      bytesInput?: long(name='BytesInput'),
      user?: string(name='User'),
    }
  ](name='ClusterStatUserInput')
  }(name='UserInputList'),
}

model GetUserInputStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserInputStatisticInfoResponseBody(name='body'),
}

async function getUserInputStatisticInfoWithOptions(request: GetUserInputStatisticInfoRequest, runtime: Util.RuntimeOptions): GetUserInputStatisticInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["FromDatetime"] = request.fromDatetime;
  query["ToDatetime"] = request.toDatetime;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetUserInputStatisticInfo',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserInputStatisticInfo(request: GetUserInputStatisticInfoRequest): GetUserInputStatisticInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserInputStatisticInfoWithOptions(request, runtime);
}

model GetUserOutputStatisticInfoRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  fromDatetime?: string(name='FromDatetime'),
  toDatetime?: string(name='ToDatetime'),
}

model GetUserOutputStatisticInfoResponseBody = {
  requestId?: string(name='RequestId'),
  userOutputList?: {
    clusterStatUserOutput?: [ 
    {
      user?: string(name='User'),
      bytesOutput?: long(name='BytesOutput'),
    }
  ](name='ClusterStatUserOutput')
  }(name='UserOutputList'),
}

model GetUserOutputStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserOutputStatisticInfoResponseBody(name='body'),
}

async function getUserOutputStatisticInfoWithOptions(request: GetUserOutputStatisticInfoRequest, runtime: Util.RuntimeOptions): GetUserOutputStatisticInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["FromDatetime"] = request.fromDatetime;
  query["ToDatetime"] = request.toDatetime;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetUserOutputStatisticInfo',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserOutputStatisticInfo(request: GetUserOutputStatisticInfoRequest): GetUserOutputStatisticInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserOutputStatisticInfoWithOptions(request, runtime);
}

model GetUserSubmissionStatisticInfoRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  fromDatetime?: string(name='FromDatetime'),
  toDatetime?: string(name='ToDatetime'),
  applicationType?: string(name='ApplicationType'),
  finalStatus?: string(name='FinalStatus'),
}

model GetUserSubmissionStatisticInfoResponseBody = {
  requestId?: string(name='RequestId'),
  userSubmissionList?: {
    clusterStatUserSubmission?: [ 
    {
      submission?: long(name='Submission'),
      user?: string(name='User'),
    }
  ](name='ClusterStatUserSubmission')
  }(name='UserSubmissionList'),
}

model GetUserSubmissionStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserSubmissionStatisticInfoResponseBody(name='body'),
}

async function getUserSubmissionStatisticInfoWithOptions(request: GetUserSubmissionStatisticInfoRequest, runtime: Util.RuntimeOptions): GetUserSubmissionStatisticInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["FromDatetime"] = request.fromDatetime;
  query["ToDatetime"] = request.toDatetime;
  query["ApplicationType"] = request.applicationType;
  query["FinalStatus"] = request.finalStatus;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetUserSubmissionStatisticInfo',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserSubmissionStatisticInfo(request: GetUserSubmissionStatisticInfoRequest): GetUserSubmissionStatisticInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserSubmissionStatisticInfoWithOptions(request, runtime);
}

model InstallLibrariesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  libraryBizId?: string(name='LibraryBizId'),
  clusterBizIdList?: [ string ](name='ClusterBizIdList'),
}

model InstallLibrariesResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model InstallLibrariesResponse = {
  headers: map[string]string(name='headers'),
  body: InstallLibrariesResponseBody(name='body'),
}

async function installLibrariesWithOptions(request: InstallLibrariesRequest, runtime: Util.RuntimeOptions): InstallLibrariesResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["LibraryBizId"] = request.libraryBizId;
  query["ClusterBizIdList"] = request.clusterBizIdList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'InstallLibraries',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installLibraries(request: InstallLibrariesRequest): InstallLibrariesResponse {
  var runtime = new Util.RuntimeOptions{};
  return installLibrariesWithOptions(request, runtime);
}

model JoinResourceGroupRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
  resourceId?: string(name='ResourceId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model JoinResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model JoinResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: JoinResourceGroupResponseBody(name='body'),
}

async function joinResourceGroupWithOptions(request: JoinResourceGroupRequest, runtime: Util.RuntimeOptions): JoinResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceType"] = request.resourceType;
  query["ResourceId"] = request.resourceId;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'JoinResourceGroup',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function joinResourceGroup(request: JoinResourceGroupRequest): JoinResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return joinResourceGroupWithOptions(request, runtime);
}

model KillFlowJobRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  jobInstanceId?: string(name='JobInstanceId'),
}

model KillFlowJobResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model KillFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: KillFlowJobResponseBody(name='body'),
}

async function killFlowJobWithOptions(request: KillFlowJobRequest, runtime: Util.RuntimeOptions): KillFlowJobResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["JobInstanceId"] = request.jobInstanceId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'KillFlowJob',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function killFlowJob(request: KillFlowJobRequest): KillFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return killFlowJobWithOptions(request, runtime);
}

model ListAdviceActionRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
  component?: string(name='Component'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListAdviceActionResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  items?: {
    item?: [ 
    {
      hostgroupName?: string(name='HostgroupName'),
      configName?: string(name='ConfigName'),
      actionType?: string(name='ActionType'),
      command?: string(name='Command'),
      gmtCreate?: long(name='GmtCreate'),
      component?: string(name='Component'),
      configItemKey?: string(name='ConfigItemKey'),
      gmtModified?: long(name='GmtModified'),
      serviceName?: string(name='ServiceName'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='Item')
  }(name='Items'),
}

model ListAdviceActionResponse = {
  headers: map[string]string(name='headers'),
  body: ListAdviceActionResponseBody(name='body'),
}

async function listAdviceActionWithOptions(request: ListAdviceActionRequest, runtime: Util.RuntimeOptions): ListAdviceActionResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["ServiceName"] = request.serviceName;
  query["Component"] = request.component;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListAdviceAction',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAdviceAction(request: ListAdviceActionRequest): ListAdviceActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAdviceActionWithOptions(request, runtime);
}

model ListApmApplicationRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  startTimeFrom?: long(name='StartTimeFrom'),
  startTimeTo?: long(name='StartTimeTo'),
  endTimeFrom?: long(name='EndTimeFrom'),
  endTimeTo?: long(name='EndTimeTo'),
  clusterId?: string(name='ClusterId'),
  appId?: string(name='AppId'),
  state?: string(name='State'),
  finalStatus?: string(name='FinalStatus'),
  user?: string(name='User'),
  queue?: string(name='Queue'),
  name?: string(name='Name'),
  jobType?: string(name='JobType'),
  orderBy?: string(name='OrderBy'),
  diagnoseResult?: string(name='DiagnoseResult'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListApmApplicationResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  apmAppInfoList?: {
    apmAppInfo?: [ 
    {
      vcoreSeconds?: long(name='VcoreSeconds'),
      diagnostics?: string(name='Diagnostics'),
      queue?: string(name='Queue'),
      diagnoseCode?: string(name='DiagnoseCode'),
      finalStatus?: string(name='FinalStatus'),
      allocatedVcore?: long(name='AllocatedVcore'),
      queueUsagePercent?: float(name='QueueUsagePercent'),
      name?: string(name='Name'),
      resourceRequests?: string(name='ResourceRequests'),
      progress?: float(name='Progress'),
      state?: string(name='State'),
      clusterUsagePercent?: float(name='ClusterUsagePercent'),
      runningContainers?: int32(name='RunningContainers'),
      applicationType?: string(name='ApplicationType'),
      user?: string(name='User'),
      allocatedMemory?: long(name='AllocatedMemory'),
      runningDuration?: int32(name='RunningDuration'),
      memorySeconds?: long(name='MemorySeconds'),
      startTime?: long(name='StartTime'),
      diagnoseResult?: string(name='DiagnoseResult'),
      finishedTime?: long(name='FinishedTime'),
      duration?: int32(name='Duration'),
      clusterBizId?: string(name='ClusterBizId'),
      applicationId?: string(name='ApplicationId'),
      submitTime?: long(name='SubmitTime'),
    }
  ](name='ApmAppInfo')
  }(name='ApmAppInfoList'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
}

model ListApmApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: ListApmApplicationResponseBody(name='body'),
}

async function listApmApplicationWithOptions(request: ListApmApplicationRequest, runtime: Util.RuntimeOptions): ListApmApplicationResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["StartTimeFrom"] = request.startTimeFrom;
  query["StartTimeTo"] = request.startTimeTo;
  query["EndTimeFrom"] = request.endTimeFrom;
  query["EndTimeTo"] = request.endTimeTo;
  query["ClusterId"] = request.clusterId;
  query["AppId"] = request.appId;
  query["State"] = request.state;
  query["FinalStatus"] = request.finalStatus;
  query["User"] = request.user;
  query["Queue"] = request.queue;
  query["Name"] = request.name;
  query["JobType"] = request.jobType;
  query["OrderBy"] = request.orderBy;
  query["DiagnoseResult"] = request.diagnoseResult;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListApmApplication',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listApmApplication(request: ListApmApplicationRequest): ListApmApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApmApplicationWithOptions(request, runtime);
}

model ListBackupsRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  limit?: int32(name='Limit'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  currentSize?: int32(name='CurrentSize'),
  pageCount?: int32(name='PageCount'),
  orderMode?: string(name='OrderMode'),
  id?: long(name='Id'),
  bizId?: string(name='BizId'),
  metadataType?: string(name='MetadataType'),
  serviceName?: string(name='ServiceName'),
  backupPlanId?: string(name='BackupPlanId'),
  clusterId?: string(name='ClusterId'),
  status?: string(name='Status'),
  backupId?: [ string ](name='BackupId'),
}

model ListBackupsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  items?: {
    item?: [ 
    {
      status?: string(name='Status'),
      tarFileName?: string(name='TarFileName'),
      storePath?: string(name='StorePath'),
      createTime?: long(name='CreateTime'),
      md5?: string(name='Md5'),
      backupPlanId?: string(name='BackupPlanId'),
      metadataInfo?: {
        metadataType?: string(name='MetadataType'),
        properties?: string(name='Properties'),
      }(name='MetadataInfo'),
      id?: string(name='Id'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='Item')
  }(name='Items'),
}

model ListBackupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListBackupsResponseBody(name='body'),
}

async function listBackupsWithOptions(request: ListBackupsRequest, runtime: Util.RuntimeOptions): ListBackupsResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Limit"] = request.limit;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["CurrentSize"] = request.currentSize;
  query["PageCount"] = request.pageCount;
  query["OrderMode"] = request.orderMode;
  query["Id"] = request.id;
  query["BizId"] = request.bizId;
  query["MetadataType"] = request.metadataType;
  query["ServiceName"] = request.serviceName;
  query["BackupPlanId"] = request.backupPlanId;
  query["ClusterId"] = request.clusterId;
  query["Status"] = request.status;
  query["BackupId"] = request.backupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListBackups',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBackups(request: ListBackupsRequest): ListBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBackupsWithOptions(request, runtime);
}

model ListClusterHostRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostInstanceId?: string(name='HostInstanceId'),
  hostGroupId?: string(name='HostGroupId'),
  hostName?: string(name='HostName'),
  privateIp?: string(name='PrivateIp'),
  publicIp?: string(name='PublicIp'),
  groupType?: string(name='GroupType'),
  componentName?: string(name='ComponentName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  statusList?: [ string ](name='StatusList'),
}

model ListClusterHostResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  hostList?: {
    host?: [ 
    {
      status?: string(name='Status'),
      type?: string(name='Type'),
      serialNumber?: string(name='SerialNumber'),
      privateIp?: string(name='PrivateIp'),
      diskList?: {
        disk?: [ 
        {
          type?: string(name='Type'),
          diskMountPoint?: string(name='DiskMountPoint'),
          blockMountPoint?: string(name='BlockMountPoint'),
          device?: string(name='Device'),
          diskSize?: int32(name='DiskSize'),
          event?: string(name='Event'),
          diskType?: string(name='DiskType'),
          diskId?: string(name='DiskId'),
        }
      ](name='Disk')
      }(name='DiskList'),
      createTime?: string(name='CreateTime'),
      chargeType?: string(name='ChargeType'),
      hostName?: string(name='HostName'),
      hostGroupId?: string(name='HostGroupId'),
      instanceType?: string(name='InstanceType'),
      hostInstanceId?: string(name='HostInstanceId'),
      supportIpV6?: boolean(name='SupportIpV6'),
      cpu?: int32(name='Cpu'),
      expiredTime?: long(name='ExpiredTime'),
      zoneId?: string(name='ZoneId'),
      publicIp?: string(name='PublicIp'),
      instanceStatus?: string(name='InstanceStatus'),
      memory?: int32(name='Memory'),
      emrExpiredTime?: string(name='EmrExpiredTime'),
      role?: string(name='Role'),
    }
  ](name='Host')
  }(name='HostList'),
}

model ListClusterHostResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterHostResponseBody(name='body'),
}

async function listClusterHostWithOptions(request: ListClusterHostRequest, runtime: Util.RuntimeOptions): ListClusterHostResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["HostInstanceId"] = request.hostInstanceId;
  query["HostGroupId"] = request.hostGroupId;
  query["HostName"] = request.hostName;
  query["PrivateIp"] = request.privateIp;
  query["PublicIp"] = request.publicIp;
  query["GroupType"] = request.groupType;
  query["ComponentName"] = request.componentName;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["StatusList"] = request.statusList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterHost',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterHost(request: ListClusterHostRequest): ListClusterHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterHostWithOptions(request, runtime);
}

model ListClusterHostComponentRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostInstanceId?: string(name='HostInstanceId'),
  hostName?: string(name='HostName'),
  serviceName?: string(name='ServiceName'),
  componentName?: string(name='ComponentName'),
  componentStatus?: string(name='ComponentStatus'),
  hostRole?: string(name='HostRole'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterHostComponentResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  componentList?: {
    component?: [ 
    {
      serviceDisplayName?: string(name='ServiceDisplayName'),
      status?: string(name='Status'),
      serialNumber?: string(name='SerialNumber'),
      serverStatus?: string(name='ServerStatus'),
      privateIp?: string(name='PrivateIp'),
      componentName?: string(name='ComponentName'),
      commissionStatus?: string(name='CommissionStatus'),
      hostName?: string(name='HostName'),
      needRestart?: boolean(name='NeedRestart'),
      instanceType?: string(name='InstanceType'),
      hostId?: string(name='HostId'),
      hostInstanceId?: string(name='HostInstanceId'),
      cpu?: int32(name='Cpu'),
      componentDisplayName?: string(name='ComponentDisplayName'),
      publicIp?: string(name='PublicIp'),
      memory?: int32(name='Memory'),
      role?: string(name='Role'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='Component')
  }(name='ComponentList'),
}

model ListClusterHostComponentResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterHostComponentResponseBody(name='body'),
}

async function listClusterHostComponentWithOptions(request: ListClusterHostComponentRequest, runtime: Util.RuntimeOptions): ListClusterHostComponentResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["HostInstanceId"] = request.hostInstanceId;
  query["HostName"] = request.hostName;
  query["ServiceName"] = request.serviceName;
  query["ComponentName"] = request.componentName;
  query["ComponentStatus"] = request.componentStatus;
  query["HostRole"] = request.hostRole;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterHostComponent',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterHostComponent(request: ListClusterHostComponentRequest): ListClusterHostComponentResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterHostComponentWithOptions(request, runtime);
}

model ListClusterHostGroupRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostGroupId?: string(name='HostGroupId'),
  hostGroupName?: string(name='HostGroupName'),
  hostGroupType?: string(name='HostGroupType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  statusList?: [ string ](name='StatusList'),
}

model ListClusterHostGroupResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  clusterId?: string(name='ClusterId'),
  total?: int32(name='Total'),
  hostGroupList?: {
    hostGroup?: [ 
    {
      status?: string(name='Status'),
      hostGroupSubType?: string(name='HostGroupSubType'),
      hostGroupType?: string(name='HostGroupType'),
      comment?: string(name='Comment'),
      scalingGroupMinNode?: int32(name='ScalingGroupMinNode'),
      vswitchId?: string(name='VswitchId'),
      securityGroupId?: string(name='SecurityGroupId'),
      hostGroupChangeStatus?: string(name='HostGroupChangeStatus'),
      chargeType?: string(name='ChargeType'),
      payType?: string(name='PayType'),
      dataDiskType?: string(name='DataDiskType'),
      systemDiskCount?: int32(name='SystemDiskCount'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      scalingGroupBizId?: string(name='ScalingGroupBizId'),
      gmtModified?: string(name='gmtModified'),
      memory?: int32(name='Memory'),
      scalingGroupMaxNode?: int32(name='ScalingGroupMaxNode'),
      hostGroupChangeType?: string(name='HostGroupChangeType'),
      lockType?: string(name='LockType'),
      scalingInMode?: string(name='ScalingInMode'),
      costSavingPercent?: float(name='CostSavingPercent'),
      dataDiskSize?: int32(name='DataDiskSize'),
      lockReason?: string(name='LockReason'),
      hostGroupId?: string(name='HostGroupId'),
      gmtCreate?: string(name='gmtCreate'),
      instanceType?: string(name='InstanceType'),
      cpu?: int32(name='Cpu'),
      dataDiskCount?: int32(name='DataDiskCount'),
      scalingGroupActiveStatus?: string(name='ScalingGroupActiveStatus'),
      nodeCount?: int32(name='NodeCount'),
      systemDiskType?: string(name='SystemDiskType'),
      scalingGroupConfigState?: string(name='ScalingGroupConfigState'),
      hostGroupName?: string(name='HostGroupName'),
    }
  ](name='HostGroup')
  }(name='HostGroupList'),
}

model ListClusterHostGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterHostGroupResponseBody(name='body'),
}

async function listClusterHostGroupWithOptions(request: ListClusterHostGroupRequest, runtime: Util.RuntimeOptions): ListClusterHostGroupResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["HostGroupId"] = request.hostGroupId;
  query["HostGroupName"] = request.hostGroupName;
  query["HostGroupType"] = request.hostGroupType;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["StatusList"] = request.statusList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterHostGroup',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterHostGroup(request: ListClusterHostGroupRequest): ListClusterHostGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterHostGroupWithOptions(request, runtime);
}

model ListClusterInstalledServiceRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterInstalledServiceResponseBody = {
  requestId?: string(name='RequestId'),
  clusterInstalledServiceList?: {
    clusterInstalledService?: [ 
    {
      serviceEcmVersion?: string(name='ServiceEcmVersion'),
      serviceDisplayName?: string(name='ServiceDisplayName'),
      serviceActionList?: {
        serviceAction?: [ 
        {
          displayName?: string(name='DisplayName'),
          componentName?: string(name='ComponentName'),
          command?: string(name='Command'),
          actionName?: string(name='ActionName'),
          serviceName?: string(name='ServiceName'),
        }
      ](name='ServiceAction')
      }(name='ServiceActionList'),
      notStartedNum?: int32(name='notStartedNum'),
      serviceVersion?: string(name='ServiceVersion'),
      comment?: string(name='comment'),
      abnormalNum?: int32(name='abnormalNum'),
      serviceName?: string(name='ServiceName'),
      onlyClient?: boolean(name='onlyClient'),
      serviceStatus?: string(name='serviceStatus'),
      needRestartNum?: int32(name='needRestartNum'),
    }
  ](name='ClusterInstalledService')
  }(name='ClusterInstalledServiceList'),
}

model ListClusterInstalledServiceResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterInstalledServiceResponseBody(name='body'),
}

async function listClusterInstalledServiceWithOptions(request: ListClusterInstalledServiceRequest, runtime: Util.RuntimeOptions): ListClusterInstalledServiceResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterInstalledService',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterInstalledService(request: ListClusterInstalledServiceRequest): ListClusterInstalledServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterInstalledServiceWithOptions(request, runtime);
}

model ListClusterOperationRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  operationId?: string(name='OperationId'),
  serviceName?: string(name='ServiceName'),
  status?: string(name='Status'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterOperationResponseBody = {
  clusterOperationList?: {
    clusterOperation?: [ 
    {
      status?: string(name='Status'),
      startTime?: string(name='StartTime'),
      comment?: string(name='Comment'),
      operationName?: string(name='OperationName'),
      operationId?: string(name='OperationId'),
      duration?: string(name='Duration'),
      percentage?: string(name='Percentage'),
    }
  ](name='ClusterOperation')
  }(name='ClusterOperationList'),
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model ListClusterOperationResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterOperationResponseBody(name='body'),
}

async function listClusterOperationWithOptions(request: ListClusterOperationRequest, runtime: Util.RuntimeOptions): ListClusterOperationResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["OperationId"] = request.operationId;
  query["ServiceName"] = request.serviceName;
  query["Status"] = request.status;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterOperation',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterOperation(request: ListClusterOperationRequest): ListClusterOperationResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterOperationWithOptions(request, runtime);
}

model ListClusterOperationHostRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  operationId?: string(name='OperationId'),
  status?: string(name='Status'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterOperationHostResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  clusterOperationHostList?: {
    clusterOperationHost?: [ 
    {
      status?: string(name='Status'),
      hostName?: string(name='HostName'),
      percentage?: string(name='Percentage'),
      hostId?: string(name='HostId'),
    }
  ](name='ClusterOperationHost')
  }(name='ClusterOperationHostList'),
}

model ListClusterOperationHostResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterOperationHostResponseBody(name='body'),
}

async function listClusterOperationHostWithOptions(request: ListClusterOperationHostRequest, runtime: Util.RuntimeOptions): ListClusterOperationHostResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["OperationId"] = request.operationId;
  query["Status"] = request.status;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterOperationHost',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterOperationHost(request: ListClusterOperationHostRequest): ListClusterOperationHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterOperationHostWithOptions(request, runtime);
}

model ListClusterOperationHostTaskRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  operationId?: string(name='OperationId'),
  hostId?: string(name='HostId'),
  status?: string(name='Status'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterOperationHostTaskResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  clusterOperationHostTaskList?: {
    clusterOperationHostTask?: [ 
    {
      status?: string(name='Status'),
      taskName?: string(name='TaskName'),
      percentage?: string(name='Percentage'),
      taskId?: string(name='TaskId'),
    }
  ](name='ClusterOperationHostTask')
  }(name='ClusterOperationHostTaskList'),
}

model ListClusterOperationHostTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterOperationHostTaskResponseBody(name='body'),
}

async function listClusterOperationHostTaskWithOptions(request: ListClusterOperationHostTaskRequest, runtime: Util.RuntimeOptions): ListClusterOperationHostTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["OperationId"] = request.operationId;
  query["HostId"] = request.hostId;
  query["Status"] = request.status;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterOperationHostTask',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterOperationHostTask(request: ListClusterOperationHostTaskRequest): ListClusterOperationHostTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterOperationHostTaskWithOptions(request, runtime);
}

model ListClusterOperationTaskRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  operationId?: string(name='OperationId'),
  status?: string(name='Status'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterOperationTaskResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  clusterOperationTaskList?: {
    clusterOperationTask?: [ 
    {
      status?: string(name='Status'),
      taskName?: string(name='TaskName'),
      percentage?: string(name='Percentage'),
      taskId?: string(name='TaskId'),
    }
  ](name='ClusterOperationTask')
  }(name='ClusterOperationTaskList'),
}

model ListClusterOperationTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterOperationTaskResponseBody(name='body'),
}

async function listClusterOperationTaskWithOptions(request: ListClusterOperationTaskRequest, runtime: Util.RuntimeOptions): ListClusterOperationTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["OperationId"] = request.operationId;
  query["Status"] = request.status;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterOperationTask',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterOperationTask(request: ListClusterOperationTaskRequest): ListClusterOperationTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterOperationTaskWithOptions(request, runtime);
}

model ListClustersRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  createType?: string(name='CreateType'),
  machineType?: string(name='MachineType'),
  isDesc?: boolean(name='IsDesc'),
  depositType?: string(name='DepositType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  defaultStatus?: boolean(name='DefaultStatus'),
  name?: string(name='Name'),
  vpcId?: string(name='VpcId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  clusterTypeList?: [ string ](name='ClusterTypeList'),
  statusList?: [ string ](name='StatusList'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  expiredTagList?: [ string ](name='ExpiredTagList'),
}

model ListClustersResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  clusters?: {
    clusterInfo?: [ 
    {
      type?: string(name='Type'),
      status?: string(name='Status'),
      runningTime?: int32(name='RunningTime'),
      machineType?: string(name='MachineType'),
      orderList?: string(name='OrderList'),
      metaStoreType?: string(name='MetaStoreType'),
      createTime?: long(name='CreateTime'),
      chargeType?: string(name='ChargeType'),
      tags?: {
        tag?: [ 
        {
          tagValue?: string(name='TagValue'),
          tagKey?: string(name='TagKey'),
        }
      ](name='Tag')
      }(name='Tags'),
      operationId?: long(name='OperationId'),
      depositType?: string(name='DepositType'),
      period?: int32(name='Period'),
      k8sClusterId?: string(name='K8sClusterId'),
      expiredTime?: long(name='ExpiredTime'),
      hasUncompletedOrder?: boolean(name='HasUncompletedOrder'),
      orderTaskInfo?: {
        currentCount?: int32(name='CurrentCount'),
        orderIdList?: string(name='OrderIdList'),
        targetCount?: int32(name='TargetCount'),
      }(name='OrderTaskInfo'),
      name?: string(name='Name'),
      createResource?: string(name='CreateResource'),
      id?: string(name='Id'),
      failReason?: {
        requestId?: string(name='RequestId'),
        errorCode?: string(name='ErrorCode'),
        errorMsg?: string(name='ErrorMsg'),
      }(name='FailReason'),
    }
  ](name='ClusterInfo')
  }(name='Clusters'),
}

model ListClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListClustersResponseBody(name='body'),
}

async function listClustersWithOptions(request: ListClustersRequest, runtime: Util.RuntimeOptions): ListClustersResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["CreateType"] = request.createType;
  query["MachineType"] = request.machineType;
  query["IsDesc"] = request.isDesc;
  query["DepositType"] = request.depositType;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["DefaultStatus"] = request.defaultStatus;
  query["Name"] = request.name;
  query["VpcId"] = request.vpcId;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["ClusterTypeList"] = request.clusterTypeList;
  query["StatusList"] = request.statusList;
  query["Tag"] = request.tag;
  query["ExpiredTagList"] = request.expiredTagList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListClusters',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusters(request: ListClustersRequest): ListClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClustersWithOptions(request, runtime);
}

model ListClusterServiceRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterServiceResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  clusterServiceList?: {
    clusterService?: [ 
    {
      serviceDisplayName?: string(name='ServiceDisplayName'),
      notStartInfo?: string(name='NotStartInfo'),
      clientType?: boolean(name='ClientType'),
      installStatus?: boolean(name='InstallStatus'),
      serviceActionList?: {
        serviceAction?: [ 
        {
          displayName?: string(name='DisplayName'),
          componentName?: string(name='ComponentName'),
          command?: string(name='Command'),
          actionName?: string(name='ActionName'),
          serviceName?: string(name='ServiceName'),
        }
      ](name='ServiceAction')
      }(name='ServiceActionList'),
      needRestartNum?: int32(name='NeedRestartNum'),
      serviceStatus?: string(name='ServiceStatus'),
      healthStatus?: string(name='HealthStatus'),
      needRestartInfo?: string(name='NeedRestartInfo'),
      stoppedNum?: int32(name='StoppedNum'),
      serviceVersion?: string(name='ServiceVersion'),
      serviceName?: string(name='ServiceName'),
      abnormalNum?: int32(name='AbnormalNum'),
    }
  ](name='ClusterService')
  }(name='ClusterServiceList'),
}

model ListClusterServiceResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterServiceResponseBody(name='body'),
}

async function listClusterServiceWithOptions(request: ListClusterServiceRequest, runtime: Util.RuntimeOptions): ListClusterServiceResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterService',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterService(request: ListClusterServiceRequest): ListClusterServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterServiceWithOptions(request, runtime);
}

model ListClusterServiceComponentRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  podName?: string(name='PodName'),
  serviceName?: string(name='ServiceName'),
  componentName?: string(name='ComponentName'),
  componentStatus?: string(name='ComponentStatus'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterServiceComponentResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  componentList?: {
    component?: [ 
    {
      status?: string(name='Status'),
      serviceDisplayName?: string(name='ServiceDisplayName'),
      privateIp?: string(name='PrivateIp'),
      serverStatus?: string(name='ServerStatus'),
      podName?: string(name='PodName'),
      componentName?: string(name='ComponentName'),
      commissionStatus?: string(name='CommissionStatus'),
      namespace?: string(name='Namespace'),
      needRestart?: boolean(name='NeedRestart'),
      workloadType?: string(name='WorkloadType'),
      workloadName?: string(name='WorkloadName'),
      componentDisplayName?: string(name='ComponentDisplayName'),
      publicIp?: string(name='PublicIp'),
      serviceName?: string(name='ServiceName'),
      role?: string(name='Role'),
      desiredCount?: int32(name='DesiredCount'),
    }
  ](name='Component')
  }(name='ComponentList'),
}

model ListClusterServiceComponentResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterServiceComponentResponseBody(name='body'),
}

async function listClusterServiceComponentWithOptions(request: ListClusterServiceComponentRequest, runtime: Util.RuntimeOptions): ListClusterServiceComponentResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["PodName"] = request.podName;
  query["ServiceName"] = request.serviceName;
  query["ComponentName"] = request.componentName;
  query["ComponentStatus"] = request.componentStatus;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterServiceComponent',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterServiceComponent(request: ListClusterServiceComponentRequest): ListClusterServiceComponentResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterServiceComponentWithOptions(request, runtime);
}

model ListClusterServiceComponentHealthInfoRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
}

model ListClusterServiceComponentHealthInfoResponseBody = {
  requestId?: string(name='RequestId'),
  clusterId?: string(name='ClusterId'),
  healthInfoList?: {
    healthInfo?: [ 
    {
      healthLevel?: string(name='HealthLevel'),
      healthDetailList?: {
        healthDetail?: [ 
        {
          code?: string(name='code'),
          healthRuleParam?: {
            service?: string(name='Service'),
            pass?: string(name='Pass'),
            component?: string(name='Component'),
            hostNames?: string(name='HostNames'),
            ruleTitle?: string(name='RuleTitle'),
            ruleDescription?: string(name='RuleDescription'),
            ruleId?: string(name='RuleId'),
          }(name='HealthRuleParam'),
        }
      ](name='HealthDetail')
      }(name='HealthDetailList'),
      componentName?: string(name='ComponentName'),
      normalNum?: int32(name='NormalNum'),
      manualStoppedNum?: int32(name='ManualStoppedNum'),
      stoppedNum?: int32(name='StoppedNum'),
      agentHeartBeatLostNum?: int32(name='AgentHeartBeatLostNum'),
      totalNum?: int32(name='TotalNum'),
      serviceName?: string(name='ServiceName'),
      createdTime?: long(name='CreatedTime'),
    }
  ](name='HealthInfo')
  }(name='HealthInfoList'),
}

model ListClusterServiceComponentHealthInfoResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterServiceComponentHealthInfoResponseBody(name='body'),
}

async function listClusterServiceComponentHealthInfoWithOptions(request: ListClusterServiceComponentHealthInfoRequest, runtime: Util.RuntimeOptions): ListClusterServiceComponentHealthInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["ServiceName"] = request.serviceName;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterServiceComponentHealthInfo',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterServiceComponentHealthInfo(request: ListClusterServiceComponentHealthInfoRequest): ListClusterServiceComponentHealthInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterServiceComponentHealthInfoWithOptions(request, runtime);
}

model ListClusterServiceConfigHistoryRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
  configVersion?: string(name='ConfigVersion'),
  hostGroupId?: string(name='HostGroupId'),
  hostInstanceId?: string(name='HostInstanceId'),
  configFileName?: string(name='ConfigFileName'),
  configItemKey?: string(name='ConfigItemKey'),
  author?: string(name='Author'),
  comment?: string(name='Comment'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterServiceConfigHistoryResponseBody = {
  totalCount?: int32(name='TotalCount'),
  configHistoryList?: {
    configHistory?: [ 
    {
      oldValue?: string(name='OldValue'),
      comment?: string(name='Comment'),
      createTime?: long(name='CreateTime'),
      author?: string(name='Author'),
      hostName?: string(name='HostName'),
      configItemName?: string(name='ConfigItemName'),
      hostGroupId?: string(name='HostGroupId'),
      newValue?: string(name='NewValue'),
      hostInstanceId?: string(name='HostInstanceId'),
      configFileName?: string(name='ConfigFileName'),
      applied?: boolean(name='Applied'),
      configVersion?: string(name='ConfigVersion'),
      serviceName?: string(name='ServiceName'),
      hostGroupName?: string(name='HostGroupName'),
    }
  ](name='ConfigHistory')
  }(name='ConfigHistoryList'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model ListClusterServiceConfigHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterServiceConfigHistoryResponseBody(name='body'),
}

async function listClusterServiceConfigHistoryWithOptions(request: ListClusterServiceConfigHistoryRequest, runtime: Util.RuntimeOptions): ListClusterServiceConfigHistoryResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["ServiceName"] = request.serviceName;
  query["ConfigVersion"] = request.configVersion;
  query["HostGroupId"] = request.hostGroupId;
  query["HostInstanceId"] = request.hostInstanceId;
  query["ConfigFileName"] = request.configFileName;
  query["ConfigItemKey"] = request.configItemKey;
  query["Author"] = request.author;
  query["Comment"] = request.comment;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterServiceConfigHistory',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterServiceConfigHistory(request: ListClusterServiceConfigHistoryRequest): ListClusterServiceConfigHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterServiceConfigHistoryWithOptions(request, runtime);
}

model ListClusterServiceQuickLinkRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
  directType?: boolean(name='DirectType'),
}

model ListClusterServiceQuickLinkResponseBody = {
  requestId?: string(name='RequestId'),
  quickLinkList?: {
    quickLink?: [ 
    {
      serviceDisplayName?: string(name='ServiceDisplayName'),
      type?: string(name='Type'),
      protocol?: string(name='Protocol'),
      serviceName?: string(name='ServiceName'),
      quickLinkAddress?: string(name='QuickLinkAddress'),
      port?: string(name='Port'),
    }
  ](name='QuickLink')
  }(name='QuickLinkList'),
}

model ListClusterServiceQuickLinkResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterServiceQuickLinkResponseBody(name='body'),
}

async function listClusterServiceQuickLinkWithOptions(request: ListClusterServiceQuickLinkRequest, runtime: Util.RuntimeOptions): ListClusterServiceQuickLinkResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["ServiceName"] = request.serviceName;
  query["DirectType"] = request.directType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterServiceQuickLink',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterServiceQuickLink(request: ListClusterServiceQuickLinkRequest): ListClusterServiceQuickLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterServiceQuickLinkWithOptions(request, runtime);
}

model ListClusterTemplatesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  bizId?: string(name='BizId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  productType?: string(name='ProductType'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListClusterTemplatesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  templateInfoList?: {
    templateInfo?: [ 
    {
      vpcId?: string(name='VpcId'),
      keyPairName?: string(name='KeyPairName'),
      logEnable?: boolean(name='LogEnable'),
      sshEnable?: boolean(name='SshEnable'),
      highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
      securityGroupId?: string(name='SecurityGroupId'),
      userId?: string(name='UserId'),
      hostGroupList?: {
        hostGroup?: [ 
        {
          sysDiskCapacity?: int32(name='SysDiskCapacity'),
          hostGroupType?: string(name='HostGroupType'),
          sysDiskType?: string(name='SysDiskType'),
          multiInstanceTypes?: string(name='MultiInstanceTypes'),
          chargeType?: string(name='ChargeType'),
          diskType?: string(name='DiskType'),
          hostGroupId?: string(name='HostGroupId'),
          instanceType?: string(name='InstanceType'),
          diskCount?: int32(name='DiskCount'),
          period?: string(name='Period'),
          diskCapacity?: int32(name='DiskCapacity'),
          nodeCount?: int32(name='NodeCount'),
          hostGroupName?: string(name='HostGroupName'),
        }
      ](name='HostGroup')
      }(name='HostGroupList'),
      isOpenPublicIp?: boolean(name='IsOpenPublicIp'),
      allowNotebook?: boolean(name='AllowNotebook'),
      gmtModified?: long(name='GmtModified'),
      templateName?: string(name='TemplateName'),
      depositType?: string(name='DepositType'),
      securityGroupName?: string(name='SecurityGroupName'),
      configList?: {
        config?: [ 
        {
          configValue?: string(name='ConfigValue'),
          replace?: string(name='Replace'),
          fileName?: string(name='FileName'),
          serviceName?: string(name='ServiceName'),
          configKey?: string(name='ConfigKey'),
          encrypt?: string(name='Encrypt'),
        }
      ](name='Config')
      }(name='ConfigList'),
      bootstrapActionList?: {
        bootstrapAction?: [ 
        {
          arg?: string(name='Arg'),
          path?: string(name='Path'),
          name?: string(name='Name'),
        }
      ](name='BootstrapAction')
      }(name='BootstrapActionList'),
      softwareInfoList?: {
        softwareInfo?: [ string ](name='SoftwareInfo')
      }(name='SoftwareInfoList'),
      instanceGeneration?: string(name='InstanceGeneration'),
      createSource?: string(name='CreateSource'),
      easEnable?: boolean(name='EasEnable'),
      useCustomHiveMetaDb?: boolean(name='UseCustomHiveMetaDb'),
      userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
      machineType?: string(name='MachineType'),
      metaStoreType?: string(name='MetaStoreType'),
      useLocalMetaDb?: boolean(name='UseLocalMetaDb'),
      masterNodeTotal?: int32(name='MasterNodeTotal'),
      initCustomHiveMetaDb?: boolean(name='InitCustomHiveMetaDb'),
      ioOptimized?: boolean(name='IoOptimized'),
      metaStoreConf?: string(name='MetaStoreConf'),
      vSwitchId?: string(name='VSwitchId'),
      configurations?: string(name='Configurations'),
      logPath?: string(name='LogPath'),
      clusterType?: string(name='ClusterType'),
      netType?: string(name='NetType'),
      zoneId?: string(name='ZoneId'),
      gmtCreate?: long(name='GmtCreate'),
      id?: string(name='Id'),
    }
  ](name='TemplateInfo')
  }(name='TemplateInfoList'),
}

model ListClusterTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterTemplatesResponseBody(name='body'),
}

async function listClusterTemplatesWithOptions(request: ListClusterTemplatesRequest, runtime: Util.RuntimeOptions): ListClusterTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["BizId"] = request.bizId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["ProductType"] = request.productType;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterTemplates',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterTemplates(request: ListClusterTemplatesRequest): ListClusterTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterTemplatesWithOptions(request, runtime);
}

model ListDataSourceRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
  name?: string(name='Name'),
  sourceType?: string(name='SourceType'),
  createFrom?: string(name='CreateFrom'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListDataSourceResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  dataSourceList?: {
    dataSource?: [ 
    {
      status?: string(name='Status'),
      conf?: string(name='Conf'),
      sourceType?: string(name='SourceType'),
      gmtModified?: long(name='GmtModified'),
      creator?: string(name='Creator'),
      modifier?: string(name='Modifier'),
      description?: string(name='Description'),
      gmtCreate?: long(name='GmtCreate'),
      createFrom?: string(name='CreateFrom'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='DataSource')
  }(name='DataSourceList'),
}

model ListDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataSourceResponseBody(name='body'),
}

async function listDataSourceWithOptions(request: ListDataSourceRequest, runtime: Util.RuntimeOptions): ListDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["PageSize"] = request.pageSize;
  query["PageNumber"] = request.pageNumber;
  query["Id"] = request.id;
  query["ProjectId"] = request.projectId;
  query["Name"] = request.name;
  query["SourceType"] = request.sourceType;
  query["CreateFrom"] = request.createFrom;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListDataSource',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDataSource(request: ListDataSourceRequest): ListDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataSourceWithOptions(request, runtime);
}

model ListDiskOpsEventsRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  userId?: string(name='UserId'),
  clusterId?: string(name='ClusterId'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
}

model ListDiskOpsEventsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  eventList?: {
    diskOpsEventInfo?: [ 
    {
      diskMountPoint?: string(name='DiskMountPoint'),
      privateIp?: string(name='PrivateIp'),
      userId?: string(name='UserId'),
      diskId?: string(name='DiskId'),
      instanceId?: string(name='InstanceId'),
      regionId?: string(name='RegionId'),
      eventType?: string(name='EventType'),
      diskDevice?: string(name='DiskDevice'),
      currentActivity?: string(name='CurrentActivity'),
      instanceName?: string(name='InstanceName'),
      clusterName?: string(name='ClusterName'),
      instanceStatus?: string(name='InstanceStatus'),
      currentActivityState?: string(name='currentActivityState'),
      clusterBizId?: string(name='ClusterBizId'),
      eventTriggerTime?: long(name='EventTriggerTime'),
    }
  ](name='DiskOpsEventInfo')
  }(name='EventList'),
}

model ListDiskOpsEventsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDiskOpsEventsResponseBody(name='body'),
}

async function listDiskOpsEventsWithOptions(request: ListDiskOpsEventsRequest, runtime: Util.RuntimeOptions): ListDiskOpsEventsResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["RegionId"] = request.regionId;
  query["UserId"] = request.userId;
  query["ClusterId"] = request.clusterId;
  query["StartTime"] = request.startTime;
  query["EndTime"] = request.endTime;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListDiskOpsEvents',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDiskOpsEvents(request: ListDiskOpsEventsRequest): ListDiskOpsEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDiskOpsEventsWithOptions(request, runtime);
}

model ListEmrAvailableConfigRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListEmrAvailableConfigResponseBody = {
  securityGroupList?: {
    securityGroup?: [ 
    {
      vpcId?: string(name='VpcId'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupName?: string(name='SecurityGroupName'),
      ecsCount?: int32(name='EcsCount'),
      securityGroupType?: string(name='SecurityGroupType'),
      availableInstanceAmount?: int32(name='AvailableInstanceAmount'),
    }
  ](name='SecurityGroup')
  }(name='SecurityGroupList'),
  requestId?: string(name='RequestId'),
  keyPairNameList?: {
    keyPairName?: [ string ](name='KeyPairName')
  }(name='KeyPairNameList'),
  vpcInfoList?: {
    vpcInfo?: [ 
    {
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
      creationTime?: string(name='CreationTime'),
      VRouterId?: string(name='VRouterId'),
      cidrBlock?: string(name='CidrBlock'),
      description?: string(name='Description'),
      vswitchInfoList?: {
        vswitchInfo?: [ 
        {
          creationTime?: string(name='CreationTime'),
          vpcId?: string(name='VpcId'),
          cidrBlock?: string(name='CidrBlock'),
          description?: string(name='Description'),
          vswitchId?: string(name='VswitchId'),
          vswitchName?: string(name='VswitchName'),
          availableIpAddressCount?: long(name='AvailableIpAddressCount'),
          zoneId?: string(name='ZoneId'),
        }
      ](name='VswitchInfo')
      }(name='VswitchInfoList'),
    }
  ](name='VpcInfo')
  }(name='VpcInfoList'),
  emrMainVersionList?: {
    emrMainVersion?: [ 
    {
      onCloudNative?: boolean(name='OnCloudNative'),
      extraInfo?: string(name='ExtraInfo'),
      clusterTypeInfoList?: {
        clusterTypeInfo?: [ 
        {
          clusterType?: string(name='ClusterType'),
          clusterServiceInfoList?: {
            clusterServiceInfo?: [ 
            {
              serviceDisplayName?: string(name='ServiceDisplayName'),
              serviceVersion?: string(name='ServiceVersion'),
              mandatory?: boolean(name='Mandatory'),
              serviceName?: string(name='ServiceName'),
            }
          ](name='ClusterServiceInfo')
          }(name='ClusterServiceInfoList'),
        }
      ](name='ClusterTypeInfo')
      }(name='ClusterTypeInfoList'),
      publishType?: string(name='PublishType'),
      stackVersion?: string(name='StackVersion'),
      stackName?: string(name='StackName'),
      ecmVersion?: boolean(name='EcmVersion'),
      mainVersionName?: string(name='MainVersionName'),
      regionId?: string(name='RegionId'),
    }
  ](name='EmrMainVersion')
  }(name='EmrMainVersionList'),
}

model ListEmrAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ListEmrAvailableConfigResponseBody(name='body'),
}

async function listEmrAvailableConfigWithOptions(request: ListEmrAvailableConfigRequest, runtime: Util.RuntimeOptions): ListEmrAvailableConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListEmrAvailableConfig',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEmrAvailableConfig(request: ListEmrAvailableConfigRequest): ListEmrAvailableConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEmrAvailableConfigWithOptions(request, runtime);
}

model ListEmrAvailableResourceRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  destinationResource?: string(name='DestinationResource'),
  clusterType?: string(name='ClusterType'),
  instanceChargeType?: string(name='InstanceChargeType'),
  spotStrategy?: string(name='SpotStrategy'),
  zoneId?: string(name='ZoneId'),
  netType?: string(name='NetType'),
  instanceType?: string(name='InstanceType'),
  systemDiskType?: string(name='SystemDiskType'),
  dataDiskType?: string(name='DataDiskType'),
  depositType?: string(name='DepositType'),
  clusterId?: string(name='ClusterId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListEmrAvailableResourceResponseBody = {
  requestId?: string(name='RequestId'),
  regionId?: string(name='RegionId'),
  emrZoneInfoList?: {
    emrZoneInfo?: [ 
    {
      zoneId?: string(name='ZoneId'),
      emrResourceInfoList?: {
        emrResourceInfo?: [ 
        {
          type?: string(name='Type'),
          supportedResourceList?: {
            supportedResource?: [ 
            {
              value?: string(name='Value'),
              max?: int32(name='Max'),
              unit?: string(name='Unit'),
              emrInstanceType?: {
                instanceBandwidthRx?: int32(name='InstanceBandwidthRx'),
                GPUSpec?: string(name='GPUSpec'),
                localStorageCategory?: string(name='LocalStorageCategory'),
                instanceBandwidthTx?: int32(name='InstanceBandwidthTx'),
                GPUAmount?: int32(name='GPUAmount'),
                instanceType?: string(name='InstanceType'),
                memorySize?: int32(name='MemorySize'),
                initialCredit?: int32(name='InitialCredit'),
                localStorageCapacity?: long(name='LocalStorageCapacity'),
                localStorageAmount?: int32(name='LocalStorageAmount'),
                instancePpsRx?: long(name='InstancePpsRx'),
                baselineCredit?: int32(name='BaselineCredit'),
                instancePpsTx?: long(name='InstancePpsTx'),
                cpuCoreCount?: int32(name='CpuCoreCount'),
                instanceTypeFamily?: string(name='InstanceTypeFamily'),
                eniQuantity?: int32(name='EniQuantity'),
              }(name='EmrInstanceType'),
              min?: int32(name='Min'),
              supportNodeTypeList?: {
                supportNodeType?: [ string ](name='SupportNodeType')
              }(name='SupportNodeTypeList'),
            }
          ](name='SupportedResource')
          }(name='SupportedResourceList'),
        }
      ](name='EmrResourceInfo')
      }(name='EmrResourceInfoList'),
    }
  ](name='EmrZoneInfo')
  }(name='EmrZoneInfoList'),
}

model ListEmrAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  body: ListEmrAvailableResourceResponseBody(name='body'),
}

async function listEmrAvailableResourceWithOptions(request: ListEmrAvailableResourceRequest, runtime: Util.RuntimeOptions): ListEmrAvailableResourceResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["DestinationResource"] = request.destinationResource;
  query["ClusterType"] = request.clusterType;
  query["InstanceChargeType"] = request.instanceChargeType;
  query["SpotStrategy"] = request.spotStrategy;
  query["ZoneId"] = request.zoneId;
  query["NetType"] = request.netType;
  query["InstanceType"] = request.instanceType;
  query["SystemDiskType"] = request.systemDiskType;
  query["DataDiskType"] = request.dataDiskType;
  query["DepositType"] = request.depositType;
  query["ClusterId"] = request.clusterId;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListEmrAvailableResource',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEmrAvailableResource(request: ListEmrAvailableResourceRequest): ListEmrAvailableResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEmrAvailableResourceWithOptions(request, runtime);
}

model ListEmrMainVersionRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  emrVersion?: string(name='EmrVersion'),
  stackName?: string(name='StackName'),
  stackVersion?: string(name='StackVersion'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListEmrMainVersionResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  emrMainVersionList?: {
    emrMainVersion?: [ 
    {
      clusterTypeInfoList?: {
        clusterTypeInfo?: [ 
        {
          serviceInfoList?: {
            serviceInfo?: [ 
            {
              serviceDisplayName?: string(name='ServiceDisplayName'),
              serviceVersion?: string(name='ServiceVersion'),
              display?: boolean(name='Display'),
              serviceDisplayVersion?: string(name='ServiceDisplayVersion'),
              mandatory?: boolean(name='Mandatory'),
              serviceName?: string(name='ServiceName'),
            }
          ](name='ServiceInfo')
          }(name='ServiceInfoList'),
          clusterType?: string(name='ClusterType'),
        }
      ](name='ClusterTypeInfo')
      }(name='ClusterTypeInfoList'),
      publishType?: string(name='PublishType'),
      stackVersion?: string(name='StackVersion'),
      emrVersion?: string(name='EmrVersion'),
      whiteUserList?: {
        whiteUser?: [ string ](name='WhiteUser')
      }(name='WhiteUserList'),
      display?: boolean(name='Display'),
      stackName?: string(name='StackName'),
      ecmVersion?: boolean(name='EcmVersion'),
      imageId?: string(name='ImageId'),
      regionId?: string(name='RegionId'),
      clusterTypeWhiteUserList?: {
        clusterTypeWhiteUser?: [ 
        {
          clusterType?: string(name='ClusterType'),
          userId?: string(name='UserId'),
        }
      ](name='ClusterTypeWhiteUser')
      }(name='ClusterTypeWhiteUserList'),
    }
  ](name='EmrMainVersion')
  }(name='EmrMainVersionList'),
}

model ListEmrMainVersionResponse = {
  headers: map[string]string(name='headers'),
  body: ListEmrMainVersionResponseBody(name='body'),
}

async function listEmrMainVersionWithOptions(request: ListEmrMainVersionRequest, runtime: Util.RuntimeOptions): ListEmrMainVersionResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["EmrVersion"] = request.emrVersion;
  query["StackName"] = request.stackName;
  query["StackVersion"] = request.stackVersion;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListEmrMainVersion',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEmrMainVersion(request: ListEmrMainVersionRequest): ListEmrMainVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEmrMainVersionWithOptions(request, runtime);
}

model ListExecutionPlanInstancesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  onlyLastInstance?: boolean(name='OnlyLastInstance'),
  isDesc?: boolean(name='IsDesc'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  executionPlanIdList?: [ string ](name='ExecutionPlanIdList'),
  statusList?: [ string ](name='StatusList'),
}

model ListExecutionPlanInstancesResponseBody = {
  executionPlanInstances?: {
    executionPlanInstance?: [ 
    {
      status?: string(name='Status'),
      logEnable?: boolean(name='LogEnable'),
      startTime?: long(name='StartTime'),
      logPath?: string(name='LogPath'),
      executionPlanId?: string(name='ExecutionPlanId'),
      clusterType?: string(name='ClusterType'),
      runTime?: int32(name='RunTime'),
      clusterName?: string(name='ClusterName'),
      workflowApp?: string(name='WorkflowApp'),
      id?: string(name='Id'),
      clusterId?: string(name='ClusterId'),
      executionPlanName?: string(name='ExecutionPlanName'),
    }
  ](name='ExecutionPlanInstance')
  }(name='ExecutionPlanInstances'),
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model ListExecutionPlanInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListExecutionPlanInstancesResponseBody(name='body'),
}

async function listExecutionPlanInstancesWithOptions(request: ListExecutionPlanInstancesRequest, runtime: Util.RuntimeOptions): ListExecutionPlanInstancesResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["OnlyLastInstance"] = request.onlyLastInstance;
  query["IsDesc"] = request.isDesc;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["ExecutionPlanIdList"] = request.executionPlanIdList;
  query["StatusList"] = request.statusList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListExecutionPlanInstances',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listExecutionPlanInstances(request: ListExecutionPlanInstancesRequest): ListExecutionPlanInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExecutionPlanInstancesWithOptions(request, runtime);
}

model ListFlowRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  jobId?: string(name='JobId'),
  name?: string(name='Name'),
  id?: string(name='Id'),
  clusterId?: string(name='ClusterId'),
  status?: string(name='Status'),
  periodic?: boolean(name='Periodic'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListFlowResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  flow?: {
    flow?: [ 
    {
      type?: string(name='Type'),
      status?: string(name='Status'),
      alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
      periodic?: boolean(name='Periodic'),
      projectId?: string(name='ProjectId'),
      hostName?: string(name='HostName'),
      gmtModified?: long(name='GmtModified'),
      description?: string(name='Description'),
      startSchedule?: long(name='StartSchedule'),
      createCluster?: boolean(name='CreateCluster'),
      endSchedule?: long(name='EndSchedule'),
      graph?: string(name='Graph'),
      alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
      gmtCreate?: long(name='GmtCreate'),
      categoryId?: string(name='CategoryId'),
      cronExpr?: string(name='CronExpr'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      alertConf?: string(name='AlertConf'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='Flow')
  }(name='Flow'),
}

model ListFlowResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowResponseBody(name='body'),
}

async function listFlowWithOptions(request: ListFlowRequest, runtime: Util.RuntimeOptions): ListFlowResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["JobId"] = request.jobId;
  query["Name"] = request.name;
  query["Id"] = request.id;
  query["ClusterId"] = request.clusterId;
  query["Status"] = request.status;
  query["Periodic"] = request.periodic;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFlow',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlow(request: ListFlowRequest): ListFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowWithOptions(request, runtime);
}

model ListFlowCategoryRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  parentId?: string(name='ParentId'),
  root?: boolean(name='Root'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListFlowCategoryResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  categories?: {
    category?: [ 
    {
      type?: string(name='Type'),
      parentId?: string(name='ParentId'),
      objectType?: string(name='ObjectType'),
      projectId?: string(name='ProjectId'),
      objectId?: string(name='ObjectId'),
      gmtCreate?: long(name='GmtCreate'),
      name?: string(name='Name'),
      gmtModified?: long(name='GmtModified'),
      categoryType?: string(name='CategoryType'),
      id?: string(name='Id'),
    }
  ](name='Category')
  }(name='Categories'),
  total?: int32(name='Total'),
}

model ListFlowCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowCategoryResponseBody(name='body'),
}

async function listFlowCategoryWithOptions(request: ListFlowCategoryRequest, runtime: Util.RuntimeOptions): ListFlowCategoryResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["ParentId"] = request.parentId;
  query["Root"] = request.root;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowCategory',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowCategory(request: ListFlowCategoryRequest): ListFlowCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowCategoryWithOptions(request, runtime);
}

model ListFlowClusterRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListFlowClusterResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  clusters?: {
    clusterInfo?: [ 
    {
      status?: string(name='Status'),
      type?: string(name='Type'),
      runningTime?: int32(name='RunningTime'),
      orderList?: string(name='OrderList'),
      createTime?: long(name='CreateTime'),
      chargeType?: string(name='ChargeType'),
      period?: int32(name='Period'),
      k8sClusterId?: string(name='K8sClusterId'),
      expiredTime?: long(name='ExpiredTime'),
      hasUncompletedOrder?: boolean(name='HasUncompletedOrder'),
      orderTaskInfo?: {
        currentCount?: int32(name='CurrentCount'),
        orderIdList?: string(name='OrderIdList'),
        targetCount?: int32(name='TargetCount'),
      }(name='OrderTaskInfo'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      createResource?: string(name='CreateResource'),
      failReason?: {
        requestId?: string(name='RequestId'),
        errorCode?: string(name='ErrorCode'),
        errorMsg?: string(name='ErrorMsg'),
      }(name='FailReason'),
    }
  ](name='ClusterInfo')
  }(name='Clusters'),
}

model ListFlowClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowClusterResponseBody(name='body'),
}

async function listFlowClusterWithOptions(request: ListFlowClusterRequest, runtime: Util.RuntimeOptions): ListFlowClusterResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowCluster',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowCluster(request: ListFlowClusterRequest): ListFlowClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowClusterWithOptions(request, runtime);
}

model ListFlowClusterAllRequest {
  productType?: string(name='ProductType'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListFlowClusterAllResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  clusters?: {
    clusterInfo?: [ 
    {
      status?: string(name='Status'),
      type?: string(name='Type'),
      runningTime?: int32(name='RunningTime'),
      orderList?: string(name='OrderList'),
      createTime?: long(name='CreateTime'),
      chargeType?: string(name='ChargeType'),
      period?: int32(name='Period'),
      k8sClusterId?: string(name='K8sClusterId'),
      expiredTime?: long(name='ExpiredTime'),
      hasUncompletedOrder?: boolean(name='HasUncompletedOrder'),
      orderTaskInfo?: {
        currentCount?: int32(name='CurrentCount'),
        orderIdList?: string(name='OrderIdList'),
        targetCount?: int32(name='TargetCount'),
      }(name='OrderTaskInfo'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      createResource?: string(name='CreateResource'),
      failReason?: {
        requestId?: string(name='RequestId'),
        errorCode?: string(name='ErrorCode'),
        errorMsg?: string(name='ErrorMsg'),
      }(name='FailReason'),
    }
  ](name='ClusterInfo')
  }(name='Clusters'),
}

model ListFlowClusterAllResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowClusterAllResponseBody(name='body'),
}

async function listFlowClusterAllWithOptions(request: ListFlowClusterAllRequest, runtime: Util.RuntimeOptions): ListFlowClusterAllResponse {
  Util.validateModel(request);
  var query = {};
  query["ProductType"] = request.productType;
  query["RegionId"] = request.regionId;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowClusterAll',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowClusterAll(request: ListFlowClusterAllRequest): ListFlowClusterAllResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowClusterAllWithOptions(request, runtime);
}

model ListFlowClusterAllHostsRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  clusterId?: string(name='ClusterId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListFlowClusterAllHostsResponseBody = {
  requestId?: string(name='RequestId'),
  hostList?: {
    host?: [ 
    {
      serialNumber?: string(name='SerialNumber'),
      type?: string(name='Type'),
      status?: string(name='Status'),
      privateIp?: string(name='PrivateIp'),
      hostName?: string(name='HostName'),
      instanceType?: string(name='InstanceType'),
      hostId?: string(name='HostId'),
      hostInstanceId?: string(name='HostInstanceId'),
      cpu?: int32(name='Cpu'),
      publicIp?: string(name='PublicIp'),
      memory?: int32(name='Memory'),
      role?: string(name='Role'),
    }
  ](name='Host')
  }(name='HostList'),
}

model ListFlowClusterAllHostsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowClusterAllHostsResponseBody(name='body'),
}

async function listFlowClusterAllHostsWithOptions(request: ListFlowClusterAllHostsRequest, runtime: Util.RuntimeOptions): ListFlowClusterAllHostsResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["ClusterId"] = request.clusterId;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowClusterAllHosts',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowClusterAllHosts(request: ListFlowClusterAllHostsRequest): ListFlowClusterAllHostsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowClusterAllHostsWithOptions(request, runtime);
}

model ListFlowClusterHostRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  clusterId?: string(name='ClusterId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListFlowClusterHostResponseBody = {
  requestId?: string(name='RequestId'),
  hostList?: {
    host?: [ 
    {
      serialNumber?: string(name='SerialNumber'),
      type?: string(name='Type'),
      status?: string(name='Status'),
      privateIp?: string(name='PrivateIp'),
      hostName?: string(name='HostName'),
      instanceType?: string(name='InstanceType'),
      hostId?: string(name='HostId'),
      hostInstanceId?: string(name='HostInstanceId'),
      cpu?: int32(name='Cpu'),
      publicIp?: string(name='PublicIp'),
      memory?: int32(name='Memory'),
      role?: string(name='Role'),
    }
  ](name='Host')
  }(name='HostList'),
}

model ListFlowClusterHostResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowClusterHostResponseBody(name='body'),
}

async function listFlowClusterHostWithOptions(request: ListFlowClusterHostRequest, runtime: Util.RuntimeOptions): ListFlowClusterHostResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["ClusterId"] = request.clusterId;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowClusterHost',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowClusterHost(request: ListFlowClusterHostRequest): ListFlowClusterHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowClusterHostWithOptions(request, runtime);
}

model ListFlowInstanceRequest {
  id?: string(name='Id'),
  flowId?: string(name='FlowId'),
  flowName?: string(name='FlowName'),
  owner?: string(name='Owner'),
  instanceId?: string(name='InstanceId'),
  nodeInstanceId?: string(name='NodeInstanceId'),
  timeRange?: string(name='TimeRange'),
  orderBy?: string(name='OrderBy'),
  orderType?: string(name='OrderType'),
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  statusList?: [ string ](name='StatusList'),
}

model ListFlowInstanceResponseBody = {
  flowInstances?: {
    flowInstance?: [ 
    {
      status?: string(name='Status'),
      owner?: string(name='Owner'),
      projectId?: string(name='ProjectId'),
      flowName?: string(name='FlowName'),
      gmtModified?: long(name='GmtModified'),
      flowId?: string(name='FlowId'),
      endTime?: long(name='EndTime'),
      startTime?: long(name='StartTime'),
      hasNodeFailed?: boolean(name='HasNodeFailed'),
      gmtCreate?: long(name='GmtCreate'),
      scheduleTime?: long(name='ScheduleTime'),
      duration?: long(name='Duration'),
      id?: string(name='Id'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='FlowInstance')
  }(name='FlowInstances'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
}

model ListFlowInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowInstanceResponseBody(name='body'),
}

async function listFlowInstanceWithOptions(request: ListFlowInstanceRequest, runtime: Util.RuntimeOptions): ListFlowInstanceResponse {
  Util.validateModel(request);
  var query = {};
  query["Id"] = request.id;
  query["FlowId"] = request.flowId;
  query["FlowName"] = request.flowName;
  query["Owner"] = request.owner;
  query["InstanceId"] = request.instanceId;
  query["NodeInstanceId"] = request.nodeInstanceId;
  query["TimeRange"] = request.timeRange;
  query["OrderBy"] = request.orderBy;
  query["OrderType"] = request.orderType;
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["StatusList"] = request.statusList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowInstance',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowInstance(request: ListFlowInstanceRequest): ListFlowInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowInstanceWithOptions(request, runtime);
}

model ListFlowJobRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  type?: string(name='Type'),
  adhoc?: boolean(name='Adhoc'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListFlowJobResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  jobList?: {
    job?: [ 
    {
      type?: string(name='Type'),
      failAct?: string(name='FailAct'),
      customVariables?: string(name='CustomVariables'),
      resourceList?: {
        resource?: [ 
        {
          path?: string(name='Path'),
          alias?: string(name='Alias'),
        }
      ](name='Resource')
      }(name='ResourceList'),
      retryInterval?: long(name='RetryInterval'),
      envConf?: string(name='EnvConf'),
      paramConf?: string(name='ParamConf'),
      mode?: string(name='mode'),
      gmtModified?: long(name='GmtModified'),
      monitorConf?: string(name='MonitorConf'),
      lastInstanceDetail?: string(name='LastInstanceDetail'),
      runConf?: string(name='RunConf'),
      params?: string(name='Params'),
      description?: string(name='Description'),
      gmtCreate?: long(name='GmtCreate'),
      categoryId?: string(name='CategoryId'),
      adhoc?: string(name='Adhoc'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      alertConf?: string(name='AlertConf'),
      maxRetry?: int32(name='MaxRetry'),
    }
  ](name='Job')
  }(name='JobList'),
}

model ListFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowJobResponseBody(name='body'),
}

async function listFlowJobWithOptions(request: ListFlowJobRequest, runtime: Util.RuntimeOptions): ListFlowJobResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["Id"] = request.id;
  query["Name"] = request.name;
  query["Type"] = request.type;
  query["Adhoc"] = request.adhoc;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowJob',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowJob(request: ListFlowJobRequest): ListFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowJobWithOptions(request, runtime);
}

model ListFlowJobHistoryRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  jobType?: string(name='JobType'),
  instanceId?: string(name='InstanceId'),
  timeRange?: string(name='TimeRange'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  statusList?: [ string ](name='StatusList'),
}

model ListFlowJobHistoryResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  nodeInstances?: {
    nodeInstance?: [ 
    {
      type?: string(name='Type'),
      status?: string(name='Status'),
      pending?: boolean(name='pending'),
      envConf?: string(name='EnvConf'),
      retryInterval?: long(name='RetryInterval'),
      projectId?: string(name='ProjectId'),
      jobType?: string(name='JobType'),
      gmtModified?: long(name='GmtModified'),
      externalInfo?: string(name='ExternalInfo'),
      externalStatus?: string(name='ExternalStatus'),
      jobName?: string(name='JobName'),
      externalId?: string(name='ExternalId'),
      clusterId?: string(name='ClusterId'),
      maxRetry?: int32(name='MaxRetry'),
      failAct?: string(name='FailAct'),
      jobParams?: string(name='JobParams'),
      paramConf?: string(name='ParamConf'),
      hostName?: string(name='HostName'),
      retries?: int32(name='Retries'),
      endTime?: long(name='EndTime'),
      startTime?: long(name='StartTime'),
      runConf?: string(name='RunConf'),
      nodeName?: string(name='NodeName'),
      jobId?: string(name='JobId'),
      gmtCreate?: long(name='GmtCreate'),
      id?: string(name='Id'),
    }
  ](name='NodeInstance')
  }(name='NodeInstances'),
}

model ListFlowJobHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowJobHistoryResponseBody(name='body'),
}

async function listFlowJobHistoryWithOptions(request: ListFlowJobHistoryRequest, runtime: Util.RuntimeOptions): ListFlowJobHistoryResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["Id"] = request.id;
  query["JobType"] = request.jobType;
  query["InstanceId"] = request.instanceId;
  query["TimeRange"] = request.timeRange;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["StatusList"] = request.statusList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowJobHistory',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowJobHistory(request: ListFlowJobHistoryRequest): ListFlowJobHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowJobHistoryWithOptions(request, runtime);
}

model ListFlowNodeInstanceRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  startTime?: long(name='StartTime'),
  orderBy?: string(name='OrderBy'),
  orderType?: string(name='OrderType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  statusList?: [ string ](name='StatusList'),
}

model ListFlowNodeInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  flowNodeInstances?: {
    flowNodeInstance?: [ 
    {
      type?: string(name='Type'),
      status?: string(name='Status'),
      retryInterval?: string(name='RetryInterval'),
      projectId?: string(name='ProjectId'),
      jobType?: string(name='JobType'),
      externalInfo?: string(name='ExternalInfo'),
      gmtModified?: long(name='GmtModified'),
      externalChildIds?: string(name='ExternalChildIds'),
      externalStatus?: string(name='ExternalStatus'),
      jobName?: string(name='JobName'),
      externalId?: string(name='ExternalId'),
      pending?: boolean(name='Pending'),
      clusterId?: string(name='ClusterId'),
      maxRetry?: string(name='MaxRetry'),
      failAct?: string(name='FailAct'),
      jobParams?: string(name='JobParams'),
      flowInstanceId?: string(name='FlowInstanceId'),
      hostName?: string(name='HostName'),
      flowId?: string(name='FlowId'),
      retries?: int32(name='Retries'),
      endTime?: long(name='EndTime'),
      startTime?: long(name='StartTime'),
      externalSubId?: string(name='ExternalSubId'),
      nodeName?: string(name='NodeName'),
      jobId?: string(name='JobId'),
      gmtCreate?: long(name='GmtCreate'),
      duration?: long(name='Duration'),
      id?: string(name='Id'),
    }
  ](name='FlowNodeInstance')
  }(name='FlowNodeInstances'),
  total?: int32(name='Total'),
}

model ListFlowNodeInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowNodeInstanceResponseBody(name='body'),
}

async function listFlowNodeInstanceWithOptions(request: ListFlowNodeInstanceRequest, runtime: Util.RuntimeOptions): ListFlowNodeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["StartTime"] = request.startTime;
  query["OrderBy"] = request.orderBy;
  query["OrderType"] = request.orderType;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["StatusList"] = request.statusList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowNodeInstance',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowNodeInstance(request: ListFlowNodeInstanceRequest): ListFlowNodeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowNodeInstanceWithOptions(request, runtime);
}

model ListFlowNodeInstanceContainerStatusRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  nodeInstanceId?: string(name='NodeInstanceId'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model ListFlowNodeInstanceContainerStatusResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  containerStatusList?: {
    containerStatus?: [ 
    {
      status?: string(name='Status'),
      containerId?: string(name='ContainerId'),
      hostName?: string(name='HostName'),
      applicationId?: string(name='ApplicationId'),
    }
  ](name='ContainerStatus')
  }(name='ContainerStatusList'),
}

model ListFlowNodeInstanceContainerStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowNodeInstanceContainerStatusResponseBody(name='body'),
}

async function listFlowNodeInstanceContainerStatusWithOptions(request: ListFlowNodeInstanceContainerStatusRequest, runtime: Util.RuntimeOptions): ListFlowNodeInstanceContainerStatusResponse {
  Util.validateModel(request);
  var query = {};
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["NodeInstanceId"] = request.nodeInstanceId;
  query["ProjectId"] = request.projectId;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowNodeInstanceContainerStatus',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowNodeInstanceContainerStatus(request: ListFlowNodeInstanceContainerStatusRequest): ListFlowNodeInstanceContainerStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowNodeInstanceContainerStatusWithOptions(request, runtime);
}

model ListFlowNodeSqlResultRequest {
  nodeInstanceId?: string(name='NodeInstanceId'),
  sqlIndex?: int32(name='SqlIndex'),
  offset?: int32(name='Offset'),
  length?: int32(name='Length'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model ListFlowNodeSqlResultResponseBody = {
  rowList?: {
    row?: [ 
    {
      rowIndex?: int32(name='RowIndex'),
      rowItemList?: {
        rowItem?: [ string ](name='rowItem')
      }(name='RowItemList'),
    }
  ](name='Row')
  }(name='RowList'),
  requestId?: string(name='RequestId'),
  headerList?: {
    header?: [ string ](name='Header')
  }(name='HeaderList'),
  end?: boolean(name='End'),
}

model ListFlowNodeSqlResultResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowNodeSqlResultResponseBody(name='body'),
}

async function listFlowNodeSqlResultWithOptions(request: ListFlowNodeSqlResultRequest, runtime: Util.RuntimeOptions): ListFlowNodeSqlResultResponse {
  Util.validateModel(request);
  var query = {};
  query["NodeInstanceId"] = request.nodeInstanceId;
  query["SqlIndex"] = request.sqlIndex;
  query["Offset"] = request.offset;
  query["Length"] = request.length;
  query["ProjectId"] = request.projectId;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowNodeSqlResult',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowNodeSqlResult(request: ListFlowNodeSqlResultRequest): ListFlowNodeSqlResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowNodeSqlResultWithOptions(request, runtime);
}

model ListFlowProjectRequest {
  productType?: string(name='ProductType'),
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListFlowProjectResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  projects?: {
    project?: [ 
    {
      description?: string(name='Description'),
      userId?: string(name='UserId'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='Project')
  }(name='Projects'),
}

model ListFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowProjectResponseBody(name='body'),
}

async function listFlowProjectWithOptions(request: ListFlowProjectRequest, runtime: Util.RuntimeOptions): ListFlowProjectResponse {
  Util.validateModel(request);
  var query = {};
  query["ProductType"] = request.productType;
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["Name"] = request.name;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowProject',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowProject(request: ListFlowProjectRequest): ListFlowProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowProjectWithOptions(request, runtime);
}

model ListFlowProjectClusterSettingRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListFlowProjectClusterSettingResponseBody = {
  clusterSettings?: {
    clusterSetting?: [ 
    {
      k8sClusterId?: string(name='K8sClusterId'),
      defaultQueue?: string(name='DefaultQueue'),
      projectId?: string(name='ProjectId'),
      gmtCreate?: long(name='GmtCreate'),
      clusterName?: string(name='ClusterName'),
      queueList?: {
        queue?: [ string ](name='Queue')
      }(name='QueueList'),
      userList?: {
        user?: [ string ](name='User')
      }(name='UserList'),
      defaultUser?: string(name='DefaultUser'),
      gmtModified?: long(name='GmtModified'),
      hostList?: {
        host?: [ string ](name='Host')
      }(name='HostList'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='ClusterSetting')
  }(name='ClusterSettings'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
}

model ListFlowProjectClusterSettingResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowProjectClusterSettingResponseBody(name='body'),
}

async function listFlowProjectClusterSettingWithOptions(request: ListFlowProjectClusterSettingRequest, runtime: Util.RuntimeOptions): ListFlowProjectClusterSettingResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowProjectClusterSetting',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowProjectClusterSetting(request: ListFlowProjectClusterSettingRequest): ListFlowProjectClusterSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowProjectClusterSettingWithOptions(request, runtime);
}

model ListFlowProjectUserRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListFlowProjectUserResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  users?: {
    user?: [ 
    {
      projectId?: string(name='ProjectId'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      userName?: string(name='UserName'),
      accountUserId?: string(name='AccountUserId'),
      ownerId?: string(name='OwnerId'),
    }
  ](name='User')
  }(name='Users'),
}

model ListFlowProjectUserResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowProjectUserResponseBody(name='body'),
}

async function listFlowProjectUserWithOptions(request: ListFlowProjectUserRequest, runtime: Util.RuntimeOptions): ListFlowProjectUserResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowProjectUser',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowProjectUser(request: ListFlowProjectUserRequest): ListFlowProjectUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowProjectUserWithOptions(request, runtime);
}

model ListJobExecutionInstancesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  executionPlanInstanceId?: string(name='ExecutionPlanInstanceId'),
  isDesc?: boolean(name='IsDesc'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListJobExecutionInstancesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  jobInstances?: {
    jobInstance?: [ 
    {
      status?: string(name='Status'),
      startTime?: long(name='StartTime'),
      jobName?: string(name='JobName'),
      retryInfo?: string(name='RetryInfo'),
      jobId?: string(name='JobId'),
      runTime?: int32(name='RunTime'),
      jobType?: string(name='JobType'),
      id?: string(name='Id'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='JobInstance')
  }(name='JobInstances'),
}

model ListJobExecutionInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobExecutionInstancesResponseBody(name='body'),
}

async function listJobExecutionInstancesWithOptions(request: ListJobExecutionInstancesRequest, runtime: Util.RuntimeOptions): ListJobExecutionInstancesResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ExecutionPlanInstanceId"] = request.executionPlanInstanceId;
  query["IsDesc"] = request.isDesc;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListJobExecutionInstances',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJobExecutionInstances(request: ListJobExecutionInstancesRequest): ListJobExecutionInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobExecutionInstancesWithOptions(request, runtime);
}

model ListJobsRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  isDesc?: boolean(name='IsDesc'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  queryType?: string(name='QueryType'),
  queryString?: string(name='QueryString'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListJobsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  jobs?: {
    jobInfo?: [ 
    {
      type?: string(name='Type'),
      failAct?: string(name='FailAct'),
      retryInterval?: int32(name='RetryInterval'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      runParameter?: string(name='RunParameter'),
      maxRetry?: int32(name='MaxRetry'),
    }
  ](name='JobInfo')
  }(name='Jobs'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobsWithOptions(request: ListJobsRequest, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["IsDesc"] = request.isDesc;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["QueryType"] = request.queryType;
  query["QueryString"] = request.queryString;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListJobs',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJobs(request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobsWithOptions(request, runtime);
}

model ListLibrariesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  limit?: int32(name='Limit'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  currentSize?: int32(name='CurrentSize'),
  pageCount?: int32(name='PageCount'),
  orderField?: string(name='OrderField'),
  orderMode?: string(name='OrderMode'),
  clusterBizId?: string(name='ClusterBizId'),
}

model ListLibrariesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  items?: {
    item?: [ 
    {
      type?: string(name='Type'),
      createTime?: long(name='CreateTime'),
      userId?: string(name='UserId'),
      sourceType?: string(name='SourceType'),
      bizId?: string(name='BizId'),
      scope?: string(name='Scope'),
      libraryVersion?: string(name='LibraryVersion'),
      name?: string(name='Name'),
      properties?: string(name='Properties'),
      sourceLocation?: string(name='SourceLocation'),
    }
  ](name='Item')
  }(name='Items'),
}

model ListLibrariesResponse = {
  headers: map[string]string(name='headers'),
  body: ListLibrariesResponseBody(name='body'),
}

async function listLibrariesWithOptions(request: ListLibrariesRequest, runtime: Util.RuntimeOptions): ListLibrariesResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Limit"] = request.limit;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["CurrentSize"] = request.currentSize;
  query["PageCount"] = request.pageCount;
  query["OrderField"] = request.orderField;
  query["OrderMode"] = request.orderMode;
  query["ClusterBizId"] = request.clusterBizId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListLibraries',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLibraries(request: ListLibrariesRequest): ListLibrariesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLibrariesWithOptions(request, runtime);
}

model ListLibraryInstallTasksRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  limit?: int32(name='Limit'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  currentSize?: int32(name='CurrentSize'),
  pageCount?: int32(name='PageCount'),
  orderField?: string(name='OrderField'),
  orderMode?: string(name='OrderMode'),
  libraryBizId?: string(name='LibraryBizId'),
  clusterBizId?: string(name='ClusterBizId'),
}

model ListLibraryInstallTasksResponseBody = {
  totalCount?: int32(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  items?: {
    item?: [ 
    {
      libraryBizId?: string(name='LibraryBizId'),
      hostname?: string(name='Hostname'),
      endTime?: long(name='EndTime'),
      taskType?: string(name='TaskType'),
      startTime?: long(name='StartTime'),
      taskStatus?: string(name='TaskStatus'),
      taskGroupId?: string(name='TaskGroupId'),
      taskProcess?: int32(name='TaskProcess'),
      clusterBizId?: string(name='ClusterBizId'),
      executeTime?: long(name='ExecuteTime'),
      taskId?: string(name='TaskId'),
      detail?: string(name='Detail'),
    }
  ](name='Item')
  }(name='Items'),
}

model ListLibraryInstallTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListLibraryInstallTasksResponseBody(name='body'),
}

async function listLibraryInstallTasksWithOptions(request: ListLibraryInstallTasksRequest, runtime: Util.RuntimeOptions): ListLibraryInstallTasksResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Limit"] = request.limit;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["CurrentSize"] = request.currentSize;
  query["PageCount"] = request.pageCount;
  query["OrderField"] = request.orderField;
  query["OrderMode"] = request.orderMode;
  query["LibraryBizId"] = request.libraryBizId;
  query["ClusterBizId"] = request.clusterBizId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListLibraryInstallTasks',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLibraryInstallTasks(request: ListLibraryInstallTasksRequest): ListLibraryInstallTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLibraryInstallTasksWithOptions(request, runtime);
}

model ListLibraryStatusRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  limit?: int32(name='Limit'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  currentSize?: int32(name='CurrentSize'),
  pageCount?: int32(name='PageCount'),
  orderField?: string(name='OrderField'),
  orderMode?: string(name='OrderMode'),
  libraryBizId?: string(name='LibraryBizId'),
  clusterBizId?: string(name='ClusterBizId'),
}

model ListLibraryStatusResponseBody = {
  totalCount?: int32(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  items?: {
    item?: [ 
    {
      status?: string(name='Status'),
      libraryBizId?: string(name='LibraryBizId'),
      libraryName?: string(name='LibraryName'),
      clusterName?: string(name='ClusterName'),
      clusterBizId?: string(name='ClusterBizId'),
    }
  ](name='Item')
  }(name='Items'),
}

model ListLibraryStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ListLibraryStatusResponseBody(name='body'),
}

async function listLibraryStatusWithOptions(request: ListLibraryStatusRequest, runtime: Util.RuntimeOptions): ListLibraryStatusResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Limit"] = request.limit;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["CurrentSize"] = request.currentSize;
  query["PageCount"] = request.pageCount;
  query["OrderField"] = request.orderField;
  query["OrderMode"] = request.orderMode;
  query["LibraryBizId"] = request.libraryBizId;
  query["ClusterBizId"] = request.clusterBizId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListLibraryStatus',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLibraryStatus(request: ListLibraryStatusRequest): ListLibraryStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLibraryStatusWithOptions(request, runtime);
}

model ListResourcePoolRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  poolType?: string(name='PoolType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListResourcePoolResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  poolInfoList?: {
    poolInfo?: [ 
    {
      ecmResourcePoolConfigList?: {
        ecmResourcePoolConfig?: [ 
        {
          status?: string(name='Status'),
          configType?: string(name='ConfigType'),
          configValue?: string(name='ConfigValue'),
          note?: string(name='Note'),
          category?: string(name='Category'),
          configKey?: string(name='ConfigKey'),
          id?: long(name='Id'),
        }
      ](name='EcmResourcePoolConfig')
      }(name='EcmResourcePoolConfigList'),
      ecmResourcePool?: {
        active?: boolean(name='Active'),
        poolType?: string(name='PoolType'),
        userId?: string(name='UserId'),
        note?: string(name='Note'),
        yarnSiteConfig?: string(name='YarnSiteConfig'),
        name?: string(name='Name'),
        id?: long(name='Id'),
      }(name='EcmResourcePool'),
      queueList?: {
        queue?: [ 
        {
          ecmResourcePoolConfigList?: {
            ecmResourcePoolConfig?: [ 
            {
              status?: string(name='Status'),
              configType?: string(name='ConfigType'),
              configValue?: string(name='ConfigValue'),
              note?: string(name='Note'),
              category?: string(name='Category'),
              configKey?: string(name='ConfigKey'),
              id?: long(name='Id'),
            }
          ](name='EcmResourcePoolConfig')
          }(name='EcmResourcePoolConfigList'),
          ecmResourceQueue?: {
            status?: string(name='Status'),
            resourcePoolId?: long(name='ResourcePoolId'),
            leaf?: boolean(name='Leaf'),
            parentQueueId?: long(name='ParentQueueId'),
            userId?: string(name='UserId'),
            queueType?: string(name='QueueType'),
            name?: string(name='Name'),
            qualifiedName?: string(name='QualifiedName'),
            id?: long(name='Id'),
          }(name='EcmResourceQueue'),
        }
      ](name='Queue')
      }(name='QueueList'),
    }
  ](name='PoolInfo')
  }(name='PoolInfoList'),
}

model ListResourcePoolResponse = {
  headers: map[string]string(name='headers'),
  body: ListResourcePoolResponseBody(name='body'),
}

async function listResourcePoolWithOptions(request: ListResourcePoolRequest, runtime: Util.RuntimeOptions): ListResourcePoolResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["PoolType"] = request.poolType;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListResourcePool',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourcePool(request: ListResourcePoolRequest): ListResourcePoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourcePoolWithOptions(request, runtime);
}

model ListRolesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
}

model ListRolesResponseBody = {
  requestId?: string(name='RequestId'),
  paging?: boolean(name='Paging'),
  data?: {
    roleDTO?: [ 
    {
      resourceType?: string(name='ResourceType'),
      description?: string(name='Description'),
      gmtCreate?: string(name='GmtCreate'),
      name?: string(name='Name'),
      gmtModified?: string(name='GmtModified'),
      id?: long(name='Id'),
    }
  ](name='roleDTO')
  }(name='Data'),
}

model ListRolesResponse = {
  headers: map[string]string(name='headers'),
  body: ListRolesResponseBody(name='body'),
}

async function listRolesWithOptions(request: ListRolesRequest, runtime: Util.RuntimeOptions): ListRolesResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceType"] = request.resourceType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListRoles',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRoles(request: ListRolesRequest): ListRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRolesWithOptions(request, runtime);
}

model ListScalingActivityV2Request {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  limit?: int32(name='Limit'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  currentSize?: int32(name='CurrentSize'),
  pageCount?: int32(name='PageCount'),
  orderField?: string(name='OrderField'),
  orderMode?: string(name='OrderMode'),
  clusterBizId?: string(name='ClusterBizId'),
  hostGroupId?: string(name='HostGroupId'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  scalingRuleName?: string(name='ScalingRuleName'),
  hostGroupName?: string(name='HostGroupName'),
  status?: string(name='Status'),
}

model ListScalingActivityV2ResponseBody = {
  totalCount?: int32(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  items?: {
    item?: [ 
    {
      status?: string(name='Status'),
      totalCapacity?: int32(name='TotalCapacity'),
      expectNum?: int32(name='ExpectNum'),
      bizId?: string(name='BizId'),
      instanceIds?: string(name='InstanceIds'),
      hostGroupBizId?: string(name='HostGroupBizId'),
      endTime?: long(name='EndTime'),
      startTime?: long(name='StartTime'),
      description?: string(name='Description'),
      scalingRuleName?: string(name='ScalingRuleName'),
      scalingRuleId?: string(name='ScalingRuleId'),
      cause?: string(name='Cause'),
      hostGroupName?: string(name='HostGroupName'),
      transition?: string(name='Transition'),
    }
  ](name='Item')
  }(name='Items'),
}

model ListScalingActivityV2Response = {
  headers: map[string]string(name='headers'),
  body: ListScalingActivityV2ResponseBody(name='body'),
}

async function listScalingActivityV2WithOptions(request: ListScalingActivityV2Request, runtime: Util.RuntimeOptions): ListScalingActivityV2Response {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["Limit"] = request.limit;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["CurrentSize"] = request.currentSize;
  query["PageCount"] = request.pageCount;
  query["OrderField"] = request.orderField;
  query["OrderMode"] = request.orderMode;
  query["ClusterBizId"] = request.clusterBizId;
  query["HostGroupId"] = request.hostGroupId;
  query["ScalingGroupBizId"] = request.scalingGroupBizId;
  query["ScalingRuleName"] = request.scalingRuleName;
  query["HostGroupName"] = request.hostGroupName;
  query["Status"] = request.status;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListScalingActivityV2',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listScalingActivityV2(request: ListScalingActivityV2Request): ListScalingActivityV2Response {
  var runtime = new Util.RuntimeOptions{};
  return listScalingActivityV2WithOptions(request, runtime);
}

model ListScalingConfigItemV2Request {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  limit?: int32(name='Limit'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  currentSize?: int32(name='CurrentSize'),
  pageCount?: int32(name='PageCount'),
  orderField?: string(name='OrderField'),
  orderMode?: string(name='OrderMode'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  configItemType?: string(name='ConfigItemType'),
}

model ListScalingConfigItemV2ResponseBody = {
  totalCount?: int32(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  items?: {
    item?: [ 
    {
      configItemType?: string(name='ConfigItemType'),
      scalingConfigItemBizId?: string(name='ScalingConfigItemBizId'),
      scalingGroupBizId?: string(name='ScalingGroupBizId'),
      configItemInformation?: string(name='ConfigItemInformation'),
    }
  ](name='Item')
  }(name='Items'),
}

model ListScalingConfigItemV2Response = {
  headers: map[string]string(name='headers'),
  body: ListScalingConfigItemV2ResponseBody(name='body'),
}

async function listScalingConfigItemV2WithOptions(request: ListScalingConfigItemV2Request, runtime: Util.RuntimeOptions): ListScalingConfigItemV2Response {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["Limit"] = request.limit;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["CurrentSize"] = request.currentSize;
  query["PageCount"] = request.pageCount;
  query["OrderField"] = request.orderField;
  query["OrderMode"] = request.orderMode;
  query["ScalingGroupBizId"] = request.scalingGroupBizId;
  query["ConfigItemType"] = request.configItemType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListScalingConfigItemV2',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listScalingConfigItemV2(request: ListScalingConfigItemV2Request): ListScalingConfigItemV2Response {
  var runtime = new Util.RuntimeOptions{};
  return listScalingConfigItemV2WithOptions(request, runtime);
}

model ListScalingGroupV2Request {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  limit?: int32(name='Limit'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  currentSize?: int32(name='CurrentSize'),
  pageCount?: int32(name='PageCount'),
  orderField?: string(name='OrderField'),
  orderMode?: string(name='OrderMode'),
  clusterBizId?: string(name='ClusterBizId'),
}

model ListScalingGroupV2ResponseBody = {
  totalCount?: int32(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  items?: {
    item?: [ 
    {
      description?: string(name='Description'),
      scalingInMode?: string(name='ScalingInMode'),
      scalingMaxSize?: int32(name='ScalingMaxSize'),
      name?: string(name='Name'),
      hostGroupBizId?: string(name='HostGroupBizId'),
      scalingMinSize?: int32(name='ScalingMinSize'),
      activeStatus?: string(name='ActiveStatus'),
      scalingGroupId?: string(name='ScalingGroupId'),
    }
  ](name='Item')
  }(name='Items'),
}

model ListScalingGroupV2Response = {
  headers: map[string]string(name='headers'),
  body: ListScalingGroupV2ResponseBody(name='body'),
}

async function listScalingGroupV2WithOptions(request: ListScalingGroupV2Request, runtime: Util.RuntimeOptions): ListScalingGroupV2Response {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["Limit"] = request.limit;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["CurrentSize"] = request.currentSize;
  query["PageCount"] = request.pageCount;
  query["OrderField"] = request.orderField;
  query["OrderMode"] = request.orderMode;
  query["ClusterBizId"] = request.clusterBizId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListScalingGroupV2',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listScalingGroupV2(request: ListScalingGroupV2Request): ListScalingGroupV2Response {
  var runtime = new Util.RuntimeOptions{};
  return listScalingGroupV2WithOptions(request, runtime);
}

model ListSecurityGroupRequest {
  regionId?: string(name='RegionId'),
  netType?: string(name='NetType'),
  vpcId?: string(name='VpcId'),
  depositType?: string(name='DepositType'),
  productType?: string(name='ProductType'),
}

model ListSecurityGroupResponseBody = {
  securityGroupList?: {
    securityGroup?: [ 
    {
      vpcId?: string(name='VpcId'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupName?: string(name='SecurityGroupName'),
      ecsCount?: int32(name='EcsCount'),
      securityGroupType?: string(name='SecurityGroupType'),
      availableInstanceAmount?: int32(name='AvailableInstanceAmount'),
    }
  ](name='SecurityGroup')
  }(name='SecurityGroupList'),
  requestId?: string(name='RequestId'),
}

model ListSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecurityGroupResponseBody(name='body'),
}

async function listSecurityGroupWithOptions(request: ListSecurityGroupRequest, runtime: Util.RuntimeOptions): ListSecurityGroupResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["NetType"] = request.netType;
  query["VpcId"] = request.vpcId;
  query["DepositType"] = request.depositType;
  query["ProductType"] = request.productType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListSecurityGroup',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSecurityGroup(request: ListSecurityGroupRequest): ListSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecurityGroupWithOptions(request, runtime);
}

model ListStackRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  stackName?: string(name='StackName'),
  stackVersion?: string(name='StackVersion'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListStackResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  stackList?: {
    stack?: [ 
    {
      status?: string(name='Status'),
      version?: string(name='Version'),
      name?: string(name='Name'),
    }
  ](name='Stack')
  }(name='StackList'),
}

model ListStackResponse = {
  headers: map[string]string(name='headers'),
  body: ListStackResponseBody(name='body'),
}

async function listStackWithOptions(request: ListStackRequest, runtime: Util.RuntimeOptions): ListStackResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["StackName"] = request.stackName;
  query["StackVersion"] = request.stackVersion;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListStack',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listStack(request: ListStackRequest): ListStackResponse {
  var runtime = new Util.RuntimeOptions{};
  return listStackWithOptions(request, runtime);
}

model ListTagKeysRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize'),
  resourceType?: string(name='ResourceType'),
  category?: string(name='Category'),
  scope?: string(name='Scope'),
}

model ListTagKeysResponseBody = {
  totalCount?: int32(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  keys?: {
    key?: [ string ](name='Key')
  }(name='Keys'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListTagKeysResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagKeysResponseBody(name='body'),
}

async function listTagKeysWithOptions(request: ListTagKeysRequest, runtime: Util.RuntimeOptions): ListTagKeysResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["NextToken"] = request.nextToken;
  query["PageSize"] = request.pageSize;
  query["ResourceType"] = request.resourceType;
  query["Category"] = request.category;
  query["Scope"] = request.scope;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListTagKeys',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagKeys(request: ListTagKeysRequest): ListTagKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagKeysWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
  nextToken?: string(name='NextToken'),
  resourceId?: [ string ](name='ResourceId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceType?: string(name='ResourceType'),
      tagValue?: string(name='TagValue'),
      resourceId?: string(name='ResourceId'),
      tagKey?: string(name='TagKey'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceType"] = request.resourceType;
  query["NextToken"] = request.nextToken;
  query["ResourceId"] = request.resourceId;
  query["Tag"] = request.tag;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListTagValuesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  key?: string(name='Key'),
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize'),
  resourceType?: string(name='ResourceType'),
  scope?: string(name='Scope'),
}

model ListTagValuesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  values?: {
    value?: [ string ](name='Value')
  }(name='Values'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListTagValuesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagValuesResponseBody(name='body'),
}

async function listTagValuesWithOptions(request: ListTagValuesRequest, runtime: Util.RuntimeOptions): ListTagValuesResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Key"] = request.key;
  query["NextToken"] = request.nextToken;
  query["PageSize"] = request.pageSize;
  query["ResourceType"] = request.resourceType;
  query["Scope"] = request.scope;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListTagValues',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagValues(request: ListTagValuesRequest): ListTagValuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagValuesWithOptions(request, runtime);
}

model ListUsersRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  type?: string(name='Type'),
}

model ListUsersResponseBody = {
  requestId?: string(name='RequestId'),
  userList?: {
    user?: [ 
    {
      linuxStatus?: string(name='LinuxStatus'),
      k8sStatus?: string(name='K8sStatus'),
      knoxStatus?: string(name='KnoxStatus'),
      groupName?: string(name='GroupName'),
      userId?: string(name='UserId'),
      kerberosStatus?: string(name='KerberosStatus'),
      userName?: string(name='UserName'),
    }
  ](name='User')
  }(name='UserList'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsersWithOptions(request: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["Type"] = request.type;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListUsers',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model ListVswitchRequest {
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
  depositType?: string(name='DepositType'),
  productType?: string(name='ProductType'),
}

model ListVswitchResponseBody = {
  requestId?: string(name='RequestId'),
  vswitchList?: {
    vswitch?: [ 
    {
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      isDefault?: boolean(name='IsDefault'),
      vSwitchId?: string(name='VSwitchId'),
      cidrBlock?: string(name='CidrBlock'),
      description?: string(name='Description'),
      availableIpAddressCount?: string(name='AvailableIpAddressCount'),
      resourceGroupId?: string(name='ResourceGroupId'),
      zoneId?: string(name='ZoneId'),
      vSwitchName?: string(name='VSwitchName'),
    }
  ](name='Vswitch')
  }(name='VswitchList'),
}

model ListVswitchResponse = {
  headers: map[string]string(name='headers'),
  body: ListVswitchResponseBody(name='body'),
}

async function listVswitchWithOptions(request: ListVswitchRequest, runtime: Util.RuntimeOptions): ListVswitchResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["VpcId"] = request.vpcId;
  query["ZoneId"] = request.zoneId;
  query["DepositType"] = request.depositType;
  query["ProductType"] = request.productType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListVswitch',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVswitch(request: ListVswitchRequest): ListVswitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVswitchWithOptions(request, runtime);
}

model ModifyClusterBootstrapActionRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  id?: string(name='Id'),
  bootstrapAction?: [ 
    {
      executionFailStrategy?: string(name='ExecutionFailStrategy'),
      arg?: string(name='Arg'),
      path?: string(name='Path'),
      executionTarget?: string(name='ExecutionTarget'),
      executionMoment?: string(name='ExecutionMoment'),
      name?: string(name='Name'),
    }
  ](name='BootstrapAction'),
}

model ModifyClusterBootstrapActionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterBootstrapActionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterBootstrapActionResponseBody(name='body'),
}

async function modifyClusterBootstrapActionWithOptions(request: ModifyClusterBootstrapActionRequest, runtime: Util.RuntimeOptions): ModifyClusterBootstrapActionResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["Id"] = request.id;
  query["BootstrapAction"] = request.bootstrapAction;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterBootstrapAction',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClusterBootstrapAction(request: ModifyClusterBootstrapActionRequest): ModifyClusterBootstrapActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterBootstrapActionWithOptions(request, runtime);
}

model ModifyClusterHostGroupRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostGroupId?: string(name='HostGroupId'),
  hostGroupName?: string(name='HostGroupName'),
  securityGroupId?: string(name='SecurityGroupId'),
  vswitchId?: string(name='VswitchId'),
  comment?: string(name='Comment'),
}

model ModifyClusterHostGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterHostGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterHostGroupResponseBody(name='body'),
}

async function modifyClusterHostGroupWithOptions(request: ModifyClusterHostGroupRequest, runtime: Util.RuntimeOptions): ModifyClusterHostGroupResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["HostGroupId"] = request.hostGroupId;
  query["HostGroupName"] = request.hostGroupName;
  query["SecurityGroupId"] = request.securityGroupId;
  query["VswitchId"] = request.vswitchId;
  query["Comment"] = request.comment;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterHostGroup',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClusterHostGroup(request: ModifyClusterHostGroupRequest): ModifyClusterHostGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterHostGroupWithOptions(request, runtime);
}

model ModifyClusterMetaCollectRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  switchOn?: boolean(name='SwitchOn'),
}

model ModifyClusterMetaCollectResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterMetaCollectResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterMetaCollectResponseBody(name='body'),
}

async function modifyClusterMetaCollectWithOptions(request: ModifyClusterMetaCollectRequest, runtime: Util.RuntimeOptions): ModifyClusterMetaCollectResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["SwitchOn"] = request.switchOn;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterMetaCollect',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClusterMetaCollect(request: ModifyClusterMetaCollectRequest): ModifyClusterMetaCollectResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterMetaCollectWithOptions(request, runtime);
}

model ModifyClusterNameRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
}

model ModifyClusterNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterNameResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterNameResponseBody(name='body'),
}

async function modifyClusterNameWithOptions(request: ModifyClusterNameRequest, runtime: Util.RuntimeOptions): ModifyClusterNameResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Id"] = request.id;
  query["Name"] = request.name;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterName',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClusterName(request: ModifyClusterNameRequest): ModifyClusterNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterNameWithOptions(request, runtime);
}

model ModifyClusterSecurityGroupRuleRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  modifyType?: string(name='ModifyType'),
  nicType?: string(name='NicType'),
  ipProtocol?: string(name='IpProtocol'),
  portRange?: string(name='PortRange'),
  whiteIp?: string(name='WhiteIp'),
}

model ModifyClusterSecurityGroupRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterSecurityGroupRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterSecurityGroupRuleResponseBody(name='body'),
}

async function modifyClusterSecurityGroupRuleWithOptions(request: ModifyClusterSecurityGroupRuleRequest, runtime: Util.RuntimeOptions): ModifyClusterSecurityGroupRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["ModifyType"] = request.modifyType;
  query["NicType"] = request.nicType;
  query["IpProtocol"] = request.ipProtocol;
  query["PortRange"] = request.portRange;
  query["WhiteIp"] = request.whiteIp;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterSecurityGroupRule',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClusterSecurityGroupRule(request: ModifyClusterSecurityGroupRuleRequest): ModifyClusterSecurityGroupRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterSecurityGroupRuleWithOptions(request, runtime);
}

model ModifyClusterServiceConfigRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
  comment?: string(name='Comment'),
  configParams?: string(name='ConfigParams'),
  customConfigParams?: string(name='CustomConfigParams'),
  groupId?: string(name='GroupId'),
  hostInstanceId?: string(name='HostInstanceId'),
  configType?: string(name='ConfigType'),
  refreshHostConfig?: boolean(name='RefreshHostConfig'),
  gatewayClusterIdList?: [ string ](name='GatewayClusterIdList'),
}

model ModifyClusterServiceConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterServiceConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterServiceConfigResponseBody(name='body'),
}

async function modifyClusterServiceConfigWithOptions(request: ModifyClusterServiceConfigRequest, runtime: Util.RuntimeOptions): ModifyClusterServiceConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["ServiceName"] = request.serviceName;
  query["Comment"] = request.comment;
  query["ConfigParams"] = request.configParams;
  query["CustomConfigParams"] = request.customConfigParams;
  query["GroupId"] = request.groupId;
  query["HostInstanceId"] = request.hostInstanceId;
  query["ConfigType"] = request.configType;
  query["RefreshHostConfig"] = request.refreshHostConfig;
  query["GatewayClusterIdList"] = request.gatewayClusterIdList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterServiceConfig',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClusterServiceConfig(request: ModifyClusterServiceConfigRequest): ModifyClusterServiceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterServiceConfigWithOptions(request, runtime);
}

model ModifyClusterTemplateRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  bizId?: string(name='BizId'),
  templateName?: string(name='TemplateName'),
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
  logPath?: string(name='LogPath'),
  securityGroupId?: string(name='SecurityGroupId'),
  isOpenPublicIp?: boolean(name='IsOpenPublicIp'),
  securityGroupName?: string(name='SecurityGroupName'),
  chargeType?: string(name='ChargeType'),
  period?: int32(name='Period'),
  autoRenew?: boolean(name='AutoRenew'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  netType?: string(name='NetType'),
  userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
  emrVer?: string(name='EmrVer'),
  clusterType?: string(name='ClusterType'),
  highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
  useLocalMetaDb?: boolean(name='UseLocalMetaDb'),
  ioOptimized?: boolean(name='IoOptimized'),
  sshEnable?: boolean(name='SshEnable'),
  instanceGeneration?: string(name='InstanceGeneration'),
  masterPwd?: string(name='MasterPwd'),
  keyPairName?: string(name='KeyPairName'),
  metaStoreType?: string(name='MetaStoreType'),
  metaStoreConf?: string(name='MetaStoreConf'),
  configurations?: string(name='Configurations'),
  easEnable?: boolean(name='EasEnable'),
  depositType?: string(name='DepositType'),
  machineType?: string(name='MachineType'),
  useCustomHiveMetaDb?: boolean(name='UseCustomHiveMetaDb'),
  initCustomHiveMetaDb?: boolean(name='InitCustomHiveMetaDb'),
  resourceGroupId?: string(name='ResourceGroupId'),
  optionSoftWareList?: [ string ](name='OptionSoftWareList'),
  hostGroup?: [ 
    {
      sysDiskCapacity?: int32(name='SysDiskCapacity'),
      hostGroupType?: string(name='HostGroupType'),
      comment?: string(name='Comment'),
      multiInstanceTypes?: string(name='MultiInstanceTypes'),
      sysDiskType?: string(name='SysDiskType'),
      autoRenew?: boolean(name='AutoRenew'),
      chargeType?: string(name='ChargeType'),
      diskType?: string(name='DiskType'),
      hostGroupId?: string(name='HostGroupId'),
      instanceType?: string(name='InstanceType'),
      diskCount?: int32(name='DiskCount'),
      createType?: string(name='CreateType'),
      period?: int32(name='Period'),
      diskCapacity?: int32(name='DiskCapacity'),
      vSwitchId?: string(name='VSwitchId'),
      nodeCount?: int32(name='NodeCount'),
      hostGroupName?: string(name='HostGroupName'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='HostGroup'),
  bootstrapAction?: [ 
    {
      executionFailStrategy?: string(name='ExecutionFailStrategy'),
      arg?: string(name='Arg'),
      path?: string(name='Path'),
      executionTarget?: string(name='ExecutionTarget'),
      executionMoment?: string(name='ExecutionMoment'),
      name?: string(name='Name'),
    }
  ](name='BootstrapAction'),
  config?: [ 
    {
      configValue?: string(name='ConfigValue'),
      replace?: string(name='Replace'),
      fileName?: string(name='FileName'),
      serviceName?: string(name='ServiceName'),
      configKey?: string(name='ConfigKey'),
      encrypt?: string(name='Encrypt'),
    }
  ](name='Config'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ModifyClusterTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  clusterTemplateId?: string(name='ClusterTemplateId'),
}

model ModifyClusterTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterTemplateResponseBody(name='body'),
}

async function modifyClusterTemplateWithOptions(request: ModifyClusterTemplateRequest, runtime: Util.RuntimeOptions): ModifyClusterTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["BizId"] = request.bizId;
  query["TemplateName"] = request.templateName;
  query["RegionId"] = request.regionId;
  query["ZoneId"] = request.zoneId;
  query["LogPath"] = request.logPath;
  query["SecurityGroupId"] = request.securityGroupId;
  query["IsOpenPublicIp"] = request.isOpenPublicIp;
  query["SecurityGroupName"] = request.securityGroupName;
  query["ChargeType"] = request.chargeType;
  query["Period"] = request.period;
  query["AutoRenew"] = request.autoRenew;
  query["VpcId"] = request.vpcId;
  query["VSwitchId"] = request.vSwitchId;
  query["NetType"] = request.netType;
  query["UserDefinedEmrEcsRole"] = request.userDefinedEmrEcsRole;
  query["EmrVer"] = request.emrVer;
  query["ClusterType"] = request.clusterType;
  query["HighAvailabilityEnable"] = request.highAvailabilityEnable;
  query["UseLocalMetaDb"] = request.useLocalMetaDb;
  query["IoOptimized"] = request.ioOptimized;
  query["SshEnable"] = request.sshEnable;
  query["InstanceGeneration"] = request.instanceGeneration;
  query["MasterPwd"] = request.masterPwd;
  query["KeyPairName"] = request.keyPairName;
  query["MetaStoreType"] = request.metaStoreType;
  query["MetaStoreConf"] = request.metaStoreConf;
  query["Configurations"] = request.configurations;
  query["EasEnable"] = request.easEnable;
  query["DepositType"] = request.depositType;
  query["MachineType"] = request.machineType;
  query["UseCustomHiveMetaDb"] = request.useCustomHiveMetaDb;
  query["InitCustomHiveMetaDb"] = request.initCustomHiveMetaDb;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["OptionSoftWareList"] = request.optionSoftWareList;
  query["HostGroup"] = request.hostGroup;
  query["BootstrapAction"] = request.bootstrapAction;
  query["Config"] = request.config;
  query["Tag"] = request.tag;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterTemplate',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClusterTemplate(request: ModifyClusterTemplateRequest): ModifyClusterTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterTemplateWithOptions(request, runtime);
}

model ModifyExecutionPlanRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  clusterName?: string(name='ClusterName'),
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
  logEnable?: boolean(name='LogEnable'),
  logPath?: string(name='LogPath'),
  securityGroupId?: string(name='SecurityGroupId'),
  isOpenPublicIp?: boolean(name='IsOpenPublicIp'),
  createClusterOnDemand?: boolean(name='CreateClusterOnDemand'),
  emrVer?: string(name='EmrVer'),
  clusterType?: string(name='ClusterType'),
  highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
  useLocalMetaDb?: boolean(name='UseLocalMetaDb'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  netType?: string(name='NetType'),
  userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
  ioOptimized?: boolean(name='IoOptimized'),
  instanceGeneration?: string(name='InstanceGeneration'),
  easEnable?: boolean(name='EasEnable'),
  workflowDefinition?: string(name='WorkflowDefinition'),
  useCustomHiveMetaDB?: boolean(name='UseCustomHiveMetaDB'),
  initCustomHiveMetaDB?: boolean(name='InitCustomHiveMetaDB'),
  configurations?: string(name='Configurations'),
  id?: string(name='Id'),
  executionPlanVersion?: long(name='ExecutionPlanVersion'),
  name?: string(name='Name'),
  strategy?: string(name='Strategy'),
  timeInterval?: int32(name='TimeInterval'),
  startTime?: long(name='StartTime'),
  timeUnit?: string(name='TimeUnit'),
  dayOfWeek?: string(name='DayOfWeek'),
  dayOfMonth?: string(name='DayOfMonth'),
  optionSoftWareList?: [ string ](name='OptionSoftWareList'),
  ecsOrder?: [ 
    {
      index?: int32(name='Index'),
      diskCapacity?: int32(name='DiskCapacity'),
      nodeType?: string(name='NodeType'),
      nodeCount?: int32(name='NodeCount'),
      diskType?: string(name='DiskType'),
      instanceType?: string(name='InstanceType'),
      diskCount?: int32(name='DiskCount'),
    }
  ](name='EcsOrder'),
  bootstrapAction?: [ 
    {
      executionFailStrategy?: string(name='ExecutionFailStrategy'),
      arg?: string(name='Arg'),
      path?: string(name='Path'),
      executionTarget?: string(name='ExecutionTarget'),
      executionMoment?: string(name='ExecutionMoment'),
      name?: string(name='Name'),
    }
  ](name='BootstrapAction'),
  config?: [ 
    {
      configValue?: string(name='ConfigValue'),
      replace?: string(name='Replace'),
      fileName?: string(name='FileName'),
      serviceName?: string(name='ServiceName'),
      configKey?: string(name='ConfigKey'),
      encrypt?: string(name='Encrypt'),
    }
  ](name='Config'),
  jobIdList?: [ string ](name='JobIdList'),
}

model ModifyExecutionPlanResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyExecutionPlanResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyExecutionPlanResponseBody(name='body'),
}

async function modifyExecutionPlanWithOptions(request: ModifyExecutionPlanRequest, runtime: Util.RuntimeOptions): ModifyExecutionPlanResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["ClusterName"] = request.clusterName;
  query["ClusterId"] = request.clusterId;
  query["RegionId"] = request.regionId;
  query["ZoneId"] = request.zoneId;
  query["LogEnable"] = request.logEnable;
  query["LogPath"] = request.logPath;
  query["SecurityGroupId"] = request.securityGroupId;
  query["IsOpenPublicIp"] = request.isOpenPublicIp;
  query["CreateClusterOnDemand"] = request.createClusterOnDemand;
  query["EmrVer"] = request.emrVer;
  query["ClusterType"] = request.clusterType;
  query["HighAvailabilityEnable"] = request.highAvailabilityEnable;
  query["UseLocalMetaDb"] = request.useLocalMetaDb;
  query["VpcId"] = request.vpcId;
  query["VSwitchId"] = request.vSwitchId;
  query["NetType"] = request.netType;
  query["UserDefinedEmrEcsRole"] = request.userDefinedEmrEcsRole;
  query["IoOptimized"] = request.ioOptimized;
  query["InstanceGeneration"] = request.instanceGeneration;
  query["EasEnable"] = request.easEnable;
  query["WorkflowDefinition"] = request.workflowDefinition;
  query["UseCustomHiveMetaDB"] = request.useCustomHiveMetaDB;
  query["InitCustomHiveMetaDB"] = request.initCustomHiveMetaDB;
  query["Configurations"] = request.configurations;
  query["Id"] = request.id;
  query["ExecutionPlanVersion"] = request.executionPlanVersion;
  query["Name"] = request.name;
  query["Strategy"] = request.strategy;
  query["TimeInterval"] = request.timeInterval;
  query["StartTime"] = request.startTime;
  query["TimeUnit"] = request.timeUnit;
  query["DayOfWeek"] = request.dayOfWeek;
  query["DayOfMonth"] = request.dayOfMonth;
  query["OptionSoftWareList"] = request.optionSoftWareList;
  query["EcsOrder"] = request.ecsOrder;
  query["BootstrapAction"] = request.bootstrapAction;
  query["Config"] = request.config;
  query["JobIdList"] = request.jobIdList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyExecutionPlan',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyExecutionPlan(request: ModifyExecutionPlanRequest): ModifyExecutionPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyExecutionPlanWithOptions(request, runtime);
}

model ModifyFlowRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  status?: string(name='Status'),
  description?: string(name='Description'),
  periodic?: boolean(name='Periodic'),
  startSchedule?: long(name='StartSchedule'),
  endSchedule?: long(name='EndSchedule'),
  cronExpr?: string(name='CronExpr'),
  createCluster?: boolean(name='CreateCluster'),
  clusterId?: string(name='ClusterId'),
  hostName?: string(name='HostName'),
  namespace?: string(name='Namespace'),
  logArchiveLocation?: string(name='LogArchiveLocation'),
  lifecycle?: string(name='Lifecycle'),
  application?: string(name='Application'),
  alertConf?: string(name='AlertConf'),
  alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
  alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
  parentFlowList?: string(name='ParentFlowList'),
  parentCategory?: string(name='ParentCategory'),
}

model ModifyFlowResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model ModifyFlowResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowResponseBody(name='body'),
}

async function modifyFlowWithOptions(request: ModifyFlowRequest, runtime: Util.RuntimeOptions): ModifyFlowResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["Id"] = request.id;
  query["Name"] = request.name;
  query["Status"] = request.status;
  query["Description"] = request.description;
  query["Periodic"] = request.periodic;
  query["StartSchedule"] = request.startSchedule;
  query["EndSchedule"] = request.endSchedule;
  query["CronExpr"] = request.cronExpr;
  query["CreateCluster"] = request.createCluster;
  query["ClusterId"] = request.clusterId;
  query["HostName"] = request.hostName;
  query["Namespace"] = request.namespace;
  query["LogArchiveLocation"] = request.logArchiveLocation;
  query["Lifecycle"] = request.lifecycle;
  query["Application"] = request.application;
  query["AlertConf"] = request.alertConf;
  query["AlertUserGroupBizId"] = request.alertUserGroupBizId;
  query["AlertDingDingGroupBizId"] = request.alertDingDingGroupBizId;
  query["ParentFlowList"] = request.parentFlowList;
  query["ParentCategory"] = request.parentCategory;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyFlow',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyFlow(request: ModifyFlowRequest): ModifyFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowWithOptions(request, runtime);
}

model ModifyFlowCategoryRequest {
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  parentId?: string(name='ParentId'),
}

model ModifyFlowCategoryResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model ModifyFlowCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowCategoryResponseBody(name='body'),
}

async function modifyFlowCategoryWithOptions(request: ModifyFlowCategoryRequest, runtime: Util.RuntimeOptions): ModifyFlowCategoryResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["RegionId"] = request.regionId;
  query["Id"] = request.id;
  query["Name"] = request.name;
  query["ParentId"] = request.parentId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyFlowCategory',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyFlowCategory(request: ModifyFlowCategoryRequest): ModifyFlowCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowCategoryWithOptions(request, runtime);
}

model ModifyFlowForWebRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  status?: string(name='Status'),
  description?: string(name='Description'),
  periodic?: boolean(name='Periodic'),
  startSchedule?: long(name='StartSchedule'),
  endSchedule?: long(name='EndSchedule'),
  cronExpr?: string(name='CronExpr'),
  createCluster?: boolean(name='CreateCluster'),
  clusterId?: string(name='ClusterId'),
  hostName?: string(name='HostName'),
  namespace?: string(name='Namespace'),
  logArchiveLocation?: string(name='LogArchiveLocation'),
  lifecycle?: string(name='Lifecycle'),
  graph?: string(name='Graph'),
  alertConf?: string(name='AlertConf'),
  alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
  alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
  parentFlowList?: string(name='ParentFlowList'),
  parentCategory?: string(name='ParentCategory'),
}

model ModifyFlowForWebResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model ModifyFlowForWebResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowForWebResponseBody(name='body'),
}

async function modifyFlowForWebWithOptions(request: ModifyFlowForWebRequest, runtime: Util.RuntimeOptions): ModifyFlowForWebResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["Id"] = request.id;
  query["Name"] = request.name;
  query["Status"] = request.status;
  query["Description"] = request.description;
  query["Periodic"] = request.periodic;
  query["StartSchedule"] = request.startSchedule;
  query["EndSchedule"] = request.endSchedule;
  query["CronExpr"] = request.cronExpr;
  query["CreateCluster"] = request.createCluster;
  query["ClusterId"] = request.clusterId;
  query["HostName"] = request.hostName;
  query["Namespace"] = request.namespace;
  query["LogArchiveLocation"] = request.logArchiveLocation;
  query["Lifecycle"] = request.lifecycle;
  query["Graph"] = request.graph;
  query["AlertConf"] = request.alertConf;
  query["AlertUserGroupBizId"] = request.alertUserGroupBizId;
  query["AlertDingDingGroupBizId"] = request.alertDingDingGroupBizId;
  query["ParentFlowList"] = request.parentFlowList;
  query["ParentCategory"] = request.parentCategory;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyFlowForWeb',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyFlowForWeb(request: ModifyFlowForWebRequest): ModifyFlowForWebResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowForWebWithOptions(request, runtime);
}

model ModifyFlowJobRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  failAct?: string(name='FailAct'),
  maxRetry?: int32(name='MaxRetry'),
  retryPolicy?: string(name='RetryPolicy'),
  maxRunningTimeSec?: long(name='MaxRunningTimeSec'),
  retryInterval?: long(name='RetryInterval'),
  params?: string(name='Params'),
  paramConf?: string(name='ParamConf'),
  customVariables?: string(name='CustomVariables'),
  envConf?: string(name='EnvConf'),
  runConf?: string(name='RunConf'),
  monitorConf?: string(name='MonitorConf'),
  mode?: string(name='Mode'),
  clusterId?: string(name='ClusterId'),
  alertConf?: string(name='AlertConf'),
  resourceList?: [ 
    {
      path?: string(name='Path'),
      alias?: string(name='Alias'),
    }
  ](name='ResourceList'),
}

model ModifyFlowJobResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model ModifyFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowJobResponseBody(name='body'),
}

async function modifyFlowJobWithOptions(request: ModifyFlowJobRequest, runtime: Util.RuntimeOptions): ModifyFlowJobResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["Id"] = request.id;
  query["Name"] = request.name;
  query["Description"] = request.description;
  query["FailAct"] = request.failAct;
  query["MaxRetry"] = request.maxRetry;
  query["RetryPolicy"] = request.retryPolicy;
  query["MaxRunningTimeSec"] = request.maxRunningTimeSec;
  query["RetryInterval"] = request.retryInterval;
  query["Params"] = request.params;
  query["ParamConf"] = request.paramConf;
  query["CustomVariables"] = request.customVariables;
  query["EnvConf"] = request.envConf;
  query["RunConf"] = request.runConf;
  query["MonitorConf"] = request.monitorConf;
  query["Mode"] = request.mode;
  query["ClusterId"] = request.clusterId;
  query["AlertConf"] = request.alertConf;
  query["ResourceList"] = request.resourceList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyFlowJob',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyFlowJob(request: ModifyFlowJobRequest): ModifyFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowJobWithOptions(request, runtime);
}

model ModifyFlowProjectRequest {
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model ModifyFlowProjectResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model ModifyFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowProjectResponseBody(name='body'),
}

async function modifyFlowProjectWithOptions(request: ModifyFlowProjectRequest, runtime: Util.RuntimeOptions): ModifyFlowProjectResponse {
  Util.validateModel(request);
  var query = {};
  query["ProjectId"] = request.projectId;
  query["RegionId"] = request.regionId;
  query["Name"] = request.name;
  query["Description"] = request.description;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyFlowProject',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyFlowProject(request: ModifyFlowProjectRequest): ModifyFlowProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowProjectWithOptions(request, runtime);
}

model ModifyFlowProjectClusterSettingRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  clusterId?: string(name='ClusterId'),
  defaultUser?: string(name='DefaultUser'),
  defaultQueue?: string(name='DefaultQueue'),
  userList?: [ string ](name='UserList'),
  queueList?: [ string ](name='QueueList'),
  hostList?: [ string ](name='HostList'),
}

model ModifyFlowProjectClusterSettingResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model ModifyFlowProjectClusterSettingResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowProjectClusterSettingResponseBody(name='body'),
}

async function modifyFlowProjectClusterSettingWithOptions(request: ModifyFlowProjectClusterSettingRequest, runtime: Util.RuntimeOptions): ModifyFlowProjectClusterSettingResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["ClusterId"] = request.clusterId;
  query["DefaultUser"] = request.defaultUser;
  query["DefaultQueue"] = request.defaultQueue;
  query["UserList"] = request.userList;
  query["QueueList"] = request.queueList;
  query["HostList"] = request.hostList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyFlowProjectClusterSetting',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyFlowProjectClusterSetting(request: ModifyFlowProjectClusterSettingRequest): ModifyFlowProjectClusterSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowProjectClusterSettingWithOptions(request, runtime);
}

model ModifyJobRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
  runParameter?: string(name='RunParameter'),
  failAct?: string(name='FailAct'),
  maxRetry?: int32(name='MaxRetry'),
  retryInterval?: int32(name='RetryInterval'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ModifyJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyJobResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyJobResponseBody(name='body'),
}

async function modifyJobWithOptions(request: ModifyJobRequest, runtime: Util.RuntimeOptions): ModifyJobResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Id"] = request.id;
  query["Name"] = request.name;
  query["RegionId"] = request.regionId;
  query["Type"] = request.type;
  query["RunParameter"] = request.runParameter;
  query["FailAct"] = request.failAct;
  query["MaxRetry"] = request.maxRetry;
  query["RetryInterval"] = request.retryInterval;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyJob',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyJob(request: ModifyJobRequest): ModifyJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyJobWithOptions(request, runtime);
}

model ModifyResourcePoolRequest {
  regionId?: string(name='RegionId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  id?: string(name='Id'),
  active?: boolean(name='Active'),
  name?: string(name='Name'),
  clusterId?: string(name='ClusterId'),
  yarnsiteconfig?: string(name='Yarnsiteconfig'),
  config?: [ 
    {
      configValue?: string(name='ConfigValue'),
      note?: string(name='Note'),
      category?: string(name='Category'),
      configKey?: string(name='ConfigKey'),
      id?: string(name='Id'),
    }
  ](name='Config'),
}

model ModifyResourcePoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyResourcePoolResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyResourcePoolResponseBody(name='body'),
}

async function modifyResourcePoolWithOptions(request: ModifyResourcePoolRequest, runtime: Util.RuntimeOptions): ModifyResourcePoolResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Id"] = request.id;
  query["Active"] = request.active;
  query["Name"] = request.name;
  query["ClusterId"] = request.clusterId;
  query["Yarnsiteconfig"] = request.yarnsiteconfig;
  query["Config"] = request.config;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyResourcePool',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyResourcePool(request: ModifyResourcePoolRequest): ModifyResourcePoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyResourcePoolWithOptions(request, runtime);
}

model ModifyResourcePoolSchedulerTypeRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  schedulerType?: string(name='SchedulerType'),
}

model ModifyResourcePoolSchedulerTypeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyResourcePoolSchedulerTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyResourcePoolSchedulerTypeResponseBody(name='body'),
}

async function modifyResourcePoolSchedulerTypeWithOptions(request: ModifyResourcePoolSchedulerTypeRequest, runtime: Util.RuntimeOptions): ModifyResourcePoolSchedulerTypeResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["SchedulerType"] = request.schedulerType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyResourcePoolSchedulerType',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyResourcePoolSchedulerType(request: ModifyResourcePoolSchedulerTypeRequest): ModifyResourcePoolSchedulerTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyResourcePoolSchedulerTypeWithOptions(request, runtime);
}

model ModifyResourceQueueRequest {
  regionId?: string(name='RegionId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  qualifiedName?: string(name='QualifiedName'),
  clusterId?: string(name='ClusterId'),
  parentQueueId?: long(name='ParentQueueId'),
  leaf?: boolean(name='Leaf'),
  resourcePoolId?: long(name='ResourcePoolId'),
  config?: [ 
    {
      configValue?: string(name='ConfigValue'),
      note?: string(name='Note'),
      category?: string(name='Category'),
      configKey?: string(name='ConfigKey'),
      id?: long(name='Id'),
    }
  ](name='Config'),
}

model ModifyResourceQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyResourceQueueResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyResourceQueueResponseBody(name='body'),
}

async function modifyResourceQueueWithOptions(request: ModifyResourceQueueRequest, runtime: Util.RuntimeOptions): ModifyResourceQueueResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Id"] = request.id;
  query["Name"] = request.name;
  query["QualifiedName"] = request.qualifiedName;
  query["ClusterId"] = request.clusterId;
  query["ParentQueueId"] = request.parentQueueId;
  query["Leaf"] = request.leaf;
  query["ResourcePoolId"] = request.resourcePoolId;
  query["Config"] = request.config;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyResourceQueue',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyResourceQueue(request: ModifyResourceQueueRequest): ModifyResourceQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyResourceQueueWithOptions(request, runtime);
}

model ModifyScalingConfigItemV2Request {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  configItemBizId?: string(name='ConfigItemBizId'),
  configItemType?: string(name='ConfigItemType'),
  configItemInformation?: string(name='ConfigItemInformation'),
}

model ModifyScalingConfigItemV2ResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model ModifyScalingConfigItemV2Response = {
  headers: map[string]string(name='headers'),
  body: ModifyScalingConfigItemV2ResponseBody(name='body'),
}

async function modifyScalingConfigItemV2WithOptions(request: ModifyScalingConfigItemV2Request, runtime: Util.RuntimeOptions): ModifyScalingConfigItemV2Response {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["ScalingGroupBizId"] = request.scalingGroupBizId;
  query["ConfigItemBizId"] = request.configItemBizId;
  query["ConfigItemType"] = request.configItemType;
  query["ConfigItemInformation"] = request.configItemInformation;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyScalingConfigItemV2',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyScalingConfigItemV2(request: ModifyScalingConfigItemV2Request): ModifyScalingConfigItemV2Response {
  var runtime = new Util.RuntimeOptions{};
  return modifyScalingConfigItemV2WithOptions(request, runtime);
}

model ModifyScalingGroupV2Request {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
}

model ModifyScalingGroupV2ResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model ModifyScalingGroupV2Response = {
  headers: map[string]string(name='headers'),
  body: ModifyScalingGroupV2ResponseBody(name='body'),
}

async function modifyScalingGroupV2WithOptions(request: ModifyScalingGroupV2Request, runtime: Util.RuntimeOptions): ModifyScalingGroupV2Response {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["Name"] = request.name;
  query["Description"] = request.description;
  query["ScalingGroupBizId"] = request.scalingGroupBizId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyScalingGroupV2',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyScalingGroupV2(request: ModifyScalingGroupV2Request): ModifyScalingGroupV2Response {
  var runtime = new Util.RuntimeOptions{};
  return modifyScalingGroupV2WithOptions(request, runtime);
}

model ModifyScalingRuleRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  scalingRuleId?: string(name='ScalingRuleId'),
  clusterId?: string(name='ClusterId'),
  hostGroupId?: string(name='HostGroupId'),
  ruleName?: string(name='RuleName'),
  adjustmentType?: string(name='AdjustmentType'),
  adjustmentValue?: int32(name='AdjustmentValue'),
  cooldown?: int32(name='Cooldown'),
  launchTime?: string(name='LaunchTime'),
  launchExpirationTime?: int32(name='LaunchExpirationTime'),
  recurrenceType?: string(name='RecurrenceType'),
  recurrenceValue?: string(name='RecurrenceValue'),
  recurrenceEndTime?: string(name='RecurrenceEndTime'),
  withGrace?: boolean(name='WithGrace'),
  timeoutWithGrace?: long(name='TimeoutWithGrace'),
  schedulerTrigger?: [ 
    {
      launchExpirationTime?: int32(name='LaunchExpirationTime'),
      recurrenceValue?: string(name='RecurrenceValue'),
      recurrenceType?: string(name='RecurrenceType'),
      recurrenceEndTime?: string(name='RecurrenceEndTime'),
      launchTime?: string(name='LaunchTime'),
    }
  ](name='SchedulerTrigger'),
  cloudWatchTrigger?: [ 
    {
      comparisonOperator?: string(name='ComparisonOperator'),
      metricName?: string(name='MetricName'),
      evaluationCount?: string(name='EvaluationCount'),
      threshold?: string(name='Threshold'),
      period?: int32(name='Period'),
      statistics?: string(name='Statistics'),
    }
  ](name='CloudWatchTrigger'),
}

model ModifyScalingRuleResponseBody = {
  requestId?: string(name='RequestId'),
  scalingRuleId?: string(name='ScalingRuleId'),
}

model ModifyScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyScalingRuleResponseBody(name='body'),
}

async function modifyScalingRuleWithOptions(request: ModifyScalingRuleRequest, runtime: Util.RuntimeOptions): ModifyScalingRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ScalingRuleId"] = request.scalingRuleId;
  query["ClusterId"] = request.clusterId;
  query["HostGroupId"] = request.hostGroupId;
  query["RuleName"] = request.ruleName;
  query["AdjustmentType"] = request.adjustmentType;
  query["AdjustmentValue"] = request.adjustmentValue;
  query["Cooldown"] = request.cooldown;
  query["LaunchTime"] = request.launchTime;
  query["LaunchExpirationTime"] = request.launchExpirationTime;
  query["RecurrenceType"] = request.recurrenceType;
  query["RecurrenceValue"] = request.recurrenceValue;
  query["RecurrenceEndTime"] = request.recurrenceEndTime;
  query["WithGrace"] = request.withGrace;
  query["TimeoutWithGrace"] = request.timeoutWithGrace;
  query["SchedulerTrigger"] = request.schedulerTrigger;
  query["CloudWatchTrigger"] = request.cloudWatchTrigger;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyScalingRule',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyScalingRule(request: ModifyScalingRuleRequest): ModifyScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyScalingRuleWithOptions(request, runtime);
}

model ModifyScalingTaskGroupRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostGroupId?: string(name='HostGroupId'),
  minSize?: int32(name='MinSize'),
  maxSize?: int32(name='MaxSize'),
  defaultCooldown?: int32(name='DefaultCooldown'),
  activeRuleCategory?: string(name='ActiveRuleCategory'),
  withGrace?: boolean(name='WithGrace'),
  timeoutWithGrace?: long(name='TimeoutWithGrace'),
}

model ModifyScalingTaskGroupResponseBody = {
  hostGroupId?: string(name='HostGroupId'),
}

model ModifyScalingTaskGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyScalingTaskGroupResponseBody(name='body'),
}

async function modifyScalingTaskGroupWithOptions(request: ModifyScalingTaskGroupRequest, runtime: Util.RuntimeOptions): ModifyScalingTaskGroupResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["HostGroupId"] = request.hostGroupId;
  query["MinSize"] = request.minSize;
  query["MaxSize"] = request.maxSize;
  query["DefaultCooldown"] = request.defaultCooldown;
  query["ActiveRuleCategory"] = request.activeRuleCategory;
  query["WithGrace"] = request.withGrace;
  query["TimeoutWithGrace"] = request.timeoutWithGrace;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyScalingTaskGroup',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyScalingTaskGroup(request: ModifyScalingTaskGroupRequest): ModifyScalingTaskGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyScalingTaskGroupWithOptions(request, runtime);
}

model QueryEntityRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: long(name='Id'),
  name?: string(name='Name'),
  category?: string(name='Category'),
  description?: string(name='Description'),
}

model QueryEntityResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  items?: {
    item?: [ 
    {
      entityId?: string(name='EntityId'),
      entityType?: string(name='EntityType'),
      tagId?: long(name='TagId'),
    }
  ](name='Item')
  }(name='Items'),
}

model QueryEntityResponse = {
  headers: map[string]string(name='headers'),
  body: QueryEntityResponseBody(name='body'),
}

async function queryEntityWithOptions(request: QueryEntityRequest, runtime: Util.RuntimeOptions): QueryEntityResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Id"] = request.id;
  query["Name"] = request.name;
  query["Category"] = request.category;
  query["Description"] = request.description;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryEntity',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryEntity(request: QueryEntityRequest): QueryEntityResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEntityWithOptions(request, runtime);
}

model QueryTagRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  entityId?: string(name='EntityId'),
  entityType?: string(name='EntityType'),
  tagId?: long(name='TagId'),
}

model QueryTagResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  items?: {
    item?: [ 
    {
      description?: string(name='Description'),
      category?: string(name='Category'),
      name?: string(name='Name'),
    }
  ](name='Item')
  }(name='Items'),
}

model QueryTagResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTagResponseBody(name='body'),
}

async function queryTagWithOptions(request: QueryTagRequest, runtime: Util.RuntimeOptions): QueryTagResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["EntityId"] = request.entityId;
  query["EntityType"] = request.entityType;
  query["TagId"] = request.tagId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryTag',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTag(request: QueryTagRequest): QueryTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTagWithOptions(request, runtime);
}

model RefreshClusterResourcePoolRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  resourcePoolId?: long(name='ResourcePoolId'),
}

model RefreshClusterResourcePoolResponseBody = {
  workFlowInstanceId?: string(name='WorkFlowInstanceId'),
  requestId?: string(name='RequestId'),
  operationId?: string(name='OperationId'),
}

model RefreshClusterResourcePoolResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshClusterResourcePoolResponseBody(name='body'),
}

async function refreshClusterResourcePoolWithOptions(request: RefreshClusterResourcePoolRequest, runtime: Util.RuntimeOptions): RefreshClusterResourcePoolResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["ResourcePoolId"] = request.resourcePoolId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RefreshClusterResourcePool',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshClusterResourcePool(request: RefreshClusterResourcePoolRequest): RefreshClusterResourcePoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshClusterResourcePoolWithOptions(request, runtime);
}

model ReleaseClusterRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: string(name='Id'),
  forceRelease?: boolean(name='ForceRelease'),
}

model ReleaseClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseClusterResponseBody(name='body'),
}

async function releaseClusterWithOptions(request: ReleaseClusterRequest, runtime: Util.RuntimeOptions): ReleaseClusterResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Id"] = request.id;
  query["ForceRelease"] = request.forceRelease;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseCluster',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseCluster(request: ReleaseClusterRequest): ReleaseClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseClusterWithOptions(request, runtime);
}

model ReleaseClusterHostGroupRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostGroupId?: string(name='HostGroupId'),
  instanceIdList?: string(name='InstanceIdList'),
}

model ReleaseClusterHostGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseClusterHostGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseClusterHostGroupResponseBody(name='body'),
}

async function releaseClusterHostGroupWithOptions(request: ReleaseClusterHostGroupRequest, runtime: Util.RuntimeOptions): ReleaseClusterHostGroupResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["HostGroupId"] = request.hostGroupId;
  query["InstanceIdList"] = request.instanceIdList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseClusterHostGroup',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseClusterHostGroup(request: ReleaseClusterHostGroupRequest): ReleaseClusterHostGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseClusterHostGroupWithOptions(request, runtime);
}

model RemoveScalingConfigItemV2Request {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  configItemType?: string(name='ConfigItemType'),
  configItemBizId?: string(name='ConfigItemBizId'),
}

model RemoveScalingConfigItemV2ResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model RemoveScalingConfigItemV2Response = {
  headers: map[string]string(name='headers'),
  body: RemoveScalingConfigItemV2ResponseBody(name='body'),
}

async function removeScalingConfigItemV2WithOptions(request: RemoveScalingConfigItemV2Request, runtime: Util.RuntimeOptions): RemoveScalingConfigItemV2Response {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["ScalingGroupBizId"] = request.scalingGroupBizId;
  query["ConfigItemType"] = request.configItemType;
  query["ConfigItemBizId"] = request.configItemBizId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RemoveScalingConfigItemV2',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeScalingConfigItemV2(request: RemoveScalingConfigItemV2Request): RemoveScalingConfigItemV2Response {
  var runtime = new Util.RuntimeOptions{};
  return removeScalingConfigItemV2WithOptions(request, runtime);
}

model RerunFlowRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  flowInstanceId?: string(name='FlowInstanceId'),
  reRunFail?: boolean(name='ReRunFail'),
}

model RerunFlowResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model RerunFlowResponse = {
  headers: map[string]string(name='headers'),
  body: RerunFlowResponseBody(name='body'),
}

async function rerunFlowWithOptions(request: RerunFlowRequest, runtime: Util.RuntimeOptions): RerunFlowResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["FlowInstanceId"] = request.flowInstanceId;
  query["ReRunFail"] = request.reRunFail;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RerunFlow',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rerunFlow(request: RerunFlowRequest): RerunFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return rerunFlowWithOptions(request, runtime);
}

model ResizeClusterV2Request {
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  autoPayOrder?: boolean(name='AutoPayOrder'),
  vswitchId?: string(name='VswitchId'),
  isOpenPublicIp?: boolean(name='IsOpenPublicIp'),
  hostComponentInfo?: [ 
    {
      componentNameList?: [ string ](name='ComponentNameList'),
      hostName?: string(name='HostName'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='HostComponentInfo'),
  hostGroup?: [ 
    {
      sysDiskCapacity?: int32(name='SysDiskCapacity'),
      hostGroupType?: string(name='HostGroupType'),
      comment?: string(name='Comment'),
      vswitchId?: int32(name='VswitchId'),
      sysDiskType?: string(name='SysDiskType'),
      autoRenew?: boolean(name='AutoRenew'),
      chargeType?: string(name='ChargeType'),
      diskType?: string(name='DiskType'),
      hostGroupId?: string(name='HostGroupId'),
      instanceType?: string(name='InstanceType'),
      hostKeyPairName?: string(name='HostKeyPairName'),
      diskCount?: int32(name='DiskCount'),
      createType?: string(name='CreateType'),
      period?: int32(name='Period'),
      hostPassword?: string(name='HostPassword'),
      diskCapacity?: int32(name='DiskCapacity'),
      nodeCount?: int32(name='NodeCount'),
      hostGroupName?: string(name='HostGroupName'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='HostGroup'),
  promotionInfo?: [ 
    {
      promotionOptionNo?: string(name='PromotionOptionNo'),
      promotionOptionCode?: string(name='PromotionOptionCode'),
      productCode?: string(name='ProductCode'),
    }
  ](name='PromotionInfo'),
}

model ResizeClusterV2ResponseBody = {
  requestId?: string(name='RequestId'),
  clusterId?: string(name='ClusterId'),
}

model ResizeClusterV2Response = {
  headers: map[string]string(name='headers'),
  body: ResizeClusterV2ResponseBody(name='body'),
}

async function resizeClusterV2WithOptions(request: ResizeClusterV2Request, runtime: Util.RuntimeOptions): ResizeClusterV2Response {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["AutoPayOrder"] = request.autoPayOrder;
  query["VswitchId"] = request.vswitchId;
  query["IsOpenPublicIp"] = request.isOpenPublicIp;
  query["HostComponentInfo"] = request.hostComponentInfo;
  query["HostGroup"] = request.hostGroup;
  query["PromotionInfo"] = request.promotionInfo;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ResizeClusterV2',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resizeClusterV2(request: ResizeClusterV2Request): ResizeClusterV2Response {
  var runtime = new Util.RuntimeOptions{};
  return resizeClusterV2WithOptions(request, runtime);
}

model ResumeExecutionPlanSchedulerRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: string(name='Id'),
}

model ResumeExecutionPlanSchedulerResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResumeExecutionPlanSchedulerResponse = {
  headers: map[string]string(name='headers'),
  body: ResumeExecutionPlanSchedulerResponseBody(name='body'),
}

async function resumeExecutionPlanSchedulerWithOptions(request: ResumeExecutionPlanSchedulerRequest, runtime: Util.RuntimeOptions): ResumeExecutionPlanSchedulerResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Id"] = request.id;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ResumeExecutionPlanScheduler',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resumeExecutionPlanScheduler(request: ResumeExecutionPlanSchedulerRequest): ResumeExecutionPlanSchedulerResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumeExecutionPlanSchedulerWithOptions(request, runtime);
}

model ResumeFlowRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  flowInstanceId?: string(name='FlowInstanceId'),
}

model ResumeFlowResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model ResumeFlowResponse = {
  headers: map[string]string(name='headers'),
  body: ResumeFlowResponseBody(name='body'),
}

async function resumeFlowWithOptions(request: ResumeFlowRequest, runtime: Util.RuntimeOptions): ResumeFlowResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["FlowInstanceId"] = request.flowInstanceId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ResumeFlow',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resumeFlow(request: ResumeFlowRequest): ResumeFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumeFlowWithOptions(request, runtime);
}

model RetryOperationRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  operationId?: string(name='OperationId'),
}

model RetryOperationResponseBody = {
  requestId?: string(name='RequestId'),
  errMsg?: string(name='ErrMsg'),
  success?: string(name='Success'),
  errCode?: string(name='ErrCode'),
}

model RetryOperationResponse = {
  headers: map[string]string(name='headers'),
  body: RetryOperationResponseBody(name='body'),
}

async function retryOperationWithOptions(request: RetryOperationRequest, runtime: Util.RuntimeOptions): RetryOperationResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["OperationId"] = request.operationId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RetryOperation',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function retryOperation(request: RetryOperationRequest): RetryOperationResponse {
  var runtime = new Util.RuntimeOptions{};
  return retryOperationWithOptions(request, runtime);
}

model RunClusterServiceActionRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostIdList?: string(name='HostIdList'),
  serviceName?: string(name='ServiceName'),
  serviceActionName?: string(name='ServiceActionName'),
  customCommand?: string(name='CustomCommand'),
  componentNameList?: string(name='ComponentNameList'),
  comment?: string(name='Comment'),
  isRolling?: boolean(name='IsRolling'),
  executeStrategy?: string(name='ExecuteStrategy'),
  customParams?: string(name='CustomParams'),
  interval?: long(name='Interval'),
  nodeCountPerBatch?: int32(name='NodeCountPerBatch'),
  totlerateFailCount?: int32(name='TotlerateFailCount'),
  onlyRestartStaleConfigNodes?: boolean(name='OnlyRestartStaleConfigNodes'),
  turnOnMaintenanceMode?: boolean(name='TurnOnMaintenanceMode'),
  hostGroupIdList?: [ string ](name='HostGroupIdList'),
}

model RunClusterServiceActionResponseBody = {
  requestId?: string(name='RequestId'),
}

model RunClusterServiceActionResponse = {
  headers: map[string]string(name='headers'),
  body: RunClusterServiceActionResponseBody(name='body'),
}

async function runClusterServiceActionWithOptions(request: RunClusterServiceActionRequest, runtime: Util.RuntimeOptions): RunClusterServiceActionResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["HostIdList"] = request.hostIdList;
  query["ServiceName"] = request.serviceName;
  query["ServiceActionName"] = request.serviceActionName;
  query["CustomCommand"] = request.customCommand;
  query["ComponentNameList"] = request.componentNameList;
  query["Comment"] = request.comment;
  query["IsRolling"] = request.isRolling;
  query["ExecuteStrategy"] = request.executeStrategy;
  query["CustomParams"] = request.customParams;
  query["Interval"] = request.interval;
  query["NodeCountPerBatch"] = request.nodeCountPerBatch;
  query["TotlerateFailCount"] = request.totlerateFailCount;
  query["OnlyRestartStaleConfigNodes"] = request.onlyRestartStaleConfigNodes;
  query["TurnOnMaintenanceMode"] = request.turnOnMaintenanceMode;
  query["HostGroupIdList"] = request.hostGroupIdList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RunClusterServiceAction',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runClusterServiceAction(request: RunClusterServiceActionRequest): RunClusterServiceActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return runClusterServiceActionWithOptions(request, runtime);
}

model RunExecutionPlanRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: string(name='Id'),
  arguments?: map[string]any(name='Arguments'),
}

model RunExecutionPlanShrinkRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: string(name='Id'),
  argumentsShrink?: string(name='Arguments'),
}

model RunExecutionPlanResponseBody = {
  requestId?: string(name='RequestId'),
  executionPlanInstanceId?: string(name='ExecutionPlanInstanceId'),
}

model RunExecutionPlanResponse = {
  headers: map[string]string(name='headers'),
  body: RunExecutionPlanResponseBody(name='body'),
}

async function runExecutionPlanWithOptions(tmpReq: RunExecutionPlanRequest, runtime: Util.RuntimeOptions): RunExecutionPlanResponse {
  Util.validateModel(tmpReq);
  var request = new RunExecutionPlanShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.arguments)) {
    request.argumentsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.arguments, 'Arguments', 'json');
  }
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Id"] = request.id;
  query["Arguments"] = request.argumentsShrink;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RunExecutionPlan',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runExecutionPlan(request: RunExecutionPlanRequest): RunExecutionPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return runExecutionPlanWithOptions(request, runtime);
}

model RunScalingActionV2Request {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  scalingActionType?: string(name='ScalingActionType'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  actionParam?: string(name='ActionParam'),
}

model RunScalingActionV2ResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model RunScalingActionV2Response = {
  headers: map[string]string(name='headers'),
  body: RunScalingActionV2ResponseBody(name='body'),
}

async function runScalingActionV2WithOptions(request: RunScalingActionV2Request, runtime: Util.RuntimeOptions): RunScalingActionV2Response {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["ScalingActionType"] = request.scalingActionType;
  query["ScalingGroupBizId"] = request.scalingGroupBizId;
  query["ActionParam"] = request.actionParam;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RunScalingActionV2',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runScalingActionV2(request: RunScalingActionV2Request): RunScalingActionV2Response {
  var runtime = new Util.RuntimeOptions{};
  return runScalingActionV2WithOptions(request, runtime);
}

model SearchLogRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostInnerIp?: string(name='HostInnerIp'),
  hostName?: string(name='HostName'),
  logstoreName?: string(name='LogstoreName'),
  fromTimestamp?: int32(name='FromTimestamp'),
  toTimestamp?: int32(name='ToTimestamp'),
  slsQueryString?: string(name='SlsQueryString'),
  offset?: int32(name='Offset'),
  line?: int32(name='Line'),
  reverse?: boolean(name='Reverse'),
}

model SearchLogResponseBody = {
  slsLogItemList?: {
    slsLogItem?: [ 
    {
      sourceIp?: string(name='SourceIp'),
      packId?: string(name='PackId'),
      path?: string(name='Path'),
      hostName?: string(name='HostName'),
      timestamp?: int32(name='Timestamp'),
      content?: string(name='Content'),
      packMeta?: string(name='PackMeta'),
    }
  ](name='SlsLogItem')
  }(name='SlsLogItemList'),
  requestId?: string(name='RequestId'),
  completed?: boolean(name='Completed'),
}

model SearchLogResponse = {
  headers: map[string]string(name='headers'),
  body: SearchLogResponseBody(name='body'),
}

async function searchLogWithOptions(request: SearchLogRequest, runtime: Util.RuntimeOptions): SearchLogResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ClusterId"] = request.clusterId;
  query["HostInnerIp"] = request.hostInnerIp;
  query["HostName"] = request.hostName;
  query["LogstoreName"] = request.logstoreName;
  query["FromTimestamp"] = request.fromTimestamp;
  query["ToTimestamp"] = request.toTimestamp;
  query["SlsQueryString"] = request.slsQueryString;
  query["Offset"] = request.offset;
  query["Line"] = request.line;
  query["Reverse"] = request.reverse;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SearchLog',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchLog(request: SearchLogRequest): SearchLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchLogWithOptions(request, runtime);
}

model StartFlowRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  flowInstanceId?: string(name='FlowInstanceId'),
}

model StartFlowResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model StartFlowResponse = {
  headers: map[string]string(name='headers'),
  body: StartFlowResponseBody(name='body'),
}

async function startFlowWithOptions(request: StartFlowRequest, runtime: Util.RuntimeOptions): StartFlowResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["FlowInstanceId"] = request.flowInstanceId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'StartFlow',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startFlow(request: StartFlowRequest): StartFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return startFlowWithOptions(request, runtime);
}

model SubmitFlowRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  flowId?: string(name='FlowId'),
  conf?: string(name='Conf'),
}

model SubmitFlowResponseBody = {
  requestId?: string(name='RequestId'),
  id?: string(name='Id'),
}

model SubmitFlowResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFlowResponseBody(name='body'),
}

async function submitFlowWithOptions(request: SubmitFlowRequest, runtime: Util.RuntimeOptions): SubmitFlowResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["FlowId"] = request.flowId;
  query["Conf"] = request.conf;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitFlow',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitFlow(request: SubmitFlowRequest): SubmitFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFlowWithOptions(request, runtime);
}

model SubmitFlowJobRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  jobId?: string(name='JobId'),
  jobInstanceId?: string(name='JobInstanceId'),
  clusterId?: string(name='ClusterId'),
  hostName?: string(name='HostName'),
  namespace?: string(name='Namespace'),
  conf?: string(name='Conf'),
}

model SubmitFlowJobResponseBody = {
  requestId?: string(name='RequestId'),
  id?: string(name='Id'),
}

model SubmitFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFlowJobResponseBody(name='body'),
}

async function submitFlowJobWithOptions(request: SubmitFlowJobRequest, runtime: Util.RuntimeOptions): SubmitFlowJobResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["JobId"] = request.jobId;
  query["JobInstanceId"] = request.jobInstanceId;
  query["ClusterId"] = request.clusterId;
  query["HostName"] = request.hostName;
  query["Namespace"] = request.namespace;
  query["Conf"] = request.conf;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitFlowJob',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitFlowJob(request: SubmitFlowJobRequest): SubmitFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFlowJobWithOptions(request, runtime);
}

model SuspendExecutionPlanSchedulerRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: string(name='Id'),
}

model SuspendExecutionPlanSchedulerResponseBody = {
  requestId?: string(name='RequestId'),
}

model SuspendExecutionPlanSchedulerResponse = {
  headers: map[string]string(name='headers'),
  body: SuspendExecutionPlanSchedulerResponseBody(name='body'),
}

async function suspendExecutionPlanSchedulerWithOptions(request: SuspendExecutionPlanSchedulerRequest, runtime: Util.RuntimeOptions): SuspendExecutionPlanSchedulerResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Id"] = request.id;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SuspendExecutionPlanScheduler',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function suspendExecutionPlanScheduler(request: SuspendExecutionPlanSchedulerRequest): SuspendExecutionPlanSchedulerResponse {
  var runtime = new Util.RuntimeOptions{};
  return suspendExecutionPlanSchedulerWithOptions(request, runtime);
}

model SuspendFlowRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  flowInstanceId?: string(name='FlowInstanceId'),
}

model SuspendFlowResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model SuspendFlowResponse = {
  headers: map[string]string(name='headers'),
  body: SuspendFlowResponseBody(name='body'),
}

async function suspendFlowWithOptions(request: SuspendFlowRequest, runtime: Util.RuntimeOptions): SuspendFlowResponse {
  Util.validateModel(request);
  var query = {};
  query["RegionId"] = request.regionId;
  query["ProjectId"] = request.projectId;
  query["FlowInstanceId"] = request.flowInstanceId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SuspendFlow',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function suspendFlow(request: SuspendFlowRequest): SuspendFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return suspendFlowWithOptions(request, runtime);
}

model TagResourcesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
  resourceId?: [ string ](name='ResourceId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceType"] = request.resourceType;
  query["ResourceId"] = request.resourceId;
  query["Tag"] = request.tag;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UninstallLibrariesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  libraryBizId?: string(name='LibraryBizId'),
  clusterBizIdList?: [ string ](name='ClusterBizIdList'),
}

model UninstallLibrariesResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model UninstallLibrariesResponse = {
  headers: map[string]string(name='headers'),
  body: UninstallLibrariesResponseBody(name='body'),
}

async function uninstallLibrariesWithOptions(request: UninstallLibrariesRequest, runtime: Util.RuntimeOptions): UninstallLibrariesResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["LibraryBizId"] = request.libraryBizId;
  query["ClusterBizIdList"] = request.clusterBizIdList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UninstallLibraries',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uninstallLibraries(request: UninstallLibrariesRequest): UninstallLibrariesResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallLibrariesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
  all?: boolean(name='All'),
  resourceId?: [ string ](name='ResourceId'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["ResourceType"] = request.resourceType;
  query["All"] = request.all;
  query["ResourceId"] = request.resourceId;
  query["TagKey"] = request.tagKey;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateDataSourceRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  conf?: string(name='Conf'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model UpdateDataSourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDataSourceResponseBody(name='body'),
}

async function updateDataSourceWithOptions(request: UpdateDataSourceRequest, runtime: Util.RuntimeOptions): UpdateDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Id"] = request.id;
  query["Name"] = request.name;
  query["Description"] = request.description;
  query["Conf"] = request.conf;
  query["ResourceGroupId"] = request.resourceGroupId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDataSource',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDataSource(request: UpdateDataSourceRequest): UpdateDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDataSourceWithOptions(request, runtime);
}

model UpdateLibraryInstallTaskStatusRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  taskBizId?: string(name='TaskBizId'),
  status?: string(name='Status'),
}

model UpdateLibraryInstallTaskStatusResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model UpdateLibraryInstallTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateLibraryInstallTaskStatusResponseBody(name='body'),
}

async function updateLibraryInstallTaskStatusWithOptions(request: UpdateLibraryInstallTaskStatusRequest, runtime: Util.RuntimeOptions): UpdateLibraryInstallTaskStatusResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["TaskBizId"] = request.taskBizId;
  query["Status"] = request.status;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLibraryInstallTaskStatus',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLibraryInstallTaskStatus(request: UpdateLibraryInstallTaskStatusRequest): UpdateLibraryInstallTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLibraryInstallTaskStatusWithOptions(request, runtime);
}

model UpdateTagRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: long(name='Id'),
  name?: string(name='Name'),
  category?: string(name='Category'),
  description?: string(name='Description'),
}

model UpdateTagResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
}

model UpdateTagResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTagResponseBody(name='body'),
}

async function updateTagWithOptions(request: UpdateTagRequest, runtime: Util.RuntimeOptions): UpdateTagResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["Id"] = request.id;
  query["Name"] = request.name;
  query["Category"] = request.category;
  query["Description"] = request.description;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTag',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTag(request: UpdateTagRequest): UpdateTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTagWithOptions(request, runtime);
}

model UpdateUserRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  aliyunUserId?: string(name='AliyunUserId'),
  userName?: string(name='UserName'),
  userType?: string(name='UserType'),
  status?: string(name='Status'),
  description?: string(name='Description'),
  roleIdList?: [ integer ](name='RoleIdList'),
  groupIdList?: [ integer ](name='GroupIdList'),
  userAccountParamList?: [ 
    {
      authType?: string(name='AuthType'),
      accountPassword?: string(name='AccountPassword'),
      accountType?: string(name='AccountType'),
    }
  ](name='UserAccountParamList'),
}

model UpdateUserResponseBody = {
  requestId?: string(name='RequestId'),
  paging?: boolean(name='Paging'),
  data?: boolean(name='Data'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserResponseBody(name='body'),
}

async function updateUserWithOptions(request: UpdateUserRequest, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  var query = {};
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RegionId"] = request.regionId;
  query["AliyunUserId"] = request.aliyunUserId;
  query["UserName"] = request.userName;
  query["UserType"] = request.userType;
  query["Status"] = request.status;
  query["Description"] = request.description;
  query["RoleIdList"] = request.roleIdList;
  query["GroupIdList"] = request.groupIdList;
  query["UserAccountParamList"] = request.userAccountParamList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUser',
    version = '2016-04-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserWithOptions(request, runtime);
}

