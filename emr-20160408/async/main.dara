/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Emr';
  @version = '2016-04-08';
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'emr.aliyuncs.com',
    cn-hangzhou = 'emr.aliyuncs.com',
    cn-shanghai = 'emr.aliyuncs.com',
    cn-shenzhen = 'emr.aliyuncs.com',
    ap-southeast-1 = 'emr.aliyuncs.com',
    us-west-1 = 'emr.aliyuncs.com',
    cn-hangzhou-finance = 'emr.aliyuncs.com',
    cn-shenzhen-finance-1 = 'emr.aliyuncs.com',
    cn-shanghai-finance-1 = 'emr.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model AddClusterServiceRequest {
  clusterId: string(name='ClusterId', position='Query'),
  comment?: string(name='Comment', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  service: [ 
    {
      serviceName: string(name='ServiceName'),
      serviceVersion?: string(name='ServiceVersion'),
    }
  ](name='Service', position='Query'),
}

model AddClusterServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddClusterServiceResponse = {
  headers: map[string]string(name='headers'),
  body: AddClusterServiceResponseBody(name='body'),
}

async function addClusterService(request: AddClusterServiceRequest): AddClusterServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddClusterService', 'POST', '/', 'json', false, 'json', request);
}

model AddScalingConfigItemV2Request {
  configItemInformation: string(name='ConfigItemInformation', position='Query'),
  configItemType: string(name='ConfigItemType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scalingGroupBizId: string(name='ScalingGroupBizId', position='Query'),
}

model AddScalingConfigItemV2ResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddScalingConfigItemV2Response = {
  headers: map[string]string(name='headers'),
  body: AddScalingConfigItemV2ResponseBody(name='body'),
}

async function addScalingConfigItemV2(request: AddScalingConfigItemV2Request): AddScalingConfigItemV2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddScalingConfigItemV2', 'POST', '/', 'json', false, 'json', request);
}

model AuthorizeSecurityGroupRequest {
  bizContent?: string(name='BizContent', position='Query'),
  bizType: string(name='BizType', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AuthorizeSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AuthorizeSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeSecurityGroupResponseBody(name='body'),
}

async function authorizeSecurityGroup(request: AuthorizeSecurityGroupRequest): AuthorizeSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AuthorizeSecurityGroup', 'POST', '/', 'json', false, 'json', request);
}

model CancelOrderRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CancelOrderResponseBody = {
  requestId?: string(name='RequestId'),
  clusterId?: string(name='clusterId'),
}

model CancelOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CancelOrderResponseBody(name='body'),
}

async function cancelOrder(request: CancelOrderRequest): CancelOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelOrder', 'POST', '/', 'json', false, 'json', request);
}

model CloneFlowRequest {
  id: string(name='Id', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CloneFlowResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CloneFlowResponse = {
  headers: map[string]string(name='headers'),
  body: CloneFlowResponseBody(name='body'),
}

async function cloneFlow(request: CloneFlowRequest): CloneFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CloneFlow', 'POST', '/', 'json', false, 'json', request);
}

model CloneFlowJobRequest {
  id: string(name='Id', position='Query'),
  name?: string(name='Name', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CloneFlowJobResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CloneFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: CloneFlowJobResponseBody(name='body'),
}

async function cloneFlowJob(request: CloneFlowJobRequest): CloneFlowJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CloneFlowJob', 'POST', '/', 'json', false, 'json', request);
}

model CreateBackupRequest {
  backupPlanId: string(name='BackupPlanId', position='Query'),
  metadataType?: string(name='MetadataType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateBackupResponseBody = {
  bizId?: string(name='BizId'),
  clusterBizId?: string(name='ClusterBizId'),
  dataSourceId?: long(name='DataSourceId'),
  ecmTaskId?: long(name='EcmTaskId'),
  endTime?: long(name='EndTime'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  hostName?: string(name='HostName'),
  requestId?: string(name='RequestId'),
  startTime?: long(name='StartTime'),
  taskDetail?: string(name='TaskDetail'),
  taskProcess?: int32(name='TaskProcess'),
  taskResultDetail?: string(name='TaskResultDetail'),
  taskStatus?: string(name='TaskStatus'),
  taskType?: string(name='TaskType'),
  triggerType?: string(name='TriggerType'),
  triggerUser?: string(name='TriggerUser'),
}

model CreateBackupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBackupResponseBody(name='body'),
}

async function createBackup(request: CreateBackupRequest): CreateBackupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBackup', 'POST', '/', 'json', false, 'json', request);
}

model CreateBackupPlanRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  rootPath?: string(name='RootPath', position='Query'),
}

model CreateBackupPlanResponseBody = {
  clusterId?: string(name='ClusterId'),
  description?: string(name='Description'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  rootPath?: string(name='RootPath'),
}

model CreateBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBackupPlanResponseBody(name='body'),
}

async function createBackupPlan(request: CreateBackupPlanRequest): CreateBackupPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBackupPlan', 'POST', '/', 'json', false, 'json', request);
}

model CreateClusterBootstrapActionRequest {
  bootstrapAction?: [ 
    {
      arg?: string(name='Arg'),
      executionFailStrategy?: string(name='ExecutionFailStrategy'),
      executionMoment?: string(name='ExecutionMoment'),
      executionTarget?: string(name='ExecutionTarget'),
      name: string(name='Name'),
      path: string(name='Path'),
    }
  ](name='BootstrapAction', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateClusterBootstrapActionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateClusterBootstrapActionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterBootstrapActionResponseBody(name='body'),
}

async function createClusterBootstrapAction(request: CreateClusterBootstrapActionRequest): CreateClusterBootstrapActionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateClusterBootstrapAction', 'POST', '/', 'json', false, 'json', request);
}

model CreateClusterHostGroupRequest {
  clusterId: string(name='ClusterId', position='Query'),
  comment?: string(name='Comment', position='Query'),
  hostGroupName: string(name='HostGroupName', position='Query'),
  hostGroupParams?: string(name='HostGroupParams', position='Query'),
  hostGroupType: string(name='HostGroupType', position='Query'),
  payType?: string(name='PayType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  vswitchId?: string(name='VswitchId', position='Query'),
}

model CreateClusterHostGroupResponseBody = {
  clusterId?: string(name='ClusterId'),
  hostGroupId?: string(name='HostGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateClusterHostGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterHostGroupResponseBody(name='body'),
}

async function createClusterHostGroup(request: CreateClusterHostGroupRequest): CreateClusterHostGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateClusterHostGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateClusterTemplateRequest {
  autoRenew?: boolean(name='AutoRenew', position='Query'),
  bootstrapAction?: [ 
    {
      arg?: string(name='Arg'),
      executionFailStrategy?: string(name='ExecutionFailStrategy'),
      executionMoment?: string(name='ExecutionMoment'),
      executionTarget?: string(name='ExecutionTarget'),
      name: string(name='Name'),
      path: string(name='Path'),
    }
  ](name='BootstrapAction', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  clusterType: string(name='ClusterType', position='Query'),
  config?: [ 
    {
      configKey: string(name='ConfigKey'),
      configValue: string(name='ConfigValue'),
      encrypt?: string(name='Encrypt'),
      fileName: string(name='FileName'),
      replace?: string(name='Replace'),
      serviceName: string(name='ServiceName'),
    }
  ](name='Config', position='Query'),
  configurations?: string(name='Configurations', position='Query'),
  depositType?: string(name='DepositType', position='Query'),
  easEnable?: boolean(name='EasEnable', position='Query'),
  emrVer: string(name='EmrVer', position='Query'),
  highAvailabilityEnable?: boolean(name='HighAvailabilityEnable', position='Query'),
  hostGroup: [ 
    {
      autoRenew?: boolean(name='AutoRenew'),
      chargeType?: string(name='ChargeType'),
      clusterId?: string(name='ClusterId'),
      comment?: string(name='Comment'),
      createType?: string(name='CreateType'),
      diskCapacity: int32(name='DiskCapacity', minimum=40, maximum=20000),
      diskCount: int32(name='DiskCount', minimum=1, maximum=4),
      diskType: string(name='DiskType'),
      hostGroupId?: string(name='HostGroupId'),
      hostGroupName: string(name='HostGroupName'),
      hostGroupType: string(name='HostGroupType'),
      instanceType: string(name='InstanceType'),
      multiInstanceTypes?: string(name='MultiInstanceTypes'),
      nodeCount: int32(name='NodeCount', minimum=2, maximum=1000),
      period?: int32(name='Period'),
      privatePoolOptionsId?: string(name='PrivatePoolOptionsId'),
      privatePoolOptionsMatchCriteria?: string(name='PrivatePoolOptionsMatchCriteria'),
      sysDiskCapacity: int32(name='SysDiskCapacity', minimum=40, maximum=500),
      sysDiskType: string(name='SysDiskType'),
      vSwitchId?: string(name='VSwitchId'),
    }
  ](name='HostGroup', position='Query'),
  initCustomHiveMetaDb?: boolean(name='InitCustomHiveMetaDb', position='Query'),
  instanceGeneration?: string(name='InstanceGeneration', position='Query'),
  ioOptimized?: boolean(name='IoOptimized', position='Query'),
  isOpenPublicIp?: boolean(name='IsOpenPublicIp', position='Query'),
  keyPairName?: string(name='KeyPairName', position='Query'),
  logPath?: string(name='LogPath', position='Query'),
  machineType?: string(name='MachineType', position='Query'),
  masterPwd?: string(name='MasterPwd', position='Query'),
  metaStoreConf?: string(name='MetaStoreConf', position='Query'),
  metaStoreType?: string(name='MetaStoreType', position='Query'),
  netType?: string(name='NetType', position='Query'),
  optionSoftWareList?: [ string ](name='OptionSoftWareList', position='Query'),
  period?: int32(name='Period', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  securityGroupName?: string(name='SecurityGroupName', position='Query'),
  sshEnable?: boolean(name='SshEnable', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
  useCustomHiveMetaDb?: boolean(name='UseCustomHiveMetaDb', position='Query'),
  useLocalMetaDb?: boolean(name='UseLocalMetaDb', position='Query'),
  userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model CreateClusterTemplateResponseBody = {
  clusterTemplateId?: string(name='ClusterTemplateId'),
  requestId?: string(name='RequestId'),
}

model CreateClusterTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterTemplateResponseBody(name='body'),
}

async function createClusterTemplate(request: CreateClusterTemplateRequest): CreateClusterTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateClusterTemplate', 'POST', '/', 'json', false, 'json', request);
}

model CreateClusterV2Request {
  authorizeContent?: string(name='AuthorizeContent', position='Query'),
  autoPayOrder?: boolean(name='AutoPayOrder', position='Query'),
  autoRenew?: boolean(name='AutoRenew', position='Query'),
  bootstrapAction?: [ 
    {
      arg?: string(name='Arg'),
      executionFailStrategy?: string(name='ExecutionFailStrategy'),
      executionMoment?: string(name='ExecutionMoment'),
      executionTarget?: string(name='ExecutionTarget'),
      name: string(name='Name'),
      path: string(name='Path'),
    }
  ](name='BootstrapAction', position='Query'),
  chargeType?: string(name='ChargeType', position='Query'),
  clickHouseConf?: string(name='ClickHouseConf', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  clusterType: string(name='ClusterType', position='Query'),
  config?: [ 
    {
      configKey: string(name='ConfigKey'),
      configValue: string(name='ConfigValue'),
      encrypt?: string(name='Encrypt'),
      fileName: string(name='FileName'),
      replace?: string(name='Replace'),
      serviceName: string(name='ServiceName'),
    }
  ](name='Config', position='Query'),
  configurations?: string(name='Configurations', position='Query'),
  depositType?: string(name='DepositType', position='Query'),
  easEnable?: boolean(name='EasEnable', position='Query'),
  emrVer: string(name='EmrVer', position='Query'),
  extraAttributes?: string(name='ExtraAttributes', position='Query'),
  highAvailabilityEnable?: boolean(name='HighAvailabilityEnable', position='Query'),
  hostComponentInfo?: [ 
    {
      componentNameList?: [ string ](name='ComponentNameList'),
      hostName?: string(name='HostName'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='HostComponentInfo', position='Query'),
  hostGroup: [ 
    {
      autoRenew?: boolean(name='AutoRenew'),
      chargeType?: string(name='ChargeType'),
      clusterId?: string(name='ClusterId'),
      comment?: string(name='Comment'),
      createType?: string(name='CreateType'),
      diskCapacity: int32(name='DiskCapacity', minimum=40, maximum=20000),
      diskCount: int32(name='DiskCount', minimum=1, maximum=4),
      diskType: string(name='DiskType'),
      gpuDriver?: string(name='GpuDriver'),
      hostGroupId?: string(name='HostGroupId'),
      hostGroupName: string(name='HostGroupName'),
      hostGroupType: string(name='HostGroupType'),
      instanceType: string(name='InstanceType'),
      nodeCount: int32(name='NodeCount', minimum=2, maximum=1000),
      period?: int32(name='Period'),
      privatePoolOptionsId?: string(name='PrivatePoolOptionsId'),
      privatePoolOptionsMatchCriteria?: string(name='PrivatePoolOptionsMatchCriteria'),
      sysDiskCapacity: int32(name='SysDiskCapacity', minimum=40, maximum=500),
      sysDiskType: string(name='SysDiskType'),
      vSwitchId?: string(name='VSwitchId'),
    }
  ](name='HostGroup', position='Query'),
  initCustomHiveMetaDB?: boolean(name='InitCustomHiveMetaDB', position='Query'),
  instanceGeneration?: string(name='InstanceGeneration', position='Query'),
  ioOptimized?: boolean(name='IoOptimized', position='Query'),
  isOpenPublicIp?: boolean(name='IsOpenPublicIp', position='Query'),
  keyPairName?: string(name='KeyPairName', position='Query'),
  logPath?: string(name='LogPath', position='Query'),
  machineType?: string(name='MachineType', position='Query'),
  masterPwd?: string(name='MasterPwd', position='Query'),
  metaStoreConf?: string(name='MetaStoreConf', position='Query'),
  metaStoreType?: string(name='MetaStoreType', position='Query'),
  name: string(name='Name', position='Query'),
  netType?: string(name='NetType', position='Query'),
  optionSoftWareList?: [ string ](name='OptionSoftWareList', position='Query'),
  period?: int32(name='Period', position='Query'),
  promotionInfo?: [ 
    {
      productCode?: string(name='ProductCode'),
      promotionOptionCode?: string(name='PromotionOptionCode'),
      promotionOptionNo?: string(name='PromotionOptionNo'),
    }
  ](name='PromotionInfo', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  relatedClusterId?: string(name='RelatedClusterId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  securityGroupName?: string(name='SecurityGroupName', position='Query'),
  serviceInfo?: [ 
    {
      serviceName?: string(name='ServiceName'),
      serviceVersion?: string(name='ServiceVersion'),
    }
  ](name='ServiceInfo', position='Query'),
  sshEnable?: boolean(name='SshEnable', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  useCustomHiveMetaDB?: boolean(name='UseCustomHiveMetaDB', position='Query'),
  useLocalMetaDb?: boolean(name='UseLocalMetaDb', position='Query'),
  userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole', position='Query'),
  userInfo?: [ 
    {
      password: string(name='Password'),
      userId: string(name='UserId'),
      userName: string(name='UserName'),
    }
  ](name='UserInfo', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  whiteListType?: string(name='WhiteListType', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model CreateClusterV2ResponseBody = {
  clusterId?: string(name='ClusterId'),
  coreOrderId?: string(name='CoreOrderId'),
  emrOrderId?: string(name='EmrOrderId'),
  masterOrderId?: string(name='MasterOrderId'),
  requestId?: string(name='RequestId'),
}

model CreateClusterV2Response = {
  headers: map[string]string(name='headers'),
  body: CreateClusterV2ResponseBody(name='body'),
}

async function createClusterV2(request: CreateClusterV2Request): CreateClusterV2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateClusterV2', 'POST', '/', 'json', false, 'json', request);
}

model CreateClusterWithTemplateRequest {
  clusterName?: string(name='ClusterName', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  templateBizId: string(name='TemplateBizId', position='Query'),
  uniqueTag?: string(name='UniqueTag', position='Query'),
}

model CreateClusterWithTemplateResponseBody = {
  clusterId?: string(name='ClusterId'),
  coreOrderId?: string(name='CoreOrderId'),
  emrOrderId?: string(name='EmrOrderId'),
  masterOrderId?: string(name='MasterOrderId'),
  requestId?: string(name='RequestId'),
}

model CreateClusterWithTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterWithTemplateResponseBody(name='body'),
}

async function createClusterWithTemplate(request: CreateClusterWithTemplateRequest): CreateClusterWithTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateClusterWithTemplate', 'POST', '/', 'json', false, 'json', request);
}

model CreateDataSourceRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  conf?: string(name='Conf', position='Query'),
  description?: string(name='Description', position='Query'),
  name: string(name='Name', position='Query'),
  navParentId?: string(name='NavParentId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sourceType: string(name='SourceType', position='Query'),
}

model CreateDataSourceResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataSourceResponseBody(name='body'),
}

async function createDataSource(request: CreateDataSourceRequest): CreateDataSourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDataSource', 'POST', '/', 'json', false, 'json', request);
}

model CreateExecutionPlanRequest {
  bootstrapAction?: [ 
    {
      arg?: string(name='Arg'),
      executionFailStrategy?: string(name='ExecutionFailStrategy'),
      executionMoment?: string(name='ExecutionMoment'),
      executionTarget?: string(name='ExecutionTarget'),
      name: string(name='Name'),
      path: string(name='Path'),
    }
  ](name='BootstrapAction', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  clusterName?: string(name='ClusterName', position='Query'),
  clusterType?: string(name='ClusterType', position='Query'),
  config?: [ 
    {
      configKey: string(name='ConfigKey'),
      configValue: string(name='ConfigValue'),
      encrypt?: string(name='Encrypt'),
      fileName: string(name='FileName'),
      replace?: string(name='Replace'),
      serviceName: string(name='ServiceName'),
    }
  ](name='Config', position='Query'),
  configurations?: string(name='Configurations', position='Query'),
  createClusterOnDemand?: boolean(name='CreateClusterOnDemand', position='Query'),
  dayOfMonth?: string(name='DayOfMonth', position='Query'),
  dayOfWeek?: string(name='DayOfWeek', position='Query'),
  easEnable?: boolean(name='EasEnable', position='Query'),
  ecsOrder?: [ 
    {
      diskCapacity: int32(name='DiskCapacity', minimum=40, maximum=2000),
      diskCount: int32(name='DiskCount', minimum=1, maximum=4),
      diskType: string(name='DiskType'),
      index?: int32(name='Index'),
      instanceType: string(name='InstanceType'),
      nodeCount: int32(name='NodeCount', minimum=2, maximum=50),
      nodeType: string(name='NodeType'),
    }
  ](name='EcsOrder', position='Query'),
  emrVer?: string(name='EmrVer', position='Query'),
  highAvailabilityEnable?: boolean(name='HighAvailabilityEnable', position='Query'),
  initCustomHiveMetaDB?: boolean(name='InitCustomHiveMetaDB', position='Query'),
  instanceGeneration?: string(name='InstanceGeneration', position='Query'),
  ioOptimized?: boolean(name='IoOptimized', position='Query'),
  isOpenPublicIp?: boolean(name='IsOpenPublicIp', position='Query'),
  jobIdList: [ string ](name='JobIdList', position='Query'),
  logEnable?: boolean(name='LogEnable', position='Query'),
  logPath?: string(name='LogPath', position='Query'),
  name: string(name='Name', position='Query'),
  netType?: string(name='NetType', position='Query'),
  optionSoftWareList?: [ string ](name='OptionSoftWareList', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  startTime?: long(name='StartTime', minimum=1, position='Query'),
  strategy: string(name='Strategy', position='Query'),
  timeInterval?: int32(name='TimeInterval', minimum=1, position='Query'),
  timeUnit?: string(name='TimeUnit', position='Query'),
  useCustomHiveMetaDB?: boolean(name='UseCustomHiveMetaDB', position='Query'),
  useLocalMetaDb?: boolean(name='UseLocalMetaDb', position='Query'),
  userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  workflowDefinition?: string(name='WorkflowDefinition', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model CreateExecutionPlanResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateExecutionPlanResponse = {
  headers: map[string]string(name='headers'),
  body: CreateExecutionPlanResponseBody(name='body'),
}

async function createExecutionPlan(request: CreateExecutionPlanRequest): CreateExecutionPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateExecutionPlan', 'POST', '/', 'json', false, 'json', request);
}

model CreateFlowRequest {
  alertConf?: string(name='AlertConf', position='Query'),
  alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId', position='Query'),
  alertUserGroupBizId?: string(name='AlertUserGroupBizId', position='Query'),
  application?: string(name='Application', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  createCluster?: boolean(name='CreateCluster', position='Query'),
  cronExpr?: string(name='CronExpr', position='Query'),
  description: string(name='Description', position='Query'),
  endSchedule?: long(name='EndSchedule', position='Query'),
  hostName?: string(name='HostName', position='Query'),
  lifecycle?: string(name='Lifecycle', position='Query'),
  logArchiveLocation?: string(name='LogArchiveLocation', position='Query'),
  name: string(name='Name', position='Query'),
  namespace?: string(name='Namespace', position='Query'),
  parentCategory?: string(name='ParentCategory', position='Query'),
  parentFlowList?: string(name='ParentFlowList', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  startSchedule?: long(name='StartSchedule', position='Query'),
}

model CreateFlowResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateFlowResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowResponseBody(name='body'),
}

async function createFlow(request: CreateFlowRequest): CreateFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFlow', 'POST', '/', 'json', false, 'json', request);
}

model CreateFlowCategoryRequest {
  name: string(name='Name', position='Query'),
  parentId?: string(name='ParentId', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
}

model CreateFlowCategoryResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateFlowCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowCategoryResponseBody(name='body'),
}

async function createFlowCategory(request: CreateFlowCategoryRequest): CreateFlowCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFlowCategory', 'POST', '/', 'json', false, 'json', request);
}

model CreateFlowForWebRequest {
  alertConf?: string(name='AlertConf', position='Query'),
  alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId', position='Query'),
  alertUserGroupBizId?: string(name='AlertUserGroupBizId', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  createCluster: boolean(name='CreateCluster', position='Query'),
  cronExpr?: string(name='CronExpr', position='Query'),
  description: string(name='Description', position='Query'),
  endSchedule?: long(name='EndSchedule', position='Query'),
  graph?: string(name='Graph', position='Query'),
  hostName?: string(name='HostName', position='Query'),
  lifecycle?: string(name='Lifecycle', position='Query'),
  logArchiveLocation?: string(name='LogArchiveLocation', position='Query'),
  name: string(name='Name', position='Query'),
  namespace?: string(name='Namespace', position='Query'),
  parentCategory?: string(name='ParentCategory', position='Query'),
  parentFlowList?: string(name='ParentFlowList', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  startSchedule?: long(name='StartSchedule', position='Query'),
}

model CreateFlowForWebResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateFlowForWebResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowForWebResponseBody(name='body'),
}

async function createFlowForWeb(request: CreateFlowForWebRequest): CreateFlowForWebResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFlowForWeb', 'POST', '/', 'json', false, 'json', request);
}

model CreateFlowJobRequest {
  adhoc?: boolean(name='Adhoc', position='Query'),
  alertConf?: string(name='AlertConf', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  customVariables?: string(name='CustomVariables', position='Body'),
  description: string(name='Description', position='Body'),
  envConf?: string(name='EnvConf', position='Body'),
  failAct?: string(name='FailAct', position='Query'),
  maxRetry?: int32(name='MaxRetry', position='Query'),
  maxRunningTimeSec?: long(name='MaxRunningTimeSec', position='Query'),
  mode?: string(name='Mode', position='Query'),
  monitorConf?: string(name='MonitorConf', position='Body'),
  name: string(name='Name', position='Query'),
  paramConf?: string(name='ParamConf', position='Body'),
  params?: string(name='Params', position='Body'),
  parentCategory?: string(name='ParentCategory', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceList?: [ 
    {
      alias?: string(name='Alias'),
      path: string(name='Path'),
    }
  ](name='ResourceList', position='Body'),
  retryInterval?: long(name='RetryInterval', position='Query'),
  retryPolicy?: string(name='RetryPolicy', position='Query'),
  runConf?: string(name='RunConf', position='Body'),
  type: string(name='Type', position='Query'),
}

model CreateFlowJobResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowJobResponseBody(name='body'),
}

async function createFlowJob(request: CreateFlowJobRequest): CreateFlowJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFlowJob', 'POST', '/', 'json', true, 'form', request);
}

model CreateFlowProjectRequest {
  description: string(name='Description', position='Query'),
  name: string(name='Name', position='Query'),
  productType?: string(name='ProductType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
}

model CreateFlowProjectResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowProjectResponseBody(name='body'),
}

async function createFlowProject(request: CreateFlowProjectRequest): CreateFlowProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFlowProject', 'POST', '/', 'json', false, 'json', request);
}

model CreateFlowProjectClusterSettingRequest {
  clusterId: string(name='ClusterId', position='Query'),
  defaultQueue?: string(name='DefaultQueue', position='Query'),
  defaultUser?: string(name='DefaultUser', position='Query'),
  hostList?: [ string ](name='HostList', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  queueList?: [ string ](name='QueueList', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  userList?: [ string ](name='UserList', position='Query'),
}

model CreateFlowProjectClusterSettingResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateFlowProjectClusterSettingResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowProjectClusterSettingResponseBody(name='body'),
}

async function createFlowProjectClusterSetting(request: CreateFlowProjectClusterSettingRequest): CreateFlowProjectClusterSettingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFlowProjectClusterSetting', 'POST', '/', 'json', false, 'json', request);
}

model CreateFlowProjectUserRequest {
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  user: [ 
    {
      userId: string(name='UserId'),
      userName: string(name='UserName'),
    }
  ](name='User', position='Query'),
}

model CreateFlowProjectUserResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateFlowProjectUserResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowProjectUserResponseBody(name='body'),
}

async function createFlowProjectUser(request: CreateFlowProjectUserRequest): CreateFlowProjectUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFlowProjectUser', 'POST', '/', 'json', false, 'json', request);
}

model CreateJobRequest {
  failAct: string(name='FailAct', position='Query'),
  maxRetry?: int32(name='MaxRetry', position='Query'),
  name: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  retryInterval?: int32(name='RetryInterval', position='Query'),
  runParameter: string(name='RunParameter', position='Query'),
  type: string(name='Type', position='Query'),
}

model CreateJobResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateJobResponseBody(name='body'),
}

async function createJob(request: CreateJobRequest): CreateJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateJob', 'POST', '/', 'json', false, 'json', request);
}

model CreateLibraryRequest {
  libraryVersion?: string(name='LibraryVersion', position='Query'),
  name?: string(name='Name', position='Query'),
  properties?: string(name='Properties', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scope?: string(name='Scope', position='Query'),
  sourceLocation?: string(name='SourceLocation', position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
  type?: string(name='Type', position='Query'),
}

model CreateLibraryResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateLibraryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLibraryResponseBody(name='body'),
}

async function createLibrary(request: CreateLibraryRequest): CreateLibraryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLibrary', 'POST', '/', 'json', false, 'json', request);
}

model CreateMetaTablePreviewTaskRequest {
  clusterId: string(name='ClusterId', position='Query'),
  databaseId: string(name='DatabaseId', position='Query'),
  password?: string(name='Password', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tableId: string(name='TableId', position='Query'),
  user?: string(name='User', position='Query'),
}

model CreateMetaTablePreviewTaskResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateMetaTablePreviewTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMetaTablePreviewTaskResponseBody(name='body'),
}

async function createMetaTablePreviewTask(request: CreateMetaTablePreviewTaskRequest): CreateMetaTablePreviewTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMetaTablePreviewTask', 'POST', '/', 'json', false, 'json', request);
}

model CreateResourcePoolRequest {
  active: boolean(name='Active', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  config?: [ 
    {
      category: string(name='Category'),
      configKey: string(name='ConfigKey'),
      configValue: string(name='ConfigValue'),
      note?: string(name='Note'),
      targetId: string(name='TargetId'),
      configType: string(name='configType'),
    }
  ](name='Config', position='Query'),
  name: string(name='Name', position='Query'),
  note?: string(name='Note', position='Query'),
  poolType: string(name='PoolType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  yarnSiteConfig?: string(name='YarnSiteConfig', position='Query'),
}

model CreateResourcePoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateResourcePoolResponse = {
  headers: map[string]string(name='headers'),
  body: CreateResourcePoolResponseBody(name='body'),
}

async function createResourcePool(request: CreateResourcePoolRequest): CreateResourcePoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateResourcePool', 'POST', '/', 'json', false, 'json', request);
}

model CreateResourceQueueRequest {
  clusterId: string(name='ClusterId', position='Query'),
  config?: [ 
    {
      category: string(name='Category'),
      configKey: string(name='ConfigKey'),
      configValue: string(name='ConfigValue'),
      note?: string(name='Note'),
    }
  ](name='Config', position='Query'),
  leaf?: boolean(name='Leaf', position='Query'),
  name: string(name='Name', position='Query'),
  parentQueueId?: long(name='ParentQueueId', position='Query'),
  qualifiedName?: string(name='QualifiedName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourcePoolId: long(name='ResourcePoolId', position='Query'),
}

model CreateResourceQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateResourceQueueResponse = {
  headers: map[string]string(name='headers'),
  body: CreateResourceQueueResponseBody(name='body'),
}

async function createResourceQueue(request: CreateResourceQueueRequest): CreateResourceQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateResourceQueue', 'POST', '/', 'json', false, 'json', request);
}

model CreateScalingGroupV2Request {
  description: string(name='Description', position='Query'),
  hostGroupId: string(name='HostGroupId', position='Query'),
  name: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateScalingGroupV2ResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateScalingGroupV2Response = {
  headers: map[string]string(name='headers'),
  body: CreateScalingGroupV2ResponseBody(name='body'),
}

async function createScalingGroupV2(request: CreateScalingGroupV2Request): CreateScalingGroupV2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateScalingGroupV2', 'POST', '/', 'json', false, 'json', request);
}

model CreateScalingRuleRequest {
  adjustmentType: string(name='AdjustmentType', position='Query'),
  adjustmentValue: int32(name='AdjustmentValue', position='Query'),
  cloudWatchTrigger?: [ 
    {
      comparisonOperator: string(name='ComparisonOperator'),
      evaluationCount: string(name='EvaluationCount'),
      metricName: string(name='MetricName'),
      period: int32(name='Period'),
      statistics: string(name='Statistics'),
      threshold: string(name='Threshold'),
    }
  ](name='CloudWatchTrigger', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  cooldown?: int32(name='Cooldown', position='Query'),
  hostGroupId: string(name='HostGroupId', position='Query'),
  launchExpirationTime?: int32(name='LaunchExpirationTime', position='Query'),
  launchTime?: string(name='LaunchTime', position='Query'),
  recurrenceEndTime?: string(name='RecurrenceEndTime', position='Query'),
  recurrenceType?: string(name='RecurrenceType', position='Query'),
  recurrenceValue?: string(name='RecurrenceValue', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ruleCategory: string(name='RuleCategory', position='Query'),
  ruleName: string(name='RuleName', position='Query'),
  schedulerTrigger?: [ 
    {
      launchExpirationTime?: int32(name='LaunchExpirationTime'),
      launchTime: string(name='LaunchTime'),
      recurrenceEndTime?: string(name='RecurrenceEndTime'),
      recurrenceType?: string(name='RecurrenceType'),
      recurrenceValue?: string(name='RecurrenceValue'),
    }
  ](name='SchedulerTrigger', position='Query'),
  timeoutWithGrace?: long(name='TimeoutWithGrace', position='Query'),
  withGrace?: boolean(name='WithGrace', position='Query'),
}

model CreateScalingRuleResponseBody = {
  requestId?: string(name='RequestId'),
  scalingRuleId?: string(name='ScalingRuleId'),
}

model CreateScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateScalingRuleResponseBody(name='body'),
}

async function createScalingRule(request: CreateScalingRuleRequest): CreateScalingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateScalingRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateTagRequest {
  category: string(name='Category', position='Query'),
  description?: string(name='Description', position='Query'),
  id?: long(name='Id', position='Query'),
  name: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateTagResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateTagResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTagResponseBody(name='body'),
}

async function createTag(request: CreateTagRequest): CreateTagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTag', 'POST', '/', 'json', false, 'json', request);
}

model CreateUserRequest {
  aliyunUserId?: string(name='AliyunUserId', position='Query'),
  description?: string(name='Description', position='Query'),
  groupIdList?: [ integer ](name='GroupIdList', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleIdList?: [ integer ](name='RoleIdList', position='Query'),
  status?: string(name='Status', position='Query'),
  userAccountParamList?: [ 
    {
      accountPassword: string(name='AccountPassword'),
      accountType: string(name='AccountType'),
      authType?: string(name='AuthType'),
    }
  ](name='UserAccountParamList', position='Query'),
  userName: string(name='UserName', position='Query'),
  userType?: string(name='UserType', position='Query'),
}

model CreateUserResponseBody = {
  data?: boolean(name='Data'),
  paging?: boolean(name='Paging'),
  requestId?: string(name='RequestId'),
}

model CreateUserResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUserResponseBody(name='body'),
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUser', 'POST', '/', 'json', false, 'json', request);
}

model CreateUsersRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userInfo: [ 
    {
      type: string(name='Type'),
      userId: string(name='UserId'),
      userName: string(name='UserName'),
    }
  ](name='UserInfo', position='Query'),
}

model CreateUsersResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateUsersResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUsersResponseBody(name='body'),
}

async function createUsers(request: CreateUsersRequest): CreateUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUsers', 'POST', '/', 'json', false, 'json', request);
}

model DecommissionHostComponentRequest {
  clusterId: string(name='ClusterId', position='Query'),
  componentName: string(name='ComponentName', position='Query'),
  hostInstanceId: string(name='HostInstanceId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceName: string(name='ServiceName', position='Query'),
  timeoutSeconds: long(name='TimeoutSeconds', position='Query'),
}

model DecommissionHostComponentResponseBody = {
  requestId?: string(name='RequestId'),
}

model DecommissionHostComponentResponse = {
  headers: map[string]string(name='headers'),
  body: DecommissionHostComponentResponseBody(name='body'),
}

async function decommissionHostComponent(request: DecommissionHostComponentRequest): DecommissionHostComponentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DecommissionHostComponent', 'POST', '/', 'json', false, 'json', request);
}

model DeleteClusterTemplateRequest {
  bizId: string(name='BizId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteClusterTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteClusterTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterTemplateResponseBody(name='body'),
}

async function deleteClusterTemplate(request: DeleteClusterTemplateRequest): DeleteClusterTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteClusterTemplate', 'POST', '/', 'json', false, 'json', request);
}

model DeleteExecutionPlanRequest {
  id: string(name='Id', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteExecutionPlanResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExecutionPlanResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExecutionPlanResponseBody(name='body'),
}

async function deleteExecutionPlan(request: DeleteExecutionPlanRequest): DeleteExecutionPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteExecutionPlan', 'POST', '/', 'json', false, 'json', request);
}

model DeleteFlowRequest {
  id: string(name='Id', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteFlowResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteFlowResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowResponseBody(name='body'),
}

async function deleteFlow(request: DeleteFlowRequest): DeleteFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFlow', 'POST', '/', 'json', false, 'json', request);
}

model DeleteFlowCategoryRequest {
  id: string(name='Id', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteFlowCategoryResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteFlowCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowCategoryResponseBody(name='body'),
}

async function deleteFlowCategory(request: DeleteFlowCategoryRequest): DeleteFlowCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFlowCategory', 'POST', '/', 'json', false, 'json', request);
}

model DeleteFlowJobRequest {
  id: string(name='Id', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteFlowJobResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowJobResponseBody(name='body'),
}

async function deleteFlowJob(request: DeleteFlowJobRequest): DeleteFlowJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFlowJob', 'POST', '/', 'json', false, 'json', request);
}

model DeleteFlowProjectRequest {
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteFlowProjectResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowProjectResponseBody(name='body'),
}

async function deleteFlowProject(request: DeleteFlowProjectRequest): DeleteFlowProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFlowProject', 'POST', '/', 'json', false, 'json', request);
}

model DeleteFlowProjectClusterSettingRequest {
  clusterId: string(name='ClusterId', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteFlowProjectClusterSettingResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteFlowProjectClusterSettingResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowProjectClusterSettingResponseBody(name='body'),
}

async function deleteFlowProjectClusterSetting(request: DeleteFlowProjectClusterSettingRequest): DeleteFlowProjectClusterSettingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFlowProjectClusterSetting', 'POST', '/', 'json', false, 'json', request);
}

model DeleteFlowProjectUserRequest {
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  userName: string(name='UserName', position='Query'),
}

model DeleteFlowProjectUserResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteFlowProjectUserResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowProjectUserResponseBody(name='body'),
}

async function deleteFlowProjectUser(request: DeleteFlowProjectUserRequest): DeleteFlowProjectUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFlowProjectUser', 'POST', '/', 'json', false, 'json', request);
}

model DeleteJobRequest {
  id: string(name='Id', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteJobResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteJobResponseBody(name='body'),
}

async function deleteJob(request: DeleteJobRequest): DeleteJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteJob', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLibrariesRequest {
  libraryBizIdList?: [ string ](name='LibraryBizIdList', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteLibrariesResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteLibrariesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLibrariesResponseBody(name='body'),
}

async function deleteLibraries(request: DeleteLibrariesRequest): DeleteLibrariesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLibraries', 'POST', '/', 'json', false, 'json', request);
}

model DeleteResourcePoolRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourcePoolId: string(name='ResourcePoolId', position='Query'),
}

model DeleteResourcePoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteResourcePoolResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteResourcePoolResponseBody(name='body'),
}

async function deleteResourcePool(request: DeleteResourcePoolRequest): DeleteResourcePoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteResourcePool', 'POST', '/', 'json', false, 'json', request);
}

model DeleteResourceQueueRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceQueueId: string(name='ResourceQueueId', position='Query'),
}

model DeleteResourceQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteResourceQueueResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteResourceQueueResponseBody(name='body'),
}

async function deleteResourceQueue(request: DeleteResourceQueueRequest): DeleteResourceQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteResourceQueue', 'POST', '/', 'json', false, 'json', request);
}

model DeleteScalingRuleRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  hostGroupId?: string(name='HostGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scalingRuleId: string(name='ScalingRuleId', position='Query'),
}

model DeleteScalingRuleResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteScalingRuleResponseBody(name='body'),
}

async function deleteScalingRule(request: DeleteScalingRuleRequest): DeleteScalingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteScalingRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTagRequest {
  category: string(name='Category', position='Query'),
  description?: string(name='Description', position='Query'),
  id?: long(name='Id', position='Query'),
  name: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteTagResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteTagResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTagResponseBody(name='body'),
}

async function deleteTag(request: DeleteTagRequest): DeleteTagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTag', 'POST', '/', 'json', false, 'json', request);
}

model DeleteUserRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  type: string(name='Type', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model DeleteUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteUser', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterBasicInfoRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeClusterBasicInfoResponseBody = {
  clusterInfo?: {
    accessInfo?: {
      ZKLinks?: {
        ZKLink?: [ 
        {
          link?: string(name='Link'),
          port?: string(name='Port'),
        }
      ](name='ZKLink')
      }(name='ZKLinks'),
    }(name='AccessInfo'),
    autoScalingAllowed?: boolean(name='AutoScalingAllowed'),
    autoScalingByLoadAllowed?: boolean(name='AutoScalingByLoadAllowed'),
    autoScalingEnable?: boolean(name='AutoScalingEnable'),
    autoScalingSpotWithLimitAllowed?: boolean(name='AutoScalingSpotWithLimitAllowed'),
    autoScalingVersion?: string(name='AutoScalingVersion'),
    autoScalingWithGraceAllowed?: boolean(name='AutoScalingWithGraceAllowed'),
    bootstrapActionList?: {
      bootstrapAction?: [ 
      {
        arg?: string(name='Arg'),
        name?: string(name='Name'),
        path?: string(name='Path'),
      }
    ](name='BootstrapAction')
    }(name='BootstrapActionList'),
    bootstrapFailed?: boolean(name='BootstrapFailed'),
    chargeType?: string(name='ChargeType'),
    clusterId?: string(name='ClusterId'),
    configurations?: string(name='Configurations'),
    coreNodeInService?: int32(name='CoreNodeInService'),
    coreNodeTotal?: int32(name='CoreNodeTotal'),
    createResource?: string(name='CreateResource'),
    createType?: string(name='CreateType'),
    depositType?: string(name='DepositType'),
    easEnable?: boolean(name='EasEnable'),
    expiredTime?: long(name='ExpiredTime'),
    extraInfo?: string(name='ExtraInfo'),
    failReason?: {
      errorCode?: string(name='ErrorCode'),
      errorMsg?: string(name='ErrorMsg'),
      requestId?: string(name='RequestId'),
    }(name='FailReason'),
    gatewayClusterIds?: string(name='GatewayClusterIds'),
    gatewayClusterInfoList?: {
      gatewayClusterInfo?: [ 
      {
        clusterId?: string(name='ClusterId'),
        clusterName?: string(name='ClusterName'),
        status?: string(name='Status'),
      }
    ](name='GatewayClusterInfo')
    }(name='GatewayClusterInfoList'),
    highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
    hostPoolInfo?: {
      hpBizId?: string(name='HpBizId'),
      hpName?: string(name='HpName'),
    }(name='HostPoolInfo'),
    imageId?: string(name='ImageId'),
    instanceGeneration?: string(name='InstanceGeneration'),
    ioOptimized?: boolean(name='IoOptimized'),
    k8sClusterId?: string(name='K8sClusterId'),
    localMetaDb?: boolean(name='LocalMetaDb'),
    logEnable?: boolean(name='LogEnable'),
    logPath?: string(name='LogPath'),
    machineType?: string(name='MachineType'),
    masterNodeInService?: int32(name='MasterNodeInService'),
    masterNodeTotal?: int32(name='MasterNodeTotal'),
    metaStoreType?: string(name='MetaStoreType'),
    name?: string(name='Name'),
    netType?: string(name='NetType'),
    operationId?: string(name='OperationId'),
    period?: int32(name='Period'),
    regionId?: string(name='RegionId'),
    relateClusterId?: string(name='RelateClusterId'),
    relateClusterInfo?: {
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      status?: string(name='Status'),
    }(name='RelateClusterInfo'),
    resizeDiskEnable?: boolean(name='ResizeDiskEnable'),
    runningTime?: int32(name='RunningTime'),
    securityGroupId?: string(name='SecurityGroupId'),
    securityGroupName?: string(name='SecurityGroupName'),
    showSoftwareInterface?: boolean(name='ShowSoftwareInterface'),
    softwareInfo?: {
      clusterType?: string(name='ClusterType'),
      emrVer?: string(name='EmrVer'),
      softwares?: {
        software?: [ 
        {
          displayName?: string(name='DisplayName'),
          name?: string(name='Name'),
          onlyDisplay?: boolean(name='OnlyDisplay'),
          startTpe?: int32(name='StartTpe'),
          version?: string(name='Version'),
        }
      ](name='Software')
      }(name='Softwares'),
    }(name='SoftwareInfo'),
    startTime?: long(name='StartTime'),
    status?: string(name='Status'),
    stopTime?: long(name='StopTime'),
    taskNodeInService?: int32(name='TaskNodeInService'),
    taskNodeTotal?: int32(name='TaskNodeTotal'),
    userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
    userId?: string(name='UserId'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
    zoneId?: string(name='ZoneId'),
  }(name='ClusterInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterBasicInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterBasicInfoResponseBody(name='body'),
}

async function describeClusterBasicInfo(request: DescribeClusterBasicInfoRequest): DescribeClusterBasicInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterBasicInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterMetaCollectRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeClusterMetaCollectResponseBody = {
  clusterId?: string(name='ClusterId'),
  metaStoreType?: string(name='MetaStoreType'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model DescribeClusterMetaCollectResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterMetaCollectResponseBody(name='body'),
}

async function describeClusterMetaCollect(request: DescribeClusterMetaCollectRequest): DescribeClusterMetaCollectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterMetaCollect', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterOperationHostTaskLogRequest {
  clusterId: string(name='ClusterId', position='Query'),
  hostId?: string(name='HostId', position='Query'),
  operationId: string(name='OperationId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
  taskId: string(name='TaskId', position='Query'),
}

model DescribeClusterOperationHostTaskLogResponseBody = {
  requestId?: string(name='RequestId'),
  stderr?: string(name='Stderr'),
  stdout?: string(name='Stdout'),
}

model DescribeClusterOperationHostTaskLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterOperationHostTaskLogResponseBody(name='body'),
}

async function describeClusterOperationHostTaskLog(request: DescribeClusterOperationHostTaskLogRequest): DescribeClusterOperationHostTaskLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterOperationHostTaskLog', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterResourcePoolSchedulerTypeRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeClusterResourcePoolSchedulerTypeResponseBody = {
  currentSchedulerType?: string(name='CurrentSchedulerType'),
  defaultSchedulerType?: string(name='DefaultSchedulerType'),
  requestId?: string(name='RequestId'),
  supportSchedulerType?: string(name='SupportSchedulerType'),
}

model DescribeClusterResourcePoolSchedulerTypeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterResourcePoolSchedulerTypeResponseBody(name='body'),
}

async function describeClusterResourcePoolSchedulerType(request: DescribeClusterResourcePoolSchedulerTypeRequest): DescribeClusterResourcePoolSchedulerTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterResourcePoolSchedulerType', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterServiceRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceName: string(name='ServiceName', position='Query'),
}

model DescribeClusterServiceResponseBody = {
  requestId?: string(name='RequestId'),
  serviceInfo?: {
    clusterServiceSummaryList?: {
      clusterServiceSummary?: [ 
      {
        alertInfo?: string(name='AlertInfo'),
        category?: string(name='Category'),
        desiredStoppedValue?: int32(name='DesiredStoppedValue'),
        displayName?: string(name='DisplayName'),
        key?: string(name='Key'),
        status?: string(name='Status'),
        type?: string(name='Type'),
        value?: string(name='Value'),
      }
    ](name='ClusterServiceSummary')
    }(name='ClusterServiceSummaryList'),
    needRestartComponentNameList?: {
      service?: [ string ](name='Service')
    }(name='NeedRestartComponentNameList'),
    needRestartHostIdList?: {
      service?: [ string ](name='Service')
    }(name='NeedRestartHostIdList'),
    needRestartInfo?: string(name='NeedRestartInfo'),
    needRestartNum?: int32(name='NeedRestartNum'),
    serviceActionList?: {
      serviceAction?: [ 
      {
        actionName?: string(name='ActionName'),
        command?: string(name='Command'),
        componentName?: string(name='ComponentName'),
        displayName?: string(name='DisplayName'),
        serviceName?: string(name='ServiceName'),
      }
    ](name='ServiceAction')
    }(name='ServiceActionList'),
    serviceName?: string(name='ServiceName'),
    serviceStatus?: string(name='ServiceStatus'),
    serviceVersion?: string(name='ServiceVersion'),
  }(name='ServiceInfo'),
}

model DescribeClusterServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterServiceResponseBody(name='body'),
}

async function describeClusterService(request: DescribeClusterServiceRequest): DescribeClusterServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterService', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterServiceConfigRequest {
  clusterId: string(name='ClusterId', position='Query'),
  configVersion?: string(name='ConfigVersion', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  hostInstanceId?: string(name='HostInstanceId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
  tagValue?: string(name='TagValue', position='Query'),
}

model DescribeClusterServiceConfigResponseBody = {
  config?: {
    applied?: string(name='Applied'),
    author?: string(name='Author'),
    comment?: string(name='Comment'),
    configValueList?: {
      configValue?: [ 
      {
        allowCustom?: boolean(name='AllowCustom'),
        configItemValueList?: {
          configItemValue?: [ 
          {
            description?: string(name='Description'),
            isCustom?: boolean(name='IsCustom'),
            itemName?: string(name='ItemName'),
            value?: string(name='Value'),
          }
        ](name='ConfigItemValue')
        }(name='ConfigItemValueList'),
        configName?: string(name='ConfigName'),
        scope?: string(name='Scope'),
        scopeId?: long(name='ScopeId'),
      }
    ](name='ConfigValue')
    }(name='ConfigValueList'),
    configVersion?: string(name='ConfigVersion'),
    createTime?: string(name='CreateTime'),
    propertyInfoList?: {
      propertyInfo?: [ 
      {
        component?: string(name='Component'),
        description?: string(name='Description'),
        displayName?: string(name='DisplayName'),
        effectWay?: {
          effectType?: string(name='EffectType'),
          invokeServiceName?: string(name='InvokeServiceName'),
        }(name='EffectWay'),
        fileName?: string(name='FileName'),
        name?: string(name='Name'),
        propertyTypes?: {
          propertyType?: [ string ](name='propertyType')
        }(name='PropertyTypes'),
        propertyValueAttributes?: {
          entries?: {
            valueEntryInfo?: [ 
            {
              description?: string(name='Description'),
              label?: string(name='Label'),
              value?: string(name='Value'),
            }
          ](name='ValueEntryInfo')
          }(name='Entries'),
          hidden?: boolean(name='Hidden'),
          incrememtStep?: string(name='IncrememtStep'),
          maximum?: string(name='Maximum'),
          mimimum?: string(name='Mimimum'),
          readOnly?: boolean(name='ReadOnly'),
          type?: string(name='Type'),
          unit?: string(name='Unit'),
        }(name='PropertyValueAttributes'),
        serviceName?: string(name='ServiceName'),
        value?: string(name='Value'),
      }
    ](name='PropertyInfo')
    }(name='PropertyInfoList'),
    serviceName?: string(name='ServiceName'),
  }(name='Config'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterServiceConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterServiceConfigResponseBody(name='body'),
}

async function describeClusterServiceConfig(request: DescribeClusterServiceConfigRequest): DescribeClusterServiceConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterServiceConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterServiceConfigHistoryRequest {
  clusterId: string(name='ClusterId', position='Query'),
  configVersion: string(name='ConfigVersion', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceName: string(name='ServiceName', position='Query'),
}

model DescribeClusterServiceConfigHistoryResponseBody = {
  config?: {
    applied?: boolean(name='Applied'),
    author?: string(name='Author'),
    comment?: string(name='Comment'),
    configValueList?: {
      configValue?: [ 
      {
        configItemValueList?: {
          configItemValue?: [ 
          {
            changeType?: string(name='ChangeType'),
            itemName?: string(name='ItemName'),
            oldValue?: string(name='OldValue'),
            value?: string(name='Value'),
          }
        ](name='ConfigItemValue')
        }(name='ConfigItemValueList'),
        configName?: string(name='ConfigName'),
      }
    ](name='ConfigValue')
    }(name='ConfigValueList'),
    configVersion?: string(name='ConfigVersion'),
    createTime?: string(name='CreateTime'),
    serviceName?: string(name='ServiceName'),
  }(name='Config'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterServiceConfigHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterServiceConfigHistoryResponseBody(name='body'),
}

async function describeClusterServiceConfigHistory(request: DescribeClusterServiceConfigHistoryRequest): DescribeClusterServiceConfigHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterServiceConfigHistory', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterServiceConfigTagRequest {
  clusterId: string(name='ClusterId', position='Query'),
  configTag?: string(name='ConfigTag', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceName: string(name='ServiceName', position='Query'),
}

model DescribeClusterServiceConfigTagResponseBody = {
  configTagList?: {
    configTag?: [ 
    {
      tag?: string(name='Tag'),
      tagDesc?: string(name='TagDesc'),
      valueList?: {
        value?: [ 
        {
          value?: string(name='Value'),
          valueDesc?: string(name='ValueDesc'),
        }
      ](name='Value')
      }(name='ValueList'),
    }
  ](name='ConfigTag')
  }(name='ConfigTagList'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterServiceConfigTagResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterServiceConfigTagResponseBody(name='body'),
}

async function describeClusterServiceConfigTag(request: DescribeClusterServiceConfigTagRequest): DescribeClusterServiceConfigTagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterServiceConfigTag', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterTemplateRequest {
  bizId: string(name='BizId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeClusterTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateInfo?: {
    allowNotebook?: boolean(name='AllowNotebook'),
    bootstrapActionList?: {
      bootstrapAction?: [ 
      {
        arg?: string(name='Arg'),
        name?: string(name='Name'),
        path?: string(name='Path'),
      }
    ](name='BootstrapAction')
    }(name='BootstrapActionList'),
    clusterType?: string(name='ClusterType'),
    configList?: {
      config?: [ 
      {
        configKey?: string(name='ConfigKey'),
        configValue?: string(name='ConfigValue'),
        encrypt?: string(name='Encrypt'),
        fileName?: string(name='FileName'),
        replace?: string(name='Replace'),
        serviceName?: string(name='ServiceName'),
      }
    ](name='Config')
    }(name='ConfigList'),
    configurations?: string(name='Configurations'),
    createSource?: string(name='CreateSource'),
    depositType?: string(name='DepositType'),
    easEnable?: boolean(name='EasEnable'),
    emrVer?: string(name='EmrVer'),
    gmtCreate?: long(name='GmtCreate'),
    gmtModified?: long(name='GmtModified'),
    highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
    hostGroupList?: {
      hostGroup?: [ 
      {
        chargeType?: string(name='ChargeType'),
        diskCapacity?: int32(name='DiskCapacity'),
        diskCount?: int32(name='DiskCount'),
        diskType?: string(name='DiskType'),
        hostGroupId?: string(name='HostGroupId'),
        hostGroupName?: string(name='HostGroupName'),
        hostGroupType?: string(name='HostGroupType'),
        instanceType?: string(name='InstanceType'),
        multiInstanceTypes?: string(name='MultiInstanceTypes'),
        nodeCount?: int32(name='NodeCount'),
        period?: string(name='Period'),
        sysDiskCapacity?: int32(name='SysDiskCapacity'),
        sysDiskType?: string(name='SysDiskType'),
      }
    ](name='HostGroup')
    }(name='HostGroupList'),
    id?: string(name='Id'),
    initCustomHiveMetaDb?: boolean(name='InitCustomHiveMetaDb'),
    instanceGeneration?: string(name='InstanceGeneration'),
    ioOptimized?: boolean(name='IoOptimized'),
    isOpenPublicIp?: boolean(name='IsOpenPublicIp'),
    keyPairName?: string(name='KeyPairName'),
    logEnable?: boolean(name='LogEnable'),
    logPath?: string(name='LogPath'),
    machineType?: string(name='MachineType'),
    masterNodeTotal?: int32(name='MasterNodeTotal'),
    masterPwd?: string(name='MasterPwd'),
    metaStoreConf?: string(name='MetaStoreConf'),
    metaStoreType?: string(name='MetaStoreType'),
    netType?: string(name='NetType'),
    securityGroupId?: string(name='SecurityGroupId'),
    securityGroupName?: string(name='SecurityGroupName'),
    softwareInfoList?: {
      softwareInfo?: [ string ](name='SoftwareInfo')
    }(name='SoftwareInfoList'),
    sshEnable?: boolean(name='SshEnable'),
    tags?: {
      tag?: [ 
      {
        tagKey?: string(name='TagKey'),
        tagValue?: string(name='TagValue'),
      }
    ](name='Tag')
    }(name='Tags'),
    templateName?: string(name='TemplateName'),
    useCustomHiveMetaDb?: boolean(name='UseCustomHiveMetaDb'),
    useLocalMetaDb?: boolean(name='UseLocalMetaDb'),
    userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
    userId?: string(name='UserId'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
    zoneId?: string(name='ZoneId'),
  }(name='TemplateInfo'),
}

model DescribeClusterTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterTemplateResponseBody(name='body'),
}

async function describeClusterTemplate(request: DescribeClusterTemplateRequest): DescribeClusterTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterTemplate', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClusterV2Request {
  id: string(name='Id', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeClusterV2ResponseBody = {
  clusterInfo?: {
    accessInfo?: {
      ZKLinks?: {
        ZKLink?: [ 
        {
          link?: string(name='Link'),
          port?: string(name='Port'),
        }
      ](name='ZKLink')
      }(name='ZKLinks'),
    }(name='AccessInfo'),
    autoScalingAllowed?: boolean(name='AutoScalingAllowed'),
    autoScalingByLoadAllowed?: boolean(name='AutoScalingByLoadAllowed'),
    autoScalingEnable?: boolean(name='AutoScalingEnable'),
    autoScalingSpotWithLimitAllowed?: boolean(name='AutoScalingSpotWithLimitAllowed'),
    autoScalingVersion?: string(name='AutoScalingVersion'),
    autoScalingWithGraceAllowed?: boolean(name='AutoScalingWithGraceAllowed'),
    bootstrapActionList?: {
      bootstrapAction?: [ 
      {
        arg?: string(name='Arg'),
        name?: string(name='Name'),
        path?: string(name='Path'),
      }
    ](name='BootstrapAction')
    }(name='BootstrapActionList'),
    bootstrapFailed?: boolean(name='BootstrapFailed'),
    chargeType?: string(name='ChargeType'),
    configurations?: string(name='Configurations'),
    coreNodeInService?: int32(name='CoreNodeInService'),
    coreNodeTotal?: int32(name='CoreNodeTotal'),
    createResource?: string(name='CreateResource'),
    createType?: string(name='CreateType'),
    depositType?: string(name='DepositType'),
    easEnable?: boolean(name='EasEnable'),
    expiredTime?: long(name='ExpiredTime'),
    extraInfo?: string(name='ExtraInfo'),
    failReason?: {
      errorCode?: string(name='ErrorCode'),
      errorMsg?: string(name='ErrorMsg'),
      requestId?: string(name='RequestId'),
    }(name='FailReason'),
    gatewayClusterIds?: string(name='GatewayClusterIds'),
    gatewayClusterInfoList?: {
      gatewayClusterInfo?: [ 
      {
        clusterId?: string(name='ClusterId'),
        clusterName?: string(name='ClusterName'),
        status?: string(name='Status'),
      }
    ](name='GatewayClusterInfo')
    }(name='GatewayClusterInfoList'),
    highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
    hostGroupList?: {
      hostGroup?: [ 
      {
        bandWidth?: string(name='BandWidth'),
        chargeType?: string(name='ChargeType'),
        cpuCore?: int32(name='CpuCore'),
        diskCapacity?: int32(name='DiskCapacity'),
        diskCount?: int32(name='DiskCount'),
        diskType?: string(name='DiskType'),
        hostGroupChangeStatus?: string(name='HostGroupChangeStatus'),
        hostGroupChangeType?: string(name='HostGroupChangeType'),
        hostGroupId?: string(name='HostGroupId'),
        hostGroupName?: string(name='HostGroupName'),
        hostGroupSubType?: string(name='HostGroupSubType'),
        hostGroupType?: string(name='HostGroupType'),
        instanceType?: string(name='InstanceType'),
        lockReason?: string(name='LockReason'),
        lockType?: string(name='LockType'),
        memoryCapacity?: int32(name='MemoryCapacity'),
        nodeCount?: int32(name='NodeCount'),
        nodes?: {
          node?: [ 
          {
            createTime?: string(name='CreateTime'),
            daemonInfos?: {
              daemonInfo?: [ 
              {
                name?: string(name='Name'),
              }
            ](name='DaemonInfo')
            }(name='DaemonInfos'),
            diskInfos?: {
              diskInfo?: [ 
              {
                device?: string(name='Device'),
                diskId?: string(name='DiskId'),
                diskName?: string(name='DiskName'),
                size?: int32(name='Size'),
                type?: string(name='Type'),
              }
            ](name='DiskInfo')
            }(name='DiskInfos'),
            emrExpiredTime?: string(name='EmrExpiredTime'),
            expiredTime?: string(name='ExpiredTime'),
            innerIp?: string(name='InnerIp'),
            instanceId?: string(name='InstanceId'),
            pubIp?: string(name='PubIp'),
            status?: string(name='Status'),
            supportIpV6?: boolean(name='SupportIpV6'),
            zoneId?: string(name='ZoneId'),
          }
        ](name='Node')
        }(name='Nodes'),
        period?: string(name='Period'),
      }
    ](name='HostGroup')
    }(name='HostGroupList'),
    hostPoolInfo?: {
      hpBizId?: string(name='HpBizId'),
      hpName?: string(name='HpName'),
    }(name='HostPoolInfo'),
    id?: string(name='Id'),
    imageId?: string(name='ImageId'),
    instanceGeneration?: string(name='InstanceGeneration'),
    ioOptimized?: boolean(name='IoOptimized'),
    k8sClusterId?: string(name='K8sClusterId'),
    localMetaDb?: boolean(name='LocalMetaDb'),
    logEnable?: boolean(name='LogEnable'),
    logPath?: string(name='LogPath'),
    machineType?: string(name='MachineType'),
    masterNodeInService?: int32(name='MasterNodeInService'),
    masterNodeTotal?: int32(name='MasterNodeTotal'),
    metaStoreType?: string(name='MetaStoreType'),
    name?: string(name='Name'),
    netType?: string(name='NetType'),
    period?: int32(name='Period'),
    regionId?: string(name='RegionId'),
    relateClusterId?: string(name='RelateClusterId'),
    relateClusterInfo?: {
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      status?: string(name='Status'),
    }(name='RelateClusterInfo'),
    resizeDiskEnable?: boolean(name='ResizeDiskEnable'),
    runningTime?: int32(name='RunningTime'),
    securityGroupId?: string(name='SecurityGroupId'),
    securityGroupName?: string(name='SecurityGroupName'),
    showSoftwareInterface?: boolean(name='ShowSoftwareInterface'),
    softwareInfo?: {
      clusterType?: string(name='ClusterType'),
      emrVer?: string(name='EmrVer'),
      softwares?: {
        software?: [ 
        {
          displayName?: string(name='DisplayName'),
          name?: string(name='Name'),
          onlyDisplay?: boolean(name='OnlyDisplay'),
          startTpe?: int32(name='StartTpe'),
          version?: string(name='Version'),
        }
      ](name='Software')
      }(name='Softwares'),
    }(name='SoftwareInfo'),
    startTime?: long(name='StartTime'),
    status?: string(name='Status'),
    stopTime?: long(name='StopTime'),
    taskNodeInService?: int32(name='TaskNodeInService'),
    taskNodeTotal?: int32(name='TaskNodeTotal'),
    userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
    userId?: string(name='UserId'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
    zoneId?: string(name='ZoneId'),
  }(name='ClusterInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterV2Response = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterV2ResponseBody(name='body'),
}

async function describeClusterV2(request: DescribeClusterV2Request): DescribeClusterV2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClusterV2', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDataSourceRequest {
  id: string(name='Id', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDataSourceResponseBody = {
  categoryId?: string(name='CategoryId'),
  clusterId?: string(name='ClusterId'),
  conf?: string(name='Conf'),
  createFrom?: string(name='CreateFrom'),
  creator?: string(name='Creator'),
  description?: string(name='Description'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  id?: string(name='Id'),
  modifier?: string(name='Modifier'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  sourceType?: string(name='SourceType'),
  status?: string(name='Status'),
}

model DescribeDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDataSourceResponseBody(name='body'),
}

async function describeDataSource(request: DescribeDataSourceRequest): DescribeDataSourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDataSource', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDiskOpsActivityRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  currentStage?: string(name='CurrentStage', position='Query'),
  currentState?: string(name='CurrentState', position='Query'),
  diskId?: string(name='DiskId', position='Query'),
  eventId?: string(name='EventId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDiskOpsActivityResponseBody = {
  activityState?: string(name='ActivityState'),
  clusterType?: string(name='ClusterType'),
  currentActivity?: string(name='CurrentActivity'),
  errorMessage?: string(name='ErrorMessage'),
  needReboot?: boolean(name='NeedReboot'),
  requestId?: string(name='RequestId'),
}

model DescribeDiskOpsActivityResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDiskOpsActivityResponseBody(name='body'),
}

async function describeDiskOpsActivity(request: DescribeDiskOpsActivityRequest): DescribeDiskOpsActivityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDiskOpsActivity', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEmrMainVersionRequest {
  emrVersion?: string(name='EmrVersion', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeEmrMainVersionResponseBody = {
  emrMainVersion?: {
    clusterTypeInfoList?: {
      clusterTypeInfo?: [ 
      {
        clusterType?: string(name='ClusterType'),
        serviceInfoList?: {
          serviceInfo?: [ 
          {
            display?: boolean(name='Display'),
            mandatory?: boolean(name='Mandatory'),
            serviceDisplayName?: string(name='ServiceDisplayName'),
            serviceDisplayVersion?: string(name='ServiceDisplayVersion'),
            serviceName?: string(name='ServiceName'),
            serviceVersion?: string(name='ServiceVersion'),
          }
        ](name='ServiceInfo')
        }(name='ServiceInfoList'),
      }
    ](name='ClusterTypeInfo')
    }(name='ClusterTypeInfoList'),
    clusterTypeWhiteUserList?: {
      clusterTypeWhiteUser?: [ 
      {
        clusterType?: string(name='ClusterType'),
        userId?: string(name='UserId'),
      }
    ](name='ClusterTypeWhiteUser')
    }(name='ClusterTypeWhiteUserList'),
    display?: boolean(name='Display'),
    ecmVersion?: boolean(name='EcmVersion'),
    emrVersion?: string(name='EmrVersion'),
    imageId?: string(name='ImageId'),
    publishType?: string(name='PublishType'),
    regionId?: string(name='RegionId'),
    stackName?: string(name='StackName'),
    stackVersion?: string(name='StackVersion'),
    whiteUserList?: {
      wwhiteUser?: [ string ](name='WwhiteUser')
    }(name='WhiteUserList'),
  }(name='EmrMainVersion'),
  requestId?: string(name='RequestId'),
}

model DescribeEmrMainVersionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEmrMainVersionResponseBody(name='body'),
}

async function describeEmrMainVersion(request: DescribeEmrMainVersionRequest): DescribeEmrMainVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEmrMainVersion', 'POST', '/', 'json', false, 'json', request);
}

model DescribeExecutionPlanRequest {
  id: string(name='Id', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeExecutionPlanResponseBody = {
  clusterId?: string(name='ClusterId'),
  clusterInfo?: {
    bootstrapActionList?: {
      bootstrapAction?: [ 
      {
        arg?: string(name='Arg'),
        name?: string(name='Name'),
        path?: string(name='Path'),
      }
    ](name='BootstrapAction')
    }(name='BootstrapActionList'),
    clusterType?: string(name='ClusterType'),
    configList?: {
      config?: [ 
      {
        configKey?: string(name='ConfigKey'),
        configValue?: string(name='ConfigValue'),
        encrypt?: string(name='Encrypt'),
        fileName?: string(name='FileName'),
        serviceName?: string(name='ServiceName'),
      }
    ](name='Config')
    }(name='ConfigList'),
    configurations?: string(name='Configurations'),
    easEnable?: boolean(name='EasEnable'),
    ecsOrders?: {
      ecsOrderInfo?: [ 
      {
        diskCapacity?: int32(name='DiskCapacity'),
        diskCount?: int32(name='DiskCount'),
        diskType?: string(name='DiskType'),
        index?: int32(name='Index'),
        instanceType?: string(name='InstanceType'),
        nodeCount?: int32(name='NodeCount'),
        nodeType?: string(name='NodeType'),
      }
    ](name='EcsOrderInfo')
    }(name='EcsOrders'),
    emrVer?: string(name='EmrVer'),
    highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
    initCustomHiveMetaDB?: boolean(name='InitCustomHiveMetaDB'),
    instanceGeneration?: string(name='InstanceGeneration'),
    ioOptimized?: boolean(name='IoOptimized'),
    logEnable?: boolean(name='LogEnable'),
    logPath?: string(name='LogPath'),
    name?: string(name='Name'),
    netType?: string(name='NetType'),
    securityGroupId?: string(name='SecurityGroupId'),
    softwareInfo?: {
      clusterType?: string(name='ClusterType'),
      emrVer?: string(name='EmrVer'),
      softwares?: {
        software?: [ 
        {
          displayName?: string(name='DisplayName'),
          name?: string(name='Name'),
          onlyDisplay?: boolean(name='OnlyDisplay'),
          optional?: boolean(name='Optional'),
          startTpe?: int32(name='StartTpe'),
          version?: string(name='Version'),
        }
      ](name='Software')
      }(name='Softwares'),
    }(name='SoftwareInfo'),
    useCustomHiveMetaDB?: boolean(name='UseCustomHiveMetaDB'),
    useLocalMetaDb?: boolean(name='UseLocalMetaDb'),
    userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
    zoneId?: string(name='ZoneId'),
  }(name='ClusterInfo'),
  clusterName?: string(name='ClusterName'),
  createClusterOnDemand?: boolean(name='CreateClusterOnDemand'),
  dayOfMonth?: string(name='DayOfMonth'),
  dayOfWeek?: string(name='DayOfWeek'),
  executionPlanVersion?: long(name='ExecutionPlanVersion'),
  id?: string(name='Id'),
  jobInfoList?: {
    jobInfo?: [ 
    {
      failAct?: string(name='FailAct'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      runParameter?: string(name='RunParameter'),
      type?: string(name='Type'),
    }
  ](name='JobInfo')
  }(name='JobInfoList'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  startTime?: long(name='StartTime'),
  status?: string(name='Status'),
  strategy?: string(name='Strategy'),
  timeInterval?: int32(name='TimeInterval'),
  timeUnit?: string(name='TimeUnit'),
  workflowApp?: string(name='WorkflowApp'),
}

model DescribeExecutionPlanResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeExecutionPlanResponseBody(name='body'),
}

async function describeExecutionPlan(request: DescribeExecutionPlanRequest): DescribeExecutionPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeExecutionPlan', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFlowRequest {
  id: string(name='Id', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeFlowResponseBody = {
  alertConf?: string(name='AlertConf'),
  alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
  alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
  application?: string(name='Application'),
  categoryId?: string(name='CategoryId'),
  clusterId?: string(name='ClusterId'),
  createCluster?: boolean(name='CreateCluster'),
  cronExpr?: string(name='CronExpr'),
  description?: string(name='Description'),
  editLockDetail?: string(name='EditLockDetail'),
  endSchedule?: long(name='EndSchedule'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  graph?: string(name='Graph'),
  hostName?: string(name='HostName'),
  id?: string(name='Id'),
  lifecycle?: string(name='Lifecycle'),
  logArchiveLocation?: string(name='LogArchiveLocation'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  parentFlowList?: {
    parentFlow?: [ 
    {
      parentFlowId?: string(name='ParentFlowId'),
      parentFlowName?: string(name='ParentFlowName'),
      projectId?: string(name='ProjectId'),
      projectName?: string(name='ProjectName'),
    }
  ](name='ParentFlow')
  }(name='ParentFlowList'),
  periodic?: boolean(name='Periodic'),
  requestId?: string(name='RequestId'),
  startSchedule?: long(name='StartSchedule'),
  status?: string(name='Status'),
  type?: string(name='Type'),
}

model DescribeFlowResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowResponseBody(name='body'),
}

async function describeFlow(request: DescribeFlowRequest): DescribeFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFlow', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFlowCategoryRequest {
  id: string(name='Id', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeFlowCategoryResponseBody = {
  categoryType?: string(name='CategoryType'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  objectId?: string(name='ObjectId'),
  objectType?: string(name='ObjectType'),
  parentId?: string(name='ParentId'),
  projectId?: string(name='ProjectId'),
  requestId?: string(name='RequestId'),
  type?: string(name='Type'),
}

model DescribeFlowCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowCategoryResponseBody(name='body'),
}

async function describeFlowCategory(request: DescribeFlowCategoryRequest): DescribeFlowCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFlowCategory', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFlowCategoryTreeRequest {
  categoryId?: string(name='CategoryId', position='Query'),
  keyword?: string(name='Keyword', position='Query'),
  mode?: string(name='Mode', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
}

model DescribeFlowCategoryTreeResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeFlowCategoryTreeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowCategoryTreeResponseBody(name='body'),
}

async function describeFlowCategoryTree(request: DescribeFlowCategoryTreeRequest): DescribeFlowCategoryTreeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFlowCategoryTree', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFlowInstanceRequest {
  id: string(name='Id', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeFlowInstanceResponseBody = {
  clusterId?: string(name='ClusterId'),
  cronExpression?: string(name='CronExpression'),
  dependencyFlowList?: {
    parentFlow?: [ 
    {
      bizDate?: long(name='BizDate'),
      dependencyFlowId?: string(name='DependencyFlowId'),
      dependencyInstanceId?: string(name='DependencyInstanceId'),
      flowId?: string(name='FlowId'),
      flowInstanceId?: string(name='FlowInstanceId'),
      meet?: boolean(name='Meet'),
      projectId?: string(name='ProjectId'),
      scheduleKey?: string(name='ScheduleKey'),
    }
  ](name='ParentFlow')
  }(name='DependencyFlowList'),
  duration?: long(name='Duration'),
  endTime?: long(name='EndTime'),
  flowId?: string(name='FlowId'),
  flowName?: string(name='FlowName'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  graph?: string(name='Graph'),
  hasNodeFailed?: boolean(name='HasNodeFailed'),
  id?: string(name='Id'),
  lifecycle?: string(name='Lifecycle'),
  logArchiveLocation?: string(name='LogArchiveLocation'),
  namespace?: string(name='Namespace'),
  nodeInstance?: {
    nodeInstance?: [ 
    {
      clusterId?: string(name='ClusterId'),
      duration?: long(name='Duration'),
      endTime?: long(name='EndTime'),
      externalId?: string(name='ExternalId'),
      externalInfo?: string(name='ExternalInfo'),
      externalStatus?: string(name='ExternalStatus'),
      failAct?: string(name='FailAct'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      hostName?: string(name='HostName'),
      id?: string(name='Id'),
      jobId?: string(name='JobId'),
      jobName?: string(name='JobName'),
      jobType?: string(name='JobType'),
      maxRetry?: string(name='MaxRetry'),
      nodeName?: string(name='NodeName'),
      pending?: boolean(name='Pending'),
      projectId?: string(name='ProjectId'),
      retries?: int32(name='Retries'),
      retryInterval?: string(name='RetryInterval'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='NodeInstance')
  }(name='NodeInstance'),
  projectId?: string(name='ProjectId'),
  requestId?: string(name='RequestId'),
  scheduleTime?: long(name='ScheduleTime'),
  startTime?: long(name='StartTime'),
  status?: string(name='Status'),
}

model DescribeFlowInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowInstanceResponseBody(name='body'),
}

async function describeFlowInstance(request: DescribeFlowInstanceRequest): DescribeFlowInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFlowInstance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFlowJobRequest {
  id: string(name='Id', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeFlowJobResponseBody = {
  adhoc?: string(name='Adhoc'),
  alertConf?: string(name='AlertConf'),
  categoryId?: string(name='CategoryId'),
  customVariables?: string(name='CustomVariables'),
  description?: string(name='Description'),
  editLockDetail?: string(name='EditLockDetail'),
  envConf?: string(name='EnvConf'),
  failAct?: string(name='FailAct'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  id?: string(name='Id'),
  lastInstanceId?: string(name='LastInstanceId'),
  maxRetry?: int32(name='MaxRetry'),
  maxRunningTimeSec?: long(name='MaxRunningTimeSec'),
  monitorConf?: string(name='MonitorConf'),
  name?: string(name='Name'),
  paramConf?: string(name='ParamConf'),
  params?: string(name='Params'),
  requestId?: string(name='RequestId'),
  resourceList?: {
    resource?: [ 
    {
      alias?: string(name='Alias'),
      path?: string(name='Path'),
    }
  ](name='Resource')
  }(name='ResourceList'),
  retryInterval?: long(name='RetryInterval'),
  retryPolicy?: string(name='RetryPolicy'),
  runConf?: string(name='RunConf'),
  type?: string(name='Type'),
  mode?: string(name='mode'),
}

model DescribeFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowJobResponseBody(name='body'),
}

async function describeFlowJob(request: DescribeFlowJobRequest): DescribeFlowJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFlowJob', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFlowNodeInstanceRequest {
  id: string(name='Id', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeFlowNodeInstanceResponseBody = {
  adhoc?: boolean(name='Adhoc'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  duration?: long(name='Duration'),
  endTime?: long(name='EndTime'),
  envConf?: string(name='EnvConf'),
  externalChildIds?: string(name='ExternalChildIds'),
  externalId?: string(name='ExternalId'),
  externalInfo?: string(name='ExternalInfo'),
  externalStatus?: string(name='ExternalStatus'),
  externalSubId?: string(name='ExternalSubId'),
  failAct?: string(name='FailAct'),
  flowId?: string(name='FlowId'),
  flowInstanceId?: string(name='FlowInstanceId'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  hostName?: string(name='HostName'),
  id?: string(name='Id'),
  jobId?: string(name='JobId'),
  jobName?: string(name='JobName'),
  jobParams?: string(name='JobParams'),
  jobType?: string(name='JobType'),
  maxRetry?: string(name='MaxRetry'),
  mode?: string(name='Mode'),
  monitorConf?: string(name='MonitorConf'),
  nodeName?: string(name='NodeName'),
  paramConf?: string(name='ParamConf'),
  pending?: boolean(name='Pending'),
  projectId?: string(name='ProjectId'),
  requestId?: string(name='RequestId'),
  retries?: int32(name='Retries'),
  retryInterval?: string(name='RetryInterval'),
  retryPolicy?: string(name='RetryPolicy'),
  runConf?: string(name='RunConf'),
  startTime?: long(name='StartTime'),
  status?: string(name='Status'),
  type?: string(name='Type'),
}

model DescribeFlowNodeInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowNodeInstanceResponseBody(name='body'),
}

async function describeFlowNodeInstance(request: DescribeFlowNodeInstanceRequest): DescribeFlowNodeInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFlowNodeInstance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFlowNodeInstanceContainerLogRequest {
  appId: string(name='AppId', position='Query'),
  containerId: string(name='ContainerId', position='Query'),
  length?: int32(name='Length', position='Query'),
  logName: string(name='LogName', position='Query'),
  nodeInstanceId: string(name='NodeInstanceId', position='Query'),
  offset?: int32(name='Offset', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeFlowNodeInstanceContainerLogResponseBody = {
  logEnd?: boolean(name='LogEnd'),
  logEntrys?: {
    logEntry?: [ 
    {
      content?: string(name='Content'),
    }
  ](name='LogEntry')
  }(name='LogEntrys'),
  requestId?: string(name='RequestId'),
}

model DescribeFlowNodeInstanceContainerLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowNodeInstanceContainerLogResponseBody(name='body'),
}

async function describeFlowNodeInstanceContainerLog(request: DescribeFlowNodeInstanceContainerLogRequest): DescribeFlowNodeInstanceContainerLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFlowNodeInstanceContainerLog', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFlowNodeInstanceLauncherLogRequest {
  endTime?: long(name='EndTime', position='Query'),
  length?: int32(name='Length', position='Query'),
  lines?: int32(name='Lines', position='Query'),
  nodeInstanceId: string(name='NodeInstanceId', position='Query'),
  offset?: int32(name='Offset', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  reverse?: boolean(name='Reverse', position='Query'),
  start?: int32(name='Start', position='Query'),
  startTime?: long(name='StartTime', position='Query'),
}

model DescribeFlowNodeInstanceLauncherLogResponseBody = {
  logEnd?: boolean(name='LogEnd'),
  logEntrys?: {
    logEntry?: [ 
    {
      content?: string(name='Content'),
    }
  ](name='LogEntry')
  }(name='LogEntrys'),
  requestId?: string(name='RequestId'),
}

model DescribeFlowNodeInstanceLauncherLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowNodeInstanceLauncherLogResponseBody(name='body'),
}

async function describeFlowNodeInstanceLauncherLog(request: DescribeFlowNodeInstanceLauncherLogRequest): DescribeFlowNodeInstanceLauncherLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFlowNodeInstanceLauncherLog', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFlowProjectRequest {
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeFlowProjectResponseBody = {
  description?: string(name='Description'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  userId?: string(name='UserId'),
}

model DescribeFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowProjectResponseBody(name='body'),
}

async function describeFlowProject(request: DescribeFlowProjectRequest): DescribeFlowProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFlowProject', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFlowProjectClusterSettingRequest {
  clusterId: string(name='ClusterId', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeFlowProjectClusterSettingResponseBody = {
  clusterId?: string(name='ClusterId'),
  defaultQueue?: string(name='DefaultQueue'),
  defaultUser?: string(name='DefaultUser'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  hostList?: {
    host?: [ string ](name='Host')
  }(name='HostList'),
  k8sClusterId?: string(name='K8sClusterId'),
  projectId?: string(name='ProjectId'),
  queueList?: {
    queue?: [ string ](name='Queue')
  }(name='QueueList'),
  requestId?: string(name='RequestId'),
  userList?: {
    user?: [ string ](name='User')
  }(name='UserList'),
}

model DescribeFlowProjectClusterSettingResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowProjectClusterSettingResponseBody(name='body'),
}

async function describeFlowProjectClusterSetting(request: DescribeFlowProjectClusterSettingRequest): DescribeFlowProjectClusterSettingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFlowProjectClusterSetting', 'POST', '/', 'json', false, 'json', request);
}

model DescribeJobRequest {
  id: string(name='Id', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeJobResponseBody = {
  failAct?: string(name='FailAct'),
  id?: string(name='Id'),
  maxRetry?: int32(name='MaxRetry'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  retryInterval?: int32(name='RetryInterval'),
  runParameter?: string(name='RunParameter'),
  type?: string(name='Type'),
}

model DescribeJobResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeJobResponseBody(name='body'),
}

async function describeJob(request: DescribeJobRequest): DescribeJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeJob', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLibraryDetailRequest {
  libraryBizId?: string(name='LibraryBizId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeLibraryDetailResponseBody = {
  bizId?: string(name='BizId'),
  createTime?: long(name='CreateTime'),
  libraryVersion?: string(name='LibraryVersion'),
  name?: string(name='Name'),
  properties?: string(name='Properties'),
  requestId?: string(name='RequestId'),
  scope?: string(name='Scope'),
  sourceLocation?: string(name='SourceLocation'),
  sourceType?: string(name='SourceType'),
  type?: string(name='Type'),
  userId?: string(name='UserId'),
}

model DescribeLibraryDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLibraryDetailResponseBody(name='body'),
}

async function describeLibraryDetail(request: DescribeLibraryDetailRequest): DescribeLibraryDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLibraryDetail', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLibraryInstallTaskDetailRequest {
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  taskBizId?: string(name='TaskBizId', position='Query'),
}

model DescribeLibraryInstallTaskDetailResponseBody = {
  clusterBizId?: string(name='ClusterBizId'),
  detail?: string(name='Detail'),
  endTime?: long(name='EndTime'),
  executeTime?: long(name='ExecuteTime'),
  hostname?: string(name='Hostname'),
  libraryBizId?: string(name='LibraryBizId'),
  requestId?: string(name='RequestId'),
  startTime?: long(name='StartTime'),
  taskGroupId?: string(name='TaskGroupId'),
  taskId?: string(name='TaskId'),
  taskProcess?: int32(name='TaskProcess'),
  taskStatus?: string(name='TaskStatus'),
  taskType?: string(name='TaskType'),
}

model DescribeLibraryInstallTaskDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLibraryInstallTaskDetailResponseBody(name='body'),
}

async function describeLibraryInstallTaskDetail(request: DescribeLibraryInstallTaskDetailRequest): DescribeLibraryInstallTaskDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLibraryInstallTaskDetail', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMetaTablePreviewTaskRequest {
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  taskId: string(name='TaskId', position='Query'),
}

model DescribeMetaTablePreviewTaskResponseBody = {
  data?: {
    headers?: {
      header?: [ string ](name='Header')
    }(name='Headers'),
    rows?: {
      row?: [ 
      {
        columns?: {
          column?: [ string ](name='Column')
        }(name='Columns'),
      }
    ](name='Row')
    }(name='Rows'),
  }(name='Data'),
  endTime?: long(name='EndTime'),
  executeTime?: long(name='ExecuteTime'),
  requestId?: string(name='RequestId'),
  startTime?: long(name='StartTime'),
  taskId?: string(name='TaskId'),
  taskProcess?: int32(name='TaskProcess'),
  taskStatus?: string(name='TaskStatus'),
}

model DescribeMetaTablePreviewTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMetaTablePreviewTaskResponseBody(name='body'),
}

async function describeMetaTablePreviewTask(request: DescribeMetaTablePreviewTaskRequest): DescribeMetaTablePreviewTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMetaTablePreviewTask', 'POST', '/', 'json', false, 'json', request);
}

model DescribeScalingActivityRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  hostGroupId?: string(name='HostGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scalingActivityId: string(name='ScalingActivityId', position='Query'),
}

model DescribeScalingActivityResponseBody = {
  bizId?: string(name='BizId'),
  cause?: string(name='Cause'),
  description?: string(name='Description'),
  endTime?: long(name='EndTime'),
  expectNum?: int32(name='ExpectNum'),
  instanceIds?: string(name='InstanceIds'),
  requestId?: string(name='RequestId'),
  scalingRuleId?: string(name='ScalingRuleId'),
  startTime?: long(name='StartTime'),
  status?: string(name='Status'),
  totalCapacity?: int32(name='TotalCapacity'),
  transition?: string(name='Transition'),
}

model DescribeScalingActivityResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeScalingActivityResponseBody(name='body'),
}

async function describeScalingActivity(request: DescribeScalingActivityRequest): DescribeScalingActivityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeScalingActivity', 'POST', '/', 'json', false, 'json', request);
}

model DescribeScalingCommonConfigRequest {
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeScalingCommonConfigResponseBody = {
  autoScalingConfigDecommissionQueryInterval?: long(name='AutoScalingConfigDecommissionQueryInterval'),
  autoScalingConfigSystemDiskSize?: int32(name='AutoScalingConfigSystemDiskSize'),
  autoScalingCoolDownTime?: int32(name='AutoScalingCoolDownTime'),
  autoScalingGroupMaxSizeLimit?: int32(name='AutoScalingGroupMaxSizeLimit'),
  autoScalingGroupMinSizeLimit?: int32(name='AutoScalingGroupMinSizeLimit'),
  autoScalingHookHeartbeatDefaultTime?: int32(name='AutoScalingHookHeartbeatDefaultTime'),
  autoScalingMNSScalingThreadSleepTime?: long(name='AutoScalingMNSScalingThreadSleepTime'),
  autoScalingRuleAlarmDelayLimit?: int32(name='AutoScalingRuleAlarmDelayLimit'),
  autoScalingRuleAlarmSilentTime?: int32(name='AutoScalingRuleAlarmSilentTime'),
  autoScalingRuleMinDelayLimit?: int32(name='AutoScalingRuleMinDelayLimit'),
  requestId?: string(name='RequestId'),
}

model DescribeScalingCommonConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeScalingCommonConfigResponseBody(name='body'),
}

async function describeScalingCommonConfig(request: DescribeScalingCommonConfigRequest): DescribeScalingCommonConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeScalingCommonConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeScalingConfigItemV2Request {
  configItemType: string(name='ConfigItemType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scalingConfigItemId: string(name='ScalingConfigItemId', position='Query'),
  scalingGroupBizId: string(name='ScalingGroupBizId', position='Query'),
}

model DescribeScalingConfigItemV2ResponseBody = {
  configItemInformation?: string(name='ConfigItemInformation'),
  configItemType?: string(name='ConfigItemType'),
  requestId?: string(name='RequestId'),
  scalingConfigItemBizId?: string(name='ScalingConfigItemBizId'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
}

model DescribeScalingConfigItemV2Response = {
  headers: map[string]string(name='headers'),
  body: DescribeScalingConfigItemV2ResponseBody(name='body'),
}

async function describeScalingConfigItemV2(request: DescribeScalingConfigItemV2Request): DescribeScalingConfigItemV2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeScalingConfigItemV2', 'POST', '/', 'json', false, 'json', request);
}

model DescribeScalingGroupInstanceV2Request {
  hostGroupBizId?: string(name='HostGroupBizId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scalingGroupBizId?: string(name='ScalingGroupBizId', position='Query'),
}

model DescribeScalingGroupInstanceV2ResponseBody = {
  activeRuleCategory?: string(name='ActiveRuleCategory'),
  defaultCooldown?: int32(name='DefaultCooldown'),
  hostGroupId?: string(name='HostGroupId'),
  maxSize?: int32(name='MaxSize'),
  minSize?: int32(name='MinSize'),
  multiAvailablePolicy?: string(name='MultiAvailablePolicy'),
  multiAvailablePolicyParam?: string(name='MultiAvailablePolicyParam'),
  requestId?: string(name='RequestId'),
  scalingConfig?: {
    dataDiskCategory?: string(name='DataDiskCategory'),
    dataDiskCount?: int32(name='DataDiskCount'),
    dataDiskSize?: int32(name='DataDiskSize'),
    instanceTypeList?: {
      instanceType?: [ string ](name='InstanceType')
    }(name='InstanceTypeList'),
    payType?: string(name='PayType'),
    spotPriceLimits?: {
      spotPriceLimit?: [ 
      {
        instanceType?: string(name='InstanceType'),
        priceLimit?: float(name='PriceLimit'),
      }
    ](name='SpotPriceLimit')
    }(name='SpotPriceLimits'),
    spotStrategy?: string(name='SpotStrategy'),
    sysDiskCategory?: string(name='SysDiskCategory'),
    sysDiskSize?: int32(name='SysDiskSize'),
  }(name='ScalingConfig'),
  scalingGroupId?: string(name='ScalingGroupId'),
  scalingRuleList?: {
    scalingRule?: [ 
    {
      adjustmentType?: string(name='AdjustmentType'),
      adjustmentValue?: int32(name='AdjustmentValue'),
      cloudWatchTrigger?: {
        comparisonOperator?: string(name='ComparisonOperator'),
        evaluationCount?: string(name='EvaluationCount'),
        metricDisplayName?: string(name='MetricDisplayName'),
        metricName?: string(name='MetricName'),
        period?: int32(name='Period'),
        statistics?: string(name='Statistics'),
        threshold?: string(name='Threshold'),
        unit?: string(name='Unit'),
      }(name='CloudWatchTrigger'),
      cooldown?: int32(name='Cooldown'),
      essScalingRuleId?: string(name='EssScalingRuleId'),
      launchExpirationTime?: int32(name='LaunchExpirationTime'),
      launchTime?: string(name='LaunchTime'),
      recurrenceEndTime?: string(name='RecurrenceEndTime'),
      recurrenceType?: string(name='RecurrenceType'),
      recurrenceValue?: string(name='RecurrenceValue'),
      ruleCategory?: string(name='RuleCategory'),
      ruleName?: string(name='RuleName'),
      scalingGroupId?: long(name='ScalingGroupId'),
      schedulerTrigger?: {
        launchExpirationTime?: int32(name='LaunchExpirationTime'),
        launchTime?: long(name='LaunchTime'),
        recurrenceEndTime?: long(name='RecurrenceEndTime'),
        recurrenceType?: string(name='RecurrenceType'),
        recurrenceValue?: string(name='RecurrenceValue'),
      }(name='SchedulerTrigger'),
      status?: string(name='Status'),
      timeoutWithGrace?: long(name='TimeoutWithGrace'),
      withGrace?: boolean(name='WithGrace'),
    }
  ](name='ScalingRule')
  }(name='ScalingRuleList'),
  timeoutWithGrace?: long(name='TimeoutWithGrace'),
  withGrace?: boolean(name='WithGrace'),
}

model DescribeScalingGroupInstanceV2Response = {
  headers: map[string]string(name='headers'),
  body: DescribeScalingGroupInstanceV2ResponseBody(name='body'),
}

async function describeScalingGroupInstanceV2(request: DescribeScalingGroupInstanceV2Request): DescribeScalingGroupInstanceV2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeScalingGroupInstanceV2', 'POST', '/', 'json', false, 'json', request);
}

model DescribeScalingGroupV2Request {
  hostGroupBizId?: string(name='HostGroupBizId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scalingGroupBizId?: string(name='ScalingGroupBizId', position='Query'),
}

model DescribeScalingGroupV2ResponseBody = {
  activeStatus?: string(name='ActiveStatus'),
  configState?: string(name='ConfigState'),
  description?: string(name='Description'),
  hostGroupBizId?: string(name='HostGroupBizId'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  scalingGroupId?: string(name='ScalingGroupId'),
  scalingInMode?: string(name='ScalingInMode'),
  scalingMaxSize?: int32(name='ScalingMaxSize'),
  scalingMinSize?: int32(name='ScalingMinSize'),
}

model DescribeScalingGroupV2Response = {
  headers: map[string]string(name='headers'),
  body: DescribeScalingGroupV2ResponseBody(name='body'),
}

async function describeScalingGroupV2(request: DescribeScalingGroupV2Request): DescribeScalingGroupV2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeScalingGroupV2', 'POST', '/', 'json', false, 'json', request);
}

model DescribeScalingRuleRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  hostGroupId?: string(name='HostGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scalingRuleId: string(name='ScalingRuleId', position='Query'),
}

model DescribeScalingRuleResponseBody = {
  adjustmentType?: string(name='AdjustmentType'),
  adjustmentValue?: int32(name='AdjustmentValue'),
  cloudWatchTrigger?: {
    comparisonOperator?: string(name='ComparisonOperator'),
    evaluationCount?: string(name='EvaluationCount'),
    metricDisplayName?: string(name='MetricDisplayName'),
    metricName?: string(name='MetricName'),
    period?: int32(name='Period'),
    statistics?: string(name='Statistics'),
    threshold?: string(name='Threshold'),
    unit?: string(name='Unit'),
  }(name='CloudWatchTrigger'),
  cooldown?: int32(name='Cooldown'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
  ruleCategory?: string(name='RuleCategory'),
  ruleName?: string(name='RuleName'),
  schedulerTrigger?: {
    launchExpirationTime?: int32(name='LaunchExpirationTime'),
    launchTime?: long(name='LaunchTime'),
    recurrenceEndTime?: long(name='RecurrenceEndTime'),
    recurrenceType?: string(name='RecurrenceType'),
    recurrenceValue?: string(name='RecurrenceValue'),
  }(name='SchedulerTrigger'),
  status?: string(name='Status'),
  timeoutWithGrace?: long(name='TimeoutWithGrace'),
  withGrace?: boolean(name='WithGrace'),
}

model DescribeScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeScalingRuleResponseBody(name='body'),
}

async function describeScalingRule(request: DescribeScalingRuleRequest): DescribeScalingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeScalingRule', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSecurityGroupAttributeRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeSecurityGroupAttributeResponseBody = {
  availableGroupList?: {
    securityGroup?: [ 
    {
      availableInstanceAmount?: int32(name='AvailableInstanceAmount'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      ecsCount?: int32(name='EcsCount'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupName?: string(name='SecurityGroupName'),
      vpcId?: string(name='VpcId'),
    }
  ](name='SecurityGroup')
  }(name='AvailableGroupList'),
  requestId?: string(name='RequestId'),
  securityGroupAttributeList?: {
    securityGroupAttribute?: [ 
    {
      bizContent?: string(name='BizContent'),
      bizType?: string(name='BizType'),
    }
  ](name='SecurityGroupAttribute')
  }(name='SecurityGroupAttributeList'),
}

model DescribeSecurityGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityGroupAttributeResponseBody(name='body'),
}

async function describeSecurityGroupAttribute(request: DescribeSecurityGroupAttributeRequest): DescribeSecurityGroupAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecurityGroupAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DetachAndReleaseClusterEniRequest {
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  targetClusterId: string(name='TargetClusterId', position='Query'),
  vswitchId: string(name='VswitchId', position='Query'),
}

model DetachAndReleaseClusterEniResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachAndReleaseClusterEniResponse = {
  headers: map[string]string(name='headers'),
  body: DetachAndReleaseClusterEniResponseBody(name='body'),
}

async function detachAndReleaseClusterEni(request: DetachAndReleaseClusterEniRequest): DetachAndReleaseClusterEniResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachAndReleaseClusterEni', 'POST', '/', 'json', false, 'json', request);
}

model GetHdfsCapacityStatisticInfoRequest {
  clusterId: string(name='ClusterId', position='Query'),
  fromDatetime: string(name='FromDatetime', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  toDatetime: string(name='ToDatetime', position='Query'),
}

model GetHdfsCapacityStatisticInfoResponseBody = {
  hdfsCapacityList?: {
    clusterStatHdfsCapacity?: [ 
    {
      capacityRemaining?: long(name='CapacityRemaining'),
      capacityRemainingGB?: long(name='CapacityRemainingGB'),
      capacityTotal?: long(name='CapacityTotal'),
      capacityTotalGB?: long(name='CapacityTotalGB'),
      capacityUsed?: long(name='CapacityUsed'),
      capacityUsedGB?: long(name='CapacityUsedGB'),
      capacityUsedNonDfs?: long(name='CapacityUsedNonDfs'),
      clusterBizId?: string(name='ClusterBizId'),
      dateTime?: string(name='DateTime'),
    }
  ](name='ClusterStatHdfsCapacity')
  }(name='HdfsCapacityList'),
  requestId?: string(name='RequestId'),
}

model GetHdfsCapacityStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetHdfsCapacityStatisticInfoResponseBody(name='body'),
}

async function getHdfsCapacityStatisticInfo(request: GetHdfsCapacityStatisticInfoRequest): GetHdfsCapacityStatisticInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetHdfsCapacityStatisticInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetJobInputStatisticInfoRequest {
  clusterId: string(name='ClusterId', position='Query'),
  fromDatetime: string(name='FromDatetime', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  toDatetime: string(name='ToDatetime', position='Query'),
}

model GetJobInputStatisticInfoResponseBody = {
  jobInputList?: {
    clusterStatJobInput?: [ 
    {
      applicationId?: string(name='ApplicationId'),
      bytesInput?: long(name='BytesInput'),
      finishTime?: long(name='FinishTime'),
      jobId?: string(name='JobId'),
      name?: string(name='Name'),
      queue?: string(name='Queue'),
      startTime?: long(name='StartTime'),
      state?: string(name='State'),
      user?: string(name='User'),
    }
  ](name='ClusterStatJobInput')
  }(name='JobInputList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model GetJobInputStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobInputStatisticInfoResponseBody(name='body'),
}

async function getJobInputStatisticInfo(request: GetJobInputStatisticInfoRequest): GetJobInputStatisticInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetJobInputStatisticInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetJobOutputStatisticInfoRequest {
  clusterId: string(name='ClusterId', position='Query'),
  fromDatetime: string(name='FromDatetime', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  toDatetime: string(name='ToDatetime', position='Query'),
}

model GetJobOutputStatisticInfoResponseBody = {
  jobOutputList?: {
    clusterStatJobOutput?: [ 
    {
      applicationId?: string(name='ApplicationId'),
      bytesOutput?: long(name='BytesOutput'),
      finishTime?: long(name='FinishTime'),
      jobId?: string(name='JobId'),
      name?: string(name='Name'),
      queue?: string(name='Queue'),
      startTime?: long(name='StartTime'),
      state?: string(name='State'),
      user?: string(name='User'),
    }
  ](name='ClusterStatJobOutput')
  }(name='JobOutputList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model GetJobOutputStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobOutputStatisticInfoResponseBody(name='body'),
}

async function getJobOutputStatisticInfo(request: GetJobOutputStatisticInfoRequest): GetJobOutputStatisticInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetJobOutputStatisticInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetJobRunningTimeStatisticInfoRequest {
  clusterId: string(name='ClusterId', position='Query'),
  fromDatetime: string(name='FromDatetime', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  toDatetime: string(name='ToDatetime', position='Query'),
}

model GetJobRunningTimeStatisticInfoResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  runningTimeList?: {
    clusterStatJobRunningTime?: [ 
    {
      applicationId?: string(name='ApplicationId'),
      finishTime?: long(name='FinishTime'),
      jobId?: string(name='JobId'),
      name?: string(name='Name'),
      queue?: string(name='Queue'),
      runningTime?: long(name='RunningTime'),
      startTime?: long(name='StartTime'),
      state?: string(name='State'),
      user?: string(name='User'),
    }
  ](name='ClusterStatJobRunningTime')
  }(name='RunningTimeList'),
  total?: int32(name='Total'),
}

model GetJobRunningTimeStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobRunningTimeStatisticInfoResponseBody(name='body'),
}

async function getJobRunningTimeStatisticInfo(request: GetJobRunningTimeStatisticInfoRequest): GetJobRunningTimeStatisticInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetJobRunningTimeStatisticInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetQueueInputStatisticInfoRequest {
  clusterId: string(name='ClusterId', position='Query'),
  fromDatetime: string(name='FromDatetime', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  toDatetime: string(name='ToDatetime', position='Query'),
}

model GetQueueInputStatisticInfoResponseBody = {
  queueInputList?: {
    clusterStatQueueInput?: [ 
    {
      bytesInput?: long(name='BytesInput'),
      queue?: string(name='Queue'),
    }
  ](name='ClusterStatQueueInput')
  }(name='QueueInputList'),
  requestId?: string(name='RequestId'),
}

model GetQueueInputStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetQueueInputStatisticInfoResponseBody(name='body'),
}

async function getQueueInputStatisticInfo(request: GetQueueInputStatisticInfoRequest): GetQueueInputStatisticInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQueueInputStatisticInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetQueueOutputStatisticInfoRequest {
  clusterId: string(name='ClusterId', position='Query'),
  fromDatetime: string(name='FromDatetime', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  toDatetime: string(name='ToDatetime', position='Query'),
}

model GetQueueOutputStatisticInfoResponseBody = {
  queueOutputList?: {
    clusterStatQueueOutput?: [ 
    {
      bytesOutput?: long(name='BytesOutput'),
      queue?: string(name='Queue'),
    }
  ](name='ClusterStatQueueOutput')
  }(name='QueueOutputList'),
  requestId?: string(name='RequestId'),
}

model GetQueueOutputStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetQueueOutputStatisticInfoResponseBody(name='body'),
}

async function getQueueOutputStatisticInfo(request: GetQueueOutputStatisticInfoRequest): GetQueueOutputStatisticInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQueueOutputStatisticInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetQueueSubmissionStatisticInfoRequest {
  applicationType?: string(name='ApplicationType', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  finalStatus?: string(name='FinalStatus', position='Query'),
  fromDatetime: string(name='FromDatetime', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  toDatetime: string(name='ToDatetime', position='Query'),
}

model GetQueueSubmissionStatisticInfoResponseBody = {
  queueSubmissionList?: {
    clusterStatQueueSubmission?: [ 
    {
      queue?: string(name='Queue'),
      submission?: long(name='Submission'),
    }
  ](name='ClusterStatQueueSubmission')
  }(name='QueueSubmissionList'),
  requestId?: string(name='RequestId'),
}

model GetQueueSubmissionStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetQueueSubmissionStatisticInfoResponseBody(name='body'),
}

async function getQueueSubmissionStatisticInfo(request: GetQueueSubmissionStatisticInfoRequest): GetQueueSubmissionStatisticInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQueueSubmissionStatisticInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetUserInputStatisticInfoRequest {
  clusterId: string(name='ClusterId', position='Query'),
  fromDatetime: string(name='FromDatetime', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  toDatetime: string(name='ToDatetime', position='Query'),
}

model GetUserInputStatisticInfoResponseBody = {
  requestId?: string(name='RequestId'),
  userInputList?: {
    clusterStatUserInput?: [ 
    {
      bytesInput?: long(name='BytesInput'),
      user?: string(name='User'),
    }
  ](name='ClusterStatUserInput')
  }(name='UserInputList'),
}

model GetUserInputStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserInputStatisticInfoResponseBody(name='body'),
}

async function getUserInputStatisticInfo(request: GetUserInputStatisticInfoRequest): GetUserInputStatisticInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserInputStatisticInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetUserOutputStatisticInfoRequest {
  clusterId: string(name='ClusterId', position='Query'),
  fromDatetime: string(name='FromDatetime', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  toDatetime: string(name='ToDatetime', position='Query'),
}

model GetUserOutputStatisticInfoResponseBody = {
  requestId?: string(name='RequestId'),
  userOutputList?: {
    clusterStatUserOutput?: [ 
    {
      bytesOutput?: long(name='BytesOutput'),
      user?: string(name='User'),
    }
  ](name='ClusterStatUserOutput')
  }(name='UserOutputList'),
}

model GetUserOutputStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserOutputStatisticInfoResponseBody(name='body'),
}

async function getUserOutputStatisticInfo(request: GetUserOutputStatisticInfoRequest): GetUserOutputStatisticInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserOutputStatisticInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetUserSubmissionStatisticInfoRequest {
  applicationType?: string(name='ApplicationType', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  finalStatus?: string(name='FinalStatus', position='Query'),
  fromDatetime: string(name='FromDatetime', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  toDatetime: string(name='ToDatetime', position='Query'),
}

model GetUserSubmissionStatisticInfoResponseBody = {
  requestId?: string(name='RequestId'),
  userSubmissionList?: {
    clusterStatUserSubmission?: [ 
    {
      submission?: long(name='Submission'),
      user?: string(name='User'),
    }
  ](name='ClusterStatUserSubmission')
  }(name='UserSubmissionList'),
}

model GetUserSubmissionStatisticInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserSubmissionStatisticInfoResponseBody(name='body'),
}

async function getUserSubmissionStatisticInfo(request: GetUserSubmissionStatisticInfoRequest): GetUserSubmissionStatisticInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserSubmissionStatisticInfo', 'POST', '/', 'json', false, 'json', request);
}

model InstallLibrariesRequest {
  clusterBizIdList?: [ string ](name='ClusterBizIdList', position='Query'),
  libraryBizId?: string(name='LibraryBizId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model InstallLibrariesResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model InstallLibrariesResponse = {
  headers: map[string]string(name='headers'),
  body: InstallLibrariesResponseBody(name='body'),
}

async function installLibraries(request: InstallLibrariesRequest): InstallLibrariesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'InstallLibraries', 'POST', '/', 'json', false, 'json', request);
}

model JoinResourceGroupRequest {
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId: string(name='ResourceGroupId', position='Query'),
  resourceId: string(name='ResourceId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
}

model JoinResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model JoinResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: JoinResourceGroupResponseBody(name='body'),
}

async function joinResourceGroup(request: JoinResourceGroupRequest): JoinResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'JoinResourceGroup', 'POST', '/', 'json', false, 'json', request);
}

model KillFlowJobRequest {
  jobInstanceId: string(name='JobInstanceId', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model KillFlowJobResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model KillFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: KillFlowJobResponseBody(name='body'),
}

async function killFlowJob(request: KillFlowJobRequest): KillFlowJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'KillFlowJob', 'POST', '/', 'json', false, 'json', request);
}

model ListAdviceActionRequest {
  clusterId: string(name='ClusterId', position='Query'),
  component?: string(name='Component', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=500, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
}

model ListAdviceActionResponseBody = {
  items?: {
    item?: [ 
    {
      actionType?: string(name='ActionType'),
      clusterId?: string(name='ClusterId'),
      command?: string(name='Command'),
      component?: string(name='Component'),
      configItemKey?: string(name='ConfigItemKey'),
      configName?: string(name='ConfigName'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      hostgroupName?: string(name='HostgroupName'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='Item')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAdviceActionResponse = {
  headers: map[string]string(name='headers'),
  body: ListAdviceActionResponseBody(name='body'),
}

async function listAdviceAction(request: ListAdviceActionRequest): ListAdviceActionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAdviceAction', 'POST', '/', 'json', false, 'json', request);
}

model ListApmApplicationRequest {
  appId?: string(name='AppId', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  diagnoseResult?: string(name='DiagnoseResult', position='Query'),
  endTimeFrom?: long(name='EndTimeFrom', position='Query'),
  endTimeTo?: long(name='EndTimeTo', position='Query'),
  finalStatus?: string(name='FinalStatus', position='Query'),
  jobType?: string(name='JobType', position='Query'),
  name?: string(name='Name', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  queue?: string(name='Queue', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTimeFrom: long(name='StartTimeFrom', position='Query'),
  startTimeTo: long(name='StartTimeTo', position='Query'),
  state?: string(name='State', position='Query'),
  user?: string(name='User', position='Query'),
}

model ListApmApplicationResponseBody = {
  apmAppInfoList?: {
    apmAppInfo?: [ 
    {
      allocatedMemory?: long(name='AllocatedMemory'),
      allocatedVcore?: long(name='AllocatedVcore'),
      applicationId?: string(name='ApplicationId'),
      applicationType?: string(name='ApplicationType'),
      clusterBizId?: string(name='ClusterBizId'),
      clusterUsagePercent?: float(name='ClusterUsagePercent'),
      diagnoseCode?: string(name='DiagnoseCode'),
      diagnoseResult?: string(name='DiagnoseResult'),
      diagnostics?: string(name='Diagnostics'),
      duration?: int32(name='Duration'),
      finalStatus?: string(name='FinalStatus'),
      finishedTime?: long(name='FinishedTime'),
      memorySeconds?: long(name='MemorySeconds'),
      name?: string(name='Name'),
      progress?: float(name='Progress'),
      queue?: string(name='Queue'),
      queueUsagePercent?: float(name='QueueUsagePercent'),
      resourceRequests?: string(name='ResourceRequests'),
      runningContainers?: int32(name='RunningContainers'),
      runningDuration?: int32(name='RunningDuration'),
      startTime?: long(name='StartTime'),
      state?: string(name='State'),
      submitTime?: long(name='SubmitTime'),
      user?: string(name='User'),
      vcoreSeconds?: long(name='VcoreSeconds'),
    }
  ](name='ApmAppInfo')
  }(name='ApmAppInfoList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListApmApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: ListApmApplicationResponseBody(name='body'),
}

async function listApmApplication(request: ListApmApplicationRequest): ListApmApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListApmApplication', 'POST', '/', 'json', false, 'json', request);
}

model ListBackupsRequest {
  backupId?: [ string ](name='BackupId', position='Query'),
  backupPlanId?: string(name='BackupPlanId', position='Query'),
  bizId?: string(name='BizId', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  currentSize?: int32(name='CurrentSize', position='Query'),
  id?: long(name='Id', position='Query'),
  limit?: int32(name='Limit', position='Query'),
  metadataType?: string(name='MetadataType', position='Query'),
  orderMode?: string(name='OrderMode', position='Query'),
  pageCount?: int32(name='PageCount', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
  status?: string(name='Status', position='Query'),
}

model ListBackupsResponseBody = {
  items?: {
    item?: [ 
    {
      backupPlanId?: string(name='BackupPlanId'),
      clusterId?: string(name='ClusterId'),
      createTime?: long(name='CreateTime'),
      id?: string(name='Id'),
      md5?: string(name='Md5'),
      metadataInfo?: {
        metadataType?: string(name='MetadataType'),
        properties?: string(name='Properties'),
      }(name='MetadataInfo'),
      status?: string(name='Status'),
      storePath?: string(name='StorePath'),
      tarFileName?: string(name='TarFileName'),
    }
  ](name='Item')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListBackupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListBackupsResponseBody(name='body'),
}

async function listBackups(request: ListBackupsRequest): ListBackupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListBackups', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterHostRequest {
  clusterId: string(name='ClusterId', position='Query'),
  componentName?: string(name='ComponentName', position='Query'),
  groupType?: string(name='GroupType', position='Query'),
  hostGroupId?: string(name='HostGroupId', position='Query'),
  hostInstanceId?: string(name='HostInstanceId', position='Query'),
  hostName?: string(name='HostName', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  privateIp?: string(name='PrivateIp', position='Query'),
  publicIp?: string(name='PublicIp', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  statusList?: [ string ](name='StatusList', position='Query'),
}

model ListClusterHostResponseBody = {
  hostList?: {
    host?: [ 
    {
      chargeType?: string(name='ChargeType'),
      cpu?: int32(name='Cpu'),
      createTime?: string(name='CreateTime'),
      diskList?: {
        disk?: [ 
        {
          blockMountPoint?: string(name='BlockMountPoint'),
          device?: string(name='Device'),
          diskId?: string(name='DiskId'),
          diskMountPoint?: string(name='DiskMountPoint'),
          diskSize?: int32(name='DiskSize'),
          diskType?: string(name='DiskType'),
          event?: string(name='Event'),
          type?: string(name='Type'),
        }
      ](name='Disk')
      }(name='DiskList'),
      emrExpiredTime?: string(name='EmrExpiredTime'),
      expiredTime?: long(name='ExpiredTime'),
      hostGroupId?: string(name='HostGroupId'),
      hostInstanceId?: string(name='HostInstanceId'),
      hostName?: string(name='HostName'),
      instanceStatus?: string(name='InstanceStatus'),
      instanceType?: string(name='InstanceType'),
      memory?: int32(name='Memory'),
      privateIp?: string(name='PrivateIp'),
      publicIp?: string(name='PublicIp'),
      role?: string(name='Role'),
      serialNumber?: string(name='SerialNumber'),
      status?: string(name='Status'),
      supportIpV6?: boolean(name='SupportIpV6'),
      type?: string(name='Type'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Host')
  }(name='HostList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListClusterHostResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterHostResponseBody(name='body'),
}

async function listClusterHost(request: ListClusterHostRequest): ListClusterHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterHost', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterHostComponentRequest {
  clusterId: string(name='ClusterId', position='Query'),
  componentName?: string(name='ComponentName', position='Query'),
  componentStatus?: string(name='ComponentStatus', position='Query'),
  hostInstanceId?: string(name='HostInstanceId', position='Query'),
  hostName?: string(name='HostName', position='Query'),
  hostRole?: string(name='HostRole', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
}

model ListClusterHostComponentResponseBody = {
  componentList?: {
    component?: [ 
    {
      commissionStatus?: string(name='CommissionStatus'),
      componentDisplayName?: string(name='ComponentDisplayName'),
      componentName?: string(name='ComponentName'),
      cpu?: int32(name='Cpu'),
      healthReportTime?: long(name='HealthReportTime'),
      healthStatus?: string(name='HealthStatus'),
      hostId?: string(name='HostId'),
      hostInstanceId?: string(name='HostInstanceId'),
      hostName?: string(name='HostName'),
      instanceType?: string(name='InstanceType'),
      memory?: int32(name='Memory'),
      needRestart?: boolean(name='NeedRestart'),
      privateIp?: string(name='PrivateIp'),
      publicIp?: string(name='PublicIp'),
      role?: string(name='Role'),
      serialNumber?: string(name='SerialNumber'),
      serverStatus?: string(name='ServerStatus'),
      serviceDisplayName?: string(name='ServiceDisplayName'),
      serviceName?: string(name='ServiceName'),
      state?: string(name='State'),
      status?: string(name='Status'),
    }
  ](name='Component')
  }(name='ComponentList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListClusterHostComponentResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterHostComponentResponseBody(name='body'),
}

async function listClusterHostComponent(request: ListClusterHostComponentRequest): ListClusterHostComponentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterHostComponent', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterHostGroupRequest {
  clusterId: string(name='ClusterId', position='Query'),
  hostGroupId?: string(name='HostGroupId', position='Query'),
  hostGroupName?: string(name='HostGroupName', position='Query'),
  hostGroupType?: string(name='HostGroupType', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  statusList?: [ string ](name='StatusList', position='Query'),
}

model ListClusterHostGroupResponseBody = {
  clusterId?: string(name='ClusterId'),
  hostGroupList?: {
    hostGroup?: [ 
    {
      chargeType?: string(name='ChargeType'),
      comment?: string(name='Comment'),
      costSavingPercent?: float(name='CostSavingPercent'),
      cpu?: int32(name='Cpu'),
      dataDiskCount?: int32(name='DataDiskCount'),
      dataDiskSize?: int32(name='DataDiskSize'),
      dataDiskType?: string(name='DataDiskType'),
      hostGroupChangeStatus?: string(name='HostGroupChangeStatus'),
      hostGroupChangeType?: string(name='HostGroupChangeType'),
      hostGroupId?: string(name='HostGroupId'),
      hostGroupName?: string(name='HostGroupName'),
      hostGroupSubType?: string(name='HostGroupSubType'),
      hostGroupType?: string(name='HostGroupType'),
      instanceType?: string(name='InstanceType'),
      lockReason?: string(name='LockReason'),
      lockType?: string(name='LockType'),
      memory?: int32(name='Memory'),
      nodeCount?: int32(name='NodeCount'),
      payType?: string(name='PayType'),
      scalingGroupActiveStatus?: string(name='ScalingGroupActiveStatus'),
      scalingGroupBizId?: string(name='ScalingGroupBizId'),
      scalingGroupConfigState?: string(name='ScalingGroupConfigState'),
      scalingGroupMaxNode?: int32(name='ScalingGroupMaxNode'),
      scalingGroupMinNode?: int32(name='ScalingGroupMinNode'),
      scalingInMode?: string(name='ScalingInMode'),
      securityGroupId?: string(name='SecurityGroupId'),
      status?: string(name='Status'),
      systemDiskCount?: int32(name='SystemDiskCount'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      systemDiskType?: string(name='SystemDiskType'),
      vswitchId?: string(name='VswitchId'),
      gmtCreate?: string(name='gmtCreate'),
      gmtModified?: string(name='gmtModified'),
    }
  ](name='HostGroup')
  }(name='HostGroupList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListClusterHostGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterHostGroupResponseBody(name='body'),
}

async function listClusterHostGroup(request: ListClusterHostGroupRequest): ListClusterHostGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterHostGroup', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterInstalledServiceRequest {
  clusterId: string(name='ClusterId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListClusterInstalledServiceResponseBody = {
  clusterInstalledServiceList?: {
    clusterInstalledService?: [ 
    {
      serviceActionList?: {
        serviceAction?: [ 
        {
          actionName?: string(name='ActionName'),
          command?: string(name='Command'),
          componentName?: string(name='ComponentName'),
          displayName?: string(name='DisplayName'),
          serviceName?: string(name='ServiceName'),
        }
      ](name='ServiceAction')
      }(name='ServiceActionList'),
      serviceDisplayName?: string(name='ServiceDisplayName'),
      serviceEcmVersion?: string(name='ServiceEcmVersion'),
      serviceName?: string(name='ServiceName'),
      serviceVersion?: string(name='ServiceVersion'),
      state?: string(name='State'),
      abnormalNum?: int32(name='abnormalNum'),
      comment?: string(name='comment'),
      needRestartNum?: int32(name='needRestartNum'),
      notStartedNum?: int32(name='notStartedNum'),
      onlyClient?: boolean(name='onlyClient'),
      serviceStatus?: string(name='serviceStatus'),
    }
  ](name='ClusterInstalledService')
  }(name='ClusterInstalledServiceList'),
  requestId?: string(name='RequestId'),
}

model ListClusterInstalledServiceResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterInstalledServiceResponseBody(name='body'),
}

async function listClusterInstalledService(request: ListClusterInstalledServiceRequest): ListClusterInstalledServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterInstalledService', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterOperationRequest {
  clusterId: string(name='ClusterId', position='Query'),
  operationId?: string(name='OperationId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
  status?: string(name='Status', position='Query'),
}

model ListClusterOperationResponseBody = {
  clusterOperationList?: {
    clusterOperation?: [ 
    {
      comment?: string(name='Comment'),
      duration?: string(name='Duration'),
      operationId?: string(name='OperationId'),
      operationName?: string(name='OperationName'),
      percentage?: string(name='Percentage'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
    }
  ](name='ClusterOperation')
  }(name='ClusterOperationList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListClusterOperationResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterOperationResponseBody(name='body'),
}

async function listClusterOperation(request: ListClusterOperationRequest): ListClusterOperationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterOperation', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterOperationHostRequest {
  clusterId: string(name='ClusterId', position='Query'),
  operationId: string(name='OperationId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
}

model ListClusterOperationHostResponseBody = {
  clusterOperationHostList?: {
    clusterOperationHost?: [ 
    {
      hostId?: string(name='HostId'),
      hostName?: string(name='HostName'),
      percentage?: string(name='Percentage'),
      status?: string(name='Status'),
    }
  ](name='ClusterOperationHost')
  }(name='ClusterOperationHostList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListClusterOperationHostResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterOperationHostResponseBody(name='body'),
}

async function listClusterOperationHost(request: ListClusterOperationHostRequest): ListClusterOperationHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterOperationHost', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterOperationHostTaskRequest {
  clusterId: string(name='ClusterId', position='Query'),
  hostId: string(name='HostId', position='Query'),
  operationId: string(name='OperationId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
}

model ListClusterOperationHostTaskResponseBody = {
  clusterOperationHostTaskList?: {
    clusterOperationHostTask?: [ 
    {
      percentage?: string(name='Percentage'),
      status?: string(name='Status'),
      taskId?: string(name='TaskId'),
      taskName?: string(name='TaskName'),
    }
  ](name='ClusterOperationHostTask')
  }(name='ClusterOperationHostTaskList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListClusterOperationHostTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterOperationHostTaskResponseBody(name='body'),
}

async function listClusterOperationHostTask(request: ListClusterOperationHostTaskRequest): ListClusterOperationHostTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterOperationHostTask', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterOperationTaskRequest {
  clusterId: string(name='ClusterId', position='Query'),
  operationId: string(name='OperationId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
}

model ListClusterOperationTaskResponseBody = {
  clusterOperationTaskList?: {
    clusterOperationTask?: [ 
    {
      percentage?: string(name='Percentage'),
      status?: string(name='Status'),
      taskId?: string(name='TaskId'),
      taskName?: string(name='TaskName'),
    }
  ](name='ClusterOperationTask')
  }(name='ClusterOperationTaskList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListClusterOperationTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterOperationTaskResponseBody(name='body'),
}

async function listClusterOperationTask(request: ListClusterOperationTaskRequest): ListClusterOperationTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterOperationTask', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterServiceRequest {
  clusterId: string(name='ClusterId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListClusterServiceResponseBody = {
  clusterServiceList?: {
    clusterService?: [ 
    {
      abnormalNum?: int32(name='AbnormalNum'),
      clientType?: boolean(name='ClientType'),
      healthStatus?: string(name='HealthStatus'),
      installStatus?: boolean(name='InstallStatus'),
      needRestartInfo?: string(name='NeedRestartInfo'),
      needRestartNum?: int32(name='NeedRestartNum'),
      notStartInfo?: string(name='NotStartInfo'),
      serviceActionList?: {
        serviceAction?: [ 
        {
          actionName?: string(name='ActionName'),
          command?: string(name='Command'),
          componentName?: string(name='ComponentName'),
          displayName?: string(name='DisplayName'),
          serviceName?: string(name='ServiceName'),
        }
      ](name='ServiceAction')
      }(name='ServiceActionList'),
      serviceDisplayName?: string(name='ServiceDisplayName'),
      serviceName?: string(name='ServiceName'),
      serviceStatus?: string(name='ServiceStatus'),
      serviceVersion?: string(name='ServiceVersion'),
      state?: string(name='State'),
      stoppedNum?: int32(name='StoppedNum'),
    }
  ](name='ClusterService')
  }(name='ClusterServiceList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListClusterServiceResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterServiceResponseBody(name='body'),
}

async function listClusterService(request: ListClusterServiceRequest): ListClusterServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterService', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterServiceComponentRequest {
  clusterId: string(name='ClusterId', position='Query'),
  componentName?: string(name='ComponentName', position='Query'),
  componentStatus?: string(name='ComponentStatus', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  podName?: string(name='PodName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
}

model ListClusterServiceComponentResponseBody = {
  componentList?: {
    component?: [ 
    {
      commissionStatus?: string(name='CommissionStatus'),
      componentDisplayName?: string(name='ComponentDisplayName'),
      componentName?: string(name='ComponentName'),
      desiredCount?: int32(name='DesiredCount'),
      namespace?: string(name='Namespace'),
      needRestart?: boolean(name='NeedRestart'),
      podName?: string(name='PodName'),
      privateIp?: string(name='PrivateIp'),
      publicIp?: string(name='PublicIp'),
      role?: string(name='Role'),
      serverStatus?: string(name='ServerStatus'),
      serviceDisplayName?: string(name='ServiceDisplayName'),
      serviceName?: string(name='ServiceName'),
      status?: string(name='Status'),
      workloadName?: string(name='WorkloadName'),
      workloadType?: string(name='WorkloadType'),
    }
  ](name='Component')
  }(name='ComponentList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListClusterServiceComponentResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterServiceComponentResponseBody(name='body'),
}

async function listClusterServiceComponent(request: ListClusterServiceComponentRequest): ListClusterServiceComponentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterServiceComponent', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterServiceComponentHealthInfoRequest {
  clusterId: string(name='ClusterId', position='Query'),
  componentName?: string(name='ComponentName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
}

model ListClusterServiceComponentHealthInfoResponseBody = {
  clusterId?: string(name='ClusterId'),
  healthInfoList?: {
    healthInfo?: [ 
    {
      agentHeartBeatLostNum?: int32(name='AgentHeartBeatLostNum'),
      badHealthNum?: int32(name='BadHealthNum'),
      componentName?: string(name='ComponentName'),
      createdTime?: long(name='CreatedTime'),
      disabledHealthNum?: int32(name='DisabledHealthNum'),
      goodHealthNum?: int32(name='GoodHealthNum'),
      healthDetailList?: {
        healthDetail?: [ 
        {
          healthRuleParam?: {
            component?: string(name='Component'),
            hostNames?: string(name='HostNames'),
            pass?: string(name='Pass'),
            ruleDescription?: string(name='RuleDescription'),
            ruleId?: string(name='RuleId'),
            ruleTitle?: string(name='RuleTitle'),
            service?: string(name='Service'),
          }(name='HealthRuleParam'),
          code?: string(name='code'),
        }
      ](name='HealthDetail')
      }(name='HealthDetailList'),
      healthLevel?: string(name='HealthLevel'),
      healthStatus?: string(name='HealthStatus'),
      manualStoppedNum?: int32(name='ManualStoppedNum'),
      noneHealthNum?: int32(name='NoneHealthNum'),
      normalNum?: int32(name='NormalNum'),
      serviceName?: string(name='ServiceName'),
      stoppedHealthNum?: int32(name='StoppedHealthNum'),
      stoppedNum?: int32(name='StoppedNum'),
      totalNum?: int32(name='TotalNum'),
      unknownHealthNum?: int32(name='UnknownHealthNum'),
      warningHealthNum?: int32(name='WarningHealthNum'),
    }
  ](name='HealthInfo')
  }(name='HealthInfoList'),
  requestId?: string(name='RequestId'),
}

model ListClusterServiceComponentHealthInfoResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterServiceComponentHealthInfoResponseBody(name='body'),
}

async function listClusterServiceComponentHealthInfo(request: ListClusterServiceComponentHealthInfoRequest): ListClusterServiceComponentHealthInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterServiceComponentHealthInfo', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterServiceConfigHistoryRequest {
  author?: string(name='Author', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  comment?: string(name='Comment', position='Query'),
  configFileName?: string(name='ConfigFileName', position='Query'),
  configItemKey?: string(name='ConfigItemKey', position='Query'),
  configVersion?: string(name='ConfigVersion', position='Query'),
  hostGroupId?: string(name='HostGroupId', position='Query'),
  hostInstanceId?: string(name='HostInstanceId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
}

model ListClusterServiceConfigHistoryResponseBody = {
  configHistoryList?: {
    configHistory?: [ 
    {
      applied?: boolean(name='Applied'),
      author?: string(name='Author'),
      comment?: string(name='Comment'),
      configFileName?: string(name='ConfigFileName'),
      configItemName?: string(name='ConfigItemName'),
      configVersion?: string(name='ConfigVersion'),
      createTime?: long(name='CreateTime'),
      hostGroupId?: string(name='HostGroupId'),
      hostGroupName?: string(name='HostGroupName'),
      hostInstanceId?: string(name='HostInstanceId'),
      hostName?: string(name='HostName'),
      newValue?: string(name='NewValue'),
      oldValue?: string(name='OldValue'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='ConfigHistory')
  }(name='ConfigHistoryList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListClusterServiceConfigHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterServiceConfigHistoryResponseBody(name='body'),
}

async function listClusterServiceConfigHistory(request: ListClusterServiceConfigHistoryRequest): ListClusterServiceConfigHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterServiceConfigHistory', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterServiceQuickLinkRequest {
  clusterId: string(name='ClusterId', position='Query'),
  directType?: boolean(name='DirectType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
}

model ListClusterServiceQuickLinkResponseBody = {
  quickLinkList?: {
    quickLink?: [ 
    {
      port?: string(name='Port'),
      protocol?: string(name='Protocol'),
      quickLinkAddress?: string(name='QuickLinkAddress'),
      serviceDisplayName?: string(name='ServiceDisplayName'),
      serviceName?: string(name='ServiceName'),
      type?: string(name='Type'),
    }
  ](name='QuickLink')
  }(name='QuickLinkList'),
  requestId?: string(name='RequestId'),
}

model ListClusterServiceQuickLinkResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterServiceQuickLinkResponseBody(name='body'),
}

async function listClusterServiceQuickLink(request: ListClusterServiceQuickLinkRequest): ListClusterServiceQuickLinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterServiceQuickLink', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterTemplatesRequest {
  bizId?: string(name='BizId', position='Query'),
  pageNumber: int32(name='PageNumber', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  productType?: string(name='ProductType', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListClusterTemplatesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  templateInfoList?: {
    templateInfo?: [ 
    {
      allowNotebook?: boolean(name='AllowNotebook'),
      bootstrapActionList?: {
        bootstrapAction?: [ 
        {
          arg?: string(name='Arg'),
          name?: string(name='Name'),
          path?: string(name='Path'),
        }
      ](name='BootstrapAction')
      }(name='BootstrapActionList'),
      clusterType?: string(name='ClusterType'),
      configList?: {
        config?: [ 
        {
          configKey?: string(name='ConfigKey'),
          configValue?: string(name='ConfigValue'),
          encrypt?: string(name='Encrypt'),
          fileName?: string(name='FileName'),
          replace?: string(name='Replace'),
          serviceName?: string(name='ServiceName'),
        }
      ](name='Config')
      }(name='ConfigList'),
      configurations?: string(name='Configurations'),
      createSource?: string(name='CreateSource'),
      depositType?: string(name='DepositType'),
      easEnable?: boolean(name='EasEnable'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
      hostGroupList?: {
        hostGroup?: [ 
        {
          chargeType?: string(name='ChargeType'),
          diskCapacity?: int32(name='DiskCapacity'),
          diskCount?: int32(name='DiskCount'),
          diskType?: string(name='DiskType'),
          hostGroupId?: string(name='HostGroupId'),
          hostGroupName?: string(name='HostGroupName'),
          hostGroupType?: string(name='HostGroupType'),
          instanceType?: string(name='InstanceType'),
          multiInstanceTypes?: string(name='MultiInstanceTypes'),
          nodeCount?: int32(name='NodeCount'),
          period?: string(name='Period'),
          sysDiskCapacity?: int32(name='SysDiskCapacity'),
          sysDiskType?: string(name='SysDiskType'),
        }
      ](name='HostGroup')
      }(name='HostGroupList'),
      id?: string(name='Id'),
      initCustomHiveMetaDb?: boolean(name='InitCustomHiveMetaDb'),
      instanceGeneration?: string(name='InstanceGeneration'),
      ioOptimized?: boolean(name='IoOptimized'),
      isOpenPublicIp?: boolean(name='IsOpenPublicIp'),
      keyPairName?: string(name='KeyPairName'),
      logEnable?: boolean(name='LogEnable'),
      logPath?: string(name='LogPath'),
      machineType?: string(name='MachineType'),
      masterNodeTotal?: int32(name='MasterNodeTotal'),
      metaStoreConf?: string(name='MetaStoreConf'),
      metaStoreType?: string(name='MetaStoreType'),
      netType?: string(name='NetType'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupName?: string(name='SecurityGroupName'),
      softwareInfoList?: {
        softwareInfo?: [ string ](name='SoftwareInfo')
      }(name='SoftwareInfoList'),
      sshEnable?: boolean(name='SshEnable'),
      templateName?: string(name='TemplateName'),
      useCustomHiveMetaDb?: boolean(name='UseCustomHiveMetaDb'),
      useLocalMetaDb?: boolean(name='UseLocalMetaDb'),
      userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
      userId?: string(name='UserId'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='TemplateInfo')
  }(name='TemplateInfoList'),
  totalCount?: int32(name='TotalCount'),
}

model ListClusterTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterTemplatesResponseBody(name='body'),
}

async function listClusterTemplates(request: ListClusterTemplatesRequest): ListClusterTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterTemplates', 'POST', '/', 'json', false, 'json', request);
}

model ListClustersRequest {
  clusterTypeList?: [ string ](name='ClusterTypeList', position='Query'),
  createType?: string(name='CreateType', position='Query'),
  defaultStatus?: boolean(name='DefaultStatus', position='Query'),
  depositType?: string(name='DepositType', position='Query'),
  expiredTagList?: [ string ](name='ExpiredTagList', position='Query'),
  isDesc?: boolean(name='IsDesc', position='Query'),
  machineType?: string(name='MachineType', position='Query'),
  name?: string(name='Name', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=500, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  statusList?: [ string ](name='StatusList', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model ListClustersResponseBody = {
  clusters?: {
    clusterInfo?: [ 
    {
      chargeType?: string(name='ChargeType'),
      createResource?: string(name='CreateResource'),
      createTime?: long(name='CreateTime'),
      depositType?: string(name='DepositType'),
      expiredTime?: long(name='ExpiredTime'),
      failReason?: {
        errorCode?: string(name='ErrorCode'),
        errorMsg?: string(name='ErrorMsg'),
        requestId?: string(name='RequestId'),
      }(name='FailReason'),
      hasUncompletedOrder?: boolean(name='HasUncompletedOrder'),
      id?: string(name='Id'),
      k8sClusterId?: string(name='K8sClusterId'),
      machineType?: string(name='MachineType'),
      metaStoreType?: string(name='MetaStoreType'),
      name?: string(name='Name'),
      operationId?: long(name='OperationId'),
      orderList?: string(name='OrderList'),
      orderTaskInfo?: {
        currentCount?: int32(name='CurrentCount'),
        orderIdList?: string(name='OrderIdList'),
        targetCount?: int32(name='TargetCount'),
      }(name='OrderTaskInfo'),
      period?: int32(name='Period'),
      runningTime?: int32(name='RunningTime'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      type?: string(name='Type'),
    }
  ](name='ClusterInfo')
  }(name='Clusters'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListClustersResponseBody(name='body'),
}

async function listClusters(request: ListClustersRequest): ListClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusters', 'POST', '/', 'json', false, 'json', request);
}

model ListDataSourceRequest {
  createFrom?: string(name='CreateFrom', position='Query'),
  id?: string(name='Id', position='Query'),
  name?: string(name='Name', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  projectId?: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
}

model ListDataSourceResponseBody = {
  dataSourceList?: {
    dataSource?: [ 
    {
      clusterId?: string(name='ClusterId'),
      conf?: string(name='Conf'),
      createFrom?: string(name='CreateFrom'),
      creator?: string(name='Creator'),
      description?: string(name='Description'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      id?: string(name='Id'),
      modifier?: string(name='Modifier'),
      name?: string(name='Name'),
      sourceType?: string(name='SourceType'),
      status?: string(name='Status'),
    }
  ](name='DataSource')
  }(name='DataSourceList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataSourceResponseBody(name='body'),
}

async function listDataSource(request: ListDataSourceRequest): ListDataSourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataSource', 'POST', '/', 'json', false, 'json', request);
}

model ListDiskOpsEventsRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  endTime?: long(name='EndTime', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: long(name='StartTime', position='Query'),
}

model ListDiskOpsEventsResponseBody = {
  eventList?: {
    diskOpsEventInfo?: [ 
    {
      clusterBizId?: string(name='ClusterBizId'),
      clusterName?: string(name='ClusterName'),
      currentActivity?: string(name='CurrentActivity'),
      currentActivityState?: string(name='CurrentActivityState'),
      diskDevice?: string(name='DiskDevice'),
      diskId?: string(name='DiskId'),
      diskMountPoint?: string(name='DiskMountPoint'),
      eventId?: string(name='EventId'),
      eventTriggerTime?: long(name='EventTriggerTime'),
      eventType?: string(name='EventType'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      instanceStatus?: string(name='InstanceStatus'),
      privateIp?: string(name='PrivateIp'),
      regionId?: string(name='RegionId'),
      userId?: string(name='UserId'),
    }
  ](name='DiskOpsEventInfo')
  }(name='EventList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListDiskOpsEventsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDiskOpsEventsResponseBody(name='body'),
}

async function listDiskOpsEvents(request: ListDiskOpsEventsRequest): ListDiskOpsEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDiskOpsEvents', 'POST', '/', 'json', false, 'json', request);
}

model ListEmrAvailableConfigRequest {
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListEmrAvailableConfigResponseBody = {
  emrMainVersionList?: {
    emrMainVersion?: [ 
    {
      clusterTypeInfoList?: {
        clusterTypeInfo?: [ 
        {
          clusterServiceInfoList?: {
            clusterServiceInfo?: [ 
            {
              mandatory?: boolean(name='Mandatory'),
              serviceDisplayName?: string(name='ServiceDisplayName'),
              serviceName?: string(name='ServiceName'),
              serviceVersion?: string(name='ServiceVersion'),
            }
          ](name='ClusterServiceInfo')
          }(name='ClusterServiceInfoList'),
          clusterType?: string(name='ClusterType'),
        }
      ](name='ClusterTypeInfo')
      }(name='ClusterTypeInfoList'),
      ecmVersion?: boolean(name='EcmVersion'),
      extraInfo?: string(name='ExtraInfo'),
      mainVersionName?: string(name='MainVersionName'),
      onCloudNative?: boolean(name='OnCloudNative'),
      publishType?: string(name='PublishType'),
      regionId?: string(name='RegionId'),
      stackName?: string(name='StackName'),
      stackVersion?: string(name='StackVersion'),
    }
  ](name='EmrMainVersion')
  }(name='EmrMainVersionList'),
  keyPairNameList?: {
    keyPairName?: [ string ](name='KeyPairName')
  }(name='KeyPairNameList'),
  requestId?: string(name='RequestId'),
  securityGroupList?: {
    securityGroup?: [ 
    {
      availableInstanceAmount?: int32(name='AvailableInstanceAmount'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      ecsCount?: int32(name='EcsCount'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupName?: string(name='SecurityGroupName'),
      securityGroupType?: string(name='SecurityGroupType'),
      vpcId?: string(name='VpcId'),
    }
  ](name='SecurityGroup')
  }(name='SecurityGroupList'),
  vpcInfoList?: {
    vpcInfo?: [ 
    {
      cidrBlock?: string(name='CidrBlock'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      VRouterId?: string(name='VRouterId'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
      vswitchInfoList?: {
        vswitchInfo?: [ 
        {
          availableIpAddressCount?: long(name='AvailableIpAddressCount'),
          cidrBlock?: string(name='CidrBlock'),
          creationTime?: string(name='CreationTime'),
          description?: string(name='Description'),
          vpcId?: string(name='VpcId'),
          vswitchId?: string(name='VswitchId'),
          vswitchName?: string(name='VswitchName'),
          zoneId?: string(name='ZoneId'),
        }
      ](name='VswitchInfo')
      }(name='VswitchInfoList'),
    }
  ](name='VpcInfo')
  }(name='VpcInfoList'),
}

model ListEmrAvailableConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ListEmrAvailableConfigResponseBody(name='body'),
}

async function listEmrAvailableConfig(request: ListEmrAvailableConfigRequest): ListEmrAvailableConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEmrAvailableConfig', 'POST', '/', 'json', false, 'json', request);
}

model ListEmrAvailableResourceRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  clusterType: string(name='ClusterType', position='Query'),
  dataDiskType?: string(name='DataDiskType', position='Query'),
  depositType?: string(name='DepositType', position='Query'),
  destinationResource: string(name='DestinationResource', position='Query'),
  emrVersion?: string(name='EmrVersion', position='Query'),
  instanceChargeType: string(name='InstanceChargeType', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  netType?: string(name='NetType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  spotStrategy?: string(name='SpotStrategy', position='Query'),
  systemDiskType?: string(name='SystemDiskType', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ListEmrAvailableResourceResponseBody = {
  emrZoneInfoList?: {
    emrZoneInfo?: [ 
    {
      emrResourceInfoList?: {
        emrResourceInfo?: [ 
        {
          supportedResourceList?: {
            supportedResource?: [ 
            {
              emrInstanceType?: {
                baselineCredit?: int32(name='BaselineCredit'),
                cpuCoreCount?: int32(name='CpuCoreCount'),
                eniQuantity?: int32(name='EniQuantity'),
                GPUAmount?: int32(name='GPUAmount'),
                GPUSpec?: string(name='GPUSpec'),
                initialCredit?: int32(name='InitialCredit'),
                instanceBandwidthRx?: int32(name='InstanceBandwidthRx'),
                instanceBandwidthTx?: int32(name='InstanceBandwidthTx'),
                instancePpsRx?: long(name='InstancePpsRx'),
                instancePpsTx?: long(name='InstancePpsTx'),
                instanceType?: string(name='InstanceType'),
                instanceTypeFamily?: string(name='InstanceTypeFamily'),
                localStorageAmount?: int32(name='LocalStorageAmount'),
                localStorageCapacity?: long(name='LocalStorageCapacity'),
                localStorageCategory?: string(name='LocalStorageCategory'),
                memorySize?: int32(name='MemorySize'),
              }(name='EmrInstanceType'),
              max?: int32(name='Max'),
              min?: int32(name='Min'),
              supportNodeTypeList?: {
                supportNodeType?: [ string ](name='SupportNodeType')
              }(name='SupportNodeTypeList'),
              unit?: string(name='Unit'),
              value?: string(name='Value'),
            }
          ](name='SupportedResource')
          }(name='SupportedResourceList'),
          type?: string(name='Type'),
        }
      ](name='EmrResourceInfo')
      }(name='EmrResourceInfoList'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='EmrZoneInfo')
  }(name='EmrZoneInfoList'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
}

model ListEmrAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  body: ListEmrAvailableResourceResponseBody(name='body'),
}

async function listEmrAvailableResource(request: ListEmrAvailableResourceRequest): ListEmrAvailableResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEmrAvailableResource', 'POST', '/', 'json', false, 'json', request);
}

model ListEmrMainVersionRequest {
  emrVersion?: string(name='EmrVersion', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  stackName?: string(name='StackName', position='Query'),
  stackVersion?: string(name='StackVersion', position='Query'),
}

model ListEmrMainVersionResponseBody = {
  emrMainVersionList?: {
    emrMainVersion?: [ 
    {
      clusterTypeInfoList?: {
        clusterTypeInfo?: [ 
        {
          clusterType?: string(name='ClusterType'),
          serviceInfoList?: {
            serviceInfo?: [ 
            {
              display?: boolean(name='Display'),
              mandatory?: boolean(name='Mandatory'),
              serviceDisplayName?: string(name='ServiceDisplayName'),
              serviceDisplayVersion?: string(name='ServiceDisplayVersion'),
              serviceName?: string(name='ServiceName'),
              serviceVersion?: string(name='ServiceVersion'),
            }
          ](name='ServiceInfo')
          }(name='ServiceInfoList'),
        }
      ](name='ClusterTypeInfo')
      }(name='ClusterTypeInfoList'),
      clusterTypeWhiteUserList?: {
        clusterTypeWhiteUser?: [ 
        {
          clusterType?: string(name='ClusterType'),
          userId?: string(name='UserId'),
        }
      ](name='ClusterTypeWhiteUser')
      }(name='ClusterTypeWhiteUserList'),
      display?: boolean(name='Display'),
      ecmVersion?: boolean(name='EcmVersion'),
      emrVersion?: string(name='EmrVersion'),
      imageId?: string(name='ImageId'),
      publishType?: string(name='PublishType'),
      regionId?: string(name='RegionId'),
      stackName?: string(name='StackName'),
      stackVersion?: string(name='StackVersion'),
      whiteUserList?: {
        whiteUser?: [ string ](name='WhiteUser')
      }(name='WhiteUserList'),
    }
  ](name='EmrMainVersion')
  }(name='EmrMainVersionList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListEmrMainVersionResponse = {
  headers: map[string]string(name='headers'),
  body: ListEmrMainVersionResponseBody(name='body'),
}

async function listEmrMainVersion(request: ListEmrMainVersionRequest): ListEmrMainVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEmrMainVersion', 'POST', '/', 'json', false, 'json', request);
}

model ListExecutionPlanInstancesRequest {
  executionPlanIdList: [ string ](name='ExecutionPlanIdList', position='Query'),
  isDesc?: boolean(name='IsDesc', position='Query'),
  onlyLastInstance?: boolean(name='OnlyLastInstance', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=500, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  statusList?: [ string ](name='StatusList', position='Query'),
}

model ListExecutionPlanInstancesResponseBody = {
  executionPlanInstances?: {
    executionPlanInstance?: [ 
    {
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      executionPlanId?: string(name='ExecutionPlanId'),
      executionPlanName?: string(name='ExecutionPlanName'),
      id?: string(name='Id'),
      logEnable?: boolean(name='LogEnable'),
      logPath?: string(name='LogPath'),
      runTime?: int32(name='RunTime'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      workflowApp?: string(name='WorkflowApp'),
    }
  ](name='ExecutionPlanInstance')
  }(name='ExecutionPlanInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListExecutionPlanInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListExecutionPlanInstancesResponseBody(name='body'),
}

async function listExecutionPlanInstances(request: ListExecutionPlanInstancesRequest): ListExecutionPlanInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListExecutionPlanInstances', 'POST', '/', 'json', false, 'json', request);
}

model ListFlowRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  id?: string(name='Id', position='Query'),
  jobId?: string(name='JobId', position='Query'),
  name?: string(name='Name', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  periodic?: boolean(name='Periodic', position='Query'),
  projectId?: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  status?: string(name='Status', position='Query'),
}

model ListFlowResponseBody = {
  flow?: {
    flow?: [ 
    {
      alertConf?: string(name='AlertConf'),
      alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
      alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
      categoryId?: string(name='CategoryId'),
      clusterId?: string(name='ClusterId'),
      createCluster?: boolean(name='CreateCluster'),
      cronExpr?: string(name='CronExpr'),
      description?: string(name='Description'),
      endSchedule?: long(name='EndSchedule'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      graph?: string(name='Graph'),
      hostName?: string(name='HostName'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      periodic?: boolean(name='Periodic'),
      projectId?: string(name='ProjectId'),
      startSchedule?: long(name='StartSchedule'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='Flow')
  }(name='Flow'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListFlowResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowResponseBody(name='body'),
}

async function listFlow(request: ListFlowRequest): ListFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlow', 'POST', '/', 'json', false, 'json', request);
}

model ListFlowCategoryRequest {
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  parentId?: string(name='ParentId', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  root?: boolean(name='Root', position='Query'),
}

model ListFlowCategoryResponseBody = {
  categories?: {
    category?: [ 
    {
      categoryType?: string(name='CategoryType'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      objectId?: string(name='ObjectId'),
      objectType?: string(name='ObjectType'),
      parentId?: string(name='ParentId'),
      projectId?: string(name='ProjectId'),
      type?: string(name='Type'),
    }
  ](name='Category')
  }(name='Categories'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListFlowCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowCategoryResponseBody(name='body'),
}

async function listFlowCategory(request: ListFlowCategoryRequest): ListFlowCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlowCategory', 'POST', '/', 'json', false, 'json', request);
}

model ListFlowClusterRequest {
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
}

model ListFlowClusterResponseBody = {
  clusters?: {
    clusterInfo?: [ 
    {
      chargeType?: string(name='ChargeType'),
      createResource?: string(name='CreateResource'),
      createTime?: long(name='CreateTime'),
      expiredTime?: long(name='ExpiredTime'),
      failReason?: {
        errorCode?: string(name='ErrorCode'),
        errorMsg?: string(name='ErrorMsg'),
        requestId?: string(name='RequestId'),
      }(name='FailReason'),
      hasUncompletedOrder?: boolean(name='HasUncompletedOrder'),
      id?: string(name='Id'),
      k8sClusterId?: string(name='K8sClusterId'),
      name?: string(name='Name'),
      orderList?: string(name='OrderList'),
      orderTaskInfo?: {
        currentCount?: int32(name='CurrentCount'),
        orderIdList?: string(name='OrderIdList'),
        targetCount?: int32(name='TargetCount'),
      }(name='OrderTaskInfo'),
      period?: int32(name='Period'),
      runningTime?: int32(name='RunningTime'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='ClusterInfo')
  }(name='Clusters'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListFlowClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowClusterResponseBody(name='body'),
}

async function listFlowCluster(request: ListFlowClusterRequest): ListFlowClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlowCluster', 'POST', '/', 'json', false, 'json', request);
}

model ListFlowClusterAllRequest {
  productType?: string(name='ProductType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
}

model ListFlowClusterAllResponseBody = {
  clusters?: {
    clusterInfo?: [ 
    {
      chargeType?: string(name='ChargeType'),
      createResource?: string(name='CreateResource'),
      createTime?: long(name='CreateTime'),
      expiredTime?: long(name='ExpiredTime'),
      failReason?: {
        errorCode?: string(name='ErrorCode'),
        errorMsg?: string(name='ErrorMsg'),
        requestId?: string(name='RequestId'),
      }(name='FailReason'),
      hasUncompletedOrder?: boolean(name='HasUncompletedOrder'),
      id?: string(name='Id'),
      k8sClusterId?: string(name='K8sClusterId'),
      name?: string(name='Name'),
      orderList?: string(name='OrderList'),
      orderTaskInfo?: {
        currentCount?: int32(name='CurrentCount'),
        orderIdList?: string(name='OrderIdList'),
        targetCount?: int32(name='TargetCount'),
      }(name='OrderTaskInfo'),
      period?: int32(name='Period'),
      runningTime?: int32(name='RunningTime'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='ClusterInfo')
  }(name='Clusters'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListFlowClusterAllResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowClusterAllResponseBody(name='body'),
}

async function listFlowClusterAll(request: ListFlowClusterAllRequest): ListFlowClusterAllResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlowClusterAll', 'POST', '/', 'json', false, 'json', request);
}

model ListFlowClusterAllHostsRequest {
  clusterId: string(name='ClusterId', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
}

model ListFlowClusterAllHostsResponseBody = {
  hostList?: {
    host?: [ 
    {
      cpu?: int32(name='Cpu'),
      hostId?: string(name='HostId'),
      hostInstanceId?: string(name='HostInstanceId'),
      hostName?: string(name='HostName'),
      instanceType?: string(name='InstanceType'),
      memory?: int32(name='Memory'),
      privateIp?: string(name='PrivateIp'),
      publicIp?: string(name='PublicIp'),
      role?: string(name='Role'),
      serialNumber?: string(name='SerialNumber'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='Host')
  }(name='HostList'),
  requestId?: string(name='RequestId'),
}

model ListFlowClusterAllHostsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowClusterAllHostsResponseBody(name='body'),
}

async function listFlowClusterAllHosts(request: ListFlowClusterAllHostsRequest): ListFlowClusterAllHostsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlowClusterAllHosts', 'POST', '/', 'json', false, 'json', request);
}

model ListFlowClusterHostRequest {
  clusterId: string(name='ClusterId', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
}

model ListFlowClusterHostResponseBody = {
  hostList?: {
    host?: [ 
    {
      cpu?: int32(name='Cpu'),
      hostId?: string(name='HostId'),
      hostInstanceId?: string(name='HostInstanceId'),
      hostName?: string(name='HostName'),
      instanceType?: string(name='InstanceType'),
      memory?: int32(name='Memory'),
      privateIp?: string(name='PrivateIp'),
      publicIp?: string(name='PublicIp'),
      role?: string(name='Role'),
      serialNumber?: string(name='SerialNumber'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='Host')
  }(name='HostList'),
  requestId?: string(name='RequestId'),
}

model ListFlowClusterHostResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowClusterHostResponseBody(name='body'),
}

async function listFlowClusterHost(request: ListFlowClusterHostRequest): ListFlowClusterHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlowClusterHost', 'POST', '/', 'json', false, 'json', request);
}

model ListFlowInstanceRequest {
  flowId?: string(name='FlowId', position='Query'),
  flowName?: string(name='FlowName', position='Query'),
  id?: string(name='Id', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  nodeInstanceId?: string(name='NodeInstanceId', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  orderType?: string(name='OrderType', position='Query'),
  owner?: string(name='Owner', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  statusList?: [ string ](name='StatusList', position='Query'),
  timeRange?: string(name='TimeRange', position='Query'),
}

model ListFlowInstanceResponseBody = {
  flowInstances?: {
    flowInstance?: [ 
    {
      clusterId?: string(name='ClusterId'),
      duration?: long(name='Duration'),
      endTime?: long(name='EndTime'),
      flowId?: string(name='FlowId'),
      flowName?: string(name='FlowName'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      hasNodeFailed?: boolean(name='HasNodeFailed'),
      id?: string(name='Id'),
      owner?: string(name='Owner'),
      projectId?: string(name='ProjectId'),
      scheduleTime?: long(name='ScheduleTime'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
    }
  ](name='FlowInstance')
  }(name='FlowInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListFlowInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowInstanceResponseBody(name='body'),
}

async function listFlowInstance(request: ListFlowInstanceRequest): ListFlowInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlowInstance', 'POST', '/', 'json', false, 'json', request);
}

model ListFlowJobRequest {
  adhoc?: boolean(name='Adhoc', position='Query'),
  id?: string(name='Id', position='Query'),
  name?: string(name='Name', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type?: string(name='Type', position='Query'),
}

model ListFlowJobResponseBody = {
  jobList?: {
    job?: [ 
    {
      adhoc?: string(name='Adhoc'),
      alertConf?: string(name='AlertConf'),
      categoryId?: string(name='CategoryId'),
      customVariables?: string(name='CustomVariables'),
      description?: string(name='Description'),
      envConf?: string(name='EnvConf'),
      failAct?: string(name='FailAct'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      id?: string(name='Id'),
      lastInstanceDetail?: string(name='LastInstanceDetail'),
      maxRetry?: int32(name='MaxRetry'),
      monitorConf?: string(name='MonitorConf'),
      name?: string(name='Name'),
      paramConf?: string(name='ParamConf'),
      params?: string(name='Params'),
      resourceList?: {
        resource?: [ 
        {
          alias?: string(name='Alias'),
          path?: string(name='Path'),
        }
      ](name='Resource')
      }(name='ResourceList'),
      retryInterval?: long(name='RetryInterval'),
      runConf?: string(name='RunConf'),
      type?: string(name='Type'),
      mode?: string(name='mode'),
    }
  ](name='Job')
  }(name='JobList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowJobResponseBody(name='body'),
}

async function listFlowJob(request: ListFlowJobRequest): ListFlowJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlowJob', 'POST', '/', 'json', false, 'json', request);
}

model ListFlowJobHistoryRequest {
  id?: string(name='Id', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  jobType?: string(name='JobType', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  statusList?: [ string ](name='StatusList', position='Query'),
  timeRange?: string(name='TimeRange', position='Query'),
}

model ListFlowJobHistoryResponseBody = {
  nodeInstances?: {
    nodeInstance?: [ 
    {
      clusterId?: string(name='ClusterId'),
      endTime?: long(name='EndTime'),
      envConf?: string(name='EnvConf'),
      externalId?: string(name='ExternalId'),
      externalInfo?: string(name='ExternalInfo'),
      externalStatus?: string(name='ExternalStatus'),
      failAct?: string(name='FailAct'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      hostName?: string(name='HostName'),
      id?: string(name='Id'),
      jobId?: string(name='JobId'),
      jobName?: string(name='JobName'),
      jobParams?: string(name='JobParams'),
      jobType?: string(name='JobType'),
      maxRetry?: int32(name='MaxRetry'),
      nodeName?: string(name='NodeName'),
      paramConf?: string(name='ParamConf'),
      projectId?: string(name='ProjectId'),
      retries?: int32(name='Retries'),
      retryInterval?: long(name='RetryInterval'),
      runConf?: string(name='RunConf'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      pending?: boolean(name='pending'),
    }
  ](name='NodeInstance')
  }(name='NodeInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListFlowJobHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowJobHistoryResponseBody(name='body'),
}

async function listFlowJobHistory(request: ListFlowJobHistoryRequest): ListFlowJobHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlowJobHistory', 'POST', '/', 'json', false, 'json', request);
}

model ListFlowNodeInstanceRequest {
  orderBy?: string(name='OrderBy', position='Query'),
  orderType?: string(name='OrderType', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  projectId?: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  startTime?: long(name='StartTime', position='Query'),
  statusList?: [ string ](name='StatusList', position='Query'),
}

model ListFlowNodeInstanceResponseBody = {
  flowNodeInstances?: {
    flowNodeInstance?: [ 
    {
      clusterId?: string(name='ClusterId'),
      duration?: long(name='Duration'),
      endTime?: long(name='EndTime'),
      externalChildIds?: string(name='ExternalChildIds'),
      externalId?: string(name='ExternalId'),
      externalInfo?: string(name='ExternalInfo'),
      externalStatus?: string(name='ExternalStatus'),
      externalSubId?: string(name='ExternalSubId'),
      failAct?: string(name='FailAct'),
      flowId?: string(name='FlowId'),
      flowInstanceId?: string(name='FlowInstanceId'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      hostName?: string(name='HostName'),
      id?: string(name='Id'),
      jobId?: string(name='JobId'),
      jobName?: string(name='JobName'),
      jobParams?: string(name='JobParams'),
      jobType?: string(name='JobType'),
      maxRetry?: string(name='MaxRetry'),
      nodeName?: string(name='NodeName'),
      pending?: boolean(name='Pending'),
      projectId?: string(name='ProjectId'),
      retries?: int32(name='Retries'),
      retryInterval?: string(name='RetryInterval'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='FlowNodeInstance')
  }(name='FlowNodeInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListFlowNodeInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowNodeInstanceResponseBody(name='body'),
}

async function listFlowNodeInstance(request: ListFlowNodeInstanceRequest): ListFlowNodeInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlowNodeInstance', 'POST', '/', 'json', false, 'json', request);
}

model ListFlowNodeInstanceContainerStatusRequest {
  nodeInstanceId: string(name='NodeInstanceId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListFlowNodeInstanceContainerStatusResponseBody = {
  containerStatusList?: {
    containerStatus?: [ 
    {
      applicationId?: string(name='ApplicationId'),
      containerId?: string(name='ContainerId'),
      hostName?: string(name='HostName'),
      status?: string(name='Status'),
    }
  ](name='ContainerStatus')
  }(name='ContainerStatusList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListFlowNodeInstanceContainerStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowNodeInstanceContainerStatusResponseBody(name='body'),
}

async function listFlowNodeInstanceContainerStatus(request: ListFlowNodeInstanceContainerStatusRequest): ListFlowNodeInstanceContainerStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlowNodeInstanceContainerStatus', 'POST', '/', 'json', false, 'json', request);
}

model ListFlowNodeSqlResultRequest {
  length?: int32(name='Length', position='Query'),
  nodeInstanceId: string(name='NodeInstanceId', position='Query'),
  offset?: int32(name='Offset', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  sqlIndex?: int32(name='SqlIndex', position='Query'),
}

model ListFlowNodeSqlResultResponseBody = {
  end?: boolean(name='End'),
  headerList?: {
    header?: [ string ](name='Header')
  }(name='HeaderList'),
  requestId?: string(name='RequestId'),
  rowList?: {
    row?: [ 
    {
      rowIndex?: int32(name='RowIndex'),
      rowItemList?: {
        rowItem?: [ string ](name='rowItem')
      }(name='RowItemList'),
    }
  ](name='Row')
  }(name='RowList'),
}

model ListFlowNodeSqlResultResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowNodeSqlResultResponseBody(name='body'),
}

async function listFlowNodeSqlResult(request: ListFlowNodeSqlResultRequest): ListFlowNodeSqlResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlowNodeSqlResult', 'POST', '/', 'json', false, 'json', request);
}

model ListFlowProjectRequest {
  name?: string(name='Name', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  productType?: string(name='ProductType', position='Query'),
  projectId?: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
}

model ListFlowProjectResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projects?: {
    project?: [ 
    {
      description?: string(name='Description'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      userId?: string(name='UserId'),
    }
  ](name='Project')
  }(name='Projects'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowProjectResponseBody(name='body'),
}

async function listFlowProject(request: ListFlowProjectRequest): ListFlowProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlowProject', 'POST', '/', 'json', false, 'json', request);
}

model ListFlowProjectClusterSettingRequest {
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListFlowProjectClusterSettingResponseBody = {
  clusterSettings?: {
    clusterSetting?: [ 
    {
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      defaultQueue?: string(name='DefaultQueue'),
      defaultUser?: string(name='DefaultUser'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      hostList?: {
        host?: [ string ](name='Host')
      }(name='HostList'),
      k8sClusterId?: string(name='K8sClusterId'),
      projectId?: string(name='ProjectId'),
      queueList?: {
        queue?: [ string ](name='Queue')
      }(name='QueueList'),
      userList?: {
        user?: [ string ](name='User')
      }(name='UserList'),
    }
  ](name='ClusterSetting')
  }(name='ClusterSettings'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListFlowProjectClusterSettingResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowProjectClusterSettingResponseBody(name='body'),
}

async function listFlowProjectClusterSetting(request: ListFlowProjectClusterSettingRequest): ListFlowProjectClusterSettingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlowProjectClusterSetting', 'POST', '/', 'json', false, 'json', request);
}

model ListFlowProjectUserRequest {
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListFlowProjectUserResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
  users?: {
    user?: [ 
    {
      accountUserId?: string(name='AccountUserId'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      ownerId?: string(name='OwnerId'),
      projectId?: string(name='ProjectId'),
      userName?: string(name='UserName'),
    }
  ](name='User')
  }(name='Users'),
}

model ListFlowProjectUserResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowProjectUserResponseBody(name='body'),
}

async function listFlowProjectUser(request: ListFlowProjectUserRequest): ListFlowProjectUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlowProjectUser', 'POST', '/', 'json', false, 'json', request);
}

model ListJobExecutionInstancesRequest {
  executionPlanInstanceId: string(name='ExecutionPlanInstanceId', position='Query'),
  isDesc?: boolean(name='IsDesc', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=500, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListJobExecutionInstancesResponseBody = {
  jobInstances?: {
    jobInstance?: [ 
    {
      clusterId?: string(name='ClusterId'),
      id?: string(name='Id'),
      jobId?: string(name='JobId'),
      jobName?: string(name='JobName'),
      jobType?: string(name='JobType'),
      retryInfo?: string(name='RetryInfo'),
      runTime?: int32(name='RunTime'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
    }
  ](name='JobInstance')
  }(name='JobInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListJobExecutionInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobExecutionInstancesResponseBody(name='body'),
}

async function listJobExecutionInstances(request: ListJobExecutionInstancesRequest): ListJobExecutionInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListJobExecutionInstances', 'POST', '/', 'json', false, 'json', request);
}

model ListJobsRequest {
  isDesc?: boolean(name='IsDesc', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=500, position='Query'),
  queryString?: string(name='QueryString', position='Query'),
  queryType?: string(name='QueryType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListJobsResponseBody = {
  jobs?: {
    jobInfo?: [ 
    {
      failAct?: string(name='FailAct'),
      id?: string(name='Id'),
      maxRetry?: int32(name='MaxRetry'),
      name?: string(name='Name'),
      retryInterval?: int32(name='RetryInterval'),
      runParameter?: string(name='RunParameter'),
      type?: string(name='Type'),
    }
  ](name='JobInfo')
  }(name='Jobs'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobs(request: ListJobsRequest): ListJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListJobs', 'POST', '/', 'json', false, 'json', request);
}

model ListLibrariesRequest {
  clusterBizId?: string(name='ClusterBizId', position='Query'),
  currentSize?: int32(name='CurrentSize', position='Query'),
  limit?: int32(name='Limit', position='Query'),
  orderField?: string(name='OrderField', position='Query'),
  orderMode?: string(name='OrderMode', position='Query'),
  pageCount?: int32(name='PageCount', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListLibrariesResponseBody = {
  items?: {
    item?: [ 
    {
      bizId?: string(name='BizId'),
      createTime?: long(name='CreateTime'),
      libraryVersion?: string(name='LibraryVersion'),
      name?: string(name='Name'),
      properties?: string(name='Properties'),
      scope?: string(name='Scope'),
      sourceLocation?: string(name='SourceLocation'),
      sourceType?: string(name='SourceType'),
      type?: string(name='Type'),
      userId?: string(name='UserId'),
    }
  ](name='Item')
  }(name='Items'),
  nextToken?: string(name='NextToken'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListLibrariesResponse = {
  headers: map[string]string(name='headers'),
  body: ListLibrariesResponseBody(name='body'),
}

async function listLibraries(request: ListLibrariesRequest): ListLibrariesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLibraries', 'POST', '/', 'json', false, 'json', request);
}

model ListLibraryInstallTasksRequest {
  clusterBizId?: string(name='ClusterBizId', position='Query'),
  currentSize?: int32(name='CurrentSize', position='Query'),
  libraryBizId?: string(name='LibraryBizId', position='Query'),
  limit?: int32(name='Limit', position='Query'),
  orderField?: string(name='OrderField', position='Query'),
  orderMode?: string(name='OrderMode', position='Query'),
  pageCount?: int32(name='PageCount', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListLibraryInstallTasksResponseBody = {
  items?: {
    item?: [ 
    {
      clusterBizId?: string(name='ClusterBizId'),
      detail?: string(name='Detail'),
      endTime?: long(name='EndTime'),
      executeTime?: long(name='ExecuteTime'),
      hostname?: string(name='Hostname'),
      libraryBizId?: string(name='LibraryBizId'),
      startTime?: long(name='StartTime'),
      taskGroupId?: string(name='TaskGroupId'),
      taskId?: string(name='TaskId'),
      taskProcess?: int32(name='TaskProcess'),
      taskStatus?: string(name='TaskStatus'),
      taskType?: string(name='TaskType'),
    }
  ](name='Item')
  }(name='Items'),
  nextToken?: string(name='NextToken'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListLibraryInstallTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListLibraryInstallTasksResponseBody(name='body'),
}

async function listLibraryInstallTasks(request: ListLibraryInstallTasksRequest): ListLibraryInstallTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLibraryInstallTasks', 'POST', '/', 'json', false, 'json', request);
}

model ListLibraryStatusRequest {
  clusterBizId?: string(name='ClusterBizId', position='Query'),
  currentSize?: int32(name='CurrentSize', position='Query'),
  libraryBizId?: string(name='LibraryBizId', position='Query'),
  limit?: int32(name='Limit', position='Query'),
  orderField?: string(name='OrderField', position='Query'),
  orderMode?: string(name='OrderMode', position='Query'),
  pageCount?: int32(name='PageCount', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListLibraryStatusResponseBody = {
  items?: {
    item?: [ 
    {
      clusterBizId?: string(name='ClusterBizId'),
      clusterName?: string(name='ClusterName'),
      libraryBizId?: string(name='LibraryBizId'),
      libraryName?: string(name='LibraryName'),
      status?: string(name='Status'),
    }
  ](name='Item')
  }(name='Items'),
  nextToken?: string(name='NextToken'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListLibraryStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ListLibraryStatusResponseBody(name='body'),
}

async function listLibraryStatus(request: ListLibraryStatusRequest): ListLibraryStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLibraryStatus', 'POST', '/', 'json', false, 'json', request);
}

model ListLocalDiskComponentInfoRequest {
  clusterId: string(name='ClusterId', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListLocalDiskComponentInfoResponseBody = {
  componentInfoList?: {
    componentInfo?: [ 
    {
      apmMetrics?: {
        apmMetric?: [ string ](name='ApmMetric')
      }(name='ApmMetrics'),
      componentDisplayName?: string(name='ComponentDisplayName'),
      componentName?: string(name='ComponentName'),
      isolateWarningMsg?: string(name='IsolateWarningMsg'),
      mountParams?: {
        mountParam?: [ 
        {
          defaultValue?: string(name='DefaultValue'),
          key?: string(name='Key'),
          max?: int32(name='Max'),
          min?: int32(name='Min'),
          name?: string(name='Name'),
          options?: {
            option?: [ string ](name='Option')
          }(name='Options'),
          tips?: string(name='Tips'),
          unit?: string(name='Unit'),
          valueType?: string(name='ValueType'),
        }
      ](name='MountParam')
      }(name='MountParams'),
      mountWarningMsg?: string(name='MountWarningMsg'),
      rebootWarningMsg?: string(name='RebootWarningMsg'),
      serviceDisplayName?: string(name='ServiceDisplayName'),
      serviceName?: string(name='ServiceName'),
      supportDiskHotSwap?: boolean(name='SupportDiskHotSwap'),
    }
  ](name='ComponentInfo')
  }(name='ComponentInfoList'),
  requestId?: string(name='RequestId'),
}

model ListLocalDiskComponentInfoResponse = {
  headers: map[string]string(name='headers'),
  body: ListLocalDiskComponentInfoResponseBody(name='body'),
}

async function listLocalDiskComponentInfo(request: ListLocalDiskComponentInfoRequest): ListLocalDiskComponentInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLocalDiskComponentInfo', 'POST', '/', 'json', false, 'json', request);
}

model ListResourcePoolRequest {
  clusterId: string(name='ClusterId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=500, position='Query'),
  poolType?: string(name='PoolType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListResourcePoolResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  poolInfoList?: {
    poolInfo?: [ 
    {
      ecmResourcePool?: {
        active?: boolean(name='Active'),
        id?: long(name='Id'),
        name?: string(name='Name'),
        note?: string(name='Note'),
        poolType?: string(name='PoolType'),
        userId?: string(name='UserId'),
        yarnSiteConfig?: string(name='YarnSiteConfig'),
      }(name='EcmResourcePool'),
      ecmResourcePoolConfigList?: {
        ecmResourcePoolConfig?: [ 
        {
          category?: string(name='Category'),
          configKey?: string(name='ConfigKey'),
          configType?: string(name='ConfigType'),
          configValue?: string(name='ConfigValue'),
          id?: long(name='Id'),
          note?: string(name='Note'),
          status?: string(name='Status'),
        }
      ](name='EcmResourcePoolConfig')
      }(name='EcmResourcePoolConfigList'),
      queueList?: {
        queue?: [ 
        {
          ecmResourcePoolConfigList?: {
            ecmResourcePoolConfig?: [ 
            {
              category?: string(name='Category'),
              configKey?: string(name='ConfigKey'),
              configType?: string(name='ConfigType'),
              configValue?: string(name='ConfigValue'),
              id?: long(name='Id'),
              note?: string(name='Note'),
              status?: string(name='Status'),
            }
          ](name='EcmResourcePoolConfig')
          }(name='EcmResourcePoolConfigList'),
          ecmResourceQueue?: {
            id?: long(name='Id'),
            leaf?: boolean(name='Leaf'),
            name?: string(name='Name'),
            parentQueueId?: long(name='ParentQueueId'),
            qualifiedName?: string(name='QualifiedName'),
            queueType?: string(name='QueueType'),
            resourcePoolId?: long(name='ResourcePoolId'),
            status?: string(name='Status'),
            userId?: string(name='UserId'),
          }(name='EcmResourceQueue'),
        }
      ](name='Queue')
      }(name='QueueList'),
    }
  ](name='PoolInfo')
  }(name='PoolInfoList'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListResourcePoolResponse = {
  headers: map[string]string(name='headers'),
  body: ListResourcePoolResponseBody(name='body'),
}

async function listResourcePool(request: ListResourcePoolRequest): ListResourcePoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListResourcePool', 'POST', '/', 'json', false, 'json', request);
}

model ListRolesRequest {
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
}

model ListRolesResponseBody = {
  data?: {
    roleDTO?: [ 
    {
      description?: string(name='Description'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='roleDTO')
  }(name='Data'),
  paging?: boolean(name='Paging'),
  requestId?: string(name='RequestId'),
}

model ListRolesResponse = {
  headers: map[string]string(name='headers'),
  body: ListRolesResponseBody(name='body'),
}

async function listRoles(request: ListRolesRequest): ListRolesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListRoles', 'POST', '/', 'json', false, 'json', request);
}

model ListScalingActivityV2Request {
  clusterBizId: string(name='ClusterBizId', position='Query'),
  currentSize?: int32(name='CurrentSize', position='Query'),
  hostGroupId?: string(name='HostGroupId', position='Query'),
  hostGroupName?: string(name='HostGroupName', position='Query'),
  limit?: int32(name='Limit', position='Query'),
  orderField?: string(name='OrderField', position='Query'),
  orderMode?: string(name='OrderMode', position='Query'),
  pageCount?: int32(name='PageCount', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scalingGroupBizId?: string(name='ScalingGroupBizId', position='Query'),
  scalingRuleName?: string(name='ScalingRuleName', position='Query'),
  status?: string(name='Status', position='Query'),
}

model ListScalingActivityV2ResponseBody = {
  items?: {
    item?: [ 
    {
      bizId?: string(name='BizId'),
      cause?: string(name='Cause'),
      description?: string(name='Description'),
      endTime?: long(name='EndTime'),
      expectNum?: int32(name='ExpectNum'),
      hostGroupBizId?: string(name='HostGroupBizId'),
      hostGroupName?: string(name='HostGroupName'),
      instanceIds?: string(name='InstanceIds'),
      scalingRuleId?: string(name='ScalingRuleId'),
      scalingRuleName?: string(name='ScalingRuleName'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      totalCapacity?: int32(name='TotalCapacity'),
      transition?: string(name='Transition'),
    }
  ](name='Item')
  }(name='Items'),
  nextToken?: string(name='NextToken'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListScalingActivityV2Response = {
  headers: map[string]string(name='headers'),
  body: ListScalingActivityV2ResponseBody(name='body'),
}

async function listScalingActivityV2(request: ListScalingActivityV2Request): ListScalingActivityV2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListScalingActivityV2', 'POST', '/', 'json', false, 'json', request);
}

model ListScalingConfigItemV2Request {
  configItemType: string(name='ConfigItemType', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scalingGroupBizId: string(name='ScalingGroupBizId', position='Query'),
}

model ListScalingConfigItemV2ResponseBody = {
  items?: {
    item?: [ 
    {
      configItemInformation?: string(name='ConfigItemInformation'),
      configItemType?: string(name='ConfigItemType'),
      scalingConfigItemBizId?: string(name='ScalingConfigItemBizId'),
      scalingGroupBizId?: string(name='ScalingGroupBizId'),
    }
  ](name='Item')
  }(name='Items'),
  nextToken?: string(name='NextToken'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListScalingConfigItemV2Response = {
  headers: map[string]string(name='headers'),
  body: ListScalingConfigItemV2ResponseBody(name='body'),
}

async function listScalingConfigItemV2(request: ListScalingConfigItemV2Request): ListScalingConfigItemV2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListScalingConfigItemV2', 'POST', '/', 'json', false, 'json', request);
}

model ListScalingGroupV2Request {
  clusterBizId?: string(name='ClusterBizId', position='Query'),
  currentSize?: int32(name='CurrentSize', position='Query'),
  limit?: int32(name='Limit', position='Query'),
  orderField?: string(name='OrderField', position='Query'),
  orderMode?: string(name='OrderMode', position='Query'),
  pageCount?: int32(name='PageCount', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListScalingGroupV2ResponseBody = {
  items?: {
    item?: [ 
    {
      activeStatus?: string(name='ActiveStatus'),
      description?: string(name='Description'),
      hostGroupBizId?: string(name='HostGroupBizId'),
      name?: string(name='Name'),
      scalingGroupId?: string(name='ScalingGroupId'),
      scalingInMode?: string(name='ScalingInMode'),
      scalingMaxSize?: int32(name='ScalingMaxSize'),
      scalingMinSize?: int32(name='ScalingMinSize'),
    }
  ](name='Item')
  }(name='Items'),
  nextToken?: string(name='NextToken'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListScalingGroupV2Response = {
  headers: map[string]string(name='headers'),
  body: ListScalingGroupV2ResponseBody(name='body'),
}

async function listScalingGroupV2(request: ListScalingGroupV2Request): ListScalingGroupV2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListScalingGroupV2', 'POST', '/', 'json', false, 'json', request);
}

model ListSecurityGroupRequest {
  depositType?: string(name='DepositType', position='Query'),
  netType?: string(name='NetType', position='Query'),
  productType?: string(name='ProductType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model ListSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
  securityGroupList?: {
    securityGroup?: [ 
    {
      availableInstanceAmount?: int32(name='AvailableInstanceAmount'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      ecsCount?: int32(name='EcsCount'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupName?: string(name='SecurityGroupName'),
      securityGroupType?: string(name='SecurityGroupType'),
      vpcId?: string(name='VpcId'),
    }
  ](name='SecurityGroup')
  }(name='SecurityGroupList'),
}

model ListSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecurityGroupResponseBody(name='body'),
}

async function listSecurityGroup(request: ListSecurityGroupRequest): ListSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSecurityGroup', 'POST', '/', 'json', false, 'json', request);
}

model ListStackRequest {
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  stackName?: string(name='StackName', position='Query'),
  stackVersion?: string(name='StackVersion', position='Query'),
}

model ListStackResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  stackList?: {
    stack?: [ 
    {
      name?: string(name='Name'),
      status?: string(name='Status'),
      version?: string(name='Version'),
    }
  ](name='Stack')
  }(name='StackList'),
  totalCount?: int32(name='TotalCount'),
}

model ListStackResponse = {
  headers: map[string]string(name='headers'),
  body: ListStackResponseBody(name='body'),
}

async function listStack(request: ListStackRequest): ListStackResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListStack', 'POST', '/', 'json', false, 'json', request);
}

model ListTagKeysRequest {
  category?: string(name='Category', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  scope?: string(name='Scope', position='Query'),
}

model ListTagKeysResponseBody = {
  code?: string(name='Code'),
  keys?: {
    key?: [ string ](name='Key')
  }(name='Keys'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListTagKeysResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagKeysResponseBody(name='body'),
}

async function listTagKeys(request: ListTagKeysRequest): ListTagKeysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagKeys', 'POST', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ListTagValuesRequest {
  key: string(name='Key', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  scope?: string(name='Scope', position='Query'),
}

model ListTagValuesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
  values?: {
    value?: [ string ](name='Value')
  }(name='Values'),
}

model ListTagValuesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagValuesResponseBody(name='body'),
}

async function listTagValues(request: ListTagValuesRequest): ListTagValuesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagValues', 'POST', '/', 'json', false, 'json', request);
}

model ListUsersRequest {
  clusterId?: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  type?: string(name='Type', position='Query'),
}

model ListUsersResponseBody = {
  requestId?: string(name='RequestId'),
  userList?: {
    user?: [ 
    {
      groupName?: string(name='GroupName'),
      k8sStatus?: string(name='K8sStatus'),
      kerberosStatus?: string(name='KerberosStatus'),
      knoxStatus?: string(name='KnoxStatus'),
      linuxStatus?: string(name='LinuxStatus'),
      userId?: string(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='User')
  }(name='UserList'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUsers', 'POST', '/', 'json', false, 'json', request);
}

model ListVswitchRequest {
  depositType?: string(name='DepositType', position='Query'),
  productType?: string(name='ProductType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ListVswitchResponseBody = {
  requestId?: string(name='RequestId'),
  vswitchList?: {
    vswitch?: [ 
    {
      availableIpAddressCount?: string(name='AvailableIpAddressCount'),
      cidrBlock?: string(name='CidrBlock'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      isDefault?: boolean(name='IsDefault'),
      resourceGroupId?: string(name='ResourceGroupId'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vSwitchName?: string(name='VSwitchName'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Vswitch')
  }(name='VswitchList'),
}

model ListVswitchResponse = {
  headers: map[string]string(name='headers'),
  body: ListVswitchResponseBody(name='body'),
}

async function listVswitch(request: ListVswitchRequest): ListVswitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListVswitch', 'POST', '/', 'json', false, 'json', request);
}

model ModifyClusterBootstrapActionRequest {
  bootstrapAction?: [ 
    {
      arg?: string(name='Arg'),
      executionFailStrategy?: string(name='ExecutionFailStrategy'),
      executionMoment?: string(name='ExecutionMoment'),
      executionTarget?: string(name='ExecutionTarget'),
      name: string(name='Name'),
      path: string(name='Path'),
    }
  ](name='BootstrapAction', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  id: string(name='Id', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyClusterBootstrapActionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterBootstrapActionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterBootstrapActionResponseBody(name='body'),
}

async function modifyClusterBootstrapAction(request: ModifyClusterBootstrapActionRequest): ModifyClusterBootstrapActionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyClusterBootstrapAction', 'POST', '/', 'json', false, 'json', request);
}

model ModifyClusterHostGroupRequest {
  clusterId: string(name='ClusterId', position='Query'),
  comment?: string(name='Comment', position='Query'),
  hostGroupId: string(name='HostGroupId', position='Query'),
  hostGroupName?: string(name='HostGroupName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  vswitchId?: string(name='VswitchId', position='Query'),
}

model ModifyClusterHostGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterHostGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterHostGroupResponseBody(name='body'),
}

async function modifyClusterHostGroup(request: ModifyClusterHostGroupRequest): ModifyClusterHostGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyClusterHostGroup', 'POST', '/', 'json', false, 'json', request);
}

model ModifyClusterMetaCollectRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  switchOn: boolean(name='SwitchOn', position='Query'),
}

model ModifyClusterMetaCollectResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterMetaCollectResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterMetaCollectResponseBody(name='body'),
}

async function modifyClusterMetaCollect(request: ModifyClusterMetaCollectRequest): ModifyClusterMetaCollectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyClusterMetaCollect', 'POST', '/', 'json', false, 'json', request);
}

model ModifyClusterNameRequest {
  id: string(name='Id', position='Query'),
  name: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyClusterNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterNameResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterNameResponseBody(name='body'),
}

async function modifyClusterName(request: ModifyClusterNameRequest): ModifyClusterNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyClusterName', 'POST', '/', 'json', false, 'json', request);
}

model ModifyClusterSecurityGroupRuleRequest {
  clusterId: string(name='ClusterId', position='Query'),
  ipProtocol: string(name='IpProtocol', position='Query'),
  modifyType: string(name='ModifyType', position='Query'),
  nicType: string(name='NicType', position='Query'),
  portRange: string(name='PortRange', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  whiteIp: string(name='WhiteIp', position='Query'),
}

model ModifyClusterSecurityGroupRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterSecurityGroupRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterSecurityGroupRuleResponseBody(name='body'),
}

async function modifyClusterSecurityGroupRule(request: ModifyClusterSecurityGroupRuleRequest): ModifyClusterSecurityGroupRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyClusterSecurityGroupRule', 'POST', '/', 'json', false, 'json', request);
}

model ModifyClusterServiceConfigRequest {
  clusterId: string(name='ClusterId', position='Query'),
  comment?: string(name='Comment', position='Query'),
  configParams: string(name='ConfigParams', position='Query'),
  configType?: string(name='ConfigType', position='Query'),
  customConfigParams?: string(name='CustomConfigParams', position='Query'),
  gatewayClusterIdList?: [ string ](name='GatewayClusterIdList', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  hostInstanceId?: string(name='HostInstanceId', position='Query'),
  refreshHostConfig?: boolean(name='RefreshHostConfig', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceName: string(name='ServiceName', position='Query'),
}

model ModifyClusterServiceConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterServiceConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterServiceConfigResponseBody(name='body'),
}

async function modifyClusterServiceConfig(request: ModifyClusterServiceConfigRequest): ModifyClusterServiceConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyClusterServiceConfig', 'POST', '/', 'json', false, 'json', request);
}

model ModifyClusterTemplateRequest {
  autoRenew?: boolean(name='AutoRenew', position='Query'),
  bizId: string(name='BizId', position='Query'),
  bootstrapAction?: [ 
    {
      arg?: string(name='Arg'),
      executionFailStrategy?: string(name='ExecutionFailStrategy'),
      executionMoment?: string(name='ExecutionMoment'),
      executionTarget?: string(name='ExecutionTarget'),
      name: string(name='Name'),
      path: string(name='Path'),
    }
  ](name='BootstrapAction', position='Query'),
  chargeType?: string(name='ChargeType', position='Query'),
  clusterType: string(name='ClusterType', position='Query'),
  config?: [ 
    {
      configKey: string(name='ConfigKey'),
      configValue: string(name='ConfigValue'),
      encrypt?: string(name='Encrypt'),
      fileName: string(name='FileName'),
      replace?: string(name='Replace'),
      serviceName: string(name='ServiceName'),
    }
  ](name='Config', position='Query'),
  configurations?: string(name='Configurations', position='Query'),
  depositType?: string(name='DepositType', position='Query'),
  easEnable?: boolean(name='EasEnable', position='Query'),
  emrVer: string(name='EmrVer', position='Query'),
  highAvailabilityEnable?: boolean(name='HighAvailabilityEnable', position='Query'),
  hostGroup: [ 
    {
      autoRenew?: boolean(name='AutoRenew'),
      chargeType?: string(name='ChargeType'),
      clusterId?: string(name='ClusterId'),
      comment?: string(name='Comment'),
      createType?: string(name='CreateType'),
      diskCapacity: int32(name='DiskCapacity', minimum=40, maximum=20000),
      diskCount: int32(name='DiskCount', minimum=1, maximum=4),
      diskType: string(name='DiskType'),
      hostGroupId?: string(name='HostGroupId'),
      hostGroupName: string(name='HostGroupName'),
      hostGroupType: string(name='HostGroupType'),
      instanceType: string(name='InstanceType'),
      multiInstanceTypes?: string(name='MultiInstanceTypes'),
      nodeCount: int32(name='NodeCount', minimum=2, maximum=1000),
      period?: int32(name='Period'),
      sysDiskCapacity: int32(name='SysDiskCapacity', minimum=40, maximum=500),
      sysDiskType: string(name='SysDiskType'),
      vSwitchId?: string(name='VSwitchId'),
    }
  ](name='HostGroup', position='Query'),
  initCustomHiveMetaDb?: boolean(name='InitCustomHiveMetaDb', position='Query'),
  instanceGeneration?: string(name='InstanceGeneration', position='Query'),
  ioOptimized?: boolean(name='IoOptimized', position='Query'),
  isOpenPublicIp?: boolean(name='IsOpenPublicIp', position='Query'),
  keyPairName?: string(name='KeyPairName', position='Query'),
  logPath?: string(name='LogPath', position='Query'),
  machineType?: string(name='MachineType', position='Query'),
  masterPwd?: string(name='MasterPwd', position='Query'),
  metaStoreConf?: string(name='MetaStoreConf', position='Query'),
  metaStoreType?: string(name='MetaStoreType', position='Query'),
  netType?: string(name='NetType', position='Query'),
  optionSoftWareList?: [ string ](name='OptionSoftWareList', position='Query'),
  period?: int32(name='Period', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  securityGroupName?: string(name='SecurityGroupName', position='Query'),
  sshEnable?: boolean(name='SshEnable', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
  useCustomHiveMetaDb?: boolean(name='UseCustomHiveMetaDb', position='Query'),
  useLocalMetaDb?: boolean(name='UseLocalMetaDb', position='Query'),
  userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model ModifyClusterTemplateResponseBody = {
  clusterTemplateId?: string(name='ClusterTemplateId'),
  requestId?: string(name='RequestId'),
}

model ModifyClusterTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterTemplateResponseBody(name='body'),
}

async function modifyClusterTemplate(request: ModifyClusterTemplateRequest): ModifyClusterTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyClusterTemplate', 'POST', '/', 'json', false, 'json', request);
}

model ModifyExecutionPlanRequest {
  bootstrapAction?: [ 
    {
      arg?: string(name='Arg'),
      executionFailStrategy?: string(name='ExecutionFailStrategy'),
      executionMoment?: string(name='ExecutionMoment'),
      executionTarget?: string(name='ExecutionTarget'),
      name: string(name='Name'),
      path: string(name='Path'),
    }
  ](name='BootstrapAction', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  clusterName?: string(name='ClusterName', position='Query'),
  clusterType?: string(name='ClusterType', position='Query'),
  config?: [ 
    {
      configKey: string(name='ConfigKey'),
      configValue: string(name='ConfigValue'),
      encrypt?: string(name='Encrypt'),
      fileName: string(name='FileName'),
      replace?: string(name='Replace'),
      serviceName: string(name='ServiceName'),
    }
  ](name='Config', position='Query'),
  configurations?: string(name='Configurations', position='Query'),
  createClusterOnDemand?: boolean(name='CreateClusterOnDemand', position='Query'),
  dayOfMonth?: string(name='DayOfMonth', position='Query'),
  dayOfWeek?: string(name='DayOfWeek', position='Query'),
  easEnable?: boolean(name='EasEnable', position='Query'),
  ecsOrder?: [ 
    {
      diskCapacity: int32(name='DiskCapacity', minimum=40, maximum=2000),
      diskCount: int32(name='DiskCount', minimum=1, maximum=4),
      diskType: string(name='DiskType'),
      index?: int32(name='Index'),
      instanceType: string(name='InstanceType'),
      nodeCount: int32(name='NodeCount', minimum=2, maximum=50),
      nodeType: string(name='NodeType'),
    }
  ](name='EcsOrder', position='Query'),
  emrVer?: string(name='EmrVer', position='Query'),
  executionPlanVersion?: long(name='ExecutionPlanVersion', position='Query'),
  highAvailabilityEnable?: boolean(name='HighAvailabilityEnable', position='Query'),
  id: string(name='Id', position='Query'),
  initCustomHiveMetaDB?: boolean(name='InitCustomHiveMetaDB', position='Query'),
  instanceGeneration?: string(name='InstanceGeneration', position='Query'),
  ioOptimized?: boolean(name='IoOptimized', position='Query'),
  isOpenPublicIp?: boolean(name='IsOpenPublicIp', position='Query'),
  jobIdList: [ string ](name='JobIdList', position='Query'),
  logEnable?: boolean(name='LogEnable', position='Query'),
  logPath?: string(name='LogPath', position='Query'),
  name: string(name='Name', position='Query'),
  netType?: string(name='NetType', position='Query'),
  optionSoftWareList?: [ string ](name='OptionSoftWareList', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  startTime?: long(name='StartTime', minimum=1, position='Query'),
  strategy: string(name='Strategy', position='Query'),
  timeInterval?: int32(name='TimeInterval', minimum=1, position='Query'),
  timeUnit?: string(name='TimeUnit', position='Query'),
  useCustomHiveMetaDB?: boolean(name='UseCustomHiveMetaDB', position='Query'),
  useLocalMetaDb?: boolean(name='UseLocalMetaDb', position='Query'),
  userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  workflowDefinition?: string(name='WorkflowDefinition', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ModifyExecutionPlanResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyExecutionPlanResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyExecutionPlanResponseBody(name='body'),
}

async function modifyExecutionPlan(request: ModifyExecutionPlanRequest): ModifyExecutionPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyExecutionPlan', 'POST', '/', 'json', false, 'json', request);
}

model ModifyFlowRequest {
  alertConf?: string(name='AlertConf', position='Query'),
  alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId', position='Query'),
  alertUserGroupBizId?: string(name='AlertUserGroupBizId', position='Query'),
  application?: string(name='Application', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  createCluster?: boolean(name='CreateCluster', position='Query'),
  cronExpr?: string(name='CronExpr', position='Query'),
  description?: string(name='Description', position='Query'),
  endSchedule?: long(name='EndSchedule', position='Query'),
  hostName?: string(name='HostName', position='Query'),
  id: string(name='Id', position='Query'),
  lifecycle?: string(name='Lifecycle', position='Query'),
  logArchiveLocation?: string(name='LogArchiveLocation', position='Query'),
  name?: string(name='Name', position='Query'),
  namespace?: string(name='Namespace', position='Query'),
  parentCategory?: string(name='ParentCategory', position='Query'),
  parentFlowList?: string(name='ParentFlowList', position='Query'),
  periodic?: boolean(name='Periodic', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  startSchedule?: long(name='StartSchedule', position='Query'),
  status?: string(name='Status', position='Query'),
}

model ModifyFlowResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyFlowResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowResponseBody(name='body'),
}

async function modifyFlow(request: ModifyFlowRequest): ModifyFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyFlow', 'POST', '/', 'json', false, 'json', request);
}

model ModifyFlowCategoryRequest {
  id: string(name='Id', position='Query'),
  name?: string(name='Name', position='Query'),
  parentId?: string(name='ParentId', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyFlowCategoryResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyFlowCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowCategoryResponseBody(name='body'),
}

async function modifyFlowCategory(request: ModifyFlowCategoryRequest): ModifyFlowCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyFlowCategory', 'POST', '/', 'json', false, 'json', request);
}

model ModifyFlowForWebRequest {
  alertConf?: string(name='AlertConf', position='Query'),
  alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId', position='Query'),
  alertUserGroupBizId?: string(name='AlertUserGroupBizId', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  createCluster: boolean(name='CreateCluster', position='Query'),
  cronExpr?: string(name='CronExpr', position='Query'),
  description?: string(name='Description', position='Query'),
  endSchedule?: long(name='EndSchedule', position='Query'),
  graph: string(name='Graph', position='Query'),
  hostName?: string(name='HostName', position='Query'),
  id: string(name='Id', position='Query'),
  lifecycle?: string(name='Lifecycle', position='Query'),
  logArchiveLocation?: string(name='LogArchiveLocation', position='Query'),
  name?: string(name='Name', position='Query'),
  namespace?: string(name='Namespace', position='Query'),
  parentCategory?: string(name='ParentCategory', position='Query'),
  parentFlowList?: string(name='ParentFlowList', position='Query'),
  periodic?: boolean(name='Periodic', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  startSchedule?: long(name='StartSchedule', position='Query'),
  status?: string(name='Status', position='Query'),
}

model ModifyFlowForWebResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyFlowForWebResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowForWebResponseBody(name='body'),
}

async function modifyFlowForWeb(request: ModifyFlowForWebRequest): ModifyFlowForWebResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyFlowForWeb', 'POST', '/', 'json', false, 'json', request);
}

model ModifyFlowJobRequest {
  alertConf?: string(name='AlertConf', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  customVariables?: string(name='CustomVariables', position='Query'),
  description?: string(name='Description', position='Query'),
  envConf?: string(name='EnvConf', position='Query'),
  failAct?: string(name='FailAct', position='Query'),
  id: string(name='Id', position='Query'),
  maxRetry?: int32(name='MaxRetry', position='Query'),
  maxRunningTimeSec?: long(name='MaxRunningTimeSec', position='Query'),
  mode?: string(name='Mode', position='Query'),
  monitorConf?: string(name='MonitorConf', position='Query'),
  name?: string(name='Name', position='Query'),
  paramConf?: string(name='ParamConf', position='Query'),
  params?: string(name='Params', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceList?: [ 
    {
      alias?: string(name='Alias'),
      path: string(name='Path'),
    }
  ](name='ResourceList', position='Query'),
  retryInterval?: long(name='RetryInterval', position='Query'),
  retryPolicy?: string(name='RetryPolicy', position='Query'),
  runConf?: string(name='RunConf', position='Query'),
}

model ModifyFlowJobResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowJobResponseBody(name='body'),
}

async function modifyFlowJob(request: ModifyFlowJobRequest): ModifyFlowJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyFlowJob', 'POST', '/', 'json', false, 'json', request);
}

model ModifyFlowProjectRequest {
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyFlowProjectResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowProjectResponseBody(name='body'),
}

async function modifyFlowProject(request: ModifyFlowProjectRequest): ModifyFlowProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyFlowProject', 'POST', '/', 'json', false, 'json', request);
}

model ModifyFlowProjectClusterSettingRequest {
  clusterId: string(name='ClusterId', position='Query'),
  defaultQueue?: string(name='DefaultQueue', position='Query'),
  defaultUser?: string(name='DefaultUser', position='Query'),
  hostList?: [ string ](name='HostList', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  queueList?: [ string ](name='QueueList', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  userList?: [ string ](name='UserList', position='Query'),
}

model ModifyFlowProjectClusterSettingResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyFlowProjectClusterSettingResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowProjectClusterSettingResponseBody(name='body'),
}

async function modifyFlowProjectClusterSetting(request: ModifyFlowProjectClusterSettingRequest): ModifyFlowProjectClusterSettingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyFlowProjectClusterSetting', 'POST', '/', 'json', false, 'json', request);
}

model ModifyJobRequest {
  failAct?: string(name='FailAct', position='Query'),
  id: string(name='Id', position='Query'),
  maxRetry?: int32(name='MaxRetry', position='Query'),
  name?: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  retryInterval?: int32(name='RetryInterval', position='Query'),
  runParameter?: string(name='RunParameter', position='Query'),
  type?: string(name='Type', position='Query'),
}

model ModifyJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyJobResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyJobResponseBody(name='body'),
}

async function modifyJob(request: ModifyJobRequest): ModifyJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyJob', 'POST', '/', 'json', false, 'json', request);
}

model ModifyResourcePoolRequest {
  active?: boolean(name='Active', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  config?: [ 
    {
      category?: string(name='Category'),
      configKey?: string(name='ConfigKey'),
      configValue?: string(name='ConfigValue'),
      id?: string(name='Id'),
      note?: string(name='Note'),
    }
  ](name='Config', position='Query'),
  id: string(name='Id', position='Query'),
  name?: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  yarnsiteconfig?: string(name='Yarnsiteconfig', position='Query'),
}

model ModifyResourcePoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyResourcePoolResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyResourcePoolResponseBody(name='body'),
}

async function modifyResourcePool(request: ModifyResourcePoolRequest): ModifyResourcePoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyResourcePool', 'POST', '/', 'json', false, 'json', request);
}

model ModifyResourcePoolSchedulerTypeRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  schedulerType: string(name='SchedulerType', position='Query'),
}

model ModifyResourcePoolSchedulerTypeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyResourcePoolSchedulerTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyResourcePoolSchedulerTypeResponseBody(name='body'),
}

async function modifyResourcePoolSchedulerType(request: ModifyResourcePoolSchedulerTypeRequest): ModifyResourcePoolSchedulerTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyResourcePoolSchedulerType', 'POST', '/', 'json', false, 'json', request);
}

model ModifyResourceQueueRequest {
  clusterId: string(name='ClusterId', position='Query'),
  config: [ 
    {
      category?: string(name='Category'),
      configKey: string(name='ConfigKey'),
      configValue: string(name='ConfigValue'),
      id?: long(name='Id'),
      note?: string(name='Note'),
    }
  ](name='Config', position='Query'),
  id: string(name='Id', position='Query'),
  leaf?: boolean(name='Leaf', position='Query'),
  name?: string(name='Name', position='Query'),
  parentQueueId?: long(name='ParentQueueId', position='Query'),
  qualifiedName?: string(name='QualifiedName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourcePoolId: long(name='ResourcePoolId', position='Query'),
}

model ModifyResourceQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyResourceQueueResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyResourceQueueResponseBody(name='body'),
}

async function modifyResourceQueue(request: ModifyResourceQueueRequest): ModifyResourceQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyResourceQueue', 'POST', '/', 'json', false, 'json', request);
}

model ModifyScalingConfigItemV2Request {
  configItemBizId: string(name='ConfigItemBizId', position='Query'),
  configItemInformation: string(name='ConfigItemInformation', position='Query'),
  configItemType: string(name='ConfigItemType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scalingGroupBizId: string(name='ScalingGroupBizId', position='Query'),
}

model ModifyScalingConfigItemV2ResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyScalingConfigItemV2Response = {
  headers: map[string]string(name='headers'),
  body: ModifyScalingConfigItemV2ResponseBody(name='body'),
}

async function modifyScalingConfigItemV2(request: ModifyScalingConfigItemV2Request): ModifyScalingConfigItemV2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyScalingConfigItemV2', 'POST', '/', 'json', false, 'json', request);
}

model ModifyScalingGroupV2Request {
  description: string(name='Description', position='Query'),
  name: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scalingGroupBizId: string(name='ScalingGroupBizId', position='Query'),
}

model ModifyScalingGroupV2ResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyScalingGroupV2Response = {
  headers: map[string]string(name='headers'),
  body: ModifyScalingGroupV2ResponseBody(name='body'),
}

async function modifyScalingGroupV2(request: ModifyScalingGroupV2Request): ModifyScalingGroupV2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyScalingGroupV2', 'POST', '/', 'json', false, 'json', request);
}

model ModifyScalingRuleRequest {
  adjustmentType?: string(name='AdjustmentType', position='Query'),
  adjustmentValue?: int32(name='AdjustmentValue', position='Query'),
  cloudWatchTrigger?: [ 
    {
      comparisonOperator: string(name='ComparisonOperator'),
      evaluationCount: string(name='EvaluationCount'),
      metricName: string(name='MetricName'),
      period: int32(name='Period'),
      statistics: string(name='Statistics'),
      threshold: string(name='Threshold'),
    }
  ](name='CloudWatchTrigger', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  cooldown?: int32(name='Cooldown', position='Query'),
  hostGroupId: string(name='HostGroupId', position='Query'),
  launchExpirationTime?: int32(name='LaunchExpirationTime', position='Query'),
  launchTime?: string(name='LaunchTime', position='Query'),
  recurrenceEndTime?: string(name='RecurrenceEndTime', position='Query'),
  recurrenceType?: string(name='RecurrenceType', position='Query'),
  recurrenceValue?: string(name='RecurrenceValue', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ruleName: string(name='RuleName', position='Query'),
  scalingRuleId: string(name='ScalingRuleId', position='Query'),
  schedulerTrigger?: [ 
    {
      launchExpirationTime?: int32(name='LaunchExpirationTime'),
      launchTime: string(name='LaunchTime'),
      recurrenceEndTime?: string(name='RecurrenceEndTime'),
      recurrenceType?: string(name='RecurrenceType'),
      recurrenceValue?: string(name='RecurrenceValue'),
    }
  ](name='SchedulerTrigger', position='Query'),
  timeoutWithGrace?: long(name='TimeoutWithGrace', position='Query'),
  withGrace?: boolean(name='WithGrace', position='Query'),
}

model ModifyScalingRuleResponseBody = {
  requestId?: string(name='RequestId'),
  scalingRuleId?: string(name='ScalingRuleId'),
}

model ModifyScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyScalingRuleResponseBody(name='body'),
}

async function modifyScalingRule(request: ModifyScalingRuleRequest): ModifyScalingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyScalingRule', 'POST', '/', 'json', false, 'json', request);
}

model ModifyScalingTaskGroupRequest {
  activeRuleCategory?: string(name='ActiveRuleCategory', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  defaultCooldown?: int32(name='DefaultCooldown', position='Query'),
  hostGroupId: string(name='HostGroupId', position='Query'),
  maxSize?: int32(name='MaxSize', position='Query'),
  minSize?: int32(name='MinSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  timeoutWithGrace?: long(name='TimeoutWithGrace', position='Query'),
  withGrace?: boolean(name='WithGrace', position='Query'),
}

model ModifyScalingTaskGroupResponseBody = {
  hostGroupId?: string(name='HostGroupId'),
}

model ModifyScalingTaskGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyScalingTaskGroupResponseBody(name='body'),
}

async function modifyScalingTaskGroup(request: ModifyScalingTaskGroupRequest): ModifyScalingTaskGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyScalingTaskGroup', 'POST', '/', 'json', false, 'json', request);
}

model QueryEntityRequest {
  category: string(name='Category', position='Query'),
  description?: string(name='Description', position='Query'),
  id?: long(name='Id', position='Query'),
  name: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryEntityResponseBody = {
  items?: {
    item?: [ 
    {
      entityId?: string(name='EntityId'),
      entityType?: string(name='EntityType'),
      tagId?: long(name='TagId'),
    }
  ](name='Item')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model QueryEntityResponse = {
  headers: map[string]string(name='headers'),
  body: QueryEntityResponseBody(name='body'),
}

async function queryEntity(request: QueryEntityRequest): QueryEntityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryEntity', 'POST', '/', 'json', false, 'json', request);
}

model QueryTagRequest {
  entityId: string(name='EntityId', position='Query'),
  entityType: string(name='EntityType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tagId?: long(name='TagId', position='Query'),
}

model QueryTagResponseBody = {
  items?: {
    item?: [ 
    {
      category?: string(name='Category'),
      description?: string(name='Description'),
      name?: string(name='Name'),
    }
  ](name='Item')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model QueryTagResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTagResponseBody(name='body'),
}

async function queryTag(request: QueryTagRequest): QueryTagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryTag', 'POST', '/', 'json', false, 'json', request);
}

model RefreshClusterResourcePoolRequest {
  clusterId: string(name='ClusterId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourcePoolId: long(name='ResourcePoolId', position='Query'),
}

model RefreshClusterResourcePoolResponseBody = {
  operationId?: string(name='OperationId'),
  requestId?: string(name='RequestId'),
  workFlowInstanceId?: string(name='WorkFlowInstanceId'),
}

model RefreshClusterResourcePoolResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshClusterResourcePoolResponseBody(name='body'),
}

async function refreshClusterResourcePool(request: RefreshClusterResourcePoolRequest): RefreshClusterResourcePoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RefreshClusterResourcePool', 'POST', '/', 'json', false, 'json', request);
}

model ReleaseClusterRequest {
  forceRelease?: boolean(name='ForceRelease', position='Query'),
  id: string(name='Id', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ReleaseClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseClusterResponseBody(name='body'),
}

async function releaseCluster(request: ReleaseClusterRequest): ReleaseClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseCluster', 'POST', '/', 'json', false, 'json', request);
}

model ReleaseClusterHostGroupRequest {
  clusterId: string(name='ClusterId', position='Query'),
  hostGroupId: string(name='HostGroupId', position='Query'),
  instanceIdList?: string(name='InstanceIdList', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ReleaseClusterHostGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseClusterHostGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseClusterHostGroupResponseBody(name='body'),
}

async function releaseClusterHostGroup(request: ReleaseClusterHostGroupRequest): ReleaseClusterHostGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseClusterHostGroup', 'POST', '/', 'json', false, 'json', request);
}

model RemoveScalingConfigItemV2Request {
  configItemBizId: string(name='ConfigItemBizId', position='Query'),
  configItemType: string(name='ConfigItemType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scalingGroupBizId: string(name='ScalingGroupBizId', position='Query'),
}

model RemoveScalingConfigItemV2ResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model RemoveScalingConfigItemV2Response = {
  headers: map[string]string(name='headers'),
  body: RemoveScalingConfigItemV2ResponseBody(name='body'),
}

async function removeScalingConfigItemV2(request: RemoveScalingConfigItemV2Request): RemoveScalingConfigItemV2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveScalingConfigItemV2', 'POST', '/', 'json', false, 'json', request);
}

model RerunFlowRequest {
  flowInstanceId: string(name='FlowInstanceId', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  reRunFail?: boolean(name='ReRunFail', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RerunFlowResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model RerunFlowResponse = {
  headers: map[string]string(name='headers'),
  body: RerunFlowResponseBody(name='body'),
}

async function rerunFlow(request: RerunFlowRequest): RerunFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RerunFlow', 'POST', '/', 'json', false, 'json', request);
}

model ResizeClusterV2Request {
  autoPayOrder?: boolean(name='AutoPayOrder', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  hostComponentInfo?: [ 
    {
      componentNameList?: [ string ](name='ComponentNameList'),
      hostName?: string(name='HostName'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='HostComponentInfo', position='Query'),
  hostGroup: [ 
    {
      autoRenew?: boolean(name='AutoRenew'),
      chargeType?: string(name='ChargeType'),
      clusterId?: string(name='ClusterId'),
      comment?: string(name='Comment'),
      createType?: string(name='CreateType'),
      diskCapacity?: int32(name='DiskCapacity', minimum=40, maximum=20000),
      diskCount?: int32(name='DiskCount', minimum=1, maximum=4),
      diskType?: string(name='DiskType'),
      hostGroupId?: string(name='HostGroupId'),
      hostGroupName?: string(name='HostGroupName'),
      hostGroupType: string(name='HostGroupType'),
      hostKeyPairName?: string(name='HostKeyPairName'),
      hostPassword?: string(name='HostPassword'),
      instanceType: string(name='InstanceType'),
      nodeCount: int32(name='NodeCount', minimum=2, maximum=1000),
      period?: int32(name='Period'),
      privatePoolOptionsId?: string(name='PrivatePoolOptionsId'),
      privatePoolOptionsMatchCriteria?: string(name='PrivatePoolOptionsMatchCriteria'),
      sysDiskCapacity?: int32(name='SysDiskCapacity', minimum=40, maximum=500),
      sysDiskType?: string(name='SysDiskType'),
      vswitchId?: int32(name='VswitchId'),
    }
  ](name='HostGroup', position='Query'),
  isOpenPublicIp?: boolean(name='IsOpenPublicIp', position='Query'),
  promotionInfo?: [ 
    {
      productCode?: string(name='ProductCode'),
      promotionOptionCode?: string(name='PromotionOptionCode'),
      promotionOptionNo?: string(name='PromotionOptionNo'),
    }
  ](name='PromotionInfo', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  vswitchId?: string(name='VswitchId', position='Query'),
}

model ResizeClusterV2ResponseBody = {
  clusterId?: string(name='ClusterId'),
  requestId?: string(name='RequestId'),
}

model ResizeClusterV2Response = {
  headers: map[string]string(name='headers'),
  body: ResizeClusterV2ResponseBody(name='body'),
}

async function resizeClusterV2(request: ResizeClusterV2Request): ResizeClusterV2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResizeClusterV2', 'POST', '/', 'json', false, 'json', request);
}

model ResumeExecutionPlanSchedulerRequest {
  id: string(name='Id', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ResumeExecutionPlanSchedulerResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResumeExecutionPlanSchedulerResponse = {
  headers: map[string]string(name='headers'),
  body: ResumeExecutionPlanSchedulerResponseBody(name='body'),
}

async function resumeExecutionPlanScheduler(request: ResumeExecutionPlanSchedulerRequest): ResumeExecutionPlanSchedulerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResumeExecutionPlanScheduler', 'POST', '/', 'json', false, 'json', request);
}

model ResumeFlowRequest {
  flowInstanceId: string(name='FlowInstanceId', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ResumeFlowResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ResumeFlowResponse = {
  headers: map[string]string(name='headers'),
  body: ResumeFlowResponseBody(name='body'),
}

async function resumeFlow(request: ResumeFlowRequest): ResumeFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResumeFlow', 'POST', '/', 'json', false, 'json', request);
}

model RetryOperationRequest {
  operationId: string(name='OperationId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RetryOperationResponseBody = {
  errCode?: string(name='ErrCode'),
  errMsg?: string(name='ErrMsg'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model RetryOperationResponse = {
  headers: map[string]string(name='headers'),
  body: RetryOperationResponseBody(name='body'),
}

async function retryOperation(request: RetryOperationRequest): RetryOperationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RetryOperation', 'POST', '/', 'json', false, 'json', request);
}

model RunClusterServiceActionRequest {
  clusterId: string(name='ClusterId', position='Query'),
  comment?: string(name='Comment', position='Query'),
  componentNameList?: string(name='ComponentNameList', position='Query'),
  customCommand?: string(name='CustomCommand', position='Query'),
  customParams?: string(name='CustomParams', position='Query'),
  executeStrategy?: string(name='ExecuteStrategy', position='Query'),
  hostGroupIdList?: [ string ](name='HostGroupIdList', position='Query'),
  hostIdList?: string(name='HostIdList', position='Query'),
  interval?: long(name='Interval', position='Query'),
  isRolling?: boolean(name='IsRolling', position='Query'),
  nodeCountPerBatch?: int32(name='NodeCountPerBatch', position='Query'),
  onlyRestartStaleConfigNodes?: boolean(name='OnlyRestartStaleConfigNodes', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceActionName: string(name='ServiceActionName', position='Query'),
  serviceName: string(name='ServiceName', position='Query'),
  totlerateFailCount?: int32(name='TotlerateFailCount', position='Query'),
  turnOnMaintenanceMode?: boolean(name='TurnOnMaintenanceMode', position='Query'),
}

model RunClusterServiceActionResponseBody = {
  requestId?: string(name='RequestId'),
}

model RunClusterServiceActionResponse = {
  headers: map[string]string(name='headers'),
  body: RunClusterServiceActionResponseBody(name='body'),
}

async function runClusterServiceAction(request: RunClusterServiceActionRequest): RunClusterServiceActionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunClusterServiceAction', 'POST', '/', 'json', false, 'json', request);
}

model RunDiskOpsActivityRequest {
  clusterId: string(name='ClusterId', position='Query'),
  currentStage?: string(name='CurrentStage', position='Query'),
  currentState?: string(name='CurrentState', position='Query'),
  diskId?: string(name='DiskId', position='Query'),
  eventId?: string(name='EventId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RunDiskOpsActivityResponseBody = {
  activityState?: string(name='ActivityState'),
  clusterType?: string(name='ClusterType'),
  currentActivity?: string(name='CurrentActivity'),
  errorMessage?: string(name='ErrorMessage'),
  needReboot?: boolean(name='NeedReboot'),
  requestId?: string(name='RequestId'),
}

model RunDiskOpsActivityResponse = {
  headers: map[string]string(name='headers'),
  body: RunDiskOpsActivityResponseBody(name='body'),
}

async function runDiskOpsActivity(request: RunDiskOpsActivityRequest): RunDiskOpsActivityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunDiskOpsActivity', 'POST', '/', 'json', false, 'json', request);
}

model RunExecutionPlanRequest {
  arguments?: map[string]any(name='Arguments', position='Query'),
  id: string(name='Id', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RunExecutionPlanResponseBody = {
  executionPlanInstanceId?: string(name='ExecutionPlanInstanceId'),
  requestId?: string(name='RequestId'),
}

model RunExecutionPlanResponse = {
  headers: map[string]string(name='headers'),
  body: RunExecutionPlanResponseBody(name='body'),
}

async function runExecutionPlan(request: RunExecutionPlanRequest): RunExecutionPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunExecutionPlan', 'POST', '/', 'json', false, 'json', request);
}

model RunScalingActionV2Request {
  actionParam?: string(name='ActionParam', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scalingActionType: string(name='ScalingActionType', position='Query'),
  scalingGroupBizId: string(name='ScalingGroupBizId', position='Query'),
}

model RunScalingActionV2ResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model RunScalingActionV2Response = {
  headers: map[string]string(name='headers'),
  body: RunScalingActionV2ResponseBody(name='body'),
}

async function runScalingActionV2(request: RunScalingActionV2Request): RunScalingActionV2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunScalingActionV2', 'POST', '/', 'json', false, 'json', request);
}

model SearchLogRequest {
  clusterId: string(name='ClusterId', position='Query'),
  fromTimestamp: int32(name='FromTimestamp', position='Query'),
  hostInnerIp?: string(name='HostInnerIp', position='Query'),
  hostName?: string(name='HostName', position='Query'),
  line: int32(name='Line', position='Query'),
  logstoreName: string(name='LogstoreName', position='Query'),
  offset: int32(name='Offset', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  reverse: boolean(name='Reverse', position='Query'),
  slsQueryString: string(name='SlsQueryString', position='Query'),
  toTimestamp: int32(name='ToTimestamp', position='Query'),
}

model SearchLogResponseBody = {
  completed?: boolean(name='Completed'),
  requestId?: string(name='RequestId'),
  slsLogItemList?: {
    slsLogItem?: [ 
    {
      content?: string(name='Content'),
      hostName?: string(name='HostName'),
      packId?: string(name='PackId'),
      packMeta?: string(name='PackMeta'),
      path?: string(name='Path'),
      sourceIp?: string(name='SourceIp'),
      timestamp?: int32(name='Timestamp'),
    }
  ](name='SlsLogItem')
  }(name='SlsLogItemList'),
}

model SearchLogResponse = {
  headers: map[string]string(name='headers'),
  body: SearchLogResponseBody(name='body'),
}

async function searchLog(request: SearchLogRequest): SearchLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchLog', 'POST', '/', 'json', false, 'json', request);
}

model StartFlowRequest {
  flowInstanceId: string(name='FlowInstanceId', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model StartFlowResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model StartFlowResponse = {
  headers: map[string]string(name='headers'),
  body: StartFlowResponseBody(name='body'),
}

async function startFlow(request: StartFlowRequest): StartFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartFlow', 'POST', '/', 'json', false, 'json', request);
}

model SubmitFlowRequest {
  conf?: string(name='Conf', position='Query'),
  flowId: string(name='FlowId', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model SubmitFlowResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model SubmitFlowResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFlowResponseBody(name='body'),
}

async function submitFlow(request: SubmitFlowRequest): SubmitFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitFlow', 'POST', '/', 'json', false, 'json', request);
}

model SubmitFlowJobRequest {
  clusterId: string(name='ClusterId', position='Query'),
  conf?: string(name='Conf', position='Query'),
  hostName?: string(name='HostName', position='Query'),
  jobId: string(name='JobId', position='Query'),
  jobInstanceId?: string(name='JobInstanceId', position='Query'),
  namespace?: string(name='Namespace', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model SubmitFlowJobResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model SubmitFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFlowJobResponseBody(name='body'),
}

async function submitFlowJob(request: SubmitFlowJobRequest): SubmitFlowJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitFlowJob', 'POST', '/', 'json', false, 'json', request);
}

model SuspendExecutionPlanSchedulerRequest {
  id: string(name='Id', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model SuspendExecutionPlanSchedulerResponseBody = {
  requestId?: string(name='RequestId'),
}

model SuspendExecutionPlanSchedulerResponse = {
  headers: map[string]string(name='headers'),
  body: SuspendExecutionPlanSchedulerResponseBody(name='body'),
}

async function suspendExecutionPlanScheduler(request: SuspendExecutionPlanSchedulerRequest): SuspendExecutionPlanSchedulerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SuspendExecutionPlanScheduler', 'POST', '/', 'json', false, 'json', request);
}

model SuspendFlowRequest {
  flowInstanceId: string(name='FlowInstanceId', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model SuspendFlowResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model SuspendFlowResponse = {
  headers: map[string]string(name='headers'),
  body: SuspendFlowResponseBody(name='body'),
}

async function suspendFlow(request: SuspendFlowRequest): SuspendFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SuspendFlow', 'POST', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model UninstallLibrariesRequest {
  clusterBizIdList?: [ string ](name='ClusterBizIdList', position='Query'),
  libraryBizId?: string(name='LibraryBizId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UninstallLibrariesResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model UninstallLibrariesResponse = {
  headers: map[string]string(name='headers'),
  body: UninstallLibrariesResponseBody(name='body'),
}

async function uninstallLibraries(request: UninstallLibrariesRequest): UninstallLibrariesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UninstallLibraries', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tagKey?: [ string ](name='TagKey', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDataSourceRequest {
  conf: string(name='Conf', position='Query'),
  description: string(name='Description', position='Query'),
  id: string(name='Id', position='Query'),
  name: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UpdateDataSourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDataSourceResponseBody(name='body'),
}

async function updateDataSource(request: UpdateDataSourceRequest): UpdateDataSourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDataSource', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLibraryInstallTaskStatusRequest {
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
  taskBizId?: string(name='TaskBizId', position='Query'),
}

model UpdateLibraryInstallTaskStatusResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateLibraryInstallTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateLibraryInstallTaskStatusResponseBody(name='body'),
}

async function updateLibraryInstallTaskStatus(request: UpdateLibraryInstallTaskStatusRequest): UpdateLibraryInstallTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLibraryInstallTaskStatus', 'POST', '/', 'json', false, 'json', request);
}

model UpdateTagRequest {
  category: string(name='Category', position='Query'),
  description?: string(name='Description', position='Query'),
  id?: long(name='Id', position='Query'),
  name: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UpdateTagResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateTagResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTagResponseBody(name='body'),
}

async function updateTag(request: UpdateTagRequest): UpdateTagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateTag', 'POST', '/', 'json', false, 'json', request);
}

model UpdateUserRequest {
  aliyunUserId?: string(name='AliyunUserId', position='Query'),
  description?: string(name='Description', position='Query'),
  groupIdList?: [ integer ](name='GroupIdList', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleIdList?: [ integer ](name='RoleIdList', position='Query'),
  status?: string(name='Status', position='Query'),
  userAccountParamList?: [ 
    {
      accountPassword: string(name='AccountPassword'),
      accountType: string(name='AccountType'),
      authType?: string(name='AuthType'),
    }
  ](name='UserAccountParamList', position='Query'),
  userName: string(name='UserName', position='Query'),
  userType?: string(name='UserType', position='Query'),
}

model UpdateUserResponseBody = {
  data?: boolean(name='Data'),
  paging?: boolean(name='Paging'),
  requestId?: string(name='RequestId'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserResponseBody(name='body'),
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateUser', 'POST', '/', 'json', false, 'json', request);
}

