/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'edas.ap-northeast-1.aliyuncs.com',
    ap-south-1 = 'edas.ap-northeast-1.aliyuncs.com',
    ap-southeast-3 = 'edas.ap-northeast-1.aliyuncs.com',
    ap-southeast-5 = 'edas.ap-northeast-1.aliyuncs.com',
    cn-beijing-finance-1 = 'edas.aliyuncs.com',
    cn-beijing-finance-pop = 'edas.aliyuncs.com',
    cn-beijing-gov-1 = 'edas.aliyuncs.com',
    cn-beijing-nu16-b01 = 'edas.aliyuncs.com',
    cn-chengdu = 'edas.aliyuncs.com',
    cn-edge-1 = 'edas.aliyuncs.com',
    cn-fujian = 'edas.aliyuncs.com',
    cn-haidian-cm12-c01 = 'edas.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'edas.aliyuncs.com',
    cn-hangzhou-finance = 'edas.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'edas.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'edas.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'edas.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'edas.aliyuncs.com',
    cn-hangzhou-test-306 = 'edas.aliyuncs.com',
    cn-hongkong-finance-pop = 'edas.aliyuncs.com',
    cn-huhehaote = 'edas.aliyuncs.com',
    cn-qingdao-nebula = 'edas.aliyuncs.com',
    cn-shanghai-et15-b01 = 'edas.aliyuncs.com',
    cn-shanghai-et2-b01 = 'edas.aliyuncs.com',
    cn-shanghai-finance-1 = 'edas.aliyuncs.com',
    cn-shanghai-inner = 'edas.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'edas.aliyuncs.com',
    cn-shenzhen-finance-1 = 'edas.aliyuncs.com',
    cn-shenzhen-inner = 'edas.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'edas.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'edas.aliyuncs.com',
    cn-wuhan = 'edas.aliyuncs.com',
    cn-yushanfang = 'edas.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'edas.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'edas.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'edas.aliyuncs.com',
    eu-west-1 = 'edas.ap-northeast-1.aliyuncs.com',
    eu-west-1-oxs = 'edas.ap-northeast-1.aliyuncs.com',
    me-east-1 = 'edas.ap-northeast-1.aliyuncs.com',
    rus-west-1-pop = 'edas.ap-northeast-1.aliyuncs.com',
    us-west-1 = 'edas.ap-northeast-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('edas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AppConfig {
  command?: string(name='Command', description='启动命令'),
  commandArgs?: [ string ](name='CommandArgs', description='启动参数'),
  configMountDescs?: [ 
    {
      mountItems?: [ 
        {
          key?: string(name='Key', description='配置项'),
          path?: string(name='Path', description='路径'),
        }
      ](name='MountItems', description='挂载条目'),
      mountPath?: string(name='MountPath', description='挂载路径'),
      name?: string(name='Name', description='名称'),
      type?: string(name='Type', description='类型'),
    }
  ](name='ConfigMountDescs', description='配置项挂载配置'),
  deployAcrossNodes?: boolean(name='DeployAcrossNodes', description='是否尽量多节点部署'),
  deployAcrossZones?: boolean(name='DeployAcrossZones', description='是否尽量多可用区部署'),
  emptyDirs?: [ 
    {
      mountPath?: string(name='MountPath', description='挂载路径'),
      name?: string(name='Name', description='容器名称'),
      readOnly?: boolean(name='ReadOnly', description='是否只读'),
      subPathExpr?: string(name='SubPathExpr', description='子路径表达式'),
    }
  ](name='EmptyDirs', description='EmptyDir挂载配置'),
  enableAhas?: boolean(name='EnableAhas', description='是否开启限流降级'),
  envFroms?: [ 
    {
      configMapRef?: string(name='ConfigMapRef', description='配置项引用'),
      secretRef?: string(name='SecretRef', description='保密字典引用'),
    }
  ](name='EnvFroms', description='环境变量引用'),
  envs?: [ 
    {
      name?: string(name='Name', description='变量名'),
      value?: string(name='Value', description='变量值'),
      valueFrom?: string(name='ValueFrom', description='变量引用'),
    }
  ](name='Envs', description='环境变量'),
  imageConfig?: {
    containerRegistryId?: string(name='ContainerRegistryId', description='镜像仓库实例ID'),
    crInstanceId?: string(name='CrInstanceId', description='镜像服务实例ID'),
    crRegionId?: string(name='CrRegionId', description='镜像仓库Region'),
    imageUrl?: string(name='ImageUrl', description='镜像地址'),
  }(name='ImageConfig', description='镜像配置'),
  isMultilingualApp?: boolean(name='IsMultilingualApp', description='是否多语言应用'),
  javaStartUpConfig?: string(name='JavaStartUpConfig', description='Java启动参数配置'),
  limitCpu?: string(name='LimitCpu', description='CPU限制'),
  limitMem?: string(name='LimitMem', description='内存限制'),
  liveness?: string(name='Liveness', description='liveness探针配置'),
  localVolumes?: [ 
    {
      mountPath?: string(name='MountPath', description='容器挂载路径'),
      name?: string(name='Name', description='名称'),
      nodePath?: string(name='NodePath', description='节点路径'),
      opsAuth?: long(name='OpsAuth', description='权限类型'),
      type?: string(name='Type', description='类型'),
    }
  ](name='LocalVolumes', description='本地磁盘挂载配置'),
  nasId?: string(name='NasId', description='NAS实例ID'),
  nasMountDescs?: [ 
    {
      mountPath?: string(name='MountPath', description='NAS挂载路径'),
      nasPath?: string(name='NasPath', description='NAS文件路径'),
    }
  ](name='NasMountDescs', description='NAS挂载配置'),
  nasStorageType?: string(name='NasStorageType', description='NAS存储类型'),
  packageConfig?: {
    edasContainerVersion?: string(name='EdasContainerVersion', description='Pandora版本'),
    jdk?: string(name='Jdk', description='JDK版本'),
    packageType?: string(name='PackageType', description='部署包类型'),
    packageUrl?: string(name='PackageUrl', description='部署包地址'),
    packageVersion?: string(name='PackageVersion', description='部署包版本'),
    timezone?: string(name='Timezone', description='时区'),
    uriEncoding?: string(name='UriEncoding', description='URI字符编码'),
    useBodyEncoding?: boolean(name='UseBodyEncoding', description='useBodyEncodingForURI是否启用'),
    webContainer?: string(name='WebContainer', description='Tomcat版本'),
  }(name='PackageConfig', description='部署包配置'),
  postStart?: string(name='PostStart', description='postStart挂钩配置'),
  preStop?: string(name='PreStop', description='preStop挂钩配置'),
  pvcMountDescs?: [ 
    {
      mountPaths?: [ 
        {
          mountPath?: string(name='MountPath', description='挂载路径'),
          readOnly?: boolean(name='ReadOnly', description='是否只读'),
          subPathExpr?: string(name='SubPathExpr', description='子路径表达式'),
        }
      ](name='MountPaths', description='持久化存储挂载路径列表'),
      pvcName?: string(name='PvcName', description='持久化存储名称'),
    }
  ](name='PvcMountDescs', description='持久化存储挂载配置'),
  readiness?: string(name='Readiness', description='readiness探针配置'),
  replicas?: long(name='Replicas', description='应用实例数'),
  requestCpu?: string(name='RequestCpu', description='CPU需求'),
  requestMem?: string(name='RequestMem', description='内存需求'),
  runtimeClassName?: string(name='RuntimeClassName', description='运行时类型'),
  slsConfigs?: [ 
    {
      logDir?: string(name='LogDir', description='日志目录'),
      logstore?: string(name='Logstore', description='日志存储'),
      project?: string(name='Project', description='日志项目'),
      type?: string(name='Type', description='类型'),
    }
  ](name='SlsConfigs', description='日志采集配置'),
  webContainerConfig?: {
    connectorType?: string(name='ConnectorType', description='connector类型'),
    contextInputType?: string(name='ContextInputType', description='Context选择类型'),
    contextPath?: string(name='ContextPath', description='Context路径'),
    httpPort?: long(name='HttpPort', description='应用端口'),
    maxThreads?: long(name='MaxThreads', description='最大线程数'),
    serverXml?: string(name='ServerXml', description='自定义配置'),
    uriEncoding?: string(name='UriEncoding', description='URI字符编码'),
    useAdvancedServerXml?: boolean(name='UseAdvancedServerXml', description='是否使用高级配置'),
    useBodyEncoding?: boolean(name='UseBodyEncoding', description='useBodyEncodingForURI是否启用'),
    useDefaultConfig?: boolean(name='UseDefaultConfig', description='是否使用默认配置'),
  }(name='WebContainerConfig', description='Tomcat配置'),
}

model AbortAndRollbackChangeOrderRequest {
  changeOrderId?: string(name='ChangeOrderId'),
}

model AbortAndRollbackChangeOrderResponseBody = {
  code?: int32(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model AbortAndRollbackChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AbortAndRollbackChangeOrderResponseBody(name='body'),
}

async function abortAndRollbackChangeOrder(request: AbortAndRollbackChangeOrderRequest): AbortAndRollbackChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return abortAndRollbackChangeOrderWithOptions(request, headers, runtime);
}

async function abortAndRollbackChangeOrderWithOptions(request: AbortAndRollbackChangeOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AbortAndRollbackChangeOrderResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.changeOrderId)) {
    query['ChangeOrderId'] = request.changeOrderId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AbortAndRollbackChangeOrder',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/change_order_abort_and_rollback`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AbortChangeOrderRequest {
  changeOrderId?: string(name='ChangeOrderId'),
}

model AbortChangeOrderResponseBody = {
  code?: int32(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model AbortChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AbortChangeOrderResponseBody(name='body'),
}

async function abortChangeOrder(request: AbortChangeOrderRequest): AbortChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return abortChangeOrderWithOptions(request, headers, runtime);
}

async function abortChangeOrderWithOptions(request: AbortChangeOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AbortChangeOrderResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.changeOrderId)) {
    query['ChangeOrderId'] = request.changeOrderId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AbortChangeOrder',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/change_order_abort`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AddLogPathRequest {
  appId?: string(name='AppId'),
  path?: string(name='Path'),
}

model AddLogPathResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AddLogPathResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddLogPathResponseBody(name='body'),
}

async function addLogPath(request: AddLogPathRequest): AddLogPathResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addLogPathWithOptions(request, headers, runtime);
}

async function addLogPathWithOptions(request: AddLogPathRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddLogPathResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.path)) {
    body['Path'] = request.path;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddLogPath',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/log/popListLogDirs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AddMockRuleRequest {
  consumerAppsJson?: string(name='ConsumerAppsJson'),
  dubboMockItemJson?: string(name='DubboMockItemJson'),
  enable?: boolean(name='Enable'),
  extraJson?: string(name='ExtraJson'),
  mockType?: long(name='MockType'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  providerAppId?: string(name='ProviderAppId'),
  providerAppName?: string(name='ProviderAppName'),
  region?: string(name='Region'),
  scMockItemJson?: string(name='ScMockItemJson'),
  source?: string(name='Source'),
}

model AddMockRuleResponseBody = {
  code?: int32(name='Code'),
  data?: {
    accountId?: string(name='AccountId'),
    consumerAppId?: string(name='ConsumerAppId'),
    consumerAppName?: string(name='ConsumerAppName'),
    enable?: boolean(name='Enable'),
    extraJson?: string(name='ExtraJson'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    namespaceId?: string(name='NamespaceId'),
    providerAppId?: string(name='ProviderAppId'),
    providerAppName?: string(name='ProviderAppName'),
    region?: string(name='Region'),
    scMockItemJson?: string(name='ScMockItemJson'),
    source?: string(name='Source'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddMockRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddMockRuleResponseBody(name='body'),
}

async function addMockRule(request: AddMockRuleRequest): AddMockRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addMockRuleWithOptions(request, headers, runtime);
}

async function addMockRuleWithOptions(request: AddMockRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddMockRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.consumerAppsJson)) {
    query['ConsumerAppsJson'] = request.consumerAppsJson;
  }
  if (!Util.isUnset(request.dubboMockItemJson)) {
    query['DubboMockItemJson'] = request.dubboMockItemJson;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.extraJson)) {
    query['ExtraJson'] = request.extraJson;
  }
  if (!Util.isUnset(request.mockType)) {
    query['MockType'] = request.mockType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.providerAppId)) {
    query['ProviderAppId'] = request.providerAppId;
  }
  if (!Util.isUnset(request.providerAppName)) {
    query['ProviderAppName'] = request.providerAppName;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.scMockItemJson)) {
    query['ScMockItemJson'] = request.scMockItemJson;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddMockRule',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/sp/api/mock/addMockRule`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AuthorizeApplicationRequest {
  appIds?: string(name='AppIds'),
  targetUserId?: string(name='TargetUserId'),
}

model AuthorizeApplicationResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AuthorizeApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AuthorizeApplicationResponseBody(name='body'),
}

async function authorizeApplication(request: AuthorizeApplicationRequest): AuthorizeApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return authorizeApplicationWithOptions(request, headers, runtime);
}

async function authorizeApplicationWithOptions(request: AuthorizeApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AuthorizeApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appIds)) {
    query['AppIds'] = request.appIds;
  }
  if (!Util.isUnset(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AuthorizeApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/account/authorize_app`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AuthorizeResourceGroupRequest {
  resourceGroupIds?: string(name='ResourceGroupIds'),
  targetUserId?: string(name='TargetUserId'),
}

model AuthorizeResourceGroupResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AuthorizeResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AuthorizeResourceGroupResponseBody(name='body'),
}

async function authorizeResourceGroup(request: AuthorizeResourceGroupRequest): AuthorizeResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return authorizeResourceGroupWithOptions(request, headers, runtime);
}

async function authorizeResourceGroupWithOptions(request: AuthorizeResourceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AuthorizeResourceGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.resourceGroupIds)) {
    query['ResourceGroupIds'] = request.resourceGroupIds;
  }
  if (!Util.isUnset(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AuthorizeResourceGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/account/authorize_res_group`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AuthorizeRoleRequest {
  roleIds?: string(name='RoleIds'),
  targetUserId?: string(name='TargetUserId'),
}

model AuthorizeRoleResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AuthorizeRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AuthorizeRoleResponseBody(name='body'),
}

async function authorizeRole(request: AuthorizeRoleRequest): AuthorizeRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return authorizeRoleWithOptions(request, headers, runtime);
}

async function authorizeRoleWithOptions(request: AuthorizeRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AuthorizeRoleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.roleIds)) {
    query['RoleIds'] = request.roleIds;
  }
  if (!Util.isUnset(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AuthorizeRole',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/account/authorize_role`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BindEcsSlbRequest {
  appId?: string(name='AppId'),
  deployGroupId?: string(name='DeployGroupId'),
  listenerHealthCheckUrl?: string(name='ListenerHealthCheckUrl'),
  listenerPort?: int32(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  slbId?: string(name='SlbId'),
  VForwardingUrlRule?: string(name='VForwardingUrlRule'),
  VServerGroupId?: string(name='VServerGroupId'),
  VServerGroupName?: string(name='VServerGroupName'),
}

model BindEcsSlbResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model BindEcsSlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindEcsSlbResponseBody(name='body'),
}

async function bindEcsSlb(request: BindEcsSlbRequest): BindEcsSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return bindEcsSlbWithOptions(request, headers, runtime);
}

async function bindEcsSlbWithOptions(request: BindEcsSlbRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BindEcsSlbResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.deployGroupId)) {
    query['DeployGroupId'] = request.deployGroupId;
  }
  if (!Util.isUnset(request.listenerHealthCheckUrl)) {
    query['ListenerHealthCheckUrl'] = request.listenerHealthCheckUrl;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.slbId)) {
    query['SlbId'] = request.slbId;
  }
  if (!Util.isUnset(request.VForwardingUrlRule)) {
    query['VForwardingUrlRule'] = request.VForwardingUrlRule;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }
  if (!Util.isUnset(request.VServerGroupName)) {
    query['VServerGroupName'] = request.VServerGroupName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindEcsSlb',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/app/slb/bind_slb`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BindK8sSlbRequest {
  appId?: string(name='AppId'),
  clusterId?: string(name='ClusterId'),
  port?: string(name='Port'),
  scheduler?: string(name='Scheduler'),
  servicePortInfos?: string(name='ServicePortInfos'),
  slbId?: string(name='SlbId'),
  slbProtocol?: string(name='SlbProtocol'),
  specification?: string(name='Specification'),
  targetPort?: string(name='TargetPort'),
  type?: string(name='Type'),
}

model BindK8sSlbResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model BindK8sSlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindK8sSlbResponseBody(name='body'),
}

async function bindK8sSlb(request: BindK8sSlbRequest): BindK8sSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return bindK8sSlbWithOptions(request, headers, runtime);
}

async function bindK8sSlbWithOptions(request: BindK8sSlbRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BindK8sSlbResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.servicePortInfos)) {
    query['ServicePortInfos'] = request.servicePortInfos;
  }
  if (!Util.isUnset(request.slbId)) {
    query['SlbId'] = request.slbId;
  }
  if (!Util.isUnset(request.slbProtocol)) {
    query['SlbProtocol'] = request.slbProtocol;
  }
  if (!Util.isUnset(request.specification)) {
    query['Specification'] = request.specification;
  }
  if (!Util.isUnset(request.targetPort)) {
    query['TargetPort'] = request.targetPort;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindK8sSlb',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_slb_binding`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BindSlbRequest {
  appId?: string(name='AppId'),
  listenerPort?: int32(name='ListenerPort'),
  slbId?: string(name='SlbId'),
  slbIp?: string(name='SlbIp'),
  type?: string(name='Type'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model BindSlbResponseBody = {
  code?: int32(name='Code'),
  data?: {
    extSlbId?: string(name='ExtSlbId'),
    extSlbIp?: string(name='ExtSlbIp'),
    extSlbName?: string(name='ExtSlbName'),
    extVServerGroupId?: string(name='ExtVServerGroupId'),
    slbId?: string(name='SlbId'),
    slbIp?: string(name='SlbIp'),
    slbName?: string(name='SlbName'),
    slbPort?: int32(name='SlbPort'),
    VServerGroupId?: string(name='VServerGroupId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model BindSlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindSlbResponseBody(name='body'),
}

async function bindSlb(request: BindSlbRequest): BindSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return bindSlbWithOptions(request, headers, runtime);
}

async function bindSlbWithOptions(request: BindSlbRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BindSlbResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.slbId)) {
    query['SlbId'] = request.slbId;
  }
  if (!Util.isUnset(request.slbIp)) {
    query['SlbIp'] = request.slbIp;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindSlb',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/app/bind_slb_json`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ChangeDeployGroupRequest {
  appId?: string(name='AppId'),
  eccInfo?: string(name='EccInfo'),
  forceStatus?: boolean(name='ForceStatus'),
  groupName?: string(name='GroupName'),
}

model ChangeDeployGroupResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ChangeDeployGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeDeployGroupResponseBody(name='body'),
}

async function changeDeployGroup(request: ChangeDeployGroupRequest): ChangeDeployGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return changeDeployGroupWithOptions(request, headers, runtime);
}

async function changeDeployGroupWithOptions(request: ChangeDeployGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ChangeDeployGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.eccInfo)) {
    query['EccInfo'] = request.eccInfo;
  }
  if (!Util.isUnset(request.forceStatus)) {
    query['ForceStatus'] = request.forceStatus;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeDeployGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/co_change_group`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ContinuePipelineRequest {
  confirm?: boolean(name='Confirm'),
  pipelineId?: string(name='PipelineId'),
}

model ContinuePipelineResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ContinuePipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ContinuePipelineResponseBody(name='body'),
}

async function continuePipeline(request: ContinuePipelineRequest): ContinuePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return continuePipelineWithOptions(request, headers, runtime);
}

async function continuePipelineWithOptions(request: ContinuePipelineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ContinuePipelineResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.confirm)) {
    query['Confirm'] = request.confirm;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ContinuePipeline',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/pipeline_batch_confirm`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ConvertK8sResourceRequest {
  clusterId?: string(name='ClusterId'),
  namespace?: string(name='Namespace'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
}

model ConvertK8sResourceResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ConvertK8sResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConvertK8sResourceResponseBody(name='body'),
}

async function convertK8sResource(request: ConvertK8sResourceRequest): ConvertK8sResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return convertK8sResourceWithOptions(request, headers, runtime);
}

async function convertK8sResourceWithOptions(request: ConvertK8sResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ConvertK8sResourceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConvertK8sResource',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/oam/k8s_resource_convert`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateApplicationScalingRuleRequest {
  appId?: string(name='AppId'),
  scalingRuleEnable?: boolean(name='ScalingRuleEnable'),
  scalingRuleMetric?: string(name='ScalingRuleMetric'),
  scalingRuleName?: string(name='ScalingRuleName'),
  scalingRuleTimer?: string(name='ScalingRuleTimer'),
  scalingRuleTrigger?: string(name='ScalingRuleTrigger'),
  scalingRuleType?: string(name='ScalingRuleType'),
}

model CreateApplicationScalingRuleResponseBody = {
  appScalingRule?: {
    appId?: string(name='AppId'),
    createTime?: long(name='CreateTime'),
    lastDisableTime?: long(name='LastDisableTime'),
    maxReplicas?: int32(name='MaxReplicas'),
    metric?: {
      maxReplicas?: int32(name='MaxReplicas'),
      metrics?: [ 
        {
          metricTargetAverageUtilization?: int32(name='MetricTargetAverageUtilization'),
          metricType?: string(name='MetricType'),
        }
      ](name='Metrics'),
      minReplicas?: int32(name='MinReplicas'),
    }(name='Metric'),
    minReplicas?: int32(name='MinReplicas'),
    scaleRuleEnabled?: boolean(name='ScaleRuleEnabled'),
    scaleRuleName?: string(name='ScaleRuleName'),
    scaleRuleType?: string(name='ScaleRuleType'),
    trigger?: {
      maxReplicas?: int32(name='MaxReplicas'),
      minReplicas?: int32(name='MinReplicas'),
      triggers?: [ 
        {
          metaData?: string(name='MetaData'),
          name?: string(name='Name'),
          type?: string(name='Type'),
        }
      ](name='Triggers'),
    }(name='Trigger'),
    updateTime?: long(name='UpdateTime'),
  }(name='AppScalingRule'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateApplicationScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateApplicationScalingRuleResponseBody(name='body'),
}

async function createApplicationScalingRule(request: CreateApplicationScalingRuleRequest): CreateApplicationScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createApplicationScalingRuleWithOptions(request, headers, runtime);
}

async function createApplicationScalingRuleWithOptions(request: CreateApplicationScalingRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateApplicationScalingRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.scalingRuleEnable)) {
    query['ScalingRuleEnable'] = request.scalingRuleEnable;
  }
  if (!Util.isUnset(request.scalingRuleMetric)) {
    query['ScalingRuleMetric'] = request.scalingRuleMetric;
  }
  if (!Util.isUnset(request.scalingRuleName)) {
    query['ScalingRuleName'] = request.scalingRuleName;
  }
  if (!Util.isUnset(request.scalingRuleTimer)) {
    query['ScalingRuleTimer'] = request.scalingRuleTimer;
  }
  if (!Util.isUnset(request.scalingRuleTrigger)) {
    query['ScalingRuleTrigger'] = request.scalingRuleTrigger;
  }
  if (!Util.isUnset(request.scalingRuleType)) {
    query['ScalingRuleType'] = request.scalingRuleType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateApplicationScalingRule',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v1/eam/scale/application_scaling_rule`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateConfigTemplateRequest {
  content?: string(name='Content', description='模板内容'),
  description?: string(name='Description', description='模板描述'),
  format?: string(name='Format', description='模板数据格式'),
  name?: string(name='Name', description='配置模板名称'),
}

model CreateConfigTemplateResponseBody = {
  code?: int32(name='Code', description='响应码'),
  data?: {
    id?: long(name='Id', description='模板ID'),
  }(name='Data', description='响应数据'),
  message?: string(name='Message', description='响应码文本描述'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model CreateConfigTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateConfigTemplateResponseBody(name='body'),
}

async function createConfigTemplate(request: CreateConfigTemplateRequest): CreateConfigTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createConfigTemplateWithOptions(request, headers, runtime);
}

async function createConfigTemplateWithOptions(request: CreateConfigTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateConfigTemplateResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.format)) {
    body['Format'] = request.format;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConfigTemplate',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/config_template`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateIDCImportCommandRequest {
  clusterId?: string(name='ClusterId'),
}

model CreateIDCImportCommandResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateIDCImportCommandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIDCImportCommandResponseBody(name='body'),
}

async function createIDCImportCommand(request: CreateIDCImportCommandRequest): CreateIDCImportCommandResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIDCImportCommandWithOptions(request, headers, runtime);
}

async function createIDCImportCommandWithOptions(request: CreateIDCImportCommandRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIDCImportCommandResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIDCImportCommand',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/create_idc_import_command`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateK8sConfigMapRequest {
  clusterId?: string(name='ClusterId'),
  data?: map[string]any(name='Data'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
}

model CreateK8sConfigMapResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateK8sConfigMapResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateK8sConfigMapResponseBody(name='body'),
}

async function createK8sConfigMap(request: CreateK8sConfigMapRequest): CreateK8sConfigMapResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createK8sConfigMapWithOptions(request, headers, runtime);
}

async function createK8sConfigMapWithOptions(request: CreateK8sConfigMapRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateK8sConfigMapResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.data)) {
    body['Data'] = request.data;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateK8sConfigMap',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_config_map`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateK8sIngressRuleRequest {
  clusterId?: string(name='ClusterId'),
  ingressConf?: map[string]any(name='IngressConf'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
}

model CreateK8sIngressRuleResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
}

model CreateK8sIngressRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateK8sIngressRuleResponseBody(name='body'),
}

async function createK8sIngressRule(request: CreateK8sIngressRuleRequest): CreateK8sIngressRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createK8sIngressRuleWithOptions(request, headers, runtime);
}

async function createK8sIngressRuleWithOptions(request: CreateK8sIngressRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateK8sIngressRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ingressConf)) {
    query['IngressConf'] = request.ingressConf;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateK8sIngressRule',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_ingress`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateK8sSecretRequest {
  base64Encoded?: boolean(name='Base64Encoded'),
  certId?: string(name='CertId'),
  certRegionId?: string(name='CertRegionId'),
  clusterId?: string(name='ClusterId'),
  data?: string(name='Data'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  type?: string(name='Type'),
}

model CreateK8sSecretResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateK8sSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateK8sSecretResponseBody(name='body'),
}

async function createK8sSecret(request: CreateK8sSecretRequest): CreateK8sSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createK8sSecretWithOptions(request, headers, runtime);
}

async function createK8sSecretWithOptions(request: CreateK8sSecretRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateK8sSecretResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.base64Encoded)) {
    body['Base64Encoded'] = request.base64Encoded;
  }
  if (!Util.isUnset(request.certId)) {
    body['CertId'] = request.certId;
  }
  if (!Util.isUnset(request.certRegionId)) {
    body['CertRegionId'] = request.certRegionId;
  }
  if (!Util.isUnset(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.data)) {
    body['Data'] = request.data;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateK8sSecret',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_secret`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateK8sServiceRequest {
  appId?: string(name='AppId'),
  name?: string(name='Name'),
  servicePorts?: map[string]any(name='ServicePorts'),
  type?: string(name='Type'),
}

model CreateK8sServiceResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateK8sServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateK8sServiceResponseBody(name='body'),
}

async function createK8sService(request: CreateK8sServiceRequest): CreateK8sServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createK8sServiceWithOptions(request, headers, runtime);
}

async function createK8sServiceWithOptions(request: CreateK8sServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateK8sServiceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.servicePorts)) {
    query['ServicePorts'] = request.servicePorts;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateK8sService',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_service`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteApplicationRequest {
  appId?: string(name='AppId'),
}

model DeleteApplicationResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteApplicationResponseBody(name='body'),
}

async function deleteApplication(request: DeleteApplicationRequest): DeleteApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteApplicationWithOptions(request, headers, runtime);
}

async function deleteApplicationWithOptions(request: DeleteApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/co_delete_app`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteApplicationScalingRuleRequest {
  appId?: string(name='AppId'),
  scalingRuleName?: string(name='ScalingRuleName'),
}

model DeleteApplicationScalingRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteApplicationScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteApplicationScalingRuleResponseBody(name='body'),
}

async function deleteApplicationScalingRule(request: DeleteApplicationScalingRuleRequest): DeleteApplicationScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteApplicationScalingRuleWithOptions(request, headers, runtime);
}

async function deleteApplicationScalingRuleWithOptions(request: DeleteApplicationScalingRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteApplicationScalingRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.scalingRuleName)) {
    query['ScalingRuleName'] = request.scalingRuleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteApplicationScalingRule',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v1/eam/scale/application_scaling_rule`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteClusterRequest {
  clusterId?: string(name='ClusterId'),
  mode?: int32(name='Mode'),
}

model DeleteClusterResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteClusterResponseBody(name='body'),
}

async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteClusterWithOptions(request, headers, runtime);
}

async function deleteClusterWithOptions(request: DeleteClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/cluster`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteClusterMemberRequest {
  clusterId?: string(name='ClusterId'),
  clusterMemberId?: string(name='ClusterMemberId'),
}

model DeleteClusterMemberResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteClusterMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteClusterMemberResponseBody(name='body'),
}

async function deleteClusterMember(request: DeleteClusterMemberRequest): DeleteClusterMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteClusterMemberWithOptions(request, headers, runtime);
}

async function deleteClusterMemberWithOptions(request: DeleteClusterMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteClusterMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterMemberId)) {
    query['ClusterMemberId'] = request.clusterMemberId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteClusterMember',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/cluster_member`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteConfigTemplateRequest {
  id?: long(name='Id', description='配置模板ID'),
}

model DeleteConfigTemplateResponseBody = {
  code?: int32(name='Code', description='响应码'),
  message?: string(name='Message', description='响应码文本描述'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model DeleteConfigTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteConfigTemplateResponseBody(name='body'),
}

async function deleteConfigTemplate(request: DeleteConfigTemplateRequest): DeleteConfigTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConfigTemplateWithOptions(request, headers, runtime);
}

async function deleteConfigTemplateWithOptions(request: DeleteConfigTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConfigTemplateResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteConfigTemplate',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/config_template`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteDeployGroupRequest {
  appId?: string(name='AppId'),
  groupName?: string(name='GroupName'),
}

model DeleteDeployGroupResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteDeployGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDeployGroupResponseBody(name='body'),
}

async function deleteDeployGroup(request: DeleteDeployGroupRequest): DeleteDeployGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDeployGroupWithOptions(request, headers, runtime);
}

async function deleteDeployGroupWithOptions(request: DeleteDeployGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDeployGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeployGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/deploy_group`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteEcuRequest {
  ecuId?: string(name='EcuId'),
}

model DeleteEcuResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteEcuResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEcuResponseBody(name='body'),
}

async function deleteEcu(request: DeleteEcuRequest): DeleteEcuResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEcuWithOptions(request, headers, runtime);
}

async function deleteEcuWithOptions(request: DeleteEcuRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteEcuResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.ecuId)) {
    query['EcuId'] = request.ecuId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEcu',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/delete_ecu`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteK8sApplicationRequest {
  appId?: string(name='AppId'),
}

model DeleteK8sApplicationResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteK8sApplicationResponseBody(name='body'),
}

async function deleteK8sApplication(request: DeleteK8sApplicationRequest): DeleteK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteK8sApplicationWithOptions(request, headers, runtime);
}

async function deleteK8sApplicationWithOptions(request: DeleteK8sApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteK8sApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteK8sApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_apps`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteK8sConfigMapRequest {
  clusterId?: string(name='ClusterId'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
}

model DeleteK8sConfigMapResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteK8sConfigMapResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteK8sConfigMapResponseBody(name='body'),
}

async function deleteK8sConfigMap(request: DeleteK8sConfigMapRequest): DeleteK8sConfigMapResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteK8sConfigMapWithOptions(request, headers, runtime);
}

async function deleteK8sConfigMapWithOptions(request: DeleteK8sConfigMapRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteK8sConfigMapResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteK8sConfigMap',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_config_map`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteK8sIngressRuleRequest {
  clusterId?: string(name='ClusterId'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
}

model DeleteK8sIngressRuleResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
}

model DeleteK8sIngressRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteK8sIngressRuleResponseBody(name='body'),
}

async function deleteK8sIngressRule(request: DeleteK8sIngressRuleRequest): DeleteK8sIngressRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteK8sIngressRuleWithOptions(request, headers, runtime);
}

async function deleteK8sIngressRuleWithOptions(request: DeleteK8sIngressRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteK8sIngressRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteK8sIngressRule',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_ingress`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteK8sSecretRequest {
  clusterId?: string(name='ClusterId'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
}

model DeleteK8sSecretResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteK8sSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteK8sSecretResponseBody(name='body'),
}

async function deleteK8sSecret(request: DeleteK8sSecretRequest): DeleteK8sSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteK8sSecretWithOptions(request, headers, runtime);
}

async function deleteK8sSecretWithOptions(request: DeleteK8sSecretRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteK8sSecretResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteK8sSecret',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_secret`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteK8sServiceRequest {
  appId?: string(name='AppId'),
  name?: string(name='Name'),
}

model DeleteK8sServiceResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteK8sServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteK8sServiceResponseBody(name='body'),
}

async function deleteK8sService(request: DeleteK8sServiceRequest): DeleteK8sServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteK8sServiceWithOptions(request, headers, runtime);
}

async function deleteK8sServiceWithOptions(request: DeleteK8sServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteK8sServiceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteK8sService',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_service`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteLogPathRequest {
  appId?: string(name='AppId'),
  path?: string(name='Path'),
}

model DeleteLogPathResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteLogPathResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLogPathResponseBody(name='body'),
}

async function deleteLogPath(request: DeleteLogPathRequest): DeleteLogPathResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLogPathWithOptions(request, headers, runtime);
}

async function deleteLogPathWithOptions(request: DeleteLogPathRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLogPathResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLogPath',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/log/popListLogDirs`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteRoleRequest {
  roleId?: int32(name='RoleId'),
}

model DeleteRoleResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRoleResponseBody(name='body'),
}

async function deleteRole(request: DeleteRoleRequest): DeleteRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRoleWithOptions(request, headers, runtime);
}

async function deleteRoleWithOptions(request: DeleteRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRoleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.roleId)) {
    query['RoleId'] = request.roleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRole',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/account/delete_role`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceGroupRequest {
  groupId?: string(name='GroupId'),
}

model DeleteServiceGroupResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceGroupResponseBody(name='body'),
}

async function deleteServiceGroup(request: DeleteServiceGroupRequest): DeleteServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceGroupWithOptions(request, headers, runtime);
}

async function deleteServiceGroupWithOptions(request: DeleteServiceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/service/serviceGroups`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteUserDefineRegionRequest {
  id?: long(name='Id'),
  regionTag?: string(name='RegionTag'),
}

model DeleteUserDefineRegionResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  regionDefine?: {
    belongRegion?: string(name='BelongRegion'),
    description?: string(name='Description'),
    id?: long(name='Id'),
    regionId?: string(name='RegionId'),
    regionName?: string(name='RegionName'),
    userId?: string(name='UserId'),
  }(name='RegionDefine'),
  requestId?: string(name='RequestId'),
}

model DeleteUserDefineRegionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUserDefineRegionResponseBody(name='body'),
}

async function deleteUserDefineRegion(request: DeleteUserDefineRegionRequest): DeleteUserDefineRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteUserDefineRegionWithOptions(request, headers, runtime);
}

async function deleteUserDefineRegionWithOptions(request: DeleteUserDefineRegionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteUserDefineRegionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.regionTag)) {
    query['RegionTag'] = request.regionTag;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUserDefineRegion',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/user_region_def`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeployApplicationRequest {
  appEnv?: string(name='AppEnv'),
  appId?: string(name='AppId'),
  batch?: int32(name='Batch'),
  batchWaitTime?: int32(name='BatchWaitTime'),
  buildPackId?: long(name='BuildPackId'),
  componentIds?: string(name='ComponentIds'),
  deployType?: string(name='DeployType'),
  desc?: string(name='Desc'),
  gray?: boolean(name='Gray'),
  groupId?: string(name='GroupId'),
  imageUrl?: string(name='ImageUrl'),
  packageVersion?: string(name='PackageVersion'),
  releaseType?: long(name='ReleaseType'),
  trafficControlStrategy?: string(name='TrafficControlStrategy'),
  warUrl?: string(name='WarUrl'),
}

model DeployApplicationResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeployApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeployApplicationResponseBody(name='body'),
}

async function deployApplication(request: DeployApplicationRequest): DeployApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deployApplicationWithOptions(request, headers, runtime);
}

async function deployApplicationWithOptions(request: DeployApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeployApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appEnv)) {
    query['AppEnv'] = request.appEnv;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.batch)) {
    query['Batch'] = request.batch;
  }
  if (!Util.isUnset(request.batchWaitTime)) {
    query['BatchWaitTime'] = request.batchWaitTime;
  }
  if (!Util.isUnset(request.buildPackId)) {
    query['BuildPackId'] = request.buildPackId;
  }
  if (!Util.isUnset(request.componentIds)) {
    query['ComponentIds'] = request.componentIds;
  }
  if (!Util.isUnset(request.deployType)) {
    query['DeployType'] = request.deployType;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.gray)) {
    query['Gray'] = request.gray;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.imageUrl)) {
    query['ImageUrl'] = request.imageUrl;
  }
  if (!Util.isUnset(request.packageVersion)) {
    query['PackageVersion'] = request.packageVersion;
  }
  if (!Util.isUnset(request.releaseType)) {
    query['ReleaseType'] = request.releaseType;
  }
  if (!Util.isUnset(request.trafficControlStrategy)) {
    query['TrafficControlStrategy'] = request.trafficControlStrategy;
  }
  if (!Util.isUnset(request.warUrl)) {
    query['WarUrl'] = request.warUrl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeployApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/co_deploy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeployK8sApplicationRequest {
  annotations?: string(name='Annotations'),
  appId?: string(name='AppId'),
  args?: string(name='Args'),
  batchTimeout?: int32(name='BatchTimeout'),
  batchWaitTime?: int32(name='BatchWaitTime'),
  buildPackId?: string(name='BuildPackId'),
  changeOrderDesc?: string(name='ChangeOrderDesc'),
  command?: string(name='Command'),
  configMountDescs?: string(name='ConfigMountDescs'),
  cpuLimit?: int32(name='CpuLimit'),
  cpuRequest?: int32(name='CpuRequest'),
  customAffinity?: string(name='CustomAffinity'),
  customTolerations?: string(name='CustomTolerations'),
  deployAcrossNodes?: string(name='DeployAcrossNodes'),
  deployAcrossZones?: string(name='DeployAcrossZones'),
  edasContainerVersion?: string(name='EdasContainerVersion'),
  emptyDirs?: string(name='EmptyDirs'),
  enableAhas?: boolean(name='EnableAhas'),
  enableEmptyPushReject?: boolean(name='EnableEmptyPushReject', description='是否开启推空保护'),
  enableLosslessRule?: boolean(name='EnableLosslessRule', description='是否启用无损上线规则'),
  envFroms?: string(name='EnvFroms'),
  envs?: string(name='Envs'),
  image?: string(name='Image'),
  imageTag?: string(name='ImageTag'),
  JDK?: string(name='JDK'),
  javaStartUpConfig?: string(name='JavaStartUpConfig'),
  labels?: string(name='Labels'),
  liveness?: string(name='Liveness'),
  localVolume?: string(name='LocalVolume'),
  losslessRuleAligned?: boolean(name='LosslessRuleAligned', description='是否启用无损滚动发布模式配置通过就绪检查前完成服务注册'),
  losslessRuleDelayTime?: int32(name='LosslessRuleDelayTime', description='无损上线延迟注册时长'),
  losslessRuleFuncType?: int32(name='LosslessRuleFuncType', description='无损上线服务预热曲线'),
  losslessRuleRelated?: boolean(name='LosslessRuleRelated', description='是否启用无损滚动发布模式配置通过就绪检查前完成服务预热'),
  losslessRuleWarmupTime?: int32(name='LosslessRuleWarmupTime', description='无损上线服务预热时长'),
  mcpuLimit?: int32(name='McpuLimit'),
  mcpuRequest?: int32(name='McpuRequest'),
  memoryLimit?: int32(name='MemoryLimit'),
  memoryRequest?: int32(name='MemoryRequest'),
  mountDescs?: string(name='MountDescs'),
  nasId?: string(name='NasId'),
  packageUrl?: string(name='PackageUrl'),
  packageVersion?: string(name='PackageVersion'),
  packageVersionId?: string(name='PackageVersionId'),
  postStart?: string(name='PostStart'),
  preStop?: string(name='PreStop'),
  pvcMountDescs?: string(name='PvcMountDescs'),
  readiness?: string(name='Readiness'),
  replicas?: int32(name='Replicas'),
  runtimeClassName?: string(name='RuntimeClassName'),
  slsConfigs?: string(name='SlsConfigs'),
  storageType?: string(name='StorageType'),
  trafficControlStrategy?: string(name='TrafficControlStrategy'),
  updateStrategy?: string(name='UpdateStrategy'),
  uriEncoding?: string(name='UriEncoding'),
  useBodyEncoding?: boolean(name='UseBodyEncoding'),
  volumesStr?: string(name='VolumesStr'),
  webContainer?: string(name='WebContainer'),
  webContainerConfig?: string(name='WebContainerConfig'),
}

model DeployK8sApplicationResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeployK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeployK8sApplicationResponseBody(name='body'),
}

async function deployK8sApplication(request: DeployK8sApplicationRequest): DeployK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deployK8sApplicationWithOptions(request, headers, runtime);
}

async function deployK8sApplicationWithOptions(request: DeployK8sApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeployK8sApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.annotations)) {
    query['Annotations'] = request.annotations;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.args)) {
    query['Args'] = request.args;
  }
  if (!Util.isUnset(request.batchTimeout)) {
    query['BatchTimeout'] = request.batchTimeout;
  }
  if (!Util.isUnset(request.batchWaitTime)) {
    query['BatchWaitTime'] = request.batchWaitTime;
  }
  if (!Util.isUnset(request.buildPackId)) {
    query['BuildPackId'] = request.buildPackId;
  }
  if (!Util.isUnset(request.changeOrderDesc)) {
    query['ChangeOrderDesc'] = request.changeOrderDesc;
  }
  if (!Util.isUnset(request.command)) {
    query['Command'] = request.command;
  }
  if (!Util.isUnset(request.configMountDescs)) {
    query['ConfigMountDescs'] = request.configMountDescs;
  }
  if (!Util.isUnset(request.cpuLimit)) {
    query['CpuLimit'] = request.cpuLimit;
  }
  if (!Util.isUnset(request.cpuRequest)) {
    query['CpuRequest'] = request.cpuRequest;
  }
  if (!Util.isUnset(request.customAffinity)) {
    query['CustomAffinity'] = request.customAffinity;
  }
  if (!Util.isUnset(request.customTolerations)) {
    query['CustomTolerations'] = request.customTolerations;
  }
  if (!Util.isUnset(request.deployAcrossNodes)) {
    query['DeployAcrossNodes'] = request.deployAcrossNodes;
  }
  if (!Util.isUnset(request.deployAcrossZones)) {
    query['DeployAcrossZones'] = request.deployAcrossZones;
  }
  if (!Util.isUnset(request.edasContainerVersion)) {
    query['EdasContainerVersion'] = request.edasContainerVersion;
  }
  if (!Util.isUnset(request.emptyDirs)) {
    query['EmptyDirs'] = request.emptyDirs;
  }
  if (!Util.isUnset(request.enableAhas)) {
    query['EnableAhas'] = request.enableAhas;
  }
  if (!Util.isUnset(request.enableEmptyPushReject)) {
    query['EnableEmptyPushReject'] = request.enableEmptyPushReject;
  }
  if (!Util.isUnset(request.enableLosslessRule)) {
    query['EnableLosslessRule'] = request.enableLosslessRule;
  }
  if (!Util.isUnset(request.envFroms)) {
    query['EnvFroms'] = request.envFroms;
  }
  if (!Util.isUnset(request.envs)) {
    query['Envs'] = request.envs;
  }
  if (!Util.isUnset(request.image)) {
    query['Image'] = request.image;
  }
  if (!Util.isUnset(request.imageTag)) {
    query['ImageTag'] = request.imageTag;
  }
  if (!Util.isUnset(request.JDK)) {
    query['JDK'] = request.JDK;
  }
  if (!Util.isUnset(request.javaStartUpConfig)) {
    query['JavaStartUpConfig'] = request.javaStartUpConfig;
  }
  if (!Util.isUnset(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.liveness)) {
    query['Liveness'] = request.liveness;
  }
  if (!Util.isUnset(request.localVolume)) {
    query['LocalVolume'] = request.localVolume;
  }
  if (!Util.isUnset(request.losslessRuleAligned)) {
    query['LosslessRuleAligned'] = request.losslessRuleAligned;
  }
  if (!Util.isUnset(request.losslessRuleDelayTime)) {
    query['LosslessRuleDelayTime'] = request.losslessRuleDelayTime;
  }
  if (!Util.isUnset(request.losslessRuleFuncType)) {
    query['LosslessRuleFuncType'] = request.losslessRuleFuncType;
  }
  if (!Util.isUnset(request.losslessRuleRelated)) {
    query['LosslessRuleRelated'] = request.losslessRuleRelated;
  }
  if (!Util.isUnset(request.losslessRuleWarmupTime)) {
    query['LosslessRuleWarmupTime'] = request.losslessRuleWarmupTime;
  }
  if (!Util.isUnset(request.mcpuLimit)) {
    query['McpuLimit'] = request.mcpuLimit;
  }
  if (!Util.isUnset(request.mcpuRequest)) {
    query['McpuRequest'] = request.mcpuRequest;
  }
  if (!Util.isUnset(request.memoryLimit)) {
    query['MemoryLimit'] = request.memoryLimit;
  }
  if (!Util.isUnset(request.memoryRequest)) {
    query['MemoryRequest'] = request.memoryRequest;
  }
  if (!Util.isUnset(request.mountDescs)) {
    query['MountDescs'] = request.mountDescs;
  }
  if (!Util.isUnset(request.nasId)) {
    query['NasId'] = request.nasId;
  }
  if (!Util.isUnset(request.packageUrl)) {
    query['PackageUrl'] = request.packageUrl;
  }
  if (!Util.isUnset(request.packageVersion)) {
    query['PackageVersion'] = request.packageVersion;
  }
  if (!Util.isUnset(request.packageVersionId)) {
    query['PackageVersionId'] = request.packageVersionId;
  }
  if (!Util.isUnset(request.postStart)) {
    query['PostStart'] = request.postStart;
  }
  if (!Util.isUnset(request.preStop)) {
    query['PreStop'] = request.preStop;
  }
  if (!Util.isUnset(request.pvcMountDescs)) {
    query['PvcMountDescs'] = request.pvcMountDescs;
  }
  if (!Util.isUnset(request.readiness)) {
    query['Readiness'] = request.readiness;
  }
  if (!Util.isUnset(request.replicas)) {
    query['Replicas'] = request.replicas;
  }
  if (!Util.isUnset(request.runtimeClassName)) {
    query['RuntimeClassName'] = request.runtimeClassName;
  }
  if (!Util.isUnset(request.slsConfigs)) {
    query['SlsConfigs'] = request.slsConfigs;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  if (!Util.isUnset(request.trafficControlStrategy)) {
    query['TrafficControlStrategy'] = request.trafficControlStrategy;
  }
  if (!Util.isUnset(request.updateStrategy)) {
    query['UpdateStrategy'] = request.updateStrategy;
  }
  if (!Util.isUnset(request.uriEncoding)) {
    query['UriEncoding'] = request.uriEncoding;
  }
  if (!Util.isUnset(request.useBodyEncoding)) {
    query['UseBodyEncoding'] = request.useBodyEncoding;
  }
  if (!Util.isUnset(request.volumesStr)) {
    query['VolumesStr'] = request.volumesStr;
  }
  if (!Util.isUnset(request.webContainer)) {
    query['WebContainer'] = request.webContainer;
  }
  if (!Util.isUnset(request.webContainerConfig)) {
    query['WebContainerConfig'] = request.webContainerConfig;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeployK8sApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_apps`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeAppInstanceListRequest {
  appId?: string(name='AppId'),
  withNodeInfo?: boolean(name='WithNodeInfo'),
}

model DescribeAppInstanceListResponseBody = {
  code?: int32(name='Code'),
  instanceList?: [ 
    {
      appId?: string(name='AppId'),
      canary?: boolean(name='Canary'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      nodeLabels?: string(name='NodeLabels'),
      nodeName?: string(name='NodeName'),
      podRaw?: string(name='PodRaw'),
      version?: string(name='Version'),
    }
  ](name='InstanceList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeAppInstanceListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAppInstanceListResponseBody(name='body'),
}

async function describeAppInstanceList(request: DescribeAppInstanceListRequest): DescribeAppInstanceListResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeAppInstanceListWithOptions(request, headers, runtime);
}

async function describeAppInstanceListWithOptions(request: DescribeAppInstanceListRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeAppInstanceListResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.withNodeInfo)) {
    query['WithNodeInfo'] = request.withNodeInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAppInstanceList',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/oam/app_instance_list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeApplicationScalingRulesRequest {
  appId?: string(name='AppId'),
}

model DescribeApplicationScalingRulesResponseBody = {
  appScalingRules?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        appId?: string(name='AppId'),
        createTime?: long(name='CreateTime'),
        lastDisableTime?: long(name='LastDisableTime'),
        maxReplicas?: int32(name='MaxReplicas'),
        metric?: {
          maxReplicas?: int32(name='MaxReplicas'),
          metrics?: [ 
            {
              metricTargetAverageUtilization?: int32(name='MetricTargetAverageUtilization'),
              metricType?: string(name='MetricType'),
            }
          ](name='Metrics'),
          minReplicas?: int32(name='MinReplicas'),
        }(name='Metric'),
        minReplicas?: int32(name='MinReplicas'),
        scaleRuleEnabled?: boolean(name='ScaleRuleEnabled'),
        scaleRuleName?: string(name='ScaleRuleName'),
        scaleRuleType?: string(name='ScaleRuleType'),
        trigger?: {
          maxReplicas?: int32(name='MaxReplicas'),
          minReplicas?: int32(name='MinReplicas'),
          triggers?: [ 
            {
              metaData?: string(name='MetaData'),
              name?: string(name='Name'),
              type?: string(name='Type'),
            }
          ](name='Triggers'),
        }(name='Trigger'),
        updateTime?: long(name='UpdateTime'),
      }
    ](name='Result'),
    totalSize?: long(name='TotalSize'),
  }(name='AppScalingRules'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeApplicationScalingRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeApplicationScalingRulesResponseBody(name='body'),
}

async function describeApplicationScalingRules(request: DescribeApplicationScalingRulesRequest): DescribeApplicationScalingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeApplicationScalingRulesWithOptions(request, headers, runtime);
}

async function describeApplicationScalingRulesWithOptions(request: DescribeApplicationScalingRulesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeApplicationScalingRulesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApplicationScalingRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v1/eam/scale/application_scaling_rules`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DisableApplicationScalingRuleRequest {
  appId?: string(name='AppId'),
  scalingRuleName?: string(name='ScalingRuleName'),
}

model DisableApplicationScalingRuleResponseBody = {
  appScalingRule?: {
    appId?: string(name='AppId'),
    createTime?: long(name='CreateTime'),
    lastDisableTime?: long(name='LastDisableTime'),
    maxReplicas?: int32(name='MaxReplicas'),
    metric?: {
      maxReplicas?: int32(name='MaxReplicas'),
      metrics?: [ 
        {
          metricTargetAverageUtilization?: int32(name='MetricTargetAverageUtilization'),
          metricType?: string(name='MetricType'),
        }
      ](name='Metrics'),
      minReplicas?: int32(name='MinReplicas'),
    }(name='Metric'),
    minReplicas?: int32(name='MinReplicas'),
    scaleRuleEnabled?: boolean(name='ScaleRuleEnabled'),
    scaleRuleName?: string(name='ScaleRuleName'),
    scaleRuleType?: string(name='ScaleRuleType'),
    trigger?: {
      maxReplicas?: int32(name='MaxReplicas'),
      minReplicas?: int32(name='MinReplicas'),
      triggers?: [ 
        {
          metaData?: string(name='MetaData'),
          name?: string(name='Name'),
          type?: string(name='Type'),
        }
      ](name='Triggers'),
    }(name='Trigger'),
    updateTime?: long(name='UpdateTime'),
  }(name='AppScalingRule'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DisableApplicationScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableApplicationScalingRuleResponseBody(name='body'),
}

async function disableApplicationScalingRule(request: DisableApplicationScalingRuleRequest): DisableApplicationScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableApplicationScalingRuleWithOptions(request, headers, runtime);
}

async function disableApplicationScalingRuleWithOptions(request: DisableApplicationScalingRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DisableApplicationScalingRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.scalingRuleName)) {
    query['ScalingRuleName'] = request.scalingRuleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableApplicationScalingRule',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v1/eam/scale/disable_application_scaling_rule`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DisableMockRuleRequest {
  id?: long(name='Id'),
}

model DisableMockRuleResponseBody = {
  code?: int32(name='Code'),
  data?: {
    accountId?: string(name='AccountId'),
    consumerAppId?: string(name='ConsumerAppId'),
    consumerAppName?: string(name='ConsumerAppName'),
    enable?: boolean(name='Enable'),
    extraJson?: string(name='ExtraJson'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    namespaceId?: string(name='NamespaceId'),
    providerAppId?: string(name='ProviderAppId'),
    providerAppName?: string(name='ProviderAppName'),
    region?: string(name='Region'),
    scMockItemJson?: string(name='ScMockItemJson'),
    source?: string(name='Source'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableMockRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableMockRuleResponseBody(name='body'),
}

async function disableMockRule(request: DisableMockRuleRequest): DisableMockRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableMockRuleWithOptions(request, headers, runtime);
}

async function disableMockRuleWithOptions(request: DisableMockRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DisableMockRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableMockRule',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/sp/api/mock/disableMockRule`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model EnableApplicationScalingRuleRequest {
  appId?: string(name='AppId'),
  scalingRuleName?: string(name='ScalingRuleName'),
}

model EnableApplicationScalingRuleResponseBody = {
  appScalingRule?: {
    appId?: string(name='AppId'),
    createTime?: long(name='CreateTime'),
    lastDisableTime?: long(name='LastDisableTime'),
    maxReplicas?: int32(name='MaxReplicas'),
    metric?: {
      maxReplicas?: int32(name='MaxReplicas'),
      metrics?: [ 
        {
          metricTargetAverageUtilization?: int32(name='MetricTargetAverageUtilization'),
          metricType?: string(name='MetricType'),
        }
      ](name='Metrics'),
      minReplicas?: int32(name='MinReplicas'),
    }(name='Metric'),
    minReplicas?: int32(name='MinReplicas'),
    scaleRuleEnabled?: boolean(name='ScaleRuleEnabled'),
    scaleRuleName?: string(name='ScaleRuleName'),
    scaleRuleType?: string(name='ScaleRuleType'),
    trigger?: {
      maxReplicas?: int32(name='MaxReplicas'),
      minReplicas?: int32(name='MinReplicas'),
      triggers?: [ 
        {
          metaData?: string(name='MetaData'),
          name?: string(name='Name'),
          type?: string(name='Type'),
        }
      ](name='Triggers'),
    }(name='Trigger'),
    updateTime?: long(name='UpdateTime'),
  }(name='AppScalingRule'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model EnableApplicationScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableApplicationScalingRuleResponseBody(name='body'),
}

async function enableApplicationScalingRule(request: EnableApplicationScalingRuleRequest): EnableApplicationScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableApplicationScalingRuleWithOptions(request, headers, runtime);
}

async function enableApplicationScalingRuleWithOptions(request: EnableApplicationScalingRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EnableApplicationScalingRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.scalingRuleName)) {
    query['ScalingRuleName'] = request.scalingRuleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableApplicationScalingRule',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v1/eam/scale/enable_application_scaling_rule`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model EnableMockRuleRequest {
  id?: long(name='Id'),
}

model EnableMockRuleResponseBody = {
  code?: int32(name='Code'),
  data?: {
    accountId?: string(name='AccountId'),
    consumerAppId?: string(name='ConsumerAppId'),
    consumerAppName?: string(name='ConsumerAppName'),
    enable?: boolean(name='Enable'),
    extraJson?: string(name='ExtraJson'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    namespaceId?: string(name='NamespaceId'),
    providerAppId?: string(name='ProviderAppId'),
    providerAppName?: string(name='ProviderAppName'),
    region?: string(name='Region'),
    scMockItemJson?: string(name='ScMockItemJson'),
    source?: string(name='Source'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableMockRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableMockRuleResponseBody(name='body'),
}

async function enableMockRule(request: EnableMockRuleRequest): EnableMockRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableMockRuleWithOptions(request, headers, runtime);
}

async function enableMockRuleWithOptions(request: EnableMockRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EnableMockRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableMockRule',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/sp/api/mock/enableMockRule`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetAccountMockRuleRequest {
  consumerAppName?: string(name='ConsumerAppName'),
  mockType?: long(name='MockType'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  providerAppName?: string(name='ProviderAppName'),
  region?: string(name='Region'),
}

model GetAccountMockRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        consumerAppId?: string(name='ConsumerAppId'),
        consumerAppName?: string(name='ConsumerAppName'),
        dubboMockItems?: [ 
          {
            exceptionClassName?: string(name='ExceptionClassName'),
            executeCondition?: string(name='ExecuteCondition'),
            group?: string(name='Group'),
            methodName?: string(name='MethodName'),
            oper?: string(name='Oper'),
            paramTypes?: [ string ](name='ParamTypes'),
            serviceName?: string(name='ServiceName'),
            value?: string(name='Value'),
            version?: string(name='Version'),
          }
        ](name='DubboMockItems'),
        enable?: boolean(name='Enable'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: int32(name='Id'),
        name?: string(name='Name'),
        providerAppId?: string(name='ProviderAppId'),
        providerAppName?: string(name='ProviderAppName'),
        region?: string(name='Region'),
        scMockItems?: [ 
          {
            exceptionClassName?: string(name='ExceptionClassName'),
            executeCondition?: string(name='ExecuteCondition'),
            method?: string(name='Method'),
            oper?: string(name='Oper'),
            path?: string(name='Path'),
            serviceName?: string(name='ServiceName'),
            value?: string(name='Value'),
          }
        ](name='ScMockItems'),
        status?: int32(name='Status'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  message?: string(name='Message'),
  success?: boolean(name='Success'),
}

model GetAccountMockRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAccountMockRuleResponseBody(name='body'),
}

async function getAccountMockRule(request: GetAccountMockRuleRequest): GetAccountMockRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAccountMockRuleWithOptions(request, headers, runtime);
}

async function getAccountMockRuleWithOptions(request: GetAccountMockRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAccountMockRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.consumerAppName)) {
    query['ConsumerAppName'] = request.consumerAppName;
  }
  if (!Util.isUnset(request.mockType)) {
    query['MockType'] = request.mockType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.providerAppName)) {
    query['ProviderAppName'] = request.providerAppName;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAccountMockRule',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/sp/api/mock/getAccountMockRule`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetAppDeploymentRequest {
  appId?: string(name='AppId'),
}

model GetAppDeploymentResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetAppDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAppDeploymentResponseBody(name='body'),
}

async function getAppDeployment(request: GetAppDeploymentRequest): GetAppDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAppDeploymentWithOptions(request, headers, runtime);
}

async function getAppDeploymentWithOptions(request: GetAppDeploymentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAppDeploymentResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAppDeployment',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/oam/app_deployment`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetApplicationRequest {
  appId?: string(name='AppId'),
}

model GetApplicationResponseBody = {
  application?: {
    appId?: string(name='AppId'),
    applicationType?: string(name='ApplicationType'),
    buildPackageId?: long(name='BuildPackageId'),
    clusterId?: string(name='ClusterId'),
    clusterType?: string(name='ClusterType'),
    cpu?: int32(name='Cpu'),
    createTime?: long(name='CreateTime'),
    description?: string(name='Description'),
    dockerize?: boolean(name='Dockerize'),
    email?: string(name='Email'),
    extSlbId?: string(name='ExtSlbId'),
    extSlbIp?: string(name='ExtSlbIp'),
    extSlbName?: string(name='ExtSlbName'),
    healthCheckUrl?: string(name='HealthCheckUrl'),
    instanceCount?: int32(name='InstanceCount'),
    memory?: int32(name='Memory'),
    name?: string(name='Name'),
    nameSpace?: string(name='NameSpace'),
    owner?: string(name='Owner'),
    port?: int32(name='Port'),
    regionId?: string(name='RegionId'),
    runningInstanceCount?: int32(name='RunningInstanceCount'),
    slbId?: string(name='SlbId'),
    slbInfo?: string(name='SlbInfo'),
    slbIp?: string(name='SlbIp'),
    slbName?: string(name='SlbName'),
    slbPort?: int32(name='SlbPort'),
    userId?: string(name='UserId'),
  }(name='Application'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetApplicationResponseBody(name='body'),
}

async function getApplication(request: GetApplicationRequest): GetApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getApplicationWithOptions(request, headers, runtime);
}

async function getApplicationWithOptions(request: GetApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/app/app_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetChangeOrderInfoRequest {
  changeOrderId?: string(name='ChangeOrderId'),
}

model GetChangeOrderInfoResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderInfo?: {
    batchCount?: int32(name='BatchCount'),
    batchType?: string(name='BatchType'),
    changeOrderDescription?: string(name='ChangeOrderDescription'),
    changeOrderId?: string(name='ChangeOrderId'),
    coType?: string(name='CoType'),
    createTime?: string(name='CreateTime'),
    createUserId?: string(name='CreateUserId'),
    desc?: string(name='Desc'),
    pipelineInfoList?: {
      pipelineInfo?: [ 
      {
        pipelineId?: string(name='PipelineId'),
        pipelineName?: string(name='PipelineName'),
        pipelineStatus?: int32(name='PipelineStatus'),
        stageDetailList?: {
          stageDetailDTO?: [ 
          {
            stageId?: string(name='StageId'),
            stageName?: string(name='StageName'),
            stageStatus?: int32(name='StageStatus'),
            taskList?: {
              taskInfoDTO?: [ 
              {
                retryType?: int32(name='RetryType'),
                showManualIgnorance?: boolean(name='ShowManualIgnorance'),
                taskErrorCode?: string(name='TaskErrorCode'),
                taskErrorIgnorance?: int32(name='TaskErrorIgnorance'),
                taskErrorMessage?: string(name='TaskErrorMessage'),
                taskId?: string(name='TaskId'),
                taskMessage?: string(name='TaskMessage'),
                taskName?: string(name='TaskName'),
                taskStatus?: string(name='TaskStatus'),
              }
            ](name='TaskInfoDTO')
            }(name='TaskList'),
          }
        ](name='StageDetailDTO')
        }(name='StageDetailList'),
        stageList?: {
          stageInfoDTO?: [ 
          {
            stageId?: string(name='StageId'),
            stageName?: string(name='StageName'),
            stageResultDTO?: {
              instanceDTOList?: {
                instanceDTO?: [ 
                {
                  instanceIp?: string(name='InstanceIp'),
                  instanceName?: string(name='InstanceName'),
                  instanceStageDTOList?: {
                    instanceStageDTO?: [ 
                    {
                      finishTime?: string(name='FinishTime'),
                      stageId?: string(name='StageId'),
                      stageMessage?: string(name='StageMessage'),
                      stageName?: string(name='StageName'),
                      startTime?: string(name='StartTime'),
                      status?: int32(name='Status'),
                    }
                  ](name='InstanceStageDTO')
                  }(name='InstanceStageDTOList'),
                  podName?: string(name='PodName'),
                  podStatus?: string(name='PodStatus'),
                  status?: int32(name='Status'),
                }
              ](name='InstanceDTO')
              }(name='InstanceDTOList'),
              serviceStage?: {
                message?: string(name='Message'),
                stageId?: string(name='StageId'),
                stageName?: string(name='StageName'),
                status?: int32(name='Status'),
              }(name='ServiceStage'),
            }(name='StageResultDTO'),
            status?: int32(name='Status'),
          }
        ](name='StageInfoDTO')
        }(name='StageList'),
        startTime?: string(name='StartTime'),
        updateTime?: string(name='UpdateTime'),
      }
    ](name='PipelineInfo')
    }(name='PipelineInfoList'),
    status?: int32(name='Status'),
    supportRollback?: boolean(name='SupportRollback'),
    targets?: {
      items?: [ string ](name='Items')
    }(name='Targets'),
    trafficControl?: {
      routes?: string(name='Routes'),
      rules?: string(name='Rules'),
      tips?: string(name='Tips'),
    }(name='TrafficControl'),
  }(name='changeOrderInfo'),
}

model GetChangeOrderInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetChangeOrderInfoResponseBody(name='body'),
}

async function getChangeOrderInfo(request: GetChangeOrderInfoRequest): GetChangeOrderInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getChangeOrderInfoWithOptions(request, headers, runtime);
}

async function getChangeOrderInfoWithOptions(request: GetChangeOrderInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetChangeOrderInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.changeOrderId)) {
    query['ChangeOrderId'] = request.changeOrderId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetChangeOrderInfo',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/change_order_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetClusterRequest {
  clusterId?: string(name='ClusterId'),
}

model GetClusterResponseBody = {
  cluster?: {
    clusterId?: string(name='ClusterId'),
    clusterImportStatus?: int32(name='ClusterImportStatus'),
    clusterName?: string(name='ClusterName'),
    clusterType?: int32(name='ClusterType'),
    cpu?: int32(name='Cpu'),
    cpuUsed?: int32(name='CpuUsed'),
    createTime?: long(name='CreateTime'),
    csClusterId?: string(name='CsClusterId'),
    description?: string(name='Description'),
    iaasProvider?: string(name='IaasProvider'),
    mem?: int32(name='Mem'),
    memUsed?: int32(name='MemUsed'),
    networkMode?: int32(name='NetworkMode'),
    nodeNum?: int32(name='NodeNum'),
    oversoldFactor?: int32(name='OversoldFactor'),
    regionId?: string(name='RegionId'),
    updateTime?: long(name='UpdateTime'),
    vpcId?: string(name='VpcId'),
  }(name='Cluster'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClusterResponseBody(name='body'),
}

async function getCluster(request: GetClusterRequest): GetClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getClusterWithOptions(request, headers, runtime);
}

async function getClusterWithOptions(request: GetClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/cluster`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetContainerConfigurationRequest {
  appId?: string(name='AppId'),
  groupId?: string(name='GroupId'),
}

model GetContainerConfigurationResponseBody = {
  code?: int32(name='Code'),
  containerConfiguration?: {
    contextPath?: string(name='ContextPath'),
    httpPort?: int32(name='HttpPort'),
    maxThreads?: int32(name='MaxThreads'),
    URIEncoding?: string(name='URIEncoding'),
    useBodyEncoding?: boolean(name='UseBodyEncoding'),
  }(name='ContainerConfiguration'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetContainerConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetContainerConfigurationResponseBody(name='body'),
}

async function getContainerConfiguration(request: GetContainerConfigurationRequest): GetContainerConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getContainerConfigurationWithOptions(request, headers, runtime);
}

async function getContainerConfigurationWithOptions(request: GetContainerConfigurationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetContainerConfigurationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetContainerConfiguration',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/app/container_config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetJavaStartUpConfigRequest {
  appId?: string(name='AppId'),
}

model GetJavaStartUpConfigResponseBody = {
  code?: int32(name='Code'),
  javaStartUpConfig?: {
    originalConfigs?: string(name='OriginalConfigs'),
    startUpArgs?: string(name='StartUpArgs'),
  }(name='JavaStartUpConfig'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetJavaStartUpConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJavaStartUpConfigResponseBody(name='body'),
}

async function getJavaStartUpConfig(request: GetJavaStartUpConfigRequest): GetJavaStartUpConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getJavaStartUpConfigWithOptions(request, headers, runtime);
}

async function getJavaStartUpConfigWithOptions(request: GetJavaStartUpConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetJavaStartUpConfigResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJavaStartUpConfig',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/oam/java_start_up_config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetJvmConfigurationRequest {
  appId?: string(name='AppId'),
  groupId?: string(name='GroupId'),
}

model GetJvmConfigurationResponseBody = {
  code?: int32(name='Code'),
  jvmConfiguration?: {
    maxHeapSize?: int32(name='MaxHeapSize'),
    maxPermSize?: int32(name='MaxPermSize'),
    minHeapSize?: int32(name='MinHeapSize'),
    options?: string(name='Options'),
  }(name='JvmConfiguration'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetJvmConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJvmConfigurationResponseBody(name='body'),
}

async function getJvmConfiguration(request: GetJvmConfigurationRequest): GetJvmConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getJvmConfigurationWithOptions(request, headers, runtime);
}

async function getJvmConfigurationWithOptions(request: GetJvmConfigurationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetJvmConfigurationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJvmConfiguration',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/app/app_jvm_config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetK8sApplicationRequest {
  appId?: string(name='AppId'),
  from?: string(name='From'),
}

model GetK8sApplicationResponseBody = {
  applcation?: {
    app?: {
      appId?: string(name='AppId'),
      applicationName?: string(name='ApplicationName'),
      applicationType?: string(name='ApplicationType'),
      buildpackId?: int32(name='BuildpackId'),
      clusterId?: string(name='ClusterId'),
      cmd?: string(name='Cmd'),
      cmdArgs?: {
        cmdArg?: [ string ](name='CmdArg')
      }(name='CmdArgs'),
      csClusterId?: string(name='CsClusterId'),
      deployType?: string(name='DeployType'),
      developType?: string(name='DevelopType'),
      edasContainerVersion?: string(name='EdasContainerVersion'),
      envList?: {
        env?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='Env')
      }(name='EnvList'),
      instances?: int32(name='Instances'),
      instancesBeforeScaling?: int32(name='InstancesBeforeScaling'),
      k8sNamespace?: string(name='K8sNamespace'),
      limitCpuM?: int32(name='LimitCpuM'),
      limitMem?: int32(name='LimitMem'),
      regionId?: string(name='RegionId'),
      requestCpuM?: int32(name='RequestCpuM'),
      requestMem?: int32(name='RequestMem'),
      tomcatVersion?: string(name='TomcatVersion'),
    }(name='App'),
    appId?: string(name='AppId'),
    conf?: {
      affinity?: string(name='Affinity'),
      ahasEnabled?: boolean(name='AhasEnabled'),
      deployAcrossNodes?: string(name='DeployAcrossNodes'),
      deployAcrossZones?: string(name='DeployAcrossZones'),
      jarStartArgs?: string(name='JarStartArgs'),
      jarStartOptions?: string(name='JarStartOptions'),
      k8sCmd?: string(name='K8sCmd'),
      k8sCmdArgs?: string(name='K8sCmdArgs'),
      k8sLocalvolumeInfo?: string(name='K8sLocalvolumeInfo'),
      k8sNasInfo?: string(name='K8sNasInfo'),
      k8sVolumeInfo?: string(name='K8sVolumeInfo'),
      liveness?: string(name='Liveness'),
      postStart?: string(name='PostStart'),
      preStop?: string(name='PreStop'),
      readiness?: string(name='Readiness'),
      runtimeClassName?: string(name='RuntimeClassName'),
      tolerations?: string(name='Tolerations'),
    }(name='Conf'),
    deployGroups?: {
      deployGroup?: [ 
      {
        components?: {
          components?: [ 
          {
            componentId?: string(name='ComponentId'),
            componentKey?: string(name='ComponentKey'),
            type?: string(name='Type'),
          }
        ](name='Components')
        }(name='Components'),
      }
    ](name='DeployGroup')
    }(name='DeployGroups'),
    imageInfo?: {
      imageUrl?: string(name='ImageUrl'),
      regionId?: string(name='RegionId'),
      repoId?: string(name='RepoId'),
      repoName?: string(name='RepoName'),
      repoNamespace?: string(name='RepoNamespace'),
      repoOriginType?: string(name='RepoOriginType'),
      tag?: string(name='Tag'),
    }(name='ImageInfo'),
    latestVersion?: {
      packageVersion?: string(name='PackageVersion'),
      url?: string(name='Url'),
      warUrl?: string(name='WarUrl'),
    }(name='LatestVersion'),
  }(name='Applcation'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetK8sApplicationResponseBody(name='body'),
}

async function getK8sApplication(request: GetK8sApplicationRequest): GetK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getK8sApplicationWithOptions(request, headers, runtime);
}

async function getK8sApplicationWithOptions(request: GetK8sApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetK8sApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetK8sApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/co_application`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetK8sClusterRequest {
  clusterType?: int32(name='ClusterType'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  regionTag?: string(name='RegionTag'),
}

model GetK8sClusterResponseBody = {
  clusterPage?: {
    clusterList?: {
      cluster?: [ 
      {
        clusterId?: string(name='ClusterId'),
        clusterImportStatus?: int32(name='ClusterImportStatus'),
        clusterName?: string(name='ClusterName'),
        clusterStatus?: int32(name='ClusterStatus'),
        clusterType?: int32(name='ClusterType'),
        cpu?: int32(name='Cpu'),
        csClusterId?: string(name='CsClusterId'),
        csClusterStatus?: string(name='CsClusterStatus'),
        description?: string(name='Description'),
        mem?: int32(name='Mem'),
        networkMode?: int32(name='NetworkMode'),
        nodeNum?: int32(name='NodeNum'),
        regionId?: string(name='RegionId'),
        subNetCidr?: string(name='SubNetCidr'),
        vpcId?: string(name='VpcId'),
        vswitchId?: string(name='VswitchId'),
      }
    ](name='Cluster')
    }(name='ClusterList'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='ClusterPage'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetK8sClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetK8sClusterResponseBody(name='body'),
}

async function getK8sCluster(request: GetK8sClusterRequest): GetK8sClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getK8sClusterWithOptions(request, headers, runtime);
}

async function getK8sClusterWithOptions(request: GetK8sClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetK8sClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionTag)) {
    query['RegionTag'] = request.regionTag;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetK8sCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s_clusters`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetK8sServicesRequest {
  appId?: string(name='AppId'),
}

model GetK8sServicesResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  services?: [ 
    {
      clusterIP?: string(name='ClusterIP'),
      name?: string(name='Name'),
      servicePorts?: [ 
        {
          nodePort?: int32(name='NodePort'),
          port?: int32(name='Port'),
          protocol?: string(name='Protocol'),
          targetPort?: string(name='TargetPort'),
        }
      ](name='ServicePorts'),
      type?: string(name='Type'),
    }
  ](name='Services'),
}

model GetK8sServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetK8sServicesResponseBody(name='body'),
}

async function getK8sServices(request: GetK8sServicesRequest): GetK8sServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getK8sServicesWithOptions(request, headers, runtime);
}

async function getK8sServicesWithOptions(request: GetK8sServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetK8sServicesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetK8sServices',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_service`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetMockRuleByConsumerAppIdRequest {
  consumerAppId?: string(name='ConsumerAppId'),
  region?: string(name='Region'),
}

model GetMockRuleByConsumerAppIdResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      accountId?: string(name='AccountId'),
      consumerAppId?: string(name='ConsumerAppId'),
      consumerAppName?: string(name='ConsumerAppName'),
      enable?: boolean(name='Enable'),
      extraJson?: string(name='ExtraJson'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      namespaceId?: string(name='NamespaceId'),
      providerAppId?: string(name='ProviderAppId'),
      providerAppName?: string(name='ProviderAppName'),
      region?: string(name='Region'),
      scMockItemJson?: string(name='ScMockItemJson'),
      source?: string(name='Source'),
    }
  ](name='Data'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMockRuleByConsumerAppIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMockRuleByConsumerAppIdResponseBody(name='body'),
}

async function getMockRuleByConsumerAppId(request: GetMockRuleByConsumerAppIdRequest): GetMockRuleByConsumerAppIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMockRuleByConsumerAppIdWithOptions(request, headers, runtime);
}

async function getMockRuleByConsumerAppIdWithOptions(request: GetMockRuleByConsumerAppIdRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMockRuleByConsumerAppIdResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.consumerAppId)) {
    query['ConsumerAppId'] = request.consumerAppId;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMockRuleByConsumerAppId',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/sp/api/mock/getMockRuleByConsumerAppId`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetMockRuleByProviderAppIdRequest {
  providerAppId?: string(name='ProviderAppId'),
  region?: string(name='Region'),
}

model GetMockRuleByProviderAppIdResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      accountId?: string(name='AccountId'),
      consumerAppId?: string(name='ConsumerAppId'),
      consumerAppName?: string(name='ConsumerAppName'),
      enable?: boolean(name='Enable'),
      extraJson?: string(name='ExtraJson'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      namespaceId?: string(name='NamespaceId'),
      providerAppId?: string(name='ProviderAppId'),
      providerAppName?: string(name='ProviderAppName'),
      region?: string(name='Region'),
      scMockItemJson?: string(name='ScMockItemJson'),
      source?: string(name='Source'),
    }
  ](name='Data'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMockRuleByProviderAppIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMockRuleByProviderAppIdResponseBody(name='body'),
}

async function getMockRuleByProviderAppId(request: GetMockRuleByProviderAppIdRequest): GetMockRuleByProviderAppIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMockRuleByProviderAppIdWithOptions(request, headers, runtime);
}

async function getMockRuleByProviderAppIdWithOptions(request: GetMockRuleByProviderAppIdRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMockRuleByProviderAppIdResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.providerAppId)) {
    query['ProviderAppId'] = request.providerAppId;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMockRuleByProviderAppId',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/sp/api/mock/getMockRuleByProviderAppId`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPackageStorageCredentialResponseBody = {
  code?: int32(name='Code'),
  credential?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    bucket?: string(name='Bucket'),
    expiration?: string(name='Expiration'),
    keyPrefix?: string(name='KeyPrefix'),
    regionId?: string(name='RegionId'),
    securityToken?: string(name='SecurityToken'),
  }(name='Credential'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetPackageStorageCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPackageStorageCredentialResponseBody(name='body'),
}

async function getPackageStorageCredential(): GetPackageStorageCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPackageStorageCredentialWithOptions(headers, runtime);
}

async function getPackageStorageCredentialWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetPackageStorageCredentialResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPackageStorageCredential',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/package_storage_credential`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetScalingRulesRequest {
  appId?: string(name='AppId'),
  groupId?: string(name='GroupId'),
  mode?: string(name='Mode'),
}

model GetScalingRulesResponseBody = {
  code?: int32(name='Code'),
  data?: {
    clusterType?: int32(name='ClusterType'),
    oversoldFactor?: int32(name='OversoldFactor'),
    ruleList?: {
      rule?: [ 
      {
        appId?: string(name='AppId'),
        cond?: string(name='Cond'),
        cpu?: int32(name='Cpu'),
        createTime?: long(name='CreateTime'),
        duration?: int32(name='Duration'),
        enable?: boolean(name='Enable'),
        groupId?: string(name='GroupId'),
        instNum?: int32(name='InstNum'),
        loadNum?: int32(name='LoadNum'),
        metricType?: string(name='MetricType'),
        mode?: string(name='Mode'),
        multiAzPolicy?: string(name='MultiAzPolicy'),
        resourceFrom?: string(name='ResourceFrom'),
        rt?: int32(name='Rt'),
        specId?: string(name='SpecId'),
        step?: int32(name='Step'),
        templateId?: string(name='TemplateId'),
        templateVersion?: int32(name='TemplateVersion'),
        updateTime?: long(name='UpdateTime'),
        vSwitchIds?: string(name='VSwitchIds'),
        vpcId?: string(name='VpcId'),
      }
    ](name='Rule')
    }(name='RuleList'),
    updateTime?: long(name='UpdateTime'),
    vpcId?: string(name='VpcId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  updateTime?: long(name='UpdateTime'),
}

model GetScalingRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetScalingRulesResponseBody(name='body'),
}

async function getScalingRules(request: GetScalingRulesRequest): GetScalingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getScalingRulesWithOptions(request, headers, runtime);
}

async function getScalingRulesWithOptions(request: GetScalingRulesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetScalingRulesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetScalingRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/app/scalingRules`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetSecureTokenRequest {
  namespaceId?: string(name='NamespaceId'),
}

model GetSecureTokenResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  secureToken?: {
    accessKey?: string(name='AccessKey'),
    addressServerHost?: string(name='AddressServerHost'),
    belongRegion?: string(name='BelongRegion'),
    description?: string(name='Description'),
    edasId?: string(name='EdasId'),
    id?: long(name='Id'),
    regionId?: string(name='RegionId'),
    regionName?: string(name='RegionName'),
    secretKey?: string(name='SecretKey'),
    tenantId?: string(name='TenantId'),
    userId?: string(name='UserId'),
  }(name='SecureToken'),
}

model GetSecureTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSecureTokenResponseBody(name='body'),
}

async function getSecureToken(request: GetSecureTokenRequest): GetSecureTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSecureTokenWithOptions(request, headers, runtime);
}

async function getSecureTokenWithOptions(request: GetSecureTokenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetSecureTokenResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSecureToken',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/secure_token`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetServiceConsumersPageRequest {
  appId?: string(name='appId'),
  group?: string(name='group'),
  ip?: string(name='ip'),
  namespace?: string(name='namespace'),
  origin?: string(name='origin'),
  page?: int32(name='page'),
  region?: string(name='region'),
  registryType?: string(name='registryType'),
  serviceId?: string(name='serviceId'),
  serviceName?: string(name='serviceName'),
  serviceType?: string(name='serviceType'),
  serviceVersion?: string(name='serviceVersion'),
  size?: int32(name='size'),
  source?: string(name='source'),
}

model GetServiceConsumersPageResponseBody = {
  code?: int32(name='Code'),
  data?: {
    content?: [ 
      {
        edasAppName?: string(name='EdasAppName'),
        edassAppId?: string(name='EdassAppId'),
        ip?: string(name='Ip'),
      }
    ](name='Content'),
    size?: int32(name='Size'),
    totalElements?: int32(name='TotalElements'),
    totalPages?: int32(name='TotalPages'),
  }(name='Data'),
  message?: string(name='Message'),
  success?: boolean(name='Success'),
}

model GetServiceConsumersPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceConsumersPageResponseBody(name='body'),
}

async function getServiceConsumersPage(request: GetServiceConsumersPageRequest): GetServiceConsumersPageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceConsumersPageWithOptions(request, headers, runtime);
}

async function getServiceConsumersPageWithOptions(request: GetServiceConsumersPageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceConsumersPageResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['appId'] = request.appId;
  }
  if (!Util.isUnset(request.group)) {
    query['group'] = request.group;
  }
  if (!Util.isUnset(request.ip)) {
    query['ip'] = request.ip;
  }
  if (!Util.isUnset(request.namespace)) {
    query['namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.origin)) {
    query['origin'] = request.origin;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.region)) {
    query['region'] = request.region;
  }
  if (!Util.isUnset(request.registryType)) {
    query['registryType'] = request.registryType;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['serviceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['serviceType'] = request.serviceType;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query['serviceVersion'] = request.serviceVersion;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.source)) {
    query['source'] = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceConsumersPage',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/sp/api/mseForOam/getServiceConsumersPage`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetServiceDetailRequest {
  appId?: string(name='appId'),
  group?: string(name='group'),
  ip?: string(name='ip'),
  namespace?: string(name='namespace'),
  origin?: string(name='origin'),
  region?: string(name='region'),
  registryType?: string(name='registryType'),
  serviceId?: string(name='serviceId'),
  serviceName?: string(name='serviceName'),
  serviceType?: string(name='serviceType'),
  serviceVersion?: string(name='serviceVersion'),
  source?: string(name='source'),
}

model GetServiceDetailResponseBody = {
  code?: int32(name='Code'),
  data?: {
    dubboApplicationName?: string(name='DubboApplicationName'),
    edasAppName?: string(name='EdasAppName'),
    group?: string(name='Group'),
    metadata?: string(name='Metadata'),
    methods?: [ 
      {
        methodController?: string(name='MethodController'),
        name?: string(name='Name'),
        nameDetail?: string(name='NameDetail'),
        parameterDefinitions?: string(name='ParameterDefinitions'),
        parameterDetails?: string(name='ParameterDetails'),
        parameterNames?: string(name='ParameterNames'),
        parameterTypes?: string(name='ParameterTypes'),
        paths?: string(name='Paths'),
        requestMethods?: string(name='RequestMethods'),
        returnDefinition?: {
          id?: string(name='Id'),
          type?: string(name='Type'),
        }(name='ReturnDefinition'),
        returnDetails?: string(name='ReturnDetails'),
        returnType?: string(name='ReturnType'),
      }
    ](name='Methods'),
    registryType?: string(name='RegistryType'),
    serviceName?: string(name='ServiceName'),
    serviceType?: string(name='ServiceType'),
    springApplicationName?: string(name='SpringApplicationName'),
    version?: string(name='Version'),
  }(name='Data'),
  message?: string(name='Message'),
  success?: boolean(name='Success'),
}

model GetServiceDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceDetailResponseBody(name='body'),
}

async function getServiceDetail(request: GetServiceDetailRequest): GetServiceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceDetailWithOptions(request, headers, runtime);
}

async function getServiceDetailWithOptions(request: GetServiceDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceDetailResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['appId'] = request.appId;
  }
  if (!Util.isUnset(request.group)) {
    query['group'] = request.group;
  }
  if (!Util.isUnset(request.ip)) {
    query['ip'] = request.ip;
  }
  if (!Util.isUnset(request.namespace)) {
    query['namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.origin)) {
    query['origin'] = request.origin;
  }
  if (!Util.isUnset(request.region)) {
    query['region'] = request.region;
  }
  if (!Util.isUnset(request.registryType)) {
    query['registryType'] = request.registryType;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['serviceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['serviceType'] = request.serviceType;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query['serviceVersion'] = request.serviceVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['source'] = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceDetail',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/sp/api/mseForOam/getServiceDetail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetServiceListPageRequest {
  namespace?: string(name='namespace'),
  origin?: string(name='origin'),
  page?: int32(name='page'),
  region?: string(name='region'),
  searchType?: string(name='searchType'),
  searchValue?: string(name='searchValue'),
  serviceType?: string(name='serviceType'),
  side?: string(name='side'),
  size?: int32(name='size'),
}

model GetServiceListPageResponseBody = {
  code?: int32(name='Code'),
  data?: {
    content?: [ 
      {
        edasAppId?: string(name='EdasAppId'),
        edasAppName?: string(name='EdasAppName'),
        group?: string(name='Group'),
        instanceNum?: int32(name='InstanceNum'),
        registerType?: string(name='RegisterType'),
        serviceId?: string(name='ServiceId'),
        serviceName?: string(name='ServiceName'),
        version?: string(name='Version'),
      }
    ](name='Content'),
    size?: int32(name='Size'),
    totalElements?: int32(name='TotalElements'),
    totalPages?: int32(name='TotalPages'),
  }(name='Data'),
  message?: string(name='Message'),
  success?: boolean(name='Success'),
}

model GetServiceListPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceListPageResponseBody(name='body'),
}

async function getServiceListPage(request: GetServiceListPageRequest): GetServiceListPageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceListPageWithOptions(request, headers, runtime);
}

async function getServiceListPageWithOptions(request: GetServiceListPageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceListPageResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.namespace)) {
    query['namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.origin)) {
    query['origin'] = request.origin;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.region)) {
    query['region'] = request.region;
  }
  if (!Util.isUnset(request.searchType)) {
    query['searchType'] = request.searchType;
  }
  if (!Util.isUnset(request.searchValue)) {
    query['searchValue'] = request.searchValue;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['serviceType'] = request.serviceType;
  }
  if (!Util.isUnset(request.side)) {
    query['side'] = request.side;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceListPage',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/sp/api/mseForOam/getServiceListPage`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetServiceMethodPageRequest {
  appId?: string(name='appId'),
  group?: string(name='group'),
  ip?: string(name='ip'),
  methodController?: string(name='methodController'),
  name?: string(name='name'),
  namespace?: string(name='namespace'),
  origin?: string(name='origin'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  path?: string(name='path'),
  region?: string(name='region'),
  registryType?: string(name='registryType'),
  serviceId?: string(name='serviceId'),
  serviceName?: string(name='serviceName'),
  serviceType?: string(name='serviceType'),
  serviceVersion?: string(name='serviceVersion'),
  source?: string(name='source'),
}

model GetServiceMethodPageResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        methodController?: string(name='MethodController'),
        name?: string(name='Name'),
        nameDetail?: string(name='NameDetail'),
        parameterDefinitions?: string(name='ParameterDefinitions'),
        parameterDetails?: string(name='ParameterDetails'),
        parameterNames?: string(name='ParameterNames'),
        parameterTypes?: string(name='ParameterTypes'),
        paths?: string(name='Paths'),
        requestMethods?: string(name='RequestMethods'),
        returnDefinition?: {
          id?: string(name='Id'),
          type?: string(name='Type'),
        }(name='ReturnDefinition'),
        returnDetails?: string(name='ReturnDetails'),
        returnType?: string(name='ReturnType'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetServiceMethodPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceMethodPageResponseBody(name='body'),
}

async function getServiceMethodPage(request: GetServiceMethodPageRequest): GetServiceMethodPageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceMethodPageWithOptions(request, headers, runtime);
}

async function getServiceMethodPageWithOptions(request: GetServiceMethodPageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceMethodPageResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['appId'] = request.appId;
  }
  if (!Util.isUnset(request.group)) {
    query['group'] = request.group;
  }
  if (!Util.isUnset(request.ip)) {
    query['ip'] = request.ip;
  }
  if (!Util.isUnset(request.methodController)) {
    query['methodController'] = request.methodController;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.origin)) {
    query['origin'] = request.origin;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.path)) {
    query['path'] = request.path;
  }
  if (!Util.isUnset(request.region)) {
    query['region'] = request.region;
  }
  if (!Util.isUnset(request.registryType)) {
    query['registryType'] = request.registryType;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['serviceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['serviceType'] = request.serviceType;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query['serviceVersion'] = request.serviceVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['source'] = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceMethodPage',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/sp/api/mseForOam/getServiceMethodPage`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetServiceProvidersPageRequest {
  appId?: string(name='appId'),
  group?: string(name='group'),
  ip?: string(name='ip'),
  namespace?: string(name='namespace'),
  origin?: string(name='origin'),
  page?: int32(name='page'),
  region?: string(name='region'),
  registryType?: string(name='registryType'),
  serviceId?: string(name='serviceId'),
  serviceName?: string(name='serviceName'),
  serviceType?: string(name='serviceType'),
  serviceVersion?: string(name='serviceVersion'),
  size?: int32(name='size'),
  source?: string(name='source'),
}

model GetServiceProvidersPageResponseBody = {
  code?: int32(name='Code'),
  data?: {
    content?: [ 
      {
        ip?: string(name='Ip'),
        port?: string(name='Port'),
        serializeType?: string(name='SerializeType'),
        timeout?: string(name='Timeout'),
      }
    ](name='Content'),
    size?: int32(name='Size'),
    totalElements?: int32(name='TotalElements'),
    totalPages?: int32(name='TotalPages'),
  }(name='Data'),
  message?: string(name='Message'),
  success?: boolean(name='Success'),
}

model GetServiceProvidersPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceProvidersPageResponseBody(name='body'),
}

async function getServiceProvidersPage(request: GetServiceProvidersPageRequest): GetServiceProvidersPageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceProvidersPageWithOptions(request, headers, runtime);
}

async function getServiceProvidersPageWithOptions(request: GetServiceProvidersPageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceProvidersPageResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['appId'] = request.appId;
  }
  if (!Util.isUnset(request.group)) {
    query['group'] = request.group;
  }
  if (!Util.isUnset(request.ip)) {
    query['ip'] = request.ip;
  }
  if (!Util.isUnset(request.namespace)) {
    query['namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.origin)) {
    query['origin'] = request.origin;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.region)) {
    query['region'] = request.region;
  }
  if (!Util.isUnset(request.registryType)) {
    query['registryType'] = request.registryType;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['serviceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['serviceType'] = request.serviceType;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query['serviceVersion'] = request.serviceVersion;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.source)) {
    query['source'] = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceProvidersPage',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/sp/api/mseForOam/getServiceProvidersPage`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetWebContainerConfigRequest {
  appId?: string(name='AppId'),
}

model GetWebContainerConfigResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  webContainerConfig?: {
    contextInputType?: string(name='ContextInputType'),
    contextPath?: string(name='ContextPath'),
    httpPort?: int32(name='HttpPort'),
    maxThreads?: int32(name='MaxThreads'),
    serverXml?: string(name='ServerXml'),
    uriEncoding?: string(name='UriEncoding'),
    useAdvancedServerXml?: boolean(name='UseAdvancedServerXml'),
    useBodyEncoding?: boolean(name='UseBodyEncoding'),
    useDefaultConfig?: boolean(name='UseDefaultConfig'),
  }(name='WebContainerConfig'),
}

model GetWebContainerConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWebContainerConfigResponseBody(name='body'),
}

async function getWebContainerConfig(request: GetWebContainerConfigRequest): GetWebContainerConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getWebContainerConfigWithOptions(request, headers, runtime);
}

async function getWebContainerConfigWithOptions(request: GetWebContainerConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetWebContainerConfigResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWebContainerConfig',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/oam/web_container_config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ImportK8sClusterRequest {
  clusterId?: string(name='ClusterId'),
  enableAsm?: boolean(name='EnableAsm'),
  mode?: int32(name='Mode'),
  namespaceId?: string(name='NamespaceId'),
}

model ImportK8sClusterResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ImportK8sClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ImportK8sClusterResponseBody(name='body'),
}

async function importK8sCluster(request: ImportK8sClusterRequest): ImportK8sClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return importK8sClusterWithOptions(request, headers, runtime);
}

async function importK8sClusterWithOptions(request: ImportK8sClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ImportK8sClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.enableAsm)) {
    query['EnableAsm'] = request.enableAsm;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportK8sCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/import_k8s_cluster`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InsertApplicationRequest {
  applicationName?: string(name='ApplicationName'),
  buildPackId?: int32(name='BuildPackId'),
  clusterId?: string(name='ClusterId'),
  componentIds?: string(name='ComponentIds'),
  cpu?: int32(name='Cpu'),
  description?: string(name='Description'),
  ecuInfo?: string(name='EcuInfo'),
  enablePortCheck?: boolean(name='EnablePortCheck'),
  enableUrlCheck?: boolean(name='EnableUrlCheck'),
  healthCheckURL?: string(name='HealthCheckURL'),
  healthCheckUrl?: string(name='HealthCheckUrl'),
  hooks?: string(name='Hooks'),
  jdk?: string(name='Jdk'),
  jvmOptions?: string(name='JvmOptions'),
  logicalRegionId?: string(name='LogicalRegionId'),
  maxHeapSize?: int32(name='MaxHeapSize'),
  maxPermSize?: int32(name='MaxPermSize'),
  mem?: int32(name='Mem'),
  minHeapSize?: int32(name='MinHeapSize'),
  packageType?: string(name='PackageType'),
  reservedPortStr?: string(name='ReservedPortStr'),
  resourceGroupId?: string(name='ResourceGroupId'),
  webContainer?: string(name='WebContainer'),
}

model InsertApplicationResponseBody = {
  applicationInfo?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    changeOrderId?: string(name='ChangeOrderId'),
    dockerize?: boolean(name='Dockerize'),
    owner?: string(name='Owner'),
    port?: int32(name='Port'),
    regionName?: string(name='RegionName'),
    userId?: string(name='UserId'),
  }(name='ApplicationInfo'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model InsertApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InsertApplicationResponseBody(name='body'),
}

async function insertApplication(request: InsertApplicationRequest): InsertApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertApplicationWithOptions(request, headers, runtime);
}

async function insertApplicationWithOptions(request: InsertApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.applicationName)) {
    query['ApplicationName'] = request.applicationName;
  }
  if (!Util.isUnset(request.buildPackId)) {
    query['BuildPackId'] = request.buildPackId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.componentIds)) {
    query['ComponentIds'] = request.componentIds;
  }
  if (!Util.isUnset(request.cpu)) {
    query['Cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ecuInfo)) {
    query['EcuInfo'] = request.ecuInfo;
  }
  if (!Util.isUnset(request.enablePortCheck)) {
    query['EnablePortCheck'] = request.enablePortCheck;
  }
  if (!Util.isUnset(request.enableUrlCheck)) {
    query['EnableUrlCheck'] = request.enableUrlCheck;
  }
  if (!Util.isUnset(request.healthCheckURL)) {
    query['HealthCheckURL'] = request.healthCheckURL;
  }
  if (!Util.isUnset(request.healthCheckUrl)) {
    query['HealthCheckUrl'] = request.healthCheckUrl;
  }
  if (!Util.isUnset(request.hooks)) {
    query['Hooks'] = request.hooks;
  }
  if (!Util.isUnset(request.jdk)) {
    query['Jdk'] = request.jdk;
  }
  if (!Util.isUnset(request.jvmOptions)) {
    query['JvmOptions'] = request.jvmOptions;
  }
  if (!Util.isUnset(request.logicalRegionId)) {
    query['LogicalRegionId'] = request.logicalRegionId;
  }
  if (!Util.isUnset(request.maxHeapSize)) {
    query['MaxHeapSize'] = request.maxHeapSize;
  }
  if (!Util.isUnset(request.maxPermSize)) {
    query['MaxPermSize'] = request.maxPermSize;
  }
  if (!Util.isUnset(request.mem)) {
    query['Mem'] = request.mem;
  }
  if (!Util.isUnset(request.minHeapSize)) {
    query['MinHeapSize'] = request.minHeapSize;
  }
  if (!Util.isUnset(request.packageType)) {
    query['PackageType'] = request.packageType;
  }
  if (!Util.isUnset(request.reservedPortStr)) {
    query['ReservedPortStr'] = request.reservedPortStr;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.webContainer)) {
    query['WebContainer'] = request.webContainer;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InsertApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/co_create_app`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InsertClusterRequest {
  clusterName?: string(name='ClusterName'),
  clusterType?: int32(name='ClusterType'),
  iaasProvider?: string(name='IaasProvider'),
  logicalRegionId?: string(name='LogicalRegionId'),
  networkMode?: int32(name='NetworkMode'),
  oversoldFactor?: int32(name='OversoldFactor'),
  vpcId?: string(name='VpcId'),
}

model InsertClusterResponseBody = {
  cluster?: {
    clusterId?: string(name='ClusterId'),
    clusterName?: string(name='ClusterName'),
    clusterType?: int32(name='ClusterType'),
    iaasProvider?: string(name='IaasProvider'),
    networkMode?: int32(name='NetworkMode'),
    oversoldFactor?: int32(name='OversoldFactor'),
    regionId?: string(name='RegionId'),
    vpcId?: string(name='VpcId'),
  }(name='Cluster'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model InsertClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InsertClusterResponseBody(name='body'),
}

async function insertCluster(request: InsertClusterRequest): InsertClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertClusterWithOptions(request, headers, runtime);
}

async function insertClusterWithOptions(request: InsertClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.iaasProvider)) {
    query['IaasProvider'] = request.iaasProvider;
  }
  if (!Util.isUnset(request.logicalRegionId)) {
    query['LogicalRegionId'] = request.logicalRegionId;
  }
  if (!Util.isUnset(request.networkMode)) {
    query['NetworkMode'] = request.networkMode;
  }
  if (!Util.isUnset(request.oversoldFactor)) {
    query['OversoldFactor'] = request.oversoldFactor;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InsertCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/cluster`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InsertClusterMemberRequest {
  clusterId?: string(name='clusterId'),
  instanceIds?: string(name='instanceIds'),
  password?: string(name='password'),
}

model InsertClusterMemberResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model InsertClusterMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InsertClusterMemberResponseBody(name='body'),
}

async function insertClusterMember(request: InsertClusterMemberRequest): InsertClusterMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertClusterMemberWithOptions(request, headers, runtime);
}

async function insertClusterMemberWithOptions(request: InsertClusterMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertClusterMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['clusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['instanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.password)) {
    query['password'] = request.password;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InsertClusterMember',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/cluster_member`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InsertDeployGroupRequest {
  appId?: string(name='AppId'),
  groupName?: string(name='GroupName'),
  initPackageVersionId?: string(name='InitPackageVersionId'),
}

model InsertDeployGroupResponseBody = {
  code?: int32(name='Code'),
  deployGroupEntity?: {
    appId?: string(name='AppId'),
    appVersionId?: string(name='AppVersionId'),
    clusterId?: string(name='ClusterId'),
    createTime?: long(name='CreateTime'),
    groupName?: string(name='GroupName'),
    groupType?: int32(name='GroupType'),
    id?: string(name='Id'),
    packageVersionId?: string(name='PackageVersionId'),
    updateTime?: long(name='UpdateTime'),
  }(name='DeployGroupEntity'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model InsertDeployGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InsertDeployGroupResponseBody(name='body'),
}

async function insertDeployGroup(request: InsertDeployGroupRequest): InsertDeployGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertDeployGroupWithOptions(request, headers, runtime);
}

async function insertDeployGroupWithOptions(request: InsertDeployGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertDeployGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.initPackageVersionId)) {
    query['InitPackageVersionId'] = request.initPackageVersionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InsertDeployGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/deploy_group`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InsertK8sApplicationRequest {
  annotations?: string(name='Annotations'),
  appName?: string(name='AppName'),
  applicationDescription?: string(name='ApplicationDescription'),
  buildPackId?: string(name='BuildPackId'),
  clusterId?: string(name='ClusterId'),
  command?: string(name='Command'),
  commandArgs?: string(name='CommandArgs'),
  configMountDescs?: string(name='ConfigMountDescs'),
  csClusterId?: string(name='CsClusterId'),
  customAffinity?: string(name='CustomAffinity'),
  customTolerations?: string(name='CustomTolerations'),
  deployAcrossNodes?: string(name='DeployAcrossNodes'),
  deployAcrossZones?: string(name='DeployAcrossZones'),
  edasContainerVersion?: string(name='EdasContainerVersion'),
  emptyDirs?: string(name='EmptyDirs'),
  enableAhas?: boolean(name='EnableAhas'),
  enableAsm?: boolean(name='EnableAsm'),
  enableEmptyPushReject?: boolean(name='EnableEmptyPushReject', description='是否开启推空保护'),
  enableLosslessRule?: boolean(name='EnableLosslessRule', description='是否启用无损上线规则'),
  envFroms?: string(name='EnvFroms'),
  envs?: string(name='Envs'),
  imageUrl?: string(name='ImageUrl'),
  internetSlbId?: string(name='InternetSlbId'),
  internetSlbPort?: int32(name='InternetSlbPort'),
  internetSlbProtocol?: string(name='InternetSlbProtocol'),
  internetTargetPort?: int32(name='InternetTargetPort'),
  intranetSlbId?: string(name='IntranetSlbId'),
  intranetSlbPort?: int32(name='IntranetSlbPort'),
  intranetSlbProtocol?: string(name='IntranetSlbProtocol'),
  intranetTargetPort?: int32(name='IntranetTargetPort'),
  isMultilingualApp?: boolean(name='IsMultilingualApp'),
  JDK?: string(name='JDK'),
  javaStartUpConfig?: string(name='JavaStartUpConfig'),
  labels?: string(name='Labels'),
  limitCpu?: int32(name='LimitCpu'),
  limitMem?: int32(name='LimitMem'),
  limitmCpu?: int32(name='LimitmCpu'),
  liveness?: string(name='Liveness'),
  localVolume?: string(name='LocalVolume'),
  logicalRegionId?: string(name='LogicalRegionId'),
  losslessRuleAligned?: boolean(name='LosslessRuleAligned', description='是否启用无损滚动发布模式配置通过就绪检查前完成服务注册'),
  losslessRuleDelayTime?: int32(name='LosslessRuleDelayTime', description='无损上线延迟注册时长'),
  losslessRuleFuncType?: int32(name='LosslessRuleFuncType', description='无损上线服务预热曲线'),
  losslessRuleRelated?: boolean(name='LosslessRuleRelated', description='是否启用无损滚动发布模式配置通过就绪检查前完成服务预热'),
  losslessRuleWarmupTime?: int32(name='LosslessRuleWarmupTime', description='无损上线服务预热时长'),
  mountDescs?: string(name='MountDescs'),
  namespace?: string(name='Namespace'),
  nasId?: string(name='NasId'),
  packageType?: string(name='PackageType'),
  packageUrl?: string(name='PackageUrl'),
  packageVersion?: string(name='PackageVersion'),
  postStart?: string(name='PostStart'),
  preStop?: string(name='PreStop'),
  pvcMountDescs?: string(name='PvcMountDescs'),
  readiness?: string(name='Readiness'),
  replicas?: int32(name='Replicas'),
  repoId?: string(name='RepoId'),
  requestsCpu?: int32(name='RequestsCpu'),
  requestsMem?: int32(name='RequestsMem'),
  requestsmCpu?: int32(name='RequestsmCpu'),
  resourceGroupId?: string(name='ResourceGroupId'),
  runtimeClassName?: string(name='RuntimeClassName'),
  slsConfigs?: string(name='SlsConfigs'),
  storageType?: string(name='StorageType'),
  timeout?: int32(name='Timeout'),
  uriEncoding?: string(name='UriEncoding'),
  useBodyEncoding?: boolean(name='UseBodyEncoding'),
  webContainer?: string(name='WebContainer'),
  webContainerConfig?: string(name='WebContainerConfig'),
}

model InsertK8sApplicationResponseBody = {
  applicationInfo?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    changeOrderId?: string(name='ChangeOrderId'),
    clusterType?: int32(name='ClusterType'),
    dockerize?: boolean(name='Dockerize'),
    edasId?: string(name='EdasId'),
    owner?: string(name='Owner'),
    regionId?: string(name='RegionId'),
    userId?: string(name='UserId'),
  }(name='ApplicationInfo'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model InsertK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InsertK8sApplicationResponseBody(name='body'),
}

async function insertK8sApplication(request: InsertK8sApplicationRequest): InsertK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertK8sApplicationWithOptions(request, headers, runtime);
}

async function insertK8sApplicationWithOptions(request: InsertK8sApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertK8sApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.annotations)) {
    query['Annotations'] = request.annotations;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.applicationDescription)) {
    query['ApplicationDescription'] = request.applicationDescription;
  }
  if (!Util.isUnset(request.buildPackId)) {
    query['BuildPackId'] = request.buildPackId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.command)) {
    query['Command'] = request.command;
  }
  if (!Util.isUnset(request.commandArgs)) {
    query['CommandArgs'] = request.commandArgs;
  }
  if (!Util.isUnset(request.configMountDescs)) {
    query['ConfigMountDescs'] = request.configMountDescs;
  }
  if (!Util.isUnset(request.csClusterId)) {
    query['CsClusterId'] = request.csClusterId;
  }
  if (!Util.isUnset(request.customAffinity)) {
    query['CustomAffinity'] = request.customAffinity;
  }
  if (!Util.isUnset(request.customTolerations)) {
    query['CustomTolerations'] = request.customTolerations;
  }
  if (!Util.isUnset(request.deployAcrossNodes)) {
    query['DeployAcrossNodes'] = request.deployAcrossNodes;
  }
  if (!Util.isUnset(request.deployAcrossZones)) {
    query['DeployAcrossZones'] = request.deployAcrossZones;
  }
  if (!Util.isUnset(request.edasContainerVersion)) {
    query['EdasContainerVersion'] = request.edasContainerVersion;
  }
  if (!Util.isUnset(request.emptyDirs)) {
    query['EmptyDirs'] = request.emptyDirs;
  }
  if (!Util.isUnset(request.enableAhas)) {
    query['EnableAhas'] = request.enableAhas;
  }
  if (!Util.isUnset(request.enableAsm)) {
    query['EnableAsm'] = request.enableAsm;
  }
  if (!Util.isUnset(request.enableEmptyPushReject)) {
    query['EnableEmptyPushReject'] = request.enableEmptyPushReject;
  }
  if (!Util.isUnset(request.enableLosslessRule)) {
    query['EnableLosslessRule'] = request.enableLosslessRule;
  }
  if (!Util.isUnset(request.envFroms)) {
    query['EnvFroms'] = request.envFroms;
  }
  if (!Util.isUnset(request.envs)) {
    query['Envs'] = request.envs;
  }
  if (!Util.isUnset(request.imageUrl)) {
    query['ImageUrl'] = request.imageUrl;
  }
  if (!Util.isUnset(request.internetSlbId)) {
    query['InternetSlbId'] = request.internetSlbId;
  }
  if (!Util.isUnset(request.internetSlbPort)) {
    query['InternetSlbPort'] = request.internetSlbPort;
  }
  if (!Util.isUnset(request.internetSlbProtocol)) {
    query['InternetSlbProtocol'] = request.internetSlbProtocol;
  }
  if (!Util.isUnset(request.internetTargetPort)) {
    query['InternetTargetPort'] = request.internetTargetPort;
  }
  if (!Util.isUnset(request.intranetSlbId)) {
    query['IntranetSlbId'] = request.intranetSlbId;
  }
  if (!Util.isUnset(request.intranetSlbPort)) {
    query['IntranetSlbPort'] = request.intranetSlbPort;
  }
  if (!Util.isUnset(request.intranetSlbProtocol)) {
    query['IntranetSlbProtocol'] = request.intranetSlbProtocol;
  }
  if (!Util.isUnset(request.intranetTargetPort)) {
    query['IntranetTargetPort'] = request.intranetTargetPort;
  }
  if (!Util.isUnset(request.isMultilingualApp)) {
    query['IsMultilingualApp'] = request.isMultilingualApp;
  }
  if (!Util.isUnset(request.JDK)) {
    query['JDK'] = request.JDK;
  }
  if (!Util.isUnset(request.javaStartUpConfig)) {
    query['JavaStartUpConfig'] = request.javaStartUpConfig;
  }
  if (!Util.isUnset(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.limitCpu)) {
    query['LimitCpu'] = request.limitCpu;
  }
  if (!Util.isUnset(request.limitMem)) {
    query['LimitMem'] = request.limitMem;
  }
  if (!Util.isUnset(request.limitmCpu)) {
    query['LimitmCpu'] = request.limitmCpu;
  }
  if (!Util.isUnset(request.liveness)) {
    query['Liveness'] = request.liveness;
  }
  if (!Util.isUnset(request.localVolume)) {
    query['LocalVolume'] = request.localVolume;
  }
  if (!Util.isUnset(request.logicalRegionId)) {
    query['LogicalRegionId'] = request.logicalRegionId;
  }
  if (!Util.isUnset(request.losslessRuleAligned)) {
    query['LosslessRuleAligned'] = request.losslessRuleAligned;
  }
  if (!Util.isUnset(request.losslessRuleDelayTime)) {
    query['LosslessRuleDelayTime'] = request.losslessRuleDelayTime;
  }
  if (!Util.isUnset(request.losslessRuleFuncType)) {
    query['LosslessRuleFuncType'] = request.losslessRuleFuncType;
  }
  if (!Util.isUnset(request.losslessRuleRelated)) {
    query['LosslessRuleRelated'] = request.losslessRuleRelated;
  }
  if (!Util.isUnset(request.losslessRuleWarmupTime)) {
    query['LosslessRuleWarmupTime'] = request.losslessRuleWarmupTime;
  }
  if (!Util.isUnset(request.mountDescs)) {
    query['MountDescs'] = request.mountDescs;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.nasId)) {
    query['NasId'] = request.nasId;
  }
  if (!Util.isUnset(request.packageType)) {
    query['PackageType'] = request.packageType;
  }
  if (!Util.isUnset(request.packageUrl)) {
    query['PackageUrl'] = request.packageUrl;
  }
  if (!Util.isUnset(request.packageVersion)) {
    query['PackageVersion'] = request.packageVersion;
  }
  if (!Util.isUnset(request.postStart)) {
    query['PostStart'] = request.postStart;
  }
  if (!Util.isUnset(request.preStop)) {
    query['PreStop'] = request.preStop;
  }
  if (!Util.isUnset(request.pvcMountDescs)) {
    query['PvcMountDescs'] = request.pvcMountDescs;
  }
  if (!Util.isUnset(request.readiness)) {
    query['Readiness'] = request.readiness;
  }
  if (!Util.isUnset(request.replicas)) {
    query['Replicas'] = request.replicas;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.requestsCpu)) {
    query['RequestsCpu'] = request.requestsCpu;
  }
  if (!Util.isUnset(request.requestsMem)) {
    query['RequestsMem'] = request.requestsMem;
  }
  if (!Util.isUnset(request.requestsmCpu)) {
    query['RequestsmCpu'] = request.requestsmCpu;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.runtimeClassName)) {
    query['RuntimeClassName'] = request.runtimeClassName;
  }
  if (!Util.isUnset(request.slsConfigs)) {
    query['SlsConfigs'] = request.slsConfigs;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.uriEncoding)) {
    query['UriEncoding'] = request.uriEncoding;
  }
  if (!Util.isUnset(request.useBodyEncoding)) {
    query['UseBodyEncoding'] = request.useBodyEncoding;
  }
  if (!Util.isUnset(request.webContainer)) {
    query['WebContainer'] = request.webContainer;
  }
  if (!Util.isUnset(request.webContainerConfig)) {
    query['WebContainerConfig'] = request.webContainerConfig;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InsertK8sApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/create_k8s_app`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InsertOrUpdateRegionRequest {
  debugEnable?: boolean(name='DebugEnable'),
  description?: string(name='Description'),
  id?: long(name='Id'),
  regionName?: string(name='RegionName'),
  regionTag?: string(name='RegionTag'),
}

model InsertOrUpdateRegionResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  userDefineRegionEntity?: {
    belongRegion?: string(name='BelongRegion'),
    debugEnable?: boolean(name='DebugEnable'),
    description?: string(name='Description'),
    id?: long(name='Id'),
    regionId?: string(name='RegionId'),
    regionName?: string(name='RegionName'),
    userId?: string(name='UserId'),
  }(name='UserDefineRegionEntity'),
}

model InsertOrUpdateRegionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InsertOrUpdateRegionResponseBody(name='body'),
}

async function insertOrUpdateRegion(request: InsertOrUpdateRegionRequest): InsertOrUpdateRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertOrUpdateRegionWithOptions(request, headers, runtime);
}

async function insertOrUpdateRegionWithOptions(request: InsertOrUpdateRegionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertOrUpdateRegionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.debugEnable)) {
    query['DebugEnable'] = request.debugEnable;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.regionName)) {
    query['RegionName'] = request.regionName;
  }
  if (!Util.isUnset(request.regionTag)) {
    query['RegionTag'] = request.regionTag;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InsertOrUpdateRegion',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/user_region_def`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InsertRoleRequest {
  actionData?: string(name='ActionData'),
  roleName?: string(name='RoleName'),
}

model InsertRoleResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  roleId?: int32(name='RoleId'),
}

model InsertRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InsertRoleResponseBody(name='body'),
}

async function insertRole(request: InsertRoleRequest): InsertRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertRoleWithOptions(request, headers, runtime);
}

async function insertRoleWithOptions(request: InsertRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertRoleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.actionData)) {
    query['ActionData'] = request.actionData;
  }
  if (!Util.isUnset(request.roleName)) {
    query['RoleName'] = request.roleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InsertRole',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/account/create_role`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InsertServiceGroupRequest {
  groupName?: string(name='GroupName'),
}

model InsertServiceGroupResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model InsertServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InsertServiceGroupResponseBody(name='body'),
}

async function insertServiceGroup(request: InsertServiceGroupRequest): InsertServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertServiceGroupWithOptions(request, headers, runtime);
}

async function insertServiceGroupWithOptions(request: InsertServiceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertServiceGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InsertServiceGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/service/serviceGroups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InstallAgentRequest {
  clusterId?: string(name='ClusterId'),
  doAsync?: boolean(name='DoAsync'),
  instanceIds?: string(name='InstanceIds'),
}

model InstallAgentResponseBody = {
  code?: int32(name='Code'),
  executionResultList?: {
    executionResult?: [ 
    {
      finishedTime?: string(name='FinishedTime'),
      instanceId?: string(name='InstanceId'),
      invokeRecordStatus?: string(name='InvokeRecordStatus'),
      status?: string(name='Status'),
      success?: boolean(name='Success'),
    }
  ](name='ExecutionResult')
  }(name='ExecutionResultList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model InstallAgentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallAgentResponseBody(name='body'),
}

async function installAgent(request: InstallAgentRequest): InstallAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installAgentWithOptions(request, headers, runtime);
}

async function installAgentWithOptions(request: InstallAgentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallAgentResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.doAsync)) {
    query['DoAsync'] = request.doAsync;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallAgent',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/ecss/install_agent`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAliyunRegionResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  regionEntityList?: {
    regionEntity?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
    }
  ](name='RegionEntity')
  }(name='RegionEntityList'),
  requestId?: string(name='RequestId'),
}

model ListAliyunRegionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAliyunRegionResponseBody(name='body'),
}

async function listAliyunRegion(): ListAliyunRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAliyunRegionWithOptions(headers, runtime);
}

async function listAliyunRegionWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListAliyunRegionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListAliyunRegion',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/region_list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListApplicationRequest {
  appName?: string(name='AppName'),
  clusterId?: string(name='ClusterId'),
  logicalRegionId?: string(name='LogicalRegionId'),
  logicalRegionIdFilter?: string(name='LogicalRegionIdFilter'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListApplicationResponseBody = {
  applicationList?: {
    application?: [ 
    {
      appId?: string(name='AppId'),
      applicationType?: string(name='ApplicationType'),
      buildPackageId?: long(name='BuildPackageId'),
      clusterId?: string(name='ClusterId'),
      clusterType?: int32(name='ClusterType'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      runningInstanceCount?: int32(name='RunningInstanceCount'),
    }
  ](name='Application')
  }(name='ApplicationList'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListApplicationResponseBody(name='body'),
}

async function listApplication(request: ListApplicationRequest): ListApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listApplicationWithOptions(request, headers, runtime);
}

async function listApplicationWithOptions(request: ListApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.logicalRegionId)) {
    query['LogicalRegionId'] = request.logicalRegionId;
  }
  if (!Util.isUnset(request.logicalRegionIdFilter)) {
    query['LogicalRegionIdFilter'] = request.logicalRegionIdFilter;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/app/app_list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListApplicationEcuRequest {
  appId?: string(name='AppId'),
  logicalRegionId?: string(name='LogicalRegionId'),
}

model ListApplicationEcuResponseBody = {
  code?: int32(name='Code'),
  ecuInfoList?: {
    ecuEntity?: [ 
    {
      appId?: string(name='AppId'),
      availableCpu?: int32(name='AvailableCpu'),
      availableMem?: int32(name='AvailableMem'),
      cpu?: int32(name='Cpu'),
      createTime?: long(name='CreateTime'),
      dockerEnv?: boolean(name='DockerEnv'),
      ecuId?: string(name='EcuId'),
      heartbeatTime?: long(name='HeartbeatTime'),
      instanceId?: string(name='InstanceId'),
      ipAddr?: string(name='IpAddr'),
      mem?: int32(name='Mem'),
      name?: string(name='Name'),
      online?: boolean(name='Online'),
      regionId?: string(name='RegionId'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='EcuEntity')
  }(name='EcuInfoList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListApplicationEcuResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListApplicationEcuResponseBody(name='body'),
}

async function listApplicationEcu(request: ListApplicationEcuRequest): ListApplicationEcuResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listApplicationEcuWithOptions(request, headers, runtime);
}

async function listApplicationEcuWithOptions(request: ListApplicationEcuRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListApplicationEcuResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.logicalRegionId)) {
    query['LogicalRegionId'] = request.logicalRegionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListApplicationEcu',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/ecu_list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAuthorityResponseBody = {
  authorityList?: {
    authority?: [ 
    {
      actionList?: {
        action?: [ 
        {
          code?: string(name='Code'),
          description?: string(name='Description'),
          groupId?: string(name='GroupId'),
          name?: string(name='Name'),
        }
      ](name='Action')
      }(name='ActionList'),
      description?: string(name='Description'),
      groupId?: string(name='GroupId'),
      name?: string(name='Name'),
    }
  ](name='Authority')
  }(name='AuthorityList'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListAuthorityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAuthorityResponseBody(name='body'),
}

async function listAuthority(): ListAuthorityResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAuthorityWithOptions(headers, runtime);
}

async function listAuthorityWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListAuthorityResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListAuthority',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/account/authority_list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListBuildPackResponseBody = {
  buildPackList?: {
    buildPack?: [ 
    {
      configId?: long(name='ConfigId'),
      disabled?: boolean(name='Disabled'),
      feature?: string(name='Feature'),
      imageId?: string(name='ImageId'),
      multipleTenant?: boolean(name='MultipleTenant'),
      packVersion?: string(name='PackVersion'),
      pandoraDesc?: string(name='PandoraDesc'),
      pandoraDownloadUrl?: string(name='PandoraDownloadUrl'),
      pandoraVersion?: string(name='PandoraVersion'),
      pluginInfo?: string(name='PluginInfo'),
      scriptName?: string(name='ScriptName'),
      scriptVersion?: string(name='ScriptVersion'),
      supportFeatures?: string(name='SupportFeatures'),
      tengineDownloadUrl?: string(name='TengineDownloadUrl'),
      tengineImageId?: string(name='TengineImageId'),
      tomcatDesc?: string(name='TomcatDesc'),
      tomcatDownloadUrl?: string(name='TomcatDownloadUrl'),
      tomcatPath?: string(name='TomcatPath'),
      tomcatVersion?: string(name='TomcatVersion'),
      withTengine?: boolean(name='WithTengine'),
    }
  ](name='BuildPack')
  }(name='BuildPackList'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListBuildPackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBuildPackResponseBody(name='body'),
}

async function listBuildPack(): ListBuildPackResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listBuildPackWithOptions(headers, runtime);
}

async function listBuildPackWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListBuildPackResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListBuildPack',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/app/build_pack_list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListClusterRequest {
  logicalRegionId?: string(name='LogicalRegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListClusterResponseBody = {
  clusterList?: {
    cluster?: [ 
    {
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      clusterType?: int32(name='ClusterType'),
      cpu?: int32(name='Cpu'),
      cpuUsed?: int32(name='CpuUsed'),
      createTime?: long(name='CreateTime'),
      csClusterId?: string(name='CsClusterId'),
      description?: string(name='Description'),
      iaasProvider?: string(name='IaasProvider'),
      mem?: int32(name='Mem'),
      memUsed?: int32(name='MemUsed'),
      networkMode?: int32(name='NetworkMode'),
      nodeNum?: int32(name='NodeNum'),
      oversoldFactor?: int32(name='OversoldFactor'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      updateTime?: long(name='UpdateTime'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Cluster')
  }(name='ClusterList'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClusterResponseBody(name='body'),
}

async function listCluster(request: ListClusterRequest): ListClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listClusterWithOptions(request, headers, runtime);
}

async function listClusterWithOptions(request: ListClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.logicalRegionId)) {
    query['LogicalRegionId'] = request.logicalRegionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/cluster_list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListClusterMembersRequest {
  clusterId?: string(name='ClusterId'),
  currentPage?: int32(name='CurrentPage'),
  ecsList?: string(name='EcsList'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterMembersResponseBody = {
  clusterMemberPage?: {
    clusterMemberList?: {
      clusterMember?: [ 
      {
        clusterId?: string(name='ClusterId'),
        clusterMemberId?: string(name='ClusterMemberId'),
        createTime?: long(name='CreateTime'),
        ecsId?: string(name='EcsId'),
        ecuId?: string(name='EcuId'),
        status?: int32(name='Status'),
        updateTime?: long(name='UpdateTime'),
      }
    ](name='ClusterMember')
    }(name='ClusterMemberList'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='ClusterMemberPage'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListClusterMembersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClusterMembersResponseBody(name='body'),
}

async function listClusterMembers(request: ListClusterMembersRequest): ListClusterMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listClusterMembersWithOptions(request, headers, runtime);
}

async function listClusterMembersWithOptions(request: ListClusterMembersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListClusterMembersResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.ecsList)) {
    query['EcsList'] = request.ecsList;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterMembers',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/cluster_member_list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListComponentsResponseBody = {
  code?: int32(name='Code'),
  componentList?: {
    component?: [ 
    {
      componentId?: string(name='ComponentId'),
      componentKey?: string(name='ComponentKey'),
      desc?: string(name='Desc'),
      expired?: boolean(name='Expired'),
      type?: string(name='Type'),
      version?: string(name='Version'),
    }
  ](name='Component')
  }(name='ComponentList'),
  message?: string(name='Message'),
}

model ListComponentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListComponentsResponseBody(name='body'),
}

async function listComponents(): ListComponentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listComponentsWithOptions(headers, runtime);
}

async function listComponentsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListComponentsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListComponents',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/components`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListConfigTemplatesRequest {
  currentPage?: long(name='CurrentPage', description='页码'),
  id?: long(name='Id', description='配置模板ID'),
  name?: string(name='Name', description='配置模板名称'),
  pageSize?: long(name='PageSize', description='页大小'),
}

model ListConfigTemplatesResponseBody = {
  code?: int32(name='Code', description='响应码'),
  data?: {
    currentPage?: int32(name='CurrentPage', description='当前分页'),
    pageSize?: int32(name='PageSize', description='页大小'),
    result?: [ 
      {
        content?: string(name='Content', description='模板内容'),
        description?: string(name='Description', description='模板描述'),
        format?: string(name='Format', description='模板数据格式'),
        gmtCreate?: long(name='GmtCreate', description='创建时间'),
        gmtModified?: long(name='GmtModified', description='更新时间'),
        id?: string(name='Id', description='配置模板ID'),
        name?: string(name='Name', description='配置模板名称'),
      }
    ](name='Result', description='配置模板列表'),
    totalSize?: long(name='TotalSize', description='配置模板总数'),
  }(name='Data', description='查询结果'),
  message?: string(name='Message', description='响应码文本描述'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model ListConfigTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConfigTemplatesResponseBody(name='body'),
}

async function listConfigTemplates(request: ListConfigTemplatesRequest): ListConfigTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConfigTemplatesWithOptions(request, headers, runtime);
}

async function listConfigTemplatesWithOptions(request: ListConfigTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListConfigTemplatesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConfigTemplates',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/config_template`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListConsumedServicesRequest {
  appId?: string(name='AppId'),
}

model ListConsumedServicesResponseBody = {
  code?: int32(name='Code'),
  consumedServicesList?: {
    listConsumedServices?: [ 
    {
      appId?: string(name='AppId'),
      dockerApplication?: boolean(name='DockerApplication'),
      group2Ip?: string(name='Group2Ip'),
      groups?: {
        group?: [ string ](name='group')
      }(name='Groups'),
      ips?: {
        ip?: [ string ](name='ip')
      }(name='Ips'),
      name?: string(name='Name'),
      type?: string(name='Type'),
      version?: string(name='Version'),
    }
  ](name='ListConsumedServices')
  }(name='ConsumedServicesList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListConsumedServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConsumedServicesResponseBody(name='body'),
}

async function listConsumedServices(request: ListConsumedServicesRequest): ListConsumedServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConsumedServicesWithOptions(request, headers, runtime);
}

async function listConsumedServicesWithOptions(request: ListConsumedServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListConsumedServicesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConsumedServices',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/service/listConsumedServices`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListConvertableEcuRequest {
  clusterId?: string(name='clusterId'),
}

model ListConvertableEcuResponseBody = {
  code?: int32(name='Code'),
  instanceList?: {
    instance?: [ 
    {
      cpu?: int32(name='Cpu'),
      ecuId?: string(name='EcuId'),
      eip?: string(name='Eip'),
      expired?: boolean(name='Expired'),
      innerIp?: string(name='InnerIp'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      mem?: int32(name='Mem'),
      privateIp?: string(name='PrivateIp'),
      publicIp?: string(name='PublicIp'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
    }
  ](name='Instance')
  }(name='InstanceList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListConvertableEcuResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConvertableEcuResponseBody(name='body'),
}

async function listConvertableEcu(request: ListConvertableEcuRequest): ListConvertableEcuResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConvertableEcuWithOptions(request, headers, runtime);
}

async function listConvertableEcuWithOptions(request: ListConvertableEcuRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListConvertableEcuResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['clusterId'] = request.clusterId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConvertableEcu',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/convertable_ecu_list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDeployGroupRequest {
  appId?: string(name='AppId'),
}

model ListDeployGroupResponseBody = {
  code?: int32(name='Code'),
  deployGroupList?: {
    deployGroup?: [ 
    {
      appId?: string(name='AppId'),
      appVersionId?: string(name='AppVersionId'),
      baseComponentMetaName?: string(name='BaseComponentMetaName'),
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      cpuLimit?: string(name='CpuLimit'),
      cpuRequest?: string(name='CpuRequest'),
      createTime?: long(name='CreateTime'),
      csClusterId?: string(name='CsClusterId'),
      deploymentName?: string(name='DeploymentName'),
      env?: string(name='Env'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      groupType?: int32(name='GroupType'),
      labels?: string(name='Labels'),
      lastUpdateTime?: long(name='LastUpdateTime'),
      memoryLimit?: string(name='MemoryLimit'),
      memoryRequest?: string(name='MemoryRequest'),
      nameSpace?: string(name='NameSpace'),
      packagePublicUrl?: string(name='PackagePublicUrl'),
      packageUrl?: string(name='PackageUrl'),
      packageVersion?: string(name='PackageVersion'),
      packageVersionId?: string(name='PackageVersionId'),
      postStart?: string(name='PostStart'),
      preStop?: string(name='PreStop'),
      reversion?: string(name='Reversion'),
      selector?: string(name='Selector'),
      status?: string(name='Status'),
      strategy?: string(name='Strategy'),
      updateTime?: long(name='UpdateTime'),
      VExtServerGroupId?: string(name='VExtServerGroupId'),
      VServerGroupId?: string(name='VServerGroupId'),
    }
  ](name='DeployGroup')
  }(name='DeployGroupList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListDeployGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeployGroupResponseBody(name='body'),
}

async function listDeployGroup(request: ListDeployGroupRequest): ListDeployGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeployGroupWithOptions(request, headers, runtime);
}

async function listDeployGroupWithOptions(request: ListDeployGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeployGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeployGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/app/deploy_group_list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEcsNotInClusterRequest {
  networkMode?: int32(name='NetworkMode'),
  vpcId?: string(name='VpcId'),
}

model ListEcsNotInClusterResponseBody = {
  code?: int32(name='Code'),
  ecsEntityList?: {
    ecsEntity?: [ 
    {
      cpu?: int32(name='Cpu'),
      eip?: string(name='Eip'),
      expired?: boolean(name='Expired'),
      innerIp?: string(name='InnerIp'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      mem?: int32(name='Mem'),
      privateIp?: string(name='PrivateIp'),
      publicIp?: string(name='PublicIp'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
    }
  ](name='EcsEntity')
  }(name='EcsEntityList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListEcsNotInClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEcsNotInClusterResponseBody(name='body'),
}

async function listEcsNotInCluster(request: ListEcsNotInClusterRequest): ListEcsNotInClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEcsNotInClusterWithOptions(request, headers, runtime);
}

async function listEcsNotInClusterWithOptions(request: ListEcsNotInClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEcsNotInClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.networkMode)) {
    query['NetworkMode'] = request.networkMode;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEcsNotInCluster',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/ecs_not_in_cluster`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEcuByRegionRequest {
  act?: string(name='Act'),
  logicalRegionId?: string(name='LogicalRegionId'),
}

model ListEcuByRegionResponseBody = {
  code?: int32(name='Code'),
  ecuEntityList?: {
    ecuEntity?: [ 
    {
      availableCpu?: int32(name='AvailableCpu'),
      availableMem?: int32(name='AvailableMem'),
      cpu?: int32(name='Cpu'),
      createTime?: long(name='CreateTime'),
      dockerEnv?: boolean(name='DockerEnv'),
      ecuId?: string(name='EcuId'),
      heartbeatTime?: long(name='HeartbeatTime'),
      instanceId?: string(name='InstanceId'),
      ipAddr?: string(name='IpAddr'),
      mem?: int32(name='Mem'),
      name?: string(name='Name'),
      online?: boolean(name='Online'),
      regionId?: string(name='RegionId'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='EcuEntity')
  }(name='EcuEntityList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListEcuByRegionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEcuByRegionResponseBody(name='body'),
}

async function listEcuByRegion(request: ListEcuByRegionRequest): ListEcuByRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEcuByRegionWithOptions(request, headers, runtime);
}

async function listEcuByRegionWithOptions(request: ListEcuByRegionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEcuByRegionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.act)) {
    query['Act'] = request.act;
  }
  if (!Util.isUnset(request.logicalRegionId)) {
    query['LogicalRegionId'] = request.logicalRegionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEcuByRegion',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/ecu_list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListHistoryDeployVersionRequest {
  appId?: string(name='AppId'),
}

model ListHistoryDeployVersionResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  packageVersionList?: {
    packageVersion?: [ 
    {
      appId?: string(name='AppId'),
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      packageVersion?: string(name='PackageVersion'),
      publicUrl?: string(name='PublicUrl'),
      type?: string(name='Type'),
      updateTime?: long(name='UpdateTime'),
      warUrl?: string(name='WarUrl'),
    }
  ](name='PackageVersion')
  }(name='PackageVersionList'),
  requestId?: string(name='RequestId'),
}

model ListHistoryDeployVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListHistoryDeployVersionResponseBody(name='body'),
}

async function listHistoryDeployVersion(request: ListHistoryDeployVersionRequest): ListHistoryDeployVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listHistoryDeployVersionWithOptions(request, headers, runtime);
}

async function listHistoryDeployVersionWithOptions(request: ListHistoryDeployVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListHistoryDeployVersionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHistoryDeployVersion',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/app/deploy_history_version_list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListK8sConfigMapsRequest {
  clusterId?: string(name='ClusterId'),
  condition?: map[string]any(name='Condition'),
  namespace?: string(name='Namespace'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  showRelatedApps?: boolean(name='ShowRelatedApps'),
}

model ListK8sConfigMapsResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    configMaps?: [ 
      {
        clusterId?: string(name='ClusterId'),
        clusterName?: string(name='ClusterName'),
        creationTime?: string(name='CreationTime'),
        data?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Data'),
        name?: string(name='Name'),
        namespace?: string(name='Namespace'),
        relatedApps?: [ 
          {
            appId?: string(name='AppId'),
            appName?: string(name='AppName'),
          }
        ](name='RelatedApps'),
      }
    ](name='ConfigMaps'),
    total?: int32(name='Total'),
  }(name='Result'),
}

model ListK8sConfigMapsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListK8sConfigMapsResponseBody(name='body'),
}

async function listK8sConfigMaps(request: ListK8sConfigMapsRequest): ListK8sConfigMapsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listK8sConfigMapsWithOptions(request, headers, runtime);
}

async function listK8sConfigMapsWithOptions(request: ListK8sConfigMapsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListK8sConfigMapsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.condition)) {
    query['Condition'] = request.condition;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.showRelatedApps)) {
    query['ShowRelatedApps'] = request.showRelatedApps;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListK8sConfigMaps',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_config_map`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListK8sIngressRulesRequest {
  clusterId?: string(name='ClusterId'),
  condition?: string(name='Condition'),
  namespace?: string(name='Namespace'),
  regionId?: string(name='RegionId'),
}

model ListK8sIngressRulesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      ingressConfs?: [ 
        {
          albId?: string(name='AlbId'),
          creationTime?: string(name='CreationTime'),
          dashboardUrl?: string(name='DashboardUrl'),
          endpoint?: string(name='Endpoint'),
          ingressType?: string(name='IngressType'),
          name?: string(name='Name'),
          namespace?: string(name='Namespace'),
          rules?: [ 
            {
              enableTls?: boolean(name='EnableTls'),
              host?: string(name='Host'),
              paths?: [ 
                {
                  appId?: string(name='AppId'),
                  appName?: string(name='AppName'),
                  backend?: {
                    serviceName?: string(name='ServiceName'),
                    servicePort?: string(name='ServicePort'),
                  }(name='Backend'),
                  path?: string(name='Path'),
                  status?: string(name='Status'),
                }
              ](name='Paths'),
              secretName?: string(name='SecretName'),
            }
          ](name='Rules'),
          sslRedirect?: boolean(name='SslRedirect'),
        }
      ](name='IngressConfs'),
      regionId?: string(name='RegionId'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListK8sIngressRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListK8sIngressRulesResponseBody(name='body'),
}

async function listK8sIngressRules(request: ListK8sIngressRulesRequest): ListK8sIngressRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listK8sIngressRulesWithOptions(request, headers, runtime);
}

async function listK8sIngressRulesWithOptions(request: ListK8sIngressRulesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListK8sIngressRulesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.condition)) {
    query['Condition'] = request.condition;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListK8sIngressRules',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_ingress`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListK8sSecretsRequest {
  clusterId?: string(name='ClusterId'),
  condition?: string(name='Condition'),
  namespace?: string(name='Namespace'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  showRelatedApps?: boolean(name='ShowRelatedApps'),
}

model ListK8sSecretsResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    secrets?: [ 
      {
        base64Encoded?: boolean(name='Base64Encoded'),
        certDetail?: {
          domainNames?: [ string ](name='DomainNames'),
          endTime?: string(name='EndTime'),
          issuer?: string(name='Issuer'),
          startTime?: string(name='StartTime'),
          status?: string(name='Status'),
        }(name='CertDetail'),
        certId?: string(name='CertId'),
        certRegionId?: string(name='CertRegionId'),
        clusterId?: string(name='ClusterId'),
        clusterName?: string(name='ClusterName'),
        creationTime?: string(name='CreationTime'),
        data?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Data'),
        name?: string(name='Name'),
        namespace?: string(name='Namespace'),
        relatedApps?: [ 
          {
            appId?: string(name='AppId'),
            appName?: string(name='AppName'),
          }
        ](name='RelatedApps'),
        relatedIngressRules?: [ 
          {
            name?: string(name='Name'),
            namespace?: string(name='Namespace'),
            relatedApps?: [ 
              {
                appId?: string(name='AppId'),
                appName?: string(name='AppName'),
              }
            ](name='RelatedApps'),
          }
        ](name='RelatedIngressRules'),
        type?: string(name='Type'),
      }
    ](name='Secrets'),
    total?: int32(name='Total'),
  }(name='Result'),
}

model ListK8sSecretsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListK8sSecretsResponseBody(name='body'),
}

async function listK8sSecrets(request: ListK8sSecretsRequest): ListK8sSecretsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listK8sSecretsWithOptions(request, headers, runtime);
}

async function listK8sSecretsWithOptions(request: ListK8sSecretsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListK8sSecretsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.condition)) {
    query['Condition'] = request.condition;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.showRelatedApps)) {
    query['ShowRelatedApps'] = request.showRelatedApps;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListK8sSecrets',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_secret`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListMethodsRequest {
  appId?: string(name='AppId'),
  serviceName?: string(name='ServiceName'),
}

model ListMethodsResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  serviceMethodList?: {
    serviceMethod?: [ 
    {
      appName?: string(name='AppName'),
      inputParams?: {
        inputParam?: [ string ](name='InputParam')
      }(name='InputParams'),
      methodName?: string(name='MethodName'),
      output?: string(name='Output'),
      paramTypes?: {
        paramType?: [ string ](name='ParamType')
      }(name='ParamTypes'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='ServiceMethod')
  }(name='ServiceMethodList'),
}

model ListMethodsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMethodsResponseBody(name='body'),
}

async function listMethods(request: ListMethodsRequest): ListMethodsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMethodsWithOptions(request, headers, runtime);
}

async function listMethodsWithOptions(request: ListMethodsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMethodsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMethods',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/service/list_methods`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPublishedServicesRequest {
  appId?: string(name='AppId'),
}

model ListPublishedServicesResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  publishedServicesList?: {
    listPublishedServices?: [ 
    {
      appId?: string(name='AppId'),
      dockerApplication?: boolean(name='DockerApplication'),
      group2Ip?: string(name='Group2Ip'),
      groups?: {
        group?: [ string ](name='group')
      }(name='Groups'),
      ips?: {
        ip?: [ string ](name='ip')
      }(name='Ips'),
      name?: string(name='Name'),
      type?: string(name='Type'),
      version?: string(name='Version'),
    }
  ](name='ListPublishedServices')
  }(name='PublishedServicesList'),
  requestId?: string(name='RequestId'),
}

model ListPublishedServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPublishedServicesResponseBody(name='body'),
}

async function listPublishedServices(request: ListPublishedServicesRequest): ListPublishedServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPublishedServicesWithOptions(request, headers, runtime);
}

async function listPublishedServicesWithOptions(request: ListPublishedServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPublishedServicesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPublishedServices',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/service/listPublishedServices`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRecentChangeOrderRequest {
  appId?: string(name='AppId'),
}

model ListRecentChangeOrderResponseBody = {
  changeOrderList?: {
    changeOrder?: [ 
    {
      appId?: string(name='AppId'),
      batchCount?: int32(name='BatchCount'),
      batchType?: string(name='BatchType'),
      changeOrderDescription?: string(name='ChangeOrderDescription'),
      changeOrderId?: string(name='ChangeOrderId'),
      coType?: string(name='CoType'),
      coTypeCode?: string(name='CoTypeCode'),
      createTime?: string(name='CreateTime'),
      createUserId?: string(name='CreateUserId'),
      finishTime?: string(name='FinishTime'),
      groupId?: string(name='GroupId'),
      source?: string(name='Source'),
      status?: int32(name='Status'),
      userId?: string(name='UserId'),
    }
  ](name='ChangeOrder')
  }(name='ChangeOrderList'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListRecentChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRecentChangeOrderResponseBody(name='body'),
}

async function listRecentChangeOrder(request: ListRecentChangeOrderRequest): ListRecentChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRecentChangeOrderWithOptions(request, headers, runtime);
}

async function listRecentChangeOrderWithOptions(request: ListRecentChangeOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRecentChangeOrderResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRecentChangeOrder',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/change_order_list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListResourceGroupResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resourceGroupList?: {
    resGroupEntity?: [ 
    {
      adminUserId?: string(name='AdminUserId'),
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      slbList?: {
        slbEntity?: [ 
        {
          address?: string(name='Address'),
          addressType?: string(name='AddressType'),
          expired?: boolean(name='Expired'),
          groupId?: int32(name='GroupId'),
          networkType?: string(name='NetworkType'),
          regionId?: string(name='RegionId'),
          slbId?: string(name='SlbId'),
          slbName?: string(name='SlbName'),
          slbStatus?: string(name='SlbStatus'),
          userId?: string(name='UserId'),
          vpcId?: string(name='VpcId'),
          vswitchId?: string(name='VswitchId'),
        }
      ](name='SlbEntity')
      }(name='SlbList'),
      updateTime?: long(name='UpdateTime'),
      ecsList?: {
        ecsEntity?: [ 
        {
          cpu?: int32(name='Cpu'),
          description?: string(name='Description'),
          ecuEntity?: {
            availableCpu?: int32(name='AvailableCpu'),
            availableMem?: int32(name='AvailableMem'),
            cpu?: int32(name='Cpu'),
            createTime?: long(name='CreateTime'),
            dockerEnv?: boolean(name='DockerEnv'),
            ecuId?: string(name='EcuId'),
            heartbeatTime?: long(name='HeartbeatTime'),
            instanceId?: string(name='InstanceId'),
            ipAddr?: string(name='IpAddr'),
            mem?: int32(name='Mem'),
            name?: string(name='Name'),
            online?: boolean(name='Online'),
            regionId?: string(name='RegionId'),
            updateTime?: long(name='UpdateTime'),
            userId?: string(name='UserId'),
            vpcId?: string(name='VpcId'),
            zoneId?: string(name='ZoneId'),
          }(name='EcuEntity'),
          eip?: string(name='Eip'),
          expired?: boolean(name='Expired'),
          groupId?: string(name='GroupId'),
          hostName?: string(name='HostName'),
          innerIp?: string(name='InnerIp'),
          instanceId?: string(name='InstanceId'),
          instanceName?: string(name='InstanceName'),
          mem?: int32(name='Mem'),
          privateIp?: string(name='PrivateIp'),
          publicIp?: string(name='PublicIp'),
          regionId?: string(name='RegionId'),
          serialNum?: string(name='SerialNum'),
          sgId?: string(name='SgId'),
          status?: string(name='Status'),
          userId?: string(name='UserId'),
          vpcEntity?: {
            cidrblock?: string(name='Cidrblock'),
            description?: string(name='Description'),
            ecsNum?: int32(name='EcsNum'),
            expired?: boolean(name='Expired'),
            regionId?: string(name='RegionId'),
            status?: string(name='Status'),
            userId?: string(name='UserId'),
            vpcId?: string(name='VpcId'),
            vpcName?: string(name='VpcName'),
          }(name='VpcEntity'),
          vpcId?: string(name='VpcId'),
          zoneId?: string(name='ZoneId'),
        }
      ](name='EcsEntity')
      }(name='ecsList'),
    }
  ](name='ResGroupEntity')
  }(name='ResourceGroupList'),
}

model ListResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceGroupResponseBody(name='body'),
}

async function listResourceGroup(): ListResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceGroupWithOptions(headers, runtime);
}

async function listResourceGroupWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListResourceGroup',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/reg_group_list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRoleResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  roleList?: {
    roleItem?: [ 
    {
      actionList?: {
        action?: [ 
        {
          code?: string(name='Code'),
          description?: string(name='Description'),
          groupId?: string(name='GroupId'),
          name?: string(name='Name'),
        }
      ](name='Action')
      }(name='ActionList'),
      role?: {
        adminUserId?: string(name='AdminUserId'),
        createTime?: long(name='CreateTime'),
        id?: int32(name='Id'),
        isDefault?: boolean(name='IsDefault'),
        name?: string(name='Name'),
        updateTime?: long(name='UpdateTime'),
      }(name='Role'),
    }
  ](name='RoleItem')
  }(name='RoleList'),
}

model ListRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRoleResponseBody(name='body'),
}

async function listRole(): ListRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRoleWithOptions(headers, runtime);
}

async function listRoleWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListRoleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListRole',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/account/role_list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRootStacksRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
}

model ListRootStacksResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        children?: [ 
          {
            comment?: string(name='Comment'),
            icon?: string(name='Icon'),
            id?: long(name='Id'),
            name?: string(name='Name'),
          }
        ](name='Children'),
        root?: {
          id?: long(name='Id'),
          name?: string(name='Name'),
        }(name='Root'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListRootStacksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRootStacksResponseBody(name='body'),
}

async function listRootStacks(request: ListRootStacksRequest): ListRootStacksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRootStacksWithOptions(request, headers, runtime);
}

async function listRootStacksWithOptions(request: ListRootStacksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRootStacksResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRootStacks',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/s2i/list_root_stack`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListScaleOutEcuRequest {
  appId?: string(name='AppId'),
  clusterId?: string(name='ClusterId'),
  cpu?: int32(name='Cpu'),
  groupId?: string(name='GroupId'),
  instanceNum?: int32(name='InstanceNum'),
  logicalRegionId?: string(name='LogicalRegionId'),
  mem?: int32(name='Mem'),
}

model ListScaleOutEcuResponseBody = {
  code?: int32(name='Code'),
  ecuInfoList?: {
    ecuInfo?: [ 
    {
      availableCpu?: int32(name='AvailableCpu'),
      availableMem?: int32(name='AvailableMem'),
      createTime?: long(name='CreateTime'),
      dockerEnv?: boolean(name='DockerEnv'),
      ecuId?: string(name='EcuId'),
      heartbeatTime?: long(name='HeartbeatTime'),
      instanceId?: string(name='InstanceId'),
      ipAddr?: string(name='IpAddr'),
      name?: string(name='Name'),
      online?: boolean(name='Online'),
      regionId?: string(name='RegionId'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='EcuInfo')
  }(name='EcuInfoList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListScaleOutEcuResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListScaleOutEcuResponseBody(name='body'),
}

async function listScaleOutEcu(request: ListScaleOutEcuRequest): ListScaleOutEcuResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listScaleOutEcuWithOptions(request, headers, runtime);
}

async function listScaleOutEcuWithOptions(request: ListScaleOutEcuRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListScaleOutEcuResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.cpu)) {
    query['Cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.instanceNum)) {
    query['InstanceNum'] = request.instanceNum;
  }
  if (!Util.isUnset(request.logicalRegionId)) {
    query['LogicalRegionId'] = request.logicalRegionId;
  }
  if (!Util.isUnset(request.mem)) {
    query['Mem'] = request.mem;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListScaleOutEcu',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/scale_out_ecu_list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListServiceGroupsResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  serviceGroupsList?: {
    listServiceGroups?: [ 
    {
      createTime?: string(name='CreateTime'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
    }
  ](name='ListServiceGroups')
  }(name='ServiceGroupsList'),
}

model ListServiceGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceGroupsResponseBody(name='body'),
}

async function listServiceGroups(): ListServiceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServiceGroupsWithOptions(headers, runtime);
}

async function listServiceGroupsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListServiceGroupsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListServiceGroups',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/service/serviceGroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSlbResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  slbList?: {
    slbEntity?: [ 
    {
      address?: string(name='Address'),
      addressType?: string(name='AddressType'),
      expired?: boolean(name='Expired'),
      groupId?: int32(name='GroupId'),
      networkType?: string(name='NetworkType'),
      regionId?: string(name='RegionId'),
      slbId?: string(name='SlbId'),
      slbName?: string(name='SlbName'),
      slbStatus?: string(name='SlbStatus'),
      userId?: string(name='UserId'),
      vpcId?: string(name='VpcId'),
      vswitchId?: string(name='VswitchId'),
    }
  ](name='SlbEntity')
  }(name='SlbList'),
}

model ListSlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSlbResponseBody(name='body'),
}

async function listSlb(): ListSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSlbWithOptions(headers, runtime);
}

async function listSlbWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListSlbResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListSlb',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/slb_list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSubAccountResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  subAccountList?: {
    subAccount?: [ 
    {
      adminEdasId?: string(name='AdminEdasId'),
      adminUserId?: string(name='AdminUserId'),
      adminUserKp?: string(name='AdminUserKp'),
      email?: string(name='Email'),
      phone?: string(name='Phone'),
      subEdasId?: string(name='SubEdasId'),
      subUserId?: string(name='SubUserId'),
      subUserKp?: string(name='SubUserKp'),
    }
  ](name='SubAccount')
  }(name='SubAccountList'),
}

model ListSubAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSubAccountResponseBody(name='body'),
}

async function listSubAccount(): ListSubAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSubAccountWithOptions(headers, runtime);
}

async function listSubAccountWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListSubAccountResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListSubAccount',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/account/sub_account_list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTagResourcesRequest {
  resourceIds?: map[string]any(name='ResourceIds'),
  resourceRegionId?: string(name='ResourceRegionId'),
  resourceType?: string(name='ResourceType'),
  tags?: map[string]any(name='Tags'),
}

model ListTagResourcesResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceRegionId)) {
    query['ResourceRegionId'] = request.resourceRegionId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/tag/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListUserDefineRegionRequest {
  debugEnable?: boolean(name='DebugEnable'),
}

model ListUserDefineRegionResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  userDefineRegionList?: {
    userDefineRegionEntity?: [ 
    {
      belongRegion?: string(name='BelongRegion'),
      debugEnable?: boolean(name='DebugEnable'),
      description?: string(name='Description'),
      id?: long(name='Id'),
      regionId?: string(name='RegionId'),
      regionName?: string(name='RegionName'),
      userId?: string(name='UserId'),
    }
  ](name='UserDefineRegionEntity')
  }(name='UserDefineRegionList'),
}

model ListUserDefineRegionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserDefineRegionResponseBody(name='body'),
}

async function listUserDefineRegion(request: ListUserDefineRegionRequest): ListUserDefineRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUserDefineRegionWithOptions(request, headers, runtime);
}

async function listUserDefineRegionWithOptions(request: ListUserDefineRegionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListUserDefineRegionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.debugEnable)) {
    query['DebugEnable'] = request.debugEnable;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserDefineRegion',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/user_region_defs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListVpcResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  vpcList?: {
    vpcEntity?: [ 
    {
      ecsNum?: int32(name='EcsNum'),
      expired?: boolean(name='Expired'),
      regionId?: string(name='RegionId'),
      userId?: string(name='UserId'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
    }
  ](name='VpcEntity')
  }(name='VpcList'),
}

model ListVpcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVpcResponseBody(name='body'),
}

async function listVpc(): ListVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVpcWithOptions(headers, runtime);
}

async function listVpcWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListVpcResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListVpc',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/vpc_list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model MigrateEcuRequest {
  instanceIds?: string(name='InstanceIds'),
  logicalRegionId?: string(name='LogicalRegionId'),
}

model MigrateEcuResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model MigrateEcuResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MigrateEcuResponseBody(name='body'),
}

async function migrateEcu(request: MigrateEcuRequest): MigrateEcuResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return migrateEcuWithOptions(request, headers, runtime);
}

async function migrateEcuWithOptions(request: MigrateEcuRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MigrateEcuResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.logicalRegionId)) {
    query['LogicalRegionId'] = request.logicalRegionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MigrateEcu',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/migrate_ecu`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyScalingRuleRequest {
  acceptEULA?: boolean(name='AcceptEULA'),
  appId?: string(name='AppId'),
  groupId?: string(name='GroupId'),
  inCondition?: string(name='InCondition'),
  inCpu?: int32(name='InCpu'),
  inDuration?: int32(name='InDuration'),
  inEnable?: boolean(name='InEnable'),
  inInstanceNum?: int32(name='InInstanceNum'),
  inLoad?: int32(name='InLoad'),
  inRT?: int32(name='InRT'),
  inStep?: int32(name='InStep'),
  keyPairName?: string(name='KeyPairName'),
  multiAzPolicy?: string(name='MultiAzPolicy'),
  outCPU?: int32(name='OutCPU'),
  outCondition?: string(name='OutCondition'),
  outDuration?: int32(name='OutDuration'),
  outEnable?: boolean(name='OutEnable'),
  outInstanceNum?: int32(name='OutInstanceNum'),
  outLoad?: int32(name='OutLoad'),
  outRT?: int32(name='OutRT'),
  outStep?: int32(name='OutStep'),
  password?: string(name='Password'),
  resourceFrom?: string(name='ResourceFrom'),
  scalingPolicy?: string(name='ScalingPolicy'),
  templateId?: string(name='TemplateId'),
  templateInstanceId?: string(name='TemplateInstanceId'),
  templateInstanceName?: string(name='TemplateInstanceName'),
  templateVersion?: int32(name='TemplateVersion'),
  vSwitchIds?: string(name='VSwitchIds'),
  vpcId?: string(name='VpcId'),
}

model ModifyScalingRuleResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ModifyScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyScalingRuleResponseBody(name='body'),
}

async function modifyScalingRule(request: ModifyScalingRuleRequest): ModifyScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyScalingRuleWithOptions(request, headers, runtime);
}

async function modifyScalingRuleWithOptions(request: ModifyScalingRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyScalingRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.acceptEULA)) {
    query['AcceptEULA'] = request.acceptEULA;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.inCondition)) {
    query['InCondition'] = request.inCondition;
  }
  if (!Util.isUnset(request.inCpu)) {
    query['InCpu'] = request.inCpu;
  }
  if (!Util.isUnset(request.inDuration)) {
    query['InDuration'] = request.inDuration;
  }
  if (!Util.isUnset(request.inEnable)) {
    query['InEnable'] = request.inEnable;
  }
  if (!Util.isUnset(request.inInstanceNum)) {
    query['InInstanceNum'] = request.inInstanceNum;
  }
  if (!Util.isUnset(request.inLoad)) {
    query['InLoad'] = request.inLoad;
  }
  if (!Util.isUnset(request.inRT)) {
    query['InRT'] = request.inRT;
  }
  if (!Util.isUnset(request.inStep)) {
    query['InStep'] = request.inStep;
  }
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.multiAzPolicy)) {
    query['MultiAzPolicy'] = request.multiAzPolicy;
  }
  if (!Util.isUnset(request.outCPU)) {
    query['OutCPU'] = request.outCPU;
  }
  if (!Util.isUnset(request.outCondition)) {
    query['OutCondition'] = request.outCondition;
  }
  if (!Util.isUnset(request.outDuration)) {
    query['OutDuration'] = request.outDuration;
  }
  if (!Util.isUnset(request.outEnable)) {
    query['OutEnable'] = request.outEnable;
  }
  if (!Util.isUnset(request.outInstanceNum)) {
    query['OutInstanceNum'] = request.outInstanceNum;
  }
  if (!Util.isUnset(request.outLoad)) {
    query['OutLoad'] = request.outLoad;
  }
  if (!Util.isUnset(request.outRT)) {
    query['OutRT'] = request.outRT;
  }
  if (!Util.isUnset(request.outStep)) {
    query['OutStep'] = request.outStep;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.resourceFrom)) {
    query['ResourceFrom'] = request.resourceFrom;
  }
  if (!Util.isUnset(request.scalingPolicy)) {
    query['ScalingPolicy'] = request.scalingPolicy;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.templateInstanceId)) {
    query['TemplateInstanceId'] = request.templateInstanceId;
  }
  if (!Util.isUnset(request.templateInstanceName)) {
    query['TemplateInstanceName'] = request.templateInstanceName;
  }
  if (!Util.isUnset(request.templateVersion)) {
    query['TemplateVersion'] = request.templateVersion;
  }
  if (!Util.isUnset(request.vSwitchIds)) {
    query['VSwitchIds'] = request.vSwitchIds;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyScalingRule',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/app/scaling_rules`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryApplicationStatusRequest {
  appId?: string(name='AppId'),
}

model QueryApplicationStatusResponseBody = {
  appInfo?: {
    application?: {
      applicationId?: string(name='ApplicationId'),
      buildPackageId?: int32(name='BuildPackageId'),
      clusterId?: string(name='ClusterId'),
      cpu?: int32(name='Cpu'),
      createTime?: long(name='CreateTime'),
      dockerize?: boolean(name='Dockerize'),
      email?: string(name='Email'),
      healthCheckUrl?: string(name='HealthCheckUrl'),
      instanceCount?: int32(name='InstanceCount'),
      launchTime?: long(name='LaunchTime'),
      memory?: int32(name='Memory'),
      name?: string(name='Name'),
      owner?: string(name='Owner'),
      phone?: string(name='Phone'),
      port?: int32(name='Port'),
      regionId?: string(name='RegionId'),
      runningInstanceCount?: int32(name='RunningInstanceCount'),
      userId?: string(name='UserId'),
    }(name='Application'),
    deployRecordList?: {
      deployRecord?: [ 
      {
        createTime?: long(name='CreateTime'),
        deployRecordId?: string(name='DeployRecordId'),
        eccId?: string(name='EccId'),
        ecuId?: string(name='EcuId'),
        packageMd5?: string(name='PackageMd5'),
        packageVersionId?: string(name='PackageVersionId'),
      }
    ](name='DeployRecord')
    }(name='DeployRecordList'),
    eccList?: {
      ecc?: [ 
      {
        appId?: string(name='AppId'),
        appState?: int32(name='AppState'),
        containerStatus?: string(name='ContainerStatus'),
        createTime?: long(name='CreateTime'),
        eccId?: string(name='EccId'),
        ecuId?: string(name='EcuId'),
        groupId?: string(name='GroupId'),
        ip?: string(name='Ip'),
        taskState?: int32(name='TaskState'),
        updateTime?: long(name='UpdateTime'),
        vpcId?: string(name='VpcId'),
      }
    ](name='Ecc')
    }(name='EccList'),
    ecuList?: {
      ecu?: [ 
      {
        availableCpu?: int32(name='AvailableCpu'),
        availableMem?: int32(name='AvailableMem'),
        createTime?: long(name='CreateTime'),
        dockerEnv?: boolean(name='DockerEnv'),
        ecuId?: string(name='EcuId'),
        groupId?: string(name='GroupId'),
        heartbeatTime?: long(name='HeartbeatTime'),
        instanceId?: string(name='InstanceId'),
        ipAddr?: string(name='IpAddr'),
        name?: string(name='Name'),
        online?: boolean(name='Online'),
        regionId?: string(name='RegionId'),
        updateTime?: long(name='UpdateTime'),
        userId?: string(name='UserId'),
        vpcId?: string(name='VpcId'),
        zoneId?: string(name='ZoneId'),
      }
    ](name='Ecu')
    }(name='EcuList'),
    groupList?: {
      group?: [ 
      {
        appId?: string(name='AppId'),
        appVersionId?: string(name='AppVersionId'),
        clusterId?: string(name='ClusterId'),
        createTime?: long(name='CreateTime'),
        groupId?: string(name='GroupId'),
        groupName?: string(name='GroupName'),
        groupType?: int32(name='GroupType'),
        packageVersionId?: string(name='PackageVersionId'),
        updateTime?: long(name='UpdateTime'),
      }
    ](name='Group')
    }(name='GroupList'),
  }(name='AppInfo'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryApplicationStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryApplicationStatusResponseBody(name='body'),
}

async function queryApplicationStatus(request: QueryApplicationStatusRequest): QueryApplicationStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryApplicationStatusWithOptions(request, headers, runtime);
}

async function queryApplicationStatusWithOptions(request: QueryApplicationStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryApplicationStatusResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryApplicationStatus',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/app/app_status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryEccInfoRequest {
  eccId?: string(name='EccId'),
}

model QueryEccInfoResponseBody = {
  code?: int32(name='Code'),
  eccInfo?: {
    appId?: string(name='AppId'),
    eccId?: string(name='EccId'),
    ecuId?: string(name='EcuId'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    packageMd5?: string(name='PackageMd5'),
    packageVersion?: string(name='PackageVersion'),
    vpcId?: string(name='VpcId'),
  }(name='EccInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryEccInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryEccInfoResponseBody(name='body'),
}

async function queryEccInfo(request: QueryEccInfoRequest): QueryEccInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryEccInfoWithOptions(request, headers, runtime);
}

async function queryEccInfoWithOptions(request: QueryEccInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryEccInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.eccId)) {
    query['EccId'] = request.eccId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEccInfo',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/ecc`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryMigrateEcuListRequest {
  logicalRegionId?: string(name='LogicalRegionId'),
}

model QueryMigrateEcuListResponseBody = {
  code?: int32(name='Code'),
  ecuEntityList?: {
    ecuEntity?: [ 
    {
      availableCpu?: int32(name='AvailableCpu'),
      availableMem?: int32(name='AvailableMem'),
      cpu?: int32(name='Cpu'),
      createTime?: long(name='CreateTime'),
      dockerEnv?: boolean(name='DockerEnv'),
      ecuId?: string(name='EcuId'),
      heartbeatTime?: long(name='HeartbeatTime'),
      instanceId?: string(name='InstanceId'),
      ipAddr?: string(name='IpAddr'),
      mem?: int32(name='Mem'),
      name?: string(name='Name'),
      online?: boolean(name='Online'),
      regionId?: string(name='RegionId'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='EcuEntity')
  }(name='EcuEntityList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryMigrateEcuListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMigrateEcuListResponseBody(name='body'),
}

async function queryMigrateEcuList(request: QueryMigrateEcuListRequest): QueryMigrateEcuListResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryMigrateEcuListWithOptions(request, headers, runtime);
}

async function queryMigrateEcuListWithOptions(request: QueryMigrateEcuListRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryMigrateEcuListResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.logicalRegionId)) {
    query['LogicalRegionId'] = request.logicalRegionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMigrateEcuList',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/migrate_ecu_list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryMigrateRegionListRequest {
  logicalRegionId?: string(name='LogicalRegionId'),
}

model QueryMigrateRegionListResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  regionEntityList?: {
    regionEntity?: [ 
    {
      regionName?: string(name='RegionName'),
      regionNo?: string(name='RegionNo'),
    }
  ](name='RegionEntity')
  }(name='RegionEntityList'),
  requestId?: string(name='RequestId'),
}

model QueryMigrateRegionListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMigrateRegionListResponseBody(name='body'),
}

async function queryMigrateRegionList(request: QueryMigrateRegionListRequest): QueryMigrateRegionListResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryMigrateRegionListWithOptions(request, headers, runtime);
}

async function queryMigrateRegionListWithOptions(request: QueryMigrateRegionListRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryMigrateRegionListResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.logicalRegionId)) {
    query['LogicalRegionId'] = request.logicalRegionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMigrateRegionList',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/migrate_region_select`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryRegionConfigResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  regionConfig?: {
    addressServerHost?: string(name='AddressServerHost'),
    agentInstallScript?: string(name='AgentInstallScript'),
    fileServerConfig?: {
      bucket?: string(name='Bucket'),
      internalUrl?: string(name='InternalUrl'),
      publicUrl?: string(name='PublicUrl'),
      vpcUrl?: string(name='VpcUrl'),
    }(name='FileServerConfig'),
    fileServerType?: string(name='FileServerType'),
    id?: string(name='Id'),
    imageId?: string(name='ImageId'),
    name?: string(name='Name'),
    no?: int32(name='No'),
    tag?: string(name='Tag'),
  }(name='RegionConfig'),
  requestId?: string(name='RequestId'),
}

model QueryRegionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryRegionConfigResponseBody(name='body'),
}

async function queryRegionConfig(): QueryRegionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryRegionConfigWithOptions(headers, runtime);
}

async function queryRegionConfigWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): QueryRegionConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'QueryRegionConfig',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/region_config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QuerySlsLogStoreListRequest {
  appId?: string(name='AppId'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  type?: string(name='Type'),
}

model QuerySlsLogStoreListResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      consumerSide?: string(name='ConsumerSide'),
      createTime?: string(name='CreateTime'),
      link?: string(name='Link'),
      logstore?: string(name='Logstore'),
      project?: string(name='Project'),
      source?: string(name='Source'),
    }
  ](name='Result'),
  totalSize?: int32(name='TotalSize'),
}

model QuerySlsLogStoreListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySlsLogStoreListResponseBody(name='body'),
}

async function querySlsLogStoreList(request: QuerySlsLogStoreListRequest): QuerySlsLogStoreListResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return querySlsLogStoreListWithOptions(request, headers, runtime);
}

async function querySlsLogStoreListWithOptions(request: QuerySlsLogStoreListRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QuerySlsLogStoreListResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySlsLogStoreList',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/sls/query_sls_log_store_list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RemoveMockRuleRequest {
  id?: long(name='Id'),
}

model RemoveMockRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountId?: string(name='AccountId'),
    consumerAppId?: string(name='ConsumerAppId'),
    consumerAppName?: string(name='ConsumerAppName'),
    enable?: boolean(name='Enable'),
    extraJson?: string(name='ExtraJson'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    namespaceId?: string(name='NamespaceId'),
    providerAppId?: string(name='ProviderAppId'),
    providerAppName?: string(name='ProviderAppName'),
    region?: string(name='Region'),
    scMockItemJson?: string(name='ScMockItemJson'),
    source?: string(name='Source'),
  }(name='Data'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RemoveMockRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveMockRuleResponseBody(name='body'),
}

async function removeMockRule(request: RemoveMockRuleRequest): RemoveMockRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeMockRuleWithOptions(request, headers, runtime);
}

async function removeMockRuleWithOptions(request: RemoveMockRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveMockRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveMockRule',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/sp/api/mock/removeMockRule`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ResetApplicationRequest {
  appId?: string(name='AppId'),
  eccInfo?: string(name='EccInfo'),
}

model ResetApplicationResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ResetApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetApplicationResponseBody(name='body'),
}

async function resetApplication(request: ResetApplicationRequest): ResetApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resetApplicationWithOptions(request, headers, runtime);
}

async function resetApplicationWithOptions(request: ResetApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ResetApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.eccInfo)) {
    query['EccInfo'] = request.eccInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/co_reset`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RestartApplicationRequest {
  appId?: string(name='AppId'),
  eccInfo?: string(name='EccInfo'),
}

model RestartApplicationResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model RestartApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartApplicationResponseBody(name='body'),
}

async function restartApplication(request: RestartApplicationRequest): RestartApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartApplicationWithOptions(request, headers, runtime);
}

async function restartApplicationWithOptions(request: RestartApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.eccInfo)) {
    query['EccInfo'] = request.eccInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/co_restart`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RestartK8sApplicationRequest {
  appId?: string(name='AppId'),
  timeout?: int32(name='Timeout'),
}

model RestartK8sApplicationResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model RestartK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartK8sApplicationResponseBody(name='body'),
}

async function restartK8sApplication(request: RestartK8sApplicationRequest): RestartK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartK8sApplicationWithOptions(request, headers, runtime);
}

async function restartK8sApplicationWithOptions(request: RestartK8sApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartK8sApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartK8sApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/restart_k8s_app`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RetryChangeOrderTaskRequest {
  retryStatus?: boolean(name='RetryStatus'),
  taskId?: string(name='TaskId'),
}

model RetryChangeOrderTaskResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model RetryChangeOrderTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RetryChangeOrderTaskResponseBody(name='body'),
}

async function retryChangeOrderTask(request: RetryChangeOrderTaskRequest): RetryChangeOrderTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return retryChangeOrderTaskWithOptions(request, headers, runtime);
}

async function retryChangeOrderTaskWithOptions(request: RetryChangeOrderTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RetryChangeOrderTaskResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.retryStatus)) {
    query['RetryStatus'] = request.retryStatus;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RetryChangeOrderTask',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/task_retry`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RollbackApplicationRequest {
  appId?: string(name='AppId'),
  batch?: int32(name='Batch'),
  batchWaitTime?: int32(name='BatchWaitTime'),
  groupId?: string(name='GroupId'),
  historyVersion?: string(name='HistoryVersion'),
}

model RollbackApplicationResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model RollbackApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RollbackApplicationResponseBody(name='body'),
}

async function rollbackApplication(request: RollbackApplicationRequest): RollbackApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return rollbackApplicationWithOptions(request, headers, runtime);
}

async function rollbackApplicationWithOptions(request: RollbackApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RollbackApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.batch)) {
    query['Batch'] = request.batch;
  }
  if (!Util.isUnset(request.batchWaitTime)) {
    query['BatchWaitTime'] = request.batchWaitTime;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.historyVersion)) {
    query['HistoryVersion'] = request.historyVersion;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RollbackApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/co_rollback`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RollbackChangeOrderRequest {
  changeOrderId?: string(name='ChangeOrderId'),
}

model RollbackChangeOrderResponseBody = {
  code?: int32(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model RollbackChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RollbackChangeOrderResponseBody(name='body'),
}

async function rollbackChangeOrder(request: RollbackChangeOrderRequest): RollbackChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return rollbackChangeOrderWithOptions(request, headers, runtime);
}

async function rollbackChangeOrderWithOptions(request: RollbackChangeOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RollbackChangeOrderResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.changeOrderId)) {
    query['ChangeOrderId'] = request.changeOrderId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RollbackChangeOrder',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/oam/changeorder/rollback`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ScaleInApplicationRequest {
  appId?: string(name='AppId'),
  eccInfo?: string(name='EccInfo'),
  forceStatus?: boolean(name='ForceStatus'),
}

model ScaleInApplicationResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
}

model ScaleInApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ScaleInApplicationResponseBody(name='body'),
}

async function scaleInApplication(request: ScaleInApplicationRequest): ScaleInApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleInApplicationWithOptions(request, headers, runtime);
}

async function scaleInApplicationWithOptions(request: ScaleInApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleInApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.eccInfo)) {
    query['EccInfo'] = request.eccInfo;
  }
  if (!Util.isUnset(request.forceStatus)) {
    query['ForceStatus'] = request.forceStatus;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ScaleInApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/co_scale_in`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ScaleK8sApplicationRequest {
  appId?: string(name='AppId'),
  replicas?: int32(name='Replicas'),
  timeout?: int32(name='Timeout'),
}

model ScaleK8sApplicationResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ScaleK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ScaleK8sApplicationResponseBody(name='body'),
}

async function scaleK8sApplication(request: ScaleK8sApplicationRequest): ScaleK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleK8sApplicationWithOptions(request, headers, runtime);
}

async function scaleK8sApplicationWithOptions(request: ScaleK8sApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleK8sApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.replicas)) {
    query['Replicas'] = request.replicas;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ScaleK8sApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_apps`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ScaleOutApplicationRequest {
  appId?: string(name='AppId'),
  deployGroup?: string(name='DeployGroup'),
  ecuInfo?: string(name='EcuInfo'),
}

model ScaleOutApplicationResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ScaleOutApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ScaleOutApplicationResponseBody(name='body'),
}

async function scaleOutApplication(request: ScaleOutApplicationRequest): ScaleOutApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleOutApplicationWithOptions(request, headers, runtime);
}

async function scaleOutApplicationWithOptions(request: ScaleOutApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleOutApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.deployGroup)) {
    query['DeployGroup'] = request.deployGroup;
  }
  if (!Util.isUnset(request.ecuInfo)) {
    query['EcuInfo'] = request.ecuInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ScaleOutApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/co_scale_out`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ScaleoutApplicationWithNewInstancesRequest {
  appId?: string(name='AppId'),
  autoRenew?: boolean(name='AutoRenew'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
  clusterId?: string(name='ClusterId'),
  groupId?: string(name='GroupId'),
  instanceChargePeriod?: int32(name='InstanceChargePeriod'),
  instanceChargePeriodUnit?: string(name='InstanceChargePeriodUnit'),
  instanceChargeType?: string(name='InstanceChargeType'),
  scalingNum?: int32(name='ScalingNum'),
  scalingPolicy?: string(name='ScalingPolicy'),
  templateId?: string(name='TemplateId'),
  templateInstanceId?: string(name='TemplateInstanceId'),
  templateVersion?: string(name='TemplateVersion'),
}

model ScaleoutApplicationWithNewInstancesResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  instanceIds?: [ string ](name='InstanceIds'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ScaleoutApplicationWithNewInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ScaleoutApplicationWithNewInstancesResponseBody(name='body'),
}

async function scaleoutApplicationWithNewInstances(request: ScaleoutApplicationWithNewInstancesRequest): ScaleoutApplicationWithNewInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleoutApplicationWithNewInstancesWithOptions(request, headers, runtime);
}

async function scaleoutApplicationWithNewInstancesWithOptions(request: ScaleoutApplicationWithNewInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleoutApplicationWithNewInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.autoRenewPeriod)) {
    query['AutoRenewPeriod'] = request.autoRenewPeriod;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.instanceChargePeriod)) {
    query['InstanceChargePeriod'] = request.instanceChargePeriod;
  }
  if (!Util.isUnset(request.instanceChargePeriodUnit)) {
    query['InstanceChargePeriodUnit'] = request.instanceChargePeriodUnit;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query['InstanceChargeType'] = request.instanceChargeType;
  }
  if (!Util.isUnset(request.scalingNum)) {
    query['ScalingNum'] = request.scalingNum;
  }
  if (!Util.isUnset(request.scalingPolicy)) {
    query['ScalingPolicy'] = request.scalingPolicy;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.templateInstanceId)) {
    query['TemplateInstanceId'] = request.templateInstanceId;
  }
  if (!Util.isUnset(request.templateVersion)) {
    query['TemplateVersion'] = request.templateVersion;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ScaleoutApplicationWithNewInstances',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/scaling/scale_out`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StartApplicationRequest {
  appId?: string(name='AppId'),
  eccInfo?: string(name='EccInfo'),
}

model StartApplicationResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StartApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartApplicationResponseBody(name='body'),
}

async function startApplication(request: StartApplicationRequest): StartApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startApplicationWithOptions(request, headers, runtime);
}

async function startApplicationWithOptions(request: StartApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StartApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.eccInfo)) {
    query['EccInfo'] = request.eccInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/co_start`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StartK8sApplicationRequest {
  appId?: string(name='AppId'),
  replicas?: int32(name='Replicas'),
  timeout?: int32(name='Timeout'),
}

model StartK8sApplicationResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StartK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartK8sApplicationResponseBody(name='body'),
}

async function startK8sApplication(request: StartK8sApplicationRequest): StartK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startK8sApplicationWithOptions(request, headers, runtime);
}

async function startK8sApplicationWithOptions(request: StartK8sApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StartK8sApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.replicas)) {
    query['Replicas'] = request.replicas;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartK8sApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/start_k8s_app`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopApplicationRequest {
  appId?: string(name='AppId'),
  eccInfo?: string(name='EccInfo'),
}

model StopApplicationResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StopApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopApplicationResponseBody(name='body'),
}

async function stopApplication(request: StopApplicationRequest): StopApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopApplicationWithOptions(request, headers, runtime);
}

async function stopApplicationWithOptions(request: StopApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.eccInfo)) {
    query['EccInfo'] = request.eccInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/co_stop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopK8sApplicationRequest {
  appId?: string(name='AppId'),
  timeout?: int32(name='Timeout'),
}

model StopK8sApplicationResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StopK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopK8sApplicationResponseBody(name='body'),
}

async function stopK8sApplication(request: StopK8sApplicationRequest): StopK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopK8sApplicationWithOptions(request, headers, runtime);
}

async function stopK8sApplicationWithOptions(request: StopK8sApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopK8sApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopK8sApplication',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/stop_k8s_app`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SwitchAdvancedMonitoringRequest {
  appId?: string(name='AppId'),
  enableAdvancedMonitoring?: boolean(name='EnableAdvancedMonitoring'),
}

model SwitchAdvancedMonitoringResponseBody = {
  advancedMonitoringEnabled?: boolean(name='AdvancedMonitoringEnabled'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SwitchAdvancedMonitoringResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SwitchAdvancedMonitoringResponseBody(name='body'),
}

async function switchAdvancedMonitoring(request: SwitchAdvancedMonitoringRequest): SwitchAdvancedMonitoringResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return switchAdvancedMonitoringWithOptions(request, headers, runtime);
}

async function switchAdvancedMonitoringWithOptions(request: SwitchAdvancedMonitoringRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SwitchAdvancedMonitoringResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.enableAdvancedMonitoring)) {
    query['EnableAdvancedMonitoring'] = request.enableAdvancedMonitoring;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SwitchAdvancedMonitoring',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/monitor/advancedMonitorInfo`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SynchronizeResourceRequest {
  resourceIds?: string(name='ResourceIds'),
  type?: string(name='Type'),
}

model SynchronizeResourceResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SynchronizeResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SynchronizeResourceResponseBody(name='body'),
}

async function synchronizeResource(request: SynchronizeResourceRequest): SynchronizeResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return synchronizeResourceWithOptions(request, headers, runtime);
}

async function synchronizeResourceWithOptions(request: SynchronizeResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SynchronizeResourceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SynchronizeResource',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/pop_sync_resource`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model TagResourcesRequest {
  resourceIds?: string(name='ResourceIds'),
  resourceRegionId?: string(name='ResourceRegionId'),
  resourceType?: string(name='ResourceType'),
  tags?: string(name='Tags'),
}

model TagResourcesResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(request, headers, runtime);
}

async function tagResourcesWithOptions(request: TagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceRegionId)) {
    query['ResourceRegionId'] = request.resourceRegionId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/tag/tags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model TransformClusterMemberRequest {
  instanceIds?: string(name='InstanceIds'),
  password?: string(name='Password'),
  targetClusterId?: string(name='TargetClusterId'),
}

model TransformClusterMemberResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model TransformClusterMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransformClusterMemberResponseBody(name='body'),
}

async function transformClusterMember(request: TransformClusterMemberRequest): TransformClusterMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return transformClusterMemberWithOptions(request, headers, runtime);
}

async function transformClusterMemberWithOptions(request: TransformClusterMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TransformClusterMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.targetClusterId)) {
    query['TargetClusterId'] = request.targetClusterId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TransformClusterMember',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/resource/transform_cluster_member`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UnbindK8sSlbRequest {
  appId?: string(name='AppId'),
  clusterId?: string(name='ClusterId'),
  slbName?: string(name='SlbName'),
  type?: string(name='Type'),
}

model UnbindK8sSlbResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UnbindK8sSlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindK8sSlbResponseBody(name='body'),
}

async function unbindK8sSlb(request: UnbindK8sSlbRequest): UnbindK8sSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unbindK8sSlbWithOptions(request, headers, runtime);
}

async function unbindK8sSlbWithOptions(request: UnbindK8sSlbRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UnbindK8sSlbResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.slbName)) {
    query['SlbName'] = request.slbName;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindK8sSlb',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_slb_binding`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UnbindSlbRequest {
  appId?: string(name='AppId'),
  deleteListener?: string(name='DeleteListener'),
  slbId?: string(name='SlbId'),
  type?: string(name='Type'),
}

model UnbindSlbResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UnbindSlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindSlbResponseBody(name='body'),
}

async function unbindSlb(request: UnbindSlbRequest): UnbindSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unbindSlbWithOptions(request, headers, runtime);
}

async function unbindSlbWithOptions(request: UnbindSlbRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UnbindSlbResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.deleteListener)) {
    query['DeleteListener'] = request.deleteListener;
  }
  if (!Util.isUnset(request.slbId)) {
    query['SlbId'] = request.slbId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindSlb',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/app/unbind_slb_json`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UntagResourcesRequest {
  deleteAll?: boolean(name='DeleteAll'),
  resourceIds?: string(name='ResourceIds'),
  resourceRegionId?: string(name='ResourceRegionId'),
  resourceType?: string(name='ResourceType'),
  tagKeys?: string(name='TagKeys'),
}

model UntagResourcesResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourcesWithOptions(request, headers, runtime);
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.deleteAll)) {
    query['DeleteAll'] = request.deleteAll;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceRegionId)) {
    query['ResourceRegionId'] = request.resourceRegionId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKeys)) {
    query['TagKeys'] = request.tagKeys;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/tag/tags`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateAccountInfoRequest {
  email?: string(name='Email'),
  name?: string(name='Name'),
  telephone?: string(name='Telephone'),
}

model UpdateAccountInfoResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateAccountInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAccountInfoResponseBody(name='body'),
}

async function updateAccountInfo(request: UpdateAccountInfoRequest): UpdateAccountInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAccountInfoWithOptions(request, headers, runtime);
}

async function updateAccountInfoWithOptions(request: UpdateAccountInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAccountInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.telephone)) {
    query['Telephone'] = request.telephone;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAccountInfo',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/account/edit_account_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateApplicationBaseInfoRequest {
  appId?: string(name='AppId'),
  appName?: string(name='AppName'),
  desc?: string(name='Desc'),
  owner?: string(name='Owner'),
}

model UpdateApplicationBaseInfoResponseBody = {
  applcation?: {
    appId?: string(name='AppId'),
    applicationType?: string(name='ApplicationType'),
    buildPackageId?: long(name='BuildPackageId'),
    clusterId?: string(name='ClusterId'),
    clusterType?: int32(name='ClusterType'),
    cpu?: int32(name='Cpu'),
    createTime?: long(name='CreateTime'),
    description?: string(name='Description'),
    dockerize?: boolean(name='Dockerize'),
    extSlbId?: string(name='ExtSlbId'),
    extSlbIp?: string(name='ExtSlbIp'),
    extSlbName?: string(name='ExtSlbName'),
    healthCheckUrl?: string(name='HealthCheckUrl'),
    instanceCount?: int32(name='InstanceCount'),
    memory?: int32(name='Memory'),
    name?: string(name='Name'),
    owner?: string(name='Owner'),
    port?: int32(name='Port'),
    regionId?: string(name='RegionId'),
    runningInstanceCount?: int32(name='RunningInstanceCount'),
    slbId?: string(name='SlbId'),
    slbIp?: string(name='SlbIp'),
    slbName?: string(name='SlbName'),
    slbPort?: int32(name='SlbPort'),
    userId?: string(name='UserId'),
  }(name='Applcation'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateApplicationBaseInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateApplicationBaseInfoResponseBody(name='body'),
}

async function updateApplicationBaseInfo(request: UpdateApplicationBaseInfoRequest): UpdateApplicationBaseInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateApplicationBaseInfoWithOptions(request, headers, runtime);
}

async function updateApplicationBaseInfoWithOptions(request: UpdateApplicationBaseInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateApplicationBaseInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.owner)) {
    query['Owner'] = request.owner;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApplicationBaseInfo',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/app/update_app_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateApplicationScalingRuleRequest {
  appId?: string(name='AppId'),
  scalingRuleEnable?: boolean(name='ScalingRuleEnable'),
  scalingRuleMetric?: string(name='ScalingRuleMetric'),
  scalingRuleName?: string(name='ScalingRuleName'),
  scalingRuleTimer?: string(name='ScalingRuleTimer'),
  scalingRuleTrigger?: string(name='ScalingRuleTrigger'),
  scalingRuleType?: string(name='ScalingRuleType'),
}

model UpdateApplicationScalingRuleResponseBody = {
  appScalingRule?: {
    appId?: string(name='AppId'),
    createTime?: long(name='CreateTime'),
    lastDisableTime?: long(name='LastDisableTime'),
    maxReplicas?: int32(name='MaxReplicas'),
    metric?: {
      maxReplicas?: int32(name='MaxReplicas'),
      metrics?: [ 
        {
          metricTargetAverageUtilization?: int32(name='MetricTargetAverageUtilization'),
          metricType?: string(name='MetricType'),
        }
      ](name='Metrics'),
      minReplicas?: int32(name='MinReplicas'),
    }(name='Metric'),
    minReplicas?: int32(name='MinReplicas'),
    scaleRuleEnabled?: boolean(name='ScaleRuleEnabled'),
    scaleRuleName?: string(name='ScaleRuleName'),
    scaleRuleType?: string(name='ScaleRuleType'),
    trigger?: {
      maxReplicas?: int32(name='MaxReplicas'),
      minReplicas?: int32(name='MinReplicas'),
      triggers?: [ 
        {
          metaData?: string(name='MetaData'),
          name?: string(name='Name'),
          type?: string(name='Type'),
        }
      ](name='Triggers'),
    }(name='Trigger'),
    updateTime?: long(name='UpdateTime'),
  }(name='AppScalingRule'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateApplicationScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateApplicationScalingRuleResponseBody(name='body'),
}

async function updateApplicationScalingRule(request: UpdateApplicationScalingRuleRequest): UpdateApplicationScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateApplicationScalingRuleWithOptions(request, headers, runtime);
}

async function updateApplicationScalingRuleWithOptions(request: UpdateApplicationScalingRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateApplicationScalingRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.scalingRuleEnable)) {
    query['ScalingRuleEnable'] = request.scalingRuleEnable;
  }
  if (!Util.isUnset(request.scalingRuleMetric)) {
    query['ScalingRuleMetric'] = request.scalingRuleMetric;
  }
  if (!Util.isUnset(request.scalingRuleName)) {
    query['ScalingRuleName'] = request.scalingRuleName;
  }
  if (!Util.isUnset(request.scalingRuleTimer)) {
    query['ScalingRuleTimer'] = request.scalingRuleTimer;
  }
  if (!Util.isUnset(request.scalingRuleTrigger)) {
    query['ScalingRuleTrigger'] = request.scalingRuleTrigger;
  }
  if (!Util.isUnset(request.scalingRuleType)) {
    query['ScalingRuleType'] = request.scalingRuleType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApplicationScalingRule',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v1/eam/scale/application_scaling_rule`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateConfigTemplateRequest {
  content?: string(name='Content', description='模板内容'),
  description?: string(name='Description', description='模板描述'),
  format?: string(name='Format', description='模板数据格式'),
  id?: long(name='Id', description='配置模板ID'),
  name?: string(name='Name', description='配置模板名称'),
}

model UpdateConfigTemplateResponseBody = {
  code?: int32(name='Code', description='响应码'),
  message?: string(name='Message', description='响应码文本描述'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model UpdateConfigTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateConfigTemplateResponseBody(name='body'),
}

async function updateConfigTemplate(request: UpdateConfigTemplateRequest): UpdateConfigTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateConfigTemplateWithOptions(request, headers, runtime);
}

async function updateConfigTemplateWithOptions(request: UpdateConfigTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateConfigTemplateResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.format)) {
    body['Format'] = request.format;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConfigTemplate',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/config_template`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateContainerRequest {
  appId?: string(name='AppId'),
  buildPackId?: int32(name='BuildPackId'),
}

model UpdateContainerResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateContainerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateContainerResponseBody(name='body'),
}

async function updateContainer(request: UpdateContainerRequest): UpdateContainerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateContainerWithOptions(request, headers, runtime);
}

async function updateContainerWithOptions(request: UpdateContainerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateContainerResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.buildPackId)) {
    query['BuildPackId'] = request.buildPackId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateContainer',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/changeorder/co_update_container`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateContainerConfigurationRequest {
  appId?: string(name='AppId'),
  contextPath?: string(name='ContextPath'),
  groupId?: string(name='GroupId'),
  httpPort?: int32(name='HttpPort'),
  maxThreads?: int32(name='MaxThreads'),
  URIEncoding?: string(name='URIEncoding'),
  useBodyEncoding?: boolean(name='UseBodyEncoding'),
}

model UpdateContainerConfigurationResponseBody = {
  code?: int32(name='Code'),
  containerConfiguration?: {
    contextPath?: string(name='ContextPath'),
    httpPort?: int32(name='HttpPort'),
    maxThreads?: int32(name='MaxThreads'),
    URIEncoding?: string(name='URIEncoding'),
    useBodyEncoding?: boolean(name='UseBodyEncoding'),
  }(name='ContainerConfiguration'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateContainerConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateContainerConfigurationResponseBody(name='body'),
}

async function updateContainerConfiguration(request: UpdateContainerConfigurationRequest): UpdateContainerConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateContainerConfigurationWithOptions(request, headers, runtime);
}

async function updateContainerConfigurationWithOptions(request: UpdateContainerConfigurationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateContainerConfigurationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.contextPath)) {
    query['ContextPath'] = request.contextPath;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.httpPort)) {
    query['HttpPort'] = request.httpPort;
  }
  if (!Util.isUnset(request.maxThreads)) {
    query['MaxThreads'] = request.maxThreads;
  }
  if (!Util.isUnset(request.URIEncoding)) {
    query['URIEncoding'] = request.URIEncoding;
  }
  if (!Util.isUnset(request.useBodyEncoding)) {
    query['UseBodyEncoding'] = request.useBodyEncoding;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateContainerConfiguration',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/app/container_config`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateHealthCheckUrlRequest {
  appId?: string(name='AppId'),
  hcURL?: string(name='hcURL'),
}

model UpdateHealthCheckUrlResponseBody = {
  code?: int32(name='Code'),
  healthCheckURL?: string(name='HealthCheckURL'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateHealthCheckUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHealthCheckUrlResponseBody(name='body'),
}

async function updateHealthCheckUrl(request: UpdateHealthCheckUrlRequest): UpdateHealthCheckUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateHealthCheckUrlWithOptions(request, headers, runtime);
}

async function updateHealthCheckUrlWithOptions(request: UpdateHealthCheckUrlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateHealthCheckUrlResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.hcURL)) {
    query['hcURL'] = request.hcURL;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHealthCheckUrl',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/app/modify_hc_url`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateHookConfigurationRequest {
  appId?: string(name='AppId'),
  groupId?: string(name='GroupId'),
  hooks?: string(name='Hooks'),
}

model UpdateHookConfigurationResponseBody = {
  code?: int32(name='Code'),
  hooksConfiguration?: [ 
    {
      ignoreFail?: boolean(name='IgnoreFail'),
      name?: string(name='Name'),
      script?: string(name='Script'),
    }
  ](name='HooksConfiguration'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateHookConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHookConfigurationResponseBody(name='body'),
}

async function updateHookConfiguration(request: UpdateHookConfigurationRequest): UpdateHookConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateHookConfigurationWithOptions(request, headers, runtime);
}

async function updateHookConfigurationWithOptions(request: UpdateHookConfigurationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateHookConfigurationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.hooks)) {
    query['Hooks'] = request.hooks;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHookConfiguration',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/app/config_app_hook_json`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateJvmConfigurationRequest {
  appId?: string(name='AppId'),
  groupId?: string(name='GroupId'),
  maxHeapSize?: int32(name='MaxHeapSize'),
  maxPermSize?: int32(name='MaxPermSize'),
  minHeapSize?: int32(name='MinHeapSize'),
  options?: string(name='Options'),
}

model UpdateJvmConfigurationResponseBody = {
  code?: int32(name='Code'),
  jvmConfiguration?: {
    maxHeapSize?: int32(name='MaxHeapSize'),
    maxPermSize?: int32(name='MaxPermSize'),
    minHeapSize?: int32(name='MinHeapSize'),
    options?: string(name='Options'),
  }(name='JvmConfiguration'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateJvmConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateJvmConfigurationResponseBody(name='body'),
}

async function updateJvmConfiguration(request: UpdateJvmConfigurationRequest): UpdateJvmConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateJvmConfigurationWithOptions(request, headers, runtime);
}

async function updateJvmConfigurationWithOptions(request: UpdateJvmConfigurationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateJvmConfigurationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.maxHeapSize)) {
    query['MaxHeapSize'] = request.maxHeapSize;
  }
  if (!Util.isUnset(request.maxPermSize)) {
    query['MaxPermSize'] = request.maxPermSize;
  }
  if (!Util.isUnset(request.minHeapSize)) {
    query['MinHeapSize'] = request.minHeapSize;
  }
  if (!Util.isUnset(request.options)) {
    query['Options'] = request.options;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateJvmConfiguration',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/app/app_jvm_config`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateK8sApplicationBaseInfoRequest {
  appId?: string(name='AppId'),
  description?: string(name='Description'),
  email?: string(name='Email'),
  owner?: string(name='Owner'),
  phoneNumber?: string(name='PhoneNumber'),
}

model UpdateK8sApplicationBaseInfoResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model UpdateK8sApplicationBaseInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateK8sApplicationBaseInfoResponseBody(name='body'),
}

async function updateK8sApplicationBaseInfo(request: UpdateK8sApplicationBaseInfoRequest): UpdateK8sApplicationBaseInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateK8sApplicationBaseInfoWithOptions(request, headers, runtime);
}

async function updateK8sApplicationBaseInfoWithOptions(request: UpdateK8sApplicationBaseInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateK8sApplicationBaseInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.owner)) {
    query['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.phoneNumber)) {
    query['PhoneNumber'] = request.phoneNumber;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateK8sApplicationBaseInfo',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/oam/update_app_basic_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateK8sApplicationConfigRequest {
  appId?: string(name='AppId'),
  clusterId?: string(name='ClusterId'),
  cpuLimit?: string(name='CpuLimit'),
  cpuRequest?: string(name='CpuRequest'),
  mcpuLimit?: string(name='McpuLimit'),
  mcpuRequest?: string(name='McpuRequest'),
  memoryLimit?: string(name='MemoryLimit'),
  memoryRequest?: string(name='MemoryRequest'),
  timeout?: int32(name='Timeout'),
}

model UpdateK8sApplicationConfigResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateK8sApplicationConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateK8sApplicationConfigResponseBody(name='body'),
}

async function updateK8sApplicationConfig(request: UpdateK8sApplicationConfigRequest): UpdateK8sApplicationConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateK8sApplicationConfigWithOptions(request, headers, runtime);
}

async function updateK8sApplicationConfigWithOptions(request: UpdateK8sApplicationConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateK8sApplicationConfigResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.cpuLimit)) {
    query['CpuLimit'] = request.cpuLimit;
  }
  if (!Util.isUnset(request.cpuRequest)) {
    query['CpuRequest'] = request.cpuRequest;
  }
  if (!Util.isUnset(request.mcpuLimit)) {
    query['McpuLimit'] = request.mcpuLimit;
  }
  if (!Util.isUnset(request.mcpuRequest)) {
    query['McpuRequest'] = request.mcpuRequest;
  }
  if (!Util.isUnset(request.memoryLimit)) {
    query['MemoryLimit'] = request.memoryLimit;
  }
  if (!Util.isUnset(request.memoryRequest)) {
    query['MemoryRequest'] = request.memoryRequest;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateK8sApplicationConfig',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_app_configuration`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateK8sConfigMapRequest {
  clusterId?: string(name='ClusterId'),
  data?: map[string]any(name='Data'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
}

model UpdateK8sConfigMapResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateK8sConfigMapResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateK8sConfigMapResponseBody(name='body'),
}

async function updateK8sConfigMap(request: UpdateK8sConfigMapRequest): UpdateK8sConfigMapResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateK8sConfigMapWithOptions(request, headers, runtime);
}

async function updateK8sConfigMapWithOptions(request: UpdateK8sConfigMapRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateK8sConfigMapResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.data)) {
    body['Data'] = request.data;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateK8sConfigMap',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_config_map`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateK8sIngressRuleRequest {
  clusterId?: string(name='ClusterId'),
  ingressConf?: map[string]any(name='IngressConf'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
}

model UpdateK8sIngressRuleResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
}

model UpdateK8sIngressRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateK8sIngressRuleResponseBody(name='body'),
}

async function updateK8sIngressRule(request: UpdateK8sIngressRuleRequest): UpdateK8sIngressRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateK8sIngressRuleWithOptions(request, headers, runtime);
}

async function updateK8sIngressRuleWithOptions(request: UpdateK8sIngressRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateK8sIngressRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ingressConf)) {
    query['IngressConf'] = request.ingressConf;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateK8sIngressRule',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_ingress`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateK8sResourceRequest {
  clusterId?: string(name='ClusterId'),
  namespace?: string(name='Namespace'),
  resourceContent?: string(name='ResourceContent'),
}

model UpdateK8sResourceResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateK8sResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateK8sResourceResponseBody(name='body'),
}

async function updateK8sResource(request: UpdateK8sResourceRequest): UpdateK8sResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateK8sResourceWithOptions(request, headers, runtime);
}

async function updateK8sResourceWithOptions(request: UpdateK8sResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateK8sResourceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.resourceContent)) {
    body['ResourceContent'] = request.resourceContent;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateK8sResource',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/oam/update_k8s_resource_config`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateK8sSecretRequest {
  base64Encoded?: boolean(name='Base64Encoded'),
  certId?: string(name='CertId'),
  certRegionId?: string(name='CertRegionId'),
  clusterId?: string(name='ClusterId'),
  data?: string(name='Data'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  type?: string(name='Type'),
}

model UpdateK8sSecretResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateK8sSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateK8sSecretResponseBody(name='body'),
}

async function updateK8sSecret(request: UpdateK8sSecretRequest): UpdateK8sSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateK8sSecretWithOptions(request, headers, runtime);
}

async function updateK8sSecretWithOptions(request: UpdateK8sSecretRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateK8sSecretResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.base64Encoded)) {
    body['Base64Encoded'] = request.base64Encoded;
  }
  if (!Util.isUnset(request.certId)) {
    body['CertId'] = request.certId;
  }
  if (!Util.isUnset(request.certRegionId)) {
    body['CertRegionId'] = request.certRegionId;
  }
  if (!Util.isUnset(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.data)) {
    body['Data'] = request.data;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateK8sSecret',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_secret`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateK8sServiceRequest {
  appId?: string(name='AppId'),
  name?: string(name='Name'),
  servicePorts?: map[string]any(name='ServicePorts'),
  type?: string(name='Type'),
}

model UpdateK8sServiceResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateK8sServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateK8sServiceResponseBody(name='body'),
}

async function updateK8sService(request: UpdateK8sServiceRequest): UpdateK8sServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateK8sServiceWithOptions(request, headers, runtime);
}

async function updateK8sServiceWithOptions(request: UpdateK8sServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateK8sServiceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.servicePorts)) {
    query['ServicePorts'] = request.servicePorts;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateK8sService',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_service`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateK8sSlbRequest {
  appId?: string(name='AppId'),
  clusterId?: string(name='ClusterId'),
  disableForceOverride?: boolean(name='DisableForceOverride'),
  port?: string(name='Port'),
  scheduler?: string(name='Scheduler'),
  servicePortInfos?: string(name='ServicePortInfos'),
  slbName?: string(name='SlbName'),
  slbProtocol?: string(name='SlbProtocol'),
  specification?: string(name='Specification'),
  targetPort?: string(name='TargetPort'),
  type?: string(name='Type'),
}

model UpdateK8sSlbResponseBody = {
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateK8sSlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateK8sSlbResponseBody(name='body'),
}

async function updateK8sSlb(request: UpdateK8sSlbRequest): UpdateK8sSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateK8sSlbWithOptions(request, headers, runtime);
}

async function updateK8sSlbWithOptions(request: UpdateK8sSlbRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateK8sSlbResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.disableForceOverride)) {
    query['DisableForceOverride'] = request.disableForceOverride;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.servicePortInfos)) {
    query['ServicePortInfos'] = request.servicePortInfos;
  }
  if (!Util.isUnset(request.slbName)) {
    query['SlbName'] = request.slbName;
  }
  if (!Util.isUnset(request.slbProtocol)) {
    query['SlbProtocol'] = request.slbProtocol;
  }
  if (!Util.isUnset(request.specification)) {
    query['Specification'] = request.specification;
  }
  if (!Util.isUnset(request.targetPort)) {
    query['TargetPort'] = request.targetPort;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateK8sSlb',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/acs/k8s_slb_binding`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateMockRuleRequest {
  dubboMockItemJson?: string(name='DubboMockItemJson'),
  extraJson?: string(name='ExtraJson'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  region?: string(name='Region'),
  scMockItemJson?: string(name='ScMockItemJson'),
}

model UpdateMockRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountId?: string(name='AccountId'),
    consumerAppId?: string(name='ConsumerAppId'),
    consumerAppName?: string(name='ConsumerAppName'),
    dubboMockItemJson?: string(name='DubboMockItemJson'),
    enable?: boolean(name='Enable'),
    extraJson?: string(name='ExtraJson'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    namespaceId?: string(name='NamespaceId'),
    providerAppId?: string(name='ProviderAppId'),
    providerAppName?: string(name='ProviderAppName'),
    region?: string(name='Region'),
    scMockItemJson?: string(name='ScMockItemJson'),
    source?: string(name='Source'),
  }(name='Data'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateMockRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMockRuleResponseBody(name='body'),
}

async function updateMockRule(request: UpdateMockRuleRequest): UpdateMockRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMockRuleWithOptions(request, headers, runtime);
}

async function updateMockRuleWithOptions(request: UpdateMockRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMockRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.dubboMockItemJson)) {
    query['DubboMockItemJson'] = request.dubboMockItemJson;
  }
  if (!Util.isUnset(request.extraJson)) {
    query['ExtraJson'] = request.extraJson;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.scMockItemJson)) {
    query['ScMockItemJson'] = request.scMockItemJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMockRule',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/sp/api/mock/updateMockRule`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateRoleRequest {
  actionData?: string(name='ActionData'),
  roleId?: int32(name='RoleId'),
}

model UpdateRoleResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRoleResponseBody(name='body'),
}

async function updateRole(request: UpdateRoleRequest): UpdateRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRoleWithOptions(request, headers, runtime);
}

async function updateRoleWithOptions(request: UpdateRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRoleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.actionData)) {
    query['ActionData'] = request.actionData;
  }
  if (!Util.isUnset(request.roleId)) {
    query['RoleId'] = request.roleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRole',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/account/edit_role`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateSlsLogStoreRequest {
  appId?: string(name='AppId'),
  configs?: string(name='Configs'),
}

model UpdateSlsLogStoreResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateSlsLogStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSlsLogStoreResponseBody(name='body'),
}

async function updateSlsLogStore(request: UpdateSlsLogStoreRequest): UpdateSlsLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSlsLogStoreWithOptions(request, headers, runtime);
}

async function updateSlsLogStoreWithOptions(request: UpdateSlsLogStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSlsLogStoreResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.configs)) {
    body['Configs'] = request.configs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSlsLogStore',
    version = '2017-08-01',
    protocol = 'HTTPS',
    pathname = `/pop/v5/k8s/sls/update_sls_log_store`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

