/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  @endpointMap = {
    ap-northeast-2-pop = 'edas.ap-northeast-1.aliyuncs.com',
    ap-south-1 = 'edas.ap-northeast-1.aliyuncs.com',
    ap-southeast-3 = 'edas.ap-northeast-1.aliyuncs.com',
    ap-southeast-5 = 'edas.ap-northeast-1.aliyuncs.com',
    cn-beijing-finance-1 = 'edas.aliyuncs.com',
    cn-beijing-finance-pop = 'edas.aliyuncs.com',
    cn-beijing-gov-1 = 'edas.aliyuncs.com',
    cn-beijing-nu16-b01 = 'edas.aliyuncs.com',
    cn-chengdu = 'edas.aliyuncs.com',
    cn-edge-1 = 'edas.aliyuncs.com',
    cn-fujian = 'edas.aliyuncs.com',
    cn-haidian-cm12-c01 = 'edas.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'edas.aliyuncs.com',
    cn-hangzhou-finance = 'edas.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'edas.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'edas.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'edas.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'edas.aliyuncs.com',
    cn-hangzhou-test-306 = 'edas.aliyuncs.com',
    cn-hongkong-finance-pop = 'edas.aliyuncs.com',
    cn-huhehaote = 'edas.aliyuncs.com',
    cn-qingdao-nebula = 'edas.aliyuncs.com',
    cn-shanghai-et15-b01 = 'edas.aliyuncs.com',
    cn-shanghai-et2-b01 = 'edas.aliyuncs.com',
    cn-shanghai-finance-1 = 'edas.aliyuncs.com',
    cn-shanghai-inner = 'edas.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'edas.aliyuncs.com',
    cn-shenzhen-finance-1 = 'edas.aliyuncs.com',
    cn-shenzhen-inner = 'edas.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'edas.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'edas.aliyuncs.com',
    cn-wuhan = 'edas.aliyuncs.com',
    cn-yushanfang = 'edas.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'edas.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'edas.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'edas.aliyuncs.com',
    eu-west-1 = 'edas.ap-northeast-1.aliyuncs.com',
    eu-west-1-oxs = 'edas.ap-northeast-1.aliyuncs.com',
    me-east-1 = 'edas.ap-northeast-1.aliyuncs.com',
    rus-west-1-pop = 'edas.ap-northeast-1.aliyuncs.com',
    us-west-1 = 'edas.ap-northeast-1.aliyuncs.com',
  };
  checkConfig(config);
  @endpoint = getEndpoint('edas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AbortAndRollbackChangeOrderRequest {
  changeOrderId?: string(name='ChangeOrderId'),
}

model AbortAndRollbackChangeOrderResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  code?: int32(name='Code'),
}

model AbortAndRollbackChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  body: AbortAndRollbackChangeOrderResponseBody(name='body'),
}

async function abortAndRollbackChangeOrder(request: AbortAndRollbackChangeOrderRequest): AbortAndRollbackChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return abortAndRollbackChangeOrderWithOptions(request, headers, runtime);
}

async function abortAndRollbackChangeOrderWithOptions(request: AbortAndRollbackChangeOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AbortAndRollbackChangeOrderResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.changeOrderId)) {
    query.ChangeOrderId = request.changeOrderId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('AbortAndRollbackChangeOrder', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/changeorder/change_order_abort_and_rollback`, 'json', req, runtime);
}

model AbortChangeOrderRequest {
  changeOrderId?: string(name='ChangeOrderId'),
}

model AbortChangeOrderResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  code?: int32(name='Code'),
}

model AbortChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  body: AbortChangeOrderResponseBody(name='body'),
}

async function abortChangeOrder(request: AbortChangeOrderRequest): AbortChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return abortChangeOrderWithOptions(request, headers, runtime);
}

async function abortChangeOrderWithOptions(request: AbortChangeOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AbortChangeOrderResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.changeOrderId)) {
    query.ChangeOrderId = request.changeOrderId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('AbortChangeOrder', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/changeorder/change_order_abort`, 'json', req, runtime);
}

model AddLogPathRequest {
  appId?: string(name='AppId'),
  path?: string(name='Path'),
}

model AddLogPathResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model AddLogPathResponse = {
  headers: map[string]string(name='headers'),
  body: AddLogPathResponseBody(name='body'),
}

async function addLogPath(request: AddLogPathRequest): AddLogPathResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addLogPathWithOptions(request, headers, runtime);
}

async function addLogPathWithOptions(request: AddLogPathRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddLogPathResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    body.AppId = request.appId;
  }
  if (!Util.isUnset(request.path)) {
    body.Path = request.path;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequestWithForm('AddLogPath', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/log/popListLogDirs`, 'json', req, runtime);
}

model AddMockRuleRequest {
  name?: string(name='Name'),
  region?: string(name='Region'),
  source?: string(name='Source'),
  providerAppId?: string(name='ProviderAppId'),
  providerAppName?: string(name='ProviderAppName'),
  extraJson?: string(name='ExtraJson'),
  scMockItemJson?: string(name='ScMockItemJson'),
  dubboMockItemJson?: string(name='DubboMockItemJson'),
  consumerAppsJson?: string(name='ConsumerAppsJson'),
  enable?: boolean(name='Enable'),
  namespace?: string(name='Namespace'),
}

model AddMockRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    namespaceId?: string(name='NamespaceId'),
    scMockItemJson?: string(name='ScMockItemJson'),
    consumerAppName?: string(name='ConsumerAppName'),
    consumerAppId?: string(name='ConsumerAppId'),
    accountId?: string(name='AccountId'),
    extraJson?: string(name='ExtraJson'),
    source?: string(name='Source'),
    region?: string(name='Region'),
    providerAppId?: string(name='ProviderAppId'),
    providerAppName?: string(name='ProviderAppName'),
    name?: string(name='Name'),
    id?: long(name='Id'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model AddMockRuleResponse = {
  headers: map[string]string(name='headers'),
  body: AddMockRuleResponseBody(name='body'),
}

async function addMockRule(request: AddMockRuleRequest): AddMockRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addMockRuleWithOptions(request, headers, runtime);
}

async function addMockRuleWithOptions(request: AddMockRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddMockRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }
  if (!Util.isUnset(request.region)) {
    query.Region = request.region;
  }
  if (!Util.isUnset(request.source)) {
    query.Source = request.source;
  }
  if (!Util.isUnset(request.providerAppId)) {
    query.ProviderAppId = request.providerAppId;
  }
  if (!Util.isUnset(request.providerAppName)) {
    query.ProviderAppName = request.providerAppName;
  }
  if (!Util.isUnset(request.extraJson)) {
    query.ExtraJson = request.extraJson;
  }
  if (!Util.isUnset(request.scMockItemJson)) {
    query.ScMockItemJson = request.scMockItemJson;
  }
  if (!Util.isUnset(request.dubboMockItemJson)) {
    query.DubboMockItemJson = request.dubboMockItemJson;
  }
  if (!Util.isUnset(request.consumerAppsJson)) {
    query.ConsumerAppsJson = request.consumerAppsJson;
  }
  if (!Util.isUnset(request.enable)) {
    query.Enable = request.enable;
  }
  if (!Util.isUnset(request.namespace)) {
    query.Namespace = request.namespace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('AddMockRule', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/mock/addMockRule`, 'json', req, runtime);
}

model AddServiceTimeConfigRequest {
  region?: string(name='Region'),
  serviceType?: string(name='ServiceType'),
  appId?: string(name='AppId'),
  serviceName?: string(name='ServiceName'),
  serviceVersion?: string(name='ServiceVersion'),
  serviceGroup?: string(name='ServiceGroup'),
  path?: string(name='Path'),
  consumerAppName?: string(name='ConsumerAppName'),
  consumerAppId?: string(name='ConsumerAppId'),
  timeout?: string(name='Timeout'),
  namespace?: string(name='Namespace'),
  source?: string(name='Source'),
}

model AddServiceTimeConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    timeout?: string(name='Timeout'),
    consumerAppName?: string(name='ConsumerAppName'),
    path?: string(name='Path'),
    consumerAppId?: string(name='ConsumerAppId'),
    id?: long(name='Id'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model AddServiceTimeConfigResponse = {
  headers: map[string]string(name='headers'),
  body: AddServiceTimeConfigResponseBody(name='body'),
}

async function addServiceTimeConfig(request: AddServiceTimeConfigRequest): AddServiceTimeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addServiceTimeConfigWithOptions(request, headers, runtime);
}

async function addServiceTimeConfigWithOptions(request: AddServiceTimeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddServiceTimeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.region)) {
    query.Region = request.region;
  }
  if (!Util.isUnset(request.serviceType)) {
    query.ServiceType = request.serviceType;
  }
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query.ServiceName = request.serviceName;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query.ServiceVersion = request.serviceVersion;
  }
  if (!Util.isUnset(request.serviceGroup)) {
    query.ServiceGroup = request.serviceGroup;
  }
  if (!Util.isUnset(request.path)) {
    query.Path = request.path;
  }
  if (!Util.isUnset(request.consumerAppName)) {
    query.ConsumerAppName = request.consumerAppName;
  }
  if (!Util.isUnset(request.consumerAppId)) {
    query.ConsumerAppId = request.consumerAppId;
  }
  if (!Util.isUnset(request.timeout)) {
    query.Timeout = request.timeout;
  }
  if (!Util.isUnset(request.namespace)) {
    query.Namespace = request.namespace;
  }
  if (!Util.isUnset(request.source)) {
    query.Source = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('AddServiceTimeConfig', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/timeout/add`, 'json', req, runtime);
}

model AuthorizeApplicationRequest {
  targetUserId?: string(name='TargetUserId'),
  appIds?: string(name='AppIds'),
}

model AuthorizeApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model AuthorizeApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeApplicationResponseBody(name='body'),
}

async function authorizeApplication(request: AuthorizeApplicationRequest): AuthorizeApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return authorizeApplicationWithOptions(request, headers, runtime);
}

async function authorizeApplicationWithOptions(request: AuthorizeApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AuthorizeApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.targetUserId)) {
    query.TargetUserId = request.targetUserId;
  }
  if (!Util.isUnset(request.appIds)) {
    query.AppIds = request.appIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('AuthorizeApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/authorize_app`, 'json', req, runtime);
}

model AuthorizeResourceGroupRequest {
  targetUserId?: string(name='TargetUserId'),
  resourceGroupIds?: string(name='ResourceGroupIds'),
}

model AuthorizeResourceGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model AuthorizeResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeResourceGroupResponseBody(name='body'),
}

async function authorizeResourceGroup(request: AuthorizeResourceGroupRequest): AuthorizeResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return authorizeResourceGroupWithOptions(request, headers, runtime);
}

async function authorizeResourceGroupWithOptions(request: AuthorizeResourceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AuthorizeResourceGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.targetUserId)) {
    query.TargetUserId = request.targetUserId;
  }
  if (!Util.isUnset(request.resourceGroupIds)) {
    query.ResourceGroupIds = request.resourceGroupIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('AuthorizeResourceGroup', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/authorize_res_group`, 'json', req, runtime);
}

model AuthorizeRoleRequest {
  targetUserId?: string(name='TargetUserId'),
  roleIds?: string(name='RoleIds'),
}

model AuthorizeRoleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model AuthorizeRoleResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeRoleResponseBody(name='body'),
}

async function authorizeRole(request: AuthorizeRoleRequest): AuthorizeRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return authorizeRoleWithOptions(request, headers, runtime);
}

async function authorizeRoleWithOptions(request: AuthorizeRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AuthorizeRoleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.targetUserId)) {
    query.TargetUserId = request.targetUserId;
  }
  if (!Util.isUnset(request.roleIds)) {
    query.RoleIds = request.roleIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('AuthorizeRole', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/authorize_role`, 'json', req, runtime);
}

model BindEcsSlbRequest {
  appId?: string(name='AppId'),
  slbId?: string(name='SlbId'),
  listenerPort?: int32(name='ListenerPort'),
  VServerGroupId?: string(name='VServerGroupId'),
  listenerProtocol?: string(name='ListenerProtocol'),
  deployGroupId?: string(name='DeployGroupId'),
  VServerGroupName?: string(name='VServerGroupName'),
  listenerHealthCheckUrl?: string(name='ListenerHealthCheckUrl'),
  VForwardingUrlRule?: string(name='VForwardingUrlRule'),
}

model BindEcsSlbResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model BindEcsSlbResponse = {
  headers: map[string]string(name='headers'),
  body: BindEcsSlbResponseBody(name='body'),
}

async function bindEcsSlb(request: BindEcsSlbRequest): BindEcsSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return bindEcsSlbWithOptions(request, headers, runtime);
}

async function bindEcsSlbWithOptions(request: BindEcsSlbRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BindEcsSlbResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.slbId)) {
    query.SlbId = request.slbId;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query.ListenerPort = request.listenerPort;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query.VServerGroupId = request.VServerGroupId;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query.ListenerProtocol = request.listenerProtocol;
  }
  if (!Util.isUnset(request.deployGroupId)) {
    query.DeployGroupId = request.deployGroupId;
  }
  if (!Util.isUnset(request.VServerGroupName)) {
    query.VServerGroupName = request.VServerGroupName;
  }
  if (!Util.isUnset(request.listenerHealthCheckUrl)) {
    query.ListenerHealthCheckUrl = request.listenerHealthCheckUrl;
  }
  if (!Util.isUnset(request.VForwardingUrlRule)) {
    query.VForwardingUrlRule = request.VForwardingUrlRule;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('BindEcsSlb', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/slb/bind_slb`, 'json', req, runtime);
}

model BindK8sSlbRequest {
  appId?: string(name='AppId'),
  clusterId?: string(name='ClusterId'),
  type?: string(name='Type'),
  slbId?: string(name='SlbId'),
  slbProtocol?: string(name='SlbProtocol'),
  targetPort?: string(name='TargetPort'),
  port?: string(name='Port'),
  servicePortInfos?: string(name='ServicePortInfos'),
  specification?: string(name='Specification'),
  scheduler?: string(name='Scheduler'),
}

model BindK8sSlbResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model BindK8sSlbResponse = {
  headers: map[string]string(name='headers'),
  body: BindK8sSlbResponseBody(name='body'),
}

async function bindK8sSlb(request: BindK8sSlbRequest): BindK8sSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return bindK8sSlbWithOptions(request, headers, runtime);
}

async function bindK8sSlbWithOptions(request: BindK8sSlbRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BindK8sSlbResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.type)) {
    query.Type = request.type;
  }
  if (!Util.isUnset(request.slbId)) {
    query.SlbId = request.slbId;
  }
  if (!Util.isUnset(request.slbProtocol)) {
    query.SlbProtocol = request.slbProtocol;
  }
  if (!Util.isUnset(request.targetPort)) {
    query.TargetPort = request.targetPort;
  }
  if (!Util.isUnset(request.port)) {
    query.Port = request.port;
  }
  if (!Util.isUnset(request.servicePortInfos)) {
    query.ServicePortInfos = request.servicePortInfos;
  }
  if (!Util.isUnset(request.specification)) {
    query.Specification = request.specification;
  }
  if (!Util.isUnset(request.scheduler)) {
    query.Scheduler = request.scheduler;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('BindK8sSlb', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s/acs/k8s_slb_binding`, 'json', req, runtime);
}

model BindSlbRequest {
  appId?: string(name='AppId'),
  slbId?: string(name='SlbId'),
  slbIp?: string(name='SlbIp'),
  type?: string(name='Type'),
  listenerPort?: int32(name='ListenerPort'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model BindSlbResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    VServerGroupId?: string(name='VServerGroupId'),
    slbId?: string(name='SlbId'),
    extSlbIp?: string(name='ExtSlbIp'),
    slbPort?: int32(name='SlbPort'),
    extSlbName?: string(name='ExtSlbName'),
    extSlbId?: string(name='ExtSlbId'),
    extVServerGroupId?: string(name='ExtVServerGroupId'),
    slbName?: string(name='SlbName'),
    slbIp?: string(name='SlbIp'),
  }(name='Data'),
  code?: int32(name='Code'),
}

model BindSlbResponse = {
  headers: map[string]string(name='headers'),
  body: BindSlbResponseBody(name='body'),
}

async function bindSlb(request: BindSlbRequest): BindSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return bindSlbWithOptions(request, headers, runtime);
}

async function bindSlbWithOptions(request: BindSlbRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BindSlbResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.slbId)) {
    query.SlbId = request.slbId;
  }
  if (!Util.isUnset(request.slbIp)) {
    query.SlbIp = request.slbIp;
  }
  if (!Util.isUnset(request.type)) {
    query.Type = request.type;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query.ListenerPort = request.listenerPort;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query.VServerGroupId = request.VServerGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('BindSlb', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/app/bind_slb_json`, 'json', req, runtime);
}

model ChangeDeployGroupRequest {
  appId?: string(name='AppId'),
  eccInfo?: string(name='EccInfo'),
  groupName?: string(name='GroupName'),
  forceStatus?: boolean(name='ForceStatus'),
}

model ChangeDeployGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model ChangeDeployGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ChangeDeployGroupResponseBody(name='body'),
}

async function changeDeployGroup(request: ChangeDeployGroupRequest): ChangeDeployGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return changeDeployGroupWithOptions(request, headers, runtime);
}

async function changeDeployGroupWithOptions(request: ChangeDeployGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ChangeDeployGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.eccInfo)) {
    query.EccInfo = request.eccInfo;
  }
  if (!Util.isUnset(request.groupName)) {
    query.GroupName = request.groupName;
  }
  if (!Util.isUnset(request.forceStatus)) {
    query.ForceStatus = request.forceStatus;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ChangeDeployGroup', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_change_group`, 'json', req, runtime);
}

model ContinuePipelineRequest {
  pipelineId?: string(name='PipelineId'),
  confirm?: boolean(name='Confirm'),
}

model ContinuePipelineResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model ContinuePipelineResponse = {
  headers: map[string]string(name='headers'),
  body: ContinuePipelineResponseBody(name='body'),
}

async function continuePipeline(request: ContinuePipelineRequest): ContinuePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return continuePipelineWithOptions(request, headers, runtime);
}

async function continuePipelineWithOptions(request: ContinuePipelineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ContinuePipelineResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pipelineId)) {
    query.PipelineId = request.pipelineId;
  }
  if (!Util.isUnset(request.confirm)) {
    query.Confirm = request.confirm;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ContinuePipeline', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/changeorder/pipeline_batch_confirm`, 'json', req, runtime);
}

model ConvertK8sResourceRequest {
  resourceType?: string(name='ResourceType'),
  resourceName?: string(name='ResourceName'),
  namespace?: string(name='Namespace'),
  clusterId?: string(name='ClusterId'),
}

model ConvertK8sResourceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model ConvertK8sResourceResponse = {
  headers: map[string]string(name='headers'),
  body: ConvertK8sResourceResponseBody(name='body'),
}

async function convertK8sResource(request: ConvertK8sResourceRequest): ConvertK8sResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return convertK8sResourceWithOptions(request, headers, runtime);
}

async function convertK8sResourceWithOptions(request: ConvertK8sResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ConvertK8sResourceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.resourceType)) {
    query.ResourceType = request.resourceType;
  }
  if (!Util.isUnset(request.resourceName)) {
    query.ResourceName = request.resourceName;
  }
  if (!Util.isUnset(request.namespace)) {
    query.Namespace = request.namespace;
  }
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ConvertK8sResource', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/oam/k8s_resource_convert`, 'json', req, runtime);
}

model CreateIDCImportCommandRequest {
  clusterId?: string(name='ClusterId'),
}

model CreateIDCImportCommandResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
}

model CreateIDCImportCommandResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIDCImportCommandResponseBody(name='body'),
}

async function createIDCImportCommand(request: CreateIDCImportCommandRequest): CreateIDCImportCommandResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIDCImportCommandWithOptions(request, headers, runtime);
}

async function createIDCImportCommandWithOptions(request: CreateIDCImportCommandRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIDCImportCommandResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    body.ClusterId = request.clusterId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequestWithForm('CreateIDCImportCommand', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/create_idc_import_command`, 'json', req, runtime);
}

model CreateK8sIngressRuleRequest {
  clusterId?: string(name='ClusterId'),
  namespace?: string(name='Namespace'),
  name?: string(name='Name'),
  rules?: string(name='Rules'),
}

model CreateK8sIngressRuleResponseBody = {
  message?: string(name='Message'),
  changeOrderIds?: [ 
    {
      changeOrderId?: string(name='ChangeOrderId'),
      appId?: string(name='AppId'),
    }
  ](name='ChangeOrderIds'),
  code?: int32(name='Code'),
}

model CreateK8sIngressRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateK8sIngressRuleResponseBody(name='body'),
}

async function createK8sIngressRule(request: CreateK8sIngressRuleRequest): CreateK8sIngressRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createK8sIngressRuleWithOptions(request, headers, runtime);
}

async function createK8sIngressRuleWithOptions(request: CreateK8sIngressRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateK8sIngressRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.namespace)) {
    query.Namespace = request.namespace;
  }
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }
  if (!Util.isUnset(request.rules)) {
    query.Rules = request.rules;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateK8sIngressRule', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s/acs/k8s_ingress`, 'json', req, runtime);
}

model CreateK8sServiceRequest {
  appId?: string(name='AppId'),
  name?: string(name='Name'),
  type?: string(name='Type'),
  servicePorts?: string(name='ServicePorts'),
}

model CreateK8sServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model CreateK8sServiceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateK8sServiceResponseBody(name='body'),
}

async function createK8sService(request: CreateK8sServiceRequest): CreateK8sServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createK8sServiceWithOptions(request, headers, runtime);
}

async function createK8sServiceWithOptions(request: CreateK8sServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateK8sServiceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }
  if (!Util.isUnset(request.type)) {
    query.Type = request.type;
  }
  if (!Util.isUnset(request.servicePorts)) {
    query.ServicePorts = request.servicePorts;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateK8sService', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s/acs/k8s_service`, 'json', req, runtime);
}

model DelegateAdminRoleRequest {
  targetUserId?: string(name='TargetUserId'),
}

model DelegateAdminRoleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model DelegateAdminRoleResponse = {
  headers: map[string]string(name='headers'),
  body: DelegateAdminRoleResponseBody(name='body'),
}

async function delegateAdminRole(request: DelegateAdminRoleRequest): DelegateAdminRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return delegateAdminRoleWithOptions(request, headers, runtime);
}

async function delegateAdminRoleWithOptions(request: DelegateAdminRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DelegateAdminRoleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.targetUserId)) {
    query.TargetUserId = request.targetUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DelegateAdminRole', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/account/delegate_admin_role`, 'json', req, runtime);
}

model DeleteApplicationRequest {
  appId?: string(name='AppId'),
}

model DeleteApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model DeleteApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteApplicationResponseBody(name='body'),
}

async function deleteApplication(request: DeleteApplicationRequest): DeleteApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteApplicationWithOptions(request, headers, runtime);
}

async function deleteApplicationWithOptions(request: DeleteApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteApplication', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/changeorder/co_delete_app`, 'json', req, runtime);
}

model DeleteClusterRequest {
  clusterId?: string(name='ClusterId'),
  mode?: int32(name='Mode'),
}

model DeleteClusterResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
  code?: int32(name='Code'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterResponseBody(name='body'),
}

async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteClusterWithOptions(request, headers, runtime);
}

async function deleteClusterWithOptions(request: DeleteClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.mode)) {
    query.Mode = request.mode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteCluster', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/resource/cluster`, 'json', req, runtime);
}

model DeleteClusterMemberRequest {
  clusterId?: string(name='ClusterId'),
  clusterMemberId?: string(name='ClusterMemberId'),
}

model DeleteClusterMemberResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
  code?: int32(name='Code'),
}

model DeleteClusterMemberResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterMemberResponseBody(name='body'),
}

async function deleteClusterMember(request: DeleteClusterMemberRequest): DeleteClusterMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteClusterMemberWithOptions(request, headers, runtime);
}

async function deleteClusterMemberWithOptions(request: DeleteClusterMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteClusterMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.clusterMemberId)) {
    query.ClusterMemberId = request.clusterMemberId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteClusterMember', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/resource/cluster_member`, 'json', req, runtime);
}

model DeleteConfigCenterRequest {
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  logicalRegionId?: string(name='LogicalRegionId'),
}

model DeleteConfigCenterResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model DeleteConfigCenterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteConfigCenterResponseBody(name='body'),
}

async function deleteConfigCenter(request: DeleteConfigCenterRequest): DeleteConfigCenterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConfigCenterWithOptions(request, headers, runtime);
}

async function deleteConfigCenterWithOptions(request: DeleteConfigCenterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConfigCenterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.dataId)) {
    query.DataId = request.dataId;
  }
  if (!Util.isUnset(request.group)) {
    query.Group = request.group;
  }
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteConfigCenter', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/configCenter`, 'json', req, runtime);
}

model DeleteDegradeControlRequest {
  appId?: string(name='AppId'),
  ruleId?: string(name='RuleId'),
}

model DeleteDegradeControlResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model DeleteDegradeControlResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDegradeControlResponseBody(name='body'),
}

async function deleteDegradeControl(request: DeleteDegradeControlRequest): DeleteDegradeControlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDegradeControlWithOptions(request, headers, runtime);
}

async function deleteDegradeControlWithOptions(request: DeleteDegradeControlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDegradeControlResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query.RuleId = request.ruleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteDegradeControl', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/degradeControl`, 'json', req, runtime);
}

model DeleteDeployGroupRequest {
  appId?: string(name='AppId'),
  groupName?: string(name='GroupName'),
}

model DeleteDeployGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: int32(name='Code'),
}

model DeleteDeployGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDeployGroupResponseBody(name='body'),
}

async function deleteDeployGroup(request: DeleteDeployGroupRequest): DeleteDeployGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDeployGroupWithOptions(request, headers, runtime);
}

async function deleteDeployGroupWithOptions(request: DeleteDeployGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDeployGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.groupName)) {
    query.GroupName = request.groupName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteDeployGroup', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/deploy_group`, 'json', req, runtime);
}

model DeleteEcuRequest {
  ecuId?: string(name='EcuId'),
}

model DeleteEcuResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: int32(name='Code'),
}

model DeleteEcuResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEcuResponseBody(name='body'),
}

async function deleteEcu(request: DeleteEcuRequest): DeleteEcuResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEcuWithOptions(request, headers, runtime);
}

async function deleteEcuWithOptions(request: DeleteEcuRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteEcuResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.ecuId)) {
    query.EcuId = request.ecuId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteEcu', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/delete_ecu`, 'json', req, runtime);
}

model DeleteFlowControlRequest {
  appId?: string(name='AppId'),
  ruleId?: string(name='RuleId'),
}

model DeleteFlowControlResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model DeleteFlowControlResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowControlResponseBody(name='body'),
}

async function deleteFlowControl(request: DeleteFlowControlRequest): DeleteFlowControlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFlowControlWithOptions(request, headers, runtime);
}

async function deleteFlowControlWithOptions(request: DeleteFlowControlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFlowControlResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query.RuleId = request.ruleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteFlowControl', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/flowControl`, 'json', req, runtime);
}

model DeleteK8sApplicationRequest {
  appId?: string(name='AppId'),
}

model DeleteK8sApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model DeleteK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteK8sApplicationResponseBody(name='body'),
}

async function deleteK8sApplication(request: DeleteK8sApplicationRequest): DeleteK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteK8sApplicationWithOptions(request, headers, runtime);
}

async function deleteK8sApplicationWithOptions(request: DeleteK8sApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteK8sApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteK8sApplication', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/k8s/acs/k8s_apps`, 'json', req, runtime);
}

model DeleteK8sIngressRuleRequest {
  clusterId?: string(name='ClusterId'),
  namespace?: string(name='Namespace'),
  name?: string(name='Name'),
}

model DeleteK8sIngressRuleResponseBody = {
  message?: string(name='Message'),
  changeOrderIds?: [ 
    {
      changeOrderId?: string(name='ChangeOrderId'),
      appId?: string(name='AppId'),
    }
  ](name='ChangeOrderIds'),
  code?: int32(name='Code'),
}

model DeleteK8sIngressRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteK8sIngressRuleResponseBody(name='body'),
}

async function deleteK8sIngressRule(request: DeleteK8sIngressRuleRequest): DeleteK8sIngressRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteK8sIngressRuleWithOptions(request, headers, runtime);
}

async function deleteK8sIngressRuleWithOptions(request: DeleteK8sIngressRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteK8sIngressRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.namespace)) {
    query.Namespace = request.namespace;
  }
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteK8sIngressRule', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/k8s/acs/k8s_ingress`, 'json', req, runtime);
}

model DeleteK8sServiceRequest {
  appId?: string(name='AppId'),
  name?: string(name='Name'),
}

model DeleteK8sServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model DeleteK8sServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteK8sServiceResponseBody(name='body'),
}

async function deleteK8sService(request: DeleteK8sServiceRequest): DeleteK8sServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteK8sServiceWithOptions(request, headers, runtime);
}

async function deleteK8sServiceWithOptions(request: DeleteK8sServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteK8sServiceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteK8sService', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/k8s/acs/k8s_service`, 'json', req, runtime);
}

model DeleteLogPathRequest {
  appId?: string(name='AppId'),
  path?: string(name='Path'),
}

model DeleteLogPathResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model DeleteLogPathResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLogPathResponseBody(name='body'),
}

async function deleteLogPath(request: DeleteLogPathRequest): DeleteLogPathResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLogPathWithOptions(request, headers, runtime);
}

async function deleteLogPathWithOptions(request: DeleteLogPathRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLogPathResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.path)) {
    query.Path = request.path;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteLogPath', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/log/popListLogDirs`, 'json', req, runtime);
}

model DeleteRoleRequest {
  roleId?: int32(name='RoleId'),
}

model DeleteRoleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model DeleteRoleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRoleResponseBody(name='body'),
}

async function deleteRole(request: DeleteRoleRequest): DeleteRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRoleWithOptions(request, headers, runtime);
}

async function deleteRoleWithOptions(request: DeleteRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRoleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.roleId)) {
    query.RoleId = request.roleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteRole', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/delete_role`, 'json', req, runtime);
}

model DeleteServiceGroupRequest {
  groupId?: string(name='GroupId'),
}

model DeleteServiceGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model DeleteServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteServiceGroupResponseBody(name='body'),
}

async function deleteServiceGroup(request: DeleteServiceGroupRequest): DeleteServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceGroupWithOptions(request, headers, runtime);
}

async function deleteServiceGroupWithOptions(request: DeleteServiceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteServiceGroup', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/service/serviceGroups`, 'json', req, runtime);
}

model DeleteServiceTimeConfigRequest {
  id?: string(name='Id'),
}

model DeleteServiceTimeConfigResponseBody = {
  message?: string(name='Message'),
  data?: {
    timeout?: string(name='Timeout'),
    consumerAppName?: string(name='ConsumerAppName'),
    path?: string(name='Path'),
    consumerAppId?: string(name='ConsumerAppId'),
    id?: long(name='Id'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteServiceTimeConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteServiceTimeConfigResponseBody(name='body'),
}

async function deleteServiceTimeConfig(request: DeleteServiceTimeConfigRequest): DeleteServiceTimeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceTimeConfigWithOptions(request, headers, runtime);
}

async function deleteServiceTimeConfigWithOptions(request: DeleteServiceTimeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceTimeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.id)) {
    query.Id = request.id;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteServiceTimeConfig', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/timeout/remove`, 'json', req, runtime);
}

model DeleteSwimmingLaneRequest {
  laneId?: long(name='LaneId'),
}

model DeleteSwimmingLaneResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: int32(name='Data'),
  code?: int32(name='Code'),
}

model DeleteSwimmingLaneResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSwimmingLaneResponseBody(name='body'),
}

async function deleteSwimmingLane(request: DeleteSwimmingLaneRequest): DeleteSwimmingLaneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSwimmingLaneWithOptions(request, headers, runtime);
}

async function deleteSwimmingLaneWithOptions(request: DeleteSwimmingLaneRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSwimmingLaneResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.laneId)) {
    query.LaneId = request.laneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteSwimmingLane', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/trafficmgnt/swimming_lanes`, 'json', req, runtime);
}

model DeleteSwimmingLaneGroupRequest {
  groupId?: long(name='GroupId'),
}

model DeleteSwimmingLaneGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: int32(name='Data'),
  code?: int32(name='Code'),
}

model DeleteSwimmingLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSwimmingLaneGroupResponseBody(name='body'),
}

async function deleteSwimmingLaneGroup(request: DeleteSwimmingLaneGroupRequest): DeleteSwimmingLaneGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSwimmingLaneGroupWithOptions(request, headers, runtime);
}

async function deleteSwimmingLaneGroupWithOptions(request: DeleteSwimmingLaneGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSwimmingLaneGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteSwimmingLaneGroup', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/trafficmgnt/swimming_lane_groups`, 'json', req, runtime);
}

model DeleteUserDefineRegionRequest {
  id?: long(name='Id'),
  regionTag?: string(name='RegionTag'),
}

model DeleteUserDefineRegionResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  regionDefine?: {
    belongRegion?: string(name='BelongRegion'),
    regionName?: string(name='RegionName'),
    description?: string(name='Description'),
    userId?: string(name='UserId'),
    id?: long(name='Id'),
    regionId?: string(name='RegionId'),
  }(name='RegionDefine'),
  code?: int32(name='Code'),
}

model DeleteUserDefineRegionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserDefineRegionResponseBody(name='body'),
}

async function deleteUserDefineRegion(request: DeleteUserDefineRegionRequest): DeleteUserDefineRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteUserDefineRegionWithOptions(request, headers, runtime);
}

async function deleteUserDefineRegionWithOptions(request: DeleteUserDefineRegionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteUserDefineRegionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.id)) {
    query.Id = request.id;
  }
  if (!Util.isUnset(request.regionTag)) {
    query.RegionTag = request.regionTag;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteUserDefineRegion', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/user_region_def`, 'json', req, runtime);
}

model DeployApplicationRequest {
  appId?: string(name='AppId'),
  packageVersion?: string(name='PackageVersion'),
  desc?: string(name='Desc'),
  deployType?: string(name='DeployType'),
  warUrl?: string(name='WarUrl'),
  imageUrl?: string(name='ImageUrl'),
  groupId?: string(name='GroupId'),
  batch?: int32(name='Batch'),
  batchWaitTime?: int32(name='BatchWaitTime'),
  appEnv?: string(name='AppEnv'),
  buildPackId?: long(name='BuildPackId'),
  componentIds?: string(name='ComponentIds'),
  releaseType?: long(name='ReleaseType'),
  gray?: boolean(name='Gray'),
  trafficControlStrategy?: string(name='TrafficControlStrategy'),
}

model DeployApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model DeployApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeployApplicationResponseBody(name='body'),
}

async function deployApplication(request: DeployApplicationRequest): DeployApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deployApplicationWithOptions(request, headers, runtime);
}

async function deployApplicationWithOptions(request: DeployApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeployApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.packageVersion)) {
    query.PackageVersion = request.packageVersion;
  }
  if (!Util.isUnset(request.desc)) {
    query.Desc = request.desc;
  }
  if (!Util.isUnset(request.deployType)) {
    query.DeployType = request.deployType;
  }
  if (!Util.isUnset(request.warUrl)) {
    query.WarUrl = request.warUrl;
  }
  if (!Util.isUnset(request.imageUrl)) {
    query.ImageUrl = request.imageUrl;
  }
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }
  if (!Util.isUnset(request.batch)) {
    query.Batch = request.batch;
  }
  if (!Util.isUnset(request.batchWaitTime)) {
    query.BatchWaitTime = request.batchWaitTime;
  }
  if (!Util.isUnset(request.appEnv)) {
    query.AppEnv = request.appEnv;
  }
  if (!Util.isUnset(request.buildPackId)) {
    query.BuildPackId = request.buildPackId;
  }
  if (!Util.isUnset(request.componentIds)) {
    query.ComponentIds = request.componentIds;
  }
  if (!Util.isUnset(request.releaseType)) {
    query.ReleaseType = request.releaseType;
  }
  if (!Util.isUnset(request.gray)) {
    query.Gray = request.gray;
  }
  if (!Util.isUnset(request.trafficControlStrategy)) {
    query.TrafficControlStrategy = request.trafficControlStrategy;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeployApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_deploy`, 'json', req, runtime);
}

model DeployK8sApplicationRequest {
  preStop?: string(name='PreStop'),
  envs?: string(name='Envs'),
  imageTag?: string(name='ImageTag'),
  batchWaitTime?: int32(name='BatchWaitTime'),
  command?: string(name='Command'),
  appId?: string(name='AppId'),
  postStart?: string(name='PostStart'),
  readiness?: string(name='Readiness'),
  liveness?: string(name='Liveness'),
  args?: string(name='Args'),
  replicas?: int32(name='Replicas'),
  image?: string(name='Image'),
  cpuLimit?: int32(name='CpuLimit'),
  memoryLimit?: int32(name='MemoryLimit'),
  cpuRequest?: int32(name='CpuRequest'),
  memoryRequest?: int32(name='MemoryRequest'),
  nasId?: string(name='NasId'),
  mountDescs?: string(name='MountDescs'),
  storageType?: string(name='StorageType'),
  localVolume?: string(name='LocalVolume'),
  packageUrl?: string(name='PackageUrl'),
  packageVersion?: string(name='PackageVersion'),
  JDK?: string(name='JDK'),
  webContainer?: string(name='WebContainer'),
  edasContainerVersion?: string(name='EdasContainerVersion'),
  uriEncoding?: string(name='UriEncoding'),
  useBodyEncoding?: boolean(name='UseBodyEncoding'),
  updateStrategy?: string(name='UpdateStrategy'),
  mcpuRequest?: int32(name='McpuRequest'),
  mcpuLimit?: int32(name='McpuLimit'),
  volumesStr?: string(name='VolumesStr'),
  packageVersionId?: string(name='PackageVersionId'),
  changeOrderDesc?: string(name='ChangeOrderDesc'),
  runtimeClassName?: string(name='RuntimeClassName'),
  deployAcrossZones?: string(name='DeployAcrossZones'),
  batchTimeout?: int32(name='BatchTimeout'),
  enableAhas?: boolean(name='EnableAhas'),
  webContainerConfig?: string(name='WebContainerConfig'),
  javaStartUpConfig?: string(name='JavaStartUpConfig'),
  slsConfigs?: string(name='SlsConfigs'),
  deployAcrossNodes?: string(name='DeployAcrossNodes'),
  trafficControlStrategy?: string(name='TrafficControlStrategy'),
}

model DeployK8sApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model DeployK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeployK8sApplicationResponseBody(name='body'),
}

async function deployK8sApplication(request: DeployK8sApplicationRequest): DeployK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deployK8sApplicationWithOptions(request, headers, runtime);
}

async function deployK8sApplicationWithOptions(request: DeployK8sApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeployK8sApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.preStop)) {
    query.PreStop = request.preStop;
  }
  if (!Util.isUnset(request.envs)) {
    query.Envs = request.envs;
  }
  if (!Util.isUnset(request.imageTag)) {
    query.ImageTag = request.imageTag;
  }
  if (!Util.isUnset(request.batchWaitTime)) {
    query.BatchWaitTime = request.batchWaitTime;
  }
  if (!Util.isUnset(request.command)) {
    query.Command = request.command;
  }
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.postStart)) {
    query.PostStart = request.postStart;
  }
  if (!Util.isUnset(request.readiness)) {
    query.Readiness = request.readiness;
  }
  if (!Util.isUnset(request.liveness)) {
    query.Liveness = request.liveness;
  }
  if (!Util.isUnset(request.args)) {
    query.Args = request.args;
  }
  if (!Util.isUnset(request.replicas)) {
    query.Replicas = request.replicas;
  }
  if (!Util.isUnset(request.image)) {
    query.Image = request.image;
  }
  if (!Util.isUnset(request.cpuLimit)) {
    query.CpuLimit = request.cpuLimit;
  }
  if (!Util.isUnset(request.memoryLimit)) {
    query.MemoryLimit = request.memoryLimit;
  }
  if (!Util.isUnset(request.cpuRequest)) {
    query.CpuRequest = request.cpuRequest;
  }
  if (!Util.isUnset(request.memoryRequest)) {
    query.MemoryRequest = request.memoryRequest;
  }
  if (!Util.isUnset(request.nasId)) {
    query.NasId = request.nasId;
  }
  if (!Util.isUnset(request.mountDescs)) {
    query.MountDescs = request.mountDescs;
  }
  if (!Util.isUnset(request.storageType)) {
    query.StorageType = request.storageType;
  }
  if (!Util.isUnset(request.localVolume)) {
    query.LocalVolume = request.localVolume;
  }
  if (!Util.isUnset(request.packageUrl)) {
    query.PackageUrl = request.packageUrl;
  }
  if (!Util.isUnset(request.packageVersion)) {
    query.PackageVersion = request.packageVersion;
  }
  if (!Util.isUnset(request.JDK)) {
    query.JDK = request.JDK;
  }
  if (!Util.isUnset(request.webContainer)) {
    query.WebContainer = request.webContainer;
  }
  if (!Util.isUnset(request.edasContainerVersion)) {
    query.EdasContainerVersion = request.edasContainerVersion;
  }
  if (!Util.isUnset(request.uriEncoding)) {
    query.UriEncoding = request.uriEncoding;
  }
  if (!Util.isUnset(request.useBodyEncoding)) {
    query.UseBodyEncoding = request.useBodyEncoding;
  }
  if (!Util.isUnset(request.updateStrategy)) {
    query.UpdateStrategy = request.updateStrategy;
  }
  if (!Util.isUnset(request.mcpuRequest)) {
    query.McpuRequest = request.mcpuRequest;
  }
  if (!Util.isUnset(request.mcpuLimit)) {
    query.McpuLimit = request.mcpuLimit;
  }
  if (!Util.isUnset(request.volumesStr)) {
    query.VolumesStr = request.volumesStr;
  }
  if (!Util.isUnset(request.packageVersionId)) {
    query.PackageVersionId = request.packageVersionId;
  }
  if (!Util.isUnset(request.changeOrderDesc)) {
    query.ChangeOrderDesc = request.changeOrderDesc;
  }
  if (!Util.isUnset(request.runtimeClassName)) {
    query.RuntimeClassName = request.runtimeClassName;
  }
  if (!Util.isUnset(request.deployAcrossZones)) {
    query.DeployAcrossZones = request.deployAcrossZones;
  }
  if (!Util.isUnset(request.batchTimeout)) {
    query.BatchTimeout = request.batchTimeout;
  }
  if (!Util.isUnset(request.enableAhas)) {
    query.EnableAhas = request.enableAhas;
  }
  if (!Util.isUnset(request.webContainerConfig)) {
    query.WebContainerConfig = request.webContainerConfig;
  }
  if (!Util.isUnset(request.javaStartUpConfig)) {
    query.JavaStartUpConfig = request.javaStartUpConfig;
  }
  if (!Util.isUnset(request.slsConfigs)) {
    query.SlsConfigs = request.slsConfigs;
  }
  if (!Util.isUnset(request.deployAcrossNodes)) {
    query.DeployAcrossNodes = request.deployAcrossNodes;
  }
  if (!Util.isUnset(request.trafficControlStrategy)) {
    query.TrafficControlStrategy = request.trafficControlStrategy;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeployK8sApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s/acs/k8s_apps`, 'json', req, runtime);
}

model DisableDegradeControlRequest {
  appId?: string(name='AppId'),
  ruleId?: string(name='RuleId'),
}

model DisableDegradeControlResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model DisableDegradeControlResponse = {
  headers: map[string]string(name='headers'),
  body: DisableDegradeControlResponseBody(name='body'),
}

async function disableDegradeControl(request: DisableDegradeControlRequest): DisableDegradeControlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableDegradeControlWithOptions(request, headers, runtime);
}

async function disableDegradeControlWithOptions(request: DisableDegradeControlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DisableDegradeControlResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query.RuleId = request.ruleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DisableDegradeControl', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/degradecontrol/disable`, 'json', req, runtime);
}

model DisableFlowControlRequest {
  appId?: string(name='AppId'),
  ruleId?: string(name='RuleId'),
}

model DisableFlowControlResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model DisableFlowControlResponse = {
  headers: map[string]string(name='headers'),
  body: DisableFlowControlResponseBody(name='body'),
}

async function disableFlowControl(request: DisableFlowControlRequest): DisableFlowControlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableFlowControlWithOptions(request, headers, runtime);
}

async function disableFlowControlWithOptions(request: DisableFlowControlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DisableFlowControlResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query.RuleId = request.ruleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DisableFlowControl', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/flowcontrol/disable`, 'json', req, runtime);
}

model DisableMockRuleRequest {
  id?: long(name='Id'),
}

model DisableMockRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    namespaceId?: string(name='NamespaceId'),
    scMockItemJson?: string(name='ScMockItemJson'),
    consumerAppName?: string(name='ConsumerAppName'),
    consumerAppId?: string(name='ConsumerAppId'),
    accountId?: string(name='AccountId'),
    extraJson?: string(name='ExtraJson'),
    source?: string(name='Source'),
    region?: string(name='Region'),
    providerAppId?: string(name='ProviderAppId'),
    providerAppName?: string(name='ProviderAppName'),
    name?: string(name='Name'),
    id?: long(name='Id'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DisableMockRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DisableMockRuleResponseBody(name='body'),
}

async function disableMockRule(request: DisableMockRuleRequest): DisableMockRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableMockRuleWithOptions(request, headers, runtime);
}

async function disableMockRuleWithOptions(request: DisableMockRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DisableMockRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.id)) {
    query.Id = request.id;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DisableMockRule', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/mock/disableMockRule`, 'json', req, runtime);
}

model EnableDegradeControlRequest {
  appId?: string(name='AppId'),
  ruleId?: string(name='RuleId'),
}

model EnableDegradeControlResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model EnableDegradeControlResponse = {
  headers: map[string]string(name='headers'),
  body: EnableDegradeControlResponseBody(name='body'),
}

async function enableDegradeControl(request: EnableDegradeControlRequest): EnableDegradeControlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableDegradeControlWithOptions(request, headers, runtime);
}

async function enableDegradeControlWithOptions(request: EnableDegradeControlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EnableDegradeControlResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query.RuleId = request.ruleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('EnableDegradeControl', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/degradecontrol/enable`, 'json', req, runtime);
}

model EnableFlowControlRequest {
  appId?: string(name='AppId'),
  ruleId?: string(name='RuleId'),
}

model EnableFlowControlResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model EnableFlowControlResponse = {
  headers: map[string]string(name='headers'),
  body: EnableFlowControlResponseBody(name='body'),
}

async function enableFlowControl(request: EnableFlowControlRequest): EnableFlowControlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableFlowControlWithOptions(request, headers, runtime);
}

async function enableFlowControlWithOptions(request: EnableFlowControlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EnableFlowControlResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query.RuleId = request.ruleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('EnableFlowControl', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/flowcontrol/enable`, 'json', req, runtime);
}

model EnableMockRuleRequest {
  id?: long(name='Id'),
}

model EnableMockRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    namespaceId?: string(name='NamespaceId'),
    scMockItemJson?: string(name='ScMockItemJson'),
    consumerAppName?: string(name='ConsumerAppName'),
    consumerAppId?: string(name='ConsumerAppId'),
    accountId?: string(name='AccountId'),
    extraJson?: string(name='ExtraJson'),
    source?: string(name='Source'),
    region?: string(name='Region'),
    providerAppId?: string(name='ProviderAppId'),
    providerAppName?: string(name='ProviderAppName'),
    name?: string(name='Name'),
    id?: long(name='Id'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model EnableMockRuleResponse = {
  headers: map[string]string(name='headers'),
  body: EnableMockRuleResponseBody(name='body'),
}

async function enableMockRule(request: EnableMockRuleRequest): EnableMockRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableMockRuleWithOptions(request, headers, runtime);
}

async function enableMockRuleWithOptions(request: EnableMockRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EnableMockRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.id)) {
    query.Id = request.id;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('EnableMockRule', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/mock/enableMockRule`, 'json', req, runtime);
}

model ExecuteStatusRequest {
  region?: string(name='Region'),
  namespaceId?: string(name='NamespaceId'),
  tenantId?: string(name='TenantId'),
  source?: string(name='Source'),
  accountId?: string(name='AccountId'),
  appId?: string(name='AppId'),
  ip?: string(name='Ip'),
  podName?: string(name='PodName'),
  status?: string(name='Status'),
}

model ExecuteStatusResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    podName?: string(name='PodName'),
    namespaceId?: string(name='NamespaceId'),
    appId?: string(name='AppId'),
    region?: string(name='Region'),
    ip?: string(name='Ip'),
    accountId?: string(name='AccountId'),
    source?: string(name='Source'),
    id?: long(name='Id'),
    tenantId?: string(name='TenantId'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ExecuteStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ExecuteStatusResponseBody(name='body'),
}

async function executeStatus(request: ExecuteStatusRequest): ExecuteStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return executeStatusWithOptions(request, headers, runtime);
}

async function executeStatusWithOptions(request: ExecuteStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ExecuteStatusResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.region)) {
    query.Region = request.region;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query.NamespaceId = request.namespaceId;
  }
  if (!Util.isUnset(request.tenantId)) {
    query.TenantId = request.tenantId;
  }
  if (!Util.isUnset(request.source)) {
    query.Source = request.source;
  }
  if (!Util.isUnset(request.accountId)) {
    query.AccountId = request.accountId;
  }
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.ip)) {
    query.Ip = request.ip;
  }
  if (!Util.isUnset(request.podName)) {
    query.PodName = request.podName;
  }
  if (!Util.isUnset(request.status)) {
    query.Status = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ExecuteStatus', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/mse/status/execute`, 'json', req, runtime);
}

model GetAccountMockRuleRequest {
  region?: string(name='Region'),
  pageSize?: string(name='PageSize'),
  pageNumber?: string(name='PageNumber'),
  name?: string(name='Name'),
  consumerAppName?: string(name='ConsumerAppName'),
  providerAppName?: string(name='ProviderAppName'),
  namespace?: string(name='Namespace'),
}

model GetAccountMockRuleResponseBody = {
  message?: string(name='Message'),
  data?: {
    result?: [ 
      {
        dubboMockItems?: [ 
          {
            methodName?: string(name='MethodName'),
            paramTypes?: [ string ](name='ParamTypes'),
            value?: string(name='Value'),
            oper?: string(name='Oper'),
            executeCondition?: string(name='ExecuteCondition'),
            version?: string(name='Version'),
            exceptionClassName?: string(name='ExceptionClassName'),
            serviceName?: string(name='ServiceName'),
            group?: string(name='Group'),
          }
        ](name='DubboMockItems'),
        status?: int32(name='Status'),
        consumerAppName?: string(name='ConsumerAppName'),
        consumerAppId?: string(name='ConsumerAppId'),
        gmtModified?: string(name='GmtModified'),
        region?: string(name='Region'),
        scMockItems?: [ 
          {
            value?: string(name='Value'),
            oper?: string(name='Oper'),
            executeCondition?: string(name='ExecuteCondition'),
            path?: string(name='Path'),
            method?: string(name='Method'),
            exceptionClassName?: string(name='ExceptionClassName'),
            serviceName?: string(name='ServiceName'),
          }
        ](name='ScMockItems'),
        gmtCreate?: string(name='GmtCreate'),
        providerAppId?: string(name='ProviderAppId'),
        providerAppName?: string(name='ProviderAppName'),
        name?: string(name='Name'),
        id?: int32(name='Id'),
        enable?: boolean(name='Enable'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetAccountMockRuleResponse = {
  headers: map[string]string(name='headers'),
  body: GetAccountMockRuleResponseBody(name='body'),
}

async function getAccountMockRule(request: GetAccountMockRuleRequest): GetAccountMockRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAccountMockRuleWithOptions(request, headers, runtime);
}

async function getAccountMockRuleWithOptions(request: GetAccountMockRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAccountMockRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.region)) {
    query.Region = request.region;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query.PageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }
  if (!Util.isUnset(request.consumerAppName)) {
    query.ConsumerAppName = request.consumerAppName;
  }
  if (!Util.isUnset(request.providerAppName)) {
    query.ProviderAppName = request.providerAppName;
  }
  if (!Util.isUnset(request.namespace)) {
    query.Namespace = request.namespace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetAccountMockRule', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/mock/getAccountMockRule`, 'json', req, runtime);
}

model GetApplicationRequest {
  appId?: string(name='AppId'),
}

model GetApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  application?: {
    extSlbIp?: string(name='ExtSlbIp'),
    owner?: string(name='Owner'),
    slbPort?: int32(name='SlbPort'),
    nameSpace?: string(name='NameSpace'),
    extSlbName?: string(name='ExtSlbName'),
    createTime?: long(name='CreateTime'),
    userId?: string(name='UserId'),
    port?: int32(name='Port'),
    runningInstanceCount?: int32(name='RunningInstanceCount'),
    slbIp?: string(name='SlbIp'),
    dockerize?: boolean(name='Dockerize'),
    instanceCount?: int32(name='InstanceCount'),
    description?: string(name='Description'),
    appId?: string(name='AppId'),
    slbInfo?: string(name='SlbInfo'),
    memory?: int32(name='Memory'),
    name?: string(name='Name'),
    clusterId?: string(name='ClusterId'),
    healthCheckUrl?: string(name='HealthCheckUrl'),
    slbId?: string(name='SlbId'),
    applicationType?: string(name='ApplicationType'),
    extSlbId?: string(name='ExtSlbId'),
    buildPackageId?: long(name='BuildPackageId'),
    regionId?: string(name='RegionId'),
    email?: string(name='Email'),
    cpu?: int32(name='Cpu'),
    clusterType?: string(name='ClusterType'),
    slbName?: string(name='SlbName'),
  }(name='Application'),
}

model GetApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: GetApplicationResponseBody(name='body'),
}

async function getApplication(request: GetApplicationRequest): GetApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getApplicationWithOptions(request, headers, runtime);
}

async function getApplicationWithOptions(request: GetApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/app_info`, 'json', req, runtime);
}

model GetChangeOrderInfoRequest {
  changeOrderId?: string(name='ChangeOrderId'),
}

model GetChangeOrderInfoResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  changeOrderInfo?: {
    status?: int32(name='Status'),
    createTime?: string(name='CreateTime'),
    changeOrderDescription?: string(name='ChangeOrderDescription'),
    batchCount?: int32(name='BatchCount'),
    createUserId?: string(name='CreateUserId'),
    supportRollback?: boolean(name='SupportRollback'),
    desc?: string(name='Desc'),
    changeOrderId?: string(name='ChangeOrderId'),
    batchType?: string(name='BatchType'),
    coType?: string(name='CoType'),
    trafficControl?: {
      tips?: string(name='Tips'),
      routes?: string(name='Routes'),
      rules?: string(name='Rules'),
    }(name='TrafficControl'),
    pipelineInfoList?: {
      pipelineInfo?: [ 
      {
        startTime?: string(name='StartTime'),
        updateTime?: string(name='UpdateTime'),
        pipelineStatus?: int32(name='PipelineStatus'),
        stageDetailList?: {
          stageDetailDTO?: [ 
          {
            stageId?: string(name='StageId'),
            stageStatus?: int32(name='StageStatus'),
            taskList?: {
              taskInfoDTO?: [ 
              {
                taskErrorIgnorance?: int32(name='TaskErrorIgnorance'),
                showManualIgnorance?: boolean(name='ShowManualIgnorance'),
                taskStatus?: string(name='TaskStatus'),
                taskName?: string(name='TaskName'),
                taskMessage?: string(name='TaskMessage'),
                taskErrorCode?: string(name='TaskErrorCode'),
                taskId?: string(name='TaskId'),
                taskErrorMessage?: string(name='TaskErrorMessage'),
              }
            ](name='TaskInfoDTO')
            }(name='TaskList'),
            stageName?: string(name='StageName'),
          }
        ](name='StageDetailDTO')
        }(name='StageDetailList'),
        pipelineName?: string(name='PipelineName'),
        stageList?: {
          stageInfoDTO?: [ 
          {
            stageId?: string(name='StageId'),
            status?: int32(name='Status'),
            stageResultDTO?: {
              serviceStage?: {
                stageId?: string(name='StageId'),
                status?: int32(name='Status'),
                message?: string(name='Message'),
                stageName?: string(name='StageName'),
              }(name='ServiceStage'),
              instanceDTOList?: {
                instanceDTO?: [ 
                {
                  status?: int32(name='Status'),
                  instanceIp?: string(name='InstanceIp'),
                  podName?: string(name='PodName'),
                  instanceStageDTOList?: {
                    instanceStageDTO?: [ 
                    {
                      stageId?: string(name='StageId'),
                      status?: int32(name='Status'),
                      startTime?: string(name='StartTime'),
                      stageMessage?: string(name='StageMessage'),
                      finishTime?: string(name='FinishTime'),
                      stageName?: string(name='StageName'),
                    }
                  ](name='InstanceStageDTO')
                  }(name='InstanceStageDTOList'),
                  instanceName?: string(name='InstanceName'),
                  podStatus?: string(name='PodStatus'),
                }
              ](name='InstanceDTO')
              }(name='InstanceDTOList'),
            }(name='StageResultDTO'),
            stageName?: string(name='StageName'),
          }
        ](name='StageInfoDTO')
        }(name='StageList'),
        pipelineId?: string(name='PipelineId'),
      }
    ](name='PipelineInfo')
    }(name='PipelineInfoList'),
  }(name='changeOrderInfo'),
}

model GetChangeOrderInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetChangeOrderInfoResponseBody(name='body'),
}

async function getChangeOrderInfo(request: GetChangeOrderInfoRequest): GetChangeOrderInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getChangeOrderInfoWithOptions(request, headers, runtime);
}

async function getChangeOrderInfoWithOptions(request: GetChangeOrderInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetChangeOrderInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.changeOrderId)) {
    query.ChangeOrderId = request.changeOrderId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetChangeOrderInfo', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/change_order_info`, 'json', req, runtime);
}

model GetClusterRequest {
  clusterId?: string(name='ClusterId'),
}

model GetClusterResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  cluster?: {
    oversoldFactor?: int32(name='OversoldFactor'),
    vpcId?: string(name='VpcId'),
    updateTime?: long(name='UpdateTime'),
    memUsed?: int32(name='MemUsed'),
    iaasProvider?: string(name='IaasProvider'),
    createTime?: long(name='CreateTime'),
    cpuUsed?: int32(name='CpuUsed'),
    mem?: int32(name='Mem'),
    regionId?: string(name='RegionId'),
    cpu?: int32(name='Cpu'),
    csClusterId?: string(name='CsClusterId'),
    description?: string(name='Description'),
    networkMode?: int32(name='NetworkMode'),
    clusterType?: int32(name='ClusterType'),
    clusterName?: string(name='ClusterName'),
    nodeNum?: int32(name='NodeNum'),
    clusterImportStatus?: int32(name='ClusterImportStatus'),
    clusterId?: string(name='ClusterId'),
  }(name='Cluster'),
  code?: int32(name='Code'),
}

model GetClusterResponse = {
  headers: map[string]string(name='headers'),
  body: GetClusterResponseBody(name='body'),
}

async function getCluster(request: GetClusterRequest): GetClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getClusterWithOptions(request, headers, runtime);
}

async function getClusterWithOptions(request: GetClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetCluster', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/cluster`, 'json', req, runtime);
}

model GetContainerConfigurationRequest {
  appId?: string(name='AppId'),
  groupId?: string(name='GroupId'),
}

model GetContainerConfigurationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  containerConfiguration?: {
    contextPath?: string(name='ContextPath'),
    URIEncoding?: string(name='URIEncoding'),
    httpPort?: int32(name='HttpPort'),
    useBodyEncoding?: boolean(name='UseBodyEncoding'),
    maxThreads?: int32(name='MaxThreads'),
  }(name='ContainerConfiguration'),
}

model GetContainerConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: GetContainerConfigurationResponseBody(name='body'),
}

async function getContainerConfiguration(request: GetContainerConfigurationRequest): GetContainerConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getContainerConfigurationWithOptions(request, headers, runtime);
}

async function getContainerConfigurationWithOptions(request: GetContainerConfigurationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetContainerConfigurationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetContainerConfiguration', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/app/container_config`, 'json', req, runtime);
}

model GetJvmConfigurationRequest {
  appId?: string(name='AppId'),
  groupId?: string(name='GroupId'),
}

model GetJvmConfigurationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  jvmConfiguration?: {
    maxPermSize?: int32(name='MaxPermSize'),
    maxHeapSize?: int32(name='MaxHeapSize'),
    options?: string(name='Options'),
    minHeapSize?: int32(name='MinHeapSize'),
  }(name='JvmConfiguration'),
  code?: int32(name='Code'),
}

model GetJvmConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: GetJvmConfigurationResponseBody(name='body'),
}

async function getJvmConfiguration(request: GetJvmConfigurationRequest): GetJvmConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getJvmConfigurationWithOptions(request, headers, runtime);
}

async function getJvmConfigurationWithOptions(request: GetJvmConfigurationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetJvmConfigurationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetJvmConfiguration', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/app/app_jvm_config`, 'json', req, runtime);
}

model GetK8sApplicationRequest {
  appId?: string(name='AppId'),
  from?: string(name='From'),
}

model GetK8sApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  applcation?: {
    conf?: {
      postStart?: string(name='PostStart'),
      readiness?: string(name='Readiness'),
      ahasEnabled?: boolean(name='AhasEnabled'),
      k8sCmdArgs?: string(name='K8sCmdArgs'),
      liveness?: string(name='Liveness'),
      deployAcrossNodes?: string(name='DeployAcrossNodes'),
      k8sCmd?: string(name='K8sCmd'),
      preStop?: string(name='PreStop'),
      jarStartArgs?: string(name='JarStartArgs'),
      deployAcrossZones?: string(name='DeployAcrossZones'),
      k8sNasInfo?: string(name='K8sNasInfo'),
      jarStartOptions?: string(name='JarStartOptions'),
      runtimeClassName?: string(name='RuntimeClassName'),
      k8sLocalvolumeInfo?: string(name='K8sLocalvolumeInfo'),
      k8sVolumeInfo?: string(name='K8sVolumeInfo'),
    }(name='Conf'),
    appId?: string(name='AppId'),
    app?: {
      instancesBeforeScaling?: int32(name='InstancesBeforeScaling'),
      deployType?: string(name='DeployType'),
      applicationName?: string(name='ApplicationName'),
      applicationType?: string(name='ApplicationType'),
      instances?: int32(name='Instances'),
      cmdArgs?: {
        cmdArg?: [ string ](name='CmdArg')
      }(name='CmdArgs'),
      cmd?: string(name='Cmd'),
      buildpackId?: int32(name='BuildpackId'),
      tomcatVersion?: string(name='TomcatVersion'),
      csClusterId?: string(name='CsClusterId'),
      appId?: string(name='AppId'),
      edasContainerVersion?: string(name='EdasContainerVersion'),
      clusterId?: string(name='ClusterId'),
      envList?: {
        env?: [ 
        {
          value?: string(name='Value'),
          name?: string(name='Name'),
        }
      ](name='Env')
      }(name='EnvList'),
    }(name='App'),
    deployGroups?: {
      deployGroup?: [ 
      {
        components?: {
          components?: [ 
          {
            componentKey?: string(name='ComponentKey'),
            componentId?: string(name='ComponentId'),
          }
        ](name='Components')
        }(name='Components'),
      }
    ](name='DeployGroup')
    }(name='DeployGroups'),
    imageInfo?: {
      repoId?: string(name='RepoId'),
      imageUrl?: string(name='ImageUrl'),
      repoOriginType?: string(name='RepoOriginType'),
      tag?: string(name='Tag'),
      repoName?: string(name='RepoName'),
      repoNamespace?: string(name='RepoNamespace'),
      regionId?: string(name='RegionId'),
    }(name='ImageInfo'),
  }(name='Applcation'),
  code?: int32(name='Code'),
}

model GetK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: GetK8sApplicationResponseBody(name='body'),
}

async function getK8sApplication(request: GetK8sApplicationRequest): GetK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getK8sApplicationWithOptions(request, headers, runtime);
}

async function getK8sApplicationWithOptions(request: GetK8sApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetK8sApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.from)) {
    query.From = request.from;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetK8sApplication', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/changeorder/co_application`, 'json', req, runtime);
}

model GetK8sClusterRequest {
  regionTag?: string(name='RegionTag'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  clusterType?: int32(name='ClusterType'),
}

model GetK8sClusterResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  clusterPage?: {
    currentPage?: int32(name='CurrentPage'),
    clusterList?: {
      cluster?: [ 
      {
        vpcId?: string(name='VpcId'),
        vswitchId?: string(name='VswitchId'),
        subNetCidr?: string(name='SubNetCidr'),
        mem?: int32(name='Mem'),
        regionId?: string(name='RegionId'),
        csClusterStatus?: string(name='CsClusterStatus'),
        cpu?: int32(name='Cpu'),
        description?: string(name='Description'),
        csClusterId?: string(name='CsClusterId'),
        networkMode?: int32(name='NetworkMode'),
        clusterType?: int32(name='ClusterType'),
        clusterStatus?: int32(name='ClusterStatus'),
        clusterName?: string(name='ClusterName'),
        nodeNum?: int32(name='NodeNum'),
        clusterId?: string(name='ClusterId'),
        clusterImportStatus?: int32(name='ClusterImportStatus'),
      }
    ](name='Cluster')
    }(name='ClusterList'),
    totalSize?: int32(name='TotalSize'),
    pageSize?: int32(name='PageSize'),
  }(name='ClusterPage'),
  code?: int32(name='Code'),
}

model GetK8sClusterResponse = {
  headers: map[string]string(name='headers'),
  body: GetK8sClusterResponseBody(name='body'),
}

async function getK8sCluster(request: GetK8sClusterRequest): GetK8sClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getK8sClusterWithOptions(request, headers, runtime);
}

async function getK8sClusterWithOptions(request: GetK8sClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetK8sClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.regionTag)) {
    query.RegionTag = request.regionTag;
  }
  if (!Util.isUnset(request.currentPage)) {
    query.CurrentPage = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.clusterType)) {
    query.ClusterType = request.clusterType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetK8sCluster', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s_clusters`, 'json', req, runtime);
}

model GetK8sServicesRequest {
  appId?: string(name='AppId'),
}

model GetK8sServicesResponseBody = {
  services?: [ 
    {
      type?: string(name='Type'),
      servicePorts?: [ 
        {
          protocol?: string(name='Protocol'),
          targetPort?: string(name='TargetPort'),
          nodePort?: int32(name='NodePort'),
          port?: int32(name='Port'),
        }
      ](name='ServicePorts'),
      name?: string(name='Name'),
      clusterIP?: string(name='ClusterIP'),
    }
  ](name='Services'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model GetK8sServicesResponse = {
  headers: map[string]string(name='headers'),
  body: GetK8sServicesResponseBody(name='body'),
}

async function getK8sServices(request: GetK8sServicesRequest): GetK8sServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getK8sServicesWithOptions(request, headers, runtime);
}

async function getK8sServicesWithOptions(request: GetK8sServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetK8sServicesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetK8sServices', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/k8s/acs/k8s_service`, 'json', req, runtime);
}

model GetMockRuleByConsumerAppIdRequest {
  region?: string(name='Region'),
  consumerAppId?: string(name='ConsumerAppId'),
}

model GetMockRuleByConsumerAppIdResponseBody = {
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      namespaceId?: string(name='NamespaceId'),
      scMockItemJson?: string(name='ScMockItemJson'),
      consumerAppName?: string(name='ConsumerAppName'),
      consumerAppId?: string(name='ConsumerAppId'),
      accountId?: string(name='AccountId'),
      extraJson?: string(name='ExtraJson'),
      source?: string(name='Source'),
      region?: string(name='Region'),
      providerAppId?: string(name='ProviderAppId'),
      providerAppName?: string(name='ProviderAppName'),
      name?: string(name='Name'),
      id?: long(name='Id'),
      enable?: boolean(name='Enable'),
    }
  ](name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetMockRuleByConsumerAppIdResponse = {
  headers: map[string]string(name='headers'),
  body: GetMockRuleByConsumerAppIdResponseBody(name='body'),
}

async function getMockRuleByConsumerAppId(request: GetMockRuleByConsumerAppIdRequest): GetMockRuleByConsumerAppIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMockRuleByConsumerAppIdWithOptions(request, headers, runtime);
}

async function getMockRuleByConsumerAppIdWithOptions(request: GetMockRuleByConsumerAppIdRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMockRuleByConsumerAppIdResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.region)) {
    query.Region = request.region;
  }
  if (!Util.isUnset(request.consumerAppId)) {
    query.ConsumerAppId = request.consumerAppId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetMockRuleByConsumerAppId', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/mock/getMockRuleByConsumerAppId`, 'json', req, runtime);
}

model GetMockRuleByIdRequest {
  id?: long(name='Id'),
}

model GetMockRuleByIdResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    dubboMockItems?: [ 
      {
        paramTypes?: string(name='ParamTypes'),
        methodName?: string(name='MethodName'),
        value?: string(name='Value'),
        oper?: string(name='Oper'),
        exceptionMessage?: string(name='ExceptionMessage'),
        executeCondition?: string(name='ExecuteCondition'),
        version?: string(name='Version'),
        path?: string(name='Path'),
        exceptionClassName?: string(name='ExceptionClassName'),
        serviceName?: string(name='ServiceName'),
        group?: string(name='Group'),
      }
    ](name='DubboMockItems'),
    consumerAppName?: string(name='ConsumerAppName'),
    consumerAppId?: string(name='ConsumerAppId'),
    accountId?: string(name='AccountId'),
    extraJson?: string(name='ExtraJson'),
    source?: string(name='Source'),
    region?: string(name='Region'),
    scMockItems?: [ 
      {
        value?: string(name='Value'),
        oper?: string(name='Oper'),
        executeCondition?: string(name='ExecuteCondition'),
        path?: string(name='Path'),
        method?: string(name='Method'),
        exceptionClassName?: string(name='ExceptionClassName'),
        serviceName?: string(name='ServiceName'),
      }
    ](name='ScMockItems'),
    providerAppId?: string(name='ProviderAppId'),
    providerAppName?: string(name='ProviderAppName'),
    name?: string(name='Name'),
    id?: long(name='Id'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetMockRuleByIdResponse = {
  headers: map[string]string(name='headers'),
  body: GetMockRuleByIdResponseBody(name='body'),
}

async function getMockRuleById(request: GetMockRuleByIdRequest): GetMockRuleByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMockRuleByIdWithOptions(request, headers, runtime);
}

async function getMockRuleByIdWithOptions(request: GetMockRuleByIdRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMockRuleByIdResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.id)) {
    query.Id = request.id;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetMockRuleById', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/mock/getMockRuleById`, 'json', req, runtime);
}

model GetMockRuleByProviderAppIdRequest {
  region?: string(name='Region'),
  providerAppId?: string(name='ProviderAppId'),
}

model GetMockRuleByProviderAppIdResponseBody = {
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      namespaceId?: string(name='NamespaceId'),
      scMockItemJson?: string(name='ScMockItemJson'),
      consumerAppName?: string(name='ConsumerAppName'),
      consumerAppId?: string(name='ConsumerAppId'),
      accountId?: string(name='AccountId'),
      extraJson?: string(name='ExtraJson'),
      source?: string(name='Source'),
      region?: string(name='Region'),
      providerAppId?: string(name='ProviderAppId'),
      providerAppName?: string(name='ProviderAppName'),
      name?: string(name='Name'),
      id?: long(name='Id'),
      enable?: boolean(name='Enable'),
    }
  ](name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetMockRuleByProviderAppIdResponse = {
  headers: map[string]string(name='headers'),
  body: GetMockRuleByProviderAppIdResponseBody(name='body'),
}

async function getMockRuleByProviderAppId(request: GetMockRuleByProviderAppIdRequest): GetMockRuleByProviderAppIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMockRuleByProviderAppIdWithOptions(request, headers, runtime);
}

async function getMockRuleByProviderAppIdWithOptions(request: GetMockRuleByProviderAppIdRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMockRuleByProviderAppIdResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.region)) {
    query.Region = request.region;
  }
  if (!Util.isUnset(request.providerAppId)) {
    query.ProviderAppId = request.providerAppId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetMockRuleByProviderAppId', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/mock/getMockRuleByProviderAppId`, 'json', req, runtime);
}

model GetPackageStorageCredentialResponseBody = {
  credential?: {
    keyPrefix?: string(name='KeyPrefix'),
    securityToken?: string(name='SecurityToken'),
    accessKeySecret?: string(name='AccessKeySecret'),
    expiration?: string(name='Expiration'),
    accessKeyId?: string(name='AccessKeyId'),
    bucket?: string(name='Bucket'),
    regionId?: string(name='RegionId'),
  }(name='Credential'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model GetPackageStorageCredentialResponse = {
  headers: map[string]string(name='headers'),
  body: GetPackageStorageCredentialResponseBody(name='body'),
}

async function getPackageStorageCredential(): GetPackageStorageCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPackageStorageCredentialWithOptions(headers, runtime);
}

async function getPackageStorageCredentialWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetPackageStorageCredentialResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetPackageStorageCredential', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/package_storage_credential`, 'json', req, runtime);
}

model GetScalingRulesRequest {
  appId?: string(name='AppId'),
  groupId?: string(name='GroupId'),
  mode?: string(name='Mode'),
}

model GetScalingRulesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  updateTime?: long(name='UpdateTime'),
  data?: {
    oversoldFactor?: int32(name='OversoldFactor'),
    vpcId?: string(name='VpcId'),
    updateTime?: long(name='UpdateTime'),
    clusterType?: int32(name='ClusterType'),
    ruleList?: {
      rule?: [ 
      {
        vpcId?: string(name='VpcId'),
        updateTime?: long(name='UpdateTime'),
        rt?: int32(name='Rt'),
        createTime?: long(name='CreateTime'),
        resourceFrom?: string(name='ResourceFrom'),
        multiAzPolicy?: string(name='MultiAzPolicy'),
        specId?: string(name='SpecId'),
        mode?: string(name='Mode'),
        loadNum?: int32(name='LoadNum'),
        templateVersion?: int32(name='TemplateVersion'),
        cond?: string(name='Cond'),
        step?: int32(name='Step'),
        cpu?: int32(name='Cpu'),
        groupId?: string(name='GroupId'),
        instNum?: int32(name='InstNum'),
        appId?: string(name='AppId'),
        duration?: int32(name='Duration'),
        vSwitchIds?: string(name='VSwitchIds'),
        metricType?: string(name='MetricType'),
        templateId?: string(name='TemplateId'),
        enable?: boolean(name='Enable'),
      }
    ](name='Rule')
    }(name='RuleList'),
  }(name='Data'),
  code?: int32(name='Code'),
}

model GetScalingRulesResponse = {
  headers: map[string]string(name='headers'),
  body: GetScalingRulesResponseBody(name='body'),
}

async function getScalingRules(request: GetScalingRulesRequest): GetScalingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getScalingRulesWithOptions(request, headers, runtime);
}

async function getScalingRulesWithOptions(request: GetScalingRulesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetScalingRulesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }
  if (!Util.isUnset(request.mode)) {
    query.Mode = request.mode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetScalingRules', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/app/scalingRules`, 'json', req, runtime);
}

model GetSecureTokenRequest {
  namespaceId?: string(name='NamespaceId'),
}

model GetSecureTokenResponseBody = {
  secureToken?: {
    secretKey?: string(name='SecretKey'),
    accessKey?: string(name='AccessKey'),
    belongRegion?: string(name='BelongRegion'),
    description?: string(name='Description'),
    regionName?: string(name='RegionName'),
    edasId?: string(name='EdasId'),
    addressServerHost?: string(name='AddressServerHost'),
    userId?: string(name='UserId'),
    id?: long(name='Id'),
    tenantId?: string(name='TenantId'),
    regionId?: string(name='RegionId'),
  }(name='SecureToken'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model GetSecureTokenResponse = {
  headers: map[string]string(name='headers'),
  body: GetSecureTokenResponseBody(name='body'),
}

async function getSecureToken(request: GetSecureTokenRequest): GetSecureTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSecureTokenWithOptions(request, headers, runtime);
}

async function getSecureTokenWithOptions(request: GetSecureTokenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetSecureTokenResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.namespaceId)) {
    query.NamespaceId = request.namespaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetSecureToken', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/secure_token`, 'json', req, runtime);
}

model GetServiceConsumersPageRequest {
  region?: string(name='region'),
  namespace?: string(name='namespace'),
  origin?: string(name='origin'),
  serviceType?: string(name='serviceType'),
  appId?: string(name='appId'),
  source?: string(name='source'),
  serviceId?: string(name='serviceId'),
  serviceName?: string(name='serviceName'),
  serviceVersion?: string(name='serviceVersion'),
  group?: string(name='group'),
  ip?: string(name='ip'),
  registryType?: string(name='registryType'),
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model GetServiceConsumersPageResponseBody = {
  message?: string(name='Message'),
  data?: {
    size?: int32(name='Size'),
    totalPages?: int32(name='TotalPages'),
    totalElements?: int32(name='TotalElements'),
    content?: [ 
      {
        edasAppName?: string(name='EdasAppName'),
        ip?: string(name='Ip'),
        edassAppId?: string(name='EdassAppId'),
      }
    ](name='Content'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model GetServiceConsumersPageResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceConsumersPageResponseBody(name='body'),
}

async function getServiceConsumersPage(request: GetServiceConsumersPageRequest): GetServiceConsumersPageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceConsumersPageWithOptions(request, headers, runtime);
}

async function getServiceConsumersPageWithOptions(request: GetServiceConsumersPageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceConsumersPageResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.region)) {
    query.region = request.region;
  }
  if (!Util.isUnset(request.namespace)) {
    query.namespace = request.namespace;
  }
  if (!Util.isUnset(request.origin)) {
    query.origin = request.origin;
  }
  if (!Util.isUnset(request.serviceType)) {
    query.serviceType = request.serviceType;
  }
  if (!Util.isUnset(request.appId)) {
    query.appId = request.appId;
  }
  if (!Util.isUnset(request.source)) {
    query.source = request.source;
  }
  if (!Util.isUnset(request.serviceId)) {
    query.serviceId = request.serviceId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query.serviceName = request.serviceName;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query.serviceVersion = request.serviceVersion;
  }
  if (!Util.isUnset(request.group)) {
    query.group = request.group;
  }
  if (!Util.isUnset(request.ip)) {
    query.ip = request.ip;
  }
  if (!Util.isUnset(request.registryType)) {
    query.registryType = request.registryType;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetServiceConsumersPage', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/mseForOam/getServiceConsumersPage`, 'json', req, runtime);
}

model GetServiceDetailRequest {
  region?: string(name='region'),
  namespace?: string(name='namespace'),
  origin?: string(name='origin'),
  serviceType?: string(name='serviceType'),
  appId?: string(name='appId'),
  source?: string(name='source'),
  serviceId?: string(name='serviceId'),
  serviceName?: string(name='serviceName'),
  serviceVersion?: string(name='serviceVersion'),
  group?: string(name='group'),
  ip?: string(name='ip'),
  registryType?: string(name='registryType'),
}

model GetServiceDetailResponseBody = {
  message?: string(name='Message'),
  data?: {
    edasAppName?: string(name='EdasAppName'),
    dubboApplicationName?: string(name='DubboApplicationName'),
    version?: string(name='Version'),
    registryType?: string(name='RegistryType'),
    springApplicationName?: string(name='SpringApplicationName'),
    serviceType?: string(name='ServiceType'),
    serviceName?: string(name='ServiceName'),
    methods?: [ 
      {
        parameterDetails?: string(name='ParameterDetails'),
        parameterNames?: string(name='ParameterNames'),
        paths?: string(name='Paths'),
        parameterTypes?: string(name='ParameterTypes'),
        returnType?: string(name='ReturnType'),
        nameDetail?: string(name='NameDetail'),
        parameterDefinitions?: string(name='ParameterDefinitions'),
        returnDefinition?: {
          type?: string(name='Type'),
          id?: string(name='Id'),
        }(name='ReturnDefinition'),
        requestMethods?: string(name='RequestMethods'),
        returnDetails?: string(name='ReturnDetails'),
        name?: string(name='Name'),
        methodController?: string(name='MethodController'),
      }
    ](name='Methods'),
    metadata?: string(name='Metadata'),
    group?: string(name='Group'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model GetServiceDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceDetailResponseBody(name='body'),
}

async function getServiceDetail(request: GetServiceDetailRequest): GetServiceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceDetailWithOptions(request, headers, runtime);
}

async function getServiceDetailWithOptions(request: GetServiceDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceDetailResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.region)) {
    query.region = request.region;
  }
  if (!Util.isUnset(request.namespace)) {
    query.namespace = request.namespace;
  }
  if (!Util.isUnset(request.origin)) {
    query.origin = request.origin;
  }
  if (!Util.isUnset(request.serviceType)) {
    query.serviceType = request.serviceType;
  }
  if (!Util.isUnset(request.appId)) {
    query.appId = request.appId;
  }
  if (!Util.isUnset(request.source)) {
    query.source = request.source;
  }
  if (!Util.isUnset(request.serviceId)) {
    query.serviceId = request.serviceId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query.serviceName = request.serviceName;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query.serviceVersion = request.serviceVersion;
  }
  if (!Util.isUnset(request.group)) {
    query.group = request.group;
  }
  if (!Util.isUnset(request.ip)) {
    query.ip = request.ip;
  }
  if (!Util.isUnset(request.registryType)) {
    query.registryType = request.registryType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetServiceDetail', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/mseForOam/getServiceDetail`, 'json', req, runtime);
}

model GetServiceListRequest {
  region?: string(name='region'),
  namespace?: string(name='namespace'),
  origin?: string(name='origin'),
  serviceType?: string(name='serviceType'),
  searchType?: string(name='searchType'),
  searchValue?: string(name='searchValue'),
  side?: string(name='side'),
}

model GetServiceListResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  success?: boolean(name='Success'),
  data?: [ 
    {
      serviceName?: string(name='ServiceName'),
      edasAppName?: string(name='EdasAppName'),
      dubboApplicationName?: string(name='DubboApplicationName'),
      springApplicationName?: string(name='SpringApplicationName'),
      serviceType?: string(name='ServiceType'),
      registryType?: string(name='RegistryType'),
      version?: string(name='Version'),
      group?: string(name='Group'),
      metadata?: string(name='Metadata'),
      methods?: [ 
        {
          name?: string(name='Name'),
          returnType?: string(name='ReturnType'),
          methodController?: string(name='MethodController'),
          parameterNames?: string(name='ParameterNames'),
          nameDetail?: string(name='NameDetail'),
          returnDetails?: string(name='ReturnDetails'),
          parameterTypes?: string(name='ParameterTypes'),
          parameterDetails?: string(name='ParameterDetails'),
          requestMethods?: string(name='RequestMethods'),
          paths?: string(name='Paths'),
          parameterDefinitions?: string(name='ParameterDefinitions'),
        }
      ](name='Methods'),
    }
  ](name='Data'),
}

model GetServiceListResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceListResponseBody(name='body'),
}

async function getServiceList(request: GetServiceListRequest): GetServiceListResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceListWithOptions(request, headers, runtime);
}

async function getServiceListWithOptions(request: GetServiceListRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceListResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.region)) {
    query.region = request.region;
  }
  if (!Util.isUnset(request.namespace)) {
    query.namespace = request.namespace;
  }
  if (!Util.isUnset(request.origin)) {
    query.origin = request.origin;
  }
  if (!Util.isUnset(request.serviceType)) {
    query.serviceType = request.serviceType;
  }
  if (!Util.isUnset(request.searchType)) {
    query.searchType = request.searchType;
  }
  if (!Util.isUnset(request.searchValue)) {
    query.searchValue = request.searchValue;
  }
  if (!Util.isUnset(request.side)) {
    query.side = request.side;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetServiceList', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/mseForOam/getServiceList`, 'json', req, runtime);
}

model GetServiceListPageRequest {
  region?: string(name='region'),
  namespace?: string(name='namespace'),
  origin?: string(name='origin'),
  serviceType?: string(name='serviceType'),
  searchType?: string(name='searchType'),
  searchValue?: string(name='searchValue'),
  side?: string(name='side'),
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model GetServiceListPageResponseBody = {
  message?: string(name='Message'),
  data?: {
    size?: int32(name='Size'),
    totalPages?: int32(name='TotalPages'),
    totalElements?: int32(name='TotalElements'),
    content?: [ 
      {
        edasAppName?: string(name='EdasAppName'),
        instanceNum?: int32(name='InstanceNum'),
        version?: string(name='Version'),
        serviceId?: string(name='ServiceId'),
        edasAppId?: string(name='EdasAppId'),
        serviceName?: string(name='ServiceName'),
        registerType?: string(name='RegisterType'),
        group?: string(name='Group'),
      }
    ](name='Content'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model GetServiceListPageResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceListPageResponseBody(name='body'),
}

async function getServiceListPage(request: GetServiceListPageRequest): GetServiceListPageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceListPageWithOptions(request, headers, runtime);
}

async function getServiceListPageWithOptions(request: GetServiceListPageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceListPageResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.region)) {
    query.region = request.region;
  }
  if (!Util.isUnset(request.namespace)) {
    query.namespace = request.namespace;
  }
  if (!Util.isUnset(request.origin)) {
    query.origin = request.origin;
  }
  if (!Util.isUnset(request.serviceType)) {
    query.serviceType = request.serviceType;
  }
  if (!Util.isUnset(request.searchType)) {
    query.searchType = request.searchType;
  }
  if (!Util.isUnset(request.searchValue)) {
    query.searchValue = request.searchValue;
  }
  if (!Util.isUnset(request.side)) {
    query.side = request.side;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetServiceListPage', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/mseForOam/getServiceListPage`, 'json', req, runtime);
}

model GetServiceMethodPageRequest {
  region?: string(name='region'),
  namespace?: string(name='namespace'),
  origin?: string(name='origin'),
  serviceType?: string(name='serviceType'),
  appId?: string(name='appId'),
  source?: string(name='source'),
  serviceId?: string(name='serviceId'),
  serviceName?: string(name='serviceName'),
  serviceVersion?: string(name='serviceVersion'),
  group?: string(name='group'),
  ip?: string(name='ip'),
  registryType?: string(name='registryType'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  methodController?: string(name='methodController'),
  path?: string(name='path'),
  name?: string(name='name'),
}

model GetServiceMethodPageResponseBody = {
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    result?: [ 
      {
        parameterDetails?: string(name='ParameterDetails'),
        parameterNames?: string(name='ParameterNames'),
        paths?: string(name='Paths'),
        parameterTypes?: string(name='ParameterTypes'),
        returnType?: string(name='ReturnType'),
        nameDetail?: string(name='NameDetail'),
        parameterDefinitions?: string(name='ParameterDefinitions'),
        returnDefinition?: {
          type?: string(name='Type'),
          id?: string(name='Id'),
        }(name='ReturnDefinition'),
        requestMethods?: string(name='RequestMethods'),
        returnDetails?: string(name='ReturnDetails'),
        name?: string(name='Name'),
        methodController?: string(name='MethodController'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetServiceMethodPageResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceMethodPageResponseBody(name='body'),
}

async function getServiceMethodPage(request: GetServiceMethodPageRequest): GetServiceMethodPageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceMethodPageWithOptions(request, headers, runtime);
}

async function getServiceMethodPageWithOptions(request: GetServiceMethodPageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceMethodPageResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.region)) {
    query.region = request.region;
  }
  if (!Util.isUnset(request.namespace)) {
    query.namespace = request.namespace;
  }
  if (!Util.isUnset(request.origin)) {
    query.origin = request.origin;
  }
  if (!Util.isUnset(request.serviceType)) {
    query.serviceType = request.serviceType;
  }
  if (!Util.isUnset(request.appId)) {
    query.appId = request.appId;
  }
  if (!Util.isUnset(request.source)) {
    query.source = request.source;
  }
  if (!Util.isUnset(request.serviceId)) {
    query.serviceId = request.serviceId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query.serviceName = request.serviceName;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query.serviceVersion = request.serviceVersion;
  }
  if (!Util.isUnset(request.group)) {
    query.group = request.group;
  }
  if (!Util.isUnset(request.ip)) {
    query.ip = request.ip;
  }
  if (!Util.isUnset(request.registryType)) {
    query.registryType = request.registryType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query.pageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.pageSize = request.pageSize;
  }
  if (!Util.isUnset(request.methodController)) {
    query.methodController = request.methodController;
  }
  if (!Util.isUnset(request.path)) {
    query.path = request.path;
  }
  if (!Util.isUnset(request.name)) {
    query.name = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetServiceMethodPage', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/mseForOam/getServiceMethodPage`, 'json', req, runtime);
}

model GetServiceProvidersPageRequest {
  region?: string(name='region'),
  namespace?: string(name='namespace'),
  origin?: string(name='origin'),
  serviceType?: string(name='serviceType'),
  appId?: string(name='appId'),
  source?: string(name='source'),
  serviceId?: string(name='serviceId'),
  serviceName?: string(name='serviceName'),
  serviceVersion?: string(name='serviceVersion'),
  group?: string(name='group'),
  ip?: string(name='ip'),
  registryType?: string(name='registryType'),
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model GetServiceProvidersPageResponseBody = {
  message?: string(name='Message'),
  data?: {
    size?: int32(name='Size'),
    totalPages?: int32(name='TotalPages'),
    totalElements?: int32(name='TotalElements'),
    content?: [ 
      {
        timeout?: string(name='Timeout'),
        ip?: string(name='Ip'),
        port?: string(name='Port'),
        serializeType?: string(name='SerializeType'),
      }
    ](name='Content'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model GetServiceProvidersPageResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceProvidersPageResponseBody(name='body'),
}

async function getServiceProvidersPage(request: GetServiceProvidersPageRequest): GetServiceProvidersPageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceProvidersPageWithOptions(request, headers, runtime);
}

async function getServiceProvidersPageWithOptions(request: GetServiceProvidersPageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceProvidersPageResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.region)) {
    query.region = request.region;
  }
  if (!Util.isUnset(request.namespace)) {
    query.namespace = request.namespace;
  }
  if (!Util.isUnset(request.origin)) {
    query.origin = request.origin;
  }
  if (!Util.isUnset(request.serviceType)) {
    query.serviceType = request.serviceType;
  }
  if (!Util.isUnset(request.appId)) {
    query.appId = request.appId;
  }
  if (!Util.isUnset(request.source)) {
    query.source = request.source;
  }
  if (!Util.isUnset(request.serviceId)) {
    query.serviceId = request.serviceId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query.serviceName = request.serviceName;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query.serviceVersion = request.serviceVersion;
  }
  if (!Util.isUnset(request.group)) {
    query.group = request.group;
  }
  if (!Util.isUnset(request.ip)) {
    query.ip = request.ip;
  }
  if (!Util.isUnset(request.registryType)) {
    query.registryType = request.registryType;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetServiceProvidersPage', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/mseForOam/getServiceProvidersPage`, 'json', req, runtime);
}

model GetSubAccountInfoRequest {
  targetUserId?: string(name='TargetUserId'),
}

model GetSubAccountInfoResponseBody = {
  authorization?: {
    roleIdData?: string(name='RoleIdData'),
    ramOperation?: boolean(name='RamOperation'),
    updateTime?: long(name='UpdateTime'),
    edasId?: string(name='EdasId'),
    isRamDel?: boolean(name='IsRamDel'),
    createTime?: long(name='CreateTime'),
    userId?: string(name='UserId'),
    adminEdasId?: string(name='AdminEdasId'),
    resGroupId?: long(name='ResGroupId'),
    isRamSlave?: boolean(name='IsRamSlave'),
    adminUserId?: string(name='AdminUserId'),
    subUserKp?: string(name='SubUserKp'),
    appIdData?: string(name='AppIdData'),
    resGroupIdData?: string(name='ResGroupIdData'),
    sts?: boolean(name='Sts'),
    delegateAdmin?: boolean(name='DelegateAdmin'),
  }(name='Authorization'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model GetSubAccountInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetSubAccountInfoResponseBody(name='body'),
}

async function getSubAccountInfo(request: GetSubAccountInfoRequest): GetSubAccountInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSubAccountInfoWithOptions(request, headers, runtime);
}

async function getSubAccountInfoWithOptions(request: GetSubAccountInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetSubAccountInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.targetUserId)) {
    query.TargetUserId = request.targetUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetSubAccountInfo', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/sub_account_info`, 'json', req, runtime);
}

model GetSwimmingLaneRequest {
  laneId?: long(name='LaneId'),
}

model GetSwimmingLaneResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    namespaceId?: string(name='NamespaceId'),
    groupId?: long(name='GroupId'),
    scenarioSign?: string(name='ScenarioSign'),
    entryRule?: string(name='EntryRule'),
    tag?: string(name='Tag'),
    enableRules?: boolean(name='EnableRules'),
    name?: string(name='Name'),
    swimmingLaneAppRelationShipList?: [ 
      {
        appName?: string(name='AppName'),
        appId?: string(name='AppId'),
        rules?: string(name='Rules'),
        laneId?: long(name='LaneId'),
      }
    ](name='SwimmingLaneAppRelationShipList'),
    id?: string(name='Id'),
  }(name='Data'),
  code?: int32(name='Code'),
}

model GetSwimmingLaneResponse = {
  headers: map[string]string(name='headers'),
  body: GetSwimmingLaneResponseBody(name='body'),
}

async function getSwimmingLane(request: GetSwimmingLaneRequest): GetSwimmingLaneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSwimmingLaneWithOptions(request, headers, runtime);
}

async function getSwimmingLaneWithOptions(request: GetSwimmingLaneRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetSwimmingLaneResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.laneId)) {
    query.LaneId = request.laneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetSwimmingLane', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/trafficmgnt/swimming_lane`, 'json', req, runtime);
}

model ImportK8sClusterRequest {
  clusterId?: string(name='ClusterId'),
  namespaceId?: string(name='NamespaceId'),
  mode?: int32(name='Mode'),
  enableAsm?: boolean(name='EnableAsm'),
}

model ImportK8sClusterResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: int32(name='Code'),
}

model ImportK8sClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ImportK8sClusterResponseBody(name='body'),
}

async function importK8sCluster(request: ImportK8sClusterRequest): ImportK8sClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return importK8sClusterWithOptions(request, headers, runtime);
}

async function importK8sClusterWithOptions(request: ImportK8sClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ImportK8sClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query.NamespaceId = request.namespaceId;
  }
  if (!Util.isUnset(request.mode)) {
    query.Mode = request.mode;
  }
  if (!Util.isUnset(request.enableAsm)) {
    query.EnableAsm = request.enableAsm;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ImportK8sCluster', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/import_k8s_cluster`, 'json', req, runtime);
}

model InsertApplicationRequest {
  clusterId?: string(name='ClusterId'),
  buildPackId?: int32(name='BuildPackId'),
  description?: string(name='Description'),
  applicationName?: string(name='ApplicationName'),
  reservedPortStr?: string(name='ReservedPortStr'),
  ecuInfo?: string(name='EcuInfo'),
  cpu?: int32(name='Cpu'),
  mem?: int32(name='Mem'),
  healthCheckURL?: string(name='HealthCheckURL'),
  logicalRegionId?: string(name='LogicalRegionId'),
  jdk?: string(name='Jdk'),
  webContainer?: string(name='WebContainer'),
  packageType?: string(name='PackageType'),
  componentIds?: string(name='ComponentIds'),
  hooks?: string(name='Hooks'),
  jvmOptions?: string(name='JvmOptions'),
  minHeapSize?: int32(name='MinHeapSize'),
  maxPermSize?: int32(name='MaxPermSize'),
  maxHeapSize?: int32(name='MaxHeapSize'),
  enableUrlCheck?: boolean(name='EnableUrlCheck'),
  enablePortCheck?: boolean(name='EnablePortCheck'),
  healthCheckUrl?: string(name='HealthCheckUrl'),
}

model InsertApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  applicationInfo?: {
    changeOrderId?: string(name='ChangeOrderId'),
    appName?: string(name='AppName'),
    owner?: string(name='Owner'),
    dockerize?: boolean(name='Dockerize'),
    regionName?: string(name='RegionName'),
    appId?: string(name='AppId'),
    userId?: string(name='UserId'),
    port?: int32(name='Port'),
  }(name='ApplicationInfo'),
  code?: int32(name='Code'),
}

model InsertApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: InsertApplicationResponseBody(name='body'),
}

async function insertApplication(request: InsertApplicationRequest): InsertApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertApplicationWithOptions(request, headers, runtime);
}

async function insertApplicationWithOptions(request: InsertApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.buildPackId)) {
    query.BuildPackId = request.buildPackId;
  }
  if (!Util.isUnset(request.description)) {
    query.Description = request.description;
  }
  if (!Util.isUnset(request.applicationName)) {
    query.ApplicationName = request.applicationName;
  }
  if (!Util.isUnset(request.reservedPortStr)) {
    query.ReservedPortStr = request.reservedPortStr;
  }
  if (!Util.isUnset(request.ecuInfo)) {
    query.EcuInfo = request.ecuInfo;
  }
  if (!Util.isUnset(request.cpu)) {
    query.Cpu = request.cpu;
  }
  if (!Util.isUnset(request.mem)) {
    query.Mem = request.mem;
  }
  if (!Util.isUnset(request.healthCheckURL)) {
    query.HealthCheckURL = request.healthCheckURL;
  }
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }
  if (!Util.isUnset(request.jdk)) {
    query.Jdk = request.jdk;
  }
  if (!Util.isUnset(request.webContainer)) {
    query.WebContainer = request.webContainer;
  }
  if (!Util.isUnset(request.packageType)) {
    query.PackageType = request.packageType;
  }
  if (!Util.isUnset(request.componentIds)) {
    query.ComponentIds = request.componentIds;
  }
  if (!Util.isUnset(request.hooks)) {
    query.Hooks = request.hooks;
  }
  if (!Util.isUnset(request.jvmOptions)) {
    query.JvmOptions = request.jvmOptions;
  }
  if (!Util.isUnset(request.minHeapSize)) {
    query.MinHeapSize = request.minHeapSize;
  }
  if (!Util.isUnset(request.maxPermSize)) {
    query.MaxPermSize = request.maxPermSize;
  }
  if (!Util.isUnset(request.maxHeapSize)) {
    query.MaxHeapSize = request.maxHeapSize;
  }
  if (!Util.isUnset(request.enableUrlCheck)) {
    query.EnableUrlCheck = request.enableUrlCheck;
  }
  if (!Util.isUnset(request.enablePortCheck)) {
    query.EnablePortCheck = request.enablePortCheck;
  }
  if (!Util.isUnset(request.healthCheckUrl)) {
    query.HealthCheckUrl = request.healthCheckUrl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InsertApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_create_app`, 'json', req, runtime);
}

model InsertClusterRequest {
  logicalRegionId?: string(name='LogicalRegionId'),
  clusterName?: string(name='ClusterName'),
  clusterType?: int32(name='ClusterType'),
  networkMode?: int32(name='NetworkMode'),
  vpcId?: string(name='VpcId'),
  oversoldFactor?: int32(name='OversoldFactor'),
  iaasProvider?: string(name='IaasProvider'),
}

model InsertClusterResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  cluster?: {
    vpcId?: string(name='VpcId'),
    oversoldFactor?: int32(name='OversoldFactor'),
    networkMode?: int32(name='NetworkMode'),
    iaasProvider?: string(name='IaasProvider'),
    clusterType?: int32(name='ClusterType'),
    clusterName?: string(name='ClusterName'),
    clusterId?: string(name='ClusterId'),
    regionId?: string(name='RegionId'),
  }(name='Cluster'),
  code?: int32(name='Code'),
}

model InsertClusterResponse = {
  headers: map[string]string(name='headers'),
  body: InsertClusterResponseBody(name='body'),
}

async function insertCluster(request: InsertClusterRequest): InsertClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertClusterWithOptions(request, headers, runtime);
}

async function insertClusterWithOptions(request: InsertClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query.ClusterName = request.clusterName;
  }
  if (!Util.isUnset(request.clusterType)) {
    query.ClusterType = request.clusterType;
  }
  if (!Util.isUnset(request.networkMode)) {
    query.NetworkMode = request.networkMode;
  }
  if (!Util.isUnset(request.vpcId)) {
    query.VpcId = request.vpcId;
  }
  if (!Util.isUnset(request.oversoldFactor)) {
    query.OversoldFactor = request.oversoldFactor;
  }
  if (!Util.isUnset(request.iaasProvider)) {
    query.IaasProvider = request.iaasProvider;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InsertCluster', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/cluster`, 'json', req, runtime);
}

model InsertClusterMemberRequest {
  clusterId?: string(name='clusterId'),
  instanceIds?: string(name='instanceIds'),
  password?: string(name='password'),
}

model InsertClusterMemberResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: int32(name='Code'),
}

model InsertClusterMemberResponse = {
  headers: map[string]string(name='headers'),
  body: InsertClusterMemberResponseBody(name='body'),
}

async function insertClusterMember(request: InsertClusterMemberRequest): InsertClusterMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertClusterMemberWithOptions(request, headers, runtime);
}

async function insertClusterMemberWithOptions(request: InsertClusterMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertClusterMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query.clusterId = request.clusterId;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query.instanceIds = request.instanceIds;
  }
  if (!Util.isUnset(request.password)) {
    query.password = request.password;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InsertClusterMember', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/cluster_member`, 'json', req, runtime);
}

model InsertConfigCenterRequest {
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  data?: string(name='Data'),
  logicalRegionId?: string(name='LogicalRegionId'),
  appName?: string(name='AppName'),
}

model InsertConfigCenterResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model InsertConfigCenterResponse = {
  headers: map[string]string(name='headers'),
  body: InsertConfigCenterResponseBody(name='body'),
}

async function insertConfigCenter(request: InsertConfigCenterRequest): InsertConfigCenterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertConfigCenterWithOptions(request, headers, runtime);
}

async function insertConfigCenterWithOptions(request: InsertConfigCenterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertConfigCenterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.dataId)) {
    query.DataId = request.dataId;
  }
  if (!Util.isUnset(request.group)) {
    query.Group = request.group;
  }
  if (!Util.isUnset(request.data)) {
    query.Data = request.data;
  }
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }
  if (!Util.isUnset(request.appName)) {
    query.AppName = request.appName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InsertConfigCenter', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/configCenter`, 'json', req, runtime);
}

model InsertDegradeControlRequest {
  appId?: string(name='AppId'),
  duration?: int32(name='Duration'),
  methodName?: string(name='MethodName'),
  rtThreshold?: int32(name='RtThreshold'),
  serviceName?: string(name='ServiceName'),
  urlVar?: string(name='UrlVar'),
  ruleType?: string(name='RuleType'),
}

model InsertDegradeControlResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model InsertDegradeControlResponse = {
  headers: map[string]string(name='headers'),
  body: InsertDegradeControlResponseBody(name='body'),
}

async function insertDegradeControl(request: InsertDegradeControlRequest): InsertDegradeControlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertDegradeControlWithOptions(request, headers, runtime);
}

async function insertDegradeControlWithOptions(request: InsertDegradeControlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertDegradeControlResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.duration)) {
    query.Duration = request.duration;
  }
  if (!Util.isUnset(request.methodName)) {
    query.MethodName = request.methodName;
  }
  if (!Util.isUnset(request.rtThreshold)) {
    query.RtThreshold = request.rtThreshold;
  }
  if (!Util.isUnset(request.serviceName)) {
    query.ServiceName = request.serviceName;
  }
  if (!Util.isUnset(request.urlVar)) {
    query.UrlVar = request.urlVar;
  }
  if (!Util.isUnset(request.ruleType)) {
    query.RuleType = request.ruleType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InsertDegradeControl', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/degradeControl`, 'json', req, runtime);
}

model InsertDeployGroupRequest {
  appId?: string(name='AppId'),
  groupName?: string(name='GroupName'),
  initPackageVersionId?: string(name='InitPackageVersionId'),
}

model InsertDeployGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  deployGroupEntity?: {
    updateTime?: long(name='UpdateTime'),
    groupName?: string(name='GroupName'),
    createTime?: long(name='CreateTime'),
    appVersionId?: string(name='AppVersionId'),
    appId?: string(name='AppId'),
    packageVersionId?: string(name='PackageVersionId'),
    groupType?: int32(name='GroupType'),
    id?: string(name='Id'),
    clusterId?: string(name='ClusterId'),
  }(name='DeployGroupEntity'),
}

model InsertDeployGroupResponse = {
  headers: map[string]string(name='headers'),
  body: InsertDeployGroupResponseBody(name='body'),
}

async function insertDeployGroup(request: InsertDeployGroupRequest): InsertDeployGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertDeployGroupWithOptions(request, headers, runtime);
}

async function insertDeployGroupWithOptions(request: InsertDeployGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertDeployGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.groupName)) {
    query.GroupName = request.groupName;
  }
  if (!Util.isUnset(request.initPackageVersionId)) {
    query.InitPackageVersionId = request.initPackageVersionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InsertDeployGroup', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/deploy_group`, 'json', req, runtime);
}

model InsertFlowControlRequest {
  appId?: string(name='AppId'),
  consumerAppId?: string(name='ConsumerAppId'),
  granularity?: string(name='Granularity'),
  methodName?: string(name='MethodName'),
  ruleType?: string(name='RuleType'),
  serviceName?: string(name='ServiceName'),
  strategy?: string(name='Strategy'),
  threshold?: int32(name='Threshold'),
  urlVar?: string(name='UrlVar'),
}

model InsertFlowControlResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model InsertFlowControlResponse = {
  headers: map[string]string(name='headers'),
  body: InsertFlowControlResponseBody(name='body'),
}

async function insertFlowControl(request: InsertFlowControlRequest): InsertFlowControlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertFlowControlWithOptions(request, headers, runtime);
}

async function insertFlowControlWithOptions(request: InsertFlowControlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertFlowControlResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.consumerAppId)) {
    query.ConsumerAppId = request.consumerAppId;
  }
  if (!Util.isUnset(request.granularity)) {
    query.Granularity = request.granularity;
  }
  if (!Util.isUnset(request.methodName)) {
    query.MethodName = request.methodName;
  }
  if (!Util.isUnset(request.ruleType)) {
    query.RuleType = request.ruleType;
  }
  if (!Util.isUnset(request.serviceName)) {
    query.ServiceName = request.serviceName;
  }
  if (!Util.isUnset(request.strategy)) {
    query.Strategy = request.strategy;
  }
  if (!Util.isUnset(request.threshold)) {
    query.Threshold = request.threshold;
  }
  if (!Util.isUnset(request.urlVar)) {
    query.UrlVar = request.urlVar;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InsertFlowControl', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/flowControl`, 'json', req, runtime);
}

model InsertK8sApplicationRequest {
  intranetTargetPort?: int32(name='IntranetTargetPort'),
  intranetSlbPort?: int32(name='IntranetSlbPort'),
  imageUrl?: string(name='ImageUrl'),
  applicationDescription?: string(name='ApplicationDescription'),
  repoId?: string(name='RepoId'),
  replicas?: int32(name='Replicas'),
  limitCpu?: int32(name='LimitCpu'),
  limitMem?: int32(name='LimitMem'),
  requestsCpu?: int32(name='RequestsCpu'),
  requestsMem?: int32(name='RequestsMem'),
  command?: string(name='Command'),
  commandArgs?: string(name='CommandArgs'),
  appName?: string(name='AppName'),
  intranetSlbProtocol?: string(name='IntranetSlbProtocol'),
  intranetSlbId?: string(name='IntranetSlbId'),
  clusterId?: string(name='ClusterId'),
  internetSlbId?: string(name='InternetSlbId'),
  internetSlbProtocol?: string(name='InternetSlbProtocol'),
  internetSlbPort?: int32(name='InternetSlbPort'),
  internetTargetPort?: int32(name='InternetTargetPort'),
  envs?: string(name='Envs'),
  preStop?: string(name='PreStop'),
  postStart?: string(name='PostStart'),
  liveness?: string(name='Liveness'),
  readiness?: string(name='Readiness'),
  nasId?: string(name='NasId'),
  mountDescs?: string(name='MountDescs'),
  storageType?: string(name='StorageType'),
  localVolume?: string(name='LocalVolume'),
  namespace?: string(name='Namespace'),
  logicalRegionId?: string(name='LogicalRegionId'),
  packageType?: string(name='PackageType'),
  packageUrl?: string(name='PackageUrl'),
  packageVersion?: string(name='PackageVersion'),
  JDK?: string(name='JDK'),
  webContainer?: string(name='WebContainer'),
  edasContainerVersion?: string(name='EdasContainerVersion'),
  uriEncoding?: string(name='UriEncoding'),
  useBodyEncoding?: boolean(name='UseBodyEncoding'),
  requestsmCpu?: int32(name='RequestsmCpu'),
  limitmCpu?: int32(name='LimitmCpu'),
  runtimeClassName?: string(name='RuntimeClassName'),
  deployAcrossZones?: string(name='DeployAcrossZones'),
  timeout?: int32(name='Timeout'),
  enableAhas?: boolean(name='EnableAhas'),
  webContainerConfig?: string(name='WebContainerConfig'),
  javaStartUpConfig?: string(name='JavaStartUpConfig'),
  slsConfigs?: string(name='SlsConfigs'),
  isMultilingualApp?: boolean(name='IsMultilingualApp'),
  deployAcrossNodes?: string(name='DeployAcrossNodes'),
}

model InsertK8sApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  applicationInfo?: {
    changeOrderId?: string(name='ChangeOrderId'),
    appName?: string(name='AppName'),
    dockerize?: boolean(name='Dockerize'),
    owner?: string(name='Owner'),
    edasId?: string(name='EdasId'),
    clusterType?: int32(name='ClusterType'),
    appId?: string(name='AppId'),
    userId?: string(name='UserId'),
    regionId?: string(name='RegionId'),
  }(name='ApplicationInfo'),
  code?: int32(name='Code'),
}

model InsertK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: InsertK8sApplicationResponseBody(name='body'),
}

async function insertK8sApplication(request: InsertK8sApplicationRequest): InsertK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertK8sApplicationWithOptions(request, headers, runtime);
}

async function insertK8sApplicationWithOptions(request: InsertK8sApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertK8sApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.intranetTargetPort)) {
    query.IntranetTargetPort = request.intranetTargetPort;
  }
  if (!Util.isUnset(request.intranetSlbPort)) {
    query.IntranetSlbPort = request.intranetSlbPort;
  }
  if (!Util.isUnset(request.imageUrl)) {
    query.ImageUrl = request.imageUrl;
  }
  if (!Util.isUnset(request.applicationDescription)) {
    query.ApplicationDescription = request.applicationDescription;
  }
  if (!Util.isUnset(request.repoId)) {
    query.RepoId = request.repoId;
  }
  if (!Util.isUnset(request.replicas)) {
    query.Replicas = request.replicas;
  }
  if (!Util.isUnset(request.limitCpu)) {
    query.LimitCpu = request.limitCpu;
  }
  if (!Util.isUnset(request.limitMem)) {
    query.LimitMem = request.limitMem;
  }
  if (!Util.isUnset(request.requestsCpu)) {
    query.RequestsCpu = request.requestsCpu;
  }
  if (!Util.isUnset(request.requestsMem)) {
    query.RequestsMem = request.requestsMem;
  }
  if (!Util.isUnset(request.command)) {
    query.Command = request.command;
  }
  if (!Util.isUnset(request.commandArgs)) {
    query.CommandArgs = request.commandArgs;
  }
  if (!Util.isUnset(request.appName)) {
    query.AppName = request.appName;
  }
  if (!Util.isUnset(request.intranetSlbProtocol)) {
    query.IntranetSlbProtocol = request.intranetSlbProtocol;
  }
  if (!Util.isUnset(request.intranetSlbId)) {
    query.IntranetSlbId = request.intranetSlbId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.internetSlbId)) {
    query.InternetSlbId = request.internetSlbId;
  }
  if (!Util.isUnset(request.internetSlbProtocol)) {
    query.InternetSlbProtocol = request.internetSlbProtocol;
  }
  if (!Util.isUnset(request.internetSlbPort)) {
    query.InternetSlbPort = request.internetSlbPort;
  }
  if (!Util.isUnset(request.internetTargetPort)) {
    query.InternetTargetPort = request.internetTargetPort;
  }
  if (!Util.isUnset(request.envs)) {
    query.Envs = request.envs;
  }
  if (!Util.isUnset(request.preStop)) {
    query.PreStop = request.preStop;
  }
  if (!Util.isUnset(request.postStart)) {
    query.PostStart = request.postStart;
  }
  if (!Util.isUnset(request.liveness)) {
    query.Liveness = request.liveness;
  }
  if (!Util.isUnset(request.readiness)) {
    query.Readiness = request.readiness;
  }
  if (!Util.isUnset(request.nasId)) {
    query.NasId = request.nasId;
  }
  if (!Util.isUnset(request.mountDescs)) {
    query.MountDescs = request.mountDescs;
  }
  if (!Util.isUnset(request.storageType)) {
    query.StorageType = request.storageType;
  }
  if (!Util.isUnset(request.localVolume)) {
    query.LocalVolume = request.localVolume;
  }
  if (!Util.isUnset(request.namespace)) {
    query.Namespace = request.namespace;
  }
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }
  if (!Util.isUnset(request.packageType)) {
    query.PackageType = request.packageType;
  }
  if (!Util.isUnset(request.packageUrl)) {
    query.PackageUrl = request.packageUrl;
  }
  if (!Util.isUnset(request.packageVersion)) {
    query.PackageVersion = request.packageVersion;
  }
  if (!Util.isUnset(request.JDK)) {
    query.JDK = request.JDK;
  }
  if (!Util.isUnset(request.webContainer)) {
    query.WebContainer = request.webContainer;
  }
  if (!Util.isUnset(request.edasContainerVersion)) {
    query.EdasContainerVersion = request.edasContainerVersion;
  }
  if (!Util.isUnset(request.uriEncoding)) {
    query.UriEncoding = request.uriEncoding;
  }
  if (!Util.isUnset(request.useBodyEncoding)) {
    query.UseBodyEncoding = request.useBodyEncoding;
  }
  if (!Util.isUnset(request.requestsmCpu)) {
    query.RequestsmCpu = request.requestsmCpu;
  }
  if (!Util.isUnset(request.limitmCpu)) {
    query.LimitmCpu = request.limitmCpu;
  }
  if (!Util.isUnset(request.runtimeClassName)) {
    query.RuntimeClassName = request.runtimeClassName;
  }
  if (!Util.isUnset(request.deployAcrossZones)) {
    query.DeployAcrossZones = request.deployAcrossZones;
  }
  if (!Util.isUnset(request.timeout)) {
    query.Timeout = request.timeout;
  }
  if (!Util.isUnset(request.enableAhas)) {
    query.EnableAhas = request.enableAhas;
  }
  if (!Util.isUnset(request.webContainerConfig)) {
    query.WebContainerConfig = request.webContainerConfig;
  }
  if (!Util.isUnset(request.javaStartUpConfig)) {
    query.JavaStartUpConfig = request.javaStartUpConfig;
  }
  if (!Util.isUnset(request.slsConfigs)) {
    query.SlsConfigs = request.slsConfigs;
  }
  if (!Util.isUnset(request.isMultilingualApp)) {
    query.IsMultilingualApp = request.isMultilingualApp;
  }
  if (!Util.isUnset(request.deployAcrossNodes)) {
    query.DeployAcrossNodes = request.deployAcrossNodes;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InsertK8sApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s/acs/create_k8s_app`, 'json', req, runtime);
}

model InsertOrUpdateRegionRequest {
  regionTag?: string(name='RegionTag'),
  regionName?: string(name='RegionName'),
  description?: string(name='Description'),
  id?: long(name='Id'),
  debugEnable?: boolean(name='DebugEnable'),
}

model InsertOrUpdateRegionResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  userDefineRegionEntity?: {
    belongRegion?: string(name='BelongRegion'),
    regionName?: string(name='RegionName'),
    description?: string(name='Description'),
    debugEnable?: boolean(name='DebugEnable'),
    userId?: string(name='UserId'),
    id?: long(name='Id'),
    regionId?: string(name='RegionId'),
  }(name='UserDefineRegionEntity'),
  code?: int32(name='Code'),
}

model InsertOrUpdateRegionResponse = {
  headers: map[string]string(name='headers'),
  body: InsertOrUpdateRegionResponseBody(name='body'),
}

async function insertOrUpdateRegion(request: InsertOrUpdateRegionRequest): InsertOrUpdateRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertOrUpdateRegionWithOptions(request, headers, runtime);
}

async function insertOrUpdateRegionWithOptions(request: InsertOrUpdateRegionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertOrUpdateRegionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.regionTag)) {
    query.RegionTag = request.regionTag;
  }
  if (!Util.isUnset(request.regionName)) {
    query.RegionName = request.regionName;
  }
  if (!Util.isUnset(request.description)) {
    query.Description = request.description;
  }
  if (!Util.isUnset(request.id)) {
    query.Id = request.id;
  }
  if (!Util.isUnset(request.debugEnable)) {
    query.DebugEnable = request.debugEnable;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InsertOrUpdateRegion', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/user_region_def`, 'json', req, runtime);
}

model InsertRoleRequest {
  roleName?: string(name='RoleName'),
  actionData?: string(name='ActionData'),
}

model InsertRoleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  roleId?: int32(name='RoleId'),
}

model InsertRoleResponse = {
  headers: map[string]string(name='headers'),
  body: InsertRoleResponseBody(name='body'),
}

async function insertRole(request: InsertRoleRequest): InsertRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertRoleWithOptions(request, headers, runtime);
}

async function insertRoleWithOptions(request: InsertRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertRoleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.roleName)) {
    query.RoleName = request.roleName;
  }
  if (!Util.isUnset(request.actionData)) {
    query.ActionData = request.actionData;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InsertRole', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/create_role`, 'json', req, runtime);
}

model InsertServiceGroupRequest {
  groupName?: string(name='GroupName'),
}

model InsertServiceGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model InsertServiceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: InsertServiceGroupResponseBody(name='body'),
}

async function insertServiceGroup(request: InsertServiceGroupRequest): InsertServiceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertServiceGroupWithOptions(request, headers, runtime);
}

async function insertServiceGroupWithOptions(request: InsertServiceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertServiceGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.groupName)) {
    query.GroupName = request.groupName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InsertServiceGroup', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/service/serviceGroups`, 'json', req, runtime);
}

model InsertSwimmingLaneRequest {
  logicalRegionId?: string(name='LogicalRegionId'),
  name?: string(name='Name'),
  tag?: string(name='Tag'),
  groupId?: long(name='GroupId'),
  entryRules?: string(name='EntryRules'),
  enableRules?: boolean(name='EnableRules'),
  appInfos?: string(name='AppInfos'),
}

model InsertSwimmingLaneResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    namespaceId?: string(name='NamespaceId'),
    groupId?: long(name='GroupId'),
    entryRule?: string(name='EntryRule'),
    appInfos?: string(name='AppInfos'),
    tag?: string(name='Tag'),
    name?: string(name='Name'),
    swimmingLaneAppRelationShipList?: [ 
      {
        appName?: string(name='AppName'),
        appId?: string(name='AppId'),
        rules?: string(name='Rules'),
        laneId?: long(name='LaneId'),
      }
    ](name='SwimmingLaneAppRelationShipList'),
    id?: long(name='Id'),
  }(name='Data'),
  code?: int32(name='Code'),
}

model InsertSwimmingLaneResponse = {
  headers: map[string]string(name='headers'),
  body: InsertSwimmingLaneResponseBody(name='body'),
}

async function insertSwimmingLane(request: InsertSwimmingLaneRequest): InsertSwimmingLaneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertSwimmingLaneWithOptions(request, headers, runtime);
}

async function insertSwimmingLaneWithOptions(request: InsertSwimmingLaneRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertSwimmingLaneResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }
  if (!Util.isUnset(request.tag)) {
    query.Tag = request.tag;
  }
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }
  if (!Util.isUnset(request.entryRules)) {
    query.EntryRules = request.entryRules;
  }
  if (!Util.isUnset(request.enableRules)) {
    query.EnableRules = request.enableRules;
  }
  if (!Util.isUnset(request.appInfos)) {
    query.AppInfos = request.appInfos;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InsertSwimmingLane', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/trafficmgnt/swimming_lanes`, 'json', req, runtime);
}

model InsertSwimmingLaneGroupRequest {
  name?: string(name='Name'),
  entryApp?: string(name='EntryApp'),
  appIds?: string(name='AppIds'),
  logicalRegionId?: string(name='LogicalRegionId'),
}

model InsertSwimmingLaneGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    namespaceId?: string(name='NamespaceId'),
    applicationList?: {
      application?: [ 
      {
        appName?: string(name='AppName'),
        appId?: string(name='AppId'),
      }
    ](name='Application')
    }(name='ApplicationList'),
    entryApplication?: {
      appName?: string(name='AppName'),
      appId?: string(name='AppId'),
    }(name='EntryApplication'),
    name?: string(name='Name'),
    id?: long(name='Id'),
  }(name='Data'),
  code?: int32(name='Code'),
}

model InsertSwimmingLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  body: InsertSwimmingLaneGroupResponseBody(name='body'),
}

async function insertSwimmingLaneGroup(request: InsertSwimmingLaneGroupRequest): InsertSwimmingLaneGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return insertSwimmingLaneGroupWithOptions(request, headers, runtime);
}

async function insertSwimmingLaneGroupWithOptions(request: InsertSwimmingLaneGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InsertSwimmingLaneGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }
  if (!Util.isUnset(request.entryApp)) {
    query.EntryApp = request.entryApp;
  }
  if (!Util.isUnset(request.appIds)) {
    query.AppIds = request.appIds;
  }
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InsertSwimmingLaneGroup', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/trafficmgnt/swimming_lane_groups`, 'json', req, runtime);
}

model InstallAgentRequest {
  clusterId?: string(name='ClusterId'),
  instanceIds?: string(name='InstanceIds'),
  doAsync?: boolean(name='DoAsync'),
}

model InstallAgentResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  executionResultList?: {
    executionResult?: [ 
    {
      status?: string(name='Status'),
      success?: boolean(name='Success'),
      finishedTime?: string(name='FinishedTime'),
      instanceId?: string(name='InstanceId'),
      invokeRecordStatus?: string(name='InvokeRecordStatus'),
    }
  ](name='ExecutionResult')
  }(name='ExecutionResultList'),
  code?: int32(name='Code'),
}

model InstallAgentResponse = {
  headers: map[string]string(name='headers'),
  body: InstallAgentResponseBody(name='body'),
}

async function installAgent(request: InstallAgentRequest): InstallAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installAgentWithOptions(request, headers, runtime);
}

async function installAgentWithOptions(request: InstallAgentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallAgentResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query.InstanceIds = request.instanceIds;
  }
  if (!Util.isUnset(request.doAsync)) {
    query.DoAsync = request.doAsync;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InstallAgent', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/ecss/install_agent`, 'json', req, runtime);
}

model ListAliyunRegionResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  regionEntityList?: {
    regionEntity?: [ 
    {
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='RegionEntity')
  }(name='RegionEntityList'),
}

model ListAliyunRegionResponse = {
  headers: map[string]string(name='headers'),
  body: ListAliyunRegionResponseBody(name='body'),
}

async function listAliyunRegion(): ListAliyunRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAliyunRegionWithOptions(headers, runtime);
}

async function listAliyunRegionWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListAliyunRegionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListAliyunRegion', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/region_list`, 'json', req, runtime);
}

model ListApplicationRequest {
  clusterId?: string(name='ClusterId'),
  logicalRegionId?: string(name='LogicalRegionId'),
  appName?: string(name='AppName'),
  resourceGroupId?: string(name='ResourceGroupId'),
  logicalRegionIdFilter?: string(name='LogicalRegionIdFilter'),
}

model ListApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  applicationList?: {
    application?: [ 
    {
      clusterType?: int32(name='ClusterType'),
      appId?: string(name='AppId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      applicationType?: string(name='ApplicationType'),
      name?: string(name='Name'),
      runningInstanceCount?: int32(name='RunningInstanceCount'),
      buildPackageId?: long(name='BuildPackageId'),
      clusterId?: string(name='ClusterId'),
      regionId?: string(name='RegionId'),
    }
  ](name='Application')
  }(name='ApplicationList'),
  code?: int32(name='Code'),
}

model ListApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: ListApplicationResponseBody(name='body'),
}

async function listApplication(request: ListApplicationRequest): ListApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listApplicationWithOptions(request, headers, runtime);
}

async function listApplicationWithOptions(request: ListApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }
  if (!Util.isUnset(request.appName)) {
    query.AppName = request.appName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query.ResourceGroupId = request.resourceGroupId;
  }
  if (!Util.isUnset(request.logicalRegionIdFilter)) {
    query.LogicalRegionIdFilter = request.logicalRegionIdFilter;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/app_list`, 'json', req, runtime);
}

model ListApplicationEcuRequest {
  appId?: string(name='AppId'),
}

model ListApplicationEcuResponseBody = {
  ecuInfoList?: {
    ecuEntity?: [ 
    {
      vpcId?: string(name='VpcId'),
      updateTime?: long(name='UpdateTime'),
      ipAddr?: string(name='IpAddr'),
      availableCpu?: int32(name='AvailableCpu'),
      createTime?: long(name='CreateTime'),
      userId?: string(name='UserId'),
      instanceId?: string(name='InstanceId'),
      mem?: int32(name='Mem'),
      regionId?: string(name='RegionId'),
      ecuId?: string(name='EcuId'),
      cpu?: int32(name='Cpu'),
      appId?: string(name='AppId'),
      dockerEnv?: boolean(name='DockerEnv'),
      online?: boolean(name='Online'),
      availableMem?: int32(name='AvailableMem'),
      zoneId?: string(name='ZoneId'),
      name?: string(name='Name'),
      heartbeatTime?: long(name='HeartbeatTime'),
    }
  ](name='EcuEntity')
  }(name='EcuInfoList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model ListApplicationEcuResponse = {
  headers: map[string]string(name='headers'),
  body: ListApplicationEcuResponseBody(name='body'),
}

async function listApplicationEcu(request: ListApplicationEcuRequest): ListApplicationEcuResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listApplicationEcuWithOptions(request, headers, runtime);
}

async function listApplicationEcuWithOptions(request: ListApplicationEcuRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListApplicationEcuResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListApplicationEcu', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/ecu_list`, 'json', req, runtime);
}

model ListAuthorityResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  authorityList?: {
    authority?: [ 
    {
      groupId?: string(name='GroupId'),
      description?: string(name='Description'),
      actionList?: {
        action?: [ 
        {
          description?: string(name='Description'),
          groupId?: string(name='GroupId'),
          code?: string(name='Code'),
          name?: string(name='Name'),
        }
      ](name='Action')
      }(name='ActionList'),
      name?: string(name='Name'),
    }
  ](name='Authority')
  }(name='AuthorityList'),
}

model ListAuthorityResponse = {
  headers: map[string]string(name='headers'),
  body: ListAuthorityResponseBody(name='body'),
}

async function listAuthority(): ListAuthorityResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAuthorityWithOptions(headers, runtime);
}

async function listAuthorityWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListAuthorityResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListAuthority', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/authority_list`, 'json', req, runtime);
}

model ListBuildPackResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  buildPackList?: {
    buildPack?: [ 
    {
      configId?: long(name='ConfigId'),
      pandoraVersion?: string(name='PandoraVersion'),
      pandoraDesc?: string(name='PandoraDesc'),
      feature?: string(name='Feature'),
      pluginInfo?: string(name='PluginInfo'),
      tengineDownloadUrl?: string(name='TengineDownloadUrl'),
      disabled?: boolean(name='Disabled'),
      tomcatPath?: string(name='TomcatPath'),
      tomcatDesc?: string(name='TomcatDesc'),
      supportFeatures?: string(name='SupportFeatures'),
      tomcatDownloadUrl?: string(name='TomcatDownloadUrl'),
      tomcatVersion?: string(name='TomcatVersion'),
      pandoraDownloadUrl?: string(name='PandoraDownloadUrl'),
      packVersion?: string(name='PackVersion'),
      multipleTenant?: boolean(name='MultipleTenant'),
      tengineImageId?: string(name='TengineImageId'),
      withTengine?: boolean(name='WithTengine'),
      imageId?: string(name='ImageId'),
      scriptName?: string(name='ScriptName'),
      scriptVersion?: string(name='ScriptVersion'),
    }
  ](name='BuildPack')
  }(name='BuildPackList'),
  code?: int32(name='Code'),
}

model ListBuildPackResponse = {
  headers: map[string]string(name='headers'),
  body: ListBuildPackResponseBody(name='body'),
}

async function listBuildPack(): ListBuildPackResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listBuildPackWithOptions(headers, runtime);
}

async function listBuildPackWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListBuildPackResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListBuildPack', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/build_pack_list`, 'json', req, runtime);
}

model ListChildrenStacksRequest {
  stackId?: long(name='StackId'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
}

model ListChildrenStacksResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    result?: [ 
      {
        comment?: string(name='Comment'),
        buildTypes?: [ string ](name='BuildTypes'),
        latest?: boolean(name='Latest'),
        name?: string(name='Name'),
        preferred?: boolean(name='Preferred'),
        id?: long(name='Id'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
    pageSize?: int32(name='PageSize'),
  }(name='Data'),
  code?: int32(name='Code'),
}

model ListChildrenStacksResponse = {
  headers: map[string]string(name='headers'),
  body: ListChildrenStacksResponseBody(name='body'),
}

async function listChildrenStacks(request: ListChildrenStacksRequest): ListChildrenStacksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listChildrenStacksWithOptions(request, headers, runtime);
}

async function listChildrenStacksWithOptions(request: ListChildrenStacksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListChildrenStacksResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.stackId)) {
    query.StackId = request.stackId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query.CurrentPage = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListChildrenStacks', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/s2i/list_children_stack`, 'json', req, runtime);
}

model ListClusterRequest {
  logicalRegionId?: string(name='LogicalRegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListClusterResponseBody = {
  clusterList?: {
    cluster?: [ 
    {
      oversoldFactor?: int32(name='OversoldFactor'),
      vpcId?: string(name='VpcId'),
      updateTime?: long(name='UpdateTime'),
      memUsed?: int32(name='MemUsed'),
      iaasProvider?: string(name='IaasProvider'),
      createTime?: long(name='CreateTime'),
      cpuUsed?: int32(name='CpuUsed'),
      mem?: int32(name='Mem'),
      regionId?: string(name='RegionId'),
      cpu?: int32(name='Cpu'),
      csClusterId?: string(name='CsClusterId'),
      description?: string(name='Description'),
      networkMode?: int32(name='NetworkMode'),
      clusterType?: int32(name='ClusterType'),
      resourceGroupId?: string(name='ResourceGroupId'),
      clusterName?: string(name='ClusterName'),
      nodeNum?: int32(name='NodeNum'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='Cluster')
  }(name='ClusterList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model ListClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterResponseBody(name='body'),
}

async function listCluster(request: ListClusterRequest): ListClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listClusterWithOptions(request, headers, runtime);
}

async function listClusterWithOptions(request: ListClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query.ResourceGroupId = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListCluster', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/cluster_list`, 'json', req, runtime);
}

model ListClusterMembersRequest {
  clusterId?: string(name='ClusterId'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  ecsList?: string(name='EcsList'),
}

model ListClusterMembersResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  clusterMemberPage?: {
    currentPage?: int32(name='CurrentPage'),
    totalSize?: int32(name='TotalSize'),
    pageSize?: int32(name='PageSize'),
    clusterMemberList?: {
      clusterMember?: [ 
      {
        status?: int32(name='Status'),
        updateTime?: long(name='UpdateTime'),
        ecuId?: string(name='EcuId'),
        ecsId?: string(name='EcsId'),
        createTime?: long(name='CreateTime'),
        clusterMemberId?: string(name='ClusterMemberId'),
        clusterId?: string(name='ClusterId'),
      }
    ](name='ClusterMember')
    }(name='ClusterMemberList'),
  }(name='ClusterMemberPage'),
  code?: int32(name='Code'),
}

model ListClusterMembersResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterMembersResponseBody(name='body'),
}

async function listClusterMembers(request: ListClusterMembersRequest): ListClusterMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listClusterMembersWithOptions(request, headers, runtime);
}

async function listClusterMembersWithOptions(request: ListClusterMembersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListClusterMembersResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query.CurrentPage = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.ecsList)) {
    query.EcsList = request.ecsList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListClusterMembers', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/cluster_member_list`, 'json', req, runtime);
}

model ListComponentsResponseBody = {
  message?: string(name='Message'),
  componentList?: {
    component?: [ 
    {
      type?: string(name='Type'),
      componentKey?: string(name='ComponentKey'),
      version?: string(name='Version'),
      expired?: boolean(name='Expired'),
      componentId?: string(name='ComponentId'),
      desc?: string(name='Desc'),
    }
  ](name='Component')
  }(name='ComponentList'),
  code?: int32(name='Code'),
}

model ListComponentsResponse = {
  headers: map[string]string(name='headers'),
  body: ListComponentsResponseBody(name='body'),
}

async function listComponents(): ListComponentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listComponentsWithOptions(headers, runtime);
}

async function listComponentsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListComponentsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListComponents', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/components`, 'json', req, runtime);
}

model ListConfigCentersRequest {
  dataIdPattern?: string(name='DataIdPattern'),
  group?: string(name='Group'),
  logicalRegionId?: string(name='LogicalRegionId'),
  appName?: string(name='AppName'),
}

model ListConfigCentersResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  configCentersList?: {
    listConfigCenters?: [ 
    {
      appName?: string(name='AppName'),
      dataId?: string(name='DataId'),
      id?: string(name='Id'),
      group?: string(name='Group'),
    }
  ](name='ListConfigCenters')
  }(name='ConfigCentersList'),
  code?: int32(name='Code'),
}

model ListConfigCentersResponse = {
  headers: map[string]string(name='headers'),
  body: ListConfigCentersResponseBody(name='body'),
}

async function listConfigCenters(request: ListConfigCentersRequest): ListConfigCentersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConfigCentersWithOptions(request, headers, runtime);
}

async function listConfigCentersWithOptions(request: ListConfigCentersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListConfigCentersResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.dataIdPattern)) {
    query.DataIdPattern = request.dataIdPattern;
  }
  if (!Util.isUnset(request.group)) {
    query.Group = request.group;
  }
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }
  if (!Util.isUnset(request.appName)) {
    query.AppName = request.appName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListConfigCenters', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/configCenters`, 'json', req, runtime);
}

model ListConsumedServicesRequest {
  appId?: string(name='AppId'),
}

model ListConsumedServicesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  consumedServicesList?: {
    listConsumedServices?: [ 
    {
      dockerApplication?: boolean(name='DockerApplication'),
      type?: string(name='Type'),
      groups?: {
        group?: [ string ](name='group')
      }(name='Groups'),
      version?: string(name='Version'),
      appId?: string(name='AppId'),
      group2Ip?: string(name='Group2Ip'),
      ips?: {
        ip?: [ string ](name='ip')
      }(name='Ips'),
      name?: string(name='Name'),
    }
  ](name='ListConsumedServices')
  }(name='ConsumedServicesList'),
  code?: int32(name='Code'),
}

model ListConsumedServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListConsumedServicesResponseBody(name='body'),
}

async function listConsumedServices(request: ListConsumedServicesRequest): ListConsumedServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConsumedServicesWithOptions(request, headers, runtime);
}

async function listConsumedServicesWithOptions(request: ListConsumedServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListConsumedServicesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListConsumedServices', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/service/listConsumedServices`, 'json', req, runtime);
}

model ListConvertableEcuRequest {
  clusterId?: string(name='clusterId'),
}

model ListConvertableEcuResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  instanceList?: {
    instance?: [ 
    {
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      privateIp?: string(name='PrivateIp'),
      expired?: boolean(name='Expired'),
      instanceId?: string(name='InstanceId'),
      mem?: int32(name='Mem'),
      regionId?: string(name='RegionId'),
      vpcName?: string(name='VpcName'),
      ecuId?: string(name='EcuId'),
      innerIp?: string(name='InnerIp'),
      cpu?: int32(name='Cpu'),
      eip?: string(name='Eip'),
      instanceName?: string(name='InstanceName'),
      publicIp?: string(name='PublicIp'),
    }
  ](name='Instance')
  }(name='InstanceList'),
  code?: int32(name='Code'),
}

model ListConvertableEcuResponse = {
  headers: map[string]string(name='headers'),
  body: ListConvertableEcuResponseBody(name='body'),
}

async function listConvertableEcu(request: ListConvertableEcuRequest): ListConvertableEcuResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConvertableEcuWithOptions(request, headers, runtime);
}

async function listConvertableEcuWithOptions(request: ListConvertableEcuRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListConvertableEcuResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query.clusterId = request.clusterId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListConvertableEcu', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/convertable_ecu_list`, 'json', req, runtime);
}

model ListCSBGatewayRequest {
  logicalRegionId?: string(name='LogicalRegionId'),
}

model ListCSBGatewayResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      gatewayType?: string(name='GatewayType'),
      name?: string(name='Name'),
      id?: long(name='Id'),
    }
  ](name='Data'),
  code?: int32(name='Code'),
}

model ListCSBGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: ListCSBGatewayResponseBody(name='body'),
}

async function listCSBGateway(request: ListCSBGatewayRequest): ListCSBGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCSBGatewayWithOptions(request, headers, runtime);
}

async function listCSBGatewayWithOptions(request: ListCSBGatewayRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCSBGatewayResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListCSBGateway', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/csbgateway/gateway`, 'json', req, runtime);
}

model ListDegradeControlsRequest {
  appId?: string(name='AppId'),
}

model ListDegradeControlsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  flowControlsMap?: {
    interfaceMethods?: {
      interfaceMethod?: [ 
      {
        version?: string(name='Version'),
        name?: string(name='name'),
        methods?: {
          method?: [ string ](name='Method')
        }(name='Methods'),
      }
    ](name='InterfaceMethod')
    }(name='InterfaceMethods'),
    appName?: string(name='AppName'),
    appId?: string(name='AppId'),
    ruleList?: {
      currentPage?: int32(name='CurrentPage'),
      totalSize?: int32(name='TotalSize'),
      ruleResultList?: {
        rule?: [ 
        {
          resource?: string(name='Resource'),
          ruleType?: string(name='RuleType'),
          updateTime?: long(name='UpdateTime'),
          state?: int32(name='State'),
          createTime?: long(name='CreateTime'),
          appId?: string(name='AppId'),
          duration?: int32(name='Duration'),
          rtThreshold?: int32(name='RtThreshold'),
          ruleId?: string(name='RuleId'),
        }
      ](name='Rule')
      }(name='RuleResultList'),
      pageSize?: int32(name='pageSize'),
    }(name='RuleList'),
  }(name='FlowControlsMap'),
  code?: int32(name='Code'),
}

model ListDegradeControlsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDegradeControlsResponseBody(name='body'),
}

async function listDegradeControls(request: ListDegradeControlsRequest): ListDegradeControlsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDegradeControlsWithOptions(request, headers, runtime);
}

async function listDegradeControlsWithOptions(request: ListDegradeControlsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDegradeControlsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListDegradeControls', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/app/degradeControls`, 'json', req, runtime);
}

model ListDeployGroupRequest {
  appId?: string(name='AppId'),
}

model ListDeployGroupResponseBody = {
  deployGroupList?: {
    deployGroup?: [ 
    {
      VServerGroupId?: string(name='VServerGroupId'),
      status?: string(name='Status'),
      cpuRequest?: string(name='CpuRequest'),
      updateTime?: long(name='UpdateTime'),
      memoryRequest?: string(name='MemoryRequest'),
      nameSpace?: string(name='NameSpace'),
      appVersionId?: string(name='AppVersionId'),
      createTime?: long(name='CreateTime'),
      deploymentName?: string(name='DeploymentName'),
      preStop?: string(name='PreStop'),
      packageUrl?: string(name='PackageUrl'),
      packageVersion?: string(name='PackageVersion'),
      baseComponentMetaName?: string(name='BaseComponentMetaName'),
      csClusterId?: string(name='CsClusterId'),
      appId?: string(name='AppId'),
      env?: string(name='Env'),
      lastUpdateTime?: long(name='LastUpdateTime'),
      groupType?: int32(name='GroupType'),
      cpuLimit?: string(name='CpuLimit'),
      clusterId?: string(name='ClusterId'),
      postStart?: string(name='PostStart'),
      labels?: string(name='Labels'),
      memoryLimit?: string(name='MemoryLimit'),
      strategy?: string(name='Strategy'),
      selector?: string(name='Selector'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      clusterName?: string(name='ClusterName'),
      packageVersionId?: string(name='PackageVersionId'),
      reversion?: string(name='Reversion'),
      VExtServerGroupId?: string(name='VExtServerGroupId'),
      packagePublicUrl?: string(name='PackagePublicUrl'),
    }
  ](name='DeployGroup')
  }(name='DeployGroupList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model ListDeployGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListDeployGroupResponseBody(name='body'),
}

async function listDeployGroup(request: ListDeployGroupRequest): ListDeployGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeployGroupWithOptions(request, headers, runtime);
}

async function listDeployGroupWithOptions(request: ListDeployGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeployGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListDeployGroup', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/deploy_group_list`, 'json', req, runtime);
}

model ListEcsNotInClusterRequest {
  networkMode?: int32(name='NetworkMode'),
  vpcId?: string(name='VpcId'),
}

model ListEcsNotInClusterResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  ecsEntityList?: {
    ecsEntity?: [ 
    {
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      privateIp?: string(name='PrivateIp'),
      expired?: boolean(name='Expired'),
      instanceId?: string(name='InstanceId'),
      mem?: int32(name='Mem'),
      regionId?: string(name='RegionId'),
      vpcName?: string(name='VpcName'),
      innerIp?: string(name='InnerIp'),
      cpu?: int32(name='Cpu'),
      eip?: string(name='Eip'),
      instanceName?: string(name='InstanceName'),
      publicIp?: string(name='PublicIp'),
    }
  ](name='EcsEntity')
  }(name='EcsEntityList'),
}

model ListEcsNotInClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ListEcsNotInClusterResponseBody(name='body'),
}

async function listEcsNotInCluster(request: ListEcsNotInClusterRequest): ListEcsNotInClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEcsNotInClusterWithOptions(request, headers, runtime);
}

async function listEcsNotInClusterWithOptions(request: ListEcsNotInClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEcsNotInClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.networkMode)) {
    query.NetworkMode = request.networkMode;
  }
  if (!Util.isUnset(request.vpcId)) {
    query.VpcId = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListEcsNotInCluster', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/ecs_not_in_cluster`, 'json', req, runtime);
}

model ListEcuByRegionRequest {
  logicalRegionId?: string(name='LogicalRegionId'),
  act?: string(name='Act'),
}

model ListEcuByRegionResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  ecuEntityList?: {
    ecuEntity?: [ 
    {
      vpcId?: string(name='VpcId'),
      updateTime?: long(name='UpdateTime'),
      ipAddr?: string(name='IpAddr'),
      availableCpu?: int32(name='AvailableCpu'),
      createTime?: long(name='CreateTime'),
      userId?: string(name='UserId'),
      instanceId?: string(name='InstanceId'),
      mem?: int32(name='Mem'),
      regionId?: string(name='RegionId'),
      ecuId?: string(name='EcuId'),
      cpu?: int32(name='Cpu'),
      dockerEnv?: boolean(name='DockerEnv'),
      online?: boolean(name='Online'),
      availableMem?: int32(name='AvailableMem'),
      zoneId?: string(name='ZoneId'),
      name?: string(name='Name'),
      heartbeatTime?: long(name='HeartbeatTime'),
    }
  ](name='EcuEntity')
  }(name='EcuEntityList'),
  code?: int32(name='Code'),
}

model ListEcuByRegionResponse = {
  headers: map[string]string(name='headers'),
  body: ListEcuByRegionResponseBody(name='body'),
}

async function listEcuByRegion(request: ListEcuByRegionRequest): ListEcuByRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEcuByRegionWithOptions(request, headers, runtime);
}

async function listEcuByRegionWithOptions(request: ListEcuByRegionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEcuByRegionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }
  if (!Util.isUnset(request.act)) {
    query.Act = request.act;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListEcuByRegion', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/ecu_list`, 'json', req, runtime);
}

model ListFlowControlsRequest {
  appId?: string(name='AppId'),
}

model ListFlowControlsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  flowControlsMap?: {
    appList?: {
      app?: [ 
      {
        slbId?: string(name='SlbId'),
        extSlbIp?: string(name='ExtSlbIp'),
        healthCheckUrl?: string(name='HealthCheckUrl'),
        owner?: string(name='Owner'),
        slbPort?: int32(name='SlbPort'),
        createTime?: long(name='CreateTime'),
        userId?: string(name='UserId'),
        applicationType?: string(name='ApplicationType'),
        extSlbId?: string(name='ExtSlbId'),
        port?: int32(name='Port'),
        runningInstanceCount?: int32(name='RunningInstanceCount'),
        slbIp?: string(name='SlbIp'),
        buildPackageId?: long(name='BuildPackageId'),
        regionId?: string(name='RegionId'),
        dockerize?: boolean(name='Dockerize'),
        cpu?: int32(name='Cpu'),
        instanceCount?: int32(name='InstanceCount'),
        description?: string(name='Description'),
        clusterType?: int32(name='ClusterType'),
        appId?: string(name='AppId'),
        memory?: int32(name='Memory'),
        name?: string(name='Name'),
        clusterId?: string(name='ClusterId'),
      }
    ](name='App')
    }(name='AppList'),
    interfaceMethods?: {
      interfaceMethod?: [ 
      {
        version?: string(name='Version'),
        name?: string(name='name'),
        methods?: {
          method?: [ string ](name='Method')
        }(name='Methods'),
      }
    ](name='InterfaceMethod')
    }(name='InterfaceMethods'),
    appName?: string(name='AppName'),
    appId?: string(name='AppId'),
    ruleList?: {
      currentPage?: int32(name='CurrentPage'),
      totalSize?: int32(name='TotalSize'),
      ruleResultList?: {
        rule?: [ 
        {
          updateTime?: long(name='UpdateTime'),
          ruleType?: string(name='RuleType'),
          state?: int32(name='State'),
          createTime?: long(name='CreateTime'),
          consumerAppId?: string(name='ConsumerAppId'),
          ruleId?: string(name='RuleId'),
          strategy?: string(name='Strategy'),
          resource?: string(name='Resource'),
          appId?: string(name='AppId'),
          granularity?: string(name='Granularity'),
          threshold?: int32(name='Threshold'),
          id?: string(name='Id'),
        }
      ](name='Rule')
      }(name='RuleResultList'),
      pageSize?: int32(name='pageSize'),
    }(name='RuleList'),
  }(name='FlowControlsMap'),
  code?: int32(name='Code'),
}

model ListFlowControlsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowControlsResponseBody(name='body'),
}

async function listFlowControls(request: ListFlowControlsRequest): ListFlowControlsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFlowControlsWithOptions(request, headers, runtime);
}

async function listFlowControlsWithOptions(request: ListFlowControlsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFlowControlsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListFlowControls', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/app/flowControls`, 'json', req, runtime);
}

model ListHistoryDeployVersionRequest {
  appId?: string(name='AppId'),
}

model ListHistoryDeployVersionResponseBody = {
  packageVersionList?: {
    packageVersion?: [ 
    {
      type?: string(name='Type'),
      publicUrl?: string(name='PublicUrl'),
      updateTime?: long(name='UpdateTime'),
      description?: string(name='Description'),
      createTime?: long(name='CreateTime'),
      appId?: string(name='AppId'),
      warUrl?: string(name='WarUrl'),
      id?: string(name='Id'),
      packageVersion?: string(name='PackageVersion'),
    }
  ](name='PackageVersion')
  }(name='PackageVersionList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model ListHistoryDeployVersionResponse = {
  headers: map[string]string(name='headers'),
  body: ListHistoryDeployVersionResponseBody(name='body'),
}

async function listHistoryDeployVersion(request: ListHistoryDeployVersionRequest): ListHistoryDeployVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listHistoryDeployVersionWithOptions(request, headers, runtime);
}

async function listHistoryDeployVersionWithOptions(request: ListHistoryDeployVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListHistoryDeployVersionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListHistoryDeployVersion', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/app/deploy_history_version_list`, 'json', req, runtime);
}

model ListK8sIngressRulesRequest {
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  namespace?: string(name='Namespace'),
}

model ListK8sIngressRulesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  ingressConfigs?: [ 
    {
      clusterName?: string(name='ClusterName'),
      ingressRules?: [ 
        {
          creationTime?: string(name='CreationTime'),
          ingressPaths?: [ 
            {
              status?: string(name='Status'),
              appName?: string(name='AppName'),
              host?: string(name='Host'),
              servicePort?: int32(name='ServicePort'),
              appId?: string(name='AppId'),
              path?: string(name='Path'),
              serviceName?: string(name='ServiceName'),
            }
          ](name='IngressPaths'),
          endpoint?: string(name='Endpoint'),
          namespace?: string(name='Namespace'),
          name?: string(name='Name'),
        }
      ](name='IngressRules'),
      clusterId?: string(name='ClusterId'),
      regionId?: string(name='RegionId'),
    }
  ](name='IngressConfigs'),
  code?: int32(name='Code'),
}

model ListK8sIngressRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListK8sIngressRulesResponseBody(name='body'),
}

async function listK8sIngressRules(request: ListK8sIngressRulesRequest): ListK8sIngressRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listK8sIngressRulesWithOptions(request, headers, runtime);
}

async function listK8sIngressRulesWithOptions(request: ListK8sIngressRulesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListK8sIngressRulesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.regionId)) {
    query.RegionId = request.regionId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.namespace)) {
    query.Namespace = request.namespace;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListK8sIngressRules', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/k8s/acs/k8s_ingress`, 'json', req, runtime);
}

model ListMethodsRequest {
  appId?: string(name='AppId'),
  serviceName?: string(name='ServiceName'),
}

model ListMethodsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  serviceMethodList?: {
    serviceMethod?: [ 
    {
      methodName?: string(name='MethodName'),
      paramTypes?: {
        paramType?: [ string ](name='ParamType')
      }(name='ParamTypes'),
      inputParams?: {
        inputParam?: [ string ](name='InputParam')
      }(name='InputParams'),
      appName?: string(name='AppName'),
      output?: string(name='Output'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='ServiceMethod')
  }(name='ServiceMethodList'),
  code?: int32(name='Code'),
}

model ListMethodsResponse = {
  headers: map[string]string(name='headers'),
  body: ListMethodsResponseBody(name='body'),
}

async function listMethods(request: ListMethodsRequest): ListMethodsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMethodsWithOptions(request, headers, runtime);
}

async function listMethodsWithOptions(request: ListMethodsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMethodsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query.ServiceName = request.serviceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListMethods', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/service/list_methods`, 'json', req, runtime);
}

model ListOperationLogsRequest {
  appId?: string(name='AppId'),
  beginTime?: long(name='BeginTime'),
  endTime?: long(name='EndTime'),
  userId?: string(name='UserId'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
}

model ListOperationLogsResponseBody = {
  logList?: [ 
    {
      status?: string(name='Status'),
      endTime?: long(name='EndTime'),
      actionGroup?: string(name='ActionGroup'),
      operatorId?: string(name='OperatorId'),
      operatorName?: string(name='OperatorName'),
      appId?: string(name='AppId'),
      beginTime?: long(name='BeginTime'),
      message?: string(name='Message'),
      actionName?: string(name='ActionName'),
      extraParameters?: string(name='ExtraParameters'),
      source?: string(name='Source'),
    }
  ](name='LogList'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  currentPage?: int32(name='CurrentPage'),
  totalSize?: int32(name='TotalSize'),
  code?: int32(name='Code'),
}

model ListOperationLogsResponse = {
  headers: map[string]string(name='headers'),
  body: ListOperationLogsResponseBody(name='body'),
}

async function listOperationLogs(request: ListOperationLogsRequest): ListOperationLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOperationLogsWithOptions(request, headers, runtime);
}

async function listOperationLogsWithOptions(request: ListOperationLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOperationLogsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.beginTime)) {
    query.BeginTime = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query.EndTime = request.endTime;
  }
  if (!Util.isUnset(request.userId)) {
    query.UserId = request.userId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query.CurrentPage = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListOperationLogs', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/operationlog/log_list`, 'json', req, runtime);
}

model ListPublishedServicesRequest {
  appId?: string(name='AppId'),
}

model ListPublishedServicesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  publishedServicesList?: {
    listPublishedServices?: [ 
    {
      dockerApplication?: boolean(name='DockerApplication'),
      type?: string(name='Type'),
      groups?: {
        group?: [ string ](name='group')
      }(name='Groups'),
      version?: string(name='Version'),
      appId?: string(name='AppId'),
      group2Ip?: string(name='Group2Ip'),
      ips?: {
        ip?: [ string ](name='ip')
      }(name='Ips'),
      name?: string(name='Name'),
    }
  ](name='ListPublishedServices')
  }(name='PublishedServicesList'),
  code?: int32(name='Code'),
}

model ListPublishedServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPublishedServicesResponseBody(name='body'),
}

async function listPublishedServices(request: ListPublishedServicesRequest): ListPublishedServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPublishedServicesWithOptions(request, headers, runtime);
}

async function listPublishedServicesWithOptions(request: ListPublishedServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPublishedServicesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListPublishedServices', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/service/listPublishedServices`, 'json', req, runtime);
}

model ListRecentChangeOrderRequest {
  appId?: string(name='AppId'),
}

model ListRecentChangeOrderResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderList?: {
    changeOrder?: [ 
    {
      status?: int32(name='Status'),
      finishTime?: string(name='FinishTime'),
      createTime?: string(name='CreateTime'),
      userId?: string(name='UserId'),
      changeOrderDescription?: string(name='ChangeOrderDescription'),
      source?: string(name='Source'),
      createUserId?: string(name='CreateUserId'),
      batchCount?: int32(name='BatchCount'),
      coTypeCode?: string(name='CoTypeCode'),
      changeOrderId?: string(name='ChangeOrderId'),
      batchType?: string(name='BatchType'),
      groupId?: string(name='GroupId'),
      coType?: string(name='CoType'),
      appId?: string(name='AppId'),
    }
  ](name='ChangeOrder')
  }(name='ChangeOrderList'),
  code?: int32(name='Code'),
}

model ListRecentChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  body: ListRecentChangeOrderResponseBody(name='body'),
}

async function listRecentChangeOrder(request: ListRecentChangeOrderRequest): ListRecentChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRecentChangeOrderWithOptions(request, headers, runtime);
}

async function listRecentChangeOrderWithOptions(request: ListRecentChangeOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRecentChangeOrderResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRecentChangeOrder', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/change_order_list`, 'json', req, runtime);
}

model ListResourceGroupResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resourceGroupList?: {
    resGroupEntity?: [ 
    {
      id?: long(name='Id'),
      name?: string(name='Name'),
      description?: string(name='Description'),
      adminUserId?: string(name='AdminUserId'),
      createTime?: long(name='CreateTime'),
      updateTime?: long(name='UpdateTime'),
      regionId?: string(name='RegionId'),
      ecsList?: {
        ecsEntity?: [ 
        {
          instanceId?: string(name='InstanceId'),
          instanceName?: string(name='InstanceName'),
          hostName?: string(name='HostName'),
          description?: string(name='Description'),
          status?: string(name='Status'),
          publicIp?: string(name='PublicIp'),
          innerIp?: string(name='InnerIp'),
          privateIp?: string(name='PrivateIp'),
          eip?: string(name='Eip'),
          serialNum?: string(name='SerialNum'),
          userId?: string(name='UserId'),
          zoneId?: string(name='ZoneId'),
          regionId?: string(name='RegionId'),
          expired?: boolean(name='Expired'),
          sgId?: string(name='SgId'),
          vpcId?: string(name='VpcId'),
          groupId?: string(name='GroupId'),
          cpu?: int32(name='Cpu'),
          mem?: int32(name='Mem'),
          ecuEntity?: {
            ecuId?: string(name='EcuId'),
            online?: boolean(name='Online'),
            dockerEnv?: boolean(name='DockerEnv'),
            createTime?: long(name='CreateTime'),
            updateTime?: long(name='UpdateTime'),
            ipAddr?: string(name='IpAddr'),
            heartbeatTime?: long(name='HeartbeatTime'),
            userId?: string(name='UserId'),
            name?: string(name='Name'),
            zoneId?: string(name='ZoneId'),
            regionId?: string(name='RegionId'),
            instanceId?: string(name='InstanceId'),
            vpcId?: string(name='VpcId'),
            availableCpu?: int32(name='AvailableCpu'),
            availableMem?: int32(name='AvailableMem'),
            cpu?: int32(name='Cpu'),
            mem?: int32(name='Mem'),
          }(name='EcuEntity'),
          vpcEntity?: {
            vpcId?: string(name='VpcId'),
            vpcName?: string(name='VpcName'),
            regionId?: string(name='RegionId'),
            userId?: string(name='UserId'),
            cidrblock?: string(name='Cidrblock'),
            status?: string(name='Status'),
            description?: string(name='Description'),
            expired?: boolean(name='Expired'),
            ecsNum?: int32(name='EcsNum'),
          }(name='VpcEntity'),
        }
      ](name='EcsEntity')
      }(name='ecsList'),
      slbList?: {
        slbEntity?: [ 
        {
          slbId?: string(name='SlbId'),
          slbName?: string(name='SlbName'),
          regionId?: string(name='RegionId'),
          userId?: string(name='UserId'),
          address?: string(name='Address'),
          slbStatus?: string(name='SlbStatus'),
          addressType?: string(name='AddressType'),
          vswitchId?: string(name='VswitchId'),
          vpcId?: string(name='VpcId'),
          networkType?: string(name='NetworkType'),
          groupId?: int32(name='GroupId'),
          expired?: boolean(name='Expired'),
        }
      ](name='SlbEntity')
      }(name='SlbList'),
    }
  ](name='ResGroupEntity')
  }(name='ResourceGroupList'),
}

model ListResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListResourceGroupResponseBody(name='body'),
}

async function listResourceGroup(): ListResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceGroupWithOptions(headers, runtime);
}

async function listResourceGroupWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListResourceGroup', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/reg_group_list`, 'json', req, runtime);
}

model ListRoleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  roleList?: {
    roleItem?: [ 
    {
      actionList?: {
        action?: [ 
        {
          description?: string(name='Description'),
          groupId?: string(name='GroupId'),
          code?: string(name='Code'),
          name?: string(name='Name'),
        }
      ](name='Action')
      }(name='ActionList'),
      role?: {
        updateTime?: long(name='UpdateTime'),
        isDefault?: boolean(name='IsDefault'),
        adminUserId?: string(name='AdminUserId'),
        createTime?: long(name='CreateTime'),
        name?: string(name='Name'),
        id?: int32(name='Id'),
      }(name='Role'),
    }
  ](name='RoleItem')
  }(name='RoleList'),
  code?: int32(name='Code'),
}

model ListRoleResponse = {
  headers: map[string]string(name='headers'),
  body: ListRoleResponseBody(name='body'),
}

async function listRole(): ListRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRoleWithOptions(headers, runtime);
}

async function listRoleWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListRoleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListRole', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/role_list`, 'json', req, runtime);
}

model ListRootStacksRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
}

model ListRootStacksResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    result?: [ 
      {
        children?: [ 
          {
            comment?: string(name='Comment'),
            icon?: string(name='Icon'),
            name?: string(name='Name'),
            id?: long(name='Id'),
          }
        ](name='Children'),
        root?: {
          name?: string(name='Name'),
          id?: long(name='Id'),
        }(name='Root'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
    pageSize?: int32(name='PageSize'),
  }(name='Data'),
  code?: int32(name='Code'),
}

model ListRootStacksResponse = {
  headers: map[string]string(name='headers'),
  body: ListRootStacksResponseBody(name='body'),
}

async function listRootStacks(request: ListRootStacksRequest): ListRootStacksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRootStacksWithOptions(request, headers, runtime);
}

async function listRootStacksWithOptions(request: ListRootStacksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRootStacksResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.currentPage)) {
    query.CurrentPage = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRootStacks', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/s2i/list_root_stack`, 'json', req, runtime);
}

model ListScaleOutEcuRequest {
  logicalRegionId?: string(name='LogicalRegionId'),
  clusterId?: string(name='ClusterId'),
  appId?: string(name='AppId'),
  groupId?: string(name='GroupId'),
  cpu?: int32(name='Cpu'),
  mem?: int32(name='Mem'),
  instanceNum?: int32(name='InstanceNum'),
}

model ListScaleOutEcuResponseBody = {
  ecuInfoList?: {
    ecuInfo?: [ 
    {
      vpcId?: string(name='VpcId'),
      updateTime?: long(name='UpdateTime'),
      ipAddr?: string(name='IpAddr'),
      availableCpu?: int32(name='AvailableCpu'),
      createTime?: long(name='CreateTime'),
      userId?: string(name='UserId'),
      instanceId?: string(name='InstanceId'),
      regionId?: string(name='RegionId'),
      ecuId?: string(name='EcuId'),
      dockerEnv?: boolean(name='DockerEnv'),
      online?: boolean(name='Online'),
      availableMem?: int32(name='AvailableMem'),
      zoneId?: string(name='ZoneId'),
      name?: string(name='Name'),
      heartbeatTime?: long(name='HeartbeatTime'),
    }
  ](name='EcuInfo')
  }(name='EcuInfoList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model ListScaleOutEcuResponse = {
  headers: map[string]string(name='headers'),
  body: ListScaleOutEcuResponseBody(name='body'),
}

async function listScaleOutEcu(request: ListScaleOutEcuRequest): ListScaleOutEcuResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listScaleOutEcuWithOptions(request, headers, runtime);
}

async function listScaleOutEcuWithOptions(request: ListScaleOutEcuRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListScaleOutEcuResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }
  if (!Util.isUnset(request.cpu)) {
    query.Cpu = request.cpu;
  }
  if (!Util.isUnset(request.mem)) {
    query.Mem = request.mem;
  }
  if (!Util.isUnset(request.instanceNum)) {
    query.InstanceNum = request.instanceNum;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListScaleOutEcu', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/scale_out_ecu_list`, 'json', req, runtime);
}

model ListServiceGroupsResponseBody = {
  serviceGroupsList?: {
    listServiceGroups?: [ 
    {
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      createTime?: string(name='CreateTime'),
    }
  ](name='ListServiceGroups')
  }(name='ServiceGroupsList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model ListServiceGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListServiceGroupsResponseBody(name='body'),
}

async function listServiceGroups(): ListServiceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServiceGroupsWithOptions(headers, runtime);
}

async function listServiceGroupsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListServiceGroupsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListServiceGroups', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/service/serviceGroups`, 'json', req, runtime);
}

model ListSlbResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  slbList?: {
    slbEntity?: [ 
    {
      vpcId?: string(name='VpcId'),
      slbId?: string(name='SlbId'),
      vswitchId?: string(name='VswitchId'),
      expired?: boolean(name='Expired'),
      userId?: string(name='UserId'),
      addressType?: string(name='AddressType'),
      networkType?: string(name='NetworkType'),
      regionId?: string(name='RegionId'),
      groupId?: int32(name='GroupId'),
      address?: string(name='Address'),
      slbName?: string(name='SlbName'),
      slbStatus?: string(name='SlbStatus'),
    }
  ](name='SlbEntity')
  }(name='SlbList'),
}

model ListSlbResponse = {
  headers: map[string]string(name='headers'),
  body: ListSlbResponseBody(name='body'),
}

async function listSlb(): ListSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSlbWithOptions(headers, runtime);
}

async function listSlbWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListSlbResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListSlb', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/slb_list`, 'json', req, runtime);
}

model ListStatusRequest {
  region?: string(name='Region'),
  namespaceId?: string(name='NamespaceId'),
  tenantId?: string(name='TenantId'),
  source?: string(name='Source'),
  accountId?: string(name='AccountId'),
  appId?: string(name='AppId'),
  ip?: string(name='Ip'),
  podName?: string(name='PodName'),
  status?: string(name='Status'),
}

model ListStatusResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      status?: string(name='Status'),
      podName?: string(name='PodName'),
      namespaceId?: string(name='NamespaceId'),
      appId?: string(name='AppId'),
      region?: string(name='Region'),
      ip?: string(name='Ip'),
      accountId?: string(name='AccountId'),
      source?: string(name='Source'),
      tenantId?: string(name='TenantId'),
    }
  ](name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ListStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ListStatusResponseBody(name='body'),
}

async function listStatus(request: ListStatusRequest): ListStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listStatusWithOptions(request, headers, runtime);
}

async function listStatusWithOptions(request: ListStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListStatusResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.region)) {
    query.Region = request.region;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query.NamespaceId = request.namespaceId;
  }
  if (!Util.isUnset(request.tenantId)) {
    query.TenantId = request.tenantId;
  }
  if (!Util.isUnset(request.source)) {
    query.Source = request.source;
  }
  if (!Util.isUnset(request.accountId)) {
    query.AccountId = request.accountId;
  }
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.ip)) {
    query.Ip = request.ip;
  }
  if (!Util.isUnset(request.podName)) {
    query.PodName = request.podName;
  }
  if (!Util.isUnset(request.status)) {
    query.Status = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListStatus', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/mse/status/list`, 'json', req, runtime);
}

model ListSubAccountResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  subAccountList?: {
    subAccount?: [ 
    {
      subEdasId?: string(name='SubEdasId'),
      subUserId?: string(name='SubUserId'),
      email?: string(name='Email'),
      adminUserId?: string(name='AdminUserId'),
      adminUserKp?: string(name='AdminUserKp'),
      adminEdasId?: string(name='AdminEdasId'),
      subUserKp?: string(name='SubUserKp'),
      phone?: string(name='Phone'),
    }
  ](name='SubAccount')
  }(name='SubAccountList'),
  code?: int32(name='Code'),
}

model ListSubAccountResponse = {
  headers: map[string]string(name='headers'),
  body: ListSubAccountResponseBody(name='body'),
}

async function listSubAccount(): ListSubAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSubAccountWithOptions(headers, runtime);
}

async function listSubAccountWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListSubAccountResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListSubAccount', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/sub_account_list`, 'json', req, runtime);
}

model ListSwimmingLaneRequest {
  groupId?: long(name='GroupId'),
}

model ListSwimmingLaneResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      namespaceId?: string(name='NamespaceId'),
      groupId?: long(name='GroupId'),
      scenarioSign?: string(name='ScenarioSign'),
      entryRule?: string(name='EntryRule'),
      tag?: string(name='Tag'),
      enableRules?: boolean(name='EnableRules'),
      name?: string(name='Name'),
      swimmingLaneAppRelationShipList?: [ 
        {
          appName?: string(name='AppName'),
          appId?: string(name='AppId'),
          rules?: string(name='Rules'),
          laneId?: long(name='LaneId'),
        }
      ](name='SwimmingLaneAppRelationShipList'),
      id?: long(name='Id'),
    }
  ](name='Data'),
  code?: int32(name='Code'),
}

model ListSwimmingLaneResponse = {
  headers: map[string]string(name='headers'),
  body: ListSwimmingLaneResponseBody(name='body'),
}

async function listSwimmingLane(request: ListSwimmingLaneRequest): ListSwimmingLaneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSwimmingLaneWithOptions(request, headers, runtime);
}

async function listSwimmingLaneWithOptions(request: ListSwimmingLaneRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSwimmingLaneResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListSwimmingLane', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/trafficmgnt/swimming_lanes`, 'json', req, runtime);
}

model ListSwimmingLaneGroupRequest {
  logicalRegionId?: string(name='LogicalRegionId'),
}

model ListSwimmingLaneGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      namespaceId?: string(name='NamespaceId'),
      applicationList?: [ 
        {
          appName?: string(name='AppName'),
          appId?: string(name='AppId'),
        }
      ](name='ApplicationList'),
      entryApplication?: {
        appName?: string(name='AppName'),
        appId?: string(name='AppId'),
        source?: string(name='Source'),
      }(name='EntryApplication'),
      name?: string(name='Name'),
      id?: long(name='Id'),
    }
  ](name='Data'),
  code?: int32(name='Code'),
}

model ListSwimmingLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListSwimmingLaneGroupResponseBody(name='body'),
}

async function listSwimmingLaneGroup(request: ListSwimmingLaneGroupRequest): ListSwimmingLaneGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSwimmingLaneGroupWithOptions(request, headers, runtime);
}

async function listSwimmingLaneGroupWithOptions(request: ListSwimmingLaneGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSwimmingLaneGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListSwimmingLaneGroup', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/trafficmgnt/swimming_lane_groups`, 'json', req, runtime);
}

model ListTagResourcesRequest {
  resourceType?: string(name='ResourceType'),
  resourceIds?: string(name='ResourceIds'),
  tags?: string(name='Tags'),
  resourceRegionId?: string(name='ResourceRegionId'),
}

model ListTagResourcesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceType?: string(name='ResourceType'),
      tagValue?: string(name='TagValue'),
      resourceId?: string(name='ResourceId'),
      tagKey?: string(name='TagKey'),
    }
  ](name='TagResource')
  }(name='TagResources'),
  code?: int32(name='Code'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.resourceType)) {
    query.ResourceType = request.resourceType;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query.ResourceIds = request.resourceIds;
  }
  if (!Util.isUnset(request.tags)) {
    query.Tags = request.tags;
  }
  if (!Util.isUnset(request.resourceRegionId)) {
    query.ResourceRegionId = request.resourceRegionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListTagResources', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/tag/tags`, 'json', req, runtime);
}

model ListUserDefineRegionRequest {
  debugEnable?: boolean(name='DebugEnable'),
}

model ListUserDefineRegionResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  userDefineRegionList?: {
    userDefineRegionEntity?: [ 
    {
      belongRegion?: string(name='BelongRegion'),
      regionName?: string(name='RegionName'),
      description?: string(name='Description'),
      debugEnable?: boolean(name='DebugEnable'),
      userId?: string(name='UserId'),
      id?: long(name='Id'),
      regionId?: string(name='RegionId'),
    }
  ](name='UserDefineRegionEntity')
  }(name='UserDefineRegionList'),
  code?: int32(name='Code'),
}

model ListUserDefineRegionResponse = {
  headers: map[string]string(name='headers'),
  body: ListUserDefineRegionResponseBody(name='body'),
}

async function listUserDefineRegion(request: ListUserDefineRegionRequest): ListUserDefineRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUserDefineRegionWithOptions(request, headers, runtime);
}

async function listUserDefineRegionWithOptions(request: ListUserDefineRegionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListUserDefineRegionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.debugEnable)) {
    query.DebugEnable = request.debugEnable;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListUserDefineRegion', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/user_region_defs`, 'json', req, runtime);
}

model ListVpcResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  vpcList?: {
    vpcEntity?: [ 
    {
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
      expired?: boolean(name='Expired'),
      userId?: string(name='UserId'),
      ecsNum?: int32(name='EcsNum'),
      regionId?: string(name='RegionId'),
    }
  ](name='VpcEntity')
  }(name='VpcList'),
  code?: int32(name='Code'),
}

model ListVpcResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcResponseBody(name='body'),
}

async function listVpc(): ListVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVpcWithOptions(headers, runtime);
}

async function listVpcWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListVpcResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListVpc', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/vpc_list`, 'json', req, runtime);
}

model MigrateEcuRequest {
  instanceIds?: string(name='InstanceIds'),
  logicalRegionId?: string(name='LogicalRegionId'),
}

model MigrateEcuResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: int32(name='Code'),
}

model MigrateEcuResponse = {
  headers: map[string]string(name='headers'),
  body: MigrateEcuResponseBody(name='body'),
}

async function migrateEcu(request: MigrateEcuRequest): MigrateEcuResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return migrateEcuWithOptions(request, headers, runtime);
}

async function migrateEcuWithOptions(request: MigrateEcuRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MigrateEcuResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceIds)) {
    query.InstanceIds = request.instanceIds;
  }
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('MigrateEcu', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/migrate_ecu`, 'json', req, runtime);
}

model ModifyScalingRuleRequest {
  appId?: string(name='AppId'),
  groupId?: string(name='GroupId'),
  inCondition?: string(name='InCondition'),
  inEnable?: boolean(name='InEnable'),
  inCpu?: int32(name='InCpu'),
  inDuration?: int32(name='InDuration'),
  inInstanceNum?: int32(name='InInstanceNum'),
  inLoad?: int32(name='InLoad'),
  inRT?: int32(name='InRT'),
  inStep?: int32(name='InStep'),
  outCondition?: string(name='OutCondition'),
  outCPU?: int32(name='OutCPU'),
  outDuration?: int32(name='OutDuration'),
  outEnable?: boolean(name='OutEnable'),
  outInstanceNum?: int32(name='OutInstanceNum'),
  outLoad?: int32(name='OutLoad'),
  outRT?: int32(name='OutRT'),
  outStep?: int32(name='OutStep'),
  resourceFrom?: string(name='ResourceFrom'),
  multiAzPolicy?: string(name='MultiAzPolicy'),
  vpcId?: string(name='VpcId'),
  vSwitchIds?: string(name='VSwitchIds'),
  scalingPolicy?: string(name='ScalingPolicy'),
  templateInstanceId?: string(name='TemplateInstanceId'),
  templateInstanceName?: string(name='TemplateInstanceName'),
  password?: string(name='Password'),
  keyPairName?: string(name='KeyPairName'),
  acceptEULA?: boolean(name='AcceptEULA'),
  templateId?: string(name='TemplateId'),
  templateVersion?: int32(name='TemplateVersion'),
}

model ModifyScalingRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model ModifyScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyScalingRuleResponseBody(name='body'),
}

async function modifyScalingRule(request: ModifyScalingRuleRequest): ModifyScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyScalingRuleWithOptions(request, headers, runtime);
}

async function modifyScalingRuleWithOptions(request: ModifyScalingRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyScalingRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }
  if (!Util.isUnset(request.inCondition)) {
    query.InCondition = request.inCondition;
  }
  if (!Util.isUnset(request.inEnable)) {
    query.InEnable = request.inEnable;
  }
  if (!Util.isUnset(request.inCpu)) {
    query.InCpu = request.inCpu;
  }
  if (!Util.isUnset(request.inDuration)) {
    query.InDuration = request.inDuration;
  }
  if (!Util.isUnset(request.inInstanceNum)) {
    query.InInstanceNum = request.inInstanceNum;
  }
  if (!Util.isUnset(request.inLoad)) {
    query.InLoad = request.inLoad;
  }
  if (!Util.isUnset(request.inRT)) {
    query.InRT = request.inRT;
  }
  if (!Util.isUnset(request.inStep)) {
    query.InStep = request.inStep;
  }
  if (!Util.isUnset(request.outCondition)) {
    query.OutCondition = request.outCondition;
  }
  if (!Util.isUnset(request.outCPU)) {
    query.OutCPU = request.outCPU;
  }
  if (!Util.isUnset(request.outDuration)) {
    query.OutDuration = request.outDuration;
  }
  if (!Util.isUnset(request.outEnable)) {
    query.OutEnable = request.outEnable;
  }
  if (!Util.isUnset(request.outInstanceNum)) {
    query.OutInstanceNum = request.outInstanceNum;
  }
  if (!Util.isUnset(request.outLoad)) {
    query.OutLoad = request.outLoad;
  }
  if (!Util.isUnset(request.outRT)) {
    query.OutRT = request.outRT;
  }
  if (!Util.isUnset(request.outStep)) {
    query.OutStep = request.outStep;
  }
  if (!Util.isUnset(request.resourceFrom)) {
    query.ResourceFrom = request.resourceFrom;
  }
  if (!Util.isUnset(request.multiAzPolicy)) {
    query.MultiAzPolicy = request.multiAzPolicy;
  }
  if (!Util.isUnset(request.vpcId)) {
    query.VpcId = request.vpcId;
  }
  if (!Util.isUnset(request.vSwitchIds)) {
    query.VSwitchIds = request.vSwitchIds;
  }
  if (!Util.isUnset(request.scalingPolicy)) {
    query.ScalingPolicy = request.scalingPolicy;
  }
  if (!Util.isUnset(request.templateInstanceId)) {
    query.TemplateInstanceId = request.templateInstanceId;
  }
  if (!Util.isUnset(request.templateInstanceName)) {
    query.TemplateInstanceName = request.templateInstanceName;
  }
  if (!Util.isUnset(request.password)) {
    query.Password = request.password;
  }
  if (!Util.isUnset(request.keyPairName)) {
    query.KeyPairName = request.keyPairName;
  }
  if (!Util.isUnset(request.acceptEULA)) {
    query.AcceptEULA = request.acceptEULA;
  }
  if (!Util.isUnset(request.templateId)) {
    query.TemplateId = request.templateId;
  }
  if (!Util.isUnset(request.templateVersion)) {
    query.TemplateVersion = request.templateVersion;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ModifyScalingRule', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/scaling_rules`, 'json', req, runtime);
}

model QueryApplicationStatusRequest {
  appId?: string(name='AppId'),
}

model QueryApplicationStatusResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  appInfo?: {
    ecuList?: {
      ecu?: [ 
      {
        ecuId?: string(name='EcuId'),
        online?: boolean(name='Online'),
        dockerEnv?: boolean(name='DockerEnv'),
        createTime?: long(name='CreateTime'),
        updateTime?: long(name='UpdateTime'),
        ipAddr?: string(name='IpAddr'),
        heartbeatTime?: long(name='HeartbeatTime'),
        userId?: string(name='UserId'),
        groupId?: string(name='GroupId'),
        name?: string(name='Name'),
        zoneId?: string(name='ZoneId'),
        regionId?: string(name='RegionId'),
        instanceId?: string(name='InstanceId'),
        vpcId?: string(name='VpcId'),
        availableCpu?: int32(name='AvailableCpu'),
        availableMem?: int32(name='AvailableMem'),
      }
    ](name='Ecu')
    }(name='EcuList'),
    eccList?: {
      ecc?: [ 
      {
        eccId?: string(name='EccId'),
        ecuId?: string(name='EcuId'),
        appId?: string(name='AppId'),
        appState?: int32(name='AppState'),
        taskState?: int32(name='TaskState'),
        createTime?: long(name='CreateTime'),
        updateTime?: long(name='UpdateTime'),
        ip?: string(name='Ip'),
        vpcId?: string(name='VpcId'),
        groupId?: string(name='GroupId'),
        containerStatus?: string(name='ContainerStatus'),
      }
    ](name='Ecc')
    }(name='EccList'),
    groupList?: {
      group?: [ 
      {
        groupId?: string(name='GroupId'),
        groupName?: string(name='GroupName'),
        appId?: string(name='AppId'),
        packageVersionId?: string(name='PackageVersionId'),
        appVersionId?: string(name='AppVersionId'),
        groupType?: int32(name='GroupType'),
        clusterId?: string(name='ClusterId'),
        createTime?: long(name='CreateTime'),
        updateTime?: long(name='UpdateTime'),
      }
    ](name='Group')
    }(name='GroupList'),
    deployRecordList?: {
      deployRecord?: [ 
      {
        deployRecordId?: string(name='DeployRecordId'),
        eccId?: string(name='EccId'),
        ecuId?: string(name='EcuId'),
        packageVersionId?: string(name='PackageVersionId'),
        packageMd5?: string(name='PackageMd5'),
        createTime?: long(name='CreateTime'),
      }
    ](name='DeployRecord')
    }(name='DeployRecordList'),
    application?: {
      applicationId?: string(name='ApplicationId'),
      buildPackageId?: int32(name='BuildPackageId'),
      clusterId?: string(name='ClusterId'),
      cpu?: int32(name='Cpu'),
      createTime?: long(name='CreateTime'),
      dockerize?: boolean(name='Dockerize'),
      email?: string(name='Email'),
      healthCheckUrl?: string(name='HealthCheckUrl'),
      instanceCount?: int32(name='InstanceCount'),
      launchTime?: long(name='LaunchTime'),
      memory?: int32(name='Memory'),
      name?: string(name='Name'),
      owner?: string(name='Owner'),
      phone?: string(name='Phone'),
      port?: int32(name='Port'),
      regionId?: string(name='RegionId'),
      runningInstanceCount?: int32(name='RunningInstanceCount'),
      userId?: string(name='UserId'),
    }(name='Application'),
  }(name='AppInfo'),
}

model QueryApplicationStatusResponse = {
  headers: map[string]string(name='headers'),
  body: QueryApplicationStatusResponseBody(name='body'),
}

async function queryApplicationStatus(request: QueryApplicationStatusRequest): QueryApplicationStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryApplicationStatusWithOptions(request, headers, runtime);
}

async function queryApplicationStatusWithOptions(request: QueryApplicationStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryApplicationStatusResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('QueryApplicationStatus', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/app/app_status`, 'json', req, runtime);
}

model QueryConfigCenterRequest {
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  logicalRegionId?: string(name='LogicalRegionId'),
}

model QueryConfigCenterResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  configCenterInfo?: {
    appName?: string(name='AppName'),
    dataId?: string(name='DataId'),
    content?: string(name='Content'),
    id?: string(name='Id'),
    group?: string(name='Group'),
  }(name='configCenterInfo'),
  code?: int32(name='Code'),
}

model QueryConfigCenterResponse = {
  headers: map[string]string(name='headers'),
  body: QueryConfigCenterResponseBody(name='body'),
}

async function queryConfigCenter(request: QueryConfigCenterRequest): QueryConfigCenterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryConfigCenterWithOptions(request, headers, runtime);
}

async function queryConfigCenterWithOptions(request: QueryConfigCenterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryConfigCenterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.dataId)) {
    query.DataId = request.dataId;
  }
  if (!Util.isUnset(request.group)) {
    query.Group = request.group;
  }
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('QueryConfigCenter', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/configCenter`, 'json', req, runtime);
}

model QueryEccInfoRequest {
  eccId?: string(name='EccId'),
}

model QueryEccInfoResponseBody = {
  eccInfo?: {
    vpcId?: string(name='VpcId'),
    eccId?: string(name='EccId'),
    ecuId?: string(name='EcuId'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    packageMd5?: string(name='PackageMd5'),
    appId?: string(name='AppId'),
    packageVersion?: string(name='PackageVersion'),
  }(name='EccInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model QueryEccInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryEccInfoResponseBody(name='body'),
}

async function queryEccInfo(request: QueryEccInfoRequest): QueryEccInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryEccInfoWithOptions(request, headers, runtime);
}

async function queryEccInfoWithOptions(request: QueryEccInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryEccInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.eccId)) {
    query.EccId = request.eccId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('QueryEccInfo', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/ecc`, 'json', req, runtime);
}

model QueryK8sClusterLogProjectInfoRequest {
  clusterId?: string(name='ClusterId'),
}

model QueryK8sClusterLogProjectInfoResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  projectInfo?: {
    projectName?: string(name='ProjectName'),
  }(name='ProjectInfo'),
  code?: int32(name='Code'),
}

model QueryK8sClusterLogProjectInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryK8sClusterLogProjectInfoResponseBody(name='body'),
}

async function queryK8sClusterLogProjectInfo(request: QueryK8sClusterLogProjectInfoRequest): QueryK8sClusterLogProjectInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryK8sClusterLogProjectInfoWithOptions(request, headers, runtime);
}

async function queryK8sClusterLogProjectInfoWithOptions(request: QueryK8sClusterLogProjectInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryK8sClusterLogProjectInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('QueryK8sClusterLogProjectInfo', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/k8s/sls/project`, 'json', req, runtime);
}

model QueryMigrateEcuListRequest {
  logicalRegionId?: string(name='LogicalRegionId'),
}

model QueryMigrateEcuListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  ecuEntityList?: {
    ecuEntity?: [ 
    {
      vpcId?: string(name='VpcId'),
      updateTime?: long(name='UpdateTime'),
      ipAddr?: string(name='IpAddr'),
      availableCpu?: int32(name='AvailableCpu'),
      createTime?: long(name='CreateTime'),
      userId?: string(name='UserId'),
      instanceId?: string(name='InstanceId'),
      mem?: int32(name='Mem'),
      regionId?: string(name='RegionId'),
      ecuId?: string(name='EcuId'),
      cpu?: int32(name='Cpu'),
      dockerEnv?: boolean(name='DockerEnv'),
      online?: boolean(name='Online'),
      availableMem?: int32(name='AvailableMem'),
      zoneId?: string(name='ZoneId'),
      name?: string(name='Name'),
      heartbeatTime?: long(name='HeartbeatTime'),
    }
  ](name='EcuEntity')
  }(name='EcuEntityList'),
  code?: int32(name='Code'),
}

model QueryMigrateEcuListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMigrateEcuListResponseBody(name='body'),
}

async function queryMigrateEcuList(request: QueryMigrateEcuListRequest): QueryMigrateEcuListResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryMigrateEcuListWithOptions(request, headers, runtime);
}

async function queryMigrateEcuListWithOptions(request: QueryMigrateEcuListRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryMigrateEcuListResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('QueryMigrateEcuList', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/migrate_ecu_list`, 'json', req, runtime);
}

model QueryMigrateRegionListRequest {
  logicalRegionId?: string(name='LogicalRegionId'),
}

model QueryMigrateRegionListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  regionEntityList?: {
    regionEntity?: [ 
    {
      regionName?: string(name='RegionName'),
      regionNo?: string(name='RegionNo'),
    }
  ](name='RegionEntity')
  }(name='RegionEntityList'),
}

model QueryMigrateRegionListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMigrateRegionListResponseBody(name='body'),
}

async function queryMigrateRegionList(request: QueryMigrateRegionListRequest): QueryMigrateRegionListResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryMigrateRegionListWithOptions(request, headers, runtime);
}

async function queryMigrateRegionListWithOptions(request: QueryMigrateRegionListRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryMigrateRegionListResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.logicalRegionId)) {
    query.LogicalRegionId = request.logicalRegionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('QueryMigrateRegionList', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/migrate_region_select`, 'json', req, runtime);
}

model QueryMonitorInfoRequest {
  start?: long(name='Start'),
  end?: long(name='End'),
  metric?: string(name='Metric'),
  tags?: string(name='Tags'),
  aggregator?: string(name='Aggregator'),
  interval?: string(name='Interval'),
}

model QueryMonitorInfoResponseBody = {
  monitorInfo?: string(name='MonitorInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model QueryMonitorInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMonitorInfoResponseBody(name='body'),
}

async function queryMonitorInfo(request: QueryMonitorInfoRequest): QueryMonitorInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryMonitorInfoWithOptions(request, headers, runtime);
}

async function queryMonitorInfoWithOptions(request: QueryMonitorInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryMonitorInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.start)) {
    query.Start = request.start;
  }
  if (!Util.isUnset(request.end)) {
    query.End = request.end;
  }
  if (!Util.isUnset(request.metric)) {
    query.Metric = request.metric;
  }
  if (!Util.isUnset(request.tags)) {
    query.Tags = request.tags;
  }
  if (!Util.isUnset(request.aggregator)) {
    query.Aggregator = request.aggregator;
  }
  if (!Util.isUnset(request.interval)) {
    query.Interval = request.interval;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('QueryMonitorInfo', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/monitor/queryMonitorInfo`, 'json', req, runtime);
}

model QueryRegionConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  regionConfig?: {
    no?: int32(name='No'),
    fileServerConfig?: {
      internalUrl?: string(name='InternalUrl'),
      publicUrl?: string(name='PublicUrl'),
      vpcUrl?: string(name='VpcUrl'),
      bucket?: string(name='Bucket'),
    }(name='FileServerConfig'),
    addressServerHost?: string(name='AddressServerHost'),
    tag?: string(name='Tag'),
    agentInstallScript?: string(name='AgentInstallScript'),
    fileServerType?: string(name='FileServerType'),
    name?: string(name='Name'),
    imageId?: string(name='ImageId'),
    id?: string(name='Id'),
  }(name='RegionConfig'),
  code?: int32(name='Code'),
}

model QueryRegionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: QueryRegionConfigResponseBody(name='body'),
}

async function queryRegionConfig(): QueryRegionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryRegionConfigWithOptions(headers, runtime);
}

async function queryRegionConfigWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): QueryRegionConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('QueryRegionConfig', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/region_config`, 'json', req, runtime);
}

model QueryServiceTimeConfigRequest {
  region?: string(name='Region'),
  serviceType?: string(name='ServiceType'),
  appId?: string(name='AppId'),
  serviceName?: string(name='ServiceName'),
  serviceVersion?: string(name='ServiceVersion'),
  serviceGroup?: string(name='ServiceGroup'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  namespace?: string(name='Namespace'),
  source?: string(name='Source'),
}

model QueryServiceTimeConfigResponseBody = {
  message?: string(name='Message'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    result?: [ 
      {
        timeout?: string(name='Timeout'),
        consumerAppName?: string(name='ConsumerAppName'),
        path?: string(name='Path'),
        consumerAppId?: string(name='ConsumerAppId'),
        id?: long(name='Id'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model QueryServiceTimeConfigResponse = {
  headers: map[string]string(name='headers'),
  body: QueryServiceTimeConfigResponseBody(name='body'),
}

async function queryServiceTimeConfig(request: QueryServiceTimeConfigRequest): QueryServiceTimeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryServiceTimeConfigWithOptions(request, headers, runtime);
}

async function queryServiceTimeConfigWithOptions(request: QueryServiceTimeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryServiceTimeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.region)) {
    query.Region = request.region;
  }
  if (!Util.isUnset(request.serviceType)) {
    query.ServiceType = request.serviceType;
  }
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query.ServiceName = request.serviceName;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query.ServiceVersion = request.serviceVersion;
  }
  if (!Util.isUnset(request.serviceGroup)) {
    query.ServiceGroup = request.serviceGroup;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query.PageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.namespace)) {
    query.Namespace = request.namespace;
  }
  if (!Util.isUnset(request.source)) {
    query.Source = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('QueryServiceTimeConfig', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/timeout/page`, 'json', req, runtime);
}

model QuerySlsLogStoreListRequest {
  appId?: string(name='AppId'),
  type?: string(name='Type'),
  pageSize?: int32(name='PageSize'),
  currentPage?: int32(name='CurrentPage'),
}

model QuerySlsLogStoreListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  totalSize?: int32(name='TotalSize'),
  code?: int32(name='Code'),
  result?: [ 
    {
      link?: string(name='Link'),
      createTime?: string(name='CreateTime'),
      logstore?: string(name='Logstore'),
      consumerSide?: string(name='ConsumerSide'),
      project?: string(name='Project'),
      source?: string(name='Source'),
    }
  ](name='Result'),
}

model QuerySlsLogStoreListResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySlsLogStoreListResponseBody(name='body'),
}

async function querySlsLogStoreList(request: QuerySlsLogStoreListRequest): QuerySlsLogStoreListResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return querySlsLogStoreListWithOptions(request, headers, runtime);
}

async function querySlsLogStoreListWithOptions(request: QuerySlsLogStoreListRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QuerySlsLogStoreListResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.type)) {
    query.Type = request.type;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.currentPage)) {
    query.CurrentPage = request.currentPage;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('QuerySlsLogStoreList', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/k8s/sls/query_sls_log_store_list`, 'json', req, runtime);
}

model RemoveMockRuleRequest {
  id?: long(name='Id'),
}

model RemoveMockRuleResponseBody = {
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    namespaceId?: string(name='NamespaceId'),
    scMockItemJson?: string(name='ScMockItemJson'),
    consumerAppName?: string(name='ConsumerAppName'),
    consumerAppId?: string(name='ConsumerAppId'),
    accountId?: string(name='AccountId'),
    extraJson?: string(name='ExtraJson'),
    source?: string(name='Source'),
    region?: string(name='Region'),
    providerAppId?: string(name='ProviderAppId'),
    providerAppName?: string(name='ProviderAppName'),
    name?: string(name='Name'),
    id?: long(name='Id'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model RemoveMockRuleResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveMockRuleResponseBody(name='body'),
}

async function removeMockRule(request: RemoveMockRuleRequest): RemoveMockRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeMockRuleWithOptions(request, headers, runtime);
}

async function removeMockRuleWithOptions(request: RemoveMockRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveMockRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.id)) {
    query.Id = request.id;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('RemoveMockRule', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/mock/removeMockRule`, 'json', req, runtime);
}

model ResetApplicationRequest {
  appId?: string(name='AppId'),
  eccInfo?: string(name='EccInfo'),
}

model ResetApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model ResetApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: ResetApplicationResponseBody(name='body'),
}

async function resetApplication(request: ResetApplicationRequest): ResetApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resetApplicationWithOptions(request, headers, runtime);
}

async function resetApplicationWithOptions(request: ResetApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ResetApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.eccInfo)) {
    query.EccInfo = request.eccInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ResetApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_reset`, 'json', req, runtime);
}

model RestartApplicationRequest {
  appId?: string(name='AppId'),
  eccInfo?: string(name='EccInfo'),
}

model RestartApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model RestartApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: RestartApplicationResponseBody(name='body'),
}

async function restartApplication(request: RestartApplicationRequest): RestartApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartApplicationWithOptions(request, headers, runtime);
}

async function restartApplicationWithOptions(request: RestartApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.eccInfo)) {
    query.EccInfo = request.eccInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('RestartApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_restart`, 'json', req, runtime);
}

model RestartK8sApplicationRequest {
  appId?: string(name='AppId'),
  timeout?: int32(name='Timeout'),
}

model RestartK8sApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model RestartK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: RestartK8sApplicationResponseBody(name='body'),
}

async function restartK8sApplication(request: RestartK8sApplicationRequest): RestartK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartK8sApplicationWithOptions(request, headers, runtime);
}

async function restartK8sApplicationWithOptions(request: RestartK8sApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartK8sApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.timeout)) {
    query.Timeout = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('RestartK8sApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s/acs/restart_k8s_app`, 'json', req, runtime);
}

model RollbackApplicationRequest {
  appId?: string(name='AppId'),
  historyVersion?: string(name='HistoryVersion'),
  groupId?: string(name='GroupId'),
  batch?: int32(name='Batch'),
  batchWaitTime?: int32(name='BatchWaitTime'),
}

model RollbackApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model RollbackApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: RollbackApplicationResponseBody(name='body'),
}

async function rollbackApplication(request: RollbackApplicationRequest): RollbackApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return rollbackApplicationWithOptions(request, headers, runtime);
}

async function rollbackApplicationWithOptions(request: RollbackApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RollbackApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.historyVersion)) {
    query.HistoryVersion = request.historyVersion;
  }
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }
  if (!Util.isUnset(request.batch)) {
    query.Batch = request.batch;
  }
  if (!Util.isUnset(request.batchWaitTime)) {
    query.BatchWaitTime = request.batchWaitTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('RollbackApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_rollback`, 'json', req, runtime);
}

model RollbackChangeOrderRequest {
  changeOrderId?: string(name='ChangeOrderId'),
}

model RollbackChangeOrderResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  code?: int32(name='Code'),
}

model RollbackChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  body: RollbackChangeOrderResponseBody(name='body'),
}

async function rollbackChangeOrder(request: RollbackChangeOrderRequest): RollbackChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return rollbackChangeOrderWithOptions(request, headers, runtime);
}

async function rollbackChangeOrderWithOptions(request: RollbackChangeOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RollbackChangeOrderResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.changeOrderId)) {
    query.ChangeOrderId = request.changeOrderId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('RollbackChangeOrder', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/oam/changeorder/rollback`, 'json', req, runtime);
}

model ScaleInApplicationRequest {
  appId?: string(name='AppId'),
  eccInfo?: string(name='EccInfo'),
  forceStatus?: boolean(name='ForceStatus'),
}

model ScaleInApplicationResponseBody = {
  message?: string(name='Message'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model ScaleInApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: ScaleInApplicationResponseBody(name='body'),
}

async function scaleInApplication(request: ScaleInApplicationRequest): ScaleInApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleInApplicationWithOptions(request, headers, runtime);
}

async function scaleInApplicationWithOptions(request: ScaleInApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleInApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.eccInfo)) {
    query.EccInfo = request.eccInfo;
  }
  if (!Util.isUnset(request.forceStatus)) {
    query.ForceStatus = request.forceStatus;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ScaleInApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_scale_in`, 'json', req, runtime);
}

model ScaleK8sApplicationRequest {
  appId?: string(name='AppId'),
  replicas?: int32(name='Replicas'),
  timeout?: int32(name='Timeout'),
}

model ScaleK8sApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model ScaleK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: ScaleK8sApplicationResponseBody(name='body'),
}

async function scaleK8sApplication(request: ScaleK8sApplicationRequest): ScaleK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleK8sApplicationWithOptions(request, headers, runtime);
}

async function scaleK8sApplicationWithOptions(request: ScaleK8sApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleK8sApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.replicas)) {
    query.Replicas = request.replicas;
  }
  if (!Util.isUnset(request.timeout)) {
    query.Timeout = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ScaleK8sApplication', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/k8s/acs/k8s_apps`, 'json', req, runtime);
}

model ScaleOutApplicationRequest {
  appId?: string(name='AppId'),
  ecuInfo?: string(name='EcuInfo'),
  deployGroup?: string(name='DeployGroup'),
}

model ScaleOutApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model ScaleOutApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: ScaleOutApplicationResponseBody(name='body'),
}

async function scaleOutApplication(request: ScaleOutApplicationRequest): ScaleOutApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleOutApplicationWithOptions(request, headers, runtime);
}

async function scaleOutApplicationWithOptions(request: ScaleOutApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleOutApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.ecuInfo)) {
    query.EcuInfo = request.ecuInfo;
  }
  if (!Util.isUnset(request.deployGroup)) {
    query.DeployGroup = request.deployGroup;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ScaleOutApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_scale_out`, 'json', req, runtime);
}

model ScaleoutApplicationWithNewInstancesRequest {
  appId?: string(name='AppId'),
  groupId?: string(name='GroupId'),
  scalingNum?: int32(name='ScalingNum'),
  templateId?: string(name='TemplateId'),
  templateVersion?: string(name='TemplateVersion'),
  scalingPolicy?: string(name='ScalingPolicy'),
  templateInstanceId?: string(name='TemplateInstanceId'),
  clusterId?: string(name='ClusterId'),
  instanceChargeType?: string(name='InstanceChargeType'),
  instanceChargePeriodUnit?: string(name='InstanceChargePeriodUnit'),
  instanceChargePeriod?: int32(name='InstanceChargePeriod'),
  autoRenew?: boolean(name='AutoRenew'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
}

model ScaleoutApplicationWithNewInstancesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  instanceIds?: [ string ](name='InstanceIds'),
  code?: int32(name='Code'),
}

model ScaleoutApplicationWithNewInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ScaleoutApplicationWithNewInstancesResponseBody(name='body'),
}

async function scaleoutApplicationWithNewInstances(request: ScaleoutApplicationWithNewInstancesRequest): ScaleoutApplicationWithNewInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleoutApplicationWithNewInstancesWithOptions(request, headers, runtime);
}

async function scaleoutApplicationWithNewInstancesWithOptions(request: ScaleoutApplicationWithNewInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleoutApplicationWithNewInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }
  if (!Util.isUnset(request.scalingNum)) {
    query.ScalingNum = request.scalingNum;
  }
  if (!Util.isUnset(request.templateId)) {
    query.TemplateId = request.templateId;
  }
  if (!Util.isUnset(request.templateVersion)) {
    query.TemplateVersion = request.templateVersion;
  }
  if (!Util.isUnset(request.scalingPolicy)) {
    query.ScalingPolicy = request.scalingPolicy;
  }
  if (!Util.isUnset(request.templateInstanceId)) {
    query.TemplateInstanceId = request.templateInstanceId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query.InstanceChargeType = request.instanceChargeType;
  }
  if (!Util.isUnset(request.instanceChargePeriodUnit)) {
    query.InstanceChargePeriodUnit = request.instanceChargePeriodUnit;
  }
  if (!Util.isUnset(request.instanceChargePeriod)) {
    query.InstanceChargePeriod = request.instanceChargePeriod;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query.AutoRenew = request.autoRenew;
  }
  if (!Util.isUnset(request.autoRenewPeriod)) {
    query.AutoRenewPeriod = request.autoRenewPeriod;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ScaleoutApplicationWithNewInstances', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/scaling/scale_out`, 'json', req, runtime);
}

model StartApplicationRequest {
  appId?: string(name='AppId'),
  eccInfo?: string(name='EccInfo'),
}

model StartApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model StartApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: StartApplicationResponseBody(name='body'),
}

async function startApplication(request: StartApplicationRequest): StartApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startApplicationWithOptions(request, headers, runtime);
}

async function startApplicationWithOptions(request: StartApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StartApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.eccInfo)) {
    query.EccInfo = request.eccInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('StartApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_start`, 'json', req, runtime);
}

model StartK8sApplicationRequest {
  replicas?: int32(name='Replicas'),
  timeout?: int32(name='Timeout'),
  appId?: string(name='AppId'),
}

model StartK8sApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model StartK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: StartK8sApplicationResponseBody(name='body'),
}

async function startK8sApplication(request: StartK8sApplicationRequest): StartK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startK8sApplicationWithOptions(request, headers, runtime);
}

async function startK8sApplicationWithOptions(request: StartK8sApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StartK8sApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.replicas)) {
    query.Replicas = request.replicas;
  }
  if (!Util.isUnset(request.timeout)) {
    query.Timeout = request.timeout;
  }
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('StartK8sApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s/acs/start_k8s_app`, 'json', req, runtime);
}

model StopApplicationRequest {
  appId?: string(name='AppId'),
  eccInfo?: string(name='EccInfo'),
}

model StopApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model StopApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: StopApplicationResponseBody(name='body'),
}

async function stopApplication(request: StopApplicationRequest): StopApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopApplicationWithOptions(request, headers, runtime);
}

async function stopApplicationWithOptions(request: StopApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.eccInfo)) {
    query.EccInfo = request.eccInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('StopApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_stop`, 'json', req, runtime);
}

model StopK8sApplicationRequest {
  appId?: string(name='AppId'),
  timeout?: int32(name='Timeout'),
}

model StopK8sApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model StopK8sApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: StopK8sApplicationResponseBody(name='body'),
}

async function stopK8sApplication(request: StopK8sApplicationRequest): StopK8sApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopK8sApplicationWithOptions(request, headers, runtime);
}

async function stopK8sApplicationWithOptions(request: StopK8sApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopK8sApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.timeout)) {
    query.Timeout = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('StopK8sApplication', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s/acs/stop_k8s_app`, 'json', req, runtime);
}

model SwitchAdvancedMonitoringRequest {
  appId?: string(name='AppId'),
  enableAdvancedMonitoring?: boolean(name='EnableAdvancedMonitoring'),
}

model SwitchAdvancedMonitoringResponseBody = {
  advancedMonitoringEnabled?: boolean(name='AdvancedMonitoringEnabled'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model SwitchAdvancedMonitoringResponse = {
  headers: map[string]string(name='headers'),
  body: SwitchAdvancedMonitoringResponseBody(name='body'),
}

async function switchAdvancedMonitoring(request: SwitchAdvancedMonitoringRequest): SwitchAdvancedMonitoringResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return switchAdvancedMonitoringWithOptions(request, headers, runtime);
}

async function switchAdvancedMonitoringWithOptions(request: SwitchAdvancedMonitoringRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SwitchAdvancedMonitoringResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.enableAdvancedMonitoring)) {
    query.EnableAdvancedMonitoring = request.enableAdvancedMonitoring;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('SwitchAdvancedMonitoring', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/monitor/advancedMonitorInfo`, 'json', req, runtime);
}

model SynchronizeResourceRequest {
  type?: string(name='Type'),
  resourceIds?: string(name='ResourceIds'),
}

model SynchronizeResourceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model SynchronizeResourceResponse = {
  headers: map[string]string(name='headers'),
  body: SynchronizeResourceResponseBody(name='body'),
}

async function synchronizeResource(request: SynchronizeResourceRequest): SynchronizeResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return synchronizeResourceWithOptions(request, headers, runtime);
}

async function synchronizeResourceWithOptions(request: SynchronizeResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SynchronizeResourceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.type)) {
    query.Type = request.type;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query.ResourceIds = request.resourceIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('SynchronizeResource', '2017-08-01', 'HTTPS', 'GET', 'AK', `/pop/v5/resource/pop_sync_resource`, 'json', req, runtime);
}

model TagResourcesRequest {
  resourceType?: string(name='ResourceType'),
  resourceIds?: string(name='ResourceIds'),
  tags?: string(name='Tags'),
  resourceRegionId?: string(name='ResourceRegionId'),
}

model TagResourcesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(request, headers, runtime);
}

async function tagResourcesWithOptions(request: TagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.resourceType)) {
    query.ResourceType = request.resourceType;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query.ResourceIds = request.resourceIds;
  }
  if (!Util.isUnset(request.tags)) {
    query.Tags = request.tags;
  }
  if (!Util.isUnset(request.resourceRegionId)) {
    query.ResourceRegionId = request.resourceRegionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('TagResources', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/tag/tags`, 'json', req, runtime);
}

model TransformClusterMemberRequest {
  instanceIds?: string(name='InstanceIds'),
  targetClusterId?: string(name='TargetClusterId'),
  password?: string(name='Password'),
}

model TransformClusterMemberResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: int32(name='Code'),
}

model TransformClusterMemberResponse = {
  headers: map[string]string(name='headers'),
  body: TransformClusterMemberResponseBody(name='body'),
}

async function transformClusterMember(request: TransformClusterMemberRequest): TransformClusterMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return transformClusterMemberWithOptions(request, headers, runtime);
}

async function transformClusterMemberWithOptions(request: TransformClusterMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TransformClusterMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceIds)) {
    query.InstanceIds = request.instanceIds;
  }
  if (!Util.isUnset(request.targetClusterId)) {
    query.TargetClusterId = request.targetClusterId;
  }
  if (!Util.isUnset(request.password)) {
    query.Password = request.password;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('TransformClusterMember', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/resource/transform_cluster_member`, 'json', req, runtime);
}

model UnbindK8sSlbRequest {
  appId?: string(name='AppId'),
  clusterId?: string(name='ClusterId'),
  type?: string(name='Type'),
  slbName?: string(name='SlbName'),
}

model UnbindK8sSlbResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model UnbindK8sSlbResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindK8sSlbResponseBody(name='body'),
}

async function unbindK8sSlb(request: UnbindK8sSlbRequest): UnbindK8sSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unbindK8sSlbWithOptions(request, headers, runtime);
}

async function unbindK8sSlbWithOptions(request: UnbindK8sSlbRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UnbindK8sSlbResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.type)) {
    query.Type = request.type;
  }
  if (!Util.isUnset(request.slbName)) {
    query.SlbName = request.slbName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UnbindK8sSlb', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/k8s/acs/k8s_slb_binding`, 'json', req, runtime);
}

model UnbindSlbRequest {
  appId?: string(name='AppId'),
  slbId?: string(name='SlbId'),
  type?: string(name='Type'),
}

model UnbindSlbResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: int32(name='Code'),
}

model UnbindSlbResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindSlbResponseBody(name='body'),
}

async function unbindSlb(request: UnbindSlbRequest): UnbindSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unbindSlbWithOptions(request, headers, runtime);
}

async function unbindSlbWithOptions(request: UnbindSlbRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UnbindSlbResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.slbId)) {
    query.SlbId = request.slbId;
  }
  if (!Util.isUnset(request.type)) {
    query.Type = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UnbindSlb', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/app/unbind_slb_json`, 'json', req, runtime);
}

model UntagResourcesRequest {
  resourceRegionId?: string(name='ResourceRegionId'),
  resourceType?: string(name='ResourceType'),
  resourceIds?: string(name='ResourceIds'),
  tagKeys?: string(name='TagKeys'),
  deleteAll?: boolean(name='DeleteAll'),
}

model UntagResourcesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourcesWithOptions(request, headers, runtime);
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.resourceRegionId)) {
    query.ResourceRegionId = request.resourceRegionId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query.ResourceType = request.resourceType;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query.ResourceIds = request.resourceIds;
  }
  if (!Util.isUnset(request.tagKeys)) {
    query.TagKeys = request.tagKeys;
  }
  if (!Util.isUnset(request.deleteAll)) {
    query.DeleteAll = request.deleteAll;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UntagResources', '2017-08-01', 'HTTPS', 'DELETE', 'AK', `/pop/v5/tag/tags`, 'json', req, runtime);
}

model UpdateAccountInfoRequest {
  name?: string(name='Name'),
  telephone?: string(name='Telephone'),
  email?: string(name='Email'),
}

model UpdateAccountInfoResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model UpdateAccountInfoResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAccountInfoResponseBody(name='body'),
}

async function updateAccountInfo(request: UpdateAccountInfoRequest): UpdateAccountInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAccountInfoWithOptions(request, headers, runtime);
}

async function updateAccountInfoWithOptions(request: UpdateAccountInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAccountInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }
  if (!Util.isUnset(request.telephone)) {
    query.Telephone = request.telephone;
  }
  if (!Util.isUnset(request.email)) {
    query.Email = request.email;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateAccountInfo', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/edit_account_info`, 'json', req, runtime);
}

model UpdateApplicationBaseInfoRequest {
  appId?: string(name='AppId'),
  appName?: string(name='AppName'),
  desc?: string(name='Desc'),
  owner?: string(name='Owner'),
}

model UpdateApplicationBaseInfoResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  applcation?: {
    extSlbIp?: string(name='ExtSlbIp'),
    owner?: string(name='Owner'),
    slbPort?: int32(name='SlbPort'),
    extSlbName?: string(name='ExtSlbName'),
    createTime?: long(name='CreateTime'),
    userId?: string(name='UserId'),
    port?: int32(name='Port'),
    runningInstanceCount?: int32(name='RunningInstanceCount'),
    slbIp?: string(name='SlbIp'),
    dockerize?: boolean(name='Dockerize'),
    description?: string(name='Description'),
    instanceCount?: int32(name='InstanceCount'),
    appId?: string(name='AppId'),
    memory?: int32(name='Memory'),
    name?: string(name='Name'),
    clusterId?: string(name='ClusterId'),
    healthCheckUrl?: string(name='HealthCheckUrl'),
    slbId?: string(name='SlbId'),
    applicationType?: string(name='ApplicationType'),
    extSlbId?: string(name='ExtSlbId'),
    buildPackageId?: long(name='BuildPackageId'),
    regionId?: string(name='RegionId'),
    cpu?: int32(name='Cpu'),
    clusterType?: int32(name='ClusterType'),
    slbName?: string(name='SlbName'),
  }(name='Applcation'),
  code?: int32(name='Code'),
}

model UpdateApplicationBaseInfoResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateApplicationBaseInfoResponseBody(name='body'),
}

async function updateApplicationBaseInfo(request: UpdateApplicationBaseInfoRequest): UpdateApplicationBaseInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateApplicationBaseInfoWithOptions(request, headers, runtime);
}

async function updateApplicationBaseInfoWithOptions(request: UpdateApplicationBaseInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateApplicationBaseInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.appName)) {
    query.AppName = request.appName;
  }
  if (!Util.isUnset(request.desc)) {
    query.Desc = request.desc;
  }
  if (!Util.isUnset(request.owner)) {
    query.Owner = request.owner;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateApplicationBaseInfo', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/update_app_info`, 'json', req, runtime);
}

model UpdateContainerRequest {
  appId?: string(name='AppId'),
  buildPackId?: int32(name='BuildPackId'),
}

model UpdateContainerResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model UpdateContainerResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateContainerResponseBody(name='body'),
}

async function updateContainer(request: UpdateContainerRequest): UpdateContainerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateContainerWithOptions(request, headers, runtime);
}

async function updateContainerWithOptions(request: UpdateContainerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateContainerResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.buildPackId)) {
    query.BuildPackId = request.buildPackId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateContainer', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/changeorder/co_update_container`, 'json', req, runtime);
}

model UpdateContainerConfigurationRequest {
  appId?: string(name='AppId'),
  groupId?: string(name='GroupId'),
  contextPath?: string(name='ContextPath'),
  httpPort?: int32(name='HttpPort'),
  maxThreads?: int32(name='MaxThreads'),
  URIEncoding?: string(name='URIEncoding'),
  useBodyEncoding?: boolean(name='UseBodyEncoding'),
}

model UpdateContainerConfigurationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  containerConfiguration?: {
    contextPath?: string(name='ContextPath'),
    URIEncoding?: string(name='URIEncoding'),
    httpPort?: int32(name='HttpPort'),
    useBodyEncoding?: boolean(name='UseBodyEncoding'),
    maxThreads?: int32(name='MaxThreads'),
  }(name='ContainerConfiguration'),
}

model UpdateContainerConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateContainerConfigurationResponseBody(name='body'),
}

async function updateContainerConfiguration(request: UpdateContainerConfigurationRequest): UpdateContainerConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateContainerConfigurationWithOptions(request, headers, runtime);
}

async function updateContainerConfigurationWithOptions(request: UpdateContainerConfigurationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateContainerConfigurationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }
  if (!Util.isUnset(request.contextPath)) {
    query.ContextPath = request.contextPath;
  }
  if (!Util.isUnset(request.httpPort)) {
    query.HttpPort = request.httpPort;
  }
  if (!Util.isUnset(request.maxThreads)) {
    query.MaxThreads = request.maxThreads;
  }
  if (!Util.isUnset(request.URIEncoding)) {
    query.URIEncoding = request.URIEncoding;
  }
  if (!Util.isUnset(request.useBodyEncoding)) {
    query.UseBodyEncoding = request.useBodyEncoding;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateContainerConfiguration', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/container_config`, 'json', req, runtime);
}

model UpdateDegradeControlRequest {
  appId?: string(name='AppId'),
  ruleId?: string(name='RuleId'),
  duration?: int32(name='Duration'),
  methodName?: string(name='MethodName'),
  rtThreshold?: int32(name='RtThreshold'),
  serviceName?: string(name='ServiceName'),
  urlVar?: string(name='UrlVar'),
  ruleType?: string(name='RuleType'),
}

model UpdateDegradeControlResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model UpdateDegradeControlResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDegradeControlResponseBody(name='body'),
}

async function updateDegradeControl(request: UpdateDegradeControlRequest): UpdateDegradeControlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDegradeControlWithOptions(request, headers, runtime);
}

async function updateDegradeControlWithOptions(request: UpdateDegradeControlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDegradeControlResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query.RuleId = request.ruleId;
  }
  if (!Util.isUnset(request.duration)) {
    query.Duration = request.duration;
  }
  if (!Util.isUnset(request.methodName)) {
    query.MethodName = request.methodName;
  }
  if (!Util.isUnset(request.rtThreshold)) {
    query.RtThreshold = request.rtThreshold;
  }
  if (!Util.isUnset(request.serviceName)) {
    query.ServiceName = request.serviceName;
  }
  if (!Util.isUnset(request.urlVar)) {
    query.UrlVar = request.urlVar;
  }
  if (!Util.isUnset(request.ruleType)) {
    query.RuleType = request.ruleType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateDegradeControl', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/degradeControl`, 'json', req, runtime);
}

model UpdateFlowControlRequest {
  appId?: string(name='AppId'),
  ruleId?: string(name='RuleId'),
  consumerAppId?: string(name='ConsumerAppId'),
  granularity?: string(name='Granularity'),
  methodName?: string(name='MethodName'),
  ruleType?: string(name='RuleType'),
  serviceName?: string(name='ServiceName'),
  strategy?: string(name='Strategy'),
  threshold?: int32(name='Threshold'),
  urlVar?: string(name='UrlVar'),
}

model UpdateFlowControlResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model UpdateFlowControlResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFlowControlResponseBody(name='body'),
}

async function updateFlowControl(request: UpdateFlowControlRequest): UpdateFlowControlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFlowControlWithOptions(request, headers, runtime);
}

async function updateFlowControlWithOptions(request: UpdateFlowControlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFlowControlResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query.RuleId = request.ruleId;
  }
  if (!Util.isUnset(request.consumerAppId)) {
    query.ConsumerAppId = request.consumerAppId;
  }
  if (!Util.isUnset(request.granularity)) {
    query.Granularity = request.granularity;
  }
  if (!Util.isUnset(request.methodName)) {
    query.MethodName = request.methodName;
  }
  if (!Util.isUnset(request.ruleType)) {
    query.RuleType = request.ruleType;
  }
  if (!Util.isUnset(request.serviceName)) {
    query.ServiceName = request.serviceName;
  }
  if (!Util.isUnset(request.strategy)) {
    query.Strategy = request.strategy;
  }
  if (!Util.isUnset(request.threshold)) {
    query.Threshold = request.threshold;
  }
  if (!Util.isUnset(request.urlVar)) {
    query.UrlVar = request.urlVar;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateFlowControl', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/flowControl`, 'json', req, runtime);
}

model UpdateHealthCheckUrlRequest {
  appId?: string(name='AppId'),
  hcURL?: string(name='hcURL'),
}

model UpdateHealthCheckUrlResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  healthCheckURL?: string(name='HealthCheckURL'),
  code?: int32(name='Code'),
}

model UpdateHealthCheckUrlResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateHealthCheckUrlResponseBody(name='body'),
}

async function updateHealthCheckUrl(request: UpdateHealthCheckUrlRequest): UpdateHealthCheckUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateHealthCheckUrlWithOptions(request, headers, runtime);
}

async function updateHealthCheckUrlWithOptions(request: UpdateHealthCheckUrlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateHealthCheckUrlResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.hcURL)) {
    query.hcURL = request.hcURL;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateHealthCheckUrl', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/modify_hc_url`, 'json', req, runtime);
}

model UpdateHookConfigurationRequest {
  appId?: string(name='AppId'),
  groupId?: string(name='GroupId'),
  hooks?: string(name='Hooks'),
}

model UpdateHookConfigurationResponseBody = {
  hooksConfiguration?: [ 
    {
      ignoreFail?: boolean(name='IgnoreFail'),
      name?: string(name='Name'),
      script?: string(name='Script'),
    }
  ](name='HooksConfiguration'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model UpdateHookConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateHookConfigurationResponseBody(name='body'),
}

async function updateHookConfiguration(request: UpdateHookConfigurationRequest): UpdateHookConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateHookConfigurationWithOptions(request, headers, runtime);
}

async function updateHookConfigurationWithOptions(request: UpdateHookConfigurationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateHookConfigurationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }
  if (!Util.isUnset(request.hooks)) {
    query.Hooks = request.hooks;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateHookConfiguration', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/app/config_app_hook_json`, 'json', req, runtime);
}

model UpdateJvmConfigurationRequest {
  appId?: string(name='AppId'),
  groupId?: string(name='GroupId'),
  options?: string(name='Options'),
  minHeapSize?: int32(name='MinHeapSize'),
  maxPermSize?: int32(name='MaxPermSize'),
  maxHeapSize?: int32(name='MaxHeapSize'),
}

model UpdateJvmConfigurationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  jvmConfiguration?: {
    maxPermSize?: int32(name='MaxPermSize'),
    options?: string(name='Options'),
    maxHeapSize?: int32(name='MaxHeapSize'),
    minHeapSize?: int32(name='MinHeapSize'),
  }(name='JvmConfiguration'),
  code?: int32(name='Code'),
}

model UpdateJvmConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateJvmConfigurationResponseBody(name='body'),
}

async function updateJvmConfiguration(request: UpdateJvmConfigurationRequest): UpdateJvmConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateJvmConfigurationWithOptions(request, headers, runtime);
}

async function updateJvmConfigurationWithOptions(request: UpdateJvmConfigurationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateJvmConfigurationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }
  if (!Util.isUnset(request.options)) {
    query.Options = request.options;
  }
  if (!Util.isUnset(request.minHeapSize)) {
    query.MinHeapSize = request.minHeapSize;
  }
  if (!Util.isUnset(request.maxPermSize)) {
    query.MaxPermSize = request.maxPermSize;
  }
  if (!Util.isUnset(request.maxHeapSize)) {
    query.MaxHeapSize = request.maxHeapSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateJvmConfiguration', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/app/app_jvm_config`, 'json', req, runtime);
}

model UpdateK8sApplicationBaseInfoRequest {
  appId?: string(name='AppId'),
  description?: string(name='Description'),
  owner?: string(name='Owner'),
  phoneNumber?: string(name='PhoneNumber'),
  email?: string(name='Email'),
}

model UpdateK8sApplicationBaseInfoResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  result?: string(name='Result'),
}

model UpdateK8sApplicationBaseInfoResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateK8sApplicationBaseInfoResponseBody(name='body'),
}

async function updateK8sApplicationBaseInfo(request: UpdateK8sApplicationBaseInfoRequest): UpdateK8sApplicationBaseInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateK8sApplicationBaseInfoWithOptions(request, headers, runtime);
}

async function updateK8sApplicationBaseInfoWithOptions(request: UpdateK8sApplicationBaseInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateK8sApplicationBaseInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.description)) {
    query.Description = request.description;
  }
  if (!Util.isUnset(request.owner)) {
    query.Owner = request.owner;
  }
  if (!Util.isUnset(request.phoneNumber)) {
    query.PhoneNumber = request.phoneNumber;
  }
  if (!Util.isUnset(request.email)) {
    query.Email = request.email;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateK8sApplicationBaseInfo', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/oam/update_app_basic_info`, 'json', req, runtime);
}

model UpdateK8sApplicationConfigRequest {
  appId?: string(name='AppId'),
  clusterId?: string(name='ClusterId'),
  cpuLimit?: string(name='CpuLimit'),
  memoryLimit?: string(name='MemoryLimit'),
  mcpuLimit?: string(name='McpuLimit'),
  cpuRequest?: string(name='CpuRequest'),
  mcpuRequest?: string(name='McpuRequest'),
  memoryRequest?: string(name='MemoryRequest'),
  timeout?: int32(name='Timeout'),
}

model UpdateK8sApplicationConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model UpdateK8sApplicationConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateK8sApplicationConfigResponseBody(name='body'),
}

async function updateK8sApplicationConfig(request: UpdateK8sApplicationConfigRequest): UpdateK8sApplicationConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateK8sApplicationConfigWithOptions(request, headers, runtime);
}

async function updateK8sApplicationConfigWithOptions(request: UpdateK8sApplicationConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateK8sApplicationConfigResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.cpuLimit)) {
    query.CpuLimit = request.cpuLimit;
  }
  if (!Util.isUnset(request.memoryLimit)) {
    query.MemoryLimit = request.memoryLimit;
  }
  if (!Util.isUnset(request.mcpuLimit)) {
    query.McpuLimit = request.mcpuLimit;
  }
  if (!Util.isUnset(request.cpuRequest)) {
    query.CpuRequest = request.cpuRequest;
  }
  if (!Util.isUnset(request.mcpuRequest)) {
    query.McpuRequest = request.mcpuRequest;
  }
  if (!Util.isUnset(request.memoryRequest)) {
    query.MemoryRequest = request.memoryRequest;
  }
  if (!Util.isUnset(request.timeout)) {
    query.Timeout = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateK8sApplicationConfig', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/k8s/acs/k8s_app_configuration`, 'json', req, runtime);
}

model UpdateK8sIngressRuleRequest {
  clusterId?: string(name='ClusterId'),
  namespace?: string(name='Namespace'),
  name?: string(name='Name'),
  rules?: string(name='Rules'),
}

model UpdateK8sIngressRuleResponseBody = {
  message?: string(name='Message'),
  changeOrderIds?: [ 
    {
      changeOrderId?: string(name='ChangeOrderId'),
      appId?: string(name='AppId'),
    }
  ](name='ChangeOrderIds'),
  code?: int32(name='Code'),
}

model UpdateK8sIngressRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateK8sIngressRuleResponseBody(name='body'),
}

async function updateK8sIngressRule(request: UpdateK8sIngressRuleRequest): UpdateK8sIngressRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateK8sIngressRuleWithOptions(request, headers, runtime);
}

async function updateK8sIngressRuleWithOptions(request: UpdateK8sIngressRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateK8sIngressRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.namespace)) {
    query.Namespace = request.namespace;
  }
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }
  if (!Util.isUnset(request.rules)) {
    query.Rules = request.rules;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateK8sIngressRule', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/k8s/acs/k8s_ingress`, 'json', req, runtime);
}

model UpdateK8sResourceRequest {
  clusterId?: string(name='ClusterId'),
  namespace?: string(name='Namespace'),
  resourceContent?: string(name='ResourceContent'),
}

model UpdateK8sResourceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model UpdateK8sResourceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateK8sResourceResponseBody(name='body'),
}

async function updateK8sResource(request: UpdateK8sResourceRequest): UpdateK8sResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateK8sResourceWithOptions(request, headers, runtime);
}

async function updateK8sResourceWithOptions(request: UpdateK8sResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateK8sResourceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    body.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.namespace)) {
    body.Namespace = request.namespace;
  }
  if (!Util.isUnset(request.resourceContent)) {
    body.ResourceContent = request.resourceContent;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequestWithForm('UpdateK8sResource', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/oam/update_k8s_resource_config`, 'json', req, runtime);
}

model UpdateK8sServiceRequest {
  appId?: string(name='AppId'),
  name?: string(name='Name'),
  type?: string(name='Type'),
  servicePorts?: string(name='ServicePorts'),
}

model UpdateK8sServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model UpdateK8sServiceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateK8sServiceResponseBody(name='body'),
}

async function updateK8sService(request: UpdateK8sServiceRequest): UpdateK8sServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateK8sServiceWithOptions(request, headers, runtime);
}

async function updateK8sServiceWithOptions(request: UpdateK8sServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateK8sServiceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }
  if (!Util.isUnset(request.type)) {
    query.Type = request.type;
  }
  if (!Util.isUnset(request.servicePorts)) {
    query.ServicePorts = request.servicePorts;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateK8sService', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/k8s/acs/k8s_service`, 'json', req, runtime);
}

model UpdateK8sSlbRequest {
  appId?: string(name='AppId'),
  clusterId?: string(name='ClusterId'),
  type?: string(name='Type'),
  slbProtocol?: string(name='SlbProtocol'),
  targetPort?: string(name='TargetPort'),
  port?: string(name='Port'),
  servicePortInfos?: string(name='ServicePortInfos'),
  specification?: string(name='Specification'),
  scheduler?: string(name='Scheduler'),
  slbName?: string(name='SlbName'),
}

model UpdateK8sSlbResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  changeOrderId?: string(name='ChangeOrderId'),
  code?: int32(name='Code'),
}

model UpdateK8sSlbResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateK8sSlbResponseBody(name='body'),
}

async function updateK8sSlb(request: UpdateK8sSlbRequest): UpdateK8sSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateK8sSlbWithOptions(request, headers, runtime);
}

async function updateK8sSlbWithOptions(request: UpdateK8sSlbRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateK8sSlbResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    query.AppId = request.appId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.type)) {
    query.Type = request.type;
  }
  if (!Util.isUnset(request.slbProtocol)) {
    query.SlbProtocol = request.slbProtocol;
  }
  if (!Util.isUnset(request.targetPort)) {
    query.TargetPort = request.targetPort;
  }
  if (!Util.isUnset(request.port)) {
    query.Port = request.port;
  }
  if (!Util.isUnset(request.servicePortInfos)) {
    query.ServicePortInfos = request.servicePortInfos;
  }
  if (!Util.isUnset(request.specification)) {
    query.Specification = request.specification;
  }
  if (!Util.isUnset(request.scheduler)) {
    query.Scheduler = request.scheduler;
  }
  if (!Util.isUnset(request.slbName)) {
    query.SlbName = request.slbName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateK8sSlb', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/k8s/acs/k8s_slb_binding`, 'json', req, runtime);
}

model UpdateMockRuleRequest {
  name?: string(name='Name'),
  region?: string(name='Region'),
  extraJson?: string(name='ExtraJson'),
  scMockItemJson?: string(name='ScMockItemJson'),
  dubboMockItemJson?: string(name='DubboMockItemJson'),
  id?: string(name='Id'),
}

model UpdateMockRuleResponseBody = {
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    namespaceId?: string(name='NamespaceId'),
    scMockItemJson?: string(name='ScMockItemJson'),
    consumerAppName?: string(name='ConsumerAppName'),
    consumerAppId?: string(name='ConsumerAppId'),
    accountId?: string(name='AccountId'),
    extraJson?: string(name='ExtraJson'),
    source?: string(name='Source'),
    region?: string(name='Region'),
    providerAppId?: string(name='ProviderAppId'),
    dubboMockItemJson?: string(name='DubboMockItemJson'),
    providerAppName?: string(name='ProviderAppName'),
    name?: string(name='Name'),
    id?: long(name='Id'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UpdateMockRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMockRuleResponseBody(name='body'),
}

async function updateMockRule(request: UpdateMockRuleRequest): UpdateMockRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMockRuleWithOptions(request, headers, runtime);
}

async function updateMockRuleWithOptions(request: UpdateMockRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMockRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }
  if (!Util.isUnset(request.region)) {
    query.Region = request.region;
  }
  if (!Util.isUnset(request.extraJson)) {
    query.ExtraJson = request.extraJson;
  }
  if (!Util.isUnset(request.scMockItemJson)) {
    query.ScMockItemJson = request.scMockItemJson;
  }
  if (!Util.isUnset(request.dubboMockItemJson)) {
    query.DubboMockItemJson = request.dubboMockItemJson;
  }
  if (!Util.isUnset(request.id)) {
    query.Id = request.id;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateMockRule', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/sp/api/mock/updateMockRule`, 'json', req, runtime);
}

model UpdateRoleRequest {
  roleId?: int32(name='RoleId'),
  actionData?: string(name='ActionData'),
}

model UpdateRoleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model UpdateRoleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRoleResponseBody(name='body'),
}

async function updateRole(request: UpdateRoleRequest): UpdateRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRoleWithOptions(request, headers, runtime);
}

async function updateRoleWithOptions(request: UpdateRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRoleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.roleId)) {
    query.RoleId = request.roleId;
  }
  if (!Util.isUnset(request.actionData)) {
    query.ActionData = request.actionData;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateRole', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/account/edit_role`, 'json', req, runtime);
}

model UpdateSlsLogStoreRequest {
  appId?: string(name='AppId'),
  configs?: string(name='Configs'),
}

model UpdateSlsLogStoreResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
}

model UpdateSlsLogStoreResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSlsLogStoreResponseBody(name='body'),
}

async function updateSlsLogStore(request: UpdateSlsLogStoreRequest): UpdateSlsLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSlsLogStoreWithOptions(request, headers, runtime);
}

async function updateSlsLogStoreWithOptions(request: UpdateSlsLogStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSlsLogStoreResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    body.AppId = request.appId;
  }
  if (!Util.isUnset(request.configs)) {
    body.Configs = request.configs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequestWithForm('UpdateSlsLogStore', '2017-08-01', 'HTTPS', 'POST', 'AK', `/pop/v5/k8s/sls/update_sls_log_store`, 'json', req, runtime);
}

model UpdateSwimmingLaneRequest {
  laneId?: long(name='LaneId'),
  name?: string(name='Name'),
  enableRules?: boolean(name='EnableRules'),
  appInfos?: string(name='AppInfos'),
  entryRules?: string(name='EntryRules'),
}

model UpdateSwimmingLaneResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    namespaceId?: string(name='NamespaceId'),
    groupId?: long(name='GroupId'),
    entryRule?: string(name='EntryRule'),
    tag?: string(name='Tag'),
    name?: string(name='Name'),
    swimmingLaneAppRelationShipList?: [ 
      {
        appName?: string(name='AppName'),
        appId?: string(name='AppId'),
        rules?: string(name='Rules'),
        laneId?: long(name='LaneId'),
      }
    ](name='SwimmingLaneAppRelationShipList'),
    id?: long(name='Id'),
  }(name='Data'),
  code?: int32(name='Code'),
}

model UpdateSwimmingLaneResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSwimmingLaneResponseBody(name='body'),
}

async function updateSwimmingLane(request: UpdateSwimmingLaneRequest): UpdateSwimmingLaneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSwimmingLaneWithOptions(request, headers, runtime);
}

async function updateSwimmingLaneWithOptions(request: UpdateSwimmingLaneRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSwimmingLaneResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.laneId)) {
    query.LaneId = request.laneId;
  }
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }
  if (!Util.isUnset(request.enableRules)) {
    query.EnableRules = request.enableRules;
  }
  if (!Util.isUnset(request.appInfos)) {
    query.AppInfos = request.appInfos;
  }
  if (!Util.isUnset(request.entryRules)) {
    query.EntryRules = request.entryRules;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateSwimmingLane', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/trafficmgnt/swimming_lanes`, 'json', req, runtime);
}

model UpdateSwimmingLaneGroupRequest {
  groupId?: long(name='GroupId'),
  name?: string(name='Name'),
  entryApp?: string(name='EntryApp'),
  appIds?: string(name='AppIds'),
}

model UpdateSwimmingLaneGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    namespaceId?: string(name='NamespaceId'),
    applicationList?: [ 
      {
        appName?: string(name='AppName'),
        appId?: string(name='AppId'),
      }
    ](name='ApplicationList'),
    entryApplication?: {
      appName?: string(name='AppName'),
      appId?: string(name='AppId'),
    }(name='EntryApplication'),
    name?: string(name='Name'),
    id?: long(name='Id'),
  }(name='Data'),
  code?: int32(name='Code'),
}

model UpdateSwimmingLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSwimmingLaneGroupResponseBody(name='body'),
}

async function updateSwimmingLaneGroup(request: UpdateSwimmingLaneGroupRequest): UpdateSwimmingLaneGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSwimmingLaneGroupWithOptions(request, headers, runtime);
}

async function updateSwimmingLaneGroupWithOptions(request: UpdateSwimmingLaneGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSwimmingLaneGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }
  if (!Util.isUnset(request.entryApp)) {
    query.EntryApp = request.entryApp;
  }
  if (!Util.isUnset(request.appIds)) {
    query.AppIds = request.appIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateSwimmingLaneGroup', '2017-08-01', 'HTTPS', 'PUT', 'AK', `/pop/v5/trafficmgnt/swimming_lane_groups`, 'json', req, runtime);
}

