/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-qingdao = 'ddosbgp.aliyuncs.com',
    cn-beijing = 'ddosbgp.aliyuncs.com',
    cn-zhangjiakou = 'ddosbgp.aliyuncs.com',
    cn-huhehaote = 'ddosbgp.aliyuncs.com',
    cn-hangzhou = 'ddosbgp.aliyuncs.com',
    cn-shanghai = 'ddosbgp.aliyuncs.com',
    cn-shenzhen = 'ddosbgp.aliyuncs.com',
    ap-northeast-1 = 'ddosbgp.ap-southeast-1.aliyuncs.com',
    ap-south-1 = 'ddosbgp.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'ddosbgp.ap-southeast-1.aliyuncs.com',
    ap-southeast-3 = 'ddosbgp.ap-southeast-1.aliyuncs.com',
    ap-southeast-5 = 'ddosbgp.ap-southeast-1.aliyuncs.com',
    cn-chengdu = 'ddosbgp.aliyuncs.com',
    eu-central-1 = 'ddosbgp.ap-southeast-1.aliyuncs.com',
    eu-west-1 = 'ddosbgp.ap-southeast-1.aliyuncs.com',
    me-east-1 = 'ddosbgp.ap-southeast-1.aliyuncs.com',
    cn-hangzhou-finance = 'ddosbgp.aliyuncs.com',
    cn-shenzhen-finance-1 = 'ddosbgp.aliyuncs.com',
    cn-shanghai-finance-1 = 'ddosbgp.aliyuncs.com',
    cn-north-2-gov-1 = 'ddosbgp.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('ddosbgp', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddIpRequest {
  ipList?: string(name='IpList'),
  packId?: string(name='PackId'),
  sourceIp?: string(name='SourceIp'),
}

model AddIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddIpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddIpResponseBody(name='body'),
}

async function addIpWithOptions(request: AddIpRequest, runtime: Util.RuntimeOptions): AddIpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipList)) {
    query['IpList'] = request.ipList;
  }
  if (!Util.isUnset(request.packId)) {
    query['PackId'] = request.packId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddIp',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addIp(request: AddIpRequest): AddIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return addIpWithOptions(request, runtime);
}

model AddProductRequest {
  packId?: string(name='PackId'),
  product?: string(name='Product'),
  sourceIp?: string(name='SourceIp'),
}

model AddProductResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddProductResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddProductResponseBody(name='body'),
}

async function addProductWithOptions(request: AddProductRequest, runtime: Util.RuntimeOptions): AddProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.packId)) {
    query['PackId'] = request.packId;
  }
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddProduct',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addProduct(request: AddProductRequest): AddProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return addProductWithOptions(request, runtime);
}

model CheckGrantRequest {
  sourceIp?: string(name='SourceIp'),
}

model CheckGrantResponseBody = {
  requestId?: string(name='RequestId'),
  status?: int32(name='Status'),
}

model CheckGrantResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckGrantResponseBody(name='body'),
}

async function checkGrantWithOptions(request: CheckGrantRequest, runtime: Util.RuntimeOptions): CheckGrantResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckGrant',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkGrant(request: CheckGrantRequest): CheckGrantResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkGrantWithOptions(request, runtime);
}

model DeleteBlackholeRequest {
  ip?: string(name='Ip'),
  packId?: string(name='PackId'),
  sourceIp?: string(name='SourceIp'),
}

model DeleteBlackholeResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBlackholeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBlackholeResponseBody(name='body'),
}

async function deleteBlackholeWithOptions(request: DeleteBlackholeRequest, runtime: Util.RuntimeOptions): DeleteBlackholeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.packId)) {
    query['PackId'] = request.packId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBlackhole',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBlackhole(request: DeleteBlackholeRequest): DeleteBlackholeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBlackholeWithOptions(request, runtime);
}

model DeleteIpRequest {
  ipList?: string(name='IpList'),
  packId?: string(name='PackId'),
  sourceIp?: string(name='SourceIp'),
}

model DeleteIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIpResponseBody(name='body'),
}

async function deleteIpWithOptions(request: DeleteIpRequest, runtime: Util.RuntimeOptions): DeleteIpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipList)) {
    query['IpList'] = request.ipList;
  }
  if (!Util.isUnset(request.packId)) {
    query['PackId'] = request.packId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIp',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIp(request: DeleteIpRequest): DeleteIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpWithOptions(request, runtime);
}

model DeleteProductRequest {
  packId?: string(name='PackId'),
  sourceIp?: string(name='SourceIp'),
}

model DeleteProductResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteProductResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProductResponseBody(name='body'),
}

async function deleteProductWithOptions(request: DeleteProductRequest, runtime: Util.RuntimeOptions): DeleteProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.packId)) {
    query['PackId'] = request.packId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProduct',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProduct(request: DeleteProductRequest): DeleteProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProductWithOptions(request, runtime);
}

model DescribeDdosEventRequest {
  endTime?: int32(name='EndTime'),
  packId?: string(name='PackId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  sourceIp?: string(name='SourceIp'),
  startTime?: int32(name='StartTime'),
}

model DescribeDdosEventResponseBody = {
  events?: [ 
    {
      endTime?: int32(name='EndTime'),
      ip?: string(name='Ip'),
      mbps?: int32(name='Mbps'),
      pps?: int32(name='Pps'),
      startTime?: int32(name='StartTime'),
      status?: string(name='Status'),
    }
  ](name='Events'),
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
}

model DescribeDdosEventResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDdosEventResponseBody(name='body'),
}

async function describeDdosEventWithOptions(request: DescribeDdosEventRequest, runtime: Util.RuntimeOptions): DescribeDdosEventResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.packId)) {
    query['PackId'] = request.packId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDdosEvent',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDdosEvent(request: DescribeDdosEventRequest): DescribeDdosEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDdosEventWithOptions(request, runtime);
}

model DescribeInstanceListRequest {
  instanceIdList?: string(name='InstanceIdList'),
  packIdList?: string(name='PackIdList'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeInstanceListResponseBody = {
  instanceList?: [ 
    {
      expireTime?: long(name='ExpireTime'),
      gmtCreate?: long(name='GmtCreate'),
      instanceId?: string(name='InstanceId'),
      packId?: string(name='PackId'),
      product?: string(name='Product'),
      remark?: string(name='Remark'),
      status?: string(name='Status'),
    }
  ](name='InstanceList'),
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
}

model DescribeInstanceListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceListResponseBody(name='body'),
}

async function describeInstanceListWithOptions(request: DescribeInstanceListRequest, runtime: Util.RuntimeOptions): DescribeInstanceListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIdList)) {
    query['InstanceIdList'] = request.instanceIdList;
  }
  if (!Util.isUnset(request.packIdList)) {
    query['PackIdList'] = request.packIdList;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceList',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceList(request: DescribeInstanceListRequest): DescribeInstanceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceListWithOptions(request, runtime);
}

model DescribeOnDemandInstanceRequest {
  pageNo?: int32(name='PageNo', description='The page number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: **50**.', example='10'),
  regionId?: string(name='RegionId', description='The region ID of the on-demand instance that you want to query. 

>  You can call the [DescribeRegions](https://www.alibabacloud.com/help/en/ddos-protection/latest/instances-describeregions) operation to query the most recent region list.', example='cn-zhangjiakou'),
}

model DescribeOnDemandInstanceResponseBody = {
  instances?: [ 
    {
      defenseStatus?: string(name='DefenseStatus', description='The protection status of the on-demand instance. Valid values:

- **Defense**: The on-demand instance is protecting your assets, which indicates that traffic is routed to the on-demand instance.
- **UnDefense**: The on-demand instance does not protect your assets.', example='Defense'),
      instanceId?: string(name='InstanceId', description='The ID of the on-demand instance.', example='ddosbgp-cn-z2q1qzxb****'),
      ipnet?: [ string ](name='Ipnet', description='The CIDR block of the on-demand instance.'),
      regionId?: string(name='RegionId', description='The region ID of the on-demand instance.', example='cn-zhangjiakou'),
      remark?: string(name='Remark', description='The description of the on-demand instance.', example='123'),
    }
  ](name='Instances', description='The details of the on-demand instance.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
  total?: string(name='Total', description='The number of entries that were returned.', example='1'),
}

model DescribeOnDemandInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeOnDemandInstanceResponseBody(name='body'),
}

/**
  * Queries the information about on-demand instances, such as whether an on-demand instance is enabled and the CIDR block of each on-demand instance.  
  * ## Limits
  * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
  * @param request DescribeOnDemandInstanceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeOnDemandInstanceResponse
 */
async function describeOnDemandInstanceWithOptions(request: DescribeOnDemandInstanceRequest, runtime: Util.RuntimeOptions): DescribeOnDemandInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOnDemandInstance',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Queries the information about on-demand instances, such as whether an on-demand instance is enabled and the CIDR block of each on-demand instance.  
  * ## Limits
  * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
  * @param request DescribeOnDemandInstanceRequest
  * @return DescribeOnDemandInstanceResponse
 */
async function describeOnDemandInstance(request: DescribeOnDemandInstanceRequest): DescribeOnDemandInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOnDemandInstanceWithOptions(request, runtime);
}

model DescribeOpEntitiesRequest {
  currentPage?: int32(name='CurrentPage'),
  endTime?: long(name='EndTime'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  sourceIp?: string(name='SourceIp'),
  startTime?: long(name='StartTime'),
}

model DescribeOpEntitiesResponseBody = {
  opEntities?: [ 
    {
      entityObject?: string(name='EntityObject'),
      entityType?: int32(name='EntityType'),
      gmtCreate?: long(name='GmtCreate'),
      opAccount?: string(name='OpAccount'),
      opAction?: int32(name='OpAction'),
      opDesc?: string(name='OpDesc'),
    }
  ](name='OpEntities'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeOpEntitiesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeOpEntitiesResponseBody(name='body'),
}

async function describeOpEntitiesWithOptions(request: DescribeOpEntitiesRequest, runtime: Util.RuntimeOptions): DescribeOpEntitiesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOpEntities',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeOpEntities(request: DescribeOpEntitiesRequest): DescribeOpEntitiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOpEntitiesWithOptions(request, runtime);
}

model DescribePackRequest {
  packId?: string(name='PackId'),
  sourceIp?: string(name='SourceIp'),
}

model DescribePackResponseBody = {
  packInfo?: {
    availableDeleteBlackholeCount?: int32(name='AvailableDeleteBlackholeCount'),
    ipList?: [ 
      {
        ip?: string(name='Ip'),
      }
    ](name='IpList'),
    packConfig?: {
      ipAdvanceThre?: int32(name='IpAdvanceThre'),
      ipBasicThre?: int32(name='IpBasicThre'),
      ipSpec?: int32(name='IpSpec'),
      packAdvThre?: int32(name='PackAdvThre'),
      packBasicThre?: int32(name='PackBasicThre'),
    }(name='PackConfig'),
    region?: string(name='Region'),
  }(name='PackInfo'),
  requestId?: string(name='RequestId'),
}

model DescribePackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePackResponseBody(name='body'),
}

async function describePackWithOptions(request: DescribePackRequest, runtime: Util.RuntimeOptions): DescribePackResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.packId)) {
    query['PackId'] = request.packId;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePack',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePack(request: DescribePackRequest): DescribePackResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePackWithOptions(request, runtime);
}

model DescribePackListRequest {
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribePackListResponseBody = {
  packList?: [ 
    {
      availableDeleteBlackholeCount?: int32(name='AvailableDeleteBlackholeCount'),
      packConfig?: {
        ipAdvanceThre?: int32(name='IpAdvanceThre'),
        ipBasicThre?: int32(name='IpBasicThre'),
        ipSpec?: int32(name='IpSpec'),
        packAdvThre?: int32(name='PackAdvThre'),
        packBasicThre?: int32(name='PackBasicThre'),
      }(name='PackConfig'),
      packId?: string(name='PackId'),
      region?: string(name='Region'),
    }
  ](name='PackList'),
  requestId?: string(name='RequestId'),
}

model DescribePackListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePackListResponseBody(name='body'),
}

async function describePackListWithOptions(request: DescribePackListRequest, runtime: Util.RuntimeOptions): DescribePackListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePackList',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePackList(request: DescribePackListRequest): DescribePackListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePackListWithOptions(request, runtime);
}

model DescribePackPaidTrafficRequest {
  currentPage?: int32(name='CurrentPage'),
  endTime?: long(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  pageSize?: int32(name='PageSize'),
  sourceIp?: string(name='SourceIp'),
  startTime?: long(name='StartTime'),
}

model DescribePackPaidTrafficResponseBody = {
  packPaidTraffics?: [ 
    {
      baseBandwidth?: int32(name='BaseBandwidth'),
      elasticBandwidth?: int32(name='ElasticBandwidth'),
      instanceId?: string(name='InstanceId'),
      maxAttack?: float(name='MaxAttack'),
      paidCapacity?: float(name='PaidCapacity'),
      startTime?: long(name='StartTime'),
      totalCapacity?: float(name='TotalCapacity'),
    }
  ](name='PackPaidTraffics'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribePackPaidTrafficResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePackPaidTrafficResponseBody(name='body'),
}

async function describePackPaidTrafficWithOptions(request: DescribePackPaidTrafficRequest, runtime: Util.RuntimeOptions): DescribePackPaidTrafficResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePackPaidTraffic',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePackPaidTraffic(request: DescribePackPaidTrafficRequest): DescribePackPaidTrafficResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePackPaidTrafficWithOptions(request, runtime);
}

model DescribeResourcePackInstancesRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  sourceIp?: string(name='SourceIp'),
}

model DescribeResourcePackInstancesResponseBody = {
  requestId?: string(name='RequestId'),
  resourcePacks?: [ 
    {
      currCapacity?: long(name='CurrCapacity'),
      endTime?: long(name='EndTime'),
      initCapacity?: long(name='InitCapacity'),
      resourcePackId?: string(name='ResourcePackId'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
    }
  ](name='ResourcePacks'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeResourcePackInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourcePackInstancesResponseBody(name='body'),
}

async function describeResourcePackInstancesWithOptions(request: DescribeResourcePackInstancesRequest, runtime: Util.RuntimeOptions): DescribeResourcePackInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourcePackInstances',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeResourcePackInstances(request: DescribeResourcePackInstancesRequest): DescribeResourcePackInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeResourcePackInstancesWithOptions(request, runtime);
}

model DescribeResourcePackStatisticsRequest {
  sourceIp?: string(name='SourceIp'),
}

model DescribeResourcePackStatisticsResponseBody = {
  availablePackNum?: int32(name='AvailablePackNum'),
  requestId?: string(name='RequestId'),
  totalCurrCapacity?: long(name='TotalCurrCapacity'),
  totalInitCapacity?: long(name='TotalInitCapacity'),
  totalUsedCapacity?: long(name='TotalUsedCapacity'),
}

model DescribeResourcePackStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourcePackStatisticsResponseBody(name='body'),
}

async function describeResourcePackStatisticsWithOptions(request: DescribeResourcePackStatisticsRequest, runtime: Util.RuntimeOptions): DescribeResourcePackStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourcePackStatistics',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeResourcePackStatistics(request: DescribeResourcePackStatisticsRequest): DescribeResourcePackStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeResourcePackStatisticsWithOptions(request, runtime);
}

model DescribeResourcePackUsageRequest {
  endTime?: long(name='EndTime'),
  sourceIp?: string(name='SourceIp'),
  startTime?: long(name='StartTime'),
}

model DescribeResourcePackUsageResponseBody = {
  endTime?: long(name='EndTime'),
  interval?: long(name='Interval'),
  packUsages?: [ 
    {
      time?: long(name='Time'),
      traffic?: float(name='Traffic'),
    }
  ](name='PackUsages'),
  requestId?: string(name='RequestId'),
  startTime?: long(name='StartTime'),
}

model DescribeResourcePackUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourcePackUsageResponseBody(name='body'),
}

async function describeResourcePackUsageWithOptions(request: DescribeResourcePackUsageRequest, runtime: Util.RuntimeOptions): DescribeResourcePackUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourcePackUsage',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeResourcePackUsage(request: DescribeResourcePackUsageRequest): DescribeResourcePackUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeResourcePackUsageWithOptions(request, runtime);
}

model DescribeTopTrafficRequest {
  endTime?: string(name='EndTime', description='The end of the time range to query. This value is a UNIX timestamp. Unit: seconds.', example='1563445054'),
  instanceId?: string(name='InstanceId', description='The ID of the on-demand instance.

>  You can call the [DescribeOnDemandInstance](~~152120~~) operation to query the IDs of all on-demand instances.', example='ddosbgp-cn-z2q1qzxb****'),
  ipnet?: string(name='Ipnet', description='The CIDR block of the on-demand instance that you want to query.', example='47.XX.XX.0/24'),
  pageNo?: int32(name='PageNo', description='The number of the page to return. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **10**. Maximum value: **50**.', example='10'),
  regionId?: string(name='RegionId', description='The region ID of the on-demand instance.

>  You can call the [DescribeRegions](~~118703~~) operation to query the most recent region list.', example='cn-zhangjiakou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the on-demand instance belongs in Resource Management.

If you do not specify this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
  rn?: int32(name='Rn', description='The number of IP addresses from which the most traffic is forwarded. Default value: **1**, which indicates the IP address from which the most traffic is forwarded.', example='1'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. This value is a UNIX timestamp. Unit: seconds.', example='1560853054'),
}

model DescribeTopTrafficResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
  total?: long(name='Total', description='The total number of entries returned.', example='1'),
  trafficList?: [ 
    {
      attackBps?: int32(name='AttackBps', description='The attack traffic. Unit: Kbit/s.', example='0'),
      attackPps?: int32(name='AttackPps', description='The number of attack data packets. Unit: packets per second (pps).', example='0'),
      bps?: int32(name='Bps', description='The total traffic. Unit: Kbit/s.', example='2919212'),
      ip?: string(name='Ip', description='The IP address from which the most traffic is forwarded by the on-demand instance.', example='47.XX.XX.0'),
      pps?: int32(name='Pps', description='The total number of data packets. Unit: pps.', example='100000'),
    }
  ](name='TrafficList', description='The information about the traffic that is forwarded by the on-demand instance.'),
}

model DescribeTopTrafficResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTopTrafficResponseBody(name='body'),
}

/**
  * You can call the DescribeTopTraffic operation to query the top N IP addresses from which the most traffic is forwarded by an on-demand instance within a specific period. 
  * ## Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
  * @param request DescribeTopTrafficRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeTopTrafficResponse
 */
async function describeTopTrafficWithOptions(request: DescribeTopTrafficRequest, runtime: Util.RuntimeOptions): DescribeTopTrafficResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ipnet)) {
    query['Ipnet'] = request.ipnet;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.rn)) {
    query['Rn'] = request.rn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTopTraffic',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call the DescribeTopTraffic operation to query the top N IP addresses from which the most traffic is forwarded by an on-demand instance within a specific period. 
  * ## Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
  * @param request DescribeTopTrafficRequest
  * @return DescribeTopTrafficResponse
 */
async function describeTopTraffic(request: DescribeTopTrafficRequest): DescribeTopTrafficResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTopTrafficWithOptions(request, runtime);
}

model DescribeTrafficRequest {
  endTime?: int32(name='EndTime'),
  interval?: int32(name='Interval'),
  name?: string(name='Name'),
  sourceIp?: string(name='SourceIp'),
  startTime?: int32(name='StartTime'),
}

model DescribeTrafficResponseBody = {
  flowList?: [ 
    {
      flowType?: string(name='FlowType'),
      kbps?: int32(name='Kbps'),
      name?: string(name='Name'),
      pps?: int32(name='Pps'),
      time?: int32(name='Time'),
    }
  ](name='FlowList'),
  requestId?: string(name='RequestId'),
}

model DescribeTrafficResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTrafficResponseBody(name='body'),
}

async function describeTrafficWithOptions(request: DescribeTrafficRequest, runtime: Util.RuntimeOptions): DescribeTrafficResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.sourceIp)) {
    query['SourceIp'] = request.sourceIp;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTraffic',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTraffic(request: DescribeTrafficRequest): DescribeTrafficResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTrafficWithOptions(request, runtime);
}

model ModifyOnDemaondDefenseStatusRequest {
  defenseStatus?: string(name='DefenseStatus', description='The protection status of the on-demand instance. Valid values:

*   **Defense**: enables the on-demand instance.
*   **UnDefense**: disables the on-demand instance.', example='Defense'),
  instanceId?: string(name='InstanceId', description='The ID of the on-demand instance.

>  You can call the [DescribeOnDemandInstance](~~152120~~) operation to query the IDs of all on-demand instances.', example='ddosbgp-cn-z2q1qzxb****'),
  regionId?: string(name='RegionId', description='The region ID of the on-demand instance.

>  You can call the [DescribeRegions](~~118703~~) operation to query the most recent region list.', example='cn-zhangjiakou'),
}

model ModifyOnDemaondDefenseStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4C467B38-3910-447D-87BC-AC049166F216'),
}

model ModifyOnDemaondDefenseStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyOnDemaondDefenseStatusResponseBody(name='body'),
}

async function modifyOnDemaondDefenseStatusWithOptions(request: ModifyOnDemaondDefenseStatusRequest, runtime: Util.RuntimeOptions): ModifyOnDemaondDefenseStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defenseStatus)) {
    query['DefenseStatus'] = request.defenseStatus;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyOnDemaondDefenseStatus',
    version = '2017-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyOnDemaondDefenseStatus(request: ModifyOnDemaondDefenseStatusRequest): ModifyOnDemaondDefenseStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyOnDemaondDefenseStatusWithOptions(request, runtime);
}

