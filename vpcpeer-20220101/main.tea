/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('vpcpeer', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AcceptVpcPeerConnectionRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  instanceId?: string(name='InstanceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
}

model AcceptVpcPeerConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model AcceptVpcPeerConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AcceptVpcPeerConnectionResponseBody(name='body'),
}

async function acceptVpcPeerConnectionWithOptions(request: AcceptVpcPeerConnectionRequest, runtime: Util.RuntimeOptions): AcceptVpcPeerConnectionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    body['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AcceptVpcPeerConnection',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function acceptVpcPeerConnection(request: AcceptVpcPeerConnectionRequest): AcceptVpcPeerConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return acceptVpcPeerConnectionWithOptions(request, runtime);
}

model CreateVpcPeerConnectionRequest {
  acceptingAliUid?: long(name='AcceptingAliUid'),
  acceptingRegionId?: string(name='AcceptingRegionId'),
  acceptingVpcId?: string(name='AcceptingVpcId'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  dryRun?: boolean(name='DryRun'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
}

model CreateVpcPeerConnectionResponseBody = {
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
}

model CreateVpcPeerConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVpcPeerConnectionResponseBody(name='body'),
}

async function createVpcPeerConnectionWithOptions(request: CreateVpcPeerConnectionRequest, runtime: Util.RuntimeOptions): CreateVpcPeerConnectionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.acceptingAliUid)) {
    body['AcceptingAliUid'] = request.acceptingAliUid;
  }
  if (!Util.isUnset(request.acceptingRegionId)) {
    body['AcceptingRegionId'] = request.acceptingRegionId;
  }
  if (!Util.isUnset(request.acceptingVpcId)) {
    body['AcceptingVpcId'] = request.acceptingVpcId;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpcPeerConnection',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVpcPeerConnection(request: CreateVpcPeerConnectionRequest): CreateVpcPeerConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpcPeerConnectionWithOptions(request, runtime);
}

model DeleteVpcPeerConnectionRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  force?: boolean(name='Force', description='是否强删'),
  instanceId?: string(name='InstanceId'),
}

model DeleteVpcPeerConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpcPeerConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVpcPeerConnectionResponseBody(name='body'),
}

async function deleteVpcPeerConnectionWithOptions(request: DeleteVpcPeerConnectionRequest, runtime: Util.RuntimeOptions): DeleteVpcPeerConnectionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.force)) {
    body['Force'] = request.force;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpcPeerConnection',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVpcPeerConnection(request: DeleteVpcPeerConnectionRequest): DeleteVpcPeerConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpcPeerConnectionWithOptions(request, runtime);
}

model GetVpcPeerConnectionAttributeRequest {
  instanceId?: string(name='InstanceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
}

model GetVpcPeerConnectionAttributeResponseBody = {
  acceptingOwnerUid?: long(name='AcceptingOwnerUid'),
  acceptingRegionId?: string(name='AcceptingRegionId'),
  acceptingVpc?: {
    ipv4Cidrs?: [ string ](name='Ipv4Cidrs'),
    ipv6Cidrs?: [ string ](name='Ipv6Cidrs'),
    vpcId?: string(name='VpcId'),
  }(name='AcceptingVpc'),
  bandwidth?: int32(name='Bandwidth'),
  bizStatus?: string(name='BizStatus'),
  description?: string(name='Description'),
  gmtCreate?: string(name='GmtCreate'),
  gmtExpired?: string(name='GmtExpired'),
  gmtModified?: string(name='GmtModified'),
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  vpc?: {
    ipv4Cidrs?: [ string ](name='Ipv4Cidrs'),
    ipv6Cidrs?: [ string ](name='Ipv6Cidrs'),
    vpcId?: string(name='VpcId'),
  }(name='Vpc'),
}

model GetVpcPeerConnectionAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVpcPeerConnectionAttributeResponseBody(name='body'),
}

async function getVpcPeerConnectionAttributeWithOptions(request: GetVpcPeerConnectionAttributeRequest, runtime: Util.RuntimeOptions): GetVpcPeerConnectionAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    body['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetVpcPeerConnectionAttribute',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVpcPeerConnectionAttribute(request: GetVpcPeerConnectionAttributeRequest): GetVpcPeerConnectionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVpcPeerConnectionAttributeWithOptions(request, runtime);
}

model ListVpcPeerConnectionsRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  vpcId?: [ string ](name='VpcId', description='根据两端vpcid过滤，不区分发起端和接收端。如果只传入一个，则根据一端过滤'),
}

model ListVpcPeerConnectionsShrinkRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  vpcIdShrink?: string(name='VpcId', description='根据两端vpcid过滤，不区分发起端和接收端。如果只传入一个，则根据一端过滤'),
}

model ListVpcPeerConnectionsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpcPeerConnects?: [ 
    {
      acceptingOwnerUid?: int32(name='AcceptingOwnerUid'),
      acceptingRegionId?: string(name='AcceptingRegionId'),
      acceptingVpc?: {
        ipv4Cidrs?: [ string ](name='Ipv4Cidrs'),
        ipv6Cidrs?: [ string ](name='Ipv6Cidrs'),
        vpcId?: string(name='VpcId'),
      }(name='AcceptingVpc'),
      bandwidth?: int32(name='Bandwidth'),
      bizStatus?: string(name='BizStatus'),
      description?: string(name='Description'),
      gmtCreate?: string(name='GmtCreate'),
      gmtExpired?: string(name='GmtExpired'),
      gmtModified?: string(name='GmtModified'),
      instanceId?: string(name='InstanceId'),
      name?: string(name='Name'),
      ownerId?: int32(name='OwnerId'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      vpc?: {
        ipv4Cidrs?: [ string ](name='Ipv4Cidrs'),
        ipv6Cidrs?: [ string ](name='Ipv6Cidrs'),
        vpcId?: string(name='VpcId'),
      }(name='Vpc'),
    }
  ](name='VpcPeerConnects'),
}

model ListVpcPeerConnectionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVpcPeerConnectionsResponseBody(name='body'),
}

async function listVpcPeerConnectionsWithOptions(tmpReq: ListVpcPeerConnectionsRequest, runtime: Util.RuntimeOptions): ListVpcPeerConnectionsResponse {
  Util.validateModel(tmpReq);
  var request = new ListVpcPeerConnectionsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.vpcId)) {
    request.vpcIdShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.vpcId, 'VpcId', 'simple');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpcIdShrink)) {
    body['VpcId'] = request.vpcIdShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListVpcPeerConnections',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVpcPeerConnections(request: ListVpcPeerConnectionsRequest): ListVpcPeerConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVpcPeerConnectionsWithOptions(request, runtime);
}

model ModifyVpcPeerConnectionRequest {
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  dryRun?: boolean(name='DryRun'),
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
}

model ModifyVpcPeerConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVpcPeerConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVpcPeerConnectionResponseBody(name='body'),
}

async function modifyVpcPeerConnectionWithOptions(request: ModifyVpcPeerConnectionRequest, runtime: Util.RuntimeOptions): ModifyVpcPeerConnectionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.bandwidth)) {
    body['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVpcPeerConnection',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVpcPeerConnection(request: ModifyVpcPeerConnectionRequest): ModifyVpcPeerConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpcPeerConnectionWithOptions(request, runtime);
}

model RejectVpcPeerConnectionRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  instanceId?: string(name='InstanceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
}

model RejectVpcPeerConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model RejectVpcPeerConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RejectVpcPeerConnectionResponseBody(name='body'),
}

async function rejectVpcPeerConnectionWithOptions(request: RejectVpcPeerConnectionRequest, runtime: Util.RuntimeOptions): RejectVpcPeerConnectionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    body['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RejectVpcPeerConnection',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rejectVpcPeerConnection(request: RejectVpcPeerConnectionRequest): RejectVpcPeerConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return rejectVpcPeerConnectionWithOptions(request, runtime);
}

