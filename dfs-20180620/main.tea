/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('dfs', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateAccessGroupRequest {
  accessGroupName?: string(name='AccessGroupName'),
  description?: string(name='Description'),
  inputRegionId?: string(name='InputRegionId'),
  networkType?: string(name='NetworkType'),
}

model CreateAccessGroupResponseBody = {
  accessGroupId?: string(name='AccessGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateAccessGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAccessGroupResponseBody(name='body'),
}

async function createAccessGroupWithOptions(request: CreateAccessGroupRequest, runtime: Util.RuntimeOptions): CreateAccessGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessGroupName)) {
    query['AccessGroupName'] = request.accessGroupName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccessGroup',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAccessGroup(request: CreateAccessGroupRequest): CreateAccessGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccessGroupWithOptions(request, runtime);
}

model CreateAccessRuleRequest {
  accessGroupId?: string(name='AccessGroupId'),
  description?: string(name='Description'),
  inputRegionId?: string(name='InputRegionId'),
  networkSegment?: string(name='NetworkSegment'),
  priority?: int32(name='Priority'),
  RWAccessType?: string(name='RWAccessType'),
}

model CreateAccessRuleResponseBody = {
  accessRuleId?: string(name='AccessRuleId'),
  requestId?: string(name='RequestId'),
}

model CreateAccessRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAccessRuleResponseBody(name='body'),
}

async function createAccessRuleWithOptions(request: CreateAccessRuleRequest, runtime: Util.RuntimeOptions): CreateAccessRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessGroupId)) {
    query['AccessGroupId'] = request.accessGroupId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  if (!Util.isUnset(request.networkSegment)) {
    query['NetworkSegment'] = request.networkSegment;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.RWAccessType)) {
    query['RWAccessType'] = request.RWAccessType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccessRule',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAccessRule(request: CreateAccessRuleRequest): CreateAccessRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccessRuleWithOptions(request, runtime);
}

model CreateFileSystemRequest {
  dataRedundancyType?: string(name='DataRedundancyType'),
  description?: string(name='Description'),
  fileSystemName?: string(name='FileSystemName'),
  inputRegionId?: string(name='InputRegionId'),
  partitionNumber?: int32(name='PartitionNumber'),
  protocolType?: string(name='ProtocolType'),
  provisionedThroughputInMiBps?: long(name='ProvisionedThroughputInMiBps'),
  spaceCapacity?: long(name='SpaceCapacity'),
  storageSetName?: string(name='StorageSetName'),
  storageType?: string(name='StorageType'),
  throughputMode?: string(name='ThroughputMode'),
  zoneId?: string(name='ZoneId'),
}

model CreateFileSystemResponseBody = {
  fileSystemId?: string(name='FileSystemId'),
  requestId?: string(name='RequestId'),
}

model CreateFileSystemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFileSystemResponseBody(name='body'),
}

async function createFileSystemWithOptions(request: CreateFileSystemRequest, runtime: Util.RuntimeOptions): CreateFileSystemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataRedundancyType)) {
    query['DataRedundancyType'] = request.dataRedundancyType;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.fileSystemName)) {
    query['FileSystemName'] = request.fileSystemName;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  if (!Util.isUnset(request.partitionNumber)) {
    query['PartitionNumber'] = request.partitionNumber;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.provisionedThroughputInMiBps)) {
    query['ProvisionedThroughputInMiBps'] = request.provisionedThroughputInMiBps;
  }
  if (!Util.isUnset(request.spaceCapacity)) {
    query['SpaceCapacity'] = request.spaceCapacity;
  }
  if (!Util.isUnset(request.storageSetName)) {
    query['StorageSetName'] = request.storageSetName;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  if (!Util.isUnset(request.throughputMode)) {
    query['ThroughputMode'] = request.throughputMode;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFileSystem',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFileSystem(request: CreateFileSystemRequest): CreateFileSystemResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFileSystemWithOptions(request, runtime);
}

model CreateMountPointRequest {
  accessGroupId?: string(name='AccessGroupId'),
  description?: string(name='Description'),
  fileSystemId?: string(name='FileSystemId'),
  inputRegionId?: string(name='InputRegionId'),
  networkType?: string(name='NetworkType'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model CreateMountPointResponseBody = {
  mountPointId?: string(name='MountPointId'),
  requestId?: string(name='RequestId'),
}

model CreateMountPointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMountPointResponseBody(name='body'),
}

async function createMountPointWithOptions(request: CreateMountPointRequest, runtime: Util.RuntimeOptions): CreateMountPointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessGroupId)) {
    query['AccessGroupId'] = request.accessGroupId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMountPoint',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMountPoint(request: CreateMountPointRequest): CreateMountPointResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMountPointWithOptions(request, runtime);
}

model CreateUserGroupsMappingRequest {
  fileSystemId?: string(name='FileSystemId'),
  groupNames?: map[string]any(name='GroupNames'),
  inputRegionId?: string(name='InputRegionId'),
  userName?: string(name='UserName'),
}

model CreateUserGroupsMappingShrinkRequest {
  fileSystemId?: string(name='FileSystemId'),
  groupNamesShrink?: string(name='GroupNames'),
  inputRegionId?: string(name='InputRegionId'),
  userName?: string(name='UserName'),
}

model CreateUserGroupsMappingResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateUserGroupsMappingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUserGroupsMappingResponseBody(name='body'),
}

async function createUserGroupsMappingWithOptions(tmpReq: CreateUserGroupsMappingRequest, runtime: Util.RuntimeOptions): CreateUserGroupsMappingResponse {
  Util.validateModel(tmpReq);
  var request = new CreateUserGroupsMappingShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.groupNames)) {
    request.groupNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.groupNames, 'GroupNames', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUserGroupsMapping',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUserGroupsMapping(request: CreateUserGroupsMappingRequest): CreateUserGroupsMappingResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserGroupsMappingWithOptions(request, runtime);
}

model DeleteAccessGroupRequest {
  accessGroupId?: string(name='AccessGroupId'),
  inputRegionId?: string(name='InputRegionId'),
}

model DeleteAccessGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAccessGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAccessGroupResponseBody(name='body'),
}

async function deleteAccessGroupWithOptions(request: DeleteAccessGroupRequest, runtime: Util.RuntimeOptions): DeleteAccessGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessGroupId)) {
    query['AccessGroupId'] = request.accessGroupId;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAccessGroup',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAccessGroup(request: DeleteAccessGroupRequest): DeleteAccessGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccessGroupWithOptions(request, runtime);
}

model DeleteAccessRuleRequest {
  accessGroupId?: string(name='AccessGroupId'),
  accessRuleId?: string(name='AccessRuleId'),
  inputRegionId?: string(name='InputRegionId'),
}

model DeleteAccessRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAccessRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAccessRuleResponseBody(name='body'),
}

async function deleteAccessRuleWithOptions(request: DeleteAccessRuleRequest, runtime: Util.RuntimeOptions): DeleteAccessRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessGroupId)) {
    query['AccessGroupId'] = request.accessGroupId;
  }
  if (!Util.isUnset(request.accessRuleId)) {
    query['AccessRuleId'] = request.accessRuleId;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAccessRule',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAccessRule(request: DeleteAccessRuleRequest): DeleteAccessRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccessRuleWithOptions(request, runtime);
}

model DeleteFileSystemRequest {
  fileSystemId?: string(name='FileSystemId'),
  inputRegionId?: string(name='InputRegionId'),
}

model DeleteFileSystemResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFileSystemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFileSystemResponseBody(name='body'),
}

async function deleteFileSystemWithOptions(request: DeleteFileSystemRequest, runtime: Util.RuntimeOptions): DeleteFileSystemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFileSystem',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFileSystem(request: DeleteFileSystemRequest): DeleteFileSystemResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFileSystemWithOptions(request, runtime);
}

model DeleteMountPointRequest {
  fileSystemId?: string(name='FileSystemId'),
  inputRegionId?: string(name='InputRegionId'),
  mountPointId?: string(name='MountPointId'),
}

model DeleteMountPointResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMountPointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMountPointResponseBody(name='body'),
}

async function deleteMountPointWithOptions(request: DeleteMountPointRequest, runtime: Util.RuntimeOptions): DeleteMountPointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  if (!Util.isUnset(request.mountPointId)) {
    query['MountPointId'] = request.mountPointId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMountPoint',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMountPoint(request: DeleteMountPointRequest): DeleteMountPointResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMountPointWithOptions(request, runtime);
}

model DeleteUserGroupsMappingRequest {
  fileSystemId?: string(name='FileSystemId'),
  groupNames?: map[string]any(name='GroupNames'),
  inputRegionId?: string(name='InputRegionId'),
  userName?: string(name='UserName'),
}

model DeleteUserGroupsMappingShrinkRequest {
  fileSystemId?: string(name='FileSystemId'),
  groupNamesShrink?: string(name='GroupNames'),
  inputRegionId?: string(name='InputRegionId'),
  userName?: string(name='UserName'),
}

model DeleteUserGroupsMappingResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUserGroupsMappingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUserGroupsMappingResponseBody(name='body'),
}

async function deleteUserGroupsMappingWithOptions(tmpReq: DeleteUserGroupsMappingRequest, runtime: Util.RuntimeOptions): DeleteUserGroupsMappingResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteUserGroupsMappingShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.groupNames)) {
    request.groupNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.groupNames, 'GroupNames', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUserGroupsMapping',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUserGroupsMapping(request: DeleteUserGroupsMappingRequest): DeleteUserGroupsMappingResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserGroupsMappingWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  inputRegionId?: string(name='InputRegionId'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
      {
        localName?: string(name='LocalName'),
        regionEndpoint?: string(name='RegionEndpoint'),
        regionId?: string(name='RegionId'),
      }
    ](name='Region'),
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model GetAccessGroupRequest {
  accessGroupId?: string(name='AccessGroupId'),
  inputRegionId?: string(name='InputRegionId'),
}

model GetAccessGroupResponseBody = {
  accessGroup?: {
    accessGroupId?: string(name='AccessGroupId'),
    accessGroupName?: string(name='AccessGroupName'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    isDefault?: boolean(name='IsDefault'),
    mountPointCount?: int32(name='MountPointCount'),
    networkType?: string(name='NetworkType'),
    regionId?: string(name='RegionId'),
    ruleCount?: int32(name='RuleCount'),
  }(name='AccessGroup'),
  requestId?: string(name='RequestId'),
}

model GetAccessGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAccessGroupResponseBody(name='body'),
}

async function getAccessGroupWithOptions(request: GetAccessGroupRequest, runtime: Util.RuntimeOptions): GetAccessGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessGroupId)) {
    query['AccessGroupId'] = request.accessGroupId;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAccessGroup',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAccessGroup(request: GetAccessGroupRequest): GetAccessGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccessGroupWithOptions(request, runtime);
}

model GetAccessRuleRequest {
  accessGroupId?: string(name='AccessGroupId'),
  accessRuleId?: string(name='AccessRuleId'),
  inputRegionId?: string(name='InputRegionId'),
}

model GetAccessRuleResponseBody = {
  accessRule?: {
    accessGroupId?: string(name='AccessGroupId'),
    accessRuleId?: string(name='AccessRuleId'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    networkSegment?: string(name='NetworkSegment'),
    priority?: int32(name='Priority'),
    RWAccessType?: string(name='RWAccessType'),
    regionId?: string(name='RegionId'),
  }(name='AccessRule'),
  requestId?: string(name='RequestId'),
}

model GetAccessRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAccessRuleResponseBody(name='body'),
}

async function getAccessRuleWithOptions(request: GetAccessRuleRequest, runtime: Util.RuntimeOptions): GetAccessRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessGroupId)) {
    query['AccessGroupId'] = request.accessGroupId;
  }
  if (!Util.isUnset(request.accessRuleId)) {
    query['AccessRuleId'] = request.accessRuleId;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAccessRule',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAccessRule(request: GetAccessRuleRequest): GetAccessRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccessRuleWithOptions(request, runtime);
}

model GetFileSystemRequest {
  fileSystemId?: string(name='FileSystemId'),
  inputRegionId?: string(name='InputRegionId'),
}

model GetFileSystemResponseBody = {
  fileSystem?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    fileSystemId?: string(name='FileSystemId'),
    fileSystemName?: string(name='FileSystemName'),
    meteringSpaceSize?: float(name='MeteringSpaceSize'),
    mountPointCount?: long(name='MountPointCount'),
    numberOfDirectories?: long(name='NumberOfDirectories'),
    numberOfFiles?: long(name='NumberOfFiles'),
    protocolType?: string(name='ProtocolType'),
    provisionedThroughputInMiBps?: long(name='ProvisionedThroughputInMiBps'),
    regionId?: string(name='RegionId'),
    spaceCapacity?: long(name='SpaceCapacity'),
    storagePackageId?: string(name='StoragePackageId'),
    storageType?: string(name='StorageType'),
    throughputMode?: string(name='ThroughputMode'),
    usedSpaceSize?: float(name='UsedSpaceSize'),
    version?: string(name='Version'),
    zoneId?: string(name='ZoneId'),
  }(name='FileSystem'),
  requestId?: string(name='RequestId'),
}

model GetFileSystemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFileSystemResponseBody(name='body'),
}

async function getFileSystemWithOptions(request: GetFileSystemRequest, runtime: Util.RuntimeOptions): GetFileSystemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFileSystem',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFileSystem(request: GetFileSystemRequest): GetFileSystemResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileSystemWithOptions(request, runtime);
}

model GetMountPointRequest {
  fileSystemId?: string(name='FileSystemId'),
  inputRegionId?: string(name='InputRegionId'),
  mountPointId?: string(name='MountPointId'),
}

model GetMountPointResponseBody = {
  mountPoint?: {
    accessGroupId?: string(name='AccessGroupId'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    fileSystemId?: string(name='FileSystemId'),
    mountPointDomain?: string(name='MountPointDomain'),
    mountPointId?: string(name='MountPointId'),
    networkType?: string(name='NetworkType'),
    regionId?: string(name='RegionId'),
    status?: string(name='Status'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
  }(name='MountPoint'),
  requestId?: string(name='RequestId'),
}

model GetMountPointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMountPointResponseBody(name='body'),
}

async function getMountPointWithOptions(request: GetMountPointRequest, runtime: Util.RuntimeOptions): GetMountPointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  if (!Util.isUnset(request.mountPointId)) {
    query['MountPointId'] = request.mountPointId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMountPoint',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMountPoint(request: GetMountPointRequest): GetMountPointResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMountPointWithOptions(request, runtime);
}

model GetRegionRequest {
  inputRegionId?: string(name='InputRegionId'),
}

model GetRegionResponseBody = {
  availableZones?: [ 
    {
      options?: [ 
        {
          protocolType?: string(name='ProtocolType'),
          storageType?: string(name='StorageType'),
        }
      ](name='Options'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='AvailableZones'),
  requestId?: string(name='RequestId'),
}

model GetRegionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRegionResponseBody(name='body'),
}

async function getRegionWithOptions(request: GetRegionRequest, runtime: Util.RuntimeOptions): GetRegionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRegion',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRegion(request: GetRegionRequest): GetRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegionWithOptions(request, runtime);
}

model ListAccessGroupsRequest {
  inputRegionId?: string(name='InputRegionId'),
  limit?: int32(name='Limit'),
  orderBy?: string(name='OrderBy'),
  orderType?: string(name='OrderType'),
  startOffset?: int32(name='StartOffset'),
}

model ListAccessGroupsResponseBody = {
  accessGroups?: [ 
    {
      accessGroupId?: string(name='AccessGroupId'),
      accessGroupName?: string(name='AccessGroupName'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      isDefault?: boolean(name='IsDefault'),
      mountPointCount?: int32(name='MountPointCount'),
      networkType?: string(name='NetworkType'),
      regionId?: string(name='RegionId'),
      ruleCount?: int32(name='RuleCount'),
    }
  ](name='AccessGroups'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAccessGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAccessGroupsResponseBody(name='body'),
}

async function listAccessGroupsWithOptions(request: ListAccessGroupsRequest, runtime: Util.RuntimeOptions): ListAccessGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.startOffset)) {
    query['StartOffset'] = request.startOffset;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAccessGroups',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAccessGroups(request: ListAccessGroupsRequest): ListAccessGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccessGroupsWithOptions(request, runtime);
}

model ListAccessRulesRequest {
  accessGroupId?: string(name='AccessGroupId'),
  inputRegionId?: string(name='InputRegionId'),
  limit?: int32(name='Limit'),
  orderBy?: string(name='OrderBy'),
  orderType?: string(name='OrderType'),
  startOffset?: int32(name='StartOffset'),
}

model ListAccessRulesResponseBody = {
  accessRules?: [ 
    {
      accessGroupId?: string(name='AccessGroupId'),
      accessRuleId?: string(name='AccessRuleId'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      networkSegment?: string(name='NetworkSegment'),
      priority?: int32(name='Priority'),
      RWAccessType?: string(name='RWAccessType'),
      regionId?: string(name='RegionId'),
    }
  ](name='AccessRules'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAccessRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAccessRulesResponseBody(name='body'),
}

async function listAccessRulesWithOptions(request: ListAccessRulesRequest, runtime: Util.RuntimeOptions): ListAccessRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessGroupId)) {
    query['AccessGroupId'] = request.accessGroupId;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.startOffset)) {
    query['StartOffset'] = request.startOffset;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAccessRules',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAccessRules(request: ListAccessRulesRequest): ListAccessRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccessRulesWithOptions(request, runtime);
}

model ListFileSystemsRequest {
  inputRegionId?: string(name='InputRegionId'),
  limit?: int32(name='Limit'),
  orderBy?: string(name='OrderBy'),
  orderType?: string(name='OrderType'),
  startOffset?: int32(name='StartOffset'),
}

model ListFileSystemsResponseBody = {
  fileSystems?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      fileSystemId?: string(name='FileSystemId'),
      fileSystemName?: string(name='FileSystemName'),
      meteringSpaceSize?: float(name='MeteringSpaceSize'),
      mountPointCount?: long(name='MountPointCount'),
      numberOfDirectories?: long(name='NumberOfDirectories'),
      numberOfFiles?: long(name='NumberOfFiles'),
      protocolType?: string(name='ProtocolType'),
      provisionedThroughputInMiBps?: long(name='ProvisionedThroughputInMiBps'),
      regionId?: string(name='RegionId'),
      spaceCapacity?: long(name='SpaceCapacity'),
      storagePackageId?: string(name='StoragePackageId'),
      storageType?: string(name='StorageType'),
      throughputMode?: string(name='ThroughputMode'),
      usedSpaceSize?: float(name='UsedSpaceSize'),
      version?: string(name='Version'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='FileSystems'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListFileSystemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFileSystemsResponseBody(name='body'),
}

async function listFileSystemsWithOptions(request: ListFileSystemsRequest, runtime: Util.RuntimeOptions): ListFileSystemsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.startOffset)) {
    query['StartOffset'] = request.startOffset;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFileSystems',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFileSystems(request: ListFileSystemsRequest): ListFileSystemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFileSystemsWithOptions(request, runtime);
}

model ListMountPointsRequest {
  fileSystemId?: string(name='FileSystemId'),
  inputRegionId?: string(name='InputRegionId'),
  limit?: int32(name='Limit'),
  orderBy?: string(name='OrderBy'),
  orderType?: string(name='OrderType'),
  startOffset?: int32(name='StartOffset'),
}

model ListMountPointsResponseBody = {
  mountPoints?: [ 
    {
      accessGroupId?: string(name='AccessGroupId'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      fileSystemId?: string(name='FileSystemId'),
      mountPointDomain?: string(name='MountPointDomain'),
      mountPointId?: string(name='MountPointId'),
      networkType?: string(name='NetworkType'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
    }
  ](name='MountPoints'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListMountPointsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMountPointsResponseBody(name='body'),
}

async function listMountPointsWithOptions(request: ListMountPointsRequest, runtime: Util.RuntimeOptions): ListMountPointsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.startOffset)) {
    query['StartOffset'] = request.startOffset;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMountPoints',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMountPoints(request: ListMountPointsRequest): ListMountPointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMountPointsWithOptions(request, runtime);
}

model ListUserGroupsMappingsRequest {
  filesystemId?: string(name='FilesystemId'),
  inputRegionId?: string(name='InputRegionId'),
  limit?: int32(name='Limit'),
  nextToken?: string(name='NextToken'),
}

model ListUserGroupsMappingsResponseBody = {
  hasMore?: boolean(name='HasMore'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  userGroupsMappings?: [ 
    {
      groupNames?: [ string ](name='GroupNames'),
      userName?: string(name='UserName'),
    }
  ](name='UserGroupsMappings'),
}

model ListUserGroupsMappingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserGroupsMappingsResponseBody(name='body'),
}

async function listUserGroupsMappingsWithOptions(request: ListUserGroupsMappingsRequest, runtime: Util.RuntimeOptions): ListUserGroupsMappingsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filesystemId)) {
    query['FilesystemId'] = request.filesystemId;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserGroupsMappings',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserGroupsMappings(request: ListUserGroupsMappingsRequest): ListUserGroupsMappingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserGroupsMappingsWithOptions(request, runtime);
}

model ModifyAccessGroupRequest {
  accessGroupId?: string(name='AccessGroupId'),
  accessGroupName?: string(name='AccessGroupName'),
  description?: string(name='Description'),
  inputRegionId?: string(name='InputRegionId'),
}

model ModifyAccessGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAccessGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAccessGroupResponseBody(name='body'),
}

async function modifyAccessGroupWithOptions(request: ModifyAccessGroupRequest, runtime: Util.RuntimeOptions): ModifyAccessGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessGroupId)) {
    query['AccessGroupId'] = request.accessGroupId;
  }
  if (!Util.isUnset(request.accessGroupName)) {
    query['AccessGroupName'] = request.accessGroupName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAccessGroup',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyAccessGroup(request: ModifyAccessGroupRequest): ModifyAccessGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAccessGroupWithOptions(request, runtime);
}

model ModifyAccessRuleRequest {
  accessGroupId?: string(name='AccessGroupId'),
  accessRuleId?: string(name='AccessRuleId'),
  description?: string(name='Description'),
  inputRegionId?: string(name='InputRegionId'),
  priority?: int32(name='Priority'),
  RWAccessType?: string(name='RWAccessType'),
}

model ModifyAccessRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAccessRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAccessRuleResponseBody(name='body'),
}

async function modifyAccessRuleWithOptions(request: ModifyAccessRuleRequest, runtime: Util.RuntimeOptions): ModifyAccessRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessGroupId)) {
    query['AccessGroupId'] = request.accessGroupId;
  }
  if (!Util.isUnset(request.accessRuleId)) {
    query['AccessRuleId'] = request.accessRuleId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.RWAccessType)) {
    query['RWAccessType'] = request.RWAccessType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAccessRule',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyAccessRule(request: ModifyAccessRuleRequest): ModifyAccessRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAccessRuleWithOptions(request, runtime);
}

model ModifyFileSystemRequest {
  description?: string(name='Description'),
  fileSystemId?: string(name='FileSystemId'),
  fileSystemName?: string(name='FileSystemName'),
  inputRegionId?: string(name='InputRegionId'),
  provisionedThroughputInMiBps?: long(name='ProvisionedThroughputInMiBps'),
  spaceCapacity?: long(name='SpaceCapacity'),
  throughputMode?: string(name='ThroughputMode'),
}

model ModifyFileSystemResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyFileSystemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyFileSystemResponseBody(name='body'),
}

async function modifyFileSystemWithOptions(request: ModifyFileSystemRequest, runtime: Util.RuntimeOptions): ModifyFileSystemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!Util.isUnset(request.fileSystemName)) {
    query['FileSystemName'] = request.fileSystemName;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  if (!Util.isUnset(request.provisionedThroughputInMiBps)) {
    query['ProvisionedThroughputInMiBps'] = request.provisionedThroughputInMiBps;
  }
  if (!Util.isUnset(request.spaceCapacity)) {
    query['SpaceCapacity'] = request.spaceCapacity;
  }
  if (!Util.isUnset(request.throughputMode)) {
    query['ThroughputMode'] = request.throughputMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyFileSystem',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyFileSystem(request: ModifyFileSystemRequest): ModifyFileSystemResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFileSystemWithOptions(request, runtime);
}

model ModifyMountPointRequest {
  accessGroupId?: string(name='AccessGroupId'),
  description?: string(name='Description'),
  fileSystemId?: string(name='FileSystemId'),
  inputRegionId?: string(name='InputRegionId'),
  mountPointId?: string(name='MountPointId'),
  status?: string(name='Status'),
}

model ModifyMountPointResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyMountPointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyMountPointResponseBody(name='body'),
}

async function modifyMountPointWithOptions(request: ModifyMountPointRequest, runtime: Util.RuntimeOptions): ModifyMountPointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessGroupId)) {
    query['AccessGroupId'] = request.accessGroupId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!Util.isUnset(request.inputRegionId)) {
    query['InputRegionId'] = request.inputRegionId;
  }
  if (!Util.isUnset(request.mountPointId)) {
    query['MountPointId'] = request.mountPointId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyMountPoint',
    version = '2018-06-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyMountPoint(request: ModifyMountPointRequest): ModifyMountPointResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMountPointWithOptions(request, runtime);
}

