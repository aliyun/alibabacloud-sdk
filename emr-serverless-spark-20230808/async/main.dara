/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'emr-serverless-spark';
  @version = '2023-08-08';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model Artifact {
  bizId: string(name='bizId', description='This parameter is required.'),
  catagoryBizId?: string(name='catagoryBizId'),
  creator: long(name='creator', description='This parameter is required.'),
  credential?: Credential(name='credential'),
  fullPath?: [ string ](name='fullPath'),
  gmtCreated: string(name='gmtCreated', description='This parameter is required.'),
  gmtModified: string(name='gmtModified', description='This parameter is required.'),
  location: string(name='location', description='This parameter is required.'),
  modifier: long(name='modifier', description='This parameter is required.'),
  modifierName?: string(name='modifierName'),
  name: string(name='name', description='This parameter is required.'),
}

model Category {
  bizId: string(name='bizId', description='This parameter is required.'),
  creator: long(name='creator', description='This parameter is required.'),
  gmtCreated: string(name='gmtCreated', description='This parameter is required.'),
  gmtModified: string(name='gmtModified', description='This parameter is required.'),
  modifier: long(name='modifier', description='This parameter is required.'),
  name: string(name='name', description='This parameter is required.', minLength=1, maxLength=64),
  parentBizId?: string(name='parentBizId'),
  type: string(name='type', description='This parameter is required.'),
}

model Configuration {
  configFileName?: string(name='configFileName'),
  configItemKey?: string(name='configItemKey'),
  configItemValue?: string(name='configItemValue'),
}

model ConfigurationOverrides {
  configurations?: [ 
    {
      configFileName?: string(name='configFileName'),
      configItemKey?: string(name='configItemKey'),
      configItemValue?: string(name='configItemValue'),
    }
  ](name='configurations'),
}

model Credential {
  accessId: string(name='accessId', description='This parameter is required.'),
  dir: string(name='dir', description='This parameter is required.'),
  expire: string(name='expire', description='This parameter is required.'),
  host: string(name='host', description='This parameter is required.'),
  policy: string(name='policy', description='This parameter is required.'),
  securityToken: string(name='securityToken', description='This parameter is required.'),
  signature: string(name='signature', description='This parameter is required.'),
}

model JobDriver {
  sparkSubmit?: {
    entryPoint?: string(name='entryPoint'),
    entryPointArguments?: [ string ](name='entryPointArguments'),
    sparkSubmitParameters?: string(name='sparkSubmitParameters'),
  }(name='sparkSubmit'),
}

model KerberosConf {
  creator?: string(name='creator'),
  enabled?: boolean(name='enabled'),
  gmtCreated?: string(name='gmtCreated'),
  gmtModified?: string(name='gmtModified'),
  kerberosConfId?: string(name='kerberosConfId'),
  keytabs?: [ string ](name='keytabs'),
  krb5Conf?: string(name='krb5Conf'),
  name?: string(name='name'),
  networkServiceId?: string(name='networkServiceId'),
  workspaceId?: string(name='workspaceId'),
}

model PrincipalAction {
  actionArn?: string(name='actionArn', example='acs:emr::workspaceId:action/create_queue'),
  principalArn?: string(name='principalArn', example='acs:emr::workspaceId:user/237593691541622267'),
}

model ReleaseVersionImage {
  cpuArchitecture?: string(name='cpuArchitecture'),
  imageId?: string(name='imageId'),
  runtimeEngineType?: string(name='runtimeEngineType'),
}

model RunLog {
  driverStartup?: string(name='driverStartup'),
  driverStdError?: string(name='driverStdError'),
  driverStdOut?: string(name='driverStdOut'),
  driverSyslog?: string(name='driverSyslog'),
}

model SparkConf {
  key: string(name='key', description='This parameter is required.'),
  value: string(name='value', description='This parameter is required.'),
}

model SqlOutput {
  rows?: [ 
    {
      values?: [ string ](name='values', example='null'),
    }
  ](name='rows'),
  schema?: {
    fields?: [ 
      {
        name?: string(name='name'),
        nullable?: boolean(name='nullable'),
        type?: string(name='type'),
      }
    ](name='fields'),
  }(name='schema'),
}

model Tag {
  key?: string(name='key', description='标签key值。', example='workflowId'),
  value?: string(name='value', description='标签key值。', example='wf-123test'),
}

model Task {
  archives?: [ string ](name='archives'),
  artifactUrl?: string(name='artifactUrl'),
  bizId: string(name='bizId', description='This parameter is required.'),
  categoryBizId?: string(name='categoryBizId'),
  content?: string(name='content'),
  creator: long(name='creator', description='This parameter is required.'),
  credential?: {
    accessId?: string(name='accessId'),
    accessUrl?: string(name='accessUrl'),
    expire?: long(name='expire'),
    host?: string(name='host'),
    path?: string(name='path'),
    policy?: string(name='policy'),
    securityToken?: string(name='securityToken'),
    signature?: string(name='signature'),
  }(name='credential'),
  defaultCatalogId?: string(name='defaultCatalogId'),
  defaultDatabase?: string(name='defaultDatabase'),
  defaultResourceQueueId?: string(name='defaultResourceQueueId'),
  defaultSqlComputeId?: string(name='defaultSqlComputeId'),
  deploymentId?: string(name='deploymentId'),
  environmentId?: string(name='environmentId'),
  extraArtifactIds?: [ string ](name='extraArtifactIds'),
  extraSparkSubmitParams?: string(name='extraSparkSubmitParams'),
  files?: [ string ](name='files'),
  fusion?: boolean(name='fusion'),
  gmtCreated: string(name='gmtCreated', description='This parameter is required.'),
  gmtModified: string(name='gmtModified', description='This parameter is required.'),
  hasChanged?: boolean(name='hasChanged'),
  hasCommited: boolean(name='hasCommited', description='This parameter is required.'),
  isStreaming?: boolean(name='isStreaming'),
  jars?: [ string ](name='jars'),
  kernelId?: string(name='kernelId'),
  lastRunResourceQueueId?: string(name='lastRunResourceQueueId'),
  modifier: long(name='modifier', description='This parameter is required.'),
  name: string(name='name', description='This parameter is required.'),
  params?: map[string]string(name='params'),
  pyFiles?: [ string ](name='pyFiles'),
  sessionClusterId?: string(name='sessionClusterId'),
  sparkArgs?: string(name='sparkArgs', example='100'),
  sparkConf?: [
    SparkConf
  ](name='sparkConf'),
  sparkDriverCores: int32(name='sparkDriverCores', description='This parameter is required.'),
  sparkDriverMemory: long(name='sparkDriverMemory', description='This parameter is required.'),
  sparkEntrypoint?: string(name='sparkEntrypoint'),
  sparkExecutorCores: int32(name='sparkExecutorCores', description='This parameter is required.'),
  sparkExecutorMemory: long(name='sparkExecutorMemory', description='This parameter is required.'),
  sparkLogLevel: string(name='sparkLogLevel', description='This parameter is required.'),
  sparkLogPath: string(name='sparkLogPath', description='This parameter is required.'),
  sparkSubmitClause?: string(name='sparkSubmitClause'),
  sparkVersion: string(name='sparkVersion', description='This parameter is required.'),
  tags?: map[string]string(name='tags'),
  timeout?: int32(name='timeout'),
  type: string(name='type', description='This parameter is required.'),
}

model TaskInstance {
  bizId?: string(name='bizId'),
  creator?: long(name='creator'),
  fenixRunId?: string(name='fenixRunId'),
  gmtCreated?: string(name='gmtCreated'),
  taskBizId?: string(name='taskBizId'),
  taskInfo?: Task(name='taskInfo'),
  taskStatus?: string(name='taskStatus'),
  workspaceBizId?: string(name='workspaceBizId'),
}

model TaskSnapshot {
  bizId?: string(name='bizId'),
  commiter?: long(name='commiter'),
  gmtCreated?: string(name='gmtCreated'),
  item?: Task(name='item'),
  message?: string(name='message'),
  taskBizId?: string(name='taskBizId'),
  version?: string(name='version'),
}

model Template {
  bizId?: string(name='bizId'),
  creator: long(name='creator', description='This parameter is required.'),
  displaySparkVersion?: string(name='displaySparkVersion'),
  fusion?: boolean(name='fusion'),
  gmtCreated: string(name='gmtCreated', description='This parameter is required.'),
  gmtModified: string(name='gmtModified', description='This parameter is required.'),
  isDefault?: boolean(name='isDefault'),
  modifier: long(name='modifier', description='This parameter is required.'),
  name?: string(name='name'),
  sparkConf?: [
    SparkConf
  ](name='sparkConf'),
  sparkDriverCores: int32(name='sparkDriverCores', description='This parameter is required.'),
  sparkDriverMemory: long(name='sparkDriverMemory', description='This parameter is required.'),
  sparkExecutorCores: int32(name='sparkExecutorCores', description='This parameter is required.'),
  sparkExecutorMemory: long(name='sparkExecutorMemory', description='This parameter is required.'),
  sparkLogLevel: string(name='sparkLogLevel', description='This parameter is required.'),
  sparkLogPath: string(name='sparkLogPath', description='This parameter is required.'),
  sparkVersion: string(name='sparkVersion', description='This parameter is required.'),
  templateType?: string(name='templateType'),
}

model TimeRange {
  endTime?: long(name='endTime', description='时间范围结束时间。', example='1688370894339'),
  startTime?: long(name='startTime', description='时间范围开始时间。', example='1688370894339'),
}

model AddMembersRequest {
  memberArns: [ string ](name='memberArns', description='This parameter is required.', position='Body'),
  workspaceId: string(name='workspaceId', description='The workspace ID.

This parameter is required.', example='w-975bcfda9625****', position='Body'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
}

model AddMembersResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model AddMembersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddMembersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AddMembers  AddMembersRequest
  * @return AddMembersResponse
 */
async function addMembers(request: AddMembersRequest): AddMembersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AddMembers', 'POST', '/api/v1/auth/members', 'json', false, 'json', request);
}

model CancelJobRunRequest {
  workspaceId: string(name='workspaceId', description='The workspace ID.

This parameter is required.', example='w-1234abcd', position='Path'),
  jobRunId: string(name='jobRunId', description='The job ID.

This parameter is required.', example='jr-231231', position='Path'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
}

model CancelJobRunResponseBody = {
  jobRunId?: string(name='jobRunId', description='The job ID.', example='jr-1a2bc3'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model CancelJobRunResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelJobRunResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CancelJobRun  CancelJobRunRequest
  * @return CancelJobRunResponse
 */
async function cancelJobRun(request: CancelJobRunRequest): CancelJobRunResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CancelJobRun', 'DELETE', '/api/v1/workspaces/{workspaceId}/jobRuns/{jobRunId}', 'json', false, 'json', request);
}

model CreateLivyComputeRequest {
  workspaceBizId?: string(name='workspaceBizId', example='w-8adde60aa809701f', position='Path'),
  authType?: string(name='authType', example='Token', position='Body'),
  autoStartConfiguration?: {
    enable?: boolean(name='enable', example='false'),
  }(name='autoStartConfiguration', position='Body'),
  autoStopConfiguration?: {
    enable?: boolean(name='enable', example='false'),
    idleTimeoutMinutes?: long(name='idleTimeoutMinutes', example='300'),
  }(name='autoStopConfiguration', position='Body'),
  cpuLimit?: string(name='cpuLimit', example='1', position='Body'),
  displayReleaseVersion?: string(name='displayReleaseVersion', example='esr-4.3.0 (Spark 3.5.2, Scala 2.12)', position='Body'),
  enablePublic?: boolean(name='enablePublic', example='true', position='Body'),
  environmentId?: string(name='environmentId', example='ev-ctfq0fem1hkhgv4hapng', position='Body'),
  fusion?: boolean(name='fusion', example='false', position='Body'),
  livyServerConf?: string(name='livyServerConf', example='{
  "sparkDefaultsConf": "spark.driver.cores     1\\nspark.driver.memory    4g\\nspark.executor.cores   1\\nspark.executor.memory  4g\\n",
  "sparkBlackListConf": "spark.driver.cores\\nspark.driver.memory",
  "livyConf": "livy.server.session.timeout  1h\\n",
  "livyClientConf": "livy.rsc.sql.num-rows  1000\\n"
}', position='Body'),
  livyVersion?: string(name='livyVersion', example='0.8.0', position='Body'),
  memoryLimit?: string(name='memoryLimit', example='4Gi', position='Body'),
  name?: string(name='name', example='testGateway', position='Body'),
  networkName?: string(name='networkName', example='test', position='Body'),
  queueName?: string(name='queueName', example='root_queue', position='Body'),
  releaseVersion?: string(name='releaseVersion', example='esr-4.3.0 (Spark 3.5.2, Scala 2.12, Java Runtime)', position='Body'),
  regionId?: string(name='regionId', example='cn-hangzhou', position='Query'),
}

model CreateLivyComputeResponseBody = {
  code?: string(name='code', example='1000000'),
  data?: {
    livyComputeId?: string(name='livyComputeId', example='lc-i8xogcdfa4fk3yn1'),
  }(name='data'),
  message?: string(name='message', example='ok'),
  requestId?: string(name='requestId', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model CreateLivyComputeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLivyComputeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateLivyCompute  CreateLivyComputeRequest
  * @return CreateLivyComputeResponse
 */
async function createLivyCompute(request: CreateLivyComputeRequest): CreateLivyComputeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateLivyCompute', 'PUT', '/api/interactive/v1/workspace/{workspaceBizId}/livycompute', 'json', false, 'json', request);
}

model CreateLivyComputeTokenRequest {
  workspaceBizId?: string(name='workspaceBizId', example='w-8adde60aa809701f', position='Path'),
  livyComputeId?: string(name='livyComputeId', example='lc-zm4dzdiubu73w2yx', position='Path'),
  autoExpireConfiguration?: {
    enable?: boolean(name='enable', example='false'),
    expireDays?: int32(name='expireDays', example='7'),
  }(name='autoExpireConfiguration', position='Body'),
  name?: string(name='name', example='mytoken', position='Body'),
  token?: string(name='token', example='gs3fy75w4o7hqe5s', position='Body'),
  regionId?: string(name='regionId', example='cn-hangzhou', position='Query'),
}

model CreateLivyComputeTokenResponseBody = {
  code?: string(name='code', example='1000000'),
  data?: {
    tokenId?: string(name='tokenId', description='Token ID。', example='lctk-xxxxxxxx'),
  }(name='data'),
  message?: string(name='message', example='ok'),
  requestId?: string(name='requestId', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model CreateLivyComputeTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLivyComputeTokenResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateLivyComputeToken  CreateLivyComputeTokenRequest
  * @return CreateLivyComputeTokenResponse
 */
async function createLivyComputeToken(request: CreateLivyComputeTokenRequest): CreateLivyComputeTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateLivyComputeToken', 'PUT', '/api/interactive/v1/workspace/{workspaceBizId}/livycompute/{livyComputeId}/token', 'json', false, 'json', request);
}

model CreateProcessDefinitionWithScheduleRequest {
  bizId: string(name='bizId', description='The workspace ID.

This parameter is required.', example='w-d8********', position='Path'),
  alertEmailAddress?: string(name='alertEmailAddress', description='The email address to receive alerts.', example='foo_bar@spark.alert.invalid.com', position='Query'),
  description: string(name='description', description='The description of the workflow.

This parameter is required.', example='ods batch workflow', position='Query'),
  executionType: string(name='executionType', description='The execution policy

This parameter is required.', example='PARALLEL', position='Query'),
  globalParams?: [ 
    {
      direct?: string(name='direct'),
      prop?: string(name='prop'),
      type?: string(name='type'),
      value?: string(name='value'),
    }
  ](name='globalParams', shrink='json', position='Query'),
  name: string(name='name', description='The name of the workflow.

This parameter is required.', example='ods_batch_workflow', position='Query'),
  productNamespace: string(name='productNamespace', description='The code of the service.

This parameter is required.', example='SS', position='Query'),
  publish?: boolean(name='publish', description='Specifies whether to publish the workflow.', example='true', position='Query'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
  resourceQueue?: string(name='resourceQueue', description='The resource queue.', example='root_queue', position='Query'),
  retryTimes?: int32(name='retryTimes', description='The number of retries.', example='1', position='Query'),
  runAs?: string(name='runAs', description='The ID of the Alibaba Cloud account used by the user who creates the workflow.', example='113***************', position='Query'),
  schedule?: {
    crontab?: string(name='crontab', description='The CRON expression that is used for scheduling.', example='0 0 0 * * ?'),
    endTime?: string(name='endTime', description='The end time of the scheduling.', example='2025-12-23 16:13:27'),
    startTime?: string(name='startTime', description='The start time of the scheduling.', example='2024-12-23 16:13:27'),
    timezoneId?: string(name='timezoneId', description='The ID of the time zone.', example='Asia/Shanghai'),
  }(name='schedule', description='The scheduling settings.', shrink='json', position='Query'),
  tags?: map[string]string(name='tags', description='The tags.', shrink='json', position='Query'),
  taskDefinitionJson: [ 
    {
      alertEmailAddress?: string(name='alertEmailAddress', description='The email address to receive alerts.', example='foo_bar@spark.alert.invalid.com'),
      code: long(name='code', description='The node ID.

This parameter is required.', example='36************'),
      description?: string(name='description', description='The node description.', example='ods transform task'),
      failAlertEnable?: boolean(name='failAlertEnable', description='Specifies whether to send alerts when the node fails.', example='false'),
      failRetryTimes?: int32(name='failRetryTimes', description='The number of retries when the node fails.', example='1'),
      name: string(name='name', description='The name of the node.

This parameter is required.', example='ods_transform_task'),
      startAlertEnable?: boolean(name='startAlertEnable', description='Specifies whether to send alerts when the node is started.', example='false'),
      tags?: map[string]string(name='tags', description='The tags.'),
      taskParams: {
        displaySparkVersion?: string(name='displaySparkVersion', description='The displayed version of the Spark engine.', example='esr-4.0.0 (Spark 3.5.2, Scala 2.12)'),
        environmentId?: string(name='environmentId', description='The environment ID.', example='env-crhq2h5lhtgju93buhkg'),
        fusion?: boolean(name='fusion', description='Specifies whether to enable Fusion engine for acceleration.', example='false'),
        localParams?: [ 
          {
            direct?: string(name='direct'),
            prop?: string(name='prop'),
            type?: string(name='type'),
            value?: string(name='value'),
          }
        ](name='localParams'),
        resourceQueueId: string(name='resourceQueueId', description='The name of the resource queue on which the job runs.

This parameter is required.', example='root_queue'),
        sparkConf?: [ 
          {
            key?: string(name='key', description='The key of the SparkConf object.', example='spark.dynamicAllocation.enabled'),
            value?: string(name='value', description='The value of the SparkConf object.', example='true'),
          }
        ](name='sparkConf', description='The configurations of the Spark job.'),
        sparkDriverCores?: int32(name='sparkDriverCores', description='The number of driver cores of the Spark job.', example='1'),
        sparkDriverMemory?: long(name='sparkDriverMemory', description='The size of driver memory of the Spark job.', example='4g'),
        sparkExecutorCores?: int32(name='sparkExecutorCores', description='The number of executor cores of the Spark job.', example='1'),
        sparkExecutorMemory?: long(name='sparkExecutorMemory', description='The size of executor memory of the Spark job.', example='4g'),
        sparkLogLevel?: string(name='sparkLogLevel', description='The level of the Spark log.', example='INFO'),
        sparkLogPath?: string(name='sparkLogPath', description='The path where the operational logs of the Spark job are stored.'),
        sparkVersion?: string(name='sparkVersion', description='The version of the Spark engine.', example='esr-4.0.0 (Spark 3.5.2, Scala 2.12)'),
        taskBizId: string(name='taskBizId', description='The ID of the data development job.

This parameter is required.', example='TSK-d87******************'),
        type?: string(name='type', description='The type of the Spark job.', example='VPC'),
        workspaceBizId: string(name='workspaceBizId', description='The workspace ID.

This parameter is required.', example='w-d8********'),
      }(name='taskParams', description='The job parameters.

This parameter is required.'),
      taskType: string(name='taskType', description='The type of the node.

This parameter is required.', example='MigrateData'),
      timeout?: int32(name='timeout', description='The timeout period of the callback. Unit: seconds.', example='1200'),
    }
  ](name='taskDefinitionJson', description='The descriptions of all nodes in the workflow.

This parameter is required.', shrink='json', position='Query'),
  taskParallelism?: int32(name='taskParallelism', description='The node parallelism.', example='1', position='Query'),
  taskRelationJson: [ 
    {
      name: string(name='name', description='The name of the node topology. You can enter a workflow name.

This parameter is required.', example='ods batch workflow'),
      postTaskCode: long(name='postTaskCode', description='The ID of the downstream node.

This parameter is required.', example='28************'),
      postTaskVersion: int32(name='postTaskVersion', description='The version of the downstream node.

This parameter is required.', example='1'),
      preTaskCode: long(name='preTaskCode', description='The ID of the upstream node.

This parameter is required.', example='16************'),
      preTaskVersion: int32(name='preTaskVersion', description='The version of the upstream node.

This parameter is required.', example='1'),
    }
  ](name='taskRelationJson', description='The dependencies of all nodes in the workflow. preTaskCode specifies the ID of an upstream node, and postTaskCode specifies the ID of a downstream node. The ID of each node is unique. If a node does not have an upstream node, set preTaskCode to 0.

This parameter is required.', shrink='json', position='Query'),
  timeout?: int32(name='timeout', description='The default timeout period of the workflow.', example='60', position='Query'),
}

model CreateProcessDefinitionWithScheduleResponseBody = {
  code?: int32(name='code', description='The code that is returned by the backend server.', example='1400009'),
  data?: {
    code?: long(name='code', description='The workflow ID.', example='160************'),
    id?: int32(name='id', description='The serial number of the workflow.', example='12342'),
  }(name='data', description='The returned data.'),
  failed?: string(name='failed', description='Indicates whether the request failed.', example='false'),
  httpStatusCode?: int32(name='httpStatusCode', description='The HTTP status code.', example='200'),
  msg?: string(name='msg', description='The description of the returned code.', example='No permission for resource action'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  success?: string(name='success', description='Indicates whether the request was successful.', example='true'),
}

model CreateProcessDefinitionWithScheduleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateProcessDefinitionWithScheduleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateProcessDefinitionWithSchedule  CreateProcessDefinitionWithScheduleRequest
  * @return CreateProcessDefinitionWithScheduleResponse
 */
async function createProcessDefinitionWithSchedule(request: CreateProcessDefinitionWithScheduleRequest): CreateProcessDefinitionWithScheduleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateProcessDefinitionWithSchedule', 'POST', '/dolphinscheduler/projects/{bizId}/process-definition', 'json', false, 'json', request);
}

model CreateSessionClusterRequest {
  workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-790b443d72394bfc', position='Path'),
  applicationConfigs?: [ 
    {
      configFileName?: string(name='configFileName', description='The name of the configuration file.', example='spark-defaults.conf'),
      configItemKey?: string(name='configItemKey', description='The key of SparkConf.', example='spark.app.name'),
      configItemValue?: string(name='configItemValue', description='The value of SparkConf.', example='test'),
    }
  ](name='applicationConfigs', description='The Spark configurations.', position='Body'),
  autoStartConfiguration?: {
    enable?: boolean(name='enable', description='Specifies whether to enable automatic startup.

*   true
*   false', example='false'),
  }(name='autoStartConfiguration', description='Specifies whether to enable automatic startup.

*   true
*   false', position='Body'),
  autoStopConfiguration?: {
    enable?: boolean(name='enable', description='Specifies whether to enable automatic termination.

*   true
*   false', example='false'),
    idleTimeoutMinutes?: integer(name='idleTimeoutMinutes', description='The idle timeout period. The session is automatically terminated when the idle timeout period is exceeded.', example='60'),
  }(name='autoStopConfiguration', description='The automatic termination configuration.', position='Body'),
  displayReleaseVersion?: string(name='displayReleaseVersion', description='The version of the Spark engine.', example='esr-3.3.1', position='Body'),
  envId?: string(name='envId', description='The ID of the Python environment. This parameter takes effect only for notebook sessions.', example='env-cpv569tlhtgndjl86t40', position='Body'),
  fusion?: boolean(name='fusion', description='Specifies whether to enable Fusion engine for acceleration.', example='false', position='Body'),
  kind?: string(name='kind', description='The session type.

*   SQL
*   NOTEBOOK', example='SQL', position='Body'),
  name?: string(name='name', description='The name of the job.', example='spark_job_name', position='Body'),
  publicEndpointEnabled?: boolean(name='publicEndpointEnabled', position='Body'),
  queueName?: string(name='queueName', description='The queue name.', example='root_queue', position='Body'),
  releaseVersion?: string(name='releaseVersion', description='The version number of Spark.', example='esr-3.3.1', position='Body'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
}

model CreateSessionClusterResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  sessionClusterId?: string(name='sessionClusterId', description='The session ID.', example='w-******'),
}

model CreateSessionClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSessionClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateSessionCluster  CreateSessionClusterRequest
  * @return CreateSessionClusterResponse
 */
async function createSessionCluster(request: CreateSessionClusterRequest): CreateSessionClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateSessionCluster', 'POST', '/api/v1/workspaces/{workspaceId}/sessionClusters', 'json', false, 'json', request);
}

model CreateSqlStatementRequest {
  workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-26ca1703f6d****', position='Path'),
  codeContent?: string(name='codeContent', description='The SQL code. You can specify one or more SQL statements.', example='SHOW TABLES', position='Body'),
  defaultCatalog?: string(name='defaultCatalog', description='The default Data Lake Formation (DLF) catalog ID.', example='default_catalog', position='Body'),
  defaultDatabase?: string(name='defaultDatabase', description='The name of the default database.', example='default', position='Body'),
  limit?: int32(name='limit', description='The maximum number of entries to return. Valid values: 1 to 10000.', example='1000', position='Body'),
  sqlComputeId?: string(name='sqlComputeId', description='The SQL session ID. You can create an SQL session in the workspace created in EMR Serverless Spark.', example='sc-dfahdfjafhajd****', position='Body'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
}

model CreateSqlStatementResponseBody = {
  data?: {
    statementId?: string(name='statementId', description='The interactive query ID.', example='st-1231dfafadfa***'),
  }(name='data', description='The data returned.'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model CreateSqlStatementResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSqlStatementResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateSqlStatement  CreateSqlStatementRequest
  * @return CreateSqlStatementResponse
 */
async function createSqlStatement(request: CreateSqlStatementRequest): CreateSqlStatementResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateSqlStatement', 'PUT', '/api/interactive/v1/workspace/{workspaceId}/statement', 'json', false, 'json', request);
}

model CreateWorkspaceRequest {
  autoRenew?: string(name='autoRenew', description='Specifies whether to enable auto-renewal. This parameter is required only if the paymentType parameter is set to Pre.', example='false', position='Body'),
  autoRenewPeriod?: string(name='autoRenewPeriod', description='The auto-renewal duration. This parameter is required only if the paymentType parameter is set to Pre.', example='100', position='Body'),
  autoRenewPeriodUnit?: string(name='autoRenewPeriodUnit', description='The unit of the auto-renewal duration. This parameter is required only if the paymentType parameter is set to Pre.', example='month', position='Body'),
  autoStartSessionCluster?: boolean(name='autoStartSessionCluster', description='Specifies whether to automatically start a session.', example='false', position='Body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request.', example='8e6aae2810c8f67229ca70bb31cd****', position='Body'),
  dlfCatalogId?: string(name='dlfCatalogId', description='The information of the Data Lake Formation (DLF) catalog.', example='123xxxxx', position='Body'),
  dlfType?: string(name='dlfType', description='The version of DLF.', example='dlf1.0', position='Body'),
  duration?: string(name='duration', description='The subscription period. This parameter is required only if the paymentType parameter is set to Pre.', example='12452', position='Body'),
  ossBucket?: string(name='ossBucket', description='The name of the Object Storage Service (OSS) bucket.', example='oss://test-bucket/', position='Body'),
  paymentDurationUnit?: string(name='paymentDurationUnit', description='The unit of the subscription duration.', example='1000', position='Body'),
  paymentType?: string(name='paymentType', description='The billing method. Valid values:

*   PayAsYouGo
*   Pre', example='PayAsYouGo', position='Body'),
  ramRoleName?: string(name='ramRoleName', description='The name of the role used to run Spark jobs.', example='AliyunEMRSparkJobRunDefaultRole', position='Body'),
  releaseType?: string(name='releaseType', description='The type of the version.', example='pro', position='Body'),
  resourceSpec?: {
    cu?: string(name='cu', description='The maximum resource quota for a workspace.', example='1000'),
  }(name='resourceSpec', description='The resource specifications.', position='Body'),
  tag?: [ 
    {
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='tag', position='Body'),
  workspaceName?: string(name='workspaceName', description='The name of the workspace.', example='default', position='Body'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
}

model CreateWorkspaceResponseBody = {
  operationId?: string(name='operationId', description='The operation ID.', example='op-******'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-******'),
}

model CreateWorkspaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateWorkspaceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateWorkspace  CreateWorkspaceRequest
  * @return CreateWorkspaceResponse
 */
async function createWorkspace(request: CreateWorkspaceRequest): CreateWorkspaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateWorkspace', 'POST', '/api/v1/workspaces', 'json', false, 'json', request);
}

model DeleteLivyComputeRequest {
  workspaceBizId?: string(name='workspaceBizId', example='w-8adde60aa809701f', position='Path'),
  livyComputeId?: string(name='livyComputeId', example='lc-i8xogcdfa4fk3yn1', position='Path'),
  regionId?: string(name='regionId', example='cn-hangzhou', position='Query'),
}

model DeleteLivyComputeResponseBody = {
  code?: string(name='code', example='1000000'),
  message?: string(name='message', example='ok'),
  requestId?: string(name='requestId', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model DeleteLivyComputeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLivyComputeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteLivyCompute  DeleteLivyComputeRequest
  * @return DeleteLivyComputeResponse
 */
async function deleteLivyCompute(request: DeleteLivyComputeRequest): DeleteLivyComputeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteLivyCompute', 'DELETE', '/api/interactive/v1/workspace/{workspaceBizId}/livycompute/{livyComputeId}', 'json', false, 'json', request);
}

model DeleteLivyComputeTokenRequest {
  workspaceBizId?: string(name='workspaceBizId', example='w-8adde60aa809701f', position='Path'),
  livyComputeId?: string(name='livyComputeId', example='lc-zm4dzdiubu73w2yx', position='Path'),
  tokenId?: string(name='tokenId', description='Token ID。', example='lctk-xxxxxxxxxx', position='Path'),
  regionId?: string(name='regionId', example='cn-hangzhou', position='Query'),
}

model DeleteLivyComputeTokenResponseBody = {
  code?: string(name='code', example='1000000'),
  message?: string(name='message', example='ok'),
  requestId?: string(name='requestId', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model DeleteLivyComputeTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLivyComputeTokenResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteLivyComputeToken  DeleteLivyComputeTokenRequest
  * @return DeleteLivyComputeTokenResponse
 */
async function deleteLivyComputeToken(request: DeleteLivyComputeTokenRequest): DeleteLivyComputeTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteLivyComputeToken', 'DELETE', '/api/interactive/v1/workspace/{workspaceBizId}/livycompute/{livyComputeId}/token/{tokenId}', 'json', false, 'json', request);
}

model EditWorkspaceQueueRequest {
  environments?: [ string ](name='environments', position='Body'),
  resourceSpec?: {
    cu?: long(name='cu', example='1000'),
  }(name='resourceSpec', position='Body'),
  workspaceId?: string(name='workspaceId', example='w-975bcfda9625****', position='Body'),
  workspaceQueueName?: string(name='workspaceQueueName', example='dev_queue', position='Body'),
  regionId?: string(name='regionId', example='cn-hangzhou', position='Query'),
}

model EditWorkspaceQueueResponseBody = {
  requestId?: string(name='RequestId', description='请求ID。', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model EditWorkspaceQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EditWorkspaceQueueResponseBody(name='body'),
}

/**
  * @param request  the request parameters of EditWorkspaceQueue  EditWorkspaceQueueRequest
  * @return EditWorkspaceQueueResponse
 */
async function editWorkspaceQueue(request: EditWorkspaceQueueRequest): EditWorkspaceQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'EditWorkspaceQueue', 'POST', '/api/v1/workspaces/queues/action/edit', 'json', false, 'json', request);
}

model GetCuHoursRequest {
  workspaceId: string(name='workspaceId', description='The workspace ID.

This parameter is required.', example='w-dsa23*****', position='Path'),
  queue: string(name='queue', description='The name of the queue.

This parameter is required.', example='root_queue', position='Path'),
  endTime: string(name='endTime', description='The end time of the query time range.

This parameter is required.', example='2024-01-08 00:00:00', position='Query'),
  startTime: string(name='startTime', description='The start time of the query time range.

This parameter is required.', example='2024-01-01 00:00:00', position='Query'),
}

model GetCuHoursResponseBody = {
  data?: {
    cuHours?: string(name='cuHours', description='The number of CU-hours consumed by a queue during a specified cycle. The value is an estimated value. Refer to your Alibaba Cloud bill for the actual number of consumed CU-hours.', example='{2025-01-09 00:00:00=2.033333, 2025-01-09 01:00:00=2.033333, 2025-01-09 02:00:00=2.033333, 2025-01-09 03:00:00=2.033333, 2025-01-09 04:00:00=2.033333, 2025-01-09 05:00:00=2.033333, 2025-01-09 06:00:00=2.033333, 2025-01-09 07:00:00=2.033333, 2025-01-09 08:00:00=2.033333, 2025-01-09 09:00:00=1.933333, 2025-01-09 10:00:00=2.133333, 2025-01-09 11:00:00=3.100000, 2025-01-09 12:00:00=2.900000}'),
  }(name='data', description='The returned data.', example='{
    "cuHours": "{2025-01-09 00:00:00=2.033333, 2025-01-09 01:00:00=2.033333, 2025-01-09 02:00:00=2.033333, 2025-01-09 03:00:00=2.033333, 2025-01-09 04:00:00=2.033333, 2025-01-09 05:00:00=2.033333, 2025-01-09 06:00:00=2.033333, 2025-01-09 07:00:00=2.033333, 2025-01-09 08:00:00=2.033333, 2025-01-09 09:00:00=1.933333, 2025-01-09 10:00:00=2.133333, 2025-01-09 11:00:00=3.100000, 2025-01-09 12:00:00=2.900000}"
}'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model GetCuHoursResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCuHoursResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetCuHours  GetCuHoursRequest
  * @return GetCuHoursResponse
 */
async function getCuHours(request: GetCuHoursRequest): GetCuHoursResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetCuHours', 'GET', '/api/v1/workspaces/{workspaceId}/metric/cuHours/{queue}', 'json', false, 'json', request);
}

model GetDoctorApplicationRequest {
  workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-d2d82aa09155****', position='Path'),
  runId?: string(name='runId', description='The job ID.', example='jr-d2d82aa09155****', position='Path'),
  locale?: string(name='locale', description='The language of diagnostic information.', example='zh-CN', position='Query'),
  queryTime?: string(name='queryTime', description='The query time.', example='2024-01-01', position='Query'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
}

model GetDoctorApplicationResponseBody = {
  data?: {
    suggestions?: [ string ](name='suggestions', description='The diagnostics list.'),
  }(name='data', description='The data returned.'),
}

model GetDoctorApplicationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDoctorApplicationResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetDoctorApplication  GetDoctorApplicationRequest
  * @return GetDoctorApplicationResponse
 */
async function getDoctorApplication(request: GetDoctorApplicationRequest): GetDoctorApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetDoctorApplication', 'GET', '/api/v1/workspaces/{workspaceId}/runs/{runId}/action/getDoctorApplication', 'json', false, 'json', request);
}

model GetJobRunRequest {
  workspaceId: string(name='workspaceId', description='The workspace ID.

This parameter is required.', example='w-1234abcd', position='Path'),
  jobRunId: string(name='jobRunId', description='The job ID.

This parameter is required.', example='jr-231231', position='Path'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
}

model GetJobRunResponseBody = {
  jobRun?: {
    codeType?: string(name='codeType', description='The code type of the job. Valid values:

*   SQL
*   JAR
*   PYTHON', example='SQL'),
    configurationOverrides?: {
      configurations?: [
        Configuration
      ](name='configurations', description='The configurations.'),
    }(name='configurationOverrides', description='The configurations of the Spark jobs.'),
    displayReleaseVersion?: string(name='displayReleaseVersion', description='The version of the Spark engine.', example='esr-4.0.0 (Spark 3.5.2, Scala 2.12)'),
    endTime?: long(name='endTime', description='The end time of the job.', example='1684119314000'),
    environmentId?: string(name='environmentId', description='The environment ID.', example='env-cpv569tlhtgndjl8****'),
    executionTimeoutSeconds?: int32(name='executionTimeoutSeconds', description='The timeout period of the job.', example='3600'),
    fusion?: boolean(name='fusion', description='Indicates whether the Fusion engine is used for acceleration.', example='false'),
    jobDriver?: JobDriver(name='jobDriver', description='The information about Spark Driver.'),
    jobRunId?: string(name='jobRunId', description='The job ID.', example='jr-231231'),
    log?: RunLog(name='log', description='The path where the operational logs are stored.'),
    name?: string(name='name', description='The job name.', example='jobName'),
    releaseVersion?: string(name='releaseVersion', description='The version of the Spark engine on which the job runs.', example='esr-3.3.1'),
    resourceOwnerId?: string(name='resourceOwnerId', description='The ID of the user who created the job.', example='1509789347011222'),
    resourceQueueId?: string(name='resourceQueueId', description='The name of the queue on which the job runs.', example='root_queue'),
    state?: string(name='state', description='The job state.', example='Running'),
    stateChangeReason?: {
      code?: string(name='code', description='The error code.', example='ERR-100000'),
      message?: string(name='message', description='The error message.', example='connection refused'),
    }(name='stateChangeReason', description='The reason of the job status change.'),
    submitTime?: long(name='submitTime', description='The time when the job was submitted.', example='1684119314000'),
    tags?: [
      Tag
    ](name='tags', description='The tags of the job.'),
    webUI?: string(name='webUI', description='The web UI of the job.', example='http://spark-ui'),
    workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-1234abcd'),
  }(name='jobRun', description='The details of the job.'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model GetJobRunResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetJobRunResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetJobRun  GetJobRunRequest
  * @return GetJobRunResponse
 */
async function getJobRun(request: GetJobRunRequest): GetJobRunResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetJobRun', 'GET', '/api/v1/workspaces/{workspaceId}/jobRuns/{jobRunId}', 'json', false, 'json', request);
}

model GetLivyComputeRequest {
  workspaceBizId?: string(name='workspaceBizId', example='w-8adde60aa809701f', position='Path'),
  livyComputeId?: string(name='livyComputeId', example='lc-i8xogcdfa4fk3yn1', position='Path'),
  regionId?: string(name='regionId', example='cn-hangzhou', position='Query'),
}

model GetLivyComputeResponseBody = {
  code?: string(name='code', example='1000000'),
  data?: {
    authType?: string(name='authType', example='Token'),
    autoStopConfiguration?: {
      enable?: boolean(name='enable', example='false'),
      idleTimeoutMinutes?: long(name='idleTimeoutMinutes', example='300'),
    }(name='autoStopConfiguration'),
    computeId?: string(name='computeId', example='lc-xxxxxxxxxxxxx'),
    cpuLimit?: string(name='cpuLimit', example='1'),
    createdBy?: string(name='createdBy', example='alice'),
    displayReleaseVersion?: string(name='displayReleaseVersion', example='esr-4.3.0 (Spark 3.5.2, Scala 2.12)'),
    enablePublic?: boolean(name='enablePublic', example='true'),
    endpoint?: string(name='endpoint', example='emr-spark-livy-gateway-cn-hangzhou.data.aliyun.com/api/v1/workspace/w-xxxxxxxxx/livycompute/lc-xxxxxxxxxxx'),
    endpointInner?: string(name='endpointInner', example='emr-spark-livy-gateway-cn-hangzhou-internal.aliyun.com/api/v1/workspace/w-xxxxxxxxx/livycompute/lc-xxxxxxxxxxx'),
    environmentId?: string(name='environmentId', example='ev-cq31c7tlhtgm9nrrlj4g'),
    fusion?: boolean(name='fusion', example='false'),
    gmtCreate?: long(name='gmtCreate', example='1749456094000'),
    livyServerConf?: string(name='livyServerConf', example='{
  "sparkDefaultsConf": "spark.driver.cores     1\\nspark.driver.memory    4g\\nspark.executor.cores   1\\nspark.executor.memory  4g\\n",
  "sparkBlackListConf": "spark.driver.cores\\nspark.driver.memory",
  "livyConf": "livy.server.session.timeout  1h\\n",
  "livyClientConf": "livy.rsc.sql.num-rows  1000\\n"
}'),
    livyVersion?: string(name='livyVersion', example='0.8.0'),
    memoryLimit?: string(name='memoryLimit', example='4Gi'),
    name?: string(name='name', example='test'),
    networkName?: string(name='networkName', example='test'),
    queueName?: string(name='queueName', example='root_queue'),
    ramUserId?: string(name='ramUserId', example='10000001'),
    releaseVersion?: string(name='releaseVersion', example='esr-4.3.0 (Spark 3.5.2, Scala 2.12, Java Runtime)'),
    startTime?: long(name='startTime', example='1749456094000'),
    status?: string(name='status', example='RUNNING'),
  }(name='data'),
  message?: string(name='message', example='ok'),
  requestId?: string(name='requestId', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model GetLivyComputeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLivyComputeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetLivyCompute  GetLivyComputeRequest
  * @return GetLivyComputeResponse
 */
async function getLivyCompute(request: GetLivyComputeRequest): GetLivyComputeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLivyCompute', 'GET', '/api/interactive/v1/workspace/{workspaceBizId}/livycompute/{livyComputeId}', 'json', false, 'json', request);
}

model GetLivyComputeTokenRequest {
  workspaceBizId?: string(name='workspaceBizId', example='w-8adde60aa809701f', position='Path'),
  livyComputeId?: string(name='livyComputeId', example='lc-6mkvn01zrg8rqhhv', position='Path'),
  tokenId?: string(name='tokenId', description='Token ID。', example='lctk-xxxxxxxx', position='Path'),
  regionId?: string(name='regionId', example='cn-hangzhou', position='Query'),
}

model GetLivyComputeTokenResponseBody = {
  code?: string(name='code', example='1000000'),
  data?: {
    autoExpireConfiguration?: {
      enable?: boolean(name='enable', example='false'),
      expireDays?: int32(name='expireDays', example='7'),
    }(name='autoExpireConfiguration'),
    createTime?: long(name='createTime', example='1749456094000'),
    createdBy?: string(name='createdBy', example='alice'),
    expireTime?: long(name='expireTime', example='1749457994000'),
    lastUsedTime?: long(name='lastUsedTime', example='1749456098000'),
    name?: string(name='name', example='test'),
    token?: string(name='token', example='d25561157a635bb'),
    tokenId?: string(name='tokenId', description='Token ID。', example='lctk-xxxxxxxxxx'),
  }(name='data'),
  message?: string(name='message', example='ok'),
  requestId?: string(name='requestId', example='484D9DDA-300D-525E-AF7A-0CCCA5C64A7A'),
}

model GetLivyComputeTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLivyComputeTokenResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetLivyComputeToken  GetLivyComputeTokenRequest
  * @return GetLivyComputeTokenResponse
 */
async function getLivyComputeToken(request: GetLivyComputeTokenRequest): GetLivyComputeTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLivyComputeToken', 'GET', '/api/interactive/v1/workspace/{workspaceBizId}/livycompute/{livyComputeId}/token/{tokenId}', 'json', false, 'json', request);
}

model GetSessionClusterRequest {
  workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-1234abcd', position='Path'),
  sessionClusterId?: string(name='sessionClusterId', description='The session ID.', example='emr-spark-demo-job', position='Path'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
}

model GetSessionClusterResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  sessionCluster?: {
    applicationConfigs?: [ 
      {
        configFileName?: string(name='configFileName', description='The name of the configuration file.', example='spark-defaults.conf'),
        configItemKey?: string(name='configItemKey', description='The key of the configuration.', example='spark.app.name'),
        configItemValue?: string(name='configItemValue', description='The configuration value.', example='test'),
      }
    ](name='applicationConfigs', description='The Spark configurations.'),
    autoStartConfiguration?: {
      enable?: boolean(name='enable', description='Indicates whether automatic startup is enabled.

*   true
*   false', example='false'),
    }(name='autoStartConfiguration', description='Indicates whether automatic startup is enabled.'),
    autoStopConfiguration?: {
      enable?: boolean(name='enable', description='Indicates whether automatic termination is enabled.

*   true
*   false', example='false'),
      idleTimeoutMinutes?: int32(name='idleTimeoutMinutes', description='The idle timeout period. The session is automatically terminated when the idle timeout period is exceeded.', example='60'),
    }(name='autoStopConfiguration', description='Indicates whether automatic termination is enabled.'),
    connectionToken?: string(name='connectionToken'),
    displayReleaseVersion?: string(name='displayReleaseVersion', description='The version of the Spark engine.', example='esr-2.2(Java Runtime)'),
    domain?: string(name='domain', description='The domain name to which the Spark UI of the session belongs.', example='your.domain.com'),
    domainInner?: string(name='domainInner', description='The internal endpoint.', example='emr-spark-gateway-cn-hangzhou-internal.data.aliyuncs.com'),
    draftId?: string(name='draftId', description='The ID of the job that is associated with the session.', example='TSK-xxxxxxxx'),
    envId?: string(name='envId', description='The environment ID.', example='env-cpv569tlhtgndjl86t40'),
    extra?: string(name='extra', description='The additional metadata of the session.', example='{"extraInfoKey":"extraInfoValue"}'),
    fusion?: boolean(name='fusion', description='Indicates whether the Fusion engine is used for acceleration.', example='false'),
    gmtCreate?: long(name='gmtCreate', description='The creation time.', example='2024-09-01 06:23:01'),
    kind?: string(name='kind', description='The type of the job. This parameter is required and cannot be modified after the deployment is created. Valid values:

*   SQLSCRIPT
*   JAR
*   PYTHON', example='SQL'),
    name?: string(name='name', description='The name of the session.', example='test'),
    publicEndpointEnabled?: boolean(name='publicEndpointEnabled'),
    queueName?: string(name='queueName', description='The queue name.', example='jobName'),
    releaseVersion?: string(name='releaseVersion', description='The version of Serverless Spark.', example='esr-2.2(Java Runtime)'),
    sessionClusterId?: string(name='sessionClusterId', description='The session ID.', example='1234abcd-12ab-34cd-56ef-1234567890ab'),
    startTime?: long(name='startTime', description='The start time.', example='2024-09-01 06:23:01'),
    state?: string(name='state', description='The job status.

*   Starting
*   Running
*   Stopping
*   Stopped
*   Error', example='Running'),
    stateChangeReason?: {
      code?: string(name='code', description='The status change code.', example='1000000'),
      message?: string(name='message', description='The status change message.', example='ok'),
    }(name='stateChangeReason', description='The reason of the job status change.'),
    userId?: string(name='userId', description='The user ID.', example='jr-231231'),
    userName?: string(name='userName', description='The name of the account that is used to create the session.', example='user1'),
    webUI?: string(name='webUI', description='The Spark UI of the session.', example='https://spark-ui/link'),
    workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-1234abcd'),
  }(name='sessionCluster', description='The session object.'),
}

model GetSessionClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSessionClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetSessionCluster  GetSessionClusterRequest
  * @return GetSessionClusterResponse
 */
async function getSessionCluster(request: GetSessionClusterRequest): GetSessionClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetSessionCluster', 'GET', '/api/v1/workspaces/{workspaceId}/sessionClusters/{sessionClusterId}', 'json', false, 'json', request);
}

model GetSqlStatementRequest {
  workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-d2d82aa09155****', position='Path'),
  statementId?: string(name='statementId', description='The interactive query ID.', example='st-2dadfhajk11cv****', position='Path'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
}

model GetSqlStatementResponseBody = {
  data?: {
    executionTime?: [ long ](name='executionTime', description='The list of time that is consumed by SQL queries.'),
    sqlErrorCode?: string(name='sqlErrorCode', description='The error code.', example='ERROR-102'),
    sqlErrorMessage?: string(name='sqlErrorMessage', description='The error message.', example='error message'),
    sqlOutputs?: [ 
      {
        rows?: string(name='rows', description='The queried data, which is a string in the JSON format.', example='[{\\"values\\":[\\"test_db\\",\\"test_table\\",false]}'),
        rowsFilePath?: string(name='rowsFilePath'),
        schema?: string(name='schema', description='The information about the schema, which is a string in the JSON format.', example='{\\"type\\":\\"struct\\",\\"fields\\":[{\\"name\\":\\"namespace\\",\\"type\\":\\"string\\",\\"nullable\\":false,\\"metadata\\":{}},{\\"name\\":\\"tableName\\",\\"type\\":\\"string\\",\\"nullable\\":false,\\"metadata\\":{}},{\\"name\\":\\"isTemporary\\",\\"type\\":\\"boolean\\",\\"nullable\\":false,\\"metadata\\":{}}]}'),
      }
    ](name='sqlOutputs', description='The query results.'),
    state?: string(name='state', description='The query status.

Valid values:

*   running
*   available
*   cancelled
*   error
*   cancelling', example='running'),
    statementId?: string(name='statementId', description='The query ID.', example='st-1231311abadfaa'),
  }(name='data', description='The response parameters.'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model GetSqlStatementResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSqlStatementResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetSqlStatement  GetSqlStatementRequest
  * @return GetSqlStatementResponse
 */
async function getSqlStatement(request: GetSqlStatementRequest): GetSqlStatementResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetSqlStatement', 'GET', '/api/interactive/v1/workspace/{workspaceId}/statement/{statementId}', 'json', false, 'json', request);
}

model GetTemplateRequest {
  workspaceBizId?: string(name='workspaceBizId', description='The workspace ID.', example='w-8adde60aa809701f', position='Path'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
  templateBizId?: string(name='templateBizId', position='Query'),
  templateType?: string(name='templateType', description='The template type.

Valid values:

*   TASK
*   SESSION', example='TASK', position='Query'),
}

model GetTemplateResponseBody = {
  data?: Template(name='data', description='The returned data.'),
  errorCode?: string(name='errorCode', description='*   If the value of success was false, an error code was returned.
*   If the value of success was true, a null value was returned.', example='040003'),
  errorMessage?: string(name='errorMessage', description='*   If the value of success was false, an error message was returned.
*   If the value of success was true, a null value was returned.', example='InvalidUser.NotFound'),
  httpStatusCode?: string(name='httpStatusCode', description='The HTTP status code.', example='200'),
  requestId?: string(name='requestId', description='The request ID.', example='484D9DDA-300D-525E-AF7A-0CCCA5C64A7A'),
  success?: boolean(name='success', description='Indicates whether the request was successful.', example='True'),
}

model GetTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetTemplate  GetTemplateRequest
  * @return GetTemplateResponse
 */
async function getTemplate(request: GetTemplateRequest): GetTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTemplate', 'GET', '/api/interactive/v1/workspace/{workspaceBizId}/template', 'json', false, 'json', request);
}

model GrantRoleToUsersRequest {
  roleArn?: string(name='roleArn', description='The Alibaba Cloud Resource Name (ARN) of the RAM role.', example='acs:emr::w-975bcfda9625****:role/Owner', position='Body'),
  userArns?: [ string ](name='userArns', description='The user ARNs.', position='Body'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
}

model GrantRoleToUsersResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model GrantRoleToUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GrantRoleToUsersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GrantRoleToUsers  GrantRoleToUsersRequest
  * @return GrantRoleToUsersResponse
 */
async function grantRoleToUsers(request: GrantRoleToUsersRequest): GrantRoleToUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GrantRoleToUsers', 'POST', '/api/v1/auth/roles/grant', 'json', false, 'json', request);
}

model ListJobRunsRequest {
  workspaceId: string(name='workspaceId', description='The workspace ID.

This parameter is required.', example='w-1234abcd', position='Path'),
  creator?: string(name='creator', description='The ID of the user who created the job.', example='1509789347011222', position='Query'),
  endTime?: {
    endTime?: long(name='endTime', description='The end of the end time range.', example='1710432000000'),
    startTime?: long(name='startTime', description='The beginning of the end time range.', example='1709740800000'),
  }(name='endTime', description='The range of end time.', shrink='json', position='Query'),
  isWorkflow?: string(name='isWorkflow', position='Query'),
  jobRunDeploymentId?: string(name='jobRunDeploymentId', description='The job run ID.', example='jd-b6d003f1930f****', position='Query'),
  jobRunId?: string(name='jobRunId', description='The job ID.', example='j-xxx', position='Query'),
  maxResults?: int32(name='maxResults', description='The maximum number of entries to return.', example='20', position='Query'),
  minDuration?: long(name='minDuration', description='The minimum running duration of the job. Unit: ms.', example='60000', position='Query'),
  name?: string(name='name', description='The job name.', example='emr-spark-demo-job', position='Query'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the request to retrieve a new page of results.', example='DD6B1B2A-5837-5237-ABE4-FF0C89568980', position='Query'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
  resourceQueueId?: string(name='resourceQueueId', description='The name of the resource queue on which the Spark jobs run.', example='dev_queue', position='Query'),
  startTime?: {
    endTime?: long(name='endTime', description='The end of the start time range.', example='1710432000000'),
    startTime?: long(name='startTime', description='The beginning of the start time range.', example='1709740800000'),
  }(name='startTime', description='The range of start time.', shrink='json', position='Query'),
  states?: [ string ](name='states', description='The job states.', example='["Running","Submitted"]', shrink='json', position='Query'),
  tags?: [ 
    {
      key?: string(name='key', description='The key of tag N.', example='tag_key'),
      value?: string(name='value', description='The value of tag N.', example='value'),
    }
  ](name='tags', description='The tags of the job.', shrink='json', position='Query'),
}

model ListJobRunsResponseBody = {
  jobRuns?: [ 
    {
      codeType?: string(name='codeType', description='The code type of the job. Valid values:

SQL

JAR

PYTHON', example='SQL'),
      configurationOverrides?: {
        configurations?: [
          Configuration
        ](name='configurations', description='The SparkConf objects.'),
      }(name='configurationOverrides', description='The advanced configurations of Spark.'),
      creator?: string(name='creator', description='The ID of the user who created the job.', example='1509789347011222'),
      cuHours?: double(name='cuHours', description='The number of CUs consumed during a specified cycle of a task. The value is an estimated value. Refer to your Alibaba Cloud bill for the actual number of consumed CUs.', example='2.059'),
      displayReleaseVersion?: string(name='displayReleaseVersion', description='The version of Spark on which the jobs run.', example='esr-3.0.0 (Spark 3.4.3, Scala 2.12)'),
      endTime?: long(name='endTime', description='The end time of the job.', example='1684119314000'),
      executionTimeoutSeconds?: int32(name='executionTimeoutSeconds', description='The timeout period of the job.', example='3600'),
      fusion?: boolean(name='fusion', description='Indicates whether the Fusion engine is used for acceleration.', example='true'),
      jobDriver?: JobDriver(name='jobDriver', description='The information about Spark Driver.'),
      jobRunId?: string(name='jobRunId', description='The job ID.', example='jr-231231'),
      log?: RunLog(name='log', description='The path where the operational logs are stored.'),
      mbSeconds?: long(name='mbSeconds', description='The total amount of memory allocated to the job multiplied by the running duration (seconds).', example='33030784'),
      name?: string(name='name', description='The job name.', example='jobName'),
      releaseVersion?: string(name='releaseVersion', description='The version of Spark on which the jobs run.', example='esr-native-3.4.0'),
      state?: string(name='state', description='The job state.', example='Running'),
      stateChangeReason?: {
        code?: string(name='code', description='The error code.', example='0'),
        message?: string(name='message', description='The error message.', example='success'),
      }(name='stateChangeReason', description='The reason of the job status change.'),
      submitTime?: long(name='submitTime', description='The time when the job was submitted.', example='1684119314000'),
      tags?: [
        Tag
      ](name='tags', description='The tags of the job.'),
      vcoreSeconds?: long(name='vcoreSeconds', description='The total number of CPU cores allocated to the job multiplied by the running duration (seconds).', example='8236'),
      webUI?: string(name='webUI', description='The web UI of the job.', example='http://spark-ui'),
      workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-1234abcd'),
    }
  ](name='jobRuns', description='The Spark jobs.'),
  maxResults?: int32(name='maxResults', description='The maximum number of entries returned.', example='20'),
  nextToken?: string(name='nextToken', description='A pagination token.', example='DD6B1B2A-5837-5237-ABE4-FF0C89568980'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='200'),
}

model ListJobRunsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListJobRunsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListJobRuns  ListJobRunsRequest
  * @return ListJobRunsResponse
 */
async function listJobRuns(request: ListJobRunsRequest): ListJobRunsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListJobRuns', 'GET', '/api/v1/workspaces/{workspaceId}/jobRuns', 'json', false, 'json', request);
}

model ListKyuubiServicesRequest {
  workspaceId?: string(name='workspaceId', example='w-d2d82aa09155****', position='Path'),
}

model ListKyuubiServicesResponseBody = {
  data?: {
    kyuubiServices?: [ 
      {
        computeInstance?: string(name='computeInstance', example='4C16G'),
        createTime?: string(name='createTime', example='2025-03-11T08:21:58Z'),
        creator?: string(name='creator', example='103*******'),
        innerEndpoint?: string(name='innerEndpoint', example='kyuubi-cn-hangzhou-internal.spark.emr.aliyuncs.com'),
        kyuubiConfigs?: string(name='kyuubiConfigs', example='kyuubi.conf.key=value1
kyuubi.conf.key1=value2'),
        kyuubiServiceId?: string(name='kyuubiServiceId', description='KyuubiServer ID。', example='kb-070104e7631242448d12a1377c309f30'),
        name?: string(name='name', example='test'),
        publicEndpoint?: string(name='publicEndpoint', example='emr-spark-kyuubi-gateway-cn-hangzhou.aliyuncs.com'),
        queue?: string(name='queue', example='dev_queue'),
        releaseVersion?: string(name='releaseVersion', example='esr-4.2.0 (Spark 3.5.2, Scala 2.12)'),
        replica?: int32(name='replica', example='3'),
        sparkConfigs?: string(name='sparkConfigs', example='spark.conf.key=value1
spark.conf.key1=value2'),
        startTime?: string(name='startTime', example='2024-11-23 09:22:00'),
        state?: string(name='state', example='Running'),
      }
    ](name='kyuubiServices'),
  }(name='data'),
  requestId?: string(name='requestId', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model ListKyuubiServicesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListKyuubiServicesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListKyuubiServices  ListKyuubiServicesRequest
  * @return ListKyuubiServicesResponse
 */
async function listKyuubiServices(request: ListKyuubiServicesRequest): ListKyuubiServicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListKyuubiServices', 'GET', '/api/v1/kyuubi/{workspaceId}', 'json', false, 'json', request);
}

model ListKyuubiSparkApplicationsRequest {
  workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-d2d82aa09155****', position='Path'),
  kyuubiServiceId?: string(name='kyuubiServiceId', description='The ID of the Kyuubi service.', example='kb-c7141f10c3f549fc9f8b8ae562b8****', position='Path'),
  applicationId?: string(name='applicationId', description='The ID of the application that is submitted by using a Kyuubi gateway.', example='spark-339f844005b6404c95f9f7c7a13b****', position='Query'),
  applicationName?: string(name='applicationName', description='The name of the Spark application that is submitted by using a Kyuubi gateway.', example='kyuubi-connection-spark-sql-anonymous-fa9a5e73-b4b1-474a-b****', position='Query'),
  maxResults?: int32(name='maxResults', description='The maximum number of entries to return.', example='20', position='Query'),
  minDuration?: long(name='minDuration', position='Query'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='1', position='Query'),
  orderBy?: [ string ](name='orderBy', shrink='json', position='Query'),
  resourceQueueId?: string(name='resourceQueueId', position='Query'),
  sort?: string(name='sort', position='Query'),
  startTime?: {
    endTime?: long(name='endTime', description='The end of the start time range.', example='1710432000000'),
    startTime?: long(name='startTime', description='The beginning of the start time range.', example='1709740800000'),
  }(name='startTime', description='The range of start time.', shrink='json', position='Query'),
}

model ListKyuubiSparkApplicationsResponseBody = {
  applications?: [ 
    {
      applicationId?: string(name='applicationId', description='The ID of the application that is submitted by using a Kyuubi gateway.', example='spark-339f844005b6404c95f9f7c7a13b****'),
      applicationName?: string(name='applicationName', description='The name of the Spark application that is submitted by using a Kyuubi gateway.', example='kyuubi-connection-spark-sql-anonymous-fa9a5e73-b4b1-474a-b****'),
      cuHours?: double(name='cuHours', description='The number of CUs consumed during a specified cycle of a task. The value is an estimated value. Refer to your Alibaba Cloud bill for the actual number of consumed CUs.', example='0.238302'),
      endTime?: string(name='endTime', description='The time when the task ended.', example='2025-02-12 20:02:02'),
      mbSeconds?: long(name='mbSeconds', description='The total amount of memory allocated to the job multiplied by the running duration (seconds).', example='3513900'),
      resourceQueueId?: string(name='resourceQueueId', description='The name of the resource queue on which the Spark jobs run.', example='dev_queue'),
      startTime?: string(name='startTime', description='The time when the task started.', example='2025-02-12 19:59:16'),
      state?: string(name='state', description='The status of the Spark application.

*   STARTING
*   RUNNING
*   TERMINATED', example='STARTING'),
      vcoreSeconds?: long(name='vcoreSeconds', description='The total number of CPU cores allocated to the job multiplied by the running duration (seconds).', example='780'),
      webUI?: string(name='webUI', description='The URL of the web UI for the Spark application.'),
    }
  ](name='applications', description='The details of the applications.'),
  maxResults?: int32(name='maxResults', description='The maximum number of entries returned.', example='20'),
  nextToken?: string(name='nextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='1'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='200'),
}

model ListKyuubiSparkApplicationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListKyuubiSparkApplicationsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListKyuubiSparkApplications  ListKyuubiSparkApplicationsRequest
  * @return ListKyuubiSparkApplicationsResponse
 */
async function listKyuubiSparkApplications(request: ListKyuubiSparkApplicationsRequest): ListKyuubiSparkApplicationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListKyuubiSparkApplications', 'GET', '/api/v1/kyuubi/{workspaceId}/{kyuubiServiceId}/applications', 'json', false, 'json', request);
}

model ListKyuubiTokenRequest {
  workspaceId?: string(name='workspaceId', example='w-d2d82aa09155****', position='Path'),
  kyuubiServiceId?: string(name='kyuubiServiceId', example='kb-c7141f10c3f549fc9f8b8ae562b8****', position='Path'),
  regionId?: string(name='regionId', example='cn-hangzhou', position='Query'),
}

model ListKyuubiTokenResponseBody = {
  data?: {
    tokens?: [ 
      {
        createTime?: long(name='createTime', example='2025-02-11T02:23:02Z'),
        createdBy?: string(name='createdBy', example='test_user'),
        expireTime?: long(name='expireTime', example='1740366769165'),
        lastUsedTime?: long(name='lastUsedTime', example='1740366232121'),
        name?: string(name='name', example='dev_serveless_spark'),
        token?: string(name='token', example='f14c1347-dcfd-4082-b101-77aa96b5de36'),
        tokenId?: string(name='tokenId', description='Token ID。', example='f14c1347-dcfd-4082-b101-77aa96b5de36'),
      }
    ](name='tokens'),
  }(name='data'),
  requestId?: string(name='requestId', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model ListKyuubiTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListKyuubiTokenResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListKyuubiToken  ListKyuubiTokenRequest
  * @return ListKyuubiTokenResponse
 */
async function listKyuubiToken(request: ListKyuubiTokenRequest): ListKyuubiTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListKyuubiToken', 'GET', '/api/v1/workspaces/{workspaceId}/kyuubiService/{kyuubiServiceId}/token', 'json', false, 'json', request);
}

model ListLivyComputeRequest {
  workspaceBizId?: string(name='workspaceBizId', example='w-8adde60aa809701f', position='Path'),
  environmentId?: string(name='environmentId', example='ev-cq31c7tlhtgm9nrrlj4g', position='Query'),
  regionId?: string(name='regionId', example='cn-hangzhou', position='Query'),
}

model ListLivyComputeResponseBody = {
  code?: string(name='code', example='1000000'),
  data?: {
    livyComputes?: [ 
      {
        computeId?: string(name='computeId', example='lc-xxxxxxxxxxxx'),
        createdBy?: string(name='createdBy', example='alice'),
        endpoint?: string(name='endpoint', example='emr-spark-livy-gateway-cn-hangzhou.data.aliyun.com/api/v1/workspace/w-xxxxxxxxx/livycompute/lc-xxxxxxxxxxx'),
        endpointInner?: string(name='endpointInner', example='emr-spark-livy-gateway-cn-hangzhou-internal.aliyun.com/api/v1/workspace/w-xxxxxxxxx/livycompute/lc-xxxxxxxxxxx'),
        gmtCreate?: long(name='gmtCreate', example='1749456094000'),
        name?: string(name='name', example='test'),
        queueName?: string(name='queueName', example='root_queue'),
        startTime?: long(name='startTime', example='1749456094000'),
        status?: string(name='status', example='RUNNING'),
      }
    ](name='livyComputes'),
  }(name='data'),
  message?: string(name='message', example='ok'),
  requestId?: string(name='requestId', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model ListLivyComputeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLivyComputeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListLivyCompute  ListLivyComputeRequest
  * @return ListLivyComputeResponse
 */
async function listLivyCompute(request: ListLivyComputeRequest): ListLivyComputeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLivyCompute', 'GET', '/api/interactive/v1/workspace/{workspaceBizId}/livycompute', 'json', false, 'json', request);
}

model ListLivyComputeTokenRequest {
  workspaceBizId?: string(name='workspaceBizId', example='w-8adde60aa809701f', position='Path'),
  livyComputeId?: string(name='livyComputeId', example='lc-zm4dzdiubu73w2yx', position='Path'),
  regionId?: string(name='regionId', example='cn-hangzhou', position='Query'),
}

model ListLivyComputeTokenResponseBody = {
  code?: string(name='code', example='1000000'),
  data?: {
    tokens?: [ 
      {
        createTime?: long(name='createTime', example='1749456094000'),
        createdby?: string(name='createdby', example='alice'),
        expireTime?: long(name='expireTime', example='1749456994000'),
        lastUsedTime?: long(name='lastUsedTime', example='1749456098000'),
        name?: string(name='name', example='test'),
        token?: string(name='token', example='5d37843fb6f1e8'),
        tokenId?: string(name='tokenId', description='Token ID。', example='lctk-xxxxxxxxxxx'),
      }
    ](name='tokens'),
  }(name='data'),
  message?: string(name='message', example='ok'),
  requestId?: string(name='requestId', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model ListLivyComputeTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLivyComputeTokenResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListLivyComputeToken  ListLivyComputeTokenRequest
  * @return ListLivyComputeTokenResponse
 */
async function listLivyComputeToken(request: ListLivyComputeTokenRequest): ListLivyComputeTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLivyComputeToken', 'GET', '/api/interactive/v1/workspace/{workspaceBizId}/livycompute/{livyComputeId}/token', 'json', false, 'json', request);
}

model ListLogContentsRequest {
  workspaceId?: string(name='workspaceId', description='Workspace ID.', example='w-72704d9fb0******', position='Path'),
  fileName?: string(name='fileName', description='Full path of the file.', position='Query'),
  length?: int32(name='length', description='Length of the log.', example='9999', position='Query'),
  offset?: int32(name='offset', description='Start line for query.', example='0', position='Query'),
  regionId?: string(name='regionId', description='Region ID.', example='cn-hangzhou', position='Query'),
}

model ListLogContentsResponseBody = {
  listLogContent?: {
    contents?: [ 
      {
        lineContent?: string(name='LineContent', description='Log line content.', example='spark pi is 3.14\\n'),
      }
    ](name='contents', description='List of log line contents.'),
    totalLength?: long(name='totalLength', description='Total number of log lines.', example='10'),
  }(name='listLogContent', description='Log content.'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model ListLogContentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLogContentsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListLogContents  ListLogContentsRequest
  * @return ListLogContentsResponse
 */
async function listLogContents(request: ListLogContentsRequest): ListLogContentsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLogContents', 'GET', '/api/v1/workspaces/{workspaceId}/action/listLogContents', 'json', false, 'json', request);
}

model ListReleaseVersionsRequest {
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
  releaseType?: string(name='releaseType', description='The type of the version.

Valid values:

*   stable
*   Beta', example='stable', position='Query'),
  releaseVersion?: string(name='releaseVersion', description='The version of EMR Serverless Spark.', example='esr-2.1 (Spark 3.3.1, Scala 2.12, Java Runtime)', position='Query'),
  releaseVersionStatus?: string(name='releaseVersionStatus', description='The status of the version.

Valid values:

*   ONLINE
*   OFFLINE', example='ONLINE', position='Query'),
  serviceFilter?: string(name='serviceFilter', position='Query'),
  workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-d2d82aa09155****', position='Query'),
}

model ListReleaseVersionsResponseBody = {
  maxResults?: int32(name='maxResults', description='The maximum number of entries returned.', example='20'),
  nextToken?: string(name='nextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='1'),
  releaseVersions?: [ 
    {
      communityVersion?: string(name='communityVersion', description='The version number of open source Spark.', example='Spark 3.3.1'),
      cpuArchitectures?: [ string ](name='cpuArchitectures', description='The CPU architectures.'),
      displayReleaseVersion?: string(name='displayReleaseVersion', description='The version number.', example='esr-2.1 (Spark 3.3.1, Scala 2.12)'),
      fusion?: boolean(name='fusion', description='Indicates whether the Fusion engine is used for acceleration.', example='true'),
      gmtCreate?: long(name='gmtCreate', description='The creation time.', example='1716215854101'),
      iaasType?: string(name='iaasType', description='The type of the Infrastructure as a Service (IaaS) layer.', example='ASI'),
      releaseVersion?: string(name='releaseVersion', description='The version number.', example='esr-2.1 (Spark 3.3.1, Scala 2.12, Java Runtime)'),
      scalaVersion?: string(name='scalaVersion', description='The version of Scala.', example='2.12'),
      state?: string(name='state', description='The status of the version.', example='ONLINE'),
      type?: string(name='type', description='The type of the version.', example='stable'),
    }
  ](name='releaseVersions', description='The versions.'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='200'),
}

model ListReleaseVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListReleaseVersionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListReleaseVersions  ListReleaseVersionsRequest
  * @return ListReleaseVersionsResponse
 */
async function listReleaseVersions(request: ListReleaseVersionsRequest): ListReleaseVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListReleaseVersions', 'GET', '/api/v1/releaseVersions', 'json', false, 'json', request);
}

model ListSessionClustersRequest {
  workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-1234abcd', position='Path'),
  kind?: string(name='kind', description='The session type.

Valid values:

*   NOTEBOOK
*   THRIFT
*   SQL', example='SQL', position='Query'),
  maxResults?: int32(name='maxResults', description='The maximum number of entries to return.', example='20', position='Query'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the request to retrieve a new page of results.', example='DD6B1B2A-5837-5237-ABE4-FF0C89568980', position='Query'),
  queueName?: string(name='queueName', description='The name of the queue.', example='root', position='Query'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
  sessionClusterId?: string(name='sessionClusterId', description='The name of the job.', example='emr-spark-demo-job', position='Query'),
}

model ListSessionClustersResponseBody = {
  maxResults?: int32(name='maxResults', description='The maximum number of entries returned.', example='20'),
  nextToken?: string(name='nextToken', description='A pagination token.', example='DD6B1B2A-5837-5237-ABE4-FF0C89568980'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  sessionClusters?: [ 
    {
      applicationConfigs?: [ 
        {
          configFileName?: string(name='configFileName', description='The name of the configuration file.', example='spark-default.conf'),
          configItemKey?: string(name='configItemKey', description='The key of the configuration.', example='spark.app.name'),
          configItemValue?: string(name='configItemValue', description='The configuration value.', example='test_application'),
        }
      ](name='applicationConfigs', description='The session configurations, which are equivalent to the configurations of the Spark job.'),
      autoStartConfiguration?: {
        enable?: boolean(name='enable', description='Indicates whether automatic startup is enabled.', example='true'),
      }(name='autoStartConfiguration', description='The automatic startup configurations.'),
      autoStopConfiguration?: {
        enable?: boolean(name='enable', description='Indicates whether automatic termination is enabled.', example='false'),
        idleTimeoutMinutes?: int32(name='idleTimeoutMinutes', description='The idle timeout period. The session is automatically terminated when the idle timeout period is exceeded.', example='45'),
      }(name='autoStopConfiguration', description='The configurations of automatic termination.'),
      displayReleaseVersion?: string(name='displayReleaseVersion', description='The version of the Spark engine.', example='esr-4.0.0 (Spark 3.5.2, Scala 2.12)'),
      domain?: string(name='domain', description='The public endpoint of the Thrift server.', example='emr-spark-gateway-cn-hangzhou.data.aliyun.com'),
      domainInner?: string(name='domainInner', description='The internal endpoint of the Thrift server.', example='emr-spark-gateway-cn-hangzhou-internal.data.aliyuncs.com'),
      draftId?: string(name='draftId', description='The ID of the job that is associated with the session.', example='TSK-xxxxxxxxx'),
      extra?: string(name='extra', description='The additional metadata of the session.', example='{"extraInfoKey":"extraInfoValue"}'),
      fusion?: boolean(name='fusion', description='Indicates whether the Fusion engine is used for acceleration.', example='false'),
      gmtCreate?: long(name='gmtCreate', description='The creation time.', example='1732267598000'),
      kind?: string(name='kind', description='The session type.

Valid values:

*   NOTEBOOK
*   THRIFT
*   SQL', example='SQL'),
      name?: string(name='name', description='The name of the session.', example='adhoc_query'),
      publicEndpointEnabled?: boolean(name='publicEndpointEnabled'),
      queueName?: string(name='queueName', description='The name of the queue that is used to run the session.', example='dev_queue'),
      releaseVersion?: string(name='releaseVersion', description='The version of EMR Serverless Spark.', example='esr-2.1'),
      sessionClusterId?: string(name='sessionClusterId', description='The session ID.', example='sc-123131'),
      startTime?: long(name='startTime', description='The start time.', example='1732267598000'),
      state?: string(name='state', description='The status of the session.

*   Starting
*   Running
*   Stopping
*   Stopped
*   Error', example='Running'),
      stateChangeReason?: {
        code?: string(name='code', description='The status change code.', example='200'),
        message?: string(name='message', description='The status change message.', example='ok'),
      }(name='stateChangeReason', description='The details of the most recent status change of the session.'),
      userId?: string(name='userId', description='The user ID.', example='123131'),
      userName?: string(name='userName', description='The username.', example='test_user'),
      webUI?: string(name='webUI', description='The Spark UI of the session.', example='http://spark-ui-xxxx'),
      workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-1234abcd'),
    }
  ](name='sessionClusters', description='The sessions.'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='200'),
}

model ListSessionClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSessionClustersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListSessionClusters  ListSessionClustersRequest
  * @return ListSessionClustersResponse
 */
async function listSessionClusters(request: ListSessionClustersRequest): ListSessionClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListSessionClusters', 'GET', '/api/v1/workspaces/{workspaceId}/sessionClusters', 'json', false, 'json', request);
}

model ListWorkspaceQueuesRequest {
  workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-26ca1703f6d71e6e', position='Path'),
  environment?: string(name='environment', description='The environment type.

Valid values:

*   dev
*   production', example='production', position='Query'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
}

model ListWorkspaceQueuesResponseBody = {
  maxResults?: int32(name='maxResults', description='The maximum number of entries returned.', example='20'),
  nextToken?: string(name='nextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='1'),
  queues?: [ 
    {
      allowActions?: [ 
        {
          actionArn?: string(name='actionArn', description='The Alibaba Cloud Resource Name (ARN) of a behavior.', example='acs:emr::workspaceId:action/create_queue'),
          actionName?: string(name='actionName', description='The name of the permission.', example='view'),
          dependencies?: [ string ](name='dependencies', description='The dependencies of the operation.', example='["view"]'),
          description?: string(name='description', description='The description of the operation.', example='文件目录遍历、文件浏览'),
          displayName?: string(name='displayName', description='The display name of the permission.', example='文件目录遍历、文件浏览'),
        }
      ](name='allowActions', description='The operations allowed for the queue.'),
      createTime?: long(name='createTime', description='The time when the workspace was created.', example='1684115879955'),
      creator?: string(name='creator', description='The ID of the user who created the queue.', example='237109'),
      environments?: [ string ](name='environments', description='The environment types of the queue.'),
      maxResource?: string(name='maxResource', description='The maximum capacity of resources that can be used in the queue.', example='{"cpu": "2","memory": "2Gi"}'),
      minResource?: string(name='minResource', description='The minimum capacity of resources that can be used in the queue.', example='{"cpu": "2","memory": "2Gi"}'),
      paymentType?: string(name='paymentType', description='The billing method. Valid values:

*   PayAsYouGo
*   Pre', example='PayAsYouGo'),
      properties?: string(name='properties', description='The queue label.', example='dev_queue'),
      queueName?: string(name='queueName', description='The name of the queue.', example='dev_queue'),
      queueScope?: string(name='queueScope', description='The queue architecture.', example='{"arch": "x86"}'),
      queueStatus?: string(name='queueStatus', description='The status of the queue.', example='RUNNING'),
      queueType?: string(name='queueType', description='The type of the queue. Valid values:

*   instance
*   instanceChildren', example='instance, instanceChildren'),
      regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
      usedResource?: string(name='usedResource', description='The capacity of resources that are used in the queue.', example='{"cpu": "2","memory": "2Gi"}'),
      workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-1234abcd'),
    }
  ](name='queues', description='The list of queues.'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='200'),
}

model ListWorkspaceQueuesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWorkspaceQueuesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListWorkspaceQueues  ListWorkspaceQueuesRequest
  * @return ListWorkspaceQueuesResponse
 */
async function listWorkspaceQueues(request: ListWorkspaceQueuesRequest): ListWorkspaceQueuesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListWorkspaceQueues', 'GET', '/api/v1/workspaces/{workspaceId}/queues', 'json', false, 'json', request);
}

model ListWorkspacesRequest {
  maxResults?: int32(name='maxResults', description='The maximum number of entries returned.', example='20', position='Query'),
  name?: string(name='name', description='The name of the workspace. Fuzzy match is supported.', example='test_workspace', position='Query'),
  nextToken?: string(name='nextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='1', position='Query'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
  state?: string(name='state', description='The state of the workspace.', example='running', position='Query'),
  tag?: [ 
    {
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='tag', shrink='json', position='Query'),
}

model ListWorkspacesResponseBody = {
  maxResults?: int32(name='maxResults', description='The maximum number of entries returned.', example='20'),
  nextToken?: string(name='nextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='1'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='200'),
  workspaces?: [ 
    {
      autoRenew?: boolean(name='autoRenew', description='Specifies whether to enable auto-renewal. This parameter is required only if the paymentType parameter is set to Pre.', example='true'),
      autoRenewPeriod?: int32(name='autoRenewPeriod', description='The auto-renewal duration. This parameter is required only if the paymentType parameter is set to Pre.', example='1'),
      autoRenewPeriodUnit?: string(name='autoRenewPeriodUnit', description='The unit of the auto-renewal duration. This parameter is required only if the paymentType parameter is set to Pre.', example='YEAR, MONTH, WEEK, DAY, HOUR, MINUTE'),
      createTime?: long(name='createTime', description='The time when the workflow was created.', example='1684115879955'),
      dlfCatalogId?: string(name='dlfCatalogId', description='The information of the Data Lake Formation (DLF) catalog.', example='default'),
      dlfType?: string(name='dlfType', description='The version of DLF.', example='1.0'),
      duration?: int32(name='duration', description='The subscription period. This parameter is required only if the paymentType parameter is set to Pre.', example='1'),
      endTime?: long(name='endTime', description='The end of the end time range.', example='1687103999999'),
      failReason?: string(name='failReason', description='The failure reason.', example='out of stock'),
      paymentDurationUnit?: string(name='paymentDurationUnit', description='The unit of the subscription duration.', example='YEAR, MONTH, WEEK, DAY, HOUR, MINUTE'),
      paymentStatus?: string(name='paymentStatus', description='The status of the payment.', example='PAID/UNPAID'),
      paymentType?: string(name='paymentType', description='The billing method. Valid values:

- PayAsYouGo
- Pre', example='PayAsYouGo'),
      prePaidQuota?: {
        allocatedResource?: string(name='allocatedResource', description='The amount of resources that are allocated by a subscription quota.', example='{\\"cpu\\":\\"1\\",\\"memory\\":\\"4Gi\\",\\"cu\\":\\"1\\"}'),
        autoRenewal?: boolean(name='autoRenewal', description='Indicates whether auto-renewal is enabled for the subscription quota.

*   true
*   false', example='true'),
        createTime?: long(name='createTime', description='The creation time of the subscription quota.', example='1745683200000'),
        expireTime?: long(name='expireTime', description='The expiration time of the subscription quota.', example='1740537153000'),
        instanceId?: string(name='instanceId', description='The ID of the instance that is generated when you purchase the subscription quota.', example='i-abc12345'),
        maxResource?: string(name='maxResource', description='The maximum amount of resources that can be used in a subscription quota.', example='{\\"cpu\\":\\"1\\",\\"memory\\":\\"4Gi\\",\\"cu\\":\\"1\\"}'),
        orderId?: string(name='orderId'),
        paymentStatus?: string(name='paymentStatus', description='The status of the subscription quota. Valid values:

*   NORMAL
*   WAIT_FOR_EXPIRE
*   EXPIRED', example='NORMAL'),
        usedResource?: string(name='usedResource', description='The amount of resources that are used.', example='{\\"cpu\\":\\"0\\",\\"memory\\":\\"0Gi\\",\\"cu\\":\\"0\\"}'),
      }(name='prePaidQuota', description='The information about the subscription quota.'),
      regionId?: string(name='regionId', description='The region ID.', example='cn-shanghai'),
      releaseType?: string(name='releaseType', description='The reason why the workspace is released.', example='SERVICE_RELEASE'),
      resourceSpec?: string(name='resourceSpec', description='The resource specifications.', example='100cu'),
      stateChangeReason?: {
        code?: string(name='code', description='The error code.', example='0'),
        message?: string(name='message', description='The error message.', example='Success'),
      }(name='stateChangeReason', description='The reason of the job status change.'),
      storage?: string(name='storage', description='The OSS path.', example='spark-result'),
      tags?: [ 
        {
          tagKey?: string(name='tagKey'),
          tagValue?: string(name='tagValue'),
        }
      ](name='tags'),
      workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-******'),
      workspaceName?: string(name='workspaceName', description='The name of the workspace.', example='spark-1'),
      workspaceStatus?: string(name='workspaceStatus', description='The workspace status.', example='STARTING,RUNNING,TERMINATED'),
    }
  ](name='workspaces', description='The queried workspaces.'),
}

model ListWorkspacesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWorkspacesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListWorkspaces  ListWorkspacesRequest
  * @return ListWorkspacesResponse
 */
async function listWorkspaces(request: ListWorkspacesRequest): ListWorkspacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListWorkspaces', 'GET', '/api/v1/workspaces', 'json', false, 'json', request);
}

model RefreshLivyComputeTokenRequest {
  workspaceBizId?: string(name='workspaceBizId', example='w-8adde60aa809701f', position='Path'),
  livyComputeId?: string(name='livyComputeId', example='lc-i8xogcdfa4fk3yn1', position='Path'),
  tokenId?: string(name='tokenId', description='Token ID。', example='lctk-xxxxxxxx', position='Path'),
  autoExpireConfiguration?: {
    enable?: boolean(name='enable', example='false'),
    expireDays?: int32(name='expireDays', example='7'),
  }(name='autoExpireConfiguration', position='Body'),
  name?: string(name='name', example='test', position='Body'),
  token?: string(name='token', example='fe86812667f04v343', position='Body'),
  regionId?: string(name='regionId', example='cn-hangzhou', position='Query'),
}

model RefreshLivyComputeTokenResponseBody = {
  code?: string(name='code', example='1000000'),
  message?: string(name='message', example='ok'),
  requestId?: string(name='requestId', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model RefreshLivyComputeTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RefreshLivyComputeTokenResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RefreshLivyComputeToken  RefreshLivyComputeTokenRequest
  * @return RefreshLivyComputeTokenResponse
 */
async function refreshLivyComputeToken(request: RefreshLivyComputeTokenRequest): RefreshLivyComputeTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RefreshLivyComputeToken', 'POST', '/api/interactive/v1/workspace/{workspaceBizId}/livycompute/{livyComputeId}/token/{tokenId}', 'json', false, 'json', request);
}

model StartJobRunRequest {
  workspaceId: string(name='workspaceId', description='The workspace ID.

This parameter is required.', example='w-123213123131', position='Path'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request.', example='8e6aae2810c8f67229ca70bb31cd6028', position='Body'),
  codeType?: string(name='codeType', description='The code type of the job. Valid values:

*   SQL
*   JAR
*   PYTHON', example='SQL', position='Body'),
  configurationOverrides?: {
    configurations?: [ 
      {
        configFileName?: string(name='configFileName', description='The configuration file of SparkConf.', example='spark-default.conf'),
        configItemKey?: string(name='configItemKey', description='The key of SparkConf.', example='spark.app.name'),
        configItemValue?: string(name='configItemValue', description='The value of SparkConf.', example='test_app'),
      }
    ](name='configurations', description='The SparkConf objects.'),
  }(name='configurationOverrides', description='The advanced configurations of Spark.', position='Body'),
  displayReleaseVersion?: string(name='displayReleaseVersion', description='The version of the Spark engine.', example='esr-3.3.1', position='Body'),
  executionTimeoutSeconds?: int32(name='executionTimeoutSeconds', description='The timeout period of the job.', example='100', position='Body'),
  fusion?: boolean(name='fusion', description='Specifies whether to enable Fusion engine for acceleration.', example='false', position='Body'),
  jobDriver?: JobDriver(name='jobDriver', description='The information about Spark Driver.', position='Body'),
  jobId?: string(name='jobId', description='The job ID.', example='jr-12345', position='Body'),
  name?: string(name='name', description='The name of the job.', example='spark_job_name', position='Body'),
  releaseVersion?: string(name='releaseVersion', description='The version number of Spark.', example='esr-3.3.1', position='Body'),
  resourceQueueId?: string(name='resourceQueueId', description='The name of the resource queue on which the Spark job runs.', example='dev_queue', position='Body'),
  tags?: [
    Tag
  ](name='tags', description='The tags of the job.', position='Body'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
}

model StartJobRunResponseBody = {
  jobRunId?: string(name='jobRunId', description='The job ID.', example='jr-54321'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model StartJobRunResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartJobRunResponseBody(name='body'),
}

/**
  * @param request  the request parameters of StartJobRun  StartJobRunRequest
  * @return StartJobRunResponse
 */
async function startJobRun(request: StartJobRunRequest): StartJobRunResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StartJobRun', 'POST', '/api/v1/workspaces/{workspaceId}/jobRuns', 'json', false, 'json', request);
}

model StartLivyComputeRequest {
  workspaceBizId?: string(name='workspaceBizId', example='w-8adde60aa809701f', position='Path'),
  livyComputeId?: string(name='livyComputeId', example='lc-i8xogcdfa4fk3yn1', position='Path'),
  regionId?: string(name='regionId', example='cn-hangzhou', position='Query'),
}

model StartLivyComputeResponseBody = {
  code?: string(name='code', example='1000000'),
  message?: string(name='message', example='ok'),
  requestId?: string(name='requestId', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model StartLivyComputeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartLivyComputeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of StartLivyCompute  StartLivyComputeRequest
  * @return StartLivyComputeResponse
 */
async function startLivyCompute(request: StartLivyComputeRequest): StartLivyComputeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StartLivyCompute', 'POST', '/api/interactive/v1/workspace/{workspaceBizId}/livycompute/{livyComputeId}/start', 'json', false, 'json', request);
}

model StartProcessInstanceRequest {
  bizId: string(name='bizId', description='The workspace ID.

This parameter is required.', example='w-d8********', position='Path'),
  action?: string(name='action', position='Query'),
  comments?: string(name='comments', position='Query'),
  email?: string(name='email', position='Query'),
  interval?: string(name='interval', position='Query'),
  isProd?: boolean(name='isProd', description='Specifies whether to run the workflow in the production environment.', example='false', position='Query'),
  processDefinitionCode: long(name='processDefinitionCode', description='The workflow ID.

This parameter is required.', example='12***********', position='Query'),
  productNamespace: string(name='productNamespace', description='The code of the service.

This parameter is required.', example='SS', position='Query'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
  runtimeQueue?: string(name='runtimeQueue', description='The queue on which the workflow runs.', example='root_queue', position='Query'),
  versionHashCode?: string(name='versionHashCode', description='The hash code of the version.', example='dh*********', position='Query'),
  versionNumber?: int32(name='versionNumber', description='The version number of the workflow.', example='1', position='Query'),
}

model StartProcessInstanceResponseBody = {
  code?: int32(name='code', description='The code that is returned by the backend server.', example='1400009'),
  data?: any(name='data', description='The data returned.', example='{\\"sessionBizId\\": \\"sc-dc85644dba1c8c63\\", \\"bizId\\": \\"st-aeed3b0d4f87418a9a9dcbd757477658\\", \\"gmtCreated\\": \\"Thu Sep 12 02:28:45 UTC 2024\\"}'),
  failed?: boolean(name='failed', description='Indicates whether the workflow fails to be run manually.', example='false'),
  httpStatusCode?: int32(name='httpStatusCode', description='The HTTP status code.', example='200'),
  msg?: string(name='msg', description='The description of the returned code.', example='No permission for resource action'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  success?: boolean(name='success', description='Indicates whether the request was successful.', example='true'),
}

model StartProcessInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartProcessInstanceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of StartProcessInstance  StartProcessInstanceRequest
  * @return StartProcessInstanceResponse
 */
async function startProcessInstance(request: StartProcessInstanceRequest): StartProcessInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StartProcessInstance', 'POST', '/dolphinscheduler/projects/{bizId}/executors/start-process-instance', 'json', false, 'json', request);
}

model StartSessionClusterRequest {
  workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-d2d82aa09155****', position='Path'),
  queueName?: string(name='queueName', description='The queue name.', example='root_queue', position='Body'),
  sessionClusterId?: string(name='sessionClusterId', description='The session ID.', example='sc-xxxxxxxxxxx', position='Body'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
}

model StartSessionClusterResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  sessionClusterId?: string(name='sessionClusterId', description='The workspace ID.', example='w-******'),
}

model StartSessionClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartSessionClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of StartSessionCluster  StartSessionClusterRequest
  * @return StartSessionClusterResponse
 */
async function startSessionCluster(request: StartSessionClusterRequest): StartSessionClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StartSessionCluster', 'POST', '/api/v1/workspaces/{workspaceId}/sessionClusters/action/startSessionCluster', 'json', false, 'json', request);
}

model StopLivyComputeRequest {
  workspaceBizId?: string(name='workspaceBizId', example='w-8adde60aa809701f', position='Path'),
  livyComputeId?: string(name='livyComputeId', example='lc-6mkvn01zrg8rqhhv', position='Path'),
  regionId?: string(name='regionId', example='cn-hangzhou', position='Query'),
}

model StopLivyComputeResponseBody = {
  code?: string(name='code', example='1000000'),
  message?: string(name='message', example='ok'),
  requestId?: string(name='requestId', example='484D9DDA-300D-525E-AF7A-0CCCA5C64A7A'),
}

model StopLivyComputeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopLivyComputeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of StopLivyCompute  StopLivyComputeRequest
  * @return StopLivyComputeResponse
 */
async function stopLivyCompute(request: StopLivyComputeRequest): StopLivyComputeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StopLivyCompute', 'POST', '/api/interactive/v1/workspace/{workspaceBizId}/livycompute/{livyComputeId}/stop', 'json', false, 'json', request);
}

model StopSessionClusterRequest {
  workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-d2d82aa09155****', position='Path'),
  queueName?: string(name='queueName', description='The queue name.', example='root_queue', position='Body'),
  sessionClusterId?: string(name='sessionClusterId', description='The session ID.', example='sc-xxxxxxxxxxxx', position='Body'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
}

model StopSessionClusterResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  sessionClusterId?: string(name='sessionClusterId', description='The session ID.', example='w-******'),
}

model StopSessionClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopSessionClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of StopSessionCluster  StopSessionClusterRequest
  * @return StopSessionClusterResponse
 */
async function stopSessionCluster(request: StopSessionClusterRequest): StopSessionClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StopSessionCluster', 'POST', '/api/v1/workspaces/{workspaceId}/sessionClusters/action/stopSessionCluster', 'json', false, 'json', request);
}

model TerminateSqlStatementRequest {
  workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-d2d82aa09155****', position='Path'),
  statementId?: string(name='statementId', description='The interactive query ID.', example='st-abcadfadf12****', position='Path'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
}

model TerminateSqlStatementResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model TerminateSqlStatementResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TerminateSqlStatementResponseBody(name='body'),
}

/**
  * @param request  the request parameters of TerminateSqlStatement  TerminateSqlStatementRequest
  * @return TerminateSqlStatementResponse
 */
async function terminateSqlStatement(request: TerminateSqlStatementRequest): TerminateSqlStatementResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'TerminateSqlStatement', 'POST', '/api/interactive/v1/workspace/{workspaceId}/statement/{statementId}/terminate', 'json', false, 'json', request);
}

model UpdateLivyComputeRequest {
  workspaceBizId?: string(name='workspaceBizId', example='w-8adde60aa809701f', position='Path'),
  livyComputeId?: string(name='livyComputeId', example='lc-i8xogcdfa4fk3yn1', position='Path'),
  authType?: string(name='authType', example='Token', position='Body'),
  autoStartConfiguration?: {
    enable?: boolean(name='enable', example='false'),
  }(name='autoStartConfiguration', position='Body'),
  autoStopConfiguration?: {
    enable?: boolean(name='enable', example='false'),
    idleTimeoutMinutes?: long(name='idleTimeoutMinutes', example='300'),
  }(name='autoStopConfiguration', position='Body'),
  cpuLimit?: string(name='cpuLimit', example='1', position='Body'),
  displayReleaseVersion?: string(name='displayReleaseVersion', example='esr-4.3.0 (Spark 3.5.2, Scala 2.12)', position='Body'),
  enablePublic?: boolean(name='enablePublic', position='Body'),
  environmentId?: string(name='environmentId', example='ev-cq146allhtgkulp5smk0', position='Body'),
  fusion?: boolean(name='fusion', example='false', position='Body'),
  livyServerConf?: string(name='livyServerConf', example='{
  "sparkDefaultsConf": "spark.driver.cores     1\\nspark.driver.memory    4g\\nspark.executor.cores   1\\nspark.executor.memory  4g\\n",
  "sparkBlackListConf": "spark.driver.cores\\nspark.driver.memory",
  "livyConf": "livy.server.session.timeout  1h\\n",
  "livyClientConf": "livy.rsc.sql.num-rows  1000\\n"
}', position='Body'),
  livyVersion?: string(name='livyVersion', example='0.8.0', position='Body'),
  memoryLimit?: string(name='memoryLimit', example='4Gi', position='Body'),
  name?: string(name='name', example='test', position='Body'),
  networkName?: string(name='networkName', example='test', position='Body'),
  queueName?: string(name='queueName', example='root_queue', position='Body'),
  releaseVersion?: string(name='releaseVersion', example='esr-4.3.0 (Spark 3.5.2, Scala 2.12, Java Runtime)', position='Body'),
  regionId?: string(name='regionId', example='cn-hangzhou', position='Query'),
}

model UpdateLivyComputeResponseBody = {
  code?: string(name='code', example='1000000'),
  message?: string(name='message', example='ok'),
  requestId?: string(name='requestId', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model UpdateLivyComputeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLivyComputeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateLivyCompute  UpdateLivyComputeRequest
  * @return UpdateLivyComputeResponse
 */
async function updateLivyCompute(request: UpdateLivyComputeRequest): UpdateLivyComputeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateLivyCompute', 'POST', '/api/interactive/v1/workspace/{workspaceBizId}/livycompute/{livyComputeId}', 'json', false, 'json', request);
}

model UpdateProcessDefinitionWithScheduleRequest {
  bizId: string(name='bizId', description='The workspace ID.

This parameter is required.', example='w-d8********', position='Path'),
  code: long(name='code', description='The workflow ID.

This parameter is required.', example='12************', position='Path'),
  alertEmailAddress?: string(name='alertEmailAddress', description='The email address to receive alerts.', example='foo_bar@spark.alert.invalid.com', position='Query'),
  description?: string(name='description', description='The description of the workflow.', example='ods batch workflow', position='Query'),
  executionType: string(name='executionType', description='The execution policy.

This parameter is required.', example='PARALLEL', position='Query'),
  globalParams?: [ 
    {
      direct?: string(name='direct'),
      prop?: string(name='prop'),
      type?: string(name='type'),
      value?: string(name='value'),
    }
  ](name='globalParams', shrink='json', position='Query'),
  name: string(name='name', description='The name of the workflow.

This parameter is required.', example='ods_batch_workflow', position='Query'),
  productNamespace: string(name='productNamespace', description='The code of the service.

This parameter is required.', example='SS', position='Query'),
  publish?: boolean(name='publish', description='Specifies whether to publish the workflow.', example='true', position='Query'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou', position='Query'),
  releaseState?: string(name='releaseState', description='The status of the workflow.', example='ONLINE', position='Query'),
  resourceQueue?: string(name='resourceQueue', description='The resource queue.', example='root_queue', position='Query'),
  retryTimes?: int32(name='retryTimes', description='The number of retries.', example='1', position='Query'),
  runAs?: string(name='runAs', description='The execution user.', example='113***************', position='Query'),
  schedule?: {
    crontab?: string(name='crontab', description='The CRON expression that is used for scheduling.', example='0 0 0 * * ?'),
    endTime?: string(name='endTime', description='The end time of the scheduling.', example='2025-12-23 16:13:27'),
    startTime?: string(name='startTime', description='The start time of the scheduling.', example='2024-12-23 16:13:27'),
    timezoneId?: string(name='timezoneId', description='The ID of the time zone.', example='Asia/Shanghai'),
  }(name='schedule', description='The scheduling settings.', shrink='json', position='Query'),
  tags?: map[string]string(name='tags', description='The tags.', shrink='json', position='Query'),
  taskDefinitionJson: [ 
    {
      alertEmailAddress?: string(name='alertEmailAddress', description='The email address to receive alerts.', example='foo_bar@spark.alert.invalid.com'),
      code: long(name='code', description='The node ID.

This parameter is required.', example='23************'),
      description?: string(name='description', description='The node description.', example='ods transform task'),
      failAlertEnable?: boolean(name='failAlertEnable', description='Specifies whether to send alerts when the node fails.', example='true'),
      failRetryTimes?: int32(name='failRetryTimes', description='The number of retries when the node fails.', example='1'),
      name: string(name='name', description='The name of the job.

This parameter is required.', example='ods_transform_task'),
      startAlertEnable?: boolean(name='startAlertEnable', description='Specifies whether to send alerts when the node is started.', example='true'),
      tags?: map[string]string(name='tags', description='The tags of the job.'),
      taskParams: {
        displaySparkVersion?: string(name='displaySparkVersion', description='The displayed version of the Spark engine.', example='esr-4.0.0 (Spark 3.5.2, Scala 2.12)'),
        environmentId?: string(name='environmentId', description='The environment ID.', example='ev-h*************'),
        fusion?: boolean(name='fusion', description='Specifies whether to enable Fusion engine for acceleration.', example='false'),
        localParams?: [ 
          {
            direct?: string(name='direct'),
            prop?: string(name='prop'),
            type?: string(name='type'),
            value?: string(name='value'),
          }
        ](name='localParams'),
        resourceQueueId: string(name='resourceQueueId', description='The name of the queue on which the job runs.

This parameter is required.', example='root_queue'),
        sparkConf?: [ 
          {
            key?: string(name='key', description='The key of the SparkConf object.', example='spark.dynamicAllocation.enabled'),
            value?: string(name='value', description='The value of the SparkConf object.', example='true'),
          }
        ](name='sparkConf', description='The configurations of the Spark jobs.'),
        sparkDriverCores?: int32(name='sparkDriverCores', description='The number of driver cores of the Spark job.', example='1'),
        sparkDriverMemory?: long(name='sparkDriverMemory', description='The size of driver memory of the Spark job.', example='4g'),
        sparkExecutorCores?: int32(name='sparkExecutorCores', description='The number of executor cores of the Spark job.', example='1'),
        sparkExecutorMemory?: long(name='sparkExecutorMemory', description='The size of executor memory of the Spark job.', example='4g'),
        sparkLogLevel?: string(name='sparkLogLevel', description='The level of the Spark log.', example='INFO'),
        sparkLogPath?: string(name='sparkLogPath', description='The path where the operational logs of the Spark job are stored.'),
        sparkVersion?: string(name='sparkVersion', description='The version of the Spark engine.', example='esr-4.0.0 (Spark 3.5.2, Scala 2.12)'),
        taskBizId: string(name='taskBizId', description='The ID of the data development job.

This parameter is required.', example='TSK-d87******************'),
        type?: string(name='type', description='The type of the Spark job.', example='SQL'),
        workspaceBizId: string(name='workspaceBizId', description='The workspace ID.

This parameter is required.', example='w-d8********'),
      }(name='taskParams', description='The job parameters.

This parameter is required.'),
      taskType: string(name='taskType', description='The type of the node.

This parameter is required.', example='EMR-SERVERLESS-SPARK'),
      timeout?: int32(name='timeout', description='The default timeout period of the node.', example='30'),
    }
  ](name='taskDefinitionJson', description='The descriptions of all nodes in the workflow.

This parameter is required.', shrink='json', position='Query'),
  taskParallelism?: int32(name='taskParallelism', description='The node parallelism.', example='1', position='Query'),
  taskRelationJson: [ 
    {
      name: string(name='name', description='The name of the node topology. You can enter a workflow name.

This parameter is required.', example='ods batch workflow'),
      postTaskCode: long(name='postTaskCode', description='The ID of the downstream node.

This parameter is required.', example='19************'),
      postTaskVersion: int32(name='postTaskVersion', description='The version of the downstream node.

This parameter is required.', example='1'),
      preTaskCode: long(name='preTaskCode', description='The ID of the upstream node.

This parameter is required.', example='16************'),
      preTaskVersion: int32(name='preTaskVersion', description='The version of the upstream node.

This parameter is required.', example='1'),
    }
  ](name='taskRelationJson', description='The dependencies of all nodes in the workflow. preTaskCode specifies the ID of an upstream node, and postTaskCode specifies the ID of a downstream node. The ID of each node is unique. If a node does not have an upstream node, set preTaskCode to 0.

This parameter is required.', shrink='json', position='Query'),
  timeout?: int32(name='timeout', description='The default timeout period of the workflow.', example='300', position='Query'),
}

model UpdateProcessDefinitionWithScheduleResponseBody = {
  code?: int32(name='code', description='The code that is returned by the backend server.', example='1400009'),
  data?: {
    alertEmailAddress?: string(name='alertEmailAddress', description='The email address to receive alerts.', example='foo_bar@spark.alert.invalid.com'),
    bizId?: string(name='bizId', description='The workspace ID.', example='alicloud_ack_one_cluster'),
    code?: string(name='code', description='The workflow ID.', example='12***********'),
    createTime?: string(name='createTime', description='The time when the workflow was created.', example='2024-09-05T02:03:19Z'),
    crontab?: string(name='crontab', description='The CRON expression that is used for scheduling.', example='0 0 0 * * ?'),
    description?: string(name='description', description='The node description.', example='1'),
    endTime?: string(name='endTime', description='The end of the end time range.', example='1710432000000'),
    executionType?: string(name='executionType', description='The execution policy.', example='SERIAL'),
    id?: string(name='id', description='The serial number of the workflow.', example='123223'),
    name?: string(name='name', description='The name of the workflow.', example='ods_batch_workflow'),
    projectName?: string(name='projectName', description='The name of the project to which the workflow belongs.', example='w-********'),
    releaseState?: string(name='releaseState', description='The status of the workflow.', example='ONLINE'),
    startTime?: string(name='startTime', description='The start time of the scheduling.', example='0'),
    timezoneId?: string(name='timezoneId', description='The ID of the time zone.', example='Asia/Shanghai'),
    updateTime?: string(name='updateTime', description='The time when the workflow was updated.', example='2024-03-05T06:24:27Z'),
    userId?: string(name='userId', description='The ID of the user that is used to initiate a scheduling.', example='113*********'),
    userName?: string(name='userName', description='The name of the user that is used to initiate a scheduling.', example='w-********'),
    version?: int32(name='version', description='The version number.', example='1'),
    versionHashCode?: string(name='versionHashCode', description='The hash code of the version.', example='dwerf*********'),
  }(name='data', description='The data returned.'),
  failed?: string(name='failed', description='Indicates whether the request failed.', example='false'),
  httpStatusCode?: int32(name='httpStatusCode', description='The HTTP status code.', example='200'),
  msg?: string(name='msg', description='The description of the returned code.', example='No permission for resource action'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  success?: string(name='success', description='Indicates whether the request was successful.', example='true'),
}

model UpdateProcessDefinitionWithScheduleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateProcessDefinitionWithScheduleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateProcessDefinitionWithSchedule  UpdateProcessDefinitionWithScheduleRequest
  * @return UpdateProcessDefinitionWithScheduleResponse
 */
async function updateProcessDefinitionWithSchedule(request: UpdateProcessDefinitionWithScheduleRequest): UpdateProcessDefinitionWithScheduleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateProcessDefinitionWithSchedule', 'PUT', '/dolphinscheduler/projects/{bizId}/process-definition/{code}', 'json', false, 'json', request);
}

