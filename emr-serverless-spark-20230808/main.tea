/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('emr-serverless-spark', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model Artifact {
  bizId?: string(name='bizId', description='This parameter is required.'),
  catagoryBizId?: string(name='catagoryBizId'),
  creator?: long(name='creator', description='This parameter is required.'),
  credential?: Credential(name='credential'),
  fullPath?: [ string ](name='fullPath'),
  gmtCreated?: string(name='gmtCreated', description='This parameter is required.'),
  gmtModified?: string(name='gmtModified', description='This parameter is required.'),
  location?: string(name='location', description='This parameter is required.'),
  modifier?: long(name='modifier', description='This parameter is required.'),
  name?: string(name='name', description='This parameter is required.'),
}

model Category {
  bizId?: string(name='bizId', description='This parameter is required.'),
  creator?: long(name='creator', description='This parameter is required.'),
  gmtCreated?: string(name='gmtCreated', description='This parameter is required.'),
  gmtModified?: string(name='gmtModified', description='This parameter is required.'),
  modifier?: long(name='modifier', description='This parameter is required.'),
  name?: string(name='name', description='This parameter is required.'),
  parentBizId?: string(name='parentBizId'),
  type?: string(name='type', description='This parameter is required.'),
}

model Configuration {
  configFileName?: string(name='configFileName'),
  configItemKey?: string(name='configItemKey'),
  configItemValue?: string(name='configItemValue'),
}

model ConfigurationOverrides {
  configurations?: [ 
    {
      configFileName?: string(name='configFileName'),
      configItemKey?: string(name='configItemKey'),
      configItemValue?: string(name='configItemValue'),
    }
  ](name='configurations'),
}

model Credential {
  accessId?: string(name='accessId', description='This parameter is required.'),
  dir?: string(name='dir', description='This parameter is required.'),
  expire?: string(name='expire', description='This parameter is required.'),
  host?: string(name='host', description='This parameter is required.'),
  policy?: string(name='policy', description='This parameter is required.'),
  securityToken?: string(name='securityToken', description='This parameter is required.'),
  signature?: string(name='signature', description='This parameter is required.'),
}

model JobDriver {
  sparkSubmit?: {
    entryPoint?: string(name='entryPoint'),
    entryPointArguments?: [ string ](name='entryPointArguments'),
    sparkSubmitParameters?: string(name='sparkSubmitParameters'),
  }(name='sparkSubmit'),
}

model KerberosConf {
  creator?: string(name='creator'),
  enabled?: boolean(name='enabled'),
  gmtCreated?: string(name='gmtCreated'),
  gmtModified?: string(name='gmtModified'),
  kerberosConfId?: string(name='kerberosConfId'),
  keytabs?: [ string ](name='keytabs'),
  krb5Conf?: string(name='krb5Conf'),
  name?: string(name='name'),
  networkServiceId?: string(name='networkServiceId'),
  workspaceId?: string(name='workspaceId'),
}

model PrincipalAction {
  actionArn?: string(name='actionArn', example='acs:emr::workspaceId:action/create_queue'),
  principalArn?: string(name='principalArn', example='acs:emr::workspaceId:user/237593691541622267'),
}

model ReleaseVersionImage {
  cpuArchitecture?: string(name='cpuArchitecture'),
  imageId?: string(name='imageId'),
  runtimeEngineType?: string(name='runtimeEngineType'),
}

model RunLog {
  driverStartup?: string(name='driverStartup'),
  driverStdError?: string(name='driverStdError'),
  driverStdOut?: string(name='driverStdOut'),
  driverSyslog?: string(name='driverSyslog'),
}

model SparkConf {
  key?: string(name='key', description='This parameter is required.'),
  value?: string(name='value', description='This parameter is required.'),
}

model SqlOutput {
  rows?: [ 
    {
      values?: [ string ](name='values', example='null'),
    }
  ](name='rows'),
  schema?: {
    fields?: [ 
      {
        name?: string(name='name'),
        nullable?: boolean(name='nullable'),
        type?: string(name='type'),
      }
    ](name='fields'),
  }(name='schema'),
}

model Tag {
  key?: string(name='key', description='标签key值。', example='workflowId'),
  value?: string(name='value', description='标签key值。', example='wf-123test'),
}

model Task {
  archives?: [ string ](name='archives'),
  artifactUrl?: string(name='artifactUrl'),
  bizId?: string(name='bizId', description='This parameter is required.'),
  categoryBizId?: string(name='categoryBizId'),
  content?: string(name='content'),
  creator?: long(name='creator', description='This parameter is required.'),
  credential?: {
    accessId?: string(name='accessId'),
    accessUrl?: string(name='accessUrl'),
    expire?: long(name='expire'),
    host?: string(name='host'),
    path?: string(name='path'),
    policy?: string(name='policy'),
    securityToken?: string(name='securityToken'),
    signature?: string(name='signature'),
  }(name='credential'),
  defaultCatalogId?: string(name='defaultCatalogId'),
  defaultDatabase?: string(name='defaultDatabase'),
  defaultResourceQueueId?: string(name='defaultResourceQueueId'),
  defaultSqlComputeId?: string(name='defaultSqlComputeId'),
  deploymentId?: string(name='deploymentId'),
  environmentId?: string(name='environmentId'),
  extraArtifactIds?: [ string ](name='extraArtifactIds'),
  extraSparkSubmitParams?: string(name='extraSparkSubmitParams'),
  files?: [ string ](name='files'),
  fusion?: boolean(name='fusion'),
  gmtCreated?: string(name='gmtCreated', description='This parameter is required.'),
  gmtModified?: string(name='gmtModified', description='This parameter is required.'),
  hasChanged?: boolean(name='hasChanged'),
  hasCommited?: boolean(name='hasCommited', description='This parameter is required.'),
  isStreaming?: boolean(name='isStreaming'),
  jars?: [ string ](name='jars'),
  lastRunResourceQueueId?: string(name='lastRunResourceQueueId'),
  modifier?: long(name='modifier', description='This parameter is required.'),
  name?: string(name='name', description='This parameter is required.'),
  pyFiles?: [ string ](name='pyFiles'),
  sparkArgs?: string(name='sparkArgs', example='100'),
  sparkConf?: [
    SparkConf
  ](name='sparkConf'),
  sparkDriverCores?: int32(name='sparkDriverCores', description='This parameter is required.'),
  sparkDriverMemory?: long(name='sparkDriverMemory', description='This parameter is required.'),
  sparkEntrypoint?: string(name='sparkEntrypoint'),
  sparkExecutorCores?: int32(name='sparkExecutorCores', description='This parameter is required.'),
  sparkExecutorMemory?: long(name='sparkExecutorMemory', description='This parameter is required.'),
  sparkLogLevel?: string(name='sparkLogLevel', description='This parameter is required.'),
  sparkLogPath?: string(name='sparkLogPath', description='This parameter is required.'),
  sparkSubmitClause?: string(name='sparkSubmitClause'),
  sparkVersion?: string(name='sparkVersion', description='This parameter is required.'),
  tags?: map[string]string(name='tags'),
  timeout?: int32(name='timeout'),
  type?: string(name='type', description='This parameter is required.'),
}

model TaskInstance {
  bizId?: string(name='bizId'),
  creator?: long(name='creator'),
  fenixRunId?: string(name='fenixRunId'),
  gmtCreated?: string(name='gmtCreated'),
  taskBizId?: string(name='taskBizId'),
  taskInfo?: Task(name='taskInfo'),
  taskStatus?: string(name='taskStatus'),
  workspaceBizId?: string(name='workspaceBizId'),
}

model TaskSnapshot {
  bizId?: string(name='bizId'),
  commiter?: long(name='commiter'),
  gmtCreated?: string(name='gmtCreated'),
  item?: Task(name='item'),
  message?: string(name='message'),
  taskBizId?: string(name='taskBizId'),
  version?: string(name='version'),
}

model Template {
  creator?: long(name='creator', description='This parameter is required.'),
  displaySparkVersion?: string(name='displaySparkVersion'),
  fusion?: boolean(name='fusion'),
  gmtCreated?: string(name='gmtCreated', description='This parameter is required.'),
  gmtModified?: string(name='gmtModified', description='This parameter is required.'),
  modifier?: long(name='modifier', description='This parameter is required.'),
  sparkConf?: [
    SparkConf
  ](name='sparkConf'),
  sparkDriverCores?: int32(name='sparkDriverCores', description='This parameter is required.'),
  sparkDriverMemory?: long(name='sparkDriverMemory', description='This parameter is required.'),
  sparkExecutorCores?: int32(name='sparkExecutorCores', description='This parameter is required.'),
  sparkExecutorMemory?: long(name='sparkExecutorMemory', description='This parameter is required.'),
  sparkLogLevel?: string(name='sparkLogLevel', description='This parameter is required.'),
  sparkLogPath?: string(name='sparkLogPath', description='This parameter is required.'),
  sparkVersion?: string(name='sparkVersion', description='This parameter is required.'),
  templateType?: string(name='templateType'),
}

model TimeRange {
  endTime?: long(name='endTime', description='时间范围结束时间。', example='1688370894339'),
  startTime?: long(name='startTime', description='时间范围开始时间。', example='1688370894339'),
}

model AddMembersRequest {
  memberArns?: [ string ](name='memberArns', description='This parameter is required.'),
  workspaceId?: string(name='workspaceId', description='The workspace ID.

This parameter is required.', example='w-975bcfda9625****'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
}

model AddMembersResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model AddMembersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddMembersResponseBody(name='body'),
}

/**
 * @summary Adds a RAM user or RAM role to a workspace as a member.
 *
 * @param request AddMembersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddMembersResponse
 */
async function addMembersWithOptions(request: AddMembersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddMembersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.memberArns)) {
    body['memberArns'] = request.memberArns;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['workspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddMembers',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/v1/auth/members`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds a RAM user or RAM role to a workspace as a member.
 *
 * @param request AddMembersRequest
 * @return AddMembersResponse
 */
async function addMembers(request: AddMembersRequest): AddMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addMembersWithOptions(request, headers, runtime);
}

model CancelJobRunRequest {
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
}

model CancelJobRunResponseBody = {
  jobRunId?: string(name='jobRunId', description='The job ID.', example='jr-1a2bc3'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model CancelJobRunResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelJobRunResponseBody(name='body'),
}

/**
 * @summary Terminates a Spark job.
 *
 * @param request CancelJobRunRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelJobRunResponse
 */
async function cancelJobRunWithOptions(workspaceId: string, jobRunId: string, request: CancelJobRunRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelJobRunResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelJobRun',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${OpenApiUtil.getEncodeParam(workspaceId)}/jobRuns/${OpenApiUtil.getEncodeParam(jobRunId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Terminates a Spark job.
 *
 * @param request CancelJobRunRequest
 * @return CancelJobRunResponse
 */
async function cancelJobRun(workspaceId: string, jobRunId: string, request: CancelJobRunRequest): CancelJobRunResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelJobRunWithOptions(workspaceId, jobRunId, request, headers, runtime);
}

model CreateProcessDefinitionWithScheduleRequest {
  alertEmailAddress?: string(name='alertEmailAddress', example='foo_bar@spark.alert.invalid.com'),
  description?: string(name='description', description='This parameter is required.', example='ods batch workflow'),
  executionType?: string(name='executionType', description='This parameter is required.', example='PARALLEL'),
  name?: string(name='name', description='This parameter is required.', example='ods_batch_workflow'),
  productNamespace?: string(name='productNamespace', description='This parameter is required.', example='SS'),
  publish?: boolean(name='publish', example='true'),
  regionId?: string(name='regionId', example='cn-hangzhou'),
  resourceQueue?: string(name='resourceQueue', example='root_queue'),
  retryTimes?: int32(name='retryTimes', example='1'),
  runAs?: string(name='runAs', example='113***************'),
  schedule?: {
    crontab?: string(name='crontab', example='0 0 0 * * ?'),
    endTime?: string(name='endTime', example='2025-12-23 16:13:27'),
    startTime?: string(name='startTime', example='2024-12-23 16:13:27'),
    timezoneId?: string(name='timezoneId', example='Asia/Shanghai'),
  }(name='schedule'),
  tags?: map[string]string(name='tags'),
  taskDefinitionJson?: [ 
    {
      alertEmailAddress?: string(name='alertEmailAddress', example='foo_bar@spark.alert.invalid.com'),
      code?: long(name='code', description='This parameter is required.', example='36************'),
      description?: string(name='description', example='ods transform task'),
      failAlertEnable?: boolean(name='failAlertEnable', example='false'),
      failRetryTimes?: int32(name='failRetryTimes', example='1'),
      name?: string(name='name', description='This parameter is required.', example='ods_transform_task'),
      startAlertEnable?: boolean(name='startAlertEnable', example='false'),
      tags?: map[string]string(name='tags'),
      taskParams?: {
        displaySparkVersion?: string(name='displaySparkVersion', example='esr-4.0.0 (Spark 3.5.2, Scala 2.12)'),
        environmentId?: string(name='environmentId', example='env-crhq2h5lhtgju93buhkg'),
        fusion?: boolean(name='fusion', example='false'),
        resourceQueueId?: string(name='resourceQueueId', description='This parameter is required.', example='root_queue'),
        sparkConf?: [ 
          {
            key?: string(name='key', example='spark.dynamicAllocation.enabled'),
            value?: string(name='value', example='true'),
          }
        ](name='sparkConf'),
        sparkDriverCores?: int32(name='sparkDriverCores', example='1'),
        sparkDriverMemory?: long(name='sparkDriverMemory', example='4g'),
        sparkExecutorCores?: int32(name='sparkExecutorCores', example='1'),
        sparkExecutorMemory?: long(name='sparkExecutorMemory', example='4g'),
        sparkLogLevel?: string(name='sparkLogLevel', example='INFO'),
        sparkLogPath?: string(name='sparkLogPath'),
        sparkVersion?: string(name='sparkVersion', example='esr-4.0.0 (Spark 3.5.2, Scala 2.12)'),
        taskBizId?: string(name='taskBizId', description='This parameter is required.', example='TSK-d87******************'),
        type?: string(name='type', example='VPC'),
        workspaceBizId?: string(name='workspaceBizId', description='This parameter is required.', example='w-d8********'),
      }(name='taskParams', description='This parameter is required.'),
      taskType?: string(name='taskType', description='This parameter is required.', example='MigrateData'),
      timeout?: int32(name='timeout', example='1200'),
    }
  ](name='taskDefinitionJson', description='This parameter is required.'),
  taskParallelism?: int32(name='taskParallelism', example='1'),
  taskRelationJson?: [ 
    {
      name?: string(name='name', description='This parameter is required.', example='ods batch workflow'),
      postTaskCode?: long(name='postTaskCode', description='This parameter is required.', example='28************'),
      postTaskVersion?: int32(name='postTaskVersion', description='This parameter is required.', example='1'),
      preTaskCode?: long(name='preTaskCode', description='This parameter is required.', example='16************'),
      preTaskVersion?: int32(name='preTaskVersion', description='This parameter is required.', example='1'),
    }
  ](name='taskRelationJson', description='This parameter is required.'),
  timeout?: int32(name='timeout', example='60'),
}

model CreateProcessDefinitionWithScheduleShrinkRequest {
  alertEmailAddress?: string(name='alertEmailAddress', example='foo_bar@spark.alert.invalid.com'),
  description?: string(name='description', description='This parameter is required.', example='ods batch workflow'),
  executionType?: string(name='executionType', description='This parameter is required.', example='PARALLEL'),
  name?: string(name='name', description='This parameter is required.', example='ods_batch_workflow'),
  productNamespace?: string(name='productNamespace', description='This parameter is required.', example='SS'),
  publish?: boolean(name='publish', example='true'),
  regionId?: string(name='regionId', example='cn-hangzhou'),
  resourceQueue?: string(name='resourceQueue', example='root_queue'),
  retryTimes?: int32(name='retryTimes', example='1'),
  runAs?: string(name='runAs', example='113***************'),
  scheduleShrink?: string(name='schedule'),
  tagsShrink?: string(name='tags'),
  taskDefinitionJsonShrink?: string(name='taskDefinitionJson', description='This parameter is required.'),
  taskParallelism?: int32(name='taskParallelism', example='1'),
  taskRelationJsonShrink?: string(name='taskRelationJson', description='This parameter is required.'),
  timeout?: int32(name='timeout', example='60'),
}

model CreateProcessDefinitionWithScheduleResponseBody = {
  code?: int32(name='code', example='1400009'),
  data?: {
    code?: long(name='code', example='160************'),
    id?: int32(name='id', example='12342'),
  }(name='data'),
  failed?: string(name='failed', example='false'),
  httpStatusCode?: int32(name='httpStatusCode', example='200'),
  msg?: string(name='msg', example='No permission for resource action'),
  requestId?: string(name='requestId', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  success?: string(name='success', example='true'),
}

model CreateProcessDefinitionWithScheduleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateProcessDefinitionWithScheduleResponseBody(name='body'),
}

/**
 * @summary 创建工作流定义
 *
 * @param tmpReq CreateProcessDefinitionWithScheduleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProcessDefinitionWithScheduleResponse
 */
async function createProcessDefinitionWithScheduleWithOptions(bizId: string, tmpReq: CreateProcessDefinitionWithScheduleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProcessDefinitionWithScheduleResponse {
  Util.validateModel(tmpReq);
  var request = new CreateProcessDefinitionWithScheduleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.schedule)) {
    request.scheduleShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.schedule, 'schedule', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'tags', 'json');
  }
  if (!Util.isUnset(tmpReq.taskDefinitionJson)) {
    request.taskDefinitionJsonShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.taskDefinitionJson, 'taskDefinitionJson', 'json');
  }
  if (!Util.isUnset(tmpReq.taskRelationJson)) {
    request.taskRelationJsonShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.taskRelationJson, 'taskRelationJson', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.alertEmailAddress)) {
    query['alertEmailAddress'] = request.alertEmailAddress;
  }
  if (!Util.isUnset(request.description)) {
    query['description'] = request.description;
  }
  if (!Util.isUnset(request.executionType)) {
    query['executionType'] = request.executionType;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.productNamespace)) {
    query['productNamespace'] = request.productNamespace;
  }
  if (!Util.isUnset(request.publish)) {
    query['publish'] = request.publish;
  }
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceQueue)) {
    query['resourceQueue'] = request.resourceQueue;
  }
  if (!Util.isUnset(request.retryTimes)) {
    query['retryTimes'] = request.retryTimes;
  }
  if (!Util.isUnset(request.runAs)) {
    query['runAs'] = request.runAs;
  }
  if (!Util.isUnset(request.scheduleShrink)) {
    query['schedule'] = request.scheduleShrink;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.taskDefinitionJsonShrink)) {
    query['taskDefinitionJson'] = request.taskDefinitionJsonShrink;
  }
  if (!Util.isUnset(request.taskParallelism)) {
    query['taskParallelism'] = request.taskParallelism;
  }
  if (!Util.isUnset(request.taskRelationJsonShrink)) {
    query['taskRelationJson'] = request.taskRelationJsonShrink;
  }
  if (!Util.isUnset(request.timeout)) {
    query['timeout'] = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateProcessDefinitionWithSchedule',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/dolphinscheduler/projects/${OpenApiUtil.getEncodeParam(bizId)}/process-definition`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建工作流定义
 *
 * @param request CreateProcessDefinitionWithScheduleRequest
 * @return CreateProcessDefinitionWithScheduleResponse
 */
async function createProcessDefinitionWithSchedule(bizId: string, request: CreateProcessDefinitionWithScheduleRequest): CreateProcessDefinitionWithScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProcessDefinitionWithScheduleWithOptions(bizId, request, headers, runtime);
}

model CreateSqlStatementRequest {
  codeContent?: string(name='codeContent', description='The SQL code. You can specify one or more SQL statements.', example='SHOW TABLES'),
  defaultCatalog?: string(name='defaultCatalog', description='The default Data Lake Formation (DLF) catalog ID.', example='default_catalog'),
  defaultDatabase?: string(name='defaultDatabase', description='The name of the default database.', example='default'),
  limit?: int32(name='limit', description='The maximum number of entries to return. Valid values: 1 to 10000.', example='1000'),
  sqlComputeId?: string(name='sqlComputeId', description='The SQL session ID. You can create an SQL session in the workspace created in EMR Serverless Spark.', example='sc-dfahdfjafhajd****'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
}

model CreateSqlStatementResponseBody = {
  data?: {
    statementId?: string(name='statementId', description='The ID of the SQL query.', example='st-1231dfafadfa***'),
  }(name='data', description='The data returned.'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model CreateSqlStatementResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSqlStatementResponseBody(name='body'),
}

/**
 * @summary Creates an SQL query task.
 *
 * @param request CreateSqlStatementRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSqlStatementResponse
 */
async function createSqlStatementWithOptions(workspaceId: string, request: CreateSqlStatementRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSqlStatementResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.codeContent)) {
    body['codeContent'] = request.codeContent;
  }
  if (!Util.isUnset(request.defaultCatalog)) {
    body['defaultCatalog'] = request.defaultCatalog;
  }
  if (!Util.isUnset(request.defaultDatabase)) {
    body['defaultDatabase'] = request.defaultDatabase;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.sqlComputeId)) {
    body['sqlComputeId'] = request.sqlComputeId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSqlStatement',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/interactive/v1/workspace/${OpenApiUtil.getEncodeParam(workspaceId)}/statement`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an SQL query task.
 *
 * @param request CreateSqlStatementRequest
 * @return CreateSqlStatementResponse
 */
async function createSqlStatement(workspaceId: string, request: CreateSqlStatementRequest): CreateSqlStatementResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSqlStatementWithOptions(workspaceId, request, headers, runtime);
}

model GetJobRunRequest {
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
}

model GetJobRunResponseBody = {
  jobRun?: {
    codeType?: string(name='codeType', description='The code type of the job. Valid values:

*   SQL
*   JAR
*   PYTHON', example='SQL'),
    configurationOverrides?: {
      configurations?: [
        Configuration
      ](name='configurations', description='The configurations.'),
    }(name='configurationOverrides', description='The job configurations of Spark.'),
    displayReleaseVersion?: string(name='displayReleaseVersion'),
    endTime?: long(name='endTime', description='The end time of the job.', example='1684119314000'),
    environmentId?: string(name='environmentId'),
    executionTimeoutSeconds?: int32(name='executionTimeoutSeconds', description='The timeout period of the job.', example='3600'),
    fusion?: boolean(name='fusion'),
    jobDriver?: JobDriver(name='jobDriver', description='The information about Spark Driver.'),
    jobRunId?: string(name='jobRunId', description='The job ID.', example='jr-231231'),
    log?: RunLog(name='log', description='The path where the operational logs are stored.'),
    name?: string(name='name', description='The job name.', example='jobName'),
    releaseVersion?: string(name='releaseVersion', description='The version of the Spark engine on which the job runs.', example='esr-3.3.1'),
    resourceOwnerId?: string(name='resourceOwnerId', description='The ID of the user who created the job.', example='1509789347011222'),
    resourceQueueId?: string(name='resourceQueueId', description='The name of the queue on which the job runs.', example='root_queue'),
    state?: string(name='state', description='The job state.', example='Running'),
    stateChangeReason?: {
      code?: string(name='code', description='The error code.', example='ERR-100000'),
      message?: string(name='message', description='The error message.', example='connection refused'),
    }(name='stateChangeReason', description='The reason of the job status change.'),
    submitTime?: long(name='submitTime', description='The time when the job was submitted.', example='1684119314000'),
    tags?: [
      Tag
    ](name='tags', description='The tags.'),
    webUI?: string(name='webUI', description='The web UI of the job.', example='http://spark-ui'),
    workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-1234abcd'),
  }(name='jobRun', description='The details of the job.'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model GetJobRunResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetJobRunResponseBody(name='body'),
}

/**
 * @summary Obtain the job details.
 *
 * @param request GetJobRunRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetJobRunResponse
 */
async function getJobRunWithOptions(workspaceId: string, jobRunId: string, request: GetJobRunRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetJobRunResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJobRun',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${OpenApiUtil.getEncodeParam(workspaceId)}/jobRuns/${OpenApiUtil.getEncodeParam(jobRunId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtain the job details.
 *
 * @param request GetJobRunRequest
 * @return GetJobRunResponse
 */
async function getJobRun(workspaceId: string, jobRunId: string, request: GetJobRunRequest): GetJobRunResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getJobRunWithOptions(workspaceId, jobRunId, request, headers, runtime);
}

model GetSessionClusterRequest {
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
}

model GetSessionClusterResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  sessionCluster?: {
    applicationConfigs?: [ 
      {
        configFileName?: string(name='configFileName', description='The name of the configuration file.', example='spark-defaults.conf'),
        configItemKey?: string(name='configItemKey', description='The key of the configuration.', example='spark.app.name'),
        configItemValue?: string(name='configItemValue', description='The configuration value.', example='test'),
      }
    ](name='applicationConfigs', description='The Spark configurations.'),
    autoStartConfiguration?: {
      enable?: boolean(name='enable', description='Indicates whether automatic startup is enabled.', example='false'),
    }(name='autoStartConfiguration', description='The automatic startup configurations.'),
    autoStopConfiguration?: {
      enable?: boolean(name='enable', description='Indicates whether automatic termination is enabled.', example='false'),
      idleTimeoutMinutes?: int32(name='idleTimeoutMinutes', description='The idle timeout period. The session is automatically terminated when the idle timeout period is exceeded.', example='60'),
    }(name='autoStopConfiguration', description='The automatic termination configurations.'),
    displayReleaseVersion?: string(name='displayReleaseVersion', description='The version of the Spark engine.', example='esr-2.2(Java Runtime)'),
    domain?: string(name='domain', description='The domain name to which the Spark UI of the session belongs.', example='your.domain.com'),
    domainInner?: string(name='domainInner', description='The internal endpoint.', example='emr-spark-gateway-cn-hangzhou-internal.data.aliyuncs.com'),
    draftId?: string(name='draftId', description='The ID of the job that is associated with the session.', example='TSK-xxxxxxxx'),
    envId?: string(name='envId', description='The environment ID.', example='env-cpv569tlhtgndjl86t40'),
    fusion?: boolean(name='fusion', description='Indicates whether the Fusion engine is used for acceleration.', example='false'),
    gmtCreate?: long(name='gmtCreate', description='The creation time.', example='2024-09-01 06:23:01'),
    kind?: string(name='kind', description='The type of the job. This parameter is required and cannot be modified after the deployment is created. Valid values:

*   SQLSCRIPT
*   JAR
*   PYTHON', example='SQL'),
    name?: string(name='name', description='The name of the session.', example='test'),
    queueName?: string(name='queueName', description='The queue name.', example='jobName'),
    releaseVersion?: string(name='releaseVersion', description='The version of E-MapReduce (EMR) Serverless Spark.', example='esr-2.2(Java Runtime)'),
    sessionClusterId?: string(name='sessionClusterId', description='The session ID.', example='1234abcd-12ab-34cd-56ef-1234567890ab'),
    startTime?: long(name='startTime', description='The start time.', example='2024-09-01 06:23:01'),
    state?: string(name='state', description='The job status.', example='Running'),
    stateChangeReason?: {
      code?: string(name='code', description='The status change code.', example='1000000'),
      message?: string(name='message', description='The status change message.', example='ok'),
    }(name='stateChangeReason', description='The reason of the job status change.'),
    userId?: string(name='userId', description='The user ID.', example='jr-231231'),
    userName?: string(name='userName', description='The name of the account that is used to create the session.', example='user1'),
    webUI?: string(name='webUI', description='The Spark UI of the session.', example='https://spark-ui/link'),
    workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-1234abcd'),
  }(name='sessionCluster', description='The session.'),
}

model GetSessionClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSessionClusterResponseBody(name='body'),
}

/**
 * @summary Queries a list of sessions.
 *
 * @param request GetSessionClusterRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSessionClusterResponse
 */
async function getSessionClusterWithOptions(workspaceId: string, sessionClusterId: string, request: GetSessionClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetSessionClusterResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSessionCluster',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${OpenApiUtil.getEncodeParam(workspaceId)}/sessionClusters/${OpenApiUtil.getEncodeParam(sessionClusterId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of sessions.
 *
 * @param request GetSessionClusterRequest
 * @return GetSessionClusterResponse
 */
async function getSessionCluster(workspaceId: string, sessionClusterId: string, request: GetSessionClusterRequest): GetSessionClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSessionClusterWithOptions(workspaceId, sessionClusterId, request, headers, runtime);
}

model GetSqlStatementRequest {
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
}

model GetSqlStatementResponseBody = {
  data?: {
    executionTime?: [ long ](name='executionTime', description='The list of time that is consumed by SQL queries.'),
    sqlErrorCode?: string(name='sqlErrorCode', description='The error code.', example='ERROR-102'),
    sqlErrorMessage?: string(name='sqlErrorMessage', description='The error message.', example='error message'),
    sqlOutputs?: [ 
      {
        rows?: string(name='rows', description='The queried data, which is a string in the JSON format.', example='[{\\\\"values\\\\":[\\\\"test_db\\\\",\\\\"test_table\\\\",false]}'),
        schema?: string(name='schema', description='The information about the schema, which is a string in the JSON format.', example='{\\\\"type\\\\":\\\\"struct\\\\",\\\\"fields\\\\":[{\\\\"name\\\\":\\\\"namespace\\\\",\\\\"type\\\\":\\\\"string\\\\",\\\\"nullable\\\\":false,\\\\"metadata\\\\":{}},{\\\\"name\\\\":\\\\"tableName\\\\",\\\\"type\\\\":\\\\"string\\\\",\\\\"nullable\\\\":false,\\\\"metadata\\\\":{}},{\\\\"name\\\\":\\\\"isTemporary\\\\",\\\\"type\\\\":\\\\"boolean\\\\",\\\\"nullable\\\\":false,\\\\"metadata\\\\":{}}]}'),
      }
    ](name='sqlOutputs', description='The query results.'),
    state?: string(name='state', description='The query status.

Valid values:

*   running
*   available
*   cancelled
*   error
*   cancelling', example='running'),
    statementId?: string(name='statementId', description='The query ID.', example='st-1231311abadfaa'),
  }(name='data', description='The response parameters.'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model GetSqlStatementResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSqlStatementResponseBody(name='body'),
}

/**
 * @summary Queries the status of an SQL query task.
 *
 * @param request GetSqlStatementRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSqlStatementResponse
 */
async function getSqlStatementWithOptions(workspaceId: string, statementId: string, request: GetSqlStatementRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetSqlStatementResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSqlStatement',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/interactive/v1/workspace/${OpenApiUtil.getEncodeParam(workspaceId)}/statement/${OpenApiUtil.getEncodeParam(statementId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the status of an SQL query task.
 *
 * @param request GetSqlStatementRequest
 * @return GetSqlStatementResponse
 */
async function getSqlStatement(workspaceId: string, statementId: string, request: GetSqlStatementRequest): GetSqlStatementResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSqlStatementWithOptions(workspaceId, statementId, request, headers, runtime);
}

model GetTemplateRequest {
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
  templateType?: string(name='templateType', description='The template type.

*   TASK
*   SESSION', example='TASK'),
}

model GetTemplateResponseBody = {
  data?: Template(name='data', description='The data returned.'),
  errorCode?: string(name='errorCode', description='*   If the value of success was false, an error code was returned.
*   If the value of success was true, a null value was returned.', example='040003'),
  errorMessage?: string(name='errorMessage', description='*   If the value of success was false, an error message was returned.
*   If the value of success was true, a null value was returned.', example='InvalidUser.NotFound'),
  httpStatusCode?: string(name='httpStatusCode', description='The HTTP status code.', example='200'),
  requestId?: string(name='requestId', description='The request ID.', example='484D9DDA-300D-525E-AF7A-0CCCA5C64A7A'),
  success?: boolean(name='success', description='Indicates whether the request was successful.', example='True'),
}

model GetTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTemplateResponseBody(name='body'),
}

/**
 * @summary Queries task templates.
 *
 * @param request GetTemplateRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTemplateResponse
 */
async function getTemplateWithOptions(workspaceBizId: string, request: GetTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTemplateResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }
  if (!Util.isUnset(request.templateType)) {
    query['templateType'] = request.templateType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTemplate',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/interactive/v1/workspace/${OpenApiUtil.getEncodeParam(workspaceBizId)}/template`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries task templates.
 *
 * @param request GetTemplateRequest
 * @return GetTemplateResponse
 */
async function getTemplate(workspaceBizId: string, request: GetTemplateRequest): GetTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTemplateWithOptions(workspaceBizId, request, headers, runtime);
}

model GrantRoleToUsersRequest {
  roleArn?: string(name='roleArn', description='The Alibaba Cloud Resource Name (ARN) of the RAM role.', example='acs:emr::w-975bcfda9625****:role/Owner'),
  userArns?: [ string ](name='userArns', description='The user ARNs.'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
}

model GrantRoleToUsersResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model GrantRoleToUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GrantRoleToUsersResponseBody(name='body'),
}

/**
 * @summary Assigns a specified role to users.
 *
 * @param request GrantRoleToUsersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantRoleToUsersResponse
 */
async function grantRoleToUsersWithOptions(request: GrantRoleToUsersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GrantRoleToUsersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.roleArn)) {
    body['roleArn'] = request.roleArn;
  }
  if (!Util.isUnset(request.userArns)) {
    body['userArns'] = request.userArns;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GrantRoleToUsers',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/v1/auth/roles/grant`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Assigns a specified role to users.
 *
 * @param request GrantRoleToUsersRequest
 * @return GrantRoleToUsersResponse
 */
async function grantRoleToUsers(request: GrantRoleToUsersRequest): GrantRoleToUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return grantRoleToUsersWithOptions(request, headers, runtime);
}

model ListJobRunsRequest {
  creator?: string(name='creator', description='The ID of the user who created the job.', example='1509789347011222'),
  endTime?: {
    endTime?: long(name='endTime', description='The end of the end time range.', example='1710432000000'),
    startTime?: long(name='startTime', description='The beginning of the end time range.', example='1709740800000'),
  }(name='endTime', description='The range of end time.'),
  jobRunDeploymentId?: string(name='jobRunDeploymentId'),
  jobRunId?: string(name='jobRunId', description='The job ID.', example='j-xxx'),
  maxResults?: int32(name='maxResults', description='The maximum number of entries to return.', example='20'),
  name?: string(name='name', description='The job name.', example='emr-spark-demo-job'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the request to retrieve a new page of results.', example='DD6B1B2A-5837-5237-ABE4-FF0C89568980'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
  resourceQueueId?: string(name='resourceQueueId', description='The name of the resource queue on which the Spark jobs run.', example='dev_queue'),
  startTime?: {
    endTime?: long(name='endTime', description='The end of the start time range.', example='1710432000000'),
    startTime?: long(name='startTime', description='The beginning of the start time range.', example='1709740800000'),
  }(name='startTime', description='The range of start time.'),
  states?: [ string ](name='states', description='The job states.', example='["Running","Submitted"]'),
  tags?: [ 
    {
      key?: string(name='key', description='The key of tag N.', example='tag_key'),
      value?: string(name='value', description='The value of tag N.', example='value'),
    }
  ](name='tags', description='The tags of the job.'),
}

model ListJobRunsShrinkRequest {
  creator?: string(name='creator', description='The ID of the user who created the job.', example='1509789347011222'),
  endTimeShrink?: string(name='endTime', description='The range of end time.'),
  jobRunDeploymentId?: string(name='jobRunDeploymentId'),
  jobRunId?: string(name='jobRunId', description='The job ID.', example='j-xxx'),
  maxResults?: int32(name='maxResults', description='The maximum number of entries to return.', example='20'),
  name?: string(name='name', description='The job name.', example='emr-spark-demo-job'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the request to retrieve a new page of results.', example='DD6B1B2A-5837-5237-ABE4-FF0C89568980'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
  resourceQueueId?: string(name='resourceQueueId', description='The name of the resource queue on which the Spark jobs run.', example='dev_queue'),
  startTimeShrink?: string(name='startTime', description='The range of start time.'),
  statesShrink?: string(name='states', description='The job states.', example='["Running","Submitted"]'),
  tagsShrink?: string(name='tags', description='The tags of the job.'),
}

model ListJobRunsResponseBody = {
  jobRuns?: [ 
    {
      codeType?: string(name='codeType', description='The code type of the job. Valid values:

SQL

JAR

PYTHON', example='SQL'),
      configurationOverrides?: {
        configurations?: [
          Configuration
        ](name='configurations', description='The SparkConf objects.'),
      }(name='configurationOverrides', description='The advanced configurations of Spark.'),
      creator?: string(name='creator', description='The ID of the user who created the job.', example='1509789347011222'),
      cuHours?: long(name='cuHours', example='2.059'),
      displayReleaseVersion?: string(name='displayReleaseVersion', example='esr-3.0.0 (Spark 3.4.3, Scala 2.12)'),
      endTime?: long(name='endTime', description='The end time of the job.', example='1684119314000'),
      executionTimeoutSeconds?: int32(name='executionTimeoutSeconds', description='The timeout period of the job.', example='3600'),
      fusion?: boolean(name='fusion', example='true'),
      jobDriver?: JobDriver(name='jobDriver', description='The information about Spark Driver.'),
      jobRunId?: string(name='jobRunId', description='The job ID.', example='jr-231231'),
      log?: RunLog(name='log', description='The path where the operational logs are stored.'),
      mbSeconds?: long(name='mbSeconds', example='33030784'),
      name?: string(name='name', description='The job name.', example='jobName'),
      releaseVersion?: string(name='releaseVersion', description='The version of Spark on which the jobs run.', example='esr-native-3.4.0'),
      state?: string(name='state', description='The job state.', example='Running'),
      stateChangeReason?: {
        code?: string(name='code', description='The error code.', example='0'),
        message?: string(name='message', description='The error message.', example='success'),
      }(name='stateChangeReason', description='The reason of the job status change.'),
      submitTime?: long(name='submitTime', description='The time when the job was submitted.', example='1684119314000'),
      tags?: [
        Tag
      ](name='tags', description='The tags.'),
      vcoreSeconds?: long(name='vcoreSeconds', example='8236'),
      webUI?: string(name='webUI', description='The web UI of the job.', example='http://spark-ui'),
      workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-1234abcd'),
    }
  ](name='jobRuns', description='The Spark jobs.'),
  maxResults?: int32(name='maxResults', description='The maximum number of entries returned.', example='20'),
  nextToken?: string(name='nextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='DD6B1B2A-5837-5237-ABE4-FF0C89568980'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='200'),
}

model ListJobRunsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListJobRunsResponseBody(name='body'),
}

/**
 * @summary Queries a list of Spark jobs.
 *
 * @param tmpReq ListJobRunsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListJobRunsResponse
 */
async function listJobRunsWithOptions(workspaceId: string, tmpReq: ListJobRunsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListJobRunsResponse {
  Util.validateModel(tmpReq);
  var request = new ListJobRunsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.endTime)) {
    request.endTimeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.endTime, 'endTime', 'json');
  }
  if (!Util.isUnset(tmpReq.startTime)) {
    request.startTimeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.startTime, 'startTime', 'json');
  }
  if (!Util.isUnset(tmpReq.states)) {
    request.statesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.states, 'states', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'tags', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.creator)) {
    query['creator'] = request.creator;
  }
  if (!Util.isUnset(request.endTimeShrink)) {
    query['endTime'] = request.endTimeShrink;
  }
  if (!Util.isUnset(request.jobRunDeploymentId)) {
    query['jobRunDeploymentId'] = request.jobRunDeploymentId;
  }
  if (!Util.isUnset(request.jobRunId)) {
    query['jobRunId'] = request.jobRunId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceQueueId)) {
    query['resourceQueueId'] = request.resourceQueueId;
  }
  if (!Util.isUnset(request.startTimeShrink)) {
    query['startTime'] = request.startTimeShrink;
  }
  if (!Util.isUnset(request.statesShrink)) {
    query['states'] = request.statesShrink;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['tags'] = request.tagsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobRuns',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${OpenApiUtil.getEncodeParam(workspaceId)}/jobRuns`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of Spark jobs.
 *
 * @param request ListJobRunsRequest
 * @return ListJobRunsResponse
 */
async function listJobRuns(workspaceId: string, request: ListJobRunsRequest): ListJobRunsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listJobRunsWithOptions(workspaceId, request, headers, runtime);
}

model ListLogContentsRequest {
  fileName?: string(name='fileName'),
  length?: int32(name='length', example='9999'),
  offset?: int32(name='offset', example='0'),
  regionId?: string(name='regionId', example='cn-hangzhou'),
}

model ListLogContentsResponseBody = {
  listLogContent?: {
    contents?: [ 
      {
        lineContent?: string(name='LineContent', example='spark pi is 3.14\\\\n'),
      }
    ](name='contents'),
    totalLength?: long(name='totalLength', example='10'),
  }(name='listLogContent'),
  requestId?: string(name='requestId', description='请求ID。', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model ListLogContentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLogContentsResponseBody(name='body'),
}

/**
 * @summary Obtains the log content.
 *
 * @param request ListLogContentsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListLogContentsResponse
 */
async function listLogContentsWithOptions(workspaceId: string, request: ListLogContentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogContentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.fileName)) {
    query['fileName'] = request.fileName;
  }
  if (!Util.isUnset(request.length)) {
    query['length'] = request.length;
  }
  if (!Util.isUnset(request.offset)) {
    query['offset'] = request.offset;
  }
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogContents',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${OpenApiUtil.getEncodeParam(workspaceId)}/action/listLogContents`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the log content.
 *
 * @param request ListLogContentsRequest
 * @return ListLogContentsResponse
 */
async function listLogContents(workspaceId: string, request: ListLogContentsRequest): ListLogContentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogContentsWithOptions(workspaceId, request, headers, runtime);
}

model ListReleaseVersionsRequest {
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
  releaseType?: string(name='releaseType', description='The type of the version.

Valid values:

*   stable
*   Beta', example='stable'),
  releaseVersion?: string(name='releaseVersion', description='The version of EMR Serverless Spark.', example='esr-2.1 (Spark 3.3.1, Scala 2.12, Java Runtime)'),
  releaseVersionStatus?: string(name='releaseVersionStatus', description='The status of the version.

Valid values:

*   ONLINE
*   OFFLINE', example='ONLINE'),
  workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-d2d82aa09155****'),
}

model ListReleaseVersionsResponseBody = {
  maxResults?: int32(name='maxResults', description='The maximum number of entries returned.', example='20'),
  nextToken?: string(name='nextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='1'),
  releaseVersions?: [ 
    {
      communityVersion?: string(name='communityVersion', description='The version number of open source Spark.', example='Spark 3.3.1'),
      cpuArchitectures?: [ string ](name='cpuArchitectures', description='The CPU architectures.'),
      displayReleaseVersion?: string(name='displayReleaseVersion', description='The version number.', example='esr-2.1 (Spark 3.3.1, Scala 2.12)'),
      fusion?: boolean(name='fusion', description='Indicates whether the Fusion engine is used for acceleration.', example='true'),
      gmtCreate?: long(name='gmtCreate', description='The creation time.', example='1716215854101'),
      iaasType?: string(name='iaasType', description='The type of the Infrastructure as a Service (IaaS) layer.', example='ASI'),
      releaseVersion?: string(name='releaseVersion', description='The version number.', example='esr-2.1 (Spark 3.3.1, Scala 2.12, Java Runtime)'),
      scalaVersion?: string(name='scalaVersion', description='The version of Scala.', example='2.12'),
      state?: string(name='state', description='The status of the version.', example='ONLINE'),
      type?: string(name='type', description='The type of the version.', example='stable'),
    }
  ](name='releaseVersions', description='The versions.'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='200'),
}

model ListReleaseVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListReleaseVersionsResponseBody(name='body'),
}

/**
 * @summary Queries the list of published versions of E-MapReduce (EMR) Serverless Spark.
 *
 * @param request ListReleaseVersionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListReleaseVersionsResponse
 */
async function listReleaseVersionsWithOptions(request: ListReleaseVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListReleaseVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }
  if (!Util.isUnset(request.releaseType)) {
    query['releaseType'] = request.releaseType;
  }
  if (!Util.isUnset(request.releaseVersion)) {
    query['releaseVersion'] = request.releaseVersion;
  }
  if (!Util.isUnset(request.releaseVersionStatus)) {
    query['releaseVersionStatus'] = request.releaseVersionStatus;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['workspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListReleaseVersions',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/v1/releaseVersions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the list of published versions of E-MapReduce (EMR) Serverless Spark.
 *
 * @param request ListReleaseVersionsRequest
 * @return ListReleaseVersionsResponse
 */
async function listReleaseVersions(request: ListReleaseVersionsRequest): ListReleaseVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listReleaseVersionsWithOptions(request, headers, runtime);
}

model ListSessionClustersRequest {
  kind?: string(name='kind', description='The session type.

Valid values:

*   NOTEBOOK
*   THRIFT
*   SQL', example='SQL'),
  maxResults?: int32(name='maxResults', description='The maximum number of entries to return.', example='20'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the request to retrieve a new page of results.', example='DD6B1B2A-5837-5237-ABE4-FF0C89568980'),
  queueName?: string(name='queueName', description='The name of the queue.', example='root'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
  sessionClusterId?: string(name='sessionClusterId', description='The name of the job.', example='emr-spark-demo-job'),
}

model ListSessionClustersResponseBody = {
  maxResults?: int32(name='maxResults', description='The maximum number of entries returned.', example='20'),
  nextToken?: string(name='nextToken', description='A pagination token.', example='DD6B1B2A-5837-5237-ABE4-FF0C89568980'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  sessionClusters?: [ 
    {
      applicationConfigs?: [ 
        {
          configFileName?: string(name='configFileName', description='The name of the configuration file.', example='spark-default.conf'),
          configItemKey?: string(name='configItemKey', description='The key of the configuration.', example='spark.app.name'),
          configItemValue?: string(name='configItemValue', description='The configuration value.', example='test_application'),
        }
      ](name='applicationConfigs', description='The session configurations, which are equivalent to the configurations of the Spark job.'),
      autoStartConfiguration?: {
        enable?: boolean(name='enable', description='Indicates whether automatic startup is enabled.', example='true'),
      }(name='autoStartConfiguration', description='The automatic startup configurations.'),
      autoStopConfiguration?: {
        enable?: boolean(name='enable', description='Indicates whether automatic termination is enabled.', example='false'),
        idleTimeoutMinutes?: int32(name='idleTimeoutMinutes', description='The idle timeout period. The session is automatically terminated when the idle timeout period is exceeded.', example='45'),
      }(name='autoStopConfiguration', description='The configurations of automatic termination.'),
      displayReleaseVersion?: string(name='displayReleaseVersion', description='The version of the Spark engine.', example='esr-4.0.0 (Spark 3.5.2, Scala 2.12)'),
      domain?: string(name='domain', description='The public endpoint of the Thrift server.', example='emr-spark-gateway-cn-hangzhou.data.aliyun.com'),
      domainInner?: string(name='domainInner', description='The internal endpoint of the Thrift server.', example='emr-spark-gateway-cn-hangzhou-internal.data.aliyuncs.com'),
      draftId?: string(name='draftId', description='The ID of the job that is associated with the session.', example='TSK-xxxxxxxxx'),
      fusion?: boolean(name='fusion', description='Indicates whether the Fusion engine is used for acceleration.', example='false'),
      gmtCreate?: long(name='gmtCreate', description='The creation time.', example='1732267598000'),
      kind?: string(name='kind', description='The session type.

Valid values:

*   NOTEBOOK
*   THRIFT
*   SQL', example='SQL'),
      name?: string(name='name', description='The name of the session.', example='adhoc_query'),
      queueName?: string(name='queueName', description='The name of the queue that is used to run the session.', example='dev_queue'),
      releaseVersion?: string(name='releaseVersion', description='The version of EMR Serverless Spark.', example='esr-2.1'),
      sessionClusterId?: string(name='sessionClusterId', description='The session ID.', example='sc-123131'),
      startTime?: long(name='startTime', description='The start time.', example='1732267598000'),
      state?: string(name='state', description='The status of the session.

*   Starting
*   Running
*   Stopping
*   Stopped
*   Error', example='Running'),
      stateChangeReason?: {
        code?: string(name='code', description='The status change code.', example='200'),
        message?: string(name='message', description='The status change message.', example='ok'),
      }(name='stateChangeReason', description='The details of the most recent status change of the session.'),
      userId?: string(name='userId', description='The user ID.', example='123131'),
      userName?: string(name='userName', description='The username.', example='test_user'),
      webUI?: string(name='webUI', description='The Spark UI of the session.', example='http://spark-ui-xxxx'),
      workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-1234abcd'),
    }
  ](name='sessionClusters', description='The sessions.'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='200'),
}

model ListSessionClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSessionClustersResponseBody(name='body'),
}

/**
 * @summary Queries the list of sessions.
 *
 * @param request ListSessionClustersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSessionClustersResponse
 */
async function listSessionClustersWithOptions(workspaceId: string, request: ListSessionClustersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSessionClustersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.kind)) {
    query['kind'] = request.kind;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.queueName)) {
    query['queueName'] = request.queueName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionClusterId)) {
    query['sessionClusterId'] = request.sessionClusterId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSessionClusters',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${OpenApiUtil.getEncodeParam(workspaceId)}/sessionClusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the list of sessions.
 *
 * @param request ListSessionClustersRequest
 * @return ListSessionClustersResponse
 */
async function listSessionClusters(workspaceId: string, request: ListSessionClustersRequest): ListSessionClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSessionClustersWithOptions(workspaceId, request, headers, runtime);
}

model ListWorkspaceQueuesRequest {
  environment?: string(name='environment', description='The environment type.

Valid values:

*   dev
*   production', example='production'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
}

model ListWorkspaceQueuesResponseBody = {
  maxResults?: int32(name='maxResults', description='The maximum number of entries returned.', example='20'),
  nextToken?: string(name='nextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='1'),
  queues?: [ 
    {
      allowActions?: [ 
        {
          actionArn?: string(name='actionArn', description='The Alibaba Cloud Resource Name (ARN) of a behavior.', example='acs:emr::workspaceId:action/create_queue'),
          actionName?: string(name='actionName', description='The name of the permission.', example='view'),
          dependencies?: [ string ](name='dependencies', description='The dependencies of the operation.', example='["view"]'),
          description?: string(name='description', description='The description of the operation.', example='文件目录遍历、文件浏览'),
          displayName?: string(name='displayName', description='The display name of the permission.', example='文件目录遍历、文件浏览'),
        }
      ](name='allowActions', description='The operations allowed for the queue.'),
      creator?: string(name='creator', description='The ID of the user who created the queue.', example='237109'),
      environments?: [ string ](name='environments', description='The environment types of the queue.'),
      maxResource?: string(name='maxResource', description='The maximum capacity of resources that can be used in the queue.', example='{"cpu": "2","memory": "2Gi"}'),
      minResource?: string(name='minResource', description='The minimum capacity of resources that can be used in the queue.', example='{"cpu": "2","memory": "2Gi"}'),
      properties?: string(name='properties', description='The queue label.', example='dev_queue'),
      queueName?: string(name='queueName', description='The name of the queue.', example='dev_queue'),
      queueScope?: string(name='queueScope', description='The queue architecture.', example='{"arch": "x86"}'),
      queueStatus?: string(name='queueStatus', description='The status of the queue.', example='RUNNING'),
      queueType?: string(name='queueType', description='The queue type.', example='instance, instanceChildren'),
      regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
      usedResource?: string(name='usedResource', description='The capacity of resources that are used in the queue.', example='{"cpu": "2","memory": "2Gi"}'),
      workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-1234abcd'),
    }
  ](name='queues', description='The list of queues.'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='200'),
}

model ListWorkspaceQueuesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWorkspaceQueuesResponseBody(name='body'),
}

/**
 * @summary Queries the list of queues in a Spark workspace.
 *
 * @param request ListWorkspaceQueuesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListWorkspaceQueuesResponse
 */
async function listWorkspaceQueuesWithOptions(workspaceId: string, request: ListWorkspaceQueuesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListWorkspaceQueuesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.environment)) {
    query['environment'] = request.environment;
  }
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkspaceQueues',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${OpenApiUtil.getEncodeParam(workspaceId)}/queues`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the list of queues in a Spark workspace.
 *
 * @param request ListWorkspaceQueuesRequest
 * @return ListWorkspaceQueuesResponse
 */
async function listWorkspaceQueues(workspaceId: string, request: ListWorkspaceQueuesRequest): ListWorkspaceQueuesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listWorkspaceQueuesWithOptions(workspaceId, request, headers, runtime);
}

model ListWorkspacesRequest {
  maxResults?: int32(name='maxResults', description='The maximum number of entries to return.', example='20'),
  name?: string(name='name', description='Fuzzy match is supported.', example='test_workspace'),
  nextToken?: string(name='nextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='1'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
  state?: string(name='state', description='The workspace status.', example='running'),
}

model ListWorkspacesResponseBody = {
  maxResults?: int32(name='maxResults', description='The maximum number of entries returned.', example='20'),
  nextToken?: string(name='nextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='1'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  totalCount?: int32(name='totalCount', description='The total number of entries returned.', example='200'),
  workspaces?: [ 
    {
      autoRenew?: boolean(name='autoRenew', description='Indicates whether auto-renewal is enabled. This parameter is required only if the paymentType parameter is set to Subscription.', example='true'),
      autoRenewPeriod?: int32(name='autoRenewPeriod', description='The auto-renewal duration. This parameter is required only if the paymentType parameter is set to Subscription.', example='1'),
      autoRenewPeriodUnit?: string(name='autoRenewPeriodUnit', description='The unit of the auto-renewal duration. This parameter is required only if the paymentType parameter is set to Subscription.', example='YEAR, MONTH, WEEK, DAY, HOUR, MINUTE'),
      createTime?: long(name='createTime', description='The time when the workspace was created.', example='1684115879955'),
      dlfCatalogId?: string(name='dlfCatalogId', description='The information of the Data Lake Formation (DLF) catalog.', example='default'),
      dlfType?: string(name='dlfType'),
      duration?: int32(name='duration', description='The subscription period. This parameter is required only if the paymentType parameter is set to Subscription.', example='1'),
      endTime?: long(name='endTime', description='The time when the workspace was released.', example='1687103999999'),
      failReason?: string(name='failReason', description='The reason for the failure.', example='out of stock'),
      paymentDurationUnit?: string(name='paymentDurationUnit', description='The unit of the subscription duration. This parameter is required only if the paymentType parameter is set to Subscription.', example='YEAR, MONTH, WEEK, DAY, HOUR, MINUTE'),
      paymentStatus?: string(name='paymentStatus', description='The status of the payment.', example='PAID/UNPAID'),
      paymentType?: string(name='paymentType', description='The payment type.', example='PayAsYouGo or Subscription'),
      regionId?: string(name='regionId', description='The region ID.', example='cn-shanghai'),
      releaseType?: string(name='releaseType', description='The reason why the workspace is released.', example='SERVICE_RELEASE'),
      resourceSpec?: string(name='resourceSpec', description='The resource specifications.', example='100cu'),
      stateChangeReason?: {
        code?: string(name='code', description='The error code.', example='0'),
        message?: string(name='message', description='The error message.', example='Success'),
      }(name='stateChangeReason', description='The information about the workspace status change.'),
      storage?: string(name='storage', description='The Object Storage Service (OSS) path.', example='spark-result'),
      workspaceId?: string(name='workspaceId', description='The workspace ID.', example='w-******'),
      workspaceName?: string(name='workspaceName', description='The name of the workspace.', example='spark批作业空间-1'),
      workspaceStatus?: string(name='workspaceStatus', description='The workspace status.', example='STARTING,RUNNING,TERMINATED'),
    }
  ](name='workspaces', description='The workspaces.'),
}

model ListWorkspacesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWorkspacesResponseBody(name='body'),
}

/**
 * @summary Queries a list of workspaces.
 *
 * @param request ListWorkspacesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListWorkspacesResponse
 */
async function listWorkspacesWithOptions(request: ListWorkspacesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListWorkspacesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.maxResults)) {
    query['maxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }
  if (!Util.isUnset(request.state)) {
    query['state'] = request.state;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkspaces',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of workspaces.
 *
 * @param request ListWorkspacesRequest
 * @return ListWorkspacesResponse
 */
async function listWorkspaces(request: ListWorkspacesRequest): ListWorkspacesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listWorkspacesWithOptions(request, headers, runtime);
}

model StartJobRunRequest {
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request.', example='8e6aae2810c8f67229ca70bb31cd6028'),
  codeType?: string(name='codeType', description='The code type of the job. Valid values:

*   SQL
*   JAR
*   PYTHON', example='SQL'),
  configurationOverrides?: {
    configurations?: [ 
      {
        configFileName?: string(name='configFileName', description='The configuration file of SparkConf.', example='spark-default.conf'),
        configItemKey?: string(name='configItemKey', description='The key of SparkConf.', example='spark.app.name'),
        configItemValue?: string(name='configItemValue', description='The value of SparkConf.', example='test_app'),
      }
    ](name='configurations', description='The SparkConf objects.'),
  }(name='configurationOverrides', description='The advanced configurations of Spark.'),
  displayReleaseVersion?: string(name='displayReleaseVersion'),
  executionTimeoutSeconds?: int32(name='executionTimeoutSeconds', description='The timeout period of the job.', example='100'),
  fusion?: boolean(name='fusion'),
  jobDriver?: JobDriver(name='jobDriver', description='The information about Spark Driver.'),
  jobId?: string(name='jobId', description='The job ID.', example='jr-12345'),
  name?: string(name='name', description='The job name.', example='spark_job_name'),
  releaseVersion?: string(name='releaseVersion', description='The version number of Spark.', example='esr-3.3.1'),
  resourceQueueId?: string(name='resourceQueueId', description='The name of the resource queue on which the Spark job runs.', example='dev_queue'),
  tags?: [
    Tag
  ](name='tags', description='The tags.'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
}

model StartJobRunResponseBody = {
  jobRunId?: string(name='jobRunId', description='The job ID.', example='jr-54321'),
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model StartJobRunResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartJobRunResponseBody(name='body'),
}

/**
 * @summary Starts a Spark job.
 *
 * @param request StartJobRunRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartJobRunResponse
 */
async function startJobRunWithOptions(workspaceId: string, request: StartJobRunRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StartJobRunResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.codeType)) {
    body['codeType'] = request.codeType;
  }
  if (!Util.isUnset(request.configurationOverrides)) {
    body['configurationOverrides'] = request.configurationOverrides;
  }
  if (!Util.isUnset(request.displayReleaseVersion)) {
    body['displayReleaseVersion'] = request.displayReleaseVersion;
  }
  if (!Util.isUnset(request.executionTimeoutSeconds)) {
    body['executionTimeoutSeconds'] = request.executionTimeoutSeconds;
  }
  if (!Util.isUnset(request.fusion)) {
    body['fusion'] = request.fusion;
  }
  if (!Util.isUnset(request.jobDriver)) {
    body['jobDriver'] = request.jobDriver;
  }
  if (!Util.isUnset(request.jobId)) {
    body['jobId'] = request.jobId;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.releaseVersion)) {
    body['releaseVersion'] = request.releaseVersion;
  }
  if (!Util.isUnset(request.resourceQueueId)) {
    body['resourceQueueId'] = request.resourceQueueId;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartJobRun',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${OpenApiUtil.getEncodeParam(workspaceId)}/jobRuns`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Starts a Spark job.
 *
 * @param request StartJobRunRequest
 * @return StartJobRunResponse
 */
async function startJobRun(workspaceId: string, request: StartJobRunRequest): StartJobRunResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startJobRunWithOptions(workspaceId, request, headers, runtime);
}

model StartProcessInstanceRequest {
  isProd?: boolean(name='isProd', example='false'),
  processDefinitionCode?: long(name='processDefinitionCode', description='This parameter is required.', example='12***********'),
  productNamespace?: string(name='productNamespace', description='This parameter is required.', example='SS'),
  regionId?: string(name='regionId', example='cn-hangzhou'),
  runtimeQueue?: string(name='runtimeQueue', example='root_queue'),
  versionHashCode?: string(name='versionHashCode', example='dh*********'),
  versionNumber?: int32(name='versionNumber', example='1'),
}

model StartProcessInstanceResponseBody = {
  code?: int32(name='code', example='1400009'),
  data?: any(name='data', example='{\\\\"sessionBizId\\\\": \\\\"sc-dc85644dba1c8c63\\\\", \\\\"bizId\\\\": \\\\"st-aeed3b0d4f87418a9a9dcbd757477658\\\\", \\\\"gmtCreated\\\\": \\\\"Thu Sep 12 02:28:45 UTC 2024\\\\"}'),
  failed?: boolean(name='failed', example='false'),
  httpStatusCode?: int32(name='httpStatusCode', example='200'),
  msg?: string(name='msg', example='No permission for resource action'),
  requestId?: string(name='requestId', description='Id of the request', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  success?: boolean(name='success', example='true'),
}

model StartProcessInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartProcessInstanceResponseBody(name='body'),
}

/**
 * @summary 启动工作流实例
 *
 * @param request StartProcessInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartProcessInstanceResponse
 */
async function startProcessInstanceWithOptions(bizId: string, request: StartProcessInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StartProcessInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.isProd)) {
    query['isProd'] = request.isProd;
  }
  if (!Util.isUnset(request.processDefinitionCode)) {
    query['processDefinitionCode'] = request.processDefinitionCode;
  }
  if (!Util.isUnset(request.productNamespace)) {
    query['productNamespace'] = request.productNamespace;
  }
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }
  if (!Util.isUnset(request.runtimeQueue)) {
    query['runtimeQueue'] = request.runtimeQueue;
  }
  if (!Util.isUnset(request.versionHashCode)) {
    query['versionHashCode'] = request.versionHashCode;
  }
  if (!Util.isUnset(request.versionNumber)) {
    query['versionNumber'] = request.versionNumber;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartProcessInstance',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/dolphinscheduler/projects/${OpenApiUtil.getEncodeParam(bizId)}/executors/start-process-instance`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 启动工作流实例
 *
 * @param request StartProcessInstanceRequest
 * @return StartProcessInstanceResponse
 */
async function startProcessInstance(bizId: string, request: StartProcessInstanceRequest): StartProcessInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startProcessInstanceWithOptions(bizId, request, headers, runtime);
}

model StartSessionClusterRequest {
  queueName?: string(name='queueName', description='The queue name.', example='root_queue'),
  sessionClusterId?: string(name='sessionClusterId', description='The session ID.', example='sc-xxxxxxxxxxx'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
}

model StartSessionClusterResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  sessionClusterId?: string(name='sessionClusterId', description='The workspace ID.', example='w-******'),
}

model StartSessionClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartSessionClusterResponseBody(name='body'),
}

/**
 * @summary Starts a session.
 *
 * @param request StartSessionClusterRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartSessionClusterResponse
 */
async function startSessionClusterWithOptions(workspaceId: string, request: StartSessionClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StartSessionClusterResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.queueName)) {
    body['queueName'] = request.queueName;
  }
  if (!Util.isUnset(request.sessionClusterId)) {
    body['sessionClusterId'] = request.sessionClusterId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartSessionCluster',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${OpenApiUtil.getEncodeParam(workspaceId)}/sessionClusters/action/startSessionCluster`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Starts a session.
 *
 * @param request StartSessionClusterRequest
 * @return StartSessionClusterResponse
 */
async function startSessionCluster(workspaceId: string, request: StartSessionClusterRequest): StartSessionClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startSessionClusterWithOptions(workspaceId, request, headers, runtime);
}

model StopSessionClusterRequest {
  queueName?: string(name='queueName', description='The queue name.', example='root_queue'),
  sessionClusterId?: string(name='sessionClusterId', description='The session ID.', example='sc-xxxxxxxxxxxx'),
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
}

model StopSessionClusterResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  sessionClusterId?: string(name='sessionClusterId', description='The workspace ID.', example='w-******'),
}

model StopSessionClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopSessionClusterResponseBody(name='body'),
}

/**
 * @summary Stops a session.
 *
 * @param request StopSessionClusterRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopSessionClusterResponse
 */
async function stopSessionClusterWithOptions(workspaceId: string, request: StopSessionClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopSessionClusterResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.queueName)) {
    body['queueName'] = request.queueName;
  }
  if (!Util.isUnset(request.sessionClusterId)) {
    body['sessionClusterId'] = request.sessionClusterId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopSessionCluster',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/v1/workspaces/${OpenApiUtil.getEncodeParam(workspaceId)}/sessionClusters/action/stopSessionCluster`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Stops a session.
 *
 * @param request StopSessionClusterRequest
 * @return StopSessionClusterResponse
 */
async function stopSessionCluster(workspaceId: string, request: StopSessionClusterRequest): StopSessionClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopSessionClusterWithOptions(workspaceId, request, headers, runtime);
}

model TerminateSqlStatementRequest {
  regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
}

model TerminateSqlStatementResponseBody = {
  requestId?: string(name='requestId', description='The request ID.', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
}

model TerminateSqlStatementResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TerminateSqlStatementResponseBody(name='body'),
}

/**
 * @summary Terminates an SQL query task.
 *
 * @param request TerminateSqlStatementRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return TerminateSqlStatementResponse
 */
async function terminateSqlStatementWithOptions(workspaceId: string, statementId: string, request: TerminateSqlStatementRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TerminateSqlStatementResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TerminateSqlStatement',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/api/interactive/v1/workspace/${OpenApiUtil.getEncodeParam(workspaceId)}/statement/${OpenApiUtil.getEncodeParam(statementId)}/terminate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Terminates an SQL query task.
 *
 * @param request TerminateSqlStatementRequest
 * @return TerminateSqlStatementResponse
 */
async function terminateSqlStatement(workspaceId: string, statementId: string, request: TerminateSqlStatementRequest): TerminateSqlStatementResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return terminateSqlStatementWithOptions(workspaceId, statementId, request, headers, runtime);
}

model UpdateProcessDefinitionWithScheduleRequest {
  alertEmailAddress?: string(name='alertEmailAddress', example='foo_bar@spark.alert.invalid.com'),
  description?: string(name='description', example='ods batch workflow'),
  executionType?: string(name='executionType', description='This parameter is required.', example='PARALLEL'),
  name?: string(name='name', description='This parameter is required.', example='ods_batch_workflow'),
  productNamespace?: string(name='productNamespace', description='This parameter is required.', example='SS'),
  publish?: boolean(name='publish', example='true'),
  regionId?: string(name='regionId', example='cn-hangzhou'),
  releaseState?: string(name='releaseState', example='ONLINE'),
  resourceQueue?: string(name='resourceQueue', example='root_queue'),
  retryTimes?: int32(name='retryTimes', example='1'),
  runAs?: string(name='runAs', example='113***************'),
  schedule?: {
    crontab?: string(name='crontab', example='0 0 0 * * ?'),
    endTime?: string(name='endTime', example='2025-12-23 16:13:27'),
    startTime?: string(name='startTime', example='2024-12-23 16:13:27'),
    timezoneId?: string(name='timezoneId', example='Asia/Shanghai'),
  }(name='schedule'),
  tags?: map[string]string(name='tags'),
  taskDefinitionJson?: [ 
    {
      alertEmailAddress?: string(name='alertEmailAddress', example='foo_bar@spark.alert.invalid.com'),
      code?: long(name='code', description='This parameter is required.', example='23************'),
      description?: string(name='description', example='ods transform task'),
      failAlertEnable?: boolean(name='failAlertEnable', example='true'),
      failRetryTimes?: int32(name='failRetryTimes', example='1'),
      name?: string(name='name', description='This parameter is required.', example='ods_transform_task'),
      startAlertEnable?: boolean(name='startAlertEnable', example='true'),
      tags?: map[string]string(name='tags'),
      taskParams?: {
        displaySparkVersion?: string(name='displaySparkVersion', example='esr-4.0.0 (Spark 3.5.2, Scala 2.12)'),
        environmentId?: string(name='environmentId', example='ev-h*************'),
        fusion?: boolean(name='fusion', example='false'),
        resourceQueueId?: string(name='resourceQueueId', description='This parameter is required.', example='root_queue'),
        sparkConf?: [ 
          {
            key?: string(name='key', example='spark.dynamicAllocation.enabled'),
            value?: string(name='value', example='true'),
          }
        ](name='sparkConf'),
        sparkDriverCores?: int32(name='sparkDriverCores', example='1'),
        sparkDriverMemory?: long(name='sparkDriverMemory', example='4g'),
        sparkExecutorCores?: int32(name='sparkExecutorCores', example='1'),
        sparkExecutorMemory?: long(name='sparkExecutorMemory', example='4g'),
        sparkLogLevel?: string(name='sparkLogLevel', example='INFO'),
        sparkLogPath?: string(name='sparkLogPath'),
        sparkVersion?: string(name='sparkVersion', example='esr-4.0.0 (Spark 3.5.2, Scala 2.12)'),
        taskBizId?: string(name='taskBizId', description='This parameter is required.', example='TSK-d87******************'),
        type?: string(name='type', example='SQL'),
        workspaceBizId?: string(name='workspaceBizId', description='This parameter is required.', example='w-d8********'),
      }(name='taskParams', description='This parameter is required.'),
      taskType?: string(name='taskType', description='This parameter is required.', example='EMR-SERVERLESS-SPARK'),
      timeout?: int32(name='timeout', example='30'),
    }
  ](name='taskDefinitionJson', description='This parameter is required.'),
  taskParallelism?: int32(name='taskParallelism', example='1'),
  taskRelationJson?: [ 
    {
      name?: string(name='name', description='This parameter is required.', example='ods batch workflow'),
      postTaskCode?: long(name='postTaskCode', description='This parameter is required.', example='19************'),
      postTaskVersion?: int32(name='postTaskVersion', description='This parameter is required.', example='1'),
      preTaskCode?: long(name='preTaskCode', description='This parameter is required.', example='16************'),
      preTaskVersion?: int32(name='preTaskVersion', description='This parameter is required.', example='1'),
    }
  ](name='taskRelationJson', description='This parameter is required.'),
  timeout?: int32(name='timeout', example='300'),
}

model UpdateProcessDefinitionWithScheduleShrinkRequest {
  alertEmailAddress?: string(name='alertEmailAddress', example='foo_bar@spark.alert.invalid.com'),
  description?: string(name='description', example='ods batch workflow'),
  executionType?: string(name='executionType', description='This parameter is required.', example='PARALLEL'),
  name?: string(name='name', description='This parameter is required.', example='ods_batch_workflow'),
  productNamespace?: string(name='productNamespace', description='This parameter is required.', example='SS'),
  publish?: boolean(name='publish', example='true'),
  regionId?: string(name='regionId', example='cn-hangzhou'),
  releaseState?: string(name='releaseState', example='ONLINE'),
  resourceQueue?: string(name='resourceQueue', example='root_queue'),
  retryTimes?: int32(name='retryTimes', example='1'),
  runAs?: string(name='runAs', example='113***************'),
  scheduleShrink?: string(name='schedule'),
  tagsShrink?: string(name='tags'),
  taskDefinitionJsonShrink?: string(name='taskDefinitionJson', description='This parameter is required.'),
  taskParallelism?: int32(name='taskParallelism', example='1'),
  taskRelationJsonShrink?: string(name='taskRelationJson', description='This parameter is required.'),
  timeout?: int32(name='timeout', example='300'),
}

model UpdateProcessDefinitionWithScheduleResponseBody = {
  code?: int32(name='code', example='1400009'),
  data?: {
    alertEmailAddress?: string(name='alertEmailAddress', example='foo_bar@spark.alert.invalid.com'),
    bizId?: string(name='bizId', example='alicloud_ack_one_cluster'),
    code?: string(name='code', example='12***********'),
    createTime?: string(name='createTime', example='2024-09-05T02:03:19Z'),
    crontab?: string(name='crontab', example='0 0 0 * * ?'),
    description?: string(name='description', example='1'),
    endTime?: string(name='endTime', example='1710432000000'),
    executionType?: string(name='executionType', example='SERIAL'),
    id?: string(name='id', example='123223'),
    name?: string(name='name', example='ods_batch_workflow'),
    projectName?: string(name='projectName', example='w-********'),
    releaseState?: string(name='releaseState', example='ONLINE'),
    startTime?: string(name='startTime', example='0'),
    timezoneId?: string(name='timezoneId', example='Asia/Shanghai'),
    updateTime?: string(name='updateTime', example='2024-03-05T06:24:27Z'),
    userId?: string(name='userId', example='113*********'),
    userName?: string(name='userName', example='w-********'),
    version?: int32(name='version', example='1'),
    versionHashCode?: string(name='versionHashCode', example='dwerf*********'),
  }(name='data'),
  failed?: string(name='failed', example='false'),
  httpStatusCode?: int32(name='httpStatusCode', example='200'),
  msg?: string(name='msg', example='No permission for resource action'),
  requestId?: string(name='requestId', description='Id of the request', example='DD6B1B2A-5837-5237-ABE4-FF0C8944****'),
  success?: string(name='success', example='true'),
}

model UpdateProcessDefinitionWithScheduleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateProcessDefinitionWithScheduleResponseBody(name='body'),
}

/**
 * @summary 更新工作流定义和定时调度
 *
 * @param tmpReq UpdateProcessDefinitionWithScheduleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateProcessDefinitionWithScheduleResponse
 */
async function updateProcessDefinitionWithScheduleWithOptions(bizId: string, code: string, tmpReq: UpdateProcessDefinitionWithScheduleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProcessDefinitionWithScheduleResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateProcessDefinitionWithScheduleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.schedule)) {
    request.scheduleShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.schedule, 'schedule', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'tags', 'json');
  }
  if (!Util.isUnset(tmpReq.taskDefinitionJson)) {
    request.taskDefinitionJsonShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.taskDefinitionJson, 'taskDefinitionJson', 'json');
  }
  if (!Util.isUnset(tmpReq.taskRelationJson)) {
    request.taskRelationJsonShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.taskRelationJson, 'taskRelationJson', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.alertEmailAddress)) {
    query['alertEmailAddress'] = request.alertEmailAddress;
  }
  if (!Util.isUnset(request.description)) {
    query['description'] = request.description;
  }
  if (!Util.isUnset(request.executionType)) {
    query['executionType'] = request.executionType;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.productNamespace)) {
    query['productNamespace'] = request.productNamespace;
  }
  if (!Util.isUnset(request.publish)) {
    query['publish'] = request.publish;
  }
  if (!Util.isUnset(request.regionId)) {
    query['regionId'] = request.regionId;
  }
  if (!Util.isUnset(request.releaseState)) {
    query['releaseState'] = request.releaseState;
  }
  if (!Util.isUnset(request.resourceQueue)) {
    query['resourceQueue'] = request.resourceQueue;
  }
  if (!Util.isUnset(request.retryTimes)) {
    query['retryTimes'] = request.retryTimes;
  }
  if (!Util.isUnset(request.runAs)) {
    query['runAs'] = request.runAs;
  }
  if (!Util.isUnset(request.scheduleShrink)) {
    query['schedule'] = request.scheduleShrink;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.taskDefinitionJsonShrink)) {
    query['taskDefinitionJson'] = request.taskDefinitionJsonShrink;
  }
  if (!Util.isUnset(request.taskParallelism)) {
    query['taskParallelism'] = request.taskParallelism;
  }
  if (!Util.isUnset(request.taskRelationJsonShrink)) {
    query['taskRelationJson'] = request.taskRelationJsonShrink;
  }
  if (!Util.isUnset(request.timeout)) {
    query['timeout'] = request.timeout;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProcessDefinitionWithSchedule',
    version = '2023-08-08',
    protocol = 'HTTPS',
    pathname = `/dolphinscheduler/projects/${OpenApiUtil.getEncodeParam(bizId)}/process-definition/${OpenApiUtil.getEncodeParam(code)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新工作流定义和定时调度
 *
 * @param request UpdateProcessDefinitionWithScheduleRequest
 * @return UpdateProcessDefinitionWithScheduleResponse
 */
async function updateProcessDefinitionWithSchedule(bizId: string, code: string, request: UpdateProcessDefinitionWithScheduleRequest): UpdateProcessDefinitionWithScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProcessDefinitionWithScheduleWithOptions(bizId, code, request, headers, runtime);
}

