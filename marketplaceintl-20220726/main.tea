/**
 *
 */
import Util;
import OSS;
import RPC;
import OpenPlatform;
import OSSUtil;
import FileForm;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('marketplaceintl', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddIntlImageProductVersionRequest {
  accessDetail?: {
    ak?: string(name='Ak'),
    autoPublish?: boolean(name='AutoPublish'),
    imageId?: string(name='ImageId'),
    imageName?: string(name='ImageName'),
    imageVersion?: string(name='ImageVersion'),
    region?: string(name='Region'),
    releaseNote?: string(name='ReleaseNote'),
    releaseRegionOption?: string(name='ReleaseRegionOption'),
    secret?: string(name='Secret'),
  }(name='AccessDetail'),
  commodityCode?: string(name='CommodityCode'),
  imageConstraint?: {
    baseConfig?: {
      maxCpu?: int32(name='MaxCpu'),
      maxMemory?: float(name='MaxMemory'),
      minBandwidth?: int32(name='MinBandwidth'),
      minCpu?: int32(name='MinCpu'),
      minDataDiskSize?: int32(name='MinDataDiskSize'),
      minMemory?: float(name='MinMemory'),
      minSystemDiskSize?: int32(name='MinSystemDiskSize'),
    }(name='BaseConfig'),
    customizeFamilyConstraints?: map[string]any(name='CustomizeFamilyConstraints'),
    supportMoreNetworkCards?: boolean(name='SupportMoreNetworkCards'),
    tcpPortRange?: [ string ](name='TcpPortRange'),
    udpPortRange?: [ string ](name='UdpPortRange'),
  }(name='ImageConstraint'),
  requestId?: string(name='RequestId'),
  uid?: string(name='Uid'),
}

model AddIntlImageProductVersionResponseBody = {
  code?: int32(name='Code'),
  data?: {
    commodityCode?: string(name='CommodityCode'),
    trackId?: string(name='TrackId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddIntlImageProductVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddIntlImageProductVersionResponseBody(name='body'),
}

async function addIntlImageProductVersionWithOptions(request: AddIntlImageProductVersionRequest, runtime: Util.RuntimeOptions): AddIntlImageProductVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.accessDetail)) {
    bodyFlat['AccessDetail'] = request.accessDetail;
  }
  if (!Util.isUnset(request.commodityCode)) {
    body['CommodityCode'] = request.commodityCode;
  }
  if (!Util.isUnset(request.imageConstraint)) {
    bodyFlat['ImageConstraint'] = request.imageConstraint;
  }
  if (!Util.isUnset(request.requestId)) {
    body['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.uid)) {
    body['Uid'] = request.uid;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddIntlImageProductVersion',
    version = '2022-07-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addIntlImageProductVersion(request: AddIntlImageProductVersionRequest): AddIntlImageProductVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return addIntlImageProductVersionWithOptions(request, runtime);
}

model CreateOrUpdateIntlImageRequest {
  accessInfo?: {
    accessDetail?: {
      ak?: string(name='Ak'),
      autoPublish?: boolean(name='AutoPublish'),
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      imageVersion?: string(name='ImageVersion'),
      region?: string(name='Region'),
      releaseNote?: string(name='ReleaseNote'),
      releaseRegionOption?: string(name='ReleaseRegionOption'),
      secret?: string(name='Secret'),
    }(name='AccessDetail'),
    autoPublish?: boolean(name='AutoPublish'),
    imageConstraint?: {
      baseConfig?: {
        maxCpu?: int32(name='MaxCpu'),
        maxMemory?: float(name='MaxMemory'),
        minBandwidth?: int32(name='MinBandwidth'),
        minCpu?: int32(name='MinCpu'),
        minDataDiskSize?: int32(name='MinDataDiskSize'),
        minMemory?: float(name='MinMemory'),
        minSystemDiskSize?: int32(name='MinSystemDiskSize'),
      }(name='BaseConfig'),
      customizeFamilyConstraints?: map[string]any(name='CustomizeFamilyConstraints'),
      supportMoreNetworkCards?: boolean(name='SupportMoreNetworkCards'),
      tcpPortRange?: [ string ](name='TcpPortRange'),
      udpPortRange?: [ string ](name='UdpPortRange'),
    }(name='ImageConstraint'),
    name?: string(name='Name'),
    releaseRegion?: string(name='ReleaseRegion'),
    releaseRegionOption?: string(name='ReleaseRegionOption'),
    type?: int32(name='Type'),
  }(name='AccessInfo'),
  basicInfo?: {
    commodityAfterSale?: string(name='CommodityAfterSale'),
    commodityDetail?: string(name='CommodityDetail'),
    commodityFeature?: string(name='CommodityFeature'),
    commodityIntroduction?: string(name='CommodityIntroduction'),
    commodityPicture?: string(name='CommodityPicture'),
    commodityPictureName?: string(name='CommodityPictureName'),
    commodityPictureStream?: string(name='CommodityPictureStream'),
    commodityQualification?: [ string ](name='CommodityQualification'),
    commodityRefundPolicy?: string(name='CommodityRefundPolicy'),
    commodityUserGuide?: string(name='CommodityUserGuide'),
    commodityVideoName?: string(name='CommodityVideoName'),
    commodityVideoStream?: string(name='CommodityVideoStream'),
    commodityVideoUrl?: string(name='CommodityVideoUrl'),
    videoSelect?: string(name='VideoSelect'),
  }(name='BasicInfo'),
  bussinessInfo?: {
    categoryId?: string(name='CategoryId'),
    pipCode?: string(name='PipCode'),
    seoDescription?: string(name='SeoDescription'),
    seoKeywords?: string(name='SeoKeywords'),
  }(name='BussinessInfo'),
  callBackUrl?: string(name='CallBackUrl'),
  commodityCode?: string(name='CommodityCode'),
  protocolInfo?: {
    agentName?: string(name='AgentName'),
    customsTarifNumber?: string(name='CustomsTarifNumber'),
    earControlled?: string(name='EarControlled'),
    eccnCode?: string(name='EccnCode'),
    finalUserProtocol?: string(name='FinalUserProtocol'),
    identificationMethod?: string(name='IdentificationMethod'),
    license?: string(name='License'),
    licenseException?: string(name='LicenseException'),
    localExportControlClassificationNumber?: string(name='LocalExportControlClassificationNumber'),
    officialIdentificationNumber?: string(name='OfficialIdentificationNumber'),
    productCryType?: string(name='ProductCryType'),
    productType?: string(name='ProductType'),
  }(name='ProtocolInfo'),
  requestId?: string(name='RequestId'),
  saleInfo?: {
    billingMethods?: int32(name='BillingMethods'),
    commodityFrontShow?: string(name='CommodityFrontShow'),
    postpaidPrice?: {
      hourPrice?: string(name='HourPrice'),
      postpaidPriceList?: [ 
        {
          basePrice?: string(name='BasePrice'),
          currency?: string(name='Currency'),
          excelUrl?: string(name='ExcelUrl'),
          instanceType?: string(name='InstanceType'),
          priceType?: string(name='PriceType'),
        }
      ](name='PostpaidPriceList'),
      unifiedPrice?: boolean(name='UnifiedPrice'),
    }(name='PostpaidPrice'),
    prepaymentPrice?: {
      monthPrice?: string(name='MonthPrice'),
      monthRenewPrice?: string(name='MonthRenewPrice'),
      prepaymentPriceList?: [ 
        {
          basePrice?: string(name='BasePrice'),
          currency?: string(name='Currency'),
          excelUrl?: string(name='ExcelUrl'),
          instanceType?: string(name='InstanceType'),
          priceType?: string(name='PriceType'),
          tradeType?: string(name='TradeType'),
        }
      ](name='PrepaymentPriceList'),
      unifiedPrice?: boolean(name='UnifiedPrice'),
      yearPrice?: string(name='YearPrice'),
      yearRenewPrice?: string(name='YearRenewPrice'),
    }(name='PrepaymentPrice'),
    pricingPlan?: string(name='PricingPlan'),
  }(name='SaleInfo'),
  uid?: string(name='Uid'),
}

model CreateOrUpdateIntlImageResponseBody = {
  code?: int32(name='Code'),
  data?: {
    code?: string(name='Code'),
    trackId?: string(name='TrackId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateOrUpdateIntlImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateIntlImageResponseBody(name='body'),
}

async function createOrUpdateIntlImageWithOptions(request: CreateOrUpdateIntlImageRequest, runtime: Util.RuntimeOptions): CreateOrUpdateIntlImageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.accessInfo)) {
    bodyFlat['AccessInfo'] = request.accessInfo;
  }
  if (!Util.isUnset(request.basicInfo)) {
    bodyFlat['BasicInfo'] = request.basicInfo;
  }
  if (!Util.isUnset(request.bussinessInfo)) {
    bodyFlat['BussinessInfo'] = request.bussinessInfo;
  }
  if (!Util.isUnset(request.callBackUrl)) {
    body['CallBackUrl'] = request.callBackUrl;
  }
  if (!Util.isUnset(request.commodityCode)) {
    body['CommodityCode'] = request.commodityCode;
  }
  if (!Util.isUnset(request.protocolInfo)) {
    bodyFlat['ProtocolInfo'] = request.protocolInfo;
  }
  if (!Util.isUnset(request.requestId)) {
    body['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.saleInfo)) {
    bodyFlat['SaleInfo'] = request.saleInfo;
  }
  if (!Util.isUnset(request.uid)) {
    body['Uid'] = request.uid;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateIntlImage',
    version = '2022-07-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateIntlImage(request: CreateOrUpdateIntlImageRequest): CreateOrUpdateIntlImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateIntlImageWithOptions(request, runtime);
}

model DescribeAccessibleRegionsRequest {
  requestId?: string(name='RequestId'),
  uid?: string(name='Uid'),
}

model DescribeAccessibleRegionsResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      regionName?: string(name='RegionName'),
      regionNo?: string(name='RegionNo'),
      trackId?: string(name='TrackId'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeAccessibleRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAccessibleRegionsResponseBody(name='body'),
}

async function describeAccessibleRegionsWithOptions(request: DescribeAccessibleRegionsRequest, runtime: Util.RuntimeOptions): DescribeAccessibleRegionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.requestId)) {
    body['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.uid)) {
    body['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAccessibleRegions',
    version = '2022-07-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAccessibleRegions(request: DescribeAccessibleRegionsRequest): DescribeAccessibleRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccessibleRegionsWithOptions(request, runtime);
}

model DescribeCategoriesRequest {
  requestId?: string(name='RequestId'),
  uid?: string(name='Uid'),
}

model DescribeCategoriesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      categoryId?: string(name='CategoryId'),
      categoryName?: string(name='CategoryName'),
      subCategories?: [ 
        {
          categoryId?: string(name='CategoryId'),
          categoryName?: string(name='CategoryName'),
        }
      ](name='SubCategories'),
      trackId?: string(name='TrackId'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeCategoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCategoriesResponseBody(name='body'),
}

async function describeCategoriesWithOptions(request: DescribeCategoriesRequest, runtime: Util.RuntimeOptions): DescribeCategoriesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.requestId)) {
    body['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.uid)) {
    body['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCategories',
    version = '2022-07-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCategories(request: DescribeCategoriesRequest): DescribeCategoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCategoriesWithOptions(request, runtime);
}

model DescribeCountriesRequest {
  requestId?: string(name='RequestId'),
  uid?: string(name='Uid'),
}

model DescribeCountriesResponseBody = {
  code?: int32(name='Code'),
  data?: {
    countries?: [ string ](name='Countries'),
    requestId?: string(name='RequestId'),
    uid?: string(name='Uid'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeCountriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCountriesResponseBody(name='body'),
}

async function describeCountriesWithOptions(request: DescribeCountriesRequest, runtime: Util.RuntimeOptions): DescribeCountriesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.requestId)) {
    body['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.uid)) {
    body['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCountries',
    version = '2022-07-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCountries(request: DescribeCountriesRequest): DescribeCountriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCountriesWithOptions(request, runtime);
}

model DescribeCustomImagesRequest {
  ak?: string(name='Ak'),
  regionNo?: string(name='RegionNo'),
  requestId?: string(name='RequestId'),
  secret?: string(name='Secret'),
  uid?: string(name='Uid'),
}

model DescribeCustomImagesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      createdOn?: long(name='CreatedOn'),
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      imageSize?: int32(name='ImageSize'),
      osname?: string(name='Osname'),
      platform?: string(name='Platform'),
      platformBit?: string(name='PlatformBit'),
      platformType?: string(name='PlatformType'),
      region?: string(name='Region'),
      trackId?: string(name='TrackId'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeCustomImagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCustomImagesResponseBody(name='body'),
}

async function describeCustomImagesWithOptions(request: DescribeCustomImagesRequest, runtime: Util.RuntimeOptions): DescribeCustomImagesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ak)) {
    body['Ak'] = request.ak;
  }
  if (!Util.isUnset(request.regionNo)) {
    body['RegionNo'] = request.regionNo;
  }
  if (!Util.isUnset(request.requestId)) {
    body['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.secret)) {
    body['Secret'] = request.secret;
  }
  if (!Util.isUnset(request.uid)) {
    body['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomImages',
    version = '2022-07-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCustomImages(request: DescribeCustomImagesRequest): DescribeCustomImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomImagesWithOptions(request, runtime);
}

model DescribeImageCommodityInfoRequest {
  commodityCode?: string(name='CommodityCode'),
  requestId?: string(name='RequestId'),
  uid?: string(name='Uid'),
}

model DescribeImageCommodityInfoResponseBody = {
  code?: int32(name='Code'),
  data?: {
    accessInfo?: {
      accessDetail?: {
        ak?: string(name='Ak'),
        autoPublish?: boolean(name='AutoPublish'),
        imageId?: string(name='ImageId'),
        imageName?: string(name='ImageName'),
        imageVersion?: string(name='ImageVersion'),
        region?: string(name='Region'),
        releaseNote?: string(name='ReleaseNote'),
        releaseRegionOption?: string(name='ReleaseRegionOption'),
        secret?: string(name='Secret'),
      }(name='AccessDetail'),
      autoPublish?: boolean(name='AutoPublish'),
      imageConstraint?: {
        baseConfig?: {
          maxCpu?: int32(name='MaxCpu'),
          maxMemory?: float(name='MaxMemory'),
          minBandwidth?: int32(name='MinBandwidth'),
          minCpu?: int32(name='MinCpu'),
          minDataDiskSize?: int32(name='MinDataDiskSize'),
          minMemory?: float(name='MinMemory'),
          minSystemDiskSize?: int32(name='MinSystemDiskSize'),
        }(name='BaseConfig'),
        customizeFamilyConstraints?: map[string]any(name='CustomizeFamilyConstraints'),
        supportMoreNetworkCards?: boolean(name='SupportMoreNetworkCards'),
        tcpPortRange?: [ string ](name='TcpPortRange'),
        udpPortRange?: [ string ](name='UdpPortRange'),
      }(name='ImageConstraint'),
      name?: string(name='Name'),
      releaseRegion?: string(name='ReleaseRegion'),
      releaseRegionOption?: string(name='ReleaseRegionOption'),
      type?: int32(name='Type'),
    }(name='AccessInfo'),
    basicInfo?: {
      commodityAfterSale?: string(name='CommodityAfterSale'),
      commodityDetail?: string(name='CommodityDetail'),
      commodityFeature?: string(name='CommodityFeature'),
      commodityIntroduction?: string(name='CommodityIntroduction'),
      commodityPicture?: string(name='CommodityPicture'),
      commodityPictureName?: string(name='CommodityPictureName'),
      commodityPictureStream?: string(name='CommodityPictureStream'),
      commodityQualification?: [ string ](name='CommodityQualification'),
      commodityRefundPolicy?: string(name='CommodityRefundPolicy'),
      commodityUserGuide?: string(name='CommodityUserGuide'),
      commodityVideoName?: string(name='CommodityVideoName'),
      commodityVideoStream?: string(name='CommodityVideoStream'),
      commodityVideoUrl?: string(name='CommodityVideoUrl'),
      videoSelect?: string(name='VideoSelect'),
    }(name='BasicInfo'),
    bussinessInfo?: {
      categoryId?: string(name='CategoryId'),
      pipCode?: string(name='PipCode'),
      seoDescription?: string(name='SeoDescription'),
      seoKeywords?: string(name='SeoKeywords'),
    }(name='BussinessInfo'),
    commodityCode?: string(name='CommodityCode'),
    protocolInfo?: {
      agentName?: string(name='AgentName'),
      customsTarifNumber?: string(name='CustomsTarifNumber'),
      earControlled?: string(name='EarControlled'),
      eccnCode?: string(name='EccnCode'),
      finalUserProtocol?: string(name='FinalUserProtocol'),
      identificationMethod?: string(name='IdentificationMethod'),
      license?: string(name='License'),
      licenseException?: string(name='LicenseException'),
      localExportControlClassificationNumber?: string(name='LocalExportControlClassificationNumber'),
      officialIdentificationNumber?: string(name='OfficialIdentificationNumber'),
      productCryType?: string(name='ProductCryType'),
      productType?: string(name='ProductType'),
    }(name='ProtocolInfo'),
    trackId?: string(name='TrackId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeImageCommodityInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageCommodityInfoResponseBody(name='body'),
}

async function describeImageCommodityInfoWithOptions(request: DescribeImageCommodityInfoRequest, runtime: Util.RuntimeOptions): DescribeImageCommodityInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.commodityCode)) {
    body['CommodityCode'] = request.commodityCode;
  }
  if (!Util.isUnset(request.requestId)) {
    body['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.uid)) {
    body['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageCommodityInfo',
    version = '2022-07-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageCommodityInfo(request: DescribeImageCommodityInfoRequest): DescribeImageCommodityInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageCommodityInfoWithOptions(request, runtime);
}

model DescribeImageCommodityStatusRequest {
  commodityCode?: string(name='CommodityCode'),
  requestId?: string(name='RequestId'),
  uid?: string(name='Uid'),
}

model DescribeImageCommodityStatusResponseBody = {
  code?: int32(name='Code'),
  data?: {
    auditStatus?: int32(name='AuditStatus'),
    commodityCode?: string(name='CommodityCode'),
    trackId?: string(name='TrackId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeImageCommodityStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageCommodityStatusResponseBody(name='body'),
}

async function describeImageCommodityStatusWithOptions(request: DescribeImageCommodityStatusRequest, runtime: Util.RuntimeOptions): DescribeImageCommodityStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.commodityCode)) {
    body['CommodityCode'] = request.commodityCode;
  }
  if (!Util.isUnset(request.requestId)) {
    body['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.uid)) {
    body['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageCommodityStatus',
    version = '2022-07-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageCommodityStatus(request: DescribeImageCommodityStatusRequest): DescribeImageCommodityStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageCommodityStatusWithOptions(request, runtime);
}

model DescribeImageConstraintsRequest {
  ak?: string(name='Ak'),
  imageId?: string(name='ImageId'),
  regionNo?: string(name='RegionNo'),
  requestId?: string(name='RequestId'),
  secret?: string(name='Secret'),
  uid?: string(name='Uid'),
}

model DescribeImageConstraintsResponseBody = {
  code?: int32(name='Code'),
  data?: {
    bandwidth?: {
      max?: int32(name='Max'),
      min?: int32(name='Min'),
      step?: int32(name='Step'),
      unit?: string(name='Unit'),
    }(name='Bandwidth'),
    cpuMemoryRange?: [ 
      {
        cpuCoreCount?: int32(name='CpuCoreCount'),
        memorySizeList?: [ float ](name='MemorySizeList'),
      }
    ](name='CpuMemoryRange'),
    dataDisk?: {
      max?: int32(name='Max'),
      min?: int32(name='Min'),
      step?: int32(name='Step'),
      unit?: string(name='Unit'),
    }(name='DataDisk'),
    systemDisk?: {
      max?: int32(name='Max'),
      min?: int32(name='Min'),
      step?: int32(name='Step'),
      unit?: string(name='Unit'),
    }(name='SystemDisk'),
    trackId?: string(name='TrackId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeImageConstraintsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageConstraintsResponseBody(name='body'),
}

async function describeImageConstraintsWithOptions(request: DescribeImageConstraintsRequest, runtime: Util.RuntimeOptions): DescribeImageConstraintsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ak)) {
    body['Ak'] = request.ak;
  }
  if (!Util.isUnset(request.imageId)) {
    body['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.regionNo)) {
    body['RegionNo'] = request.regionNo;
  }
  if (!Util.isUnset(request.requestId)) {
    body['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.secret)) {
    body['Secret'] = request.secret;
  }
  if (!Util.isUnset(request.uid)) {
    body['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageConstraints',
    version = '2022-07-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageConstraints(request: DescribeImageConstraintsRequest): DescribeImageConstraintsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageConstraintsWithOptions(request, runtime);
}

model DescribeInstanceTypesRequest {
  requestId?: string(name='RequestId'),
  uid?: string(name='Uid'),
}

model DescribeInstanceTypesResponseBody = {
  code?: int32(name='Code'),
  data?: {
    customizeFamily?: [ 
      {
        globalKey?: string(name='GlobalKey'),
        text?: string(name='Text'),
        value?: string(name='Value'),
      }
    ](name='CustomizeFamily'),
    instanceTypes?: [ 
      {
        text?: string(name='Text'),
        value?: string(name='Value'),
      }
    ](name='InstanceTypes'),
    trackId?: string(name='TrackId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeInstanceTypesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceTypesResponseBody(name='body'),
}

async function describeInstanceTypesWithOptions(request: DescribeInstanceTypesRequest, runtime: Util.RuntimeOptions): DescribeInstanceTypesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.requestId)) {
    body['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.uid)) {
    body['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceTypes',
    version = '2022-07-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceTypes(request: DescribeInstanceTypesRequest): DescribeInstanceTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceTypesWithOptions(request, runtime);
}

model DescribeListResourcesRequest {
  requestId?: string(name='RequestId'),
  type?: string(name='Type'),
  uid?: string(name='Uid'),
}

model DescribeListResourcesResponseBody = {
  code?: int32(name='Code'),
  data?: {
    ossLink?: [ string ](name='OssLink'),
    trackId?: string(name='TrackId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeListResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeListResourcesResponseBody(name='body'),
}

async function describeListResourcesWithOptions(request: DescribeListResourcesRequest, runtime: Util.RuntimeOptions): DescribeListResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.requestId)) {
    body['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  if (!Util.isUnset(request.uid)) {
    body['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeListResources',
    version = '2022-07-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeListResources(request: DescribeListResourcesRequest): DescribeListResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeListResourcesWithOptions(request, runtime);
}

model DescribeReleasableRegionListRequest {
  requestId?: string(name='RequestId'),
  uid?: string(name='Uid'),
}

model DescribeReleasableRegionListResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      regionName?: string(name='RegionName'),
      regionNo?: string(name='RegionNo'),
      trackId?: string(name='TrackId'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeReleasableRegionListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeReleasableRegionListResponseBody(name='body'),
}

async function describeReleasableRegionListWithOptions(request: DescribeReleasableRegionListRequest, runtime: Util.RuntimeOptions): DescribeReleasableRegionListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.requestId)) {
    body['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.uid)) {
    body['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeReleasableRegionList',
    version = '2022-07-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeReleasableRegionList(request: DescribeReleasableRegionListRequest): DescribeReleasableRegionListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReleasableRegionListWithOptions(request, runtime);
}

model SubmitImageCommodityReviewRequest {
  commodityCode?: string(name='CommodityCode'),
  requestId?: string(name='RequestId'),
  uid?: string(name='Uid'),
}

model SubmitImageCommodityReviewResponseBody = {
  code?: int32(name='Code'),
  data?: {
    commodityCode?: string(name='CommodityCode'),
    trackId?: string(name='TrackId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubmitImageCommodityReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitImageCommodityReviewResponseBody(name='body'),
}

async function submitImageCommodityReviewWithOptions(request: SubmitImageCommodityReviewRequest, runtime: Util.RuntimeOptions): SubmitImageCommodityReviewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.commodityCode)) {
    body['CommodityCode'] = request.commodityCode;
  }
  if (!Util.isUnset(request.requestId)) {
    body['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.uid)) {
    body['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SubmitImageCommodityReview',
    version = '2022-07-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitImageCommodityReview(request: SubmitImageCommodityReviewRequest): SubmitImageCommodityReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitImageCommodityReviewWithOptions(request, runtime);
}

model UploadFileRequest {
  fileName?: string(name='FileName'),
  fileUrl?: string(name='FileUrl'),
  requestId?: string(name='RequestId'),
  type?: string(name='Type'),
  uid?: string(name='Uid'),
}

model UploadFileAdvanceRequest {
  fileUrlObject: readable(name='FileUrlObject'),
  fileName?: string(name='FileName'),
  requestId?: string(name='RequestId'),
  type?: string(name='Type'),
  uid?: string(name='Uid'),
}

model UploadFileResponseBody = {
  code?: int32(name='Code'),
  data?: {
    trackId?: string(name='TrackId'),
    url?: string(name='Url'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UploadFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadFileResponseBody(name='body'),
}

async function uploadFileWithOptions(request: UploadFileRequest, runtime: Util.RuntimeOptions): UploadFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.fileUrl)) {
    body['FileUrl'] = request.fileUrl;
  }
  if (!Util.isUnset(request.requestId)) {
    body['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  if (!Util.isUnset(request.uid)) {
    body['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UploadFile',
    version = '2022-07-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadFile(request: UploadFileRequest): UploadFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadFileWithOptions(request, runtime);
}

async function uploadFileAdvance(request: UploadFileAdvanceRequest, runtime: Util.RuntimeOptions): UploadFileResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new RPC.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'marketplaceIntl',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var uploadFileReq = new UploadFileRequest{};
  OpenApiUtil.convert(request, uploadFileReq);

  if(!Util.isUnset(request.fileUrlObject)){
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.endpoint, authResponse.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.objectKey,
      content = request.fileUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.accessKeyId,
      policy = authResponse.encodedPolicy,
      signature = authResponse.signature,
      key = authResponse.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    uploadFileReq.fileUrl =   `http://${authResponse.bucket}.${authResponse.endpoint}/${authResponse.objectKey}`;
  }
  var uploadFileResp = uploadFileWithOptions(uploadFileReq, runtime);
  return uploadFileResp;
}

