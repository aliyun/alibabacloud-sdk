/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('cdp', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CancelOrderRequest {
  instanceId?: string(name='InstanceId'),
}

model CancelOrderResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelOrderResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelOrderResponseBody(name='body'),
}

async function cancelOrderWithOptions(request: CancelOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelOrderResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelOrder',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/order/cancel`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelOrder(request: CancelOrderRequest): CancelOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelOrderWithOptions(request, headers, runtime);
}

model CheckClusterNameRequest {
  clusterName?: string(name='ClusterName'),
}

model CheckClusterNameResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckClusterNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckClusterNameResponseBody(name='body'),
}

async function checkClusterNameWithOptions(request: CheckClusterNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckClusterNameResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckClusterName',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/check/cluster_name`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkClusterName(request: CheckClusterNameRequest): CheckClusterNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkClusterNameWithOptions(request, headers, runtime);
}

model ConfirmNoticeRequest {
  clusterBizId?: string(name='ClusterBizId'),
}

model ConfirmNoticeResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConfirmNoticeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfirmNoticeResponseBody(name='body'),
}

async function confirmNoticeWithOptions(request: ConfirmNoticeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ConfirmNoticeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterBizId)) {
    query['ClusterBizId'] = request.clusterBizId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmNotice',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/confirm_notice`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function confirmNotice(request: ConfirmNoticeRequest): ConfirmNoticeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return confirmNoticeWithOptions(request, headers, runtime);
}

model CreateClusterRequest {
  clientToken?: string(name='ClientToken'),
  clusterInfo?: string(name='ClusterInfo'),
}

model CreateClusterResponseBody = {
  data?: string(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateClusterResponseBody(name='body'),
}

async function createClusterWithOptions(request: CreateClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterInfo)) {
    query['ClusterInfo'] = request.clusterInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCluster',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createClusterWithOptions(request, headers, runtime);
}

model GetClusterDetailRequest {
  clusterBizId?: string(name='ClusterBizId'),
  instanceId?: string(name='InstanceId'),
}

model GetClusterDetailResponseBody = {
  data?: {
    autoRenew?: boolean(name='AutoRenew'),
    beginTime?: long(name='BeginTime'),
    clusterBizId?: string(name='ClusterBizId'),
    clusterId?: string(name='ClusterId'),
    clusterName?: string(name='ClusterName'),
    clusterStatus?: string(name='ClusterStatus'),
    clusterStatusValue?: int32(name='ClusterStatusValue'),
    clusterType?: string(name='ClusterType'),
    controlCenterUrl?: string(name='ControlCenterUrl'),
    deployMode?: string(name='DeployMode'),
    duration?: int32(name='Duration'),
    expireTime?: long(name='ExpireTime'),
    gmtCreate?: long(name='GmtCreate'),
    gmtModified?: long(name='GmtModified'),
    instanceConf?: map[string]any(name='InstanceConf'),
    noticeConfirmed?: boolean(name='NoticeConfirmed'),
    orderBizId?: string(name='OrderBizId'),
    packageType?: string(name='PackageType'),
    pricingCycle?: string(name='PricingCycle'),
    regionId?: string(name='RegionId'),
    runningTime?: long(name='RunningTime'),
    version?: string(name='Version'),
    zoneId?: string(name='ZoneId'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model GetClusterDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClusterDetailResponseBody(name='body'),
}

async function getClusterDetailWithOptions(request: GetClusterDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetClusterDetailResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterBizId)) {
    query['ClusterBizId'] = request.clusterBizId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClusterDetail',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getClusterDetail(request: GetClusterDetailRequest): GetClusterDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getClusterDetailWithOptions(request, headers, runtime);
}

model HasDefaultRoleResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model HasDefaultRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: HasDefaultRoleResponseBody(name='body'),
}

async function hasDefaultRoleWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): HasDefaultRoleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'HasDefaultRole',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/user/has_default_role`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function hasDefaultRole(): HasDefaultRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return hasDefaultRoleWithOptions(headers, runtime);
}

model InitializeClouderaDataPlatformResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InitializeClouderaDataPlatformResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InitializeClouderaDataPlatformResponseBody(name='body'),
}

async function initializeClouderaDataPlatformWithOptions(ClientToken: string, headers: map[string]string, runtime: Util.RuntimeOptions): InitializeClouderaDataPlatformResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'InitializeClouderaDataPlatform',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/user/create_default_role`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function initializeClouderaDataPlatform(ClientToken: string): InitializeClouderaDataPlatformResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return initializeClouderaDataPlatformWithOptions(ClientToken, headers, runtime);
}

model ListDefaultComponentsRequest {
  clusterType?: string(name='ClusterType', example='CDP-base'),
  securityMode?: string(name='SecurityMode', example='NORMAL'),
}

model ListDefaultComponentsResponseBody = {
  data?: [ string ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: string(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDefaultComponentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDefaultComponentsResponseBody(name='body'),
}

async function listDefaultComponentsWithOptions(request: ListDefaultComponentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDefaultComponentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.securityMode)) {
    query['SecurityMode'] = request.securityMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDefaultComponents',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/cdp/defaultComponents`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDefaultComponents(request: ListDefaultComponentsRequest): ListDefaultComponentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDefaultComponentsWithOptions(request, headers, runtime);
}

model ListNodeGroupConstraintsRequest {
  clusterType?: string(name='ClusterType', example='CDP-base'),
}

model ListNodeGroupConstraintsResponseBody = {
  data?: [ 
    {
      hostGroupType?: string(name='HostGroupType'),
      recommendedInstanceTypes?: [ string ](name='RecommendedInstanceTypes'),
      availableDataDiskCategories?: [ string ](name='availableDataDiskCategories'),
      availableInstanceTypes?: [ string ](name='availableInstanceTypes'),
      availableSystemDiskCategories?: [ string ](name='availableSystemDiskCategories'),
      defaultDataDiskCount?: int32(name='defaultDataDiskCount'),
      defaultDataDiskSize?: int32(name='defaultDataDiskSize'),
      defaultNodeCount?: int32(name='defaultNodeCount'),
      defaultSystemDiskSize?: int32(name='defaultSystemDiskSize'),
      maxDataDiskCount?: int32(name='maxDataDiskCount'),
      maxDataDiskSize?: int32(name='maxDataDiskSize'),
      maxNodeCount?: int32(name='maxNodeCount'),
      maxSystemDiskSize?: int32(name='maxSystemDiskSize'),
      minDataDiskCount?: int32(name='minDataDiskCount'),
      minDataDiskSize?: int32(name='minDataDiskSize'),
      minNodeCount?: int32(name='minNodeCount'),
      minSystemDiskSize?: int32(name='minSystemDiskSize'),
      nodeGroupName?: string(name='nodeGroupName'),
    }
  ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListNodeGroupConstraintsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListNodeGroupConstraintsResponseBody(name='body'),
}

async function listNodeGroupConstraintsWithOptions(request: ListNodeGroupConstraintsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListNodeGroupConstraintsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNodeGroupConstraints',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/cdp/nodeGroupConstraints`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNodeGroupConstraints(request: ListNodeGroupConstraintsRequest): ListNodeGroupConstraintsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listNodeGroupConstraintsWithOptions(request, headers, runtime);
}

model ListNodesRequest {
  clusterBizId?: string(name='ClusterBizId'),
}

model ListNodesResponseBody = {
  data?: [ 
    {
      createTime?: long(name='CreateTime'),
      ecsNodeDtoList?: [ 
        {
          beginTime?: string(name='BeginTime'),
          cpuCount?: int32(name='CpuCount'),
          diskCapacity?: int32(name='DiskCapacity'),
          diskCount?: int32(name='DiskCount'),
          diskType?: string(name='DiskType'),
          expireTime?: long(name='ExpireTime'),
          gmtCreate?: string(name='GmtCreate'),
          gmtModified?: string(name='GmtModified'),
          index?: int32(name='Index'),
          instanceType?: string(name='InstanceType'),
          memorySize?: int32(name='MemorySize'),
          nodeGroupId?: string(name='NodeGroupId'),
          nodeGroupName?: string(name='NodeGroupName'),
          nodeGroupType?: string(name='NodeGroupType'),
          nodeId?: string(name='NodeId'),
          nodeName?: string(name='NodeName'),
          nodeResourceType?: string(name='NodeResourceType'),
          nodeStatus?: string(name='NodeStatus'),
          privateIp?: string(name='PrivateIp'),
          publicIp?: string(name='PublicIp'),
          runningTime?: long(name='RunningTime'),
          serialNumber?: string(name='SerialNumber'),
          systemDiskCapacity?: int32(name='SystemDiskCapacity'),
          systemDiskCount?: int32(name='SystemDiskCount'),
          systemDiskType?: string(name='SystemDiskType'),
        }
      ](name='EcsNodeDtoList'),
      expireTime?: long(name='ExpireTime'),
      instanceConf?: map[string]any(name='InstanceConf'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
    }
  ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListNodesResponseBody(name='body'),
}

async function listNodesWithOptions(request: ListNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListNodesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterBizId)) {
    query['ClusterBizId'] = request.clusterBizId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNodes',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/nodes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNodes(request: ListNodesRequest): ListNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listNodesWithOptions(request, headers, runtime);
}

model ListOperationsRequest {
  clusterBizId?: string(name='ClusterBizId'),
  parentOperationNodeId?: string(name='ParentOperationNodeId'),
}

model ListOperationsResponseBody = {
  data?: [ 
    {
      endTime?: long(name='EndTime'),
      hasChildOperationNodes?: boolean(name='HasChildOperationNodes'),
      hasOperationTask?: boolean(name='HasOperationTask'),
      operationId?: string(name='OperationId'),
      operationNodeId?: string(name='OperationNodeId'),
      operationNodeName?: int32(name='OperationNodeName'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
    }
  ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListOperationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOperationsResponseBody(name='body'),
}

async function listOperationsWithOptions(request: ListOperationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOperationsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterBizId)) {
    query['ClusterBizId'] = request.clusterBizId;
  }
  if (!Util.isUnset(request.parentOperationNodeId)) {
    query['ParentOperationNodeId'] = request.parentOperationNodeId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOperations',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/operations`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOperations(request: ListOperationsRequest): ListOperationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOperationsWithOptions(request, headers, runtime);
}

model ListRegionsResponseBody = {
  data?: [ 
    {
      description?: string(name='Description'),
      regionId?: string(name='RegionId'),
      regionName?: string(name='RegionName'),
    }
  ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRegionsResponseBody(name='body'),
}

async function listRegionsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListRegionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListRegions',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/region/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRegions(): ListRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRegionsWithOptions(headers, runtime);
}

model ListZonesRequest {
  regionId?: string(name='RegionId'),
}

model ListZonesResponseBody = {
  data?: [ string ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListZonesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListZonesResponseBody(name='body'),
}

async function listZonesWithOptions(request: ListZonesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListZonesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListZones',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/user/zones`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listZones(request: ListZonesRequest): ListZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listZonesWithOptions(request, headers, runtime);
}

model QueryOrderRequest {
  clusterBizId?: string(name='ClusterBizId'),
}

model QueryOrderResponseBody = {
  data?: [ 
    {
      instanceIds?: [ string ](name='InstanceIds'),
      orderId?: string(name='OrderId'),
      orderStatus?: string(name='OrderStatus'),
      orderType?: string(name='OrderType'),
    }
  ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryOrderResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryOrderResponseBody(name='body'),
}

async function queryOrderWithOptions(request: QueryOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryOrderResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterBizId)) {
    query['ClusterBizId'] = request.clusterBizId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryOrder',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/order/query`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryOrder(request: QueryOrderRequest): QueryOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryOrderWithOptions(request, headers, runtime);
}

model QueryPriceRequest {
  duration?: int32(name='Duration'),
  instanceId?: string(name='InstanceId'),
  nodeGroupSpecs?: string(name='NodeGroupSpecs'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
}

model QueryPriceResponseBody = {
  data?: {
    discountPrice?: double(name='DiscountPrice'),
    ecsPriceInfo?: {
      currency?: string(name='Currency'),
      discountPrice?: double(name='DiscountPrice'),
      originalPrice?: double(name='OriginalPrice'),
      tradePrice?: double(name='TradePrice'),
    }(name='EcsPriceInfo'),
    softPriceInfo?: {
      currency?: string(name='Currency'),
      discountPrice?: double(name='DiscountPrice'),
      originalPrice?: double(name='OriginalPrice'),
      tradePrice?: double(name='TradePrice'),
    }(name='SoftPriceInfo'),
    sumPrice?: double(name='SumPrice'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryPriceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPriceResponseBody(name='body'),
}

async function queryPriceWithOptions(request: QueryPriceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryPriceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.nodeGroupSpecs)) {
    query['NodeGroupSpecs'] = request.nodeGroupSpecs;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryPrice',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/buy/query_price`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryPrice(request: QueryPriceRequest): QueryPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryPriceWithOptions(request, headers, runtime);
}

model QueryRenewOrderRequest {
  clusterBizId?: string(name='ClusterBizId'),
}

model QueryRenewOrderResponseBody = {
  data?: [ long ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryRenewOrderResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryRenewOrderResponseBody(name='body'),
}

async function queryRenewOrderWithOptions(request: QueryRenewOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryRenewOrderResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterBizId)) {
    query['ClusterBizId'] = request.clusterBizId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryRenewOrder',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/order/query_renew_order`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryRenewOrder(request: QueryRenewOrderRequest): QueryRenewOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryRenewOrderWithOptions(request, headers, runtime);
}

model QueryRenewPriceRequest {
  clusterBizId?: string(name='ClusterBizId'),
  instances?: string(name='Instances'),
}

model QueryRenewPriceResponseBody = {
  data?: {
    cdpSoftPriceInfo?: {
      currency?: string(name='Currency'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      tradePrice?: float(name='TradePrice'),
    }(name='CdpSoftPriceInfo'),
    discountPrice?: float(name='DiscountPrice'),
    ecsPriceInfo?: {
      currency?: string(name='Currency'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      tradePrice?: float(name='TradePrice'),
    }(name='EcsPriceInfo'),
    sumPrice?: float(name='SumPrice'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryRenewPriceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryRenewPriceResponseBody(name='body'),
}

async function queryRenewPriceWithOptions(request: QueryRenewPriceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryRenewPriceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterBizId)) {
    query['ClusterBizId'] = request.clusterBizId;
  }
  if (!Util.isUnset(request.instances)) {
    query['Instances'] = request.instances;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryRenewPrice',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/buy/query_renew_price`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryRenewPrice(request: QueryRenewPriceRequest): QueryRenewPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryRenewPriceWithOptions(request, headers, runtime);
}

model QueryScaleUpOrderRequest {
  clusterBizId?: string(name='ClusterBizId'),
  instanceId?: string(name='InstanceId'),
}

model QueryScaleUpOrderResponseBody = {
  data?: [ long ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: long(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryScaleUpOrderResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryScaleUpOrderResponseBody(name='body'),
}

async function queryScaleUpOrderWithOptions(request: QueryScaleUpOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryScaleUpOrderResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterBizId)) {
    query['ClusterBizId'] = request.clusterBizId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryScaleUpOrder',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/order/query_scale_up_order`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryScaleUpOrder(request: QueryScaleUpOrderRequest): QueryScaleUpOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryScaleUpOrderWithOptions(request, headers, runtime);
}

model QueryScaleUpPriceRequest {
  clusterBizId?: string(name='ClusterBizId'),
  coreNumber?: long(name='CoreNumber'),
  duration?: long(name='Duration'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  nodeGroupType?: string(name='NodeGroupType'),
  pricingCycle?: string(name='PricingCycle'),
}

model QueryScaleUpPriceResponseBody = {
  data?: {
    discountPrice?: float(name='DiscountPrice'),
    ecsPriceInfo?: {
      currency?: string(name='Currency'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      tradePrice?: float(name='TradePrice'),
    }(name='EcsPriceInfo'),
    softPriceInfo?: {
      currency?: string(name='Currency'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      tradePrice?: float(name='TradePrice'),
    }(name='SoftPriceInfo'),
    sumPrice?: float(name='SumPrice'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: long(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryScaleUpPriceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryScaleUpPriceResponseBody(name='body'),
}

async function queryScaleUpPriceWithOptions(request: QueryScaleUpPriceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryScaleUpPriceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterBizId)) {
    query['ClusterBizId'] = request.clusterBizId;
  }
  if (!Util.isUnset(request.coreNumber)) {
    query['CoreNumber'] = request.coreNumber;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.nodeGroupType)) {
    query['NodeGroupType'] = request.nodeGroupType;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryScaleUpPrice',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/buy/query_scale_up_price`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryScaleUpPrice(request: QueryScaleUpPriceRequest): QueryScaleUpPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryScaleUpPriceWithOptions(request, headers, runtime);
}

model ReleaseClusterRequest {
  instanceId?: string(name='InstanceId'),
}

model ReleaseClusterResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReleaseClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleaseClusterResponseBody(name='body'),
}

async function releaseClusterWithOptions(request: ReleaseClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ReleaseClusterResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseCluster',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/release`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseCluster(request: ReleaseClusterRequest): ReleaseClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return releaseClusterWithOptions(request, headers, runtime);
}

model RenewInstanceRequest {
  clusterBizId?: string(name='ClusterBizId'),
  instances?: string(name='Instances'),
}

model RenewInstanceResponseBody = {
  data?: {
    orderIds?: [ string ](name='OrderIds'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RenewInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenewInstanceResponseBody(name='body'),
}

async function renewInstanceWithOptions(request: RenewInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenewInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterBizId)) {
    query['ClusterBizId'] = request.clusterBizId;
  }
  if (!Util.isUnset(request.instances)) {
    query['Instances'] = request.instances;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenewInstance',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/order/renew_instance`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renewInstanceWithOptions(request, headers, runtime);
}

model ScaleUpClusterRequest {
  clusterBizId?: string(name='ClusterBizId'),
  coreNumber?: long(name='CoreNumber'),
  duration?: long(name='Duration'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  nodeGroupType?: string(name='NodeGroupType'),
  pricingCycle?: string(name='PricingCycle'),
}

model ScaleUpClusterResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: long(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ScaleUpClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ScaleUpClusterResponseBody(name='body'),
}

async function scaleUpClusterWithOptions(request: ScaleUpClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleUpClusterResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterBizId)) {
    query['ClusterBizId'] = request.clusterBizId;
  }
  if (!Util.isUnset(request.coreNumber)) {
    query['CoreNumber'] = request.coreNumber;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.nodeGroupType)) {
    query['NodeGroupType'] = request.nodeGroupType;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ScaleUpCluster',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/scale_up`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function scaleUpCluster(request: ScaleUpClusterRequest): ScaleUpClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleUpClusterWithOptions(request, headers, runtime);
}

model SearchClusterInstancesRequest {
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model SearchClusterInstancesResponseBody = {
  data?: [ 
    {
      beginTime?: long(name='BeginTime'),
      clusterBizId?: string(name='ClusterBizId'),
      clusterId?: string(name='ClusterId'),
      clusterInstanceInfo?: {
        controlCenterLoginName?: string(name='ControlCenterLoginName'),
        controlCenterUrl?: string(name='ControlCenterUrl'),
        sgId?: string(name='SgId'),
        vpcId?: string(name='VpcId'),
        vswId?: string(name='VswId'),
      }(name='ClusterInstanceInfo'),
      clusterName?: string(name='ClusterName'),
      clusterStatus?: string(name='ClusterStatus'),
      clusterStatusValue?: int32(name='ClusterStatusValue'),
      clusterType?: string(name='ClusterType'),
      controlCenterUrl?: string(name='ControlCenterUrl'),
      duration?: int32(name='Duration'),
      ecsGroupList?: [ 
        {
          cpuCount?: int32(name='CpuCount'),
          diskCapacity?: int32(name='DiskCapacity'),
          diskCount?: int32(name='DiskCount'),
          diskType?: string(name='DiskType'),
          hostGroupName?: string(name='HostGroupName'),
          hostGroupType?: string(name='HostGroupType'),
          instanceType?: string(name='InstanceType'),
          memorySize?: int32(name='MemorySize'),
          nodeCount?: int32(name='NodeCount'),
          systemDiskCapacity?: string(name='SystemDiskCapacity'),
          systemDiskCount?: int32(name='SystemDiskCount'),
          systemDiskType?: string(name='SystemDiskType'),
        }
      ](name='EcsGroupList'),
      expireTime?: long(name='ExpireTime'),
      failReason?: string(name='FailReason'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      instanceConf?: map[string]any(name='InstanceConf'),
      noticeConfirmed?: boolean(name='NoticeConfirmed'),
      orderBizId?: string(name='OrderBizId'),
      packageType?: string(name='PackageType'),
      pricingCycle?: string(name='PricingCycle'),
      regionId?: string(name='RegionId'),
      runningTime?: long(name='RunningTime'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model SearchClusterInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchClusterInstancesResponseBody(name='body'),
}

async function searchClusterInstancesWithOptions(request: SearchClusterInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchClusterInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchClusterInstances',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/order/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchClusterInstances(request: SearchClusterInstancesRequest): SearchClusterInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchClusterInstancesWithOptions(request, headers, runtime);
}

model SingleOrderRequest {
  instanceId?: string(name='InstanceId'),
}

model SingleOrderResponseBody = {
  data?: {
    clusterId?: string(name='ClusterId'),
    clusterSize?: int32(name='ClusterSize'),
    clusterStatus?: int32(name='ClusterStatus'),
    deployMode?: string(name='DeployMode'),
    duration?: int32(name='Duration'),
    ecsGroupList?: [ 
      {
        cpuCount?: int32(name='CpuCount'),
        diskCapacity?: int32(name='DiskCapacity'),
        diskCount?: int32(name='DiskCount'),
        diskType?: string(name='DiskType'),
        hostGroupName?: string(name='HostGroupName'),
        hostGroupType?: string(name='HostGroupType'),
        instanceType?: string(name='InstanceType'),
        memorySize?: int32(name='MemorySize'),
        nodeCount?: int32(name='NodeCount'),
        systemDiskCapacity?: int32(name='SystemDiskCapacity'),
        systemDiskCount?: int32(name='SystemDiskCount'),
        systemDiskType?: string(name='SystemDiskType'),
      }
    ](name='EcsGroupList'),
    instanceId?: string(name='InstanceId'),
    orderId?: string(name='OrderId'),
    packageType?: string(name='PackageType'),
    pricingCycle?: string(name='PricingCycle'),
    storageSize?: int32(name='StorageSize'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SingleOrderResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SingleOrderResponseBody(name='body'),
}

async function singleOrderWithOptions(request: SingleOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SingleOrderResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SingleOrder',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/order/single`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function singleOrder(request: SingleOrderRequest): SingleOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return singleOrderWithOptions(request, headers, runtime);
}

model UpdateClusterNameRequest {
  clusterBizId?: string(name='ClusterBizId'),
  clusterName?: string(name='ClusterName'),
}

model UpdateClusterNameResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateClusterNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateClusterNameResponseBody(name='body'),
}

async function updateClusterNameWithOptions(request: UpdateClusterNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateClusterNameResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterBizId)) {
    query['ClusterBizId'] = request.clusterBizId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateClusterName',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/cluster/update_name`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateClusterName(request: UpdateClusterNameRequest): UpdateClusterNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateClusterNameWithOptions(request, headers, runtime);
}

model UploadLicenseResponseBody = {
  data?: string(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model UploadLicenseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UploadLicenseResponseBody(name='body'),
}

async function uploadLicenseWithOptions(RegionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): UploadLicenseResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UploadLicense',
    version = '2021-04-02',
    protocol = 'HTTPS',
    pathname = `/webapi/user/upload`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadLicense(RegionId: string): UploadLicenseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return uploadLicenseWithOptions(RegionId, headers, runtime);
}

