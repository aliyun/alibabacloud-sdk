/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('cdp', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model CancelOrderRequest {
  instanceId?: string(name='InstanceId'),
}

model CancelOrderResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CancelOrderResponseBody(name='body'),
}

async function cancelOrder(request: CancelOrderRequest): CancelOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelOrderWithOptions(request, headers, runtime);
}

async function cancelOrderWithOptions(request: CancelOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelOrderResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query.InstanceId = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CancelOrder', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/order/cancel`, 'json', req, runtime);
}

model CheckClusterNameRequest {
  clusterName?: string(name='ClusterName'),
}

model CheckClusterNameResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckClusterNameResponse = {
  headers: map[string]string(name='headers'),
  body: CheckClusterNameResponseBody(name='body'),
}

async function checkClusterName(request: CheckClusterNameRequest): CheckClusterNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkClusterNameWithOptions(request, headers, runtime);
}

async function checkClusterNameWithOptions(request: CheckClusterNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckClusterNameResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterName)) {
    query.ClusterName = request.clusterName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CheckClusterName', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/check/cluster_name`, 'json', req, runtime);
}

model CheckServiceLinkedRoleForDeletingResponseBody = {
  data?: boolean(name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckServiceLinkedRoleForDeletingResponse = {
  headers: map[string]string(name='headers'),
  body: CheckServiceLinkedRoleForDeletingResponseBody(name='body'),
}

async function checkServiceLinkedRoleForDeleting(): CheckServiceLinkedRoleForDeletingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkServiceLinkedRoleForDeletingWithOptions(headers, runtime);
}

async function checkServiceLinkedRoleForDeletingWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): CheckServiceLinkedRoleForDeletingResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('CheckServiceLinkedRoleForDeleting', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/user/check_default_role`, 'json', req, runtime);
}

model ConfirmNoticeRequest {
  instanceId?: string(name='InstanceId'),
}

model ConfirmNoticeResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConfirmNoticeResponse = {
  headers: map[string]string(name='headers'),
  body: ConfirmNoticeResponseBody(name='body'),
}

async function confirmNotice(request: ConfirmNoticeRequest): ConfirmNoticeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return confirmNoticeWithOptions(request, headers, runtime);
}

async function confirmNoticeWithOptions(request: ConfirmNoticeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ConfirmNoticeResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query.InstanceId = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ConfirmNotice', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/cluster/confirm_notice`, 'json', req, runtime);
}

model CreateClusterRequest {
  clientToken?: string(name='ClientToken'),
  clusterInfo?: string(name='ClusterInfo'),
}

model CreateClusterResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterResponseBody(name='body'),
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createClusterWithOptions(request, headers, runtime);
}

async function createClusterWithOptions(request: CreateClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }
  if (!Util.isUnset(request.clusterInfo)) {
    query.ClusterInfo = request.clusterInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateCluster', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/cluster/create`, 'json', req, runtime);
}

model CreateDefaultRoleResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDefaultRoleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDefaultRoleResponseBody(name='body'),
}

async function createDefaultRole(ClientToken: string): CreateDefaultRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDefaultRoleWithOptions(ClientToken, headers, runtime);
}

async function createDefaultRoleWithOptions(ClientToken: string, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDefaultRoleResponse {
  ClientToken = OpenApiUtil.getEncodeParam(ClientToken);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('CreateDefaultRole', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/user/create_default_role`, 'json', req, runtime);
}

model CreateServiceLinkedRoleRequest {
  clientToken?: string(name='ClientToken'),
}

model CreateServiceLinkedRoleResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateServiceLinkedRoleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServiceLinkedRoleResponseBody(name='body'),
}

async function createServiceLinkedRole(request: CreateServiceLinkedRoleRequest): CreateServiceLinkedRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceLinkedRoleWithOptions(request, headers, runtime);
}

async function createServiceLinkedRoleWithOptions(request: CreateServiceLinkedRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceLinkedRoleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateServiceLinkedRole', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/user/create_default_role`, 'json', req, runtime);
}

model GetClusterDetailRequest {
  instanceId?: string(name='InstanceId'),
}

model GetClusterDetailResponseBody = {
  data?: {
    beginTime?: long(name='BeginTime'),
    clusterBizId?: string(name='ClusterBizId'),
    clusterId?: string(name='ClusterId'),
    clusterName?: string(name='ClusterName'),
    clusterStatus?: string(name='ClusterStatus'),
    clusterStatusValue?: int32(name='ClusterStatusValue'),
    controlCenterUrl?: string(name='ControlCenterUrl'),
    deployMode?: string(name='DeployMode'),
    duration?: int32(name='Duration'),
    ecsGroupList?: [ 
      {
        cpuCount?: int32(name='CpuCount'),
        diskCapacity?: int32(name='DiskCapacity'),
        diskCount?: int32(name='DiskCount'),
        diskType?: string(name='DiskType'),
        hostGroupName?: string(name='HostGroupName'),
        hostGroupType?: string(name='HostGroupType'),
        instanceType?: string(name='InstanceType'),
        memorySize?: int32(name='MemorySize'),
        nodeCount?: int32(name='NodeCount'),
        systemDiskCapacity?: string(name='SystemDiskCapacity'),
        systemDiskCount?: int32(name='SystemDiskCount'),
        systemDiskType?: string(name='SystemDiskType'),
      }
    ](name='EcsGroupList'),
    expireTime?: boolean(name='ExpireTime'),
    gmtCreate?: long(name='GmtCreate'),
    gmtModified?: long(name='GmtModified'),
    instanceConf?: map[string]any(name='InstanceConf'),
    orderBizId?: string(name='OrderBizId'),
    packageType?: string(name='PackageType'),
    pricingCycle?: string(name='PricingCycle'),
    regionId?: string(name='RegionId'),
    runningTime?: long(name='RunningTime'),
    zoneId?: string(name='ZoneId'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model GetClusterDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetClusterDetailResponseBody(name='body'),
}

async function getClusterDetail(request: GetClusterDetailRequest): GetClusterDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getClusterDetailWithOptions(request, headers, runtime);
}

async function getClusterDetailWithOptions(request: GetClusterDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetClusterDetailResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query.InstanceId = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetClusterDetail', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/cluster/detail`, 'json', req, runtime);
}

model HasDefaultRoleResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model HasDefaultRoleResponse = {
  headers: map[string]string(name='headers'),
  body: HasDefaultRoleResponseBody(name='body'),
}

async function hasDefaultRole(): HasDefaultRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return hasDefaultRoleWithOptions(headers, runtime);
}

async function hasDefaultRoleWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): HasDefaultRoleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('HasDefaultRole', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/user/has_default_role`, 'json', req, runtime);
}

model InitializeClouderaDataPlatformResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InitializeClouderaDataPlatformResponse = {
  headers: map[string]string(name='headers'),
  body: InitializeClouderaDataPlatformResponseBody(name='body'),
}

async function initializeClouderaDataPlatform(ClientToken: string): InitializeClouderaDataPlatformResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return initializeClouderaDataPlatformWithOptions(ClientToken, headers, runtime);
}

async function initializeClouderaDataPlatformWithOptions(ClientToken: string, headers: map[string]string, runtime: Util.RuntimeOptions): InitializeClouderaDataPlatformResponse {
  ClientToken = OpenApiUtil.getEncodeParam(ClientToken);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('InitializeClouderaDataPlatform', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/user/create_default_role`, 'json', req, runtime);
}

model ListNodesRequest {
  instanceId?: string(name='InstanceId'),
}

model ListNodesResponseBody = {
  data?: [ 
    {
      createTime?: long(name='CreateTime'),
      ecsNodeDtoList?: [ 
        {
          beginTime?: string(name='BeginTime'),
          cpuCount?: int32(name='CpuCount'),
          diskCapacity?: int32(name='DiskCapacity'),
          diskCount?: int32(name='DiskCount'),
          diskType?: string(name='DiskType'),
          expireTime?: long(name='ExpireTime'),
          gmtCreate?: string(name='GmtCreate'),
          gmtModified?: string(name='GmtModified'),
          index?: int32(name='Index'),
          instanceType?: string(name='InstanceType'),
          memorySize?: int32(name='MemorySize'),
          nodeGroupId?: string(name='NodeGroupId'),
          nodeGroupType?: string(name='NodeGroupType'),
          nodeId?: string(name='NodeId'),
          nodeName?: string(name='NodeName'),
          nodeResourceType?: string(name='NodeResourceType'),
          nodeStatus?: string(name='NodeStatus'),
          privateIp?: string(name='PrivateIp'),
          publicIp?: string(name='PublicIp'),
          runningTime?: long(name='RunningTime'),
          serialNumber?: string(name='SerialNumber'),
          systemDiskCapacity?: int32(name='SystemDiskCapacity'),
          systemDiskCount?: int32(name='SystemDiskCount'),
          systemDiskType?: string(name='SystemDiskType'),
        }
      ](name='EcsNodeDtoList'),
      expireTime?: long(name='ExpireTime'),
      instanceConf?: map[string]any(name='InstanceConf'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
    }
  ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesResponseBody(name='body'),
}

async function listNodes(request: ListNodesRequest): ListNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listNodesWithOptions(request, headers, runtime);
}

async function listNodesWithOptions(request: ListNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListNodesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query.InstanceId = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListNodes', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/cluster/nodes`, 'json', req, runtime);
}

model ListOperationsRequest {
  instanceId?: string(name='InstanceId'),
  parentOperationNodeId?: string(name='ParentOperationNodeId'),
}

model ListOperationsResponseBody = {
  data?: [ 
    {
      endTime?: long(name='EndTime'),
      hasChildOperationNodes?: boolean(name='HasChildOperationNodes'),
      hasOperationTask?: boolean(name='HasOperationTask'),
      operationId?: string(name='OperationId'),
      operationNodeId?: string(name='OperationNodeId'),
      operationNodeName?: int32(name='OperationNodeName'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
    }
  ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListOperationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListOperationsResponseBody(name='body'),
}

async function listOperations(request: ListOperationsRequest): ListOperationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOperationsWithOptions(request, headers, runtime);
}

async function listOperationsWithOptions(request: ListOperationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOperationsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query.InstanceId = request.instanceId;
  }
  if (!Util.isUnset(request.parentOperationNodeId)) {
    query.ParentOperationNodeId = request.parentOperationNodeId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListOperations', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/cluster/operations`, 'json', req, runtime);
}

model ListRegionsResponseBody = {
  data?: [ 
    {
      description?: string(name='Description'),
      regionId?: string(name='RegionId'),
      regionName?: string(name='RegionName'),
    }
  ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRegionsResponseBody(name='body'),
}

async function listRegions(): ListRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRegionsWithOptions(headers, runtime);
}

async function listRegionsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListRegionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListRegions', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/region/list`, 'json', req, runtime);
}

model ListSecurityGroupsRequest {
  vpcId?: string(name='VpcId'),
}

model ListSecurityGroupsResponseBody = {
  data?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupName?: string(name='SecurityGroupName'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListSecurityGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecurityGroupsResponseBody(name='body'),
}

async function listSecurityGroups(request: ListSecurityGroupsRequest): ListSecurityGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSecurityGroupsWithOptions(request, headers, runtime);
}

async function listSecurityGroupsWithOptions(request: ListSecurityGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSecurityGroupsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.vpcId)) {
    query.VpcId = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListSecurityGroups', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/user/security_groups`, 'json', req, runtime);
}

model ListVpcsRequest {
  regionId?: string(name='RegionId'),
}

model ListVpcsResponseBody = {
  data?: [ 
    {
      cidrBlock?: string(name='CidrBlock'),
      description?: string(name='Description'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
    }
  ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListVpcsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcsResponseBody(name='body'),
}

async function listVpcs(request: ListVpcsRequest): ListVpcsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVpcsWithOptions(request, headers, runtime);
}

async function listVpcsWithOptions(request: ListVpcsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListVpcsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.regionId)) {
    query.RegionId = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListVpcs', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/user/vpcs`, 'json', req, runtime);
}

model ListVswitchesRequest {
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model ListVswitchesResponseBody = {
  data?: [ 
    {
      availableIpAddressCount?: long(name='AvailableIpAddressCount'),
      cidrBlock?: string(name='CidrBlock'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      isDefault?: boolean(name='IsDefault'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vSwitchName?: string(name='VSwitchName'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListVswitchesResponse = {
  headers: map[string]string(name='headers'),
  body: ListVswitchesResponseBody(name='body'),
}

async function listVswitches(request: ListVswitchesRequest): ListVswitchesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVswitchesWithOptions(request, headers, runtime);
}

async function listVswitchesWithOptions(request: ListVswitchesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListVswitchesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.regionId)) {
    query.RegionId = request.regionId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query.VpcId = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query.ZoneId = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListVswitches', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/user/vswitches`, 'json', req, runtime);
}

model ListZonesRequest {
  regionId?: string(name='RegionId'),
}

model ListZonesResponseBody = {
  data?: [ string ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListZonesResponse = {
  headers: map[string]string(name='headers'),
  body: ListZonesResponseBody(name='body'),
}

async function listZones(request: ListZonesRequest): ListZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listZonesWithOptions(request, headers, runtime);
}

async function listZonesWithOptions(request: ListZonesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListZonesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.regionId)) {
    query.RegionId = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListZones', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/user/zones`, 'json', req, runtime);
}

model QueryOrderRequest {
  instanceId?: string(name='InstanceId'),
}

model QueryOrderResponseBody = {
  data?: [ 
    {
      instanceIds?: [ string ](name='InstanceIds'),
      orderId?: string(name='OrderId'),
      orderStatus?: string(name='OrderStatus'),
      orderType?: string(name='OrderType'),
    }
  ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryOrderResponse = {
  headers: map[string]string(name='headers'),
  body: QueryOrderResponseBody(name='body'),
}

async function queryOrder(request: QueryOrderRequest): QueryOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryOrderWithOptions(request, headers, runtime);
}

async function queryOrderWithOptions(request: QueryOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryOrderResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query.InstanceId = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('QueryOrder', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/order/query`, 'json', req, runtime);
}

model QueryPriceRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model QueryPriceResponseBody = {
  data?: {
    currency?: string(name='Currency'),
    discountPrice?: float(name='DiscountPrice'),
    originalPrice?: float(name='OriginalPrice'),
    tradePrice?: float(name='TradePrice'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryPriceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryPriceResponseBody(name='body'),
}

async function queryPrice(request: QueryPriceRequest): QueryPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryPriceWithOptions(request, headers, runtime);
}

async function queryPriceWithOptions(request: QueryPriceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryPriceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query.InstanceId = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query.RegionId = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('QueryPrice', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/buy/query_price`, 'json', req, runtime);
}

model QueryRenewOrderRequest {
  instanceId?: string(name='InstanceId'),
}

model QueryRenewOrderResponseBody = {
  data?: [ long ](name='Data'),
  errMessage?: string(name='ErrMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryRenewOrderResponse = {
  headers: map[string]string(name='headers'),
  body: QueryRenewOrderResponseBody(name='body'),
}

async function queryRenewOrder(request: QueryRenewOrderRequest): QueryRenewOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryRenewOrderWithOptions(request, headers, runtime);
}

async function queryRenewOrderWithOptions(request: QueryRenewOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryRenewOrderResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query.InstanceId = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('QueryRenewOrder', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/order/query_renew_order`, 'json', req, runtime);
}

model QueryRenewPriceRequest {
  duration?: int32(name='Duration'),
  instanceId?: string(name='InstanceId'),
  pricingCycle?: string(name='PricingCycle'),
}

model QueryRenewPriceResponseBody = {
  data?: {
    cdpSoftPriceInfo?: {
      currency?: string(name='Currency'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      tradePrice?: float(name='TradePrice'),
    }(name='CdpSoftPriceInfo'),
    discountPrice?: float(name='DiscountPrice'),
    ecsPriceInfo?: {
      currency?: string(name='Currency'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      tradePrice?: float(name='TradePrice'),
    }(name='EcsPriceInfo'),
    sumPrice?: float(name='SumPrice'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryRenewPriceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryRenewPriceResponseBody(name='body'),
}

async function queryRenewPrice(request: QueryRenewPriceRequest): QueryRenewPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryRenewPriceWithOptions(request, headers, runtime);
}

async function queryRenewPriceWithOptions(request: QueryRenewPriceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryRenewPriceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.duration)) {
    query.Duration = request.duration;
  }
  if (!Util.isUnset(request.instanceId)) {
    query.InstanceId = request.instanceId;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query.PricingCycle = request.pricingCycle;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('QueryRenewPrice', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/buy/query_renew_price`, 'json', req, runtime);
}

model QueryScaleUpOrderRequest {
  instanceId?: string(name='InstanceId', description='A short description of struct'),
}

model QueryScaleUpOrderResponseBody = {
  data?: [ long ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: long(name='HttpStatusCode'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model QueryScaleUpOrderResponse = {
  headers: map[string]string(name='headers'),
  body: QueryScaleUpOrderResponseBody(name='body'),
}

async function queryScaleUpOrder(request: QueryScaleUpOrderRequest): QueryScaleUpOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryScaleUpOrderWithOptions(request, headers, runtime);
}

async function queryScaleUpOrderWithOptions(request: QueryScaleUpOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryScaleUpOrderResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query.InstanceId = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('QueryScaleUpOrder', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/order/query_scale_up_order`, 'json', req, runtime);
}

model QueryScaleUpPriceRequest {
  coreNumber?: long(name='CoreNumber'),
  duration?: long(name='Duration'),
  instanceId?: string(name='InstanceId', description='A short description of struct'),
  instanceType?: string(name='InstanceType'),
  pricingCycle?: string(name='PricingCycle'),
}

model QueryScaleUpPriceResponseBody = {
  data?: {
    discountPrice?: float(name='DiscountPrice'),
    ecsPriceInfo?: {
      currency?: string(name='Currency'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      tradePrice?: float(name='TradePrice'),
    }(name='EcsPriceInfo', description='Id of the request'),
    softPriceInfo?: {
      currency?: string(name='Currency'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      tradePrice?: float(name='TradePrice'),
    }(name='SoftPriceInfo'),
    sumPrice?: float(name='SumPrice'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: long(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryScaleUpPriceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryScaleUpPriceResponseBody(name='body'),
}

async function queryScaleUpPrice(request: QueryScaleUpPriceRequest): QueryScaleUpPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryScaleUpPriceWithOptions(request, headers, runtime);
}

async function queryScaleUpPriceWithOptions(request: QueryScaleUpPriceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryScaleUpPriceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.coreNumber)) {
    query.CoreNumber = request.coreNumber;
  }
  if (!Util.isUnset(request.duration)) {
    query.Duration = request.duration;
  }
  if (!Util.isUnset(request.instanceId)) {
    query.InstanceId = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query.InstanceType = request.instanceType;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query.PricingCycle = request.pricingCycle;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('QueryScaleUpPrice', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/buy/query_scale_up_price`, 'json', req, runtime);
}

model ReleaseClusterRequest {
  instanceId?: string(name='InstanceId'),
}

model ReleaseClusterResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReleaseClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseClusterResponseBody(name='body'),
}

async function releaseCluster(request: ReleaseClusterRequest): ReleaseClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return releaseClusterWithOptions(request, headers, runtime);
}

async function releaseClusterWithOptions(request: ReleaseClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ReleaseClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query.InstanceId = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ReleaseCluster', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/cluster/release`, 'json', req, runtime);
}

model RenewInstanceRequest {
  duration?: int32(name='Duration'),
  instanceId?: string(name='InstanceId'),
  pricingCycle?: string(name='PricingCycle'),
}

model RenewInstanceResponseBody = {
  data?: {
    orderIds?: [ string ](name='OrderIds'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renewInstanceWithOptions(request, headers, runtime);
}

async function renewInstanceWithOptions(request: RenewInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenewInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.duration)) {
    query.Duration = request.duration;
  }
  if (!Util.isUnset(request.instanceId)) {
    query.InstanceId = request.instanceId;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query.PricingCycle = request.pricingCycle;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('RenewInstance', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/order/renew_instance`, 'json', req, runtime);
}

model ScaleUpClusterRequest {
  coreNumber?: long(name='CoreNumber'),
  duration?: long(name='Duration'),
  instanceId?: string(name='InstanceId', description='A short description of struct'),
  instanceType?: string(name='InstanceType'),
  nodeGroupId?: string(name='NodeGroupId'),
  pricingCycle?: string(name='PricingCycle'),
}

model ScaleUpClusterResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: long(name='HttpStatusCode'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ScaleUpClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ScaleUpClusterResponseBody(name='body'),
}

async function scaleUpCluster(request: ScaleUpClusterRequest): ScaleUpClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleUpClusterWithOptions(request, headers, runtime);
}

async function scaleUpClusterWithOptions(request: ScaleUpClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleUpClusterResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.coreNumber)) {
    query.CoreNumber = request.coreNumber;
  }
  if (!Util.isUnset(request.duration)) {
    query.Duration = request.duration;
  }
  if (!Util.isUnset(request.instanceId)) {
    query.InstanceId = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query.InstanceType = request.instanceType;
  }
  if (!Util.isUnset(request.nodeGroupId)) {
    query.NodeGroupId = request.nodeGroupId;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query.PricingCycle = request.pricingCycle;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ScaleUpCluster', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/cluster/scale_up`, 'json', req, runtime);
}

model SearchClusterInstancesRequest {
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model SearchClusterInstancesResponseBody = {
  data?: [ 
    {
      beginTime?: long(name='BeginTime'),
      clusterBizId?: string(name='ClusterBizId'),
      clusterId?: string(name='ClusterId'),
      clusterInstanceInfo?: {
        controlCenterLoginName?: string(name='ControlCenterLoginName'),
        controlCenterUrl?: string(name='ControlCenterUrl'),
        sgId?: string(name='SgId'),
        vpcId?: string(name='VpcId'),
        vswId?: string(name='VswId'),
      }(name='ClusterInstanceInfo'),
      clusterName?: string(name='ClusterName'),
      clusterStatus?: string(name='ClusterStatus'),
      clusterStatusValue?: int32(name='ClusterStatusValue'),
      controlCenterUrl?: string(name='ControlCenterUrl'),
      duration?: int32(name='Duration'),
      ecsGroupList?: [ 
        {
          cpuCount?: int32(name='CpuCount'),
          diskCapacity?: int32(name='DiskCapacity'),
          diskCount?: int32(name='DiskCount'),
          diskType?: string(name='DiskType'),
          hostGroupName?: string(name='HostGroupName'),
          hostGroupType?: string(name='HostGroupType'),
          instanceType?: string(name='InstanceType'),
          memorySize?: int32(name='MemorySize'),
          nodeCount?: int32(name='NodeCount'),
          systemDiskCapacity?: string(name='SystemDiskCapacity'),
          systemDiskCount?: int32(name='SystemDiskCount'),
          systemDiskType?: string(name='SystemDiskType'),
        }
      ](name='EcsGroupList'),
      expireTime?: long(name='ExpireTime'),
      failReason?: string(name='FailReason'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      instanceConf?: map[string]any(name='InstanceConf'),
      noticeConfirmed?: boolean(name='NoticeConfirmed'),
      orderBizId?: string(name='OrderBizId'),
      packageType?: string(name='PackageType'),
      pricingCycle?: string(name='PricingCycle'),
      regionId?: string(name='RegionId'),
      runningTime?: long(name='RunningTime'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model SearchClusterInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: SearchClusterInstancesResponseBody(name='body'),
}

async function searchClusterInstances(request: SearchClusterInstancesRequest): SearchClusterInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchClusterInstancesWithOptions(request, headers, runtime);
}

async function searchClusterInstancesWithOptions(request: SearchClusterInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchClusterInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query.ClusterId = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query.ClusterName = request.clusterName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query.PageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('SearchClusterInstances', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/order/list`, 'json', req, runtime);
}

model SingleOrderRequest {
  instanceId?: string(name='InstanceId'),
}

model SingleOrderResponseBody = {
  data?: {
    clusterId?: string(name='ClusterId'),
    clusterSize?: int32(name='ClusterSize'),
    clusterStatus?: int32(name='ClusterStatus'),
    deployMode?: string(name='DeployMode'),
    duration?: int32(name='Duration'),
    ecsGroupList?: [ 
      {
        cpuCount?: int32(name='CpuCount'),
        diskCapacity?: int32(name='DiskCapacity'),
        diskCount?: int32(name='DiskCount'),
        diskType?: string(name='DiskType'),
        hostGroupName?: string(name='HostGroupName'),
        hostGroupType?: string(name='HostGroupType'),
        instanceType?: string(name='InstanceType'),
        memorySize?: int32(name='MemorySize'),
        nodeCount?: int32(name='NodeCount'),
        systemDiskCapacity?: int32(name='SystemDiskCapacity'),
        systemDiskCount?: int32(name='SystemDiskCount'),
        systemDiskType?: string(name='SystemDiskType'),
      }
    ](name='EcsGroupList'),
    instanceId?: string(name='InstanceId'),
    orderId?: string(name='OrderId'),
    packageType?: string(name='PackageType'),
    pricingCycle?: string(name='PricingCycle'),
    storageSize?: int32(name='StorageSize'),
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SingleOrderResponse = {
  headers: map[string]string(name='headers'),
  body: SingleOrderResponseBody(name='body'),
}

async function singleOrder(request: SingleOrderRequest): SingleOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return singleOrderWithOptions(request, headers, runtime);
}

async function singleOrderWithOptions(request: SingleOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SingleOrderResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query.InstanceId = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('SingleOrder', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/order/single`, 'json', req, runtime);
}

model UpdateClusterNameRequest {
  clusterName?: string(name='ClusterName'),
  instanceId?: string(name='InstanceId'),
}

model UpdateClusterNameResponseBody = {
  data?: boolean(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateClusterNameResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateClusterNameResponseBody(name='body'),
}

async function updateClusterName(request: UpdateClusterNameRequest): UpdateClusterNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateClusterNameWithOptions(request, headers, runtime);
}

async function updateClusterNameWithOptions(request: UpdateClusterNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateClusterNameResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterName)) {
    query.ClusterName = request.clusterName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query.InstanceId = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateClusterName', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/cluster/update_name`, 'json', req, runtime);
}

model UploadLicenseResponseBody = {
  data?: string(name='Data'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model UploadLicenseResponse = {
  headers: map[string]string(name='headers'),
  body: UploadLicenseResponseBody(name='body'),
}

async function uploadLicense(RegionId: string): UploadLicenseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return uploadLicenseWithOptions(RegionId, headers, runtime);
}

async function uploadLicenseWithOptions(RegionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): UploadLicenseResponse {
  RegionId = OpenApiUtil.getEncodeParam(RegionId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('UploadLicense', '2021-04-02', 'HTTPS', 'POST', 'AK', `/webapi/user/upload`, 'json', req, runtime);
}

