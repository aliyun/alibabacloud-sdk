/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('nlb', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddServersToServerGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** of each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether only to precheck the request. Valid values:

*   **true**: prechecks the request but does not add the servers to the server group. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.', example='false'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-atstuj3rtoptyui****'),
  servers?: [ 
    {
      description?: string(name='Description', description='The description of the servers.

The description must be 2 to 256 characters in length, and can contain letters, digits, commas (,), periods (.), semicolons (;), forward slashes (/), at signs (@), underscores (\\_), and hyphens (-).

>  You can specify at most 40 servers in each call.', example='ECS'),
      port?: int32(name='Port', description='The port used by the backend server. Valid values: **1** to **65535**.

>  You can specify at most 40 servers in each call.', example='443'),
      serverId?: string(name='ServerId', description='The ID of the server. You can specify at most 40 server IDs in each call.

*   If the server group type is **Instance**, set the ServerId parameter to the ID of an Elastic Compute Service (ECS) instance, an elastic network interface (ENI), or an elastic container instance. These backend servers are specified by **Ecs**, **Eni**, or **Eci**.
*   If the server group type is **Ip**, set the ServerId parameter to an IP address.', example='ecs-bp67acfmxazb4p****'),
      serverIp?: string(name='ServerIp', description='The IP address of the server. If the server group type is **Ip**, set the ServerId parameter to an IP address.

>  You can specify at most 40 server IP addresses in each call.', example='192.168.6.6'),
      serverType?: string(name='ServerType', description='The type of the backend server. Valid values:

*   **Ecs**: an ECS instance
*   **Eni**: an ENI
*   **Eci**: an elastic container instance
*   **Ip**: an IP address

>  You can specify at most 40 servers in each call.', example='Ecs'),
      weight?: int32(name='Weight', description='The weight of the backend server. Valid values: **0** to **100**. Default value: **100**. If the weight of a backend server is set to **0**, no requests are forwarded to the backend server.

>  You can specify at most 40 servers in each call.', example='100'),
    }
  ](name='Servers'),
}

model AddServersToServerGroupResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-atstuj3rtoptyui****'),
}

model AddServersToServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddServersToServerGroupResponseBody(name='body'),
}

async function addServersToServerGroupWithOptions(request: AddServersToServerGroupRequest, runtime: Util.RuntimeOptions): AddServersToServerGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.servers)) {
    bodyFlat['Servers'] = request.servers;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddServersToServerGroup',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addServersToServerGroup(request: AddServersToServerGroupRequest): AddServersToServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addServersToServerGroupWithOptions(request, runtime);
}

model AssociateAdditionalCertificatesWithListenerRequest {
  additionalCertificateIds?: [ string ](name='AdditionalCertificateIds'),
  clientToken?: string(name='ClientToken', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', example='true'),
  listenerId?: string(name='ListenerId', example='lsr-bp1bpn0kn908w4nbw****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model AssociateAdditionalCertificatesWithListenerResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model AssociateAdditionalCertificatesWithListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateAdditionalCertificatesWithListenerResponseBody(name='body'),
}

async function associateAdditionalCertificatesWithListenerWithOptions(request: AssociateAdditionalCertificatesWithListenerRequest, runtime: Util.RuntimeOptions): AssociateAdditionalCertificatesWithListenerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.additionalCertificateIds)) {
    body['AdditionalCertificateIds'] = request.additionalCertificateIds;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    body['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AssociateAdditionalCertificatesWithListener',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateAdditionalCertificatesWithListener(request: AssociateAdditionalCertificatesWithListenerRequest): AssociateAdditionalCertificatesWithListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateAdditionalCertificatesWithListenerWithOptions(request, runtime);
}

model AttachCommonBandwidthPackageToLoadBalancerRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId', description='The ID of the EIP bandwidth plan.', example='cbwp-bp1pzf0ym72pu3y76****'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** of each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether only to precheck the request. Valid values:

*   **true**: prechecks the request but does not associate the EIP bandwidth plan with the NLB instance. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.', example='false'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the NLB instance.', example='nlb-83ckzc8d4xlp8o****'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
}

model AttachCommonBandwidthPackageToLoadBalancerResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model AttachCommonBandwidthPackageToLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachCommonBandwidthPackageToLoadBalancerResponseBody(name='body'),
}

async function attachCommonBandwidthPackageToLoadBalancerWithOptions(request: AttachCommonBandwidthPackageToLoadBalancerRequest, runtime: Util.RuntimeOptions): AttachCommonBandwidthPackageToLoadBalancerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    body['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AttachCommonBandwidthPackageToLoadBalancer',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachCommonBandwidthPackageToLoadBalancer(request: AttachCommonBandwidthPackageToLoadBalancerRequest): AttachCommonBandwidthPackageToLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachCommonBandwidthPackageToLoadBalancerWithOptions(request, runtime);
}

model CreateListenerRequest {
  alpnEnabled?: boolean(name='AlpnEnabled', description='Specifies whether to enable Application-Layer Protocol Negotiation (ALPN). Valid values:

*   **true**: yes
*   **false** (default): no', example='false'),
  alpnPolicy?: string(name='AlpnPolicy', description='The ALPN policy.', example='ALPN'),
  caCertificateIds?: [ string ](name='CaCertificateIds'),
  caEnabled?: boolean(name='CaEnabled', description='Specifies whether to enable mutual authentication. Valid values:

*   **true**: yes
*   **false** (default): no', example='false'),
  certificateIds?: [ string ](name='CertificateIds'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.', example='123e4567-e89b-12d3-a456-426655440000'),
  cps?: int32(name='Cps', description='The maximum number of connections that can be created per second on the NLB instance. Valid values: **0** to **1000000**. **0** specifies that the number of connections is unlimited.', example='100'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to only precheck this request. Valid values:

*   **true**: prechecks the request without creating the resource. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  endPort?: int32(name='EndPort', description='The last port in the listening port range. Valid values: **0** to **65535**.

The number of the last port must be larger than that of the first port.', example='566'),
  idleTimeout?: int32(name='IdleTimeout', description='The timeout period of an idle connection. Unit: seconds.

Valid values: **1** to **900**. Default value: **900**.', example='900'),
  listenerDescription?: string(name='ListenerDescription', description='The name of the listener.

The name must be 2 to 256 characters in length, and can contain letters, digits, commas (,), periods (.), semicolons (;), forward slashes (/), at signs (@), underscores (\\_), and hyphens (-).', example='tcp_80'),
  listenerPort?: int32(name='ListenerPort', description='The listening port. Valid values: **0** to **65535**.

If you set the value to **0**, the listener listens by port range. If you set the value to **0**, you must also set the **StartPort** and **EndPort** parameters.', example='80'),
  listenerProtocol?: string(name='ListenerProtocol', description='The listening protocol. Valid values: **TCP**, **UDP**, and **TCPSSL**.', example='TCP'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the NLB instance.', example='nlb-83ckzc8d4xlp8o****'),
  mss?: int32(name='Mss', description='The maximum size of a TCP segment. Unit: bytes. Valid values: **0** to **1500**.

**0** specifies that the maximum segment size remains unchanged.

>  This parameter is supported only by listeners that use SSL over TCP.', example='43'),
  proxyProtocolEnabled?: boolean(name='ProxyProtocolEnabled', description='Specifies whether to use the Proxy protocol to pass client IP addresses to backend servers. Valid values:

*   **true**: yes
*   **false** (default): no', example='false'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  secSensorEnabled?: boolean(name='SecSensorEnabled', description='Specifies whether to enable fine-grained monitoring. Valid values:

*   **true**: yes
*   **false** (default): no', example='false'),
  securityPolicyId?: string(name='SecurityPolicyId', description='The ID of the security policy. System security policies and custom security policies are supported.

Valid values: **tls_cipher_policy\\_1\\_0** (default), **tls_cipher_policy\\_1\\_1**, **tls_cipher_policy\\_1\\_2**, **tls_cipher_policy\\_1\\_2\\_strict**, and **tls_cipher_policy\\_1\\_2\\_strict_with\\_1\\_3**.

>  This parameter takes effect only for listeners that use SSL over TCP.', example='tls_cipher_policy_1_0'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-ppdpc14gdm3x4o****'),
  startPort?: int32(name='StartPort', description='The first port in the listening port range. Valid values: **0** to **65535**.', example='244'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model CreateListenerResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  listenerId?: string(name='ListenerId', description='The ID of the listener.', example='lsn-bp1bpn0kn908w4nbw****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model CreateListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateListenerResponseBody(name='body'),
}

async function createListenerWithOptions(request: CreateListenerRequest, runtime: Util.RuntimeOptions): CreateListenerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alpnEnabled)) {
    body['AlpnEnabled'] = request.alpnEnabled;
  }
  if (!Util.isUnset(request.alpnPolicy)) {
    body['AlpnPolicy'] = request.alpnPolicy;
  }
  if (!Util.isUnset(request.caCertificateIds)) {
    body['CaCertificateIds'] = request.caCertificateIds;
  }
  if (!Util.isUnset(request.caEnabled)) {
    body['CaEnabled'] = request.caEnabled;
  }
  if (!Util.isUnset(request.certificateIds)) {
    body['CertificateIds'] = request.certificateIds;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.cps)) {
    body['Cps'] = request.cps;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.endPort)) {
    body['EndPort'] = request.endPort;
  }
  if (!Util.isUnset(request.idleTimeout)) {
    body['IdleTimeout'] = request.idleTimeout;
  }
  if (!Util.isUnset(request.listenerDescription)) {
    body['ListenerDescription'] = request.listenerDescription;
  }
  if (!Util.isUnset(request.listenerPort)) {
    body['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    body['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.mss)) {
    body['Mss'] = request.mss;
  }
  if (!Util.isUnset(request.proxyProtocolEnabled)) {
    body['ProxyProtocolEnabled'] = request.proxyProtocolEnabled;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.secSensorEnabled)) {
    body['SecSensorEnabled'] = request.secSensorEnabled;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    body['SecurityPolicyId'] = request.securityPolicyId;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.startPort)) {
    body['StartPort'] = request.startPort;
  }
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateListener',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createListener(request: CreateListenerRequest): CreateListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createListenerWithOptions(request, runtime);
}

model CreateLoadBalancerRequest {
  addressIpVersion?: string(name='AddressIpVersion', description='The protocol version. Valid values:

*   **ipv4:** IPv4. This is the default value.
*   **DualStack:** dual stack.', example='ipv4'),
  addressType?: string(name='AddressType', description='The type of IPv4 address used by the NLB instance. Valid values:

*   **Internet**: The NLB instance uses a public IP address. The domain name of the NLB instance is resolved to the public IP address. Therefore, the NLB instance can be accessed over the Internet.
*   **Intranet**: The NLB instance uses a private IP address. The domain name of the NLB instance is resolved to the private IP address. Therefore, the NLB instance can be accessed over the virtual private cloud (VPC) where the NLB instance is deployed.

>  To enable a public IPv6 address for an NLB instance, call the [EnableLoadBalancerIpv6Internet](~~445878~~) operation.', example='Internet'),
  bandwidthPackageId?: string(name='BandwidthPackageId', description='The ID of the EIP bandwidth plan that is associated with the Internet-facing NLB instance.', example='cbwp-bp1vevu8h3ieh****'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request is different.', example='123e4567-e89b-12d3-a456-426655440000'),
  deletionProtectionConfig?: {
    enabled?: boolean(name='Enabled', description='Specifies whether to enable deletion protection. Valid values:

*   **true**: yes
*   **false** (default): no', example='false'),
    reason?: string(name='Reason', description='The reason why the deletion protection feature is enabled or disabled. The value must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The value must start with a letter.', example='The instance is running'),
  }(name='DeletionProtectionConfig', description='The configuration of the deletion protection feature.'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run. Valid values:

*   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false**: performs a dry run and sends the request. This is the default value. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  loadBalancerBillingConfig?: {
    payType?: string(name='PayType', description='The billing method of the NLB instance.

Set the value to **PostPay**, which specifies the pay-as-you-go billing method.', example='PostPay'),
  }(name='LoadBalancerBillingConfig', description='The billing settings of the NLB instance.'),
  loadBalancerName?: string(name='LoadBalancerName', description='The name of the NLB instance.

The value must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The value must start with a letter.', example='NLB1'),
  loadBalancerType?: string(name='LoadBalancerType', description='The type of the instance. Set the value to **network**, which specifies an NLB instance.', example='network'),
  modificationProtectionConfig?: {
    reason?: string(name='Reason', description='The reason why the configuration read-only mode is enabled. The value must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The value must start with a letter.

>  This parameter takes effect only if the **Status** parameter is set to **ConsoleProtection**.', example='Service guarantee period'),
    status?: string(name='Status', description='Specifies whether to enable the configuration read-only mode. Valid values:

*   **NonProtection**: does not enable the configuration read-only mode. You cannot set the **Reason** parameter. If the **Reason** parameter is set, the value is cleared.
*   **ConsoleProtection**: enables the configuration read-only mode. You can set the **Reason** parameter.

>  If you set this parameter to **ConsoleProtection**, you cannot use the NLB console to modify instance configurations. However, you can call API operations to modify instance configurations.', example='ConsoleProtection'),
  }(name='ModificationProtectionConfig', description='The configuration of the configuration read-only mode.'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-atstuj3rtop****'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vpcId?: string(name='VpcId', description='The ID of the VPC where the NLB instance is deployed.', example='vpc-bp1b49rqrybk45nio****'),
  zoneMappings?: [ 
    {
      allocationId?: string(name='AllocationId', description='The ID of the elastic IP address (EIP) that is associated with the Internet-facing NLB instance. You can specify one EIP for each zone. You must add at least two zones. You can add a maximum of 10 zones.', example='eip-bp1aedxso6u80u0qf****'),
      privateIPv4Address?: string(name='PrivateIPv4Address', description='The private IP address. You must add at least two zones. You can add a maximum of 10 zones.', example='192.168.10.1'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch in the zone. You can specify only one vSwitch (subnet) in each zone of an NLB instance. You must add at least two zones. You can add a maximum of 10 zones.', example='vsw-sersdf****'),
      zoneId?: string(name='ZoneId', description='The ID of the zone of the NLB instance. You must add at least two zones. You can add a maximum of 10 zones.

You can call the [DescribeZones](~~443890~~) operation to query the most recent zone list.', example='cn-hangzhou-a'),
    }
  ](name='ZoneMappings', description='The mappings between zones and vSwitches. You must add at least two zones. You can add a maximum of 10 zones.'),
}

model CreateLoadBalancerResponseBody = {
  loadbalancerId?: string(name='LoadbalancerId', description='The ID of the NLB instance.', example='nlb-83ckzc8d4xlp8o****'),
  orderId?: long(name='OrderId', description='The ID of the order for the NLB instance.', example='20230000'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model CreateLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLoadBalancerResponseBody(name='body'),
}

/**
  * *   When you create an NLB instance, the service-linked role AliyunServiceRoleForNlb is automatically created and assigned to you.
  * *   **CreateLoadBalancer** is an asynchronous operation. After you send a request, the system returns an instance ID and runs the task in the background. You can call [GetLoadBalancerAttribute](~~445873~~) to query the status of an NLB instance.
  *     *   If an NLB instance is in the **Provisioning** state, the NLB instance is being created.
  *     *   If an NLB instance is in the **Active** state, the NLB instance is created.
  *
  * @param request CreateLoadBalancerRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateLoadBalancerResponse
 */
async function createLoadBalancerWithOptions(request: CreateLoadBalancerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.addressIpVersion)) {
    body['AddressIpVersion'] = request.addressIpVersion;
  }
  if (!Util.isUnset(request.addressType)) {
    body['AddressType'] = request.addressType;
  }
  if (!Util.isUnset(request.bandwidthPackageId)) {
    body['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.deletionProtectionConfig)) {
    bodyFlat['DeletionProtectionConfig'] = request.deletionProtectionConfig;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerBillingConfig)) {
    bodyFlat['LoadBalancerBillingConfig'] = request.loadBalancerBillingConfig;
  }
  if (!Util.isUnset(request.loadBalancerName)) {
    body['LoadBalancerName'] = request.loadBalancerName;
  }
  if (!Util.isUnset(request.loadBalancerType)) {
    body['LoadBalancerType'] = request.loadBalancerType;
  }
  if (!Util.isUnset(request.modificationProtectionConfig)) {
    bodyFlat['ModificationProtectionConfig'] = request.modificationProtectionConfig;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneMappings)) {
    bodyFlat['ZoneMappings'] = request.zoneMappings;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLoadBalancer',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   When you create an NLB instance, the service-linked role AliyunServiceRoleForNlb is automatically created and assigned to you.
  * *   **CreateLoadBalancer** is an asynchronous operation. After you send a request, the system returns an instance ID and runs the task in the background. You can call [GetLoadBalancerAttribute](~~445873~~) to query the status of an NLB instance.
  *     *   If an NLB instance is in the **Provisioning** state, the NLB instance is being created.
  *     *   If an NLB instance is in the **Active** state, the NLB instance is created.
  *
  * @param request CreateLoadBalancerRequest
  * @return CreateLoadBalancerResponse
 */
async function createLoadBalancer(request: CreateLoadBalancerRequest): CreateLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerWithOptions(request, runtime);
}

model CreateSecurityPolicyRequest {
  ciphers?: [ string ](name='Ciphers'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether only to precheck the request. Valid values:

*   **true**: checks the request but does not create the security policy. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.', example='false'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-atstuj3rtop****'),
  securityPolicyName?: string(name='SecurityPolicyName', description='The name of the security policy.

The name must be 1 to 200 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-).', example='TLSCipherPolicy'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  tlsVersions?: [ string ](name='TlsVersions'),
}

model CreateSecurityPolicyResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='D7A8875F-373A-5F48-8484-25B07A61F2AF'),
  securityPolicyId?: string(name='SecurityPolicyId', description='The ID of the TLS security policy.', example='tls-bp14bb1e7dll4f****'),
}

model CreateSecurityPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSecurityPolicyResponseBody(name='body'),
}

async function createSecurityPolicyWithOptions(request: CreateSecurityPolicyRequest, runtime: Util.RuntimeOptions): CreateSecurityPolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ciphers)) {
    body['Ciphers'] = request.ciphers;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.securityPolicyName)) {
    body['SecurityPolicyName'] = request.securityPolicyName;
  }
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.tlsVersions)) {
    body['TlsVersions'] = request.tlsVersions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSecurityPolicy',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSecurityPolicy(request: CreateSecurityPolicyRequest): CreateSecurityPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSecurityPolicyWithOptions(request, runtime);
}

model CreateServerGroupRequest {
  addressIPVersion?: string(name='AddressIPVersion', description='The protocol version. Valid values:

*   **ipv4:** IPv4. This is the default value.
*   **DualStack:** dual stack.', example='ipv4'),
  anyPortEnabled?: boolean(name='AnyPortEnabled', description='Specifies whether to enable all-port forwarding. Valid values:

*   **true:** yes.
*   **false:** no. This is the default value.', example='false'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can contain only ASCII characters.

>  If you do not set this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** may be different for each API request.', example='123e4567-e89b-12d3-a456-426655440000'),
  connectionDrainEnabled?: boolean(name='ConnectionDrainEnabled', description='Specifies whether to enable connection draining. Valid values:

*   **true:** yes.
*   **false:** no. This is the default value.', example='false'),
  connectionDrainTimeout?: int32(name='ConnectionDrainTimeout', description='The timeout period of connection draining. Unit: seconds.

Valid values: **10** to **900**.', example='10'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run. Valid values:

*   **true:** performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false:** performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='true'),
  healthCheckConfig?: {
    healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='The backend port that is used for health checks.

Valid values: **0** to **65535**.

Default value: **0**. If you set the value to 0, the port of a backend server is used for health checks.', example='0'),
    healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='The maximum timeout period of a health check response. Unit: seconds.

Valid values: **1** to **300**.

Default value: **5**.', example='5'),
    healthCheckDomain?: string(name='HealthCheckDomain', description='The domain name that is used for health checks. Valid values:

*   **$SERVER_IP:** the private IP address of a backend server.
*   **domain:** the domain name you want to use for health checks. The domain name must be 1 to 80 characters in length and can contain lowercase letters, digits, hyphens (-), and periods (.).

>  This parameter takes effect only when you set **HealthCheckType** to **HTTP**.', example='$SERVER_IP'),
    healthCheckEnabled?: boolean(name='HealthCheckEnabled', description='Specifies whether to enable the health check feature. Valid values:

*   **true:** yes. This is the default value.
*   **false:** no.', example='true'),
    healthCheckHttpCode?: [ string ](name='HealthCheckHttpCode'),
    healthCheckInterval?: int32(name='HealthCheckInterval', description='The interval between two consecutive health checks. Unit: seconds.

Valid values: **5** to **5000**.

Default value: **10**.', example='10'),
    healthCheckType?: string(name='HealthCheckType', description='The protocol that is used for health checks. Valid values: **TCP** (default) and **HTTP**.', example='TCP'),
    healthCheckUrl?: string(name='HealthCheckUrl', description='The path to which health check requests are sent.

The path must be 1 to 80 characters in length, and can contain only letters, digits, and the following special characters: `- / . % ? # & =`. It can also contain the following extended characters: `_ ; ~ ! ( ) * [ ] @ $ ^ : \\" , +`. The path must start with a forward slash (/).

>  This parameter takes effect only when you set **HealthCheckType** to **HTTP**.', example='/test/index.html'),
    healthyThreshold?: int32(name='HealthyThreshold', description='The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**.

Valid values: **2** to **10**.

Default value: **2**.', example='2'),
    httpCheckMethod?: string(name='HttpCheckMethod', description='The HTTP method that is used for health checks. Valid values: **GET** (default) and **HEAD**.

>  This parameter takes effect only when you set **HealthCheckType** to **HTTP**.', example='GET'),
    unhealthyThreshold?: int32(name='UnhealthyThreshold', description='The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**.

Valid values: **2** to **10**.

Default value: **2**.', example='2'),
  }(name='HealthCheckConfig'),
  preserveClientIpEnabled?: boolean(name='PreserveClientIpEnabled', description='Specifies whether to enable client IP preservation. Valid values:

*   **true:** yes.
*   **false:** no. This is the default value.', example='false'),
  protocol?: string(name='Protocol', description='The protocol used to forward requests to the backend servers. Valid values:

*   **TCP:** This is the default value.
*   **UDP**
*   **TCPSSL**', example='TCP'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the server group belongs.', example='rg-atstuj3rtop****'),
  scheduler?: string(name='Scheduler', description='The scheduling algorithm. Valid values:

*   **Wrr:** The weighted round-robin algorithm is used. Backend servers with higher weights receive more requests than backend servers with lower weights. This is the default value.
*   **rr:** The round-robin algorithm is used. Requests are forwarded to backend servers in sequence.
*   **sch:** Source IP hashing is used. Requests from the same source IP address are forwarded to the same backend server.
*   **tch:** Four-element hashing is used. It specifies consistent hashing that is based on four factors: source IP address, destination IP address, source port, and destination port. Requests that contain the same information based on the four factors are forwarded to the same backend server.
*   **qch:** QUIC ID hashing is used. Requests that contain the same QUIC ID are forwarded to the same backend server.', example='Wrr'),
  serverGroupName?: string(name='ServerGroupName', description='The name of the server group.

The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.', example='NLB_ServerGroup'),
  serverGroupType?: string(name='ServerGroupType', description='The type of the server group. Valid values:

*   **Instance:** allows you to add servers of the **Ecs**, **Ens**, or **Eci** type. This is the default value.
*   **Ip:** allows you to add servers by specifying IP addresses.', example='Instance'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vpcId?: string(name='VpcId', description='The ID of the VPC to which the server group belongs.

>  If **ServerGroupType** is set to **Instance**, only servers in the specified VPC can be added to the server group.', example='vpc-bp15zckdt37pq72zv****'),
}

model CreateServerGroupResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-atstuj3rtoptyui****'),
}

model CreateServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServerGroupResponseBody(name='body'),
}

/**
  * *   **protocol** specifies the protocol used to forward requests to the backend servers.
  * *   NLB instances support only backend server groups that use TCP, UDP, or SSL over TCP.
  * *   **CreateServerGroup** is an asynchronous operation. After you send the request, the system returns a request ID even though the operation is still being performed in the background. You can call the [GetJobStatus](~~445904~~) operation to query the creation status of a server group.
  *     *   If the task is in the **Succeeded** status, the server group is created.
  *     *   If the task is in the **Processing** status, the server group is being created.
  *
  * @param request CreateServerGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateServerGroupResponse
 */
async function createServerGroupWithOptions(request: CreateServerGroupRequest, runtime: Util.RuntimeOptions): CreateServerGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.addressIPVersion)) {
    body['AddressIPVersion'] = request.addressIPVersion;
  }
  if (!Util.isUnset(request.anyPortEnabled)) {
    body['AnyPortEnabled'] = request.anyPortEnabled;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.connectionDrainEnabled)) {
    body['ConnectionDrainEnabled'] = request.connectionDrainEnabled;
  }
  if (!Util.isUnset(request.connectionDrainTimeout)) {
    body['ConnectionDrainTimeout'] = request.connectionDrainTimeout;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.healthCheckConfig)) {
    bodyFlat['HealthCheckConfig'] = request.healthCheckConfig;
  }
  if (!Util.isUnset(request.preserveClientIpEnabled)) {
    body['PreserveClientIpEnabled'] = request.preserveClientIpEnabled;
  }
  if (!Util.isUnset(request.protocol)) {
    body['Protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.scheduler)) {
    body['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.serverGroupName)) {
    body['ServerGroupName'] = request.serverGroupName;
  }
  if (!Util.isUnset(request.serverGroupType)) {
    body['ServerGroupType'] = request.serverGroupType;
  }
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServerGroup',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   **protocol** specifies the protocol used to forward requests to the backend servers.
  * *   NLB instances support only backend server groups that use TCP, UDP, or SSL over TCP.
  * *   **CreateServerGroup** is an asynchronous operation. After you send the request, the system returns a request ID even though the operation is still being performed in the background. You can call the [GetJobStatus](~~445904~~) operation to query the creation status of a server group.
  *     *   If the task is in the **Succeeded** status, the server group is created.
  *     *   If the task is in the **Processing** status, the server group is being created.
  *
  * @param request CreateServerGroupRequest
  * @return CreateServerGroupResponse
 */
async function createServerGroup(request: CreateServerGroupRequest): CreateServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServerGroupWithOptions(request, runtime);
}

model DeleteListenerRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** of each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether only to precheck the request. Valid values:

*   **true**: prechecks the request but does not delete the listener. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.', example='false'),
  listenerId?: string(name='ListenerId', description='The ID of the listener.', example='lsn-bp1bpn0kn908w4nbw****'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
}

model DeleteListenerResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model DeleteListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteListenerResponseBody(name='body'),
}

async function deleteListenerWithOptions(request: DeleteListenerRequest, runtime: Util.RuntimeOptions): DeleteListenerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    body['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteListener',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteListener(request: DeleteListenerRequest): DeleteListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteListenerWithOptions(request, runtime);
}

model DeleteLoadBalancerRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to only precheck this request. Valid values:

*   **true**: prechecks the request without deleting the NLB instance. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.', example='false'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the NLB instance.', example='nlb-wb7r6dlwetvt5j****'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
}

model DeleteLoadBalancerResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model DeleteLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLoadBalancerResponseBody(name='body'),
}

async function deleteLoadBalancerWithOptions(request: DeleteLoadBalancerRequest, runtime: Util.RuntimeOptions): DeleteLoadBalancerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLoadBalancer',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLoadBalancer(request: DeleteLoadBalancerRequest): DeleteLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLoadBalancerWithOptions(request, runtime);
}

model DeleteSecurityPolicyRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can only contain ASCII characters.

>  If you do not set this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. **RequestId** of each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run. Valid values:

*   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the available regions.', example='cn-hangzhou'),
  securityPolicyId?: string(name='SecurityPolicyId', description='The ID of the TLS security policy.', example='tls-bp14bb1e7dll4f****'),
}

model DeleteSecurityPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D7A8875F-373A-5F48-8484-25B07A61F2AF'),
}

model DeleteSecurityPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSecurityPolicyResponseBody(name='body'),
}

async function deleteSecurityPolicyWithOptions(request: DeleteSecurityPolicyRequest, runtime: Util.RuntimeOptions): DeleteSecurityPolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    body['SecurityPolicyId'] = request.securityPolicyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSecurityPolicy',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSecurityPolicy(request: DeleteSecurityPolicyRequest): DeleteSecurityPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecurityPolicyWithOptions(request, runtime);
}

model DeleteServerGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can only contain ASCII characters.

>  If you do not set this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. **RequestId** of each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run. Valid values:

*   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-atstuj3rtoptyui****'),
}

model DeleteServerGroupResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
}

model DeleteServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServerGroupResponseBody(name='body'),
}

/**
  * You can delete server groups that are not associated with listeners.
  *
  * @param request DeleteServerGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteServerGroupResponse
 */
async function deleteServerGroupWithOptions(request: DeleteServerGroupRequest, runtime: Util.RuntimeOptions): DeleteServerGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServerGroup',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can delete server groups that are not associated with listeners.
  *
  * @param request DeleteServerGroupRequest
  * @return DeleteServerGroupResponse
 */
async function deleteServerGroup(request: DeleteServerGroupRequest): DeleteServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServerGroupWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The supported natural language. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English
*   **ja**: Japanese', example='en-US'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  serviceCode?: string(name='ServiceCode', description='The service code. Set the value to **nlb**.', example='nlb'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName', description='The name of the region.'),
      regionEndpoint?: string(name='RegionEndpoint', description='The endpoint of the region service.', example='nlb.cn-hangzhou.aliyuncs.com'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='Regions', description='A list of regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.serviceCode)) {
    query['ServiceCode'] = request.serviceCode;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeZonesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The supported natural language. Valid values:

*   **zh-CN**: Chinese
*   **en-US** (default): English
*   **ja**: Japanese', example='zh-CN'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.', example='123e4567-e89b-12d3-a456-426655440000'),
  regionId?: string(name='RegionId', description='The ID of the region to which the zone belongs. You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  serviceCode?: string(name='ServiceCode', description='The service code. Set the value to **nlb**.', example='nlb'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
  zones?: [ 
    {
      localName?: string(name='LocalName', description='The name of the zone.'),
      zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-g'),
    }
  ](name='Zones', description='The list of zones.'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeZonesResponseBody(name='body'),
}

async function describeZonesWithOptions(request: DescribeZonesRequest, runtime: Util.RuntimeOptions): DescribeZonesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serviceCode)) {
    query['ServiceCode'] = request.serviceCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeZones',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeZonesWithOptions(request, runtime);
}

model DetachCommonBandwidthPackageFromLoadBalancerRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId', description='The ID of the EIP bandwidth plan.', example='cbwp-bp1pzf0ym72pu3y76****'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** of each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether only to precheck the request. Valid values:

*   **true**: prechecks the request but does not disassociate the NLB instance from the EIP bandwidth plan. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.', example='false'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the NLB instance.', example='nlb-83ckzc8d4xlp8o****'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
}

model DetachCommonBandwidthPackageFromLoadBalancerResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model DetachCommonBandwidthPackageFromLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachCommonBandwidthPackageFromLoadBalancerResponseBody(name='body'),
}

async function detachCommonBandwidthPackageFromLoadBalancerWithOptions(request: DetachCommonBandwidthPackageFromLoadBalancerRequest, runtime: Util.RuntimeOptions): DetachCommonBandwidthPackageFromLoadBalancerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    body['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetachCommonBandwidthPackageFromLoadBalancer',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachCommonBandwidthPackageFromLoadBalancer(request: DetachCommonBandwidthPackageFromLoadBalancerRequest): DetachCommonBandwidthPackageFromLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachCommonBandwidthPackageFromLoadBalancerWithOptions(request, runtime);
}

model DisableLoadBalancerIpv6InternetRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** of each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether only to precheck the request. Valid values:

*   **true**: prechecks the request but does not change the network type of the NLB instance. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.', example='false'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the NLB instance.', example='nlb-83ckzc8d4xlp8o****'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
}

model DisableLoadBalancerIpv6InternetResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model DisableLoadBalancerIpv6InternetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableLoadBalancerIpv6InternetResponseBody(name='body'),
}

async function disableLoadBalancerIpv6InternetWithOptions(request: DisableLoadBalancerIpv6InternetRequest, runtime: Util.RuntimeOptions): DisableLoadBalancerIpv6InternetResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DisableLoadBalancerIpv6Internet',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableLoadBalancerIpv6Internet(request: DisableLoadBalancerIpv6InternetRequest): DisableLoadBalancerIpv6InternetResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableLoadBalancerIpv6InternetWithOptions(request, runtime);
}

model DisassociateAdditionalCertificatesWithListenerRequest {
  additionalCertificateIds?: [ string ](name='AdditionalCertificateIds'),
  clientToken?: string(name='ClientToken', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', example='true'),
  listenerId?: string(name='ListenerId', example='lsr-bp1bpn0kn908w4nbw****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model DisassociateAdditionalCertificatesWithListenerResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model DisassociateAdditionalCertificatesWithListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisassociateAdditionalCertificatesWithListenerResponseBody(name='body'),
}

async function disassociateAdditionalCertificatesWithListenerWithOptions(request: DisassociateAdditionalCertificatesWithListenerRequest, runtime: Util.RuntimeOptions): DisassociateAdditionalCertificatesWithListenerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.additionalCertificateIds)) {
    body['AdditionalCertificateIds'] = request.additionalCertificateIds;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    body['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DisassociateAdditionalCertificatesWithListener',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disassociateAdditionalCertificatesWithListener(request: DisassociateAdditionalCertificatesWithListenerRequest): DisassociateAdditionalCertificatesWithListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return disassociateAdditionalCertificatesWithListenerWithOptions(request, runtime);
}

model EnableLoadBalancerIpv6InternetRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether only to precheck the request. Valid values:

*   **true**: prechecks the request but does not change the network type of the NLB instance. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.', example='false'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the NLB instance.', example='nlb-83ckzc8d4xlp8o****'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
}

model EnableLoadBalancerIpv6InternetResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model EnableLoadBalancerIpv6InternetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableLoadBalancerIpv6InternetResponseBody(name='body'),
}

async function enableLoadBalancerIpv6InternetWithOptions(request: EnableLoadBalancerIpv6InternetRequest, runtime: Util.RuntimeOptions): EnableLoadBalancerIpv6InternetResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EnableLoadBalancerIpv6Internet',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableLoadBalancerIpv6Internet(request: EnableLoadBalancerIpv6InternetRequest): EnableLoadBalancerIpv6InternetResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableLoadBalancerIpv6InternetWithOptions(request, runtime);
}

model GetJobStatusRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** of each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
}

model GetJobStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
  status?: string(name='Status', description='The state of the task. Valid values:

*   **Succeeded**: The task is successful.
*   **processing**: The ticket is being executed.', example='Succeeded'),
}

model GetJobStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJobStatusResponseBody(name='body'),
}

async function getJobStatusWithOptions(request: GetJobStatusRequest, runtime: Util.RuntimeOptions): GetJobStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJobStatus',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJobStatus(request: GetJobStatusRequest): GetJobStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobStatusWithOptions(request, runtime);
}

model GetListenerAttributeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** of each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether only to precheck the request. Valid values:

*   **true**: checks the request but does not query the listener details. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.', example='false'),
  listenerId?: string(name='ListenerId', description='The ID of the listener.', example='lsn-bp1bpn0kn908w4nbw****'),
  regionId?: string(name='RegionId', description='The ID of the region where the Network Load Balancer (NLB) instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
}

model GetListenerAttributeResponseBody = {
  alpnEnabled?: boolean(name='AlpnEnabled', description='Indicates whether Application-Layer Protocol Negotiation (ALPN) is enabled. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
  alpnPolicy?: string(name='AlpnPolicy', description='The ALPN policy. Valid values:

*   **HTTP1Only**
*   **HTTP2Only**
*   **HTTP2Preferred**
*   **HTTP2Optional**', example='HTTP1Only'),
  caCertificateIds?: [ string ](name='CaCertificateIds', description='The CA certificates. Only one CA certificate is supported.

>  This parameter takes effect only for listeners that use SSL over TCP.'),
  caEnabled?: boolean(name='CaEnabled', description='Indicates whether mutual authentication is enabled. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
  certificateIds?: [ string ](name='CertificateIds', description='The server certificates. Only one server certificate is supported.

>  This parameter takes effect only for listeners that use SSL over TCP.'),
  cps?: int32(name='Cps', description='The maximum number of connections that can be created per second on the NLB instance. Valid values: **0** to **1000000**. **0** specifies that the number of connections is unlimited.', example='1000'),
  endPort?: string(name='EndPort', description='The last port in the listening port range. Valid values: **0** to **65535**. The number of the last port must be smaller than that of the first port.', example='455'),
  idleTimeout?: int32(name='IdleTimeout', description='The timeout period of an idle connection. Unit: seconds. Valid values: **1** to **900**.', example='900'),
  listenerDescription?: string(name='ListenerDescription', description='The name of the listener.

The name must be 2 to 256 characters in length, and can contain letters, digits, commas (,), periods (.), semicolons (;), forward slashes (/), at signs (@), underscores (\\_), and hyphens (-).', example='tcpssl_443'),
  listenerId?: string(name='ListenerId', description='The ID of the listener.', example='lsn-ga6sjjcll6ou34l1et****'),
  listenerPort?: int32(name='ListenerPort', description='The listening port. Valid values: **0** to **65535**. A value of **0** specifies all ports. If you set the value to **0**, you must also set the **StartPort** and **EndPort** parameters.', example='233'),
  listenerProtocol?: string(name='ListenerProtocol', description='The listening protocol. Valid values: **TCP**, **UDP**, and **TCPSSL**.', example='TCPSSL'),
  listenerStatus?: string(name='ListenerStatus', description='The status of the listener. Valid values:

*   **Provisioning**: The listener is being created.
*   **Running**: The listener is running.
*   **Configuring**: The listener is being configured.
*   **Stopping**: The listener is being stopped.
*   **Stopped**: The listener is stopped.
*   **Starting**: The listener is being started.
*   **Deleting**: The listener is being deleted.
*   **Deleted**: The listener is deleted.', example='Running'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the NLB instance.', example='nlb-83ckzc8d4xlp8o****'),
  mss?: int32(name='Mss', description='The size of the largest TCP segment. Unit: bytes. Valid values: **0** to **1500**. **0** specifies that the maximum segment size remains unchanged.

>  This parameter is supported only by listeners that use SSL over TCP.', example='166'),
  proxyProtocolEnabled?: boolean(name='ProxyProtocolEnabled', description='Indicates whether the Proxy protocol is used to pass client IP addresses to backend servers. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
  secSensorEnabled?: boolean(name='SecSensorEnabled', description='Indicates whether fine-grained monitoring is enabled. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
  securityPolicyId?: string(name='SecurityPolicyId', description='The ID of the security policy. System security policies and custom security policies are supported.

Valid values: **tls_cipher_policy\\_1\\_0**, **tls_cipher_policy\\_1\\_1**, **tls_cipher_policy\\_1\\_2**, **tls_cipher_policy\\_1\\_2\\_strict**, and **tls_cipher_policy\\_1\\_2\\_strict_with\\_1\\_3**.

>  This parameter takes effect only for listeners that use SSL over TCP.', example='tls_cipher_policy_1_0'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-ppdpc14gdm3x4o****'),
  startPort?: string(name='StartPort', description='The first port in the listening port range. Valid values: **0** to **65535**.', example='233'),
  tags?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Tags'),
}

model GetListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetListenerAttributeResponseBody(name='body'),
}

async function getListenerAttributeWithOptions(request: GetListenerAttributeRequest, runtime: Util.RuntimeOptions): GetListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetListenerAttribute',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getListenerAttribute(request: GetListenerAttributeRequest): GetListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getListenerAttributeWithOptions(request, runtime);
}

model GetListenerHealthStatusRequest {
  listenerId?: string(name='ListenerId', description='The ID of the listener of the NLB instance.', example='lsn-bp1bpn0kn908w4nbw****'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.', example='20'),
  nextToken?: string(name='NextToken', description='The token that is used for the next query. Valid values:

*   If this is your first query or no next query is to be sent, ignore this parameter.
*   If a next query is to be sent, set the parameter to the value of NextToken that is returned from the last call.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
}

model GetListenerHealthStatusResponseBody = {
  listenerHealthStatus?: [ 
    {
      listenerId?: string(name='ListenerId', description='The ID of the listener of the NLB instance.', example='lsn-agkd9gmjx8nd85jjs0****'),
      listenerPort?: int32(name='ListenerPort', description='The listening port.', example='80'),
      listenerProtocol?: string(name='ListenerProtocol', description='The listening protocol. Valid values: **TCP**, **UDP**, and **TCPSSL**.', example='TCPSSL'),
      serverGroupInfos?: [ 
        {
          heathCheckEnabled?: boolean(name='HeathCheckEnabled', description='Indicates whether the health check feature is enabled. Valid values:

*   **true**: enabled
*   **false**: disabled', example='true'),
          nonNormalServers?: [ 
            {
              port?: int32(name='Port', description='The backend port.', example='80'),
              reason?: {
                reasonCode?: string(name='ReasonCode', description='The reason why the **status** is abnormal. Valid values:

*   **CONNECT_TIMEOUT**: The NLB instance failed to connect to the backend server within the specified period of time.
*   **CONNECT_FAILED**: The NLB instance failed to connect to the backend server.
*   **RECV_RESPONSE_TIMEOUT**: The NLB instance failed to receive a response from the backend server within the specified period of time.
*   **CONNECT_INTERRUPT**: The connection between the health check and the backend servers was interrupted.
*   **HTTP_CODE_NOT_MATCH**: The HTTP status code from the backend servers was not the expected one.
*   **HTTP_INVALID_HEADER**: The format of the response from the backend servers is invalid.', example='CONNECT_TIMEOUT'),
              }(name='Reason', description='The cause of the health check failure.'),
              serverId?: string(name='ServerId', description='The ID of the backend server.', example='i-bp1bt75jaujl7tjl****'),
              serverIp?: string(name='ServerIp', description='The IP address of the backend server.', example='192.168.8.10'),
              status?: string(name='Status', description='The health check status. Valid values:

*   **Initial**: indicates that health checks are configured for the NLB instance, but no data was found.
*   **Unhealthy**: indicates that the backend server consecutively fails health checks.
*   **Unused**: indicates that the weight of the backend server is 0.
*   **Unavailable**: indicates that health checks are disabled.', example='Initial'),
            }
          ](name='NonNormalServers', description='A list of unhealthy backend servers.'),
          serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-ppdpc14gdm3x4o****'),
        }
      ](name='ServerGroupInfos', description='The information about the server groups.'),
    }
  ](name='ListenerHealthStatus', description='The health check status of the server groups that are associated with the listener.'),
  maxResults?: int32(name='MaxResults', description='The number of entries returned per page.', example='20'),
  nextToken?: string(name='NextToken', description='The token that is used for the next query. Valid values:

- If **NextToken** is empty, it indicates that no next query is to be sent.
- If a value of **NextToken** is returned, the value is the token used for the next query.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
  totalCount?: int32(name='TotalCount', description='The number of entries returned.', example='10'),
}

model GetListenerHealthStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetListenerHealthStatusResponseBody(name='body'),
}

async function getListenerHealthStatusWithOptions(request: GetListenerHealthStatusRequest, runtime: Util.RuntimeOptions): GetListenerHealthStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetListenerHealthStatus',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getListenerHealthStatus(request: GetListenerHealthStatusRequest): GetListenerHealthStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getListenerHealthStatusWithOptions(request, runtime);
}

model GetLoadBalancerAttributeRequest {
  clientToken?: string(name='ClientToken', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', example='false'),
  loadBalancerId?: string(name='LoadBalancerId', example='nlb-83ckzc8d4xlp8o****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model GetLoadBalancerAttributeResponseBody = {
  addressIpVersion?: string(name='AddressIpVersion', example='ipv4'),
  addressType?: string(name='AddressType', example='Internet'),
  bandwidthPackageId?: string(name='BandwidthPackageId', example='cbwp-bp1vevu8h3ieh****'),
  cps?: int32(name='Cps', example='100'),
  createTime?: string(name='CreateTime', example='2022-07-02T02:49:05Z'),
  crossZoneEnabled?: boolean(name='CrossZoneEnabled', example='true'),
  DNSName?: string(name='DNSName', example='nlb-wb7r6dlwetvt5j****.cn-hangzhou.nlb.aliyuncs.com'),
  deletionProtectionConfig?: {
    enabled?: boolean(name='Enabled', example='true'),
    enabledTime?: string(name='EnabledTime', example='2022-11-02T02:49:05Z'),
    reason?: string(name='Reason'),
  }(name='DeletionProtectionConfig'),
  ipv6AddressType?: string(name='Ipv6AddressType', example='Internet'),
  loadBalancerBillingConfig?: {
    payType?: string(name='PayType', example='PostPay'),
  }(name='LoadBalancerBillingConfig'),
  loadBalancerBusinessStatus?: string(name='LoadBalancerBusinessStatus', example='Normal'),
  loadBalancerId?: string(name='LoadBalancerId', example='nlb-83ckzc8d4xlp8o****'),
  loadBalancerName?: string(name='LoadBalancerName', example='NLB1'),
  loadBalancerStatus?: string(name='LoadBalancerStatus', example='Active'),
  loadBalancerType?: string(name='LoadBalancerType', example='network'),
  modificationProtectionConfig?: {
    enabledTime?: string(name='EnabledTime', example='2022-12-02T02:49:05Z'),
    reason?: string(name='Reason'),
    status?: string(name='Status', example='ConsoleProtection'),
  }(name='ModificationProtectionConfig'),
  operationLocks?: [ 
    {
      lockReason?: string(name='LockReason'),
      lockType?: string(name='LockType', example='SecurityLocked'),
    }
  ](name='OperationLocks'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  requestId?: string(name='RequestId', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-atstuj3rtop****'),
  securityGroupIds?: [ string ](name='SecurityGroupIds'),
  tags?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Tags'),
  vpcId?: string(name='VpcId', example='vpc-bp1b49rqrybk45nio****'),
  zoneMappings?: [ 
    {
      loadBalancerAddresses?: [ 
        {
          allocationId?: string(name='AllocationId', example='eip-bp1aedxso6u80u0qf****'),
          eniId?: string(name='EniId', example='eni-bp12f1xhs5yal61a****'),
          ipv6Address?: string(name='Ipv6Address', example='2001:db8:1:1:1:1:1:1'),
          privateIPv4Address?: string(name='PrivateIPv4Address', example='192.168.3.32'),
          privateIPv4HcStatus?: string(name='PrivateIPv4HcStatus'),
          privateIPv6HcStatus?: string(name='PrivateIPv6HcStatus'),
          publicIPv4Address?: string(name='PublicIPv4Address', example='120.XX.XX.69'),
        }
      ](name='LoadBalancerAddresses'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId', example='vsw-bp1rmcrwg3erh1fh8****'),
      zoneId?: string(name='ZoneId', example='cn-hangzhou-a'),
    }
  ](name='ZoneMappings'),
}

model GetLoadBalancerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLoadBalancerAttributeResponseBody(name='body'),
}

async function getLoadBalancerAttributeWithOptions(request: GetLoadBalancerAttributeRequest, runtime: Util.RuntimeOptions): GetLoadBalancerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLoadBalancerAttribute',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLoadBalancerAttribute(request: GetLoadBalancerAttributeRequest): GetLoadBalancerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLoadBalancerAttributeWithOptions(request, runtime);
}

model ListListenerCertificatesRequest {
  certType?: string(name='CertType', example='cas'),
  listenerId?: string(name='ListenerId', description='The ID of the listener. Specify the ID of a listener that uses SSL over TCP.', example='lsn-j49ht1jxxqyg45****@80'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.', example='20'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   You do not need to specify this parameter for the first request.
*   You must specify the token that is obtained from the previous query as the value of NextToken.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  regionId?: string(name='RegionId', description='The ID of the region where the Network Load Balancer (NLB) instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
}

model ListListenerCertificatesResponseBody = {
  certificateIds?: [ string ](name='CertificateIds', description='The server certificates.'),
  certificates?: [ 
    {
      certificateId?: string(name='CertificateId', example='12315790343_166f8204689_1714763408_70998****'),
      certificateType?: string(name='CertificateType', example='Server'),
      isDefault?: boolean(name='IsDefault', example='true'),
      status?: string(name='Status', example='Associating'),
    }
  ](name='Certificates'),
  maxResults?: int32(name='MaxResults', description='The number of entries returned per page. Valid values: **1** to **100**. Default value: **20**.', example='20'),
  nextToken?: string(name='NextToken', description='The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results. Valid values:

*   You do not need to specify this parameter for the first request.
*   You must specify the token that is obtained from the previous query as the value of NextToken.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The request ID.', example='2198BD6D-9EBB-5E1C-9C48-E0ABB79CF831'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListListenerCertificatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListListenerCertificatesResponseBody(name='body'),
}

async function listListenerCertificatesWithOptions(request: ListListenerCertificatesRequest, runtime: Util.RuntimeOptions): ListListenerCertificatesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.certType)) {
    body['CertType'] = request.certType;
  }
  if (!Util.isUnset(request.listenerId)) {
    body['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListListenerCertificates',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listListenerCertificates(request: ListListenerCertificatesRequest): ListListenerCertificatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenerCertificatesWithOptions(request, runtime);
}

model ListListenersRequest {
  listenerIds?: [ string ](name='ListenerIds'),
  listenerProtocol?: string(name='ListenerProtocol', description='The listening protocol. Valid values: **TCP**, **UDP**, and **TCPSSL**.', example='TCPSSL'),
  loadBalancerIds?: [ string ](name='LoadBalancerIds'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.', example='20'),
  nextToken?: string(name='NextToken', description='The token that is used for the next query. Valid values:

*   If this is your first query or no next query is to be sent, ignore this parameter.
*   If a next query is to be sent, set the parameter to the value of NextToken that is returned from the last call.', example='NextToken	FFmyTO70tTpLG6I3FmYAXGKPd****'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListListenersResponseBody = {
  listeners?: [ 
    {
      alpnEnabled?: boolean(name='AlpnEnabled', description='Indicates whether Application-Layer Protocol Negotiation (ALPN) is enabled. Valid values:

*   **true**: enabled
*   **false**: disabled', example='false'),
      alpnPolicy?: string(name='AlpnPolicy', description='The ALPN policy. Valid values:

*   **HTTP1Only**
*   **HTTP2Only**
*   **HTTP2Preferred**
*   **HTTP2Optional**', example='HTTP1Only'),
      caCertificateIds?: [ string ](name='CaCertificateIds', description='The list of CA certificates.

>  This parameter takes effect only for listeners that use SSL over TCP.'),
      caEnabled?: boolean(name='CaEnabled', description='Indicates whether mutual authentication is enabled. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
      certificateIds?: [ string ](name='CertificateIds', description='The list of server certificates.

>  This parameter takes effect only for listeners that use SSL over TCP.'),
      cps?: int32(name='Cps', description='The maximum number of connections that can be created per second on the NLB instance. Valid values: **0** to **1000000**. **0** indicates that the number of connections is unlimited.', example='1000'),
      endPort?: string(name='EndPort', description='The last port in the listening port range.', example='455'),
      idleTimeout?: int32(name='IdleTimeout', description='The timeout period of an idle connection. Unit: seconds. Valid values: **1** to **900**. Default value: **900**.', example='900'),
      listenerDescription?: string(name='ListenerDescription', description='The name of the listener.

The name must be 2 to 256 characters in length, and can contain letters, digits, commas (,), periods (.), semicolons (;), forward slashes (/), at signs (@), underscores (\\_), and hyphens (-).', example='tcpssl_443'),
      listenerId?: string(name='ListenerId', description='The ID of the listener.', example='lsn-ga6sjjcll6ou34l1et****'),
      listenerPort?: int32(name='ListenerPort', description='The listening port.', example='443'),
      listenerProtocol?: string(name='ListenerProtocol', description='The listening protocol. Valid values: **TCP**, **UDP**, and **TCPSSL**.', example='TCPSSL'),
      listenerStatus?: string(name='ListenerStatus', description='The status of the listener. Valid values:

*   **Provisioning**
*   **Running**
*   **Configuring**
*   **Stopping**
*   **Stopped**
*   **Starting**
*   **Deleting**
*   **Deleted**', example='Running'),
      loadBalancerId?: string(name='LoadBalancerId', description='The ID of the NLB instance.', example='nlb-83ckzc8d4xlp8o****'),
      mss?: int32(name='Mss', description='The maximum size of a TCP segment. Unit: bytes. Valid values: **0** to **1500**. **0** indicates that the maximum segment size remains unchanged.

>  This parameter is supported only by listeners that use SSL over TCP.', example='200'),
      proxyProtocolEnabled?: boolean(name='ProxyProtocolEnabled', description='Indicates whether the Proxy protocol is used to pass client IP addresses to backend servers. Valid values:

*   **true**: enabled
*   **false**: disabled', example='false'),
      regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.', example='cn-hangzhou'),
      secSensorEnabled?: boolean(name='SecSensorEnabled', description='Indicates whether fine-grained monitoring is enabled. Valid values:

*   **true**: enabled
*   **false**: disabled', example='false'),
      securityPolicyId?: string(name='SecurityPolicyId', description='The ID of the security policy.

>  This parameter takes effect only for listeners that use SSL over TCP.', example='tls_cipher_policy_1_1'),
      serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-ppdpc14gdm3x4o****'),
      startPort?: string(name='StartPort', description='The first port in the listening port range.', example='233'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
    }
  ](name='Listeners', description='The list of listeners.'),
  maxResults?: int32(name='MaxResults', description='The number of entries returned per page.', example='20'),
  nextToken?: string(name='NextToken', description='The token that is used for the next query. Valid values:

*   If **NextToken** is empty, it indicates that no next query is to be sent.
*   If a value of **NextToken** is returned, the value is the token used for the next query.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
  totalCount?: int32(name='TotalCount', description='The number of entries returned.', example='4'),
}

model ListListenersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListListenersResponseBody(name='body'),
}

async function listListenersWithOptions(request: ListListenersRequest, runtime: Util.RuntimeOptions): ListListenersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerIds)) {
    query['ListenerIds'] = request.listenerIds;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerIds)) {
    query['LoadBalancerIds'] = request.loadBalancerIds;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListListeners',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listListeners(request: ListListenersRequest): ListListenersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenersWithOptions(request, runtime);
}

model ListLoadBalancersRequest {
  addressIpVersion?: string(name='AddressIpVersion', example='ipv4'),
  addressType?: string(name='AddressType', example='Internet'),
  DNSName?: string(name='DNSName', example='nlb-wb7r6dlwetvt5j****.cn-hangzhou.nlb.aliyuncs.com'),
  ipv6AddressType?: string(name='Ipv6AddressType', example='Internet'),
  loadBalancerBusinessStatus?: string(name='LoadBalancerBusinessStatus', example='Normal'),
  loadBalancerIds?: [ string ](name='LoadBalancerIds'),
  loadBalancerNames?: [ string ](name='LoadBalancerNames'),
  loadBalancerStatus?: string(name='LoadBalancerStatus', example='Active'),
  loadBalancerType?: string(name='LoadBalancerType', example='network'),
  maxResults?: int32(name='MaxResults', example='20'),
  nextToken?: string(name='NextToken', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-atstuj3rtop****'),
  tag?: [ 
    {
      key?: string(name='Key', example='KeyTest'),
      value?: string(name='Value', example='ValueTest'),
    }
  ](name='Tag'),
  vpcIds?: [ string ](name='VpcIds'),
  zoneId?: string(name='ZoneId', example='cn-hangzhou-a'),
}

model ListLoadBalancersResponseBody = {
  loadBalancers?: [ 
    {
      addressIpVersion?: string(name='AddressIpVersion', example='ipv4'),
      addressType?: string(name='AddressType', example='Internet'),
      bandwidthPackageId?: string(name='BandwidthPackageId', example='cbwp-bp1vevu8h3ieh****'),
      createTime?: string(name='CreateTime', example='2022-07-18T17:22Z'),
      crossZoneEnabled?: boolean(name='CrossZoneEnabled', example='true'),
      DNSName?: string(name='DNSName', example='nlb-wb7r6dlwetvt5j****.cn-hangzhou.nlb.aliyuncs.com'),
      deletionProtectionConfig?: {
        enabled?: boolean(name='Enabled', example='true'),
        enabledTime?: string(name='EnabledTime', example='2022-12-01T17:22Z'),
        reason?: string(name='Reason'),
      }(name='DeletionProtectionConfig'),
      ipv6AddressType?: string(name='Ipv6AddressType', example='Internet'),
      loadBalancerBillingConfig?: {
        payType?: string(name='PayType', example='PostPay'),
      }(name='LoadBalancerBillingConfig'),
      loadBalancerBusinessStatus?: string(name='LoadBalancerBusinessStatus', example='Normal'),
      loadBalancerId?: string(name='LoadBalancerId', example='nlb-83ckzc8d4xlp8o****'),
      loadBalancerName?: string(name='LoadBalancerName', example='NLB1'),
      loadBalancerStatus?: string(name='LoadBalancerStatus', example='Active'),
      loadBalancerType?: string(name='LoadBalancerType', example='Network'),
      modificationProtectionConfig?: {
        enabledTime?: string(name='EnabledTime', example='2022-12-01T17:22Z'),
        reason?: string(name='Reason'),
        status?: string(name='Status', example='ConsoleProtection'),
      }(name='ModificationProtectionConfig'),
      operationLocks?: [ 
        {
          lockReason?: string(name='LockReason'),
          lockType?: string(name='LockType', example='SecurityLocked'),
        }
      ](name='OperationLocks'),
      regionId?: string(name='RegionId', example='cn-hangzhou'),
      resourceGroupId?: string(name='ResourceGroupId', example='rg-atstuj3rtop****'),
      securityGroupIds?: [ string ](name='SecurityGroupIds'),
      tags?: [ 
        {
          key?: string(name='Key', example='KeyTest'),
          value?: string(name='Value', example='ValueTest'),
        }
      ](name='Tags'),
      vpcId?: string(name='VpcId', example='vpc-bp1b49rqrybk45nio****'),
      zoneMappings?: [ 
        {
          loadBalancerAddresses?: [ 
            {
              allocationId?: string(name='AllocationId', example='eip-bp1aedxso6u80u0qf****'),
              eniId?: string(name='EniId', example='eni-bp12f1xhs5yal61a****'),
              ipv6Address?: string(name='Ipv6Address', example='2001:db8:1:1:1:1:1:1'),
              privateIPv4Address?: string(name='PrivateIPv4Address', example='192.168.3.32'),
              privateIPv4HcStatus?: string(name='PrivateIPv4HcStatus'),
              privateIPv6HcStatus?: string(name='PrivateIPv6HcStatus'),
              publicIPv4Address?: string(name='PublicIPv4Address', example='120.XX.XX.69'),
            }
          ](name='LoadBalancerAddresses'),
          status?: string(name='Status'),
          vSwitchId?: string(name='VSwitchId', example='vsw-bp1rmcrwg3erh1fh8****'),
          zoneId?: string(name='ZoneId', example='cn-hangzhou-a'),
        }
      ](name='ZoneMappings'),
    }
  ](name='LoadBalancers'),
  maxResults?: int32(name='MaxResults', example='20'),
  nextToken?: string(name='NextToken', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
  totalCount?: int32(name='TotalCount', example='10'),
}

model ListLoadBalancersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLoadBalancersResponseBody(name='body'),
}

async function listLoadBalancersWithOptions(request: ListLoadBalancersRequest, runtime: Util.RuntimeOptions): ListLoadBalancersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addressIpVersion)) {
    query['AddressIpVersion'] = request.addressIpVersion;
  }
  if (!Util.isUnset(request.addressType)) {
    query['AddressType'] = request.addressType;
  }
  if (!Util.isUnset(request.DNSName)) {
    query['DNSName'] = request.DNSName;
  }
  if (!Util.isUnset(request.ipv6AddressType)) {
    query['Ipv6AddressType'] = request.ipv6AddressType;
  }
  if (!Util.isUnset(request.loadBalancerBusinessStatus)) {
    query['LoadBalancerBusinessStatus'] = request.loadBalancerBusinessStatus;
  }
  if (!Util.isUnset(request.loadBalancerIds)) {
    query['LoadBalancerIds'] = request.loadBalancerIds;
  }
  if (!Util.isUnset(request.loadBalancerNames)) {
    query['LoadBalancerNames'] = request.loadBalancerNames;
  }
  if (!Util.isUnset(request.loadBalancerStatus)) {
    query['LoadBalancerStatus'] = request.loadBalancerStatus;
  }
  if (!Util.isUnset(request.loadBalancerType)) {
    query['LoadBalancerType'] = request.loadBalancerType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vpcIds)) {
    query['VpcIds'] = request.vpcIds;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLoadBalancers',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLoadBalancers(request: ListLoadBalancersRequest): ListLoadBalancersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLoadBalancersWithOptions(request, runtime);
}

model ListSecurityPolicyRequest {
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.', example='20'),
  nextToken?: string(name='NextToken', description='The token that is used for the next query. Valid values:

*   If this is your first query or no next query is to be sent, ignore this parameter.
*   If a next query is to be sent, set the parameter to the value of NextToken that is returned from the last call.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-atstuj3rtop****'),
  securityPolicyIds?: [ string ](name='SecurityPolicyIds'),
  securityPolicyNames?: [ string ](name='SecurityPolicyNames'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag keys. You can specify up to 10 tag keys.

It can be at most 64 characters in length, and cannot contain `http://` or `https://`. It must not start with `aliyun` or `acs:`.', example='Test'),
      value?: string(name='Value', description='The tag values. You can specify up to 10 tag values.

It can be at most 128 characters in length, and cannot contain `http://` or `https://`. It must not start with `aliyun` or `acs:`.', example='Test'),
    }
  ](name='Tag'),
}

model ListSecurityPolicyResponseBody = {
  maxResults?: int32(name='MaxResults', description='The number of entries returned per page.', example='20'),
  nextToken?: string(name='NextToken', description='The token that is used for the next query. Valid values:

*   If this is your first query or no next query is to be sent, ignore this parameter.
*   If a next query is to be sent, set the parameter to the value of NextToken that is returned from the last call.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='D7A8875F-373A-5F48-8484-25B07A61F2AF'),
  securityPolicies?: [ 
    {
      ciphers?: string(name='Ciphers', description='The supported cipher suites, which are determined by the TLS protocol version. You can specify at most 32 cipher suites.

TLS 1.0 and TLS 1.1 support the following cipher suites:

*   **ECDHE-ECDSA-AES128-SHA**
*   **ECDHE-ECDSA-AES256-SHA**
*   **ECDHE-RSA-AES128-SHA**
*   **ECDHE-RSA-AES256-SHA**
*   **AES128-SHA**
*   **AES256-SHA**
*   **DES-CBC3-SHA**

TLS 1.2 supports the following cipher suites:

*   **ECDHE-ECDSA-AES128-SHA**
*   **ECDHE-ECDSA-AES256-SHA**
*   **ECDHE-RSA-AES128-SHA**
*   **ECDHE-RSA-AES256-SHA**
*   **AES128-SHA**
*   **AES256-SHA**
*   **DES-CBC3-SHA**
*   **ECDHE-ECDSA-AES128-GCM-SHA256**
*   **ECDHE-ECDSA-AES256-GCM-SHA384**
*   **ECDHE-ECDSA-AES128-SHA256**
*   **ECDHE-ECDSA-AES256-SHA384**
*   **ECDHE-RSA-AES128-GCM-SHA256**
*   **ECDHE-RSA-AES256-GCM-SHA384**
*   **ECDHE-RSA-AES128-SHA256**
*   **ECDHE-RSA-AES256-SHA384**
*   **AES128-GCM-SHA256**
*   **AES256-GCM-SHA384**
*   **AES128-SHA256**
*   **AES256-SHA256**

TLS 1.3 supports the following cipher suites:

*   **TLS_AES\\_128\\_GCM_SHA256**
*   **TLS_AES\\_256\\_GCM_SHA384**
*   **TLS_CHACHA20\\_POLY1305\\_SHA256**
*   **TLS_AES\\_128\\_CCM_SHA256**
*   **TLS_AES\\_128\\_CCM\\_8\\_SHA256**', example='ECDHE-ECDSA-AES128-SHA'),
      regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.', example='cn-hangzhou'),
      relatedListeners?: [ 
        {
          listenerId?: string(name='ListenerId', description='The ID of the listener.', example='lsn-bp1bpn0kn908w4nbw****'),
          listenerPort?: long(name='ListenerPort', description='The listening port.', example='443'),
          listenerProtocol?: string(name='ListenerProtocol', description='The listening protocol. Valid value: **TCPSSL**.', example='TCPSSL'),
          loadBalancerId?: string(name='LoadBalancerId', description='The ID of the NLB instance.', example='nlb-83ckzc8d4xlp8o****'),
        }
      ](name='RelatedListeners', description='The listeners that are associated with the NLB instance.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-atstuj3rtop****'),
      securityPolicyId?: string(name='SecurityPolicyId', description='The ID of the TLS security policy.', example='tls-bp14bb1e7dll4f****'),
      securityPolicyName?: string(name='SecurityPolicyName', description='The name of the TLS security policy.', example='TLSCipherPolicy'),
      securityPolicyStatus?: string(name='SecurityPolicyStatus', description='The status of the TLS security policy. Valid values:

*   **Configuring**: The security policy is being configured.
*   **Available**: The security policy is available.', example='Available'),
      tags?: [ 
        {
          key?: string(name='Key', description='The tag keys. You can specify up to 10 tag keys.

The tag key can be at most 64 characters in length, and cannot contain `http://` or `https://`. The tag key cannot start with `aliyun` or `acs:`.', example='Test'),
          value?: string(name='Value', description='The tag values. You can specify up to 10 tag values.

It can be at most 128 characters in length, and cannot contain `http://` or `https://`. It must not start with `aliyun` or `acs:`.', example='Test'),
        }
      ](name='Tags', description='The tags that are added to the NLB instance.'),
      tlsVersion?: string(name='TlsVersion', description='The supported versions of the TLS protocol. Valid values: **TLSv1.0**, **TLSv1.1**, **TLSv1.2**, and **TLSv1.3**.', example='TLSv1.0'),
    }
  ](name='SecurityPolicies', description='A list of TLS security policies.'),
  totalCount?: int32(name='TotalCount', description='The number of entries returned.', example='10'),
}

model ListSecurityPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSecurityPolicyResponseBody(name='body'),
}

async function listSecurityPolicyWithOptions(request: ListSecurityPolicyRequest, runtime: Util.RuntimeOptions): ListSecurityPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.securityPolicyIds)) {
    body['SecurityPolicyIds'] = request.securityPolicyIds;
  }
  if (!Util.isUnset(request.securityPolicyNames)) {
    body['SecurityPolicyNames'] = request.securityPolicyNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListSecurityPolicy',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSecurityPolicy(request: ListSecurityPolicyRequest): ListSecurityPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecurityPolicyWithOptions(request, runtime);
}

model ListServerGroupServersRequest {
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.', example='20'),
  nextToken?: string(name='NextToken', description='The token that is used for the next query. Valid values:

*   If this is your first query or no next query is to be sent, ignore this parameter.
*   If a next query is to be sent, set the parameter to the value of NextToken that is returned from the last call.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-atstuj3rtoptyui****'),
  serverIds?: [ string ](name='ServerIds'),
  serverIps?: [ string ](name='ServerIps'),
}

model ListServerGroupServersResponseBody = {
  maxResults?: int32(name='MaxResults', description='The number of entries returned per page.', example='20'),
  nextToken?: string(name='NextToken', description='The token that is used for the next query. Valid values:

*   If this is your first query or no next query is to be sent, ignore this parameter.
*   If a next query is to be sent, set the parameter to the value of NextToken that is returned from the last call.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
  servers?: [ 
    {
      description?: string(name='Description', description='The description of the backend server.', example='ECS'),
      port?: int32(name='Port', description='The port used by the backend server. Valid values: **1** to **65535**.', example='80'),
      serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-atstuj3rtoptyui****'),
      serverId?: string(name='ServerId', description='The ID of the server.', example='ecs-bp67acfmxazb4p****'),
      serverIp?: string(name='ServerIp', description='The IP address of the backend server.', example='192.168.2.1'),
      serverType?: string(name='ServerType', description='The type of the backend server. Valid values:

*   **Ecs**: an Elastic Compute Service (ECS) instance
*   **Eni**: an elastic network interface (ENI)
*   **Eci**: an elastic container instance
*   **Ip**: an IP address', example='Ecs'),
      status?: string(name='Status', description='Indicates the status of the backend server. Valid values:

*   **Adding**: The backend server is being added.
*   **Available**: The backend server is added.
*   **Configuring**: The backend server is being configured.
*   **Removing**: The backend server is being removed.', example='Available'),
      weight?: int32(name='Weight', description='The weight of the backend server.', example='100'),
      zoneId?: string(name='ZoneId', description='The zone ID of the server.', example='cn-hangzhou-a'),
    }
  ](name='Servers', description='A list of backend servers.'),
  totalCount?: int32(name='TotalCount', description='The number of entries returned.', example='10'),
}

model ListServerGroupServersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServerGroupServersResponseBody(name='body'),
}

async function listServerGroupServersWithOptions(request: ListServerGroupServersRequest, runtime: Util.RuntimeOptions): ListServerGroupServersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.serverIds)) {
    body['ServerIds'] = request.serverIds;
  }
  if (!Util.isUnset(request.serverIps)) {
    body['ServerIps'] = request.serverIps;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListServerGroupServers',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServerGroupServers(request: ListServerGroupServersRequest): ListServerGroupServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServerGroupServersWithOptions(request, runtime);
}

model ListServerGroupsRequest {
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.', example='20'),
  nextToken?: string(name='NextToken', description='The token that determines the start point of the query. Valid values:

*   If this is your first query and no next queries are to be sent, ignore this parameter.
*   If a next query is to be sent, set the value to the value of NextToken that is returned from the last call.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the server group belongs.', example='rg-atstuj3rtop****'),
  serverGroupIds?: [ string ](name='ServerGroupIds'),
  serverGroupNames?: [ string ](name='ServerGroupNames'),
  serverGroupType?: string(name='ServerGroupType', description='The type of server group. Valid values:

*   **Instance** : allows you to add servers of the **Ecs**, **Ens**, and **Eci** types.
*   **Ip**: allows you to add servers by specifying IP addresses.', example='Instance'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. You can specify up to 10 tag keys.

The tag key can be up to 64 characters in length, and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.', example='Test'),
      value?: string(name='Value', description='The tag value. You can specify up to 10 tag values.

The tag value can be up to 128 characters in length, and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.', example='Test'),
    }
  ](name='Tag'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC) to which the server group belongs.', example='vpc-bp15zckdt37pq72zv****'),
}

model ListServerGroupsResponseBody = {
  maxResults?: int32(name='MaxResults', description='The number of entries returned per page. Valid values: **1** to **100**.', example='20'),
  nextToken?: string(name='NextToken', description='The token that determines the start point of the query. Valid values:

*   If **NextToken** is empty, it indicates that no subsequent query is to be sent.
*   If a value of **NextToken** is returned, the value is the token used for the next query.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='54B28E3D-DF70-471B-AA93-08E683A1B45'),
  serverGroups?: [ 
    {
      addressIPVersion?: string(name='AddressIPVersion', description='The protocol version. Valid values:

*   **ipv4**: IPv4
*   **DualStack**: dual stack', example='ipv4'),
      aliUid?: long(name='AliUid', description='The UID of the Alibaba Cloud account.', example='165820696622****'),
      anyPortEnabled?: boolean(name='AnyPortEnabled', description='Indicates whether the feature of forwarding requests to all ports is enabled. Valid values:

*   **true**: enabled
*   **false**: disabled', example='false'),
      connectionDrainEnabled?: boolean(name='ConnectionDrainEnabled', description='Indicates whether connection draining is enabled. Valid values:

*   **true**: enabled
*   **false**: disabled', example='false'),
      connectionDrainTimeout?: int32(name='ConnectionDrainTimeout', description='The timeout period of connection draining. Unit: seconds.

Valid values: **10** to **900**.', example='200'),
      healthCheck?: {
        healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='The backend port that is used for health checks.

Valid values: **0** to **65535**.

A value of **0** indicates that the port on a backend server is used for health checks.', example='200'),
        healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='The maximum timeout period of a health check. Unit: seconds.

Valid values: **1** to **300**.', example='200'),
        healthCheckDomain?: string(name='HealthCheckDomain', description='The domain name that is used for health checks. Valid values:

*   **$SERVER_IP**: the private IP address of a backend server.
*   **domain**: a specified domain name. The domain name must be 1 to 80 characters in length, and can contain lowercase letters, digits, hyphens (-), and periods (.).

>  This parameter takes effect only if **HealthCheckType** is set to **HTTP**.', example='$SERVER_IP'),
        healthCheckEnabled?: boolean(name='HealthCheckEnabled', description='Indicates whether the health check feature is enabled. Valid values:

*   **true**: enabled
*   **false**: disabled', example='false'),
        healthCheckHttpCode?: [ string ](name='HealthCheckHttpCode', description='The HTTP status codes returned for health checks. Multiple HTTP status codes are separated by commas (,).

Valid values: **http\\_2xx**, **http\\_3xx**, **http\\_4xx**, and **http\\_5xx**.

>  This parameter takes effect only if **HealthCheckType** is set to **HTTP**.'),
        healthCheckInterval?: int32(name='HealthCheckInterval', description='The interval between two consecutive health checks. Unit: seconds.

Valid values: **5** to **50**.', example='200'),
        healthCheckType?: string(name='HealthCheckType', description='The protocol that is used for health checks. Valid values: **TCP** and **HTTP**.', example='TCP'),
        healthCheckUrl?: string(name='HealthCheckUrl', description='The path to which health check requests are sent.

>  This parameter takes effect only if **HealthCheckType** is set to **HTTP**.', example='/test/index.html'),
        healthyThreshold?: int32(name='HealthyThreshold', description='The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**.

Valid values: **2** to **10**.', example='2'),
        httpCheckMethod?: string(name='HttpCheckMethod', description='The HTTP method that is used for health checks. Valid values: **GET** and **HEAD**.

>  This parameter takes effect only if **HealthCheckType** is set to **HTTP**.', example='GET'),
        unhealthyThreshold?: int32(name='UnhealthyThreshold', description='The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**.

Valid values: **2** to **10**.', example='3'),
      }(name='HealthCheck', description='The configurations of health checks.'),
      preserveClientIpEnabled?: boolean(name='PreserveClientIpEnabled', description='Indicates whether client IP preservation is enabled. Valid values:

*   **true**: enabled
*   **false**: disabled

>  Note: If **AddressIPVersion** is set to **ipv4**, the default value is **true**. If **AddressIPVersion** is set to **ipv6**, the only valid value is **false**. **true** will be supported in later version.', example='true'),
      protocol?: string(name='Protocol', description='The protocol used to forward requests to the backend servers. Valid values: **TCP**, **UDP**, and **TCPSSL**.', example='TCP'),
      regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.', example='cn-hangzhou'),
      relatedLoadBalancerIds?: [ string ](name='RelatedLoadBalancerIds', description='The NLB instances.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the server group belongs.', example='rg-atstuj3rtop****'),
      scheduler?: string(name='Scheduler', description='The scheduling algorithm. Valid values:

*   **Wrr**: Backend servers with higher weights receive more requests than backend servers with lower weights.
*   **rr**: Requests are forwarded to the backend servers in sequence. sch: Requests are forwarded to the backend servers based on source IP address hashing.
*   **sch**: Requests from the same source IP address are forwarded to the same backend server.
*   **tch**: Four-element hashing, which specifies consistent hashing that is based on four factors: source IP address, destination IP address, source port, and destination port. Requests that contain the same information based on the four factors are forwarded to the same backend server.
*   **qch**: QUIC ID hashing. Requests that contain the same QUIC ID are forwarded to the same backend server.', example='Wrr'),
      serverCount?: int32(name='ServerCount', description='The number of server groups associated with the NLB instances.', example='2'),
      serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-atstuj3rtoptyui****'),
      serverGroupName?: string(name='ServerGroupName', description='The name of the server group.', example='NLB_ServerGroup'),
      serverGroupStatus?: string(name='ServerGroupStatus', description='The status of the server group. Valid values:

*   **Creating**: The server group is being created.
*   **Available**: The server group is available.
*   **Configuring**: The server group is being configured.', example='Available'),
      serverGroupType?: string(name='ServerGroupType', description='The type of server group. Valid values:

*   **Instance** : allows you to add servers of the **Ecs**, **Ens**, and **Eci** types.
*   **Ip**: allows you to add servers by specifying IP addresses.', example='Instance'),
      tags?: [ 
        {
          key?: string(name='Key', description='The tag key. At most 10 tag keys are returned.

The tag key can be up to 64 characters in length, and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.', example='Test'),
          value?: string(name='Value', description='The tag value. At most 10 tag values are returned.

The tag value can be up to 128 characters in length, and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.', example='Test'),
        }
      ](name='Tags', description='The tags that are added to the NLB instance.'),
      vpcId?: string(name='VpcId', description='The ID of the VPC to which the server group belongs.', example='vpc-bp15zckdt37pq72zv****'),
    }
  ](name='ServerGroups', description='The server groups.'),
  totalCount?: int32(name='TotalCount', description='The number of entries returned.', example='1'),
}

model ListServerGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServerGroupsResponseBody(name='body'),
}

async function listServerGroupsWithOptions(request: ListServerGroupsRequest, runtime: Util.RuntimeOptions): ListServerGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.serverGroupIds)) {
    body['ServerGroupIds'] = request.serverGroupIds;
  }
  if (!Util.isUnset(request.serverGroupNames)) {
    body['ServerGroupNames'] = request.serverGroupNames;
  }
  if (!Util.isUnset(request.serverGroupType)) {
    body['ServerGroupType'] = request.serverGroupType;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListServerGroups',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServerGroups(request: ListServerGroupsRequest): ListServerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServerGroupsWithOptions(request, runtime);
}

model ListSystemSecurityPolicyRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model ListSystemSecurityPolicyResponseBody = {
  requestId?: string(name='RequestId', example='5C057647-284B-5C67-A07E-4B8F3DABA9F9'),
  securityPolicies?: [ 
    {
      ciphers?: string(name='Ciphers', example='ECDHE-ECDSA-AES128-SHA'),
      securityPolicyId?: string(name='SecurityPolicyId', example='sp-3fdab6dkkke10s****'),
      securityPolicyName?: string(name='SecurityPolicyName', example='test'),
      tlsVersion?: string(name='TlsVersion', example='TLSv1.0'),
    }
  ](name='SecurityPolicies'),
}

model ListSystemSecurityPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSystemSecurityPolicyResponseBody(name='body'),
}

async function listSystemSecurityPolicyWithOptions(request: ListSystemSecurityPolicyRequest, runtime: Util.RuntimeOptions): ListSystemSecurityPolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListSystemSecurityPolicy',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSystemSecurityPolicy(request: ListSystemSecurityPolicyRequest): ListSystemSecurityPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSystemSecurityPolicyWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  maxResults?: int32(name='MaxResults', example='20'),
  nextToken?: string(name='NextToken', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType', example='loadbalancer'),
  tag?: [ 
    {
      key?: string(name='Key', example='env'),
      value?: string(name='Value', example='product'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  maxResults?: int32(name='MaxResults', example='20'),
  nextToken?: string(name='NextToken', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
  tagResources?: [ 
    {
      aliUid?: long(name='AliUid', example='1429****39299349'),
      category?: string(name='Category', example='All'),
      regionNo?: string(name='RegionNo', example='cn-hangzhou'),
      resourceId?: string(name='ResourceId', example='nlb-nrnrxwd15en27r****'),
      resourceType?: string(name='ResourceType', example='loadbalancer'),
      scope?: string(name='Scope', example='public'),
      tagKey?: string(name='TagKey', example='env'),
      tagValue?: string(name='TagValue', example='product'),
    }
  ](name='TagResources'),
  totalCount?: int32(name='TotalCount', example='10'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.resourceId)) {
    bodyFlat['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    bodyFlat['Tag'] = request.tag;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model LoadBalancerJoinSecurityGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.

>  If you do not set this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** may be different for each API request.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to check the request without performing the operation. Valid values:

*   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error code is returned based on the cause of the failure. If the request passes the check, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the check, an HTTP 2xx status code is returned and the operation is performed.', example='true'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the NLB instance to be associated with the security group.', example='nlb-83ckzc8d4xlp8o****'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  securityGroupIds?: [ string ](name='SecurityGroupIds'),
}

model LoadBalancerJoinSecurityGroupResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model LoadBalancerJoinSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LoadBalancerJoinSecurityGroupResponseBody(name='body'),
}

/**
  * *   Make sure that you have created a security group. For more information about how to create a security group, see [CreateSecurityGroup](~~25553~~).
  * *   An NLB instance can be associated with up to four security groups.
  * *   You can query the security groups that are associated with an NLB instance by calling the [GetLoadBalancerAttribute](~~214362~~) operation.
  * *   LoadBalancerJoinSecurityGroup is an asynchronous operation. After you call the operation, the system returns a request ID and runs the task in the background. You can call the [GetJobStatus](~~445904~~) operation to query the status of a task.
  *     *   If the task is in the **Succeeded** state, the security group is associated.
  *     *   If the task is in the **Processing** state, the security group is being associated. In this case, you can perform only query operations.
  *
  * @param request LoadBalancerJoinSecurityGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return LoadBalancerJoinSecurityGroupResponse
 */
async function loadBalancerJoinSecurityGroupWithOptions(request: LoadBalancerJoinSecurityGroupRequest, runtime: Util.RuntimeOptions): LoadBalancerJoinSecurityGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityGroupIds)) {
    body['SecurityGroupIds'] = request.securityGroupIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'LoadBalancerJoinSecurityGroup',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   Make sure that you have created a security group. For more information about how to create a security group, see [CreateSecurityGroup](~~25553~~).
  * *   An NLB instance can be associated with up to four security groups.
  * *   You can query the security groups that are associated with an NLB instance by calling the [GetLoadBalancerAttribute](~~214362~~) operation.
  * *   LoadBalancerJoinSecurityGroup is an asynchronous operation. After you call the operation, the system returns a request ID and runs the task in the background. You can call the [GetJobStatus](~~445904~~) operation to query the status of a task.
  *     *   If the task is in the **Succeeded** state, the security group is associated.
  *     *   If the task is in the **Processing** state, the security group is being associated. In this case, you can perform only query operations.
  *
  * @param request LoadBalancerJoinSecurityGroupRequest
  * @return LoadBalancerJoinSecurityGroupResponse
 */
async function loadBalancerJoinSecurityGroup(request: LoadBalancerJoinSecurityGroupRequest): LoadBalancerJoinSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return loadBalancerJoinSecurityGroupWithOptions(request, runtime);
}

model LoadBalancerLeaveSecurityGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.

>  If you do not set this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** may be different for each API request.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to check the request without performing the operation. Valid values:

*   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error code is returned based on the cause of the failure. If the request passes the check, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the check, an HTTP 2xx status code is returned and the operation is performed.', example='true'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the NLB instance.', example='nlb-83ckzc8d4xlp8o****'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  securityGroupIds?: [ string ](name='SecurityGroupIds'),
}

model LoadBalancerLeaveSecurityGroupResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model LoadBalancerLeaveSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LoadBalancerLeaveSecurityGroupResponseBody(name='body'),
}

/**
  * LoadBalancerLeaveSecurityGroup is an asynchronous operation. After you call the operation, the system returns a request ID and runs the task in the background. You can call the [GetJobStatus](~~445904~~) operation to query the status of a task.
  * *   If the task is in the **Succeeded** state, the security group is disassociated.
  * *   If the task is in the **Processing** state, the security group is being disassociated. In this case, you can perform only query operations.
  *
  * @param request LoadBalancerLeaveSecurityGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return LoadBalancerLeaveSecurityGroupResponse
 */
async function loadBalancerLeaveSecurityGroupWithOptions(request: LoadBalancerLeaveSecurityGroupRequest, runtime: Util.RuntimeOptions): LoadBalancerLeaveSecurityGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityGroupIds)) {
    body['SecurityGroupIds'] = request.securityGroupIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'LoadBalancerLeaveSecurityGroup',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * LoadBalancerLeaveSecurityGroup is an asynchronous operation. After you call the operation, the system returns a request ID and runs the task in the background. You can call the [GetJobStatus](~~445904~~) operation to query the status of a task.
  * *   If the task is in the **Succeeded** state, the security group is disassociated.
  * *   If the task is in the **Processing** state, the security group is being disassociated. In this case, you can perform only query operations.
  *
  * @param request LoadBalancerLeaveSecurityGroupRequest
  * @return LoadBalancerLeaveSecurityGroupResponse
 */
async function loadBalancerLeaveSecurityGroup(request: LoadBalancerLeaveSecurityGroupRequest): LoadBalancerLeaveSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return loadBalancerLeaveSecurityGroupWithOptions(request, runtime);
}

model MoveResourceGroupRequest {
  newResourceGroupId?: string(name='NewResourceGroupId', example='rg-aekzjcnrv3vvqhq'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceId?: string(name='ResourceId', example='nlb-nrnrxwd15en27r****'),
  resourceType?: string(name='ResourceType', example='loadbalancer'),
}

model MoveResourceGroupResponseBody = {
  data?: {
    resourceId?: string(name='ResourceId', example='nlb-nrnrxwd15en27r****'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode', example='200'),
  requestId?: string(name='RequestId', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
  success?: boolean(name='Success', example='true'),
}

model MoveResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MoveResourceGroupResponseBody(name='body'),
}

async function moveResourceGroupWithOptions(request: MoveResourceGroupRequest, runtime: Util.RuntimeOptions): MoveResourceGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.newResourceGroupId)) {
    body['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    body['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'MoveResourceGroup',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function moveResourceGroup(request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveResourceGroupWithOptions(request, runtime);
}

model RemoveServersFromServerGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** of each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether only to precheck the request. Valid values:

*   **true**: prechecks the request but does not remove the backend servers. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.', example='false'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-atstuj3rtoptyui****'),
  servers?: [ 
    {
      port?: int32(name='Port', description='The port used by the backend server. Valid values: **1** to **65535**.', example='443'),
      serverId?: string(name='ServerId', description='The ID of the server.

*   If the server group type is **Instance**, set the ServerId parameter to the ID of an Elastic Compute Service (ECS) instance, an elastic network interface (ENI), or an elastic container instance. These backend servers are specified by **Ecs**, **Eni**, or **Eci**.
*   If the server group type is **Ip**, set the ServerId parameter to an IP address.', example='ecs-bp67acfmxazb4p****'),
      serverIp?: string(name='ServerIp', description='The IP address of the server. If the server group type is **Ip**, set the ServerId parameter to an IP address.', example='192.168.6.6'),
      serverType?: string(name='ServerType', description='The type of the backend server. Valid values:

*   **Ecs**: an ECS instance
*   **Eni**: an ENI
*   **Eci**: an elastic container instance
*   **Ip**: an IP address', example='Ecs'),
    }
  ](name='Servers'),
}

model RemoveServersFromServerGroupResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-atstuj3rtoptyui****'),
}

model RemoveServersFromServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveServersFromServerGroupResponseBody(name='body'),
}

async function removeServersFromServerGroupWithOptions(request: RemoveServersFromServerGroupRequest, runtime: Util.RuntimeOptions): RemoveServersFromServerGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.servers)) {
    body['Servers'] = request.servers;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveServersFromServerGroup',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeServersFromServerGroup(request: RemoveServersFromServerGroupRequest): RemoveServersFromServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeServersFromServerGroupWithOptions(request, runtime);
}

model StartListenerRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether only to precheck the request. Valid values:

*   **true**: prechecks the request but does not enable the listener. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.', example='false'),
  listenerId?: string(name='ListenerId', description='The ID of the listener.', example='lsn-bp1bpn0kn908w4nbw****'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
}

model StartListenerResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model StartListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartListenerResponseBody(name='body'),
}

async function startListenerWithOptions(request: StartListenerRequest, runtime: Util.RuntimeOptions): StartListenerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    body['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartListener',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startListener(request: StartListenerRequest): StartListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return startListenerWithOptions(request, runtime);
}

model StopListenerRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can only contain ASCII characters.

>  If you do not set this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. **RequestId** of each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run. Valid values:

*   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  listenerId?: string(name='ListenerId', description='The ID of the listener.', example='lsn-bp1bpn0kn908w4nbw****'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
}

model StopListenerResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model StopListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopListenerResponseBody(name='body'),
}

async function stopListenerWithOptions(request: StopListenerRequest, runtime: Util.RuntimeOptions): StopListenerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    body['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopListener',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopListener(request: StopListenerRequest): StopListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopListenerWithOptions(request, runtime);
}

model TagResourcesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.

>  If you do not set this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** is different for each API request.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run. Valid values:

*   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false**: performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed. This is the default value.', example='true'),
  regionId?: string(name='RegionId', description='The region ID of the resource.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The ID of the resource. You can specify up to 50 resource IDs in each call.'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Valid values:

*   **loadbalancer**: a Network Load Balancer (NLB) instance
*   **securitypolicy**: a security policy
*   **servergroup**: a server group', example='loadbalancer'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. The tag key can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.

You can add up to 20 tags in each call.', example='env'),
      value?: string(name='Value', description='The tag value. The tag value can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.

You can add up to 20 tags in each call.', example='product'),
    }
  ](name='Tag', description='The tags.'),
}

model TagResourcesResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.resourceId)) {
    bodyFlat['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    bodyFlat['Tag'] = request.tag;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to remove all tags from the specified resource. Valid values:

*   **true**: removes all tags from the specified resource.
*   **false**: does not remove all tags from the specified resource. This is the default value.', example='false'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.

>  If you do not set this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** is different for each API request.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run. Valid values:

*   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false**: performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed. This is the default value.', example='true'),
  regionId?: string(name='RegionId', description='The region ID of the resource.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The ID of the resource. You can specify up to 50 resource IDs in each call.'),
  resourceType?: string(name='ResourceType', description='The type of the resource from which you want to remove tags. Valid values:

*   **loadbalancer**: a Network Load Balancer (NLB) instance
*   **securitypolicy**: a security policy
*   **servergroup**: a server group', example='loadbalancer'),
  tagKey?: [ string ](name='TagKey', description='The key of the tag that you want to remove. You can remove up to 20 tags in each call.'),
}

model UntagResourcesResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    body['All'] = request.all;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.resourceId)) {
    bodyFlat['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    bodyFlat['TagKey'] = request.tagKey;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateListenerAttributeRequest {
  alpnEnabled?: boolean(name='AlpnEnabled', description='Specifies whether to enable Application-Layer Protocol Negotiation (ALPN). Valid values:

*   **true**: yes
*   **false**: no', example='false'),
  alpnPolicy?: string(name='AlpnPolicy', description='The ALPN policy.', example='ALPN'),
  caCertificateIds?: [ string ](name='CaCertificateIds'),
  caEnabled?: boolean(name='CaEnabled', description='Specifies whether to enable mutual authentication. Valid values:

*   **true**: yes
*   **false** (default): no', example='false'),
  certificateIds?: [ string ](name='CertificateIds'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** of each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  cps?: int32(name='Cps', description='The maximum number of connections that can be created per second on the NLB instance. Valid values: **0** to **1000000**. **0** specifies that the number of connections is unlimited.', example='10000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether only to precheck the request. Valid values:

*   **true**: prechecks the request but does not update the configurations of the listener. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.', example='false'),
  idleTimeout?: int32(name='IdleTimeout', description='The timeout period of an idle connection. Unit: seconds. Valid values: **1** to **900**.', example='900'),
  listenerDescription?: string(name='ListenerDescription', description='Enter a name for the listener.

The description must be 2 to 256 characters in length, and can contain letters, digits, commas (,), periods (.), semicolons (;), forward slashes (/), at signs (@), underscores (\\_), and hyphens (-).', example='tcpssl_443'),
  listenerId?: string(name='ListenerId', description='The ID of the listener.', example='lsn-bp1bpn0kn908w4nbw****'),
  mss?: int32(name='Mss', description='The size of the largest TCP segment. Unit: bytes. Valid values: **0** to **1500**. **0** specifies that the maximum segment size remains unchanged. This parameter is supported only by listeners that use SSL over TCP.', example='344'),
  proxyProtocolEnabled?: boolean(name='ProxyProtocolEnabled', description='Specifies whether to use the Proxy protocol to pass client IP addresses to backend servers. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  secSensorEnabled?: boolean(name='SecSensorEnabled', description='Specifies whether to enable fine-grained monitoring. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
  securityPolicyId?: string(name='SecurityPolicyId', description='The ID of the security policy.

>  This parameter takes effect only for listeners that use SSL over TCP.', example='tls_cipher_policy_1_1'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-ppdpc14gdm3x4o****'),
}

model UpdateListenerAttributeResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model UpdateListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateListenerAttributeResponseBody(name='body'),
}

async function updateListenerAttributeWithOptions(request: UpdateListenerAttributeRequest, runtime: Util.RuntimeOptions): UpdateListenerAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alpnEnabled)) {
    body['AlpnEnabled'] = request.alpnEnabled;
  }
  if (!Util.isUnset(request.alpnPolicy)) {
    body['AlpnPolicy'] = request.alpnPolicy;
  }
  if (!Util.isUnset(request.caCertificateIds)) {
    body['CaCertificateIds'] = request.caCertificateIds;
  }
  if (!Util.isUnset(request.caEnabled)) {
    body['CaEnabled'] = request.caEnabled;
  }
  if (!Util.isUnset(request.certificateIds)) {
    body['CertificateIds'] = request.certificateIds;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.cps)) {
    body['Cps'] = request.cps;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.idleTimeout)) {
    body['IdleTimeout'] = request.idleTimeout;
  }
  if (!Util.isUnset(request.listenerDescription)) {
    body['ListenerDescription'] = request.listenerDescription;
  }
  if (!Util.isUnset(request.listenerId)) {
    body['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.mss)) {
    body['Mss'] = request.mss;
  }
  if (!Util.isUnset(request.proxyProtocolEnabled)) {
    body['ProxyProtocolEnabled'] = request.proxyProtocolEnabled;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.secSensorEnabled)) {
    body['SecSensorEnabled'] = request.secSensorEnabled;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    body['SecurityPolicyId'] = request.securityPolicyId;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateListenerAttribute',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateListenerAttribute(request: UpdateListenerAttributeRequest): UpdateListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateListenerAttributeWithOptions(request, runtime);
}

model UpdateLoadBalancerAddressTypeConfigRequest {
  addressType?: string(name='AddressType', description='The new network type. Valid values:

*   **Internet**: The NLB instance uses a public IP address. The domain name of the NLB instance is resolved to the public IP address. Therefore, the NLB instance can be accessed over the Internet.
*   **Intranet**: The NLB instance uses a private IP address. The domain name of the NLB instance is resolved to the private IP address. Therefore, the NLB instance can be accessed over the virtual private cloud (VPC) where the NLB instance is deployed.', example='Internet'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can only contain ASCII characters.

>  If you do not specify this parameter, the system automatically sets **ClientToken** to the value of **RequestId**. **RequestId** of each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to check the request without performing the operation. Valid values:

*   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the check, an HTTP 2xx status code is returned and the operation is performed.', example='false'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the NLB instance.', example='nlb-83ckzc8d4xlp8o****'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  zoneMappings?: [ 
    {
      allocationId?: string(name='AllocationId', description='The ID of the elastic IP address (EIP).', example='eip-bp1aedxso6u80u0qf****'),
      eipType?: string(name='EipType', description='The type of the EIP. Valid values:

*   **Common**: EIP
*   **Anycast**: Anycast EIP

>  Only NLB instances in the China (Hong Kong) region can be associated with Anycast EIPs. This parameter is required if you set the **AddressType** parameter to **Internet**.', example='Common'),
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch in the zone. You can specify only one vSwitch (subnet) in each zone of an NLB instance.', example='vsw-bp10ttov87felojcn****'),
      zoneId?: string(name='ZoneId', description='The ID of the zone of the NLB instance.

You can call the [DescribeZones](~~443890~~) operation to query the most recent zone list.', example='cn-hangzhou-a'),
    }
  ](name='ZoneMappings'),
}

model UpdateLoadBalancerAddressTypeConfigResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model UpdateLoadBalancerAddressTypeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLoadBalancerAddressTypeConfigResponseBody(name='body'),
}

/**
  * *   Make sure that an NLB instance is created. For more information, see [CreateLoadBalancer](~~445868~~).
  * *   You can call the [GetLoadBalancerAttribute](~~445873~~) operation to query the **AddressType** value of an NLB instance after you change the network type.
  * *   **UpdateLoadBalancerAddressTypeConfig** is an asynchronous operation. After you send a request, the request ID is returned but the operation is still being performed in the system background. You can call the [GetJobStatus](~~445904~~) operation to query the task status:
  *     *   If the task is in the **Succeeded** state, the network type of the IPv4 address of the NLB instance is changed.
  *     *   If the task is in the **Processing** state, the network type of the IPv4 address of the NLB instance is being changed. In this case, you can perform only query operations.
  *
  * @param request UpdateLoadBalancerAddressTypeConfigRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateLoadBalancerAddressTypeConfigResponse
 */
async function updateLoadBalancerAddressTypeConfigWithOptions(request: UpdateLoadBalancerAddressTypeConfigRequest, runtime: Util.RuntimeOptions): UpdateLoadBalancerAddressTypeConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.addressType)) {
    body['AddressType'] = request.addressType;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.zoneMappings)) {
    body['ZoneMappings'] = request.zoneMappings;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLoadBalancerAddressTypeConfig',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   Make sure that an NLB instance is created. For more information, see [CreateLoadBalancer](~~445868~~).
  * *   You can call the [GetLoadBalancerAttribute](~~445873~~) operation to query the **AddressType** value of an NLB instance after you change the network type.
  * *   **UpdateLoadBalancerAddressTypeConfig** is an asynchronous operation. After you send a request, the request ID is returned but the operation is still being performed in the system background. You can call the [GetJobStatus](~~445904~~) operation to query the task status:
  *     *   If the task is in the **Succeeded** state, the network type of the IPv4 address of the NLB instance is changed.
  *     *   If the task is in the **Processing** state, the network type of the IPv4 address of the NLB instance is being changed. In this case, you can perform only query operations.
  *
  * @param request UpdateLoadBalancerAddressTypeConfigRequest
  * @return UpdateLoadBalancerAddressTypeConfigResponse
 */
async function updateLoadBalancerAddressTypeConfig(request: UpdateLoadBalancerAddressTypeConfigRequest): UpdateLoadBalancerAddressTypeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoadBalancerAddressTypeConfigWithOptions(request, runtime);
}

model UpdateLoadBalancerAttributeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** of each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  cps?: int32(name='Cps', description='The maximum number of connections that can be created per second on the NLB instance. Valid values: **1** to **1000000**.', example='1'),
  crossZoneEnabled?: boolean(name='CrossZoneEnabled', description='Specifies whether to enable cross-zone load balancing for the NLB instance. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
  dryRun?: boolean(name='DryRun', description='Specifies whether only to precheck this request. Valid values:

*   **true**: prechecks the request but does not modify the name or status of the NLB instance. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.', example='false'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the NLB instance.', example='nlb-wb7r6dlwetvt5j****'),
  loadBalancerName?: string(name='LoadBalancerName', description='The name of the NLB instance.

The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.', example='NLB1'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-beijing'),
}

model UpdateLoadBalancerAttributeResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='aab74cfa-3bc4-48fc-80fc-0101da5a****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7294679F-08DE-16D4-8E5D-1625685DC10B'),
}

model UpdateLoadBalancerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLoadBalancerAttributeResponseBody(name='body'),
}

async function updateLoadBalancerAttributeWithOptions(request: UpdateLoadBalancerAttributeRequest, runtime: Util.RuntimeOptions): UpdateLoadBalancerAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.cps)) {
    body['Cps'] = request.cps;
  }
  if (!Util.isUnset(request.crossZoneEnabled)) {
    body['CrossZoneEnabled'] = request.crossZoneEnabled;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.loadBalancerName)) {
    body['LoadBalancerName'] = request.loadBalancerName;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLoadBalancerAttribute',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLoadBalancerAttribute(request: UpdateLoadBalancerAttributeRequest): UpdateLoadBalancerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoadBalancerAttributeWithOptions(request, runtime);
}

model UpdateLoadBalancerProtectionRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.

>  If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-426655440000'),
  deletionProtectionEnabled?: boolean(name='DeletionProtectionEnabled', description='Specifies whether to enable deletion protection. Valid values:

*   **true**
*   **false**', example='false'),
  deletionProtectionReason?: string(name='DeletionProtectionReason', description='The reason for enabling deletion protection. The reason must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The reason must start with a letter.

>  This parameter is valid only if you set **DeletionProtectionEnabled** to **true**.'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the NLB instance.', example='nlb-83ckzc8d4xlp8o****'),
  modificationProtectionReason?: string(name='ModificationProtectionReason', description='The reason for enabling the configuration read-only mode. The reason must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The reason must start with a letter.

>  This parameter takes effect only if you set **Status** to **ConsoleProtection**.'),
  modificationProtectionStatus?: string(name='ModificationProtectionStatus', description='Specifies whether to enable the configuration read-only mode. Valid values:

*   **NonProtection**: disables the configuration read-only mode. In this case, you cannot specify **ModificationProtectionReason**. If you specify **ModificationProtectionReason**, the value is cleared.
*   **ConsoleProtection**: enables the configuration read-only mode. In this case, you can specify **ModificationProtectionReason**.

>  If you set this parameter to **ConsoleProtection**, you cannot modify instance configurations in the NLB console. However, you can modify instance configurations by calling API operations.', example='ConsoleProtection'),
  regionId?: string(name='RegionId', description='The region ID of the NLB instance.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
}

model UpdateLoadBalancerProtectionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model UpdateLoadBalancerProtectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLoadBalancerProtectionResponseBody(name='body'),
}

/**
  * >  You can call the [GetLoadBalancerAttribute](~~445873~~) operation to query the details of deletion protection and the configuration read-only mode.
  *
  * @param request UpdateLoadBalancerProtectionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateLoadBalancerProtectionResponse
 */
async function updateLoadBalancerProtectionWithOptions(request: UpdateLoadBalancerProtectionRequest, runtime: Util.RuntimeOptions): UpdateLoadBalancerProtectionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.deletionProtectionEnabled)) {
    body['DeletionProtectionEnabled'] = request.deletionProtectionEnabled;
  }
  if (!Util.isUnset(request.deletionProtectionReason)) {
    body['DeletionProtectionReason'] = request.deletionProtectionReason;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.modificationProtectionReason)) {
    body['ModificationProtectionReason'] = request.modificationProtectionReason;
  }
  if (!Util.isUnset(request.modificationProtectionStatus)) {
    body['ModificationProtectionStatus'] = request.modificationProtectionStatus;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLoadBalancerProtection',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call the [GetLoadBalancerAttribute](~~445873~~) operation to query the details of deletion protection and the configuration read-only mode.
  *
  * @param request UpdateLoadBalancerProtectionRequest
  * @return UpdateLoadBalancerProtectionResponse
 */
async function updateLoadBalancerProtection(request: UpdateLoadBalancerProtectionRequest): UpdateLoadBalancerProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoadBalancerProtectionWithOptions(request, runtime);
}

model UpdateLoadBalancerZonesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can only contain ASCII characters.

>  If you do not specify this parameter, the system automatically sets **ClientToken** to the value of **RequestId**. **RequestId** of each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to check the request without performing the operation. Valid values:

*   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
*   **false**: sends the request. If the request passes the check, an HTTP 2xx status code is returned and the operation is performed. This is the default value.', example='false'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the NLB instance.', example='nlb-83ckzc8d4xlp8o****'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  zoneMappings?: [ 
    {
      allocationId?: string(name='AllocationId', description='The ID of the elastic IP address (EIP) or Anycast EIP.', example='eip-bp1aedxso6u80u0qf****'),
      eipType?: string(name='EipType', description='The type of the EIP. Valid values:

*   **Common**: EIP
*   **Anycast**: Anycast EIP

>  Only NLB instances in the China (Hong Kong) region can be associated with Anycast EIPs. This parameter is required if you set the **AddressType** parameter to **Internet**.', example='Common'),
      privateIPv4Address?: string(name='PrivateIPv4Address', description='The private IP addresses.', example='192.168.36.16'),
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch in the zone. By default, each zone contains one vSwitch and one subnet.', example='vsw-bp1rmcrwg3erh1fh8****'),
      zoneId?: string(name='ZoneId', description='The ID of the zone. You can call the [DescribeZones](~~443890~~) operation to query the zones.', example='cn-hangzhou-a'),
    }
  ](name='ZoneMappings'),
}

model UpdateLoadBalancerZonesResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model UpdateLoadBalancerZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLoadBalancerZonesResponseBody(name='body'),
}

/**
  * - Make sure that an NLB instance is created. For more information, see [CreateLoadBalancer](/help/en/server-load-balancer/latest/createloadbalancer).
  * - You can call the [GetLoadBalancerAttribute](/help/en/server-load-balancer/latest/getloadbalancerattribute-nlb) operation to query the zones and zone attributes of an NLB instance.
  * - **UpdateLoadBalancerZones** is an asynchronous operation. After you send a request, the request ID is returned but the operation is still being performed in the system background. You can call the [GetJobStatus](/help/en/server-load-balancer/latest/getjobstatus) operation to query the status of a task: 
  *          - If the task is in the **Succeeded** state, the zones and zone attributes are modified.
  *   - If the task is in the **Processing** state, the zones and zone attributes are being modified. In this case, you can perform only query operations.
  * ## Precautions
  * When you call this operation, make sure that you specify all the zones of the NLB instance, including the existing zones and new zones. If you do not specify the existing zones, the existing zones are removed.
  *
  * @param request UpdateLoadBalancerZonesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateLoadBalancerZonesResponse
 */
async function updateLoadBalancerZonesWithOptions(request: UpdateLoadBalancerZonesRequest, runtime: Util.RuntimeOptions): UpdateLoadBalancerZonesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.zoneMappings)) {
    body['ZoneMappings'] = request.zoneMappings;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLoadBalancerZones',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * - Make sure that an NLB instance is created. For more information, see [CreateLoadBalancer](/help/en/server-load-balancer/latest/createloadbalancer).
  * - You can call the [GetLoadBalancerAttribute](/help/en/server-load-balancer/latest/getloadbalancerattribute-nlb) operation to query the zones and zone attributes of an NLB instance.
  * - **UpdateLoadBalancerZones** is an asynchronous operation. After you send a request, the request ID is returned but the operation is still being performed in the system background. You can call the [GetJobStatus](/help/en/server-load-balancer/latest/getjobstatus) operation to query the status of a task: 
  *          - If the task is in the **Succeeded** state, the zones and zone attributes are modified.
  *   - If the task is in the **Processing** state, the zones and zone attributes are being modified. In this case, you can perform only query operations.
  * ## Precautions
  * When you call this operation, make sure that you specify all the zones of the NLB instance, including the existing zones and new zones. If you do not specify the existing zones, the existing zones are removed.
  *
  * @param request UpdateLoadBalancerZonesRequest
  * @return UpdateLoadBalancerZonesResponse
 */
async function updateLoadBalancerZones(request: UpdateLoadBalancerZonesRequest): UpdateLoadBalancerZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoadBalancerZonesWithOptions(request, runtime);
}

model UpdateSecurityPolicyAttributeRequest {
  ciphers?: [ string ](name='Ciphers'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether only to precheck the request. Valid values:

*   **true**: prechecks the request but does not modify the configurations of the security policy. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.', example='false'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  securityPolicyId?: string(name='SecurityPolicyId', description='The ID of the TLS security policy.', example='tls-bp14bb1e7dll4f****'),
  securityPolicyName?: string(name='SecurityPolicyName', description='The name of the security policy.

The name must be 1 to 200 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-).', example='TLSCipherPolicy'),
  tlsVersions?: [ string ](name='TlsVersions'),
}

model UpdateSecurityPolicyAttributeResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='D7A8875F-373A-5F48-8484-25B07A61F2AF'),
  securityPolicyId?: string(name='SecurityPolicyId', description='The ID of the TLS security policy.', example='tls-bp14bb1e7dll4f****'),
}

model UpdateSecurityPolicyAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSecurityPolicyAttributeResponseBody(name='body'),
}

async function updateSecurityPolicyAttributeWithOptions(request: UpdateSecurityPolicyAttributeRequest, runtime: Util.RuntimeOptions): UpdateSecurityPolicyAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ciphers)) {
    body['Ciphers'] = request.ciphers;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    body['SecurityPolicyId'] = request.securityPolicyId;
  }
  if (!Util.isUnset(request.securityPolicyName)) {
    body['SecurityPolicyName'] = request.securityPolicyName;
  }
  if (!Util.isUnset(request.tlsVersions)) {
    body['TlsVersions'] = request.tlsVersions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSecurityPolicyAttribute',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSecurityPolicyAttribute(request: UpdateSecurityPolicyAttributeRequest): UpdateSecurityPolicyAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSecurityPolicyAttributeWithOptions(request, runtime);
}

model UpdateServerGroupAttributeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters.

>  If you do not specify this parameter, the system automatically sets **ClientToken** to the value of **RequestId**. **RequestId** may be different for each API request.', example='123e4567-e89b-12d3-a456-426655440000'),
  connectionDrainEnabled?: boolean(name='ConnectionDrainEnabled', description='Specifies whether to enable connection draining. Valid values:

*   **true**: enables connection draining.
*   **false**: disables connection draining.', example='false'),
  connectionDrainTimeout?: int32(name='ConnectionDrainTimeout', description='The timeout period of connection draining. Unit: seconds. Valid values: **10** to **900**.', example='10'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to only precheck the request. Valid values:

*   **true**: checks the request without performing the UpdateServerGroupAttribute operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the check, a 2xx HTTP status code is returned and the UpdateServerGroupAttribute operation is performed.', example='false'),
  healthCheckConfig?: {
    healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='The backend port that is used for health checks. Valid values: **0** to **65535**. If you set the value to **0**, the ports of backend servers are used for health checks.', example='0'),
    healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='The maximum timeout period of a health check response. Unit: seconds. Valid values: **1** to **300**.', example='100'),
    healthCheckDomain?: string(name='HealthCheckDomain', description='The domain name that is used for health checks. Valid values:

*   **$SERVER_IP**: the private IP address of a backend server.
*   **domain**: a specific domain name. The domain name must be 1 to 80 characters in length and can contain lowercase letters, digits, hyphens (-), and periods (.).

>  This parameter takes effect only when you set **HealthCheckType** to **HTTP**.', example='$SERVER_IP'),
    healthCheckEnabled?: boolean(name='HealthCheckEnabled', description='Specifies whether to enable the health check feature. Valid values:

*   **true**: enables the health check feature.
*   **false**: disables the health check feature.', example='false'),
    healthCheckHttpCode?: [ string ](name='HealthCheckHttpCode'),
    healthCheckInterval?: int32(name='HealthCheckInterval', description='The interval between two consecutive health checks. Unit: seconds.

Valid values: **5** to **50**.', example='5'),
    healthCheckType?: string(name='HealthCheckType', description='The protocol that is used for health checks. Valid values: **TCP** and **HTTP**.', example='TCP'),
    healthCheckUrl?: string(name='HealthCheckUrl', description='The path to which health check requests are sent.

The path must be 1 to 80 characters in length, and can contain only letters, digits, and the following special characters: `- / . % ? # & =`. The path can also contain the following extended characters: `_ ; ~ ! ( ) * [ ] @ $ ^ : \\" , +`. The path must start with a forward slash (/).

>  This parameter takes effect only when you set **HealthCheckType** to **HTTP**.', example='/test/index.html'),
    healthyThreshold?: int32(name='HealthyThreshold', description='The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**. Valid values: **2** to **10**.', example='3'),
    httpCheckMethod?: string(name='HttpCheckMethod', description='The HTTP method that is used for health checks. Valid values: **GET** and **HEAD**.

>  This parameter takes effect only when you set **HealthCheckType** to **HTTP**.', example='GET'),
    unhealthyThreshold?: int32(name='UnhealthyThreshold', description='The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**. Valid values: **2** to **10**.', example='3'),
  }(name='HealthCheckConfig'),
  preserveClientIpEnabled?: boolean(name='PreserveClientIpEnabled', description='Specifies whether to enable client IP preservation. Valid values:

*   **true**: enables client IP preservation.
*   **false**: disables client IP preservation.', example='false'),
  regionId?: string(name='RegionId', description='The ID of the region where the NLB instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the available regions.', example='cn-hangzhou'),
  scheduler?: string(name='Scheduler', description='The scheduling algorithm. Valid values:

*   **Wrr**: Backend servers with higher weights receive more requests than backend servers with lower weights.
*   **rr**: Requests are forwarded to backend servers in sequence.
*   **sch**: Requests from the same source IP address are forwarded to the same backend server.
*   **tch**: Four-element hashing is used. This value specifies consistent hashing that is based on four factors: source IP address, destination IP address, source port, and destination port. Requests that contain the same information based on the four factors are forwarded to the same backend server.
*   **qch**: Requests that contain the same QUIC ID are forwarded to the same backend server.', example='Wrr'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-atstuj3rtoptyui****'),
  serverGroupName?: string(name='ServerGroupName', description='The new name of the server group.

The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.', example='NLB_ServerGroup1'),
}

model UpdateServerGroupAttributeResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-atstuj3rtoptyui****'),
}

model UpdateServerGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServerGroupAttributeResponseBody(name='body'),
}

async function updateServerGroupAttributeWithOptions(request: UpdateServerGroupAttributeRequest, runtime: Util.RuntimeOptions): UpdateServerGroupAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.connectionDrainEnabled)) {
    body['ConnectionDrainEnabled'] = request.connectionDrainEnabled;
  }
  if (!Util.isUnset(request.connectionDrainTimeout)) {
    body['ConnectionDrainTimeout'] = request.connectionDrainTimeout;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.healthCheckConfig)) {
    bodyFlat['HealthCheckConfig'] = request.healthCheckConfig;
  }
  if (!Util.isUnset(request.preserveClientIpEnabled)) {
    body['PreserveClientIpEnabled'] = request.preserveClientIpEnabled;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.scheduler)) {
    body['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.serverGroupName)) {
    body['ServerGroupName'] = request.serverGroupName;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServerGroupAttribute',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateServerGroupAttribute(request: UpdateServerGroupAttributeRequest): UpdateServerGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateServerGroupAttributeWithOptions(request, runtime);
}

model UpdateServerGroupServersAttributeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can only contain ASCII characters.

>  If you do not specify this parameter, the system automatically sets **ClientToken** to the value of **RequestId**. **RequestId** of each API request may be different.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run. Valid values:

*   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  regionId?: string(name='RegionId', description='The ID of the region where the Network Load Balancer (NLB) instance is deployed.

You can call the [DescribeRegions](~~443657~~) operation to query the most recent region list.', example='cn-hangzhou'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-atstuj3rtoptyui****'),
  servers?: [ 
    {
      description?: string(name='Description', description='The description of the backend server.

The description must be 2 to 256 characters in length, and can contain letters, digits, commas (,), periods (.), semicolons (;), forward slashes (/), at signs (@), underscores (\\_), and hyphens (-).'),
      port?: int32(name='Port', description='The port used by the backend server. Valid values: **1** to **65535**. You can specify at most 40 backend servers in each call.

>  The value of this parameter cannot be modified.', example='443'),
      serverId?: string(name='ServerId', description='The ID of the backend server. You can specify at most 40 backend servers in each call.

*   If the server group type is **Instance**, set the ServerId parameter to the ID of an Elastic Compute Service (ECS) instance, an elastic network interface (ENI), or an elastic container instance. These backend servers are specified by **Ecs**, **Eni**, or **Eci**.
*   If the server group type is **Ip**, set the ServerId parameter to an IP address.', example='ecs-bp67acfmxazb4p****'),
      serverIp?: string(name='ServerIp', description='The IP address of the server. If the server group type is **Ip**, you must specify an IP address.

>  You can specify at most 40 backend servers in each call.', example='192.168.6.6'),
      serverType?: string(name='ServerType', description='The type of the backend server. Valid values:

*   **Ecs**: an ECS instance
*   **Eni**: an ENI
*   **Eci**: an elastic container instance
*   **Ip**: an IP address

>  You can specify at most 40 backend servers in each call.', example='Ecs'),
      weight?: int32(name='Weight', description='The weight of the backend server. Valid values: **0** to **100**. Default value: **100**. If the weight of a backend server is set to **0**, no requests are forwarded to the backend server.

>  You can specify at most 40 backend servers in each call.', example='100'),
    }
  ](name='Servers'),
}

model UpdateServerGroupServersAttributeResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='54B48E3D-DF70-471B-AA93-08E683A1B45'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-atstuj3rtoptyui****'),
}

model UpdateServerGroupServersAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServerGroupServersAttributeResponseBody(name='body'),
}

/**
  * The **UpdateServerGroupServersAttribute** operation is asynchronous. After you send a request, the system returns the request ID, but the operation is still being performed in the system background.
  * 1\\. You can call [ListServerGroups](~~445895~~) to query the status of a server group.
  * *   If a server group is in the **Configuring** state, it indicates that the server group is being modified.
  * *   If a server group is in the **Available** state, it indicates that the server group is running.
  * 2\\. You can call [ListServerGroupServers](~~445896~~) to query the status of a backend server.
  * *   If a backend server is in the **Configuring** state, it indicates that the backend server is being modified.
  * *   If a backend server is in the **Available** state, it indicates that the backend server is running.
  *
  * @param request UpdateServerGroupServersAttributeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateServerGroupServersAttributeResponse
 */
async function updateServerGroupServersAttributeWithOptions(request: UpdateServerGroupServersAttributeRequest, runtime: Util.RuntimeOptions): UpdateServerGroupServersAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.servers)) {
    body['Servers'] = request.servers;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServerGroupServersAttribute',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The **UpdateServerGroupServersAttribute** operation is asynchronous. After you send a request, the system returns the request ID, but the operation is still being performed in the system background.
  * 1\\. You can call [ListServerGroups](~~445895~~) to query the status of a server group.
  * *   If a server group is in the **Configuring** state, it indicates that the server group is being modified.
  * *   If a server group is in the **Available** state, it indicates that the server group is running.
  * 2\\. You can call [ListServerGroupServers](~~445896~~) to query the status of a backend server.
  * *   If a backend server is in the **Configuring** state, it indicates that the backend server is being modified.
  * *   If a backend server is in the **Available** state, it indicates that the backend server is running.
  *
  * @param request UpdateServerGroupServersAttributeRequest
  * @return UpdateServerGroupServersAttributeResponse
 */
async function updateServerGroupServersAttribute(request: UpdateServerGroupServersAttributeRequest): UpdateServerGroupServersAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateServerGroupServersAttributeWithOptions(request, runtime);
}

