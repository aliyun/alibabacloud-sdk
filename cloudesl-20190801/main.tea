/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'cloudesl.aliyuncs.com',
    ap-northeast-2-pop = 'cloudesl.aliyuncs.com',
    ap-south-1 = 'cloudesl.aliyuncs.com',
    ap-southeast-1 = 'cloudesl.aliyuncs.com',
    ap-southeast-2 = 'cloudesl.aliyuncs.com',
    ap-southeast-3 = 'cloudesl.aliyuncs.com',
    ap-southeast-5 = 'cloudesl.aliyuncs.com',
    cn-beijing = 'cloudesl.aliyuncs.com',
    cn-beijing-finance-1 = 'cloudesl.aliyuncs.com',
    cn-beijing-finance-pop = 'cloudesl.aliyuncs.com',
    cn-beijing-gov-1 = 'cloudesl.aliyuncs.com',
    cn-beijing-nu16-b01 = 'cloudesl.aliyuncs.com',
    cn-chengdu = 'cloudesl.aliyuncs.com',
    cn-edge-1 = 'cloudesl.aliyuncs.com',
    cn-fujian = 'cloudesl.aliyuncs.com',
    cn-haidian-cm12-c01 = 'cloudesl.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'cloudesl.aliyuncs.com',
    cn-hangzhou-finance = 'cloudesl.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'cloudesl.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'cloudesl.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'cloudesl.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'cloudesl.aliyuncs.com',
    cn-hangzhou-test-306 = 'cloudesl.aliyuncs.com',
    cn-hongkong = 'cloudesl.aliyuncs.com',
    cn-hongkong-finance-pop = 'cloudesl.aliyuncs.com',
    cn-huhehaote = 'cloudesl.aliyuncs.com',
    cn-north-2-gov-1 = 'cloudesl.aliyuncs.com',
    cn-qingdao = 'cloudesl.aliyuncs.com',
    cn-qingdao-nebula = 'cloudesl.aliyuncs.com',
    cn-shanghai = 'cloudesl.aliyuncs.com',
    cn-shanghai-et15-b01 = 'cloudesl.aliyuncs.com',
    cn-shanghai-et2-b01 = 'cloudesl.aliyuncs.com',
    cn-shanghai-finance-1 = 'cloudesl.aliyuncs.com',
    cn-shanghai-inner = 'cloudesl.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'cloudesl.aliyuncs.com',
    cn-shenzhen = 'cloudesl.aliyuncs.com',
    cn-shenzhen-finance-1 = 'cloudesl.aliyuncs.com',
    cn-shenzhen-inner = 'cloudesl.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'cloudesl.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'cloudesl.aliyuncs.com',
    cn-wuhan = 'cloudesl.aliyuncs.com',
    cn-yushanfang = 'cloudesl.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'cloudesl.aliyuncs.com',
    cn-zhangjiakou = 'cloudesl.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'cloudesl.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'cloudesl.aliyuncs.com',
    eu-central-1 = 'cloudesl.aliyuncs.com',
    eu-west-1 = 'cloudesl.aliyuncs.com',
    eu-west-1-oxs = 'cloudesl.aliyuncs.com',
    me-east-1 = 'cloudesl.aliyuncs.com',
    rus-west-1-pop = 'cloudesl.aliyuncs.com',
    us-east-1 = 'cloudesl.aliyuncs.com',
    us-west-1 = 'cloudesl.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('cloudesl', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ActivateApDeviceRequest {
  apMac?: string(name='ApMac', description='This parameter is required.'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model ActivateApDeviceResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ActivateApDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ActivateApDeviceResponseBody(name='body'),
}

/**
 * @param request ActivateApDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ActivateApDeviceResponse
 */
async function activateApDeviceWithOptions(request: ActivateApDeviceRequest, runtime: Util.RuntimeOptions): ActivateApDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apMac)) {
    body['ApMac'] = request.apMac;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ActivateApDevice',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ActivateApDeviceRequest
 * @return ActivateApDeviceResponse
 */
async function activateApDevice(request: ActivateApDeviceRequest): ActivateApDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return activateApDeviceWithOptions(request, runtime);
}

model AddApDeviceRequest {
  apMac?: string(name='ApMac', description='This parameter is required.'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model AddApDeviceResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddApDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddApDeviceResponseBody(name='body'),
}

/**
 * @param request AddApDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddApDeviceResponse
 */
async function addApDeviceWithOptions(request: AddApDeviceRequest, runtime: Util.RuntimeOptions): AddApDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apMac)) {
    body['ApMac'] = request.apMac;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddApDevice',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddApDeviceRequest
 * @return AddApDeviceResponse
 */
async function addApDevice(request: AddApDeviceRequest): AddApDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addApDeviceWithOptions(request, runtime);
}

model AddEslDeviceRequest {
  eslBarCode?: string(name='EslBarCode', description='This parameter is required.'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model AddEslDeviceResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddEslDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddEslDeviceResponseBody(name='body'),
}

/**
 * @param request AddEslDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddEslDeviceResponse
 */
async function addEslDeviceWithOptions(request: AddEslDeviceRequest, runtime: Util.RuntimeOptions): AddEslDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eslBarCode)) {
    body['EslBarCode'] = request.eslBarCode;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddEslDevice',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddEslDeviceRequest
 * @return AddEslDeviceResponse
 */
async function addEslDevice(request: AddEslDeviceRequest): AddEslDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addEslDeviceWithOptions(request, runtime);
}

model AddUserRequest {
  userId?: string(name='UserId', description='This parameter is required.', example='user1'),
}

model AddUserResponseBody = {
  code?: string(name='Code', example='-1001'),
  dynamicCode?: string(name='DynamicCode', example='PlatformResponseError.%s'),
  dynamicMessage?: string(name='DynamicMessage', example='The specified store %s does not exist.'),
  errorCode?: string(name='ErrorCode', example='MandatoryParameters'),
  errorMessage?: string(name='ErrorMessage', example='The specified resource type is invalid.'),
  message?: string(name='Message', example='success'),
  requestId?: string(name='RequestId', example='E69C8998-1787-4999-8C75-D663FF1173CF'),
  success?: boolean(name='Success', example='true'),
}

model AddUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddUserResponseBody(name='body'),
}

/**
 * @param request AddUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddUserResponse
 */
async function addUserWithOptions(request: AddUserRequest, runtime: Util.RuntimeOptions): AddUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddUser',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddUserRequest
 * @return AddUserResponse
 */
async function addUser(request: AddUserRequest): AddUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUserWithOptions(request, runtime);
}

model AssignUserRequest {
  stores?: string(name='Stores'),
  userId?: string(name='UserId', description='This parameter is required.'),
  userType?: string(name='UserType', description='This parameter is required.'),
}

model AssignUserResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AssignUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AssignUserResponseBody(name='body'),
}

/**
 * @param request AssignUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssignUserResponse
 */
async function assignUserWithOptions(request: AssignUserRequest, runtime: Util.RuntimeOptions): AssignUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.stores)) {
    body['Stores'] = request.stores;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userType)) {
    body['UserType'] = request.userType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AssignUser',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AssignUserRequest
 * @return AssignUserResponse
 */
async function assignUser(request: AssignUserRequest): AssignUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return assignUserWithOptions(request, runtime);
}

model BatchInsertItemsRequest {
  itemInfo?: [ 
    {
      actionPrice?: int32(name='ActionPrice'),
      bePromotion?: boolean(name='BePromotion'),
      beSourceCode?: boolean(name='BeSourceCode'),
      brandName?: string(name='BrandName'),
      categoryName?: string(name='CategoryName'),
      companyId?: string(name='CompanyId'),
      customizeFeatureA?: string(name='CustomizeFeatureA'),
      customizeFeatureB?: string(name='CustomizeFeatureB'),
      customizeFeatureC?: string(name='CustomizeFeatureC'),
      customizeFeatureD?: string(name='CustomizeFeatureD'),
      customizeFeatureE?: string(name='CustomizeFeatureE'),
      customizeFeatureF?: string(name='CustomizeFeatureF'),
      customizeFeatureG?: string(name='CustomizeFeatureG'),
      customizeFeatureH?: string(name='CustomizeFeatureH'),
      customizeFeatureI?: string(name='CustomizeFeatureI'),
      customizeFeatureJ?: string(name='CustomizeFeatureJ'),
      energyEfficiency?: string(name='EnergyEfficiency'),
      extraAttribute?: string(name='ExtraAttribute'),
      forestFirstId?: string(name='ForestFirstId'),
      forestSecondId?: string(name='ForestSecondId'),
      itemBarCode?: string(name='ItemBarCode'),
      itemId?: long(name='ItemId'),
      itemInfoIndex?: int32(name='ItemInfoIndex'),
      itemQrCode?: string(name='ItemQrCode'),
      itemShortTitle?: string(name='ItemShortTitle'),
      itemTitle?: string(name='ItemTitle'),
      memberPrice?: int32(name='MemberPrice'),
      modelNumber?: string(name='ModelNumber'),
      optionGroups?: string(name='OptionGroups'),
      originalPrice?: int32(name='OriginalPrice'),
      priceUnit?: string(name='PriceUnit'),
      productionPlace?: string(name='ProductionPlace'),
      promotionEnd?: string(name='PromotionEnd'),
      promotionReason?: string(name='PromotionReason'),
      promotionStart?: string(name='PromotionStart'),
      promotionText?: string(name='PromotionText'),
      rank?: string(name='Rank'),
      saleSpec?: string(name='SaleSpec'),
      skuId?: string(name='SkuId'),
      sourceCode?: string(name='SourceCode'),
      storeId?: string(name='StoreId'),
      suggestPrice?: int32(name='SuggestPrice'),
    }
  ](name='ItemInfo', description='This parameter is required.'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model BatchInsertItemsResponseBody = {
  batchResults?: {
    batchResult?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      index?: int32(name='Index'),
      message?: string(name='Message'),
      success?: boolean(name='Success'),
    }
  ](name='BatchResult')
  }(name='BatchResults'),
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchInsertItemsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchInsertItemsResponseBody(name='body'),
}

/**
 * @param request BatchInsertItemsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchInsertItemsResponse
 */
async function batchInsertItemsWithOptions(request: BatchInsertItemsRequest, runtime: Util.RuntimeOptions): BatchInsertItemsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.itemInfo)) {
    body['ItemInfo'] = request.itemInfo;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchInsertItems',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchInsertItemsRequest
 * @return BatchInsertItemsResponse
 */
async function batchInsertItems(request: BatchInsertItemsRequest): BatchInsertItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchInsertItemsWithOptions(request, runtime);
}

model BindEslDeviceRequest {
  eslBarCode?: string(name='EslBarCode', description='This parameter is required.'),
  itemBarCode?: string(name='ItemBarCode', description='This parameter is required.'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model BindEslDeviceResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BindEslDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindEslDeviceResponseBody(name='body'),
}

/**
 * @param request BindEslDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindEslDeviceResponse
 */
async function bindEslDeviceWithOptions(request: BindEslDeviceRequest, runtime: Util.RuntimeOptions): BindEslDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eslBarCode)) {
    body['EslBarCode'] = request.eslBarCode;
  }
  if (!Util.isUnset(request.itemBarCode)) {
    body['ItemBarCode'] = request.itemBarCode;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BindEslDevice',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BindEslDeviceRequest
 * @return BindEslDeviceResponse
 */
async function bindEslDevice(request: BindEslDeviceRequest): BindEslDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindEslDeviceWithOptions(request, runtime);
}

model BindEslDeviceShelfRequest {
  eslBarCode?: string(name='EslBarCode', description='This parameter is required.'),
  shelfCode?: string(name='ShelfCode', description='This parameter is required.'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model BindEslDeviceShelfResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BindEslDeviceShelfResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindEslDeviceShelfResponseBody(name='body'),
}

/**
 * @param request BindEslDeviceShelfRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindEslDeviceShelfResponse
 */
async function bindEslDeviceShelfWithOptions(request: BindEslDeviceShelfRequest, runtime: Util.RuntimeOptions): BindEslDeviceShelfResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eslBarCode)) {
    body['EslBarCode'] = request.eslBarCode;
  }
  if (!Util.isUnset(request.shelfCode)) {
    body['ShelfCode'] = request.shelfCode;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BindEslDeviceShelf',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BindEslDeviceShelfRequest
 * @return BindEslDeviceShelfResponse
 */
async function bindEslDeviceShelf(request: BindEslDeviceShelfRequest): BindEslDeviceShelfResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindEslDeviceShelfWithOptions(request, runtime);
}

model ConfirmLogisticsRequest {
  logisticsDocuments?: string(name='LogisticsDocuments'),
  poNumber?: string(name='PoNumber', description='This parameter is required.'),
  prNumber?: string(name='PrNumber', description='This parameter is required.'),
  status?: string(name='Status'),
}

model ConfirmLogisticsResponseBody = {
  acceptance?: string(name='Acceptance'),
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConfirmLogisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfirmLogisticsResponseBody(name='body'),
}

/**
 * @param request ConfirmLogisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfirmLogisticsResponse
 */
async function confirmLogisticsWithOptions(request: ConfirmLogisticsRequest, runtime: Util.RuntimeOptions): ConfirmLogisticsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.logisticsDocuments)) {
    body['LogisticsDocuments'] = request.logisticsDocuments;
  }
  if (!Util.isUnset(request.poNumber)) {
    body['PoNumber'] = request.poNumber;
  }
  if (!Util.isUnset(request.prNumber)) {
    body['PrNumber'] = request.prNumber;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmLogistics',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ConfirmLogisticsRequest
 * @return ConfirmLogisticsResponse
 */
async function confirmLogistics(request: ConfirmLogisticsRequest): ConfirmLogisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmLogisticsWithOptions(request, runtime);
}

model CreateStoreRequest {
  brand?: string(name='Brand'),
  comments?: string(name='Comments'),
  companyId?: string(name='CompanyId', description='This parameter is required.'),
  groups?: string(name='Groups'),
  outId?: string(name='OutId'),
  parentId?: string(name='ParentId'),
  phone?: string(name='Phone', description='This parameter is required.'),
  storeName?: string(name='StoreName', description='This parameter is required.'),
}

model CreateStoreResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  storeId?: string(name='StoreId'),
  success?: boolean(name='Success'),
}

model CreateStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateStoreResponseBody(name='body'),
}

/**
 * @param request CreateStoreRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateStoreResponse
 */
async function createStoreWithOptions(request: CreateStoreRequest, runtime: Util.RuntimeOptions): CreateStoreResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.brand)) {
    body['Brand'] = request.brand;
  }
  if (!Util.isUnset(request.comments)) {
    body['Comments'] = request.comments;
  }
  if (!Util.isUnset(request.companyId)) {
    body['CompanyId'] = request.companyId;
  }
  if (!Util.isUnset(request.groups)) {
    body['Groups'] = request.groups;
  }
  if (!Util.isUnset(request.outId)) {
    body['OutId'] = request.outId;
  }
  if (!Util.isUnset(request.parentId)) {
    body['ParentId'] = request.parentId;
  }
  if (!Util.isUnset(request.phone)) {
    body['Phone'] = request.phone;
  }
  if (!Util.isUnset(request.storeName)) {
    body['StoreName'] = request.storeName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateStore',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateStoreRequest
 * @return CreateStoreResponse
 */
async function createStore(request: CreateStoreRequest): CreateStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  return createStoreWithOptions(request, runtime);
}

model DeleteApDeviceRequest {
  apMac?: string(name='ApMac', description='This parameter is required.'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model DeleteApDeviceResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteApDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteApDeviceResponseBody(name='body'),
}

/**
 * @param request DeleteApDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteApDeviceResponse
 */
async function deleteApDeviceWithOptions(request: DeleteApDeviceRequest, runtime: Util.RuntimeOptions): DeleteApDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apMac)) {
    body['ApMac'] = request.apMac;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteApDevice',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteApDeviceRequest
 * @return DeleteApDeviceResponse
 */
async function deleteApDevice(request: DeleteApDeviceRequest): DeleteApDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteApDeviceWithOptions(request, runtime);
}

model DeleteEslDeviceRequest {
  eslBarCode?: string(name='EslBarCode', description='This parameter is required.'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model DeleteEslDeviceResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteEslDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteEslDeviceResponseBody(name='body'),
}

/**
 * @param request DeleteEslDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEslDeviceResponse
 */
async function deleteEslDeviceWithOptions(request: DeleteEslDeviceRequest, runtime: Util.RuntimeOptions): DeleteEslDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eslBarCode)) {
    body['EslBarCode'] = request.eslBarCode;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEslDevice',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteEslDeviceRequest
 * @return DeleteEslDeviceResponse
 */
async function deleteEslDevice(request: DeleteEslDeviceRequest): DeleteEslDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEslDeviceWithOptions(request, runtime);
}

model DeleteItemRequest {
  itemBarCode?: string(name='ItemBarCode', description='This parameter is required.'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model DeleteItemResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteItemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteItemResponseBody(name='body'),
}

/**
 * @param request DeleteItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteItemResponse
 */
async function deleteItemWithOptions(request: DeleteItemRequest, runtime: Util.RuntimeOptions): DeleteItemResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.itemBarCode)) {
    body['ItemBarCode'] = request.itemBarCode;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteItem',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteItemRequest
 * @return DeleteItemResponse
 */
async function deleteItem(request: DeleteItemRequest): DeleteItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteItemWithOptions(request, runtime);
}

model DeleteItemBySkuIdRequest {
  skuId?: string(name='SkuId', description='This parameter is required.'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model DeleteItemBySkuIdResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteItemBySkuIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteItemBySkuIdResponseBody(name='body'),
}

/**
 * @param request DeleteItemBySkuIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteItemBySkuIdResponse
 */
async function deleteItemBySkuIdWithOptions(request: DeleteItemBySkuIdRequest, runtime: Util.RuntimeOptions): DeleteItemBySkuIdResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.skuId)) {
    body['SkuId'] = request.skuId;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteItemBySkuId',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteItemBySkuIdRequest
 * @return DeleteItemBySkuIdResponse
 */
async function deleteItemBySkuId(request: DeleteItemBySkuIdRequest): DeleteItemBySkuIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteItemBySkuIdWithOptions(request, runtime);
}

model DeleteStoreRequest {
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model DeleteStoreResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteStoreResponseBody(name='body'),
}

/**
 * @param request DeleteStoreRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteStoreResponse
 */
async function deleteStoreWithOptions(request: DeleteStoreRequest, runtime: Util.RuntimeOptions): DeleteStoreResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteStore',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteStoreRequest
 * @return DeleteStoreResponse
 */
async function deleteStore(request: DeleteStoreRequest): DeleteStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteStoreWithOptions(request, runtime);
}

model DeleteUserRequest {
  userId?: string(name='UserId', description='This parameter is required.'),
}

model DeleteUserResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteUserResponseBody(name='body'),
}

/**
 * @param request DeleteUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteUserResponse
 */
async function deleteUserWithOptions(request: DeleteUserRequest, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUser',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteUserRequest
 * @return DeleteUserResponse
 */
async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserWithOptions(request, runtime);
}

model DescribeAlarmsRequest {
  alarmId?: string(name='AlarmId'),
  alarmStatus?: string(name='AlarmStatus'),
  alarmType?: string(name='AlarmType'),
  errorType?: string(name='ErrorType'),
  fromAlarmTime?: string(name='FromAlarmTime'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
  toAlarmTime?: string(name='ToAlarmTime'),
}

model DescribeAlarmsResponseBody = {
  alarms?: {
    alarmInfo?: [ 
    {
      alarmId?: string(name='AlarmId'),
      alarmStatus?: string(name='AlarmStatus'),
      alarmTime?: string(name='AlarmTime'),
      alarmType?: string(name='AlarmType'),
      companyId?: string(name='CompanyId'),
      dealTime?: string(name='DealTime'),
      dealUserId?: long(name='DealUserId'),
      deviceBarCode?: string(name='DeviceBarCode'),
      deviceMac?: string(name='DeviceMac'),
      deviceType?: string(name='DeviceType'),
      errorType?: string(name='ErrorType'),
      itemBarCode?: string(name='ItemBarCode'),
      itemTitle?: string(name='ItemTitle'),
      model?: string(name='Model'),
      storeId?: string(name='StoreId'),
      vendor?: string(name='Vendor'),
    }
  ](name='AlarmInfo')
  }(name='Alarms'),
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeAlarmsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAlarmsResponseBody(name='body'),
}

/**
 * @param request DescribeAlarmsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAlarmsResponse
 */
async function describeAlarmsWithOptions(request: DescribeAlarmsRequest, runtime: Util.RuntimeOptions): DescribeAlarmsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alarmId)) {
    body['AlarmId'] = request.alarmId;
  }
  if (!Util.isUnset(request.alarmStatus)) {
    body['AlarmStatus'] = request.alarmStatus;
  }
  if (!Util.isUnset(request.alarmType)) {
    body['AlarmType'] = request.alarmType;
  }
  if (!Util.isUnset(request.errorType)) {
    body['ErrorType'] = request.errorType;
  }
  if (!Util.isUnset(request.fromAlarmTime)) {
    body['FromAlarmTime'] = request.fromAlarmTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  if (!Util.isUnset(request.toAlarmTime)) {
    body['ToAlarmTime'] = request.toAlarmTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAlarms',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeAlarmsRequest
 * @return DescribeAlarmsResponse
 */
async function describeAlarms(request: DescribeAlarmsRequest): DescribeAlarmsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlarmsWithOptions(request, runtime);
}

model DescribeApDevicesRequest {
  activated?: boolean(name='Activated'),
  apMac?: string(name='ApMac'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model DescribeApDevicesResponseBody = {
  apDevices?: {
    apInfo?: [ 
    {
      isActivate?: boolean(name='IsActivate'),
      mac?: string(name='Mac'),
      model?: string(name='Model'),
      status?: boolean(name='Status'),
    }
  ](name='ApInfo')
  }(name='ApDevices'),
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeApDevicesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeApDevicesResponseBody(name='body'),
}

/**
 * @param request DescribeApDevicesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeApDevicesResponse
 */
async function describeApDevicesWithOptions(request: DescribeApDevicesRequest, runtime: Util.RuntimeOptions): DescribeApDevicesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.activated)) {
    body['Activated'] = request.activated;
  }
  if (!Util.isUnset(request.apMac)) {
    body['ApMac'] = request.apMac;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApDevices',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeApDevicesRequest
 * @return DescribeApDevicesResponse
 */
async function describeApDevices(request: DescribeApDevicesRequest): DescribeApDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeApDevicesWithOptions(request, runtime);
}

model DescribeEslDevicesRequest {
  beBind?: boolean(name='BeBind'),
  eslBarCode?: string(name='EslBarCode'),
  eslStatus?: string(name='EslStatus'),
  fromBatteryLevel?: int32(name='FromBatteryLevel'),
  itemBarCode?: string(name='ItemBarCode'),
  mac?: string(name='Mac'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  shelfCode?: string(name='ShelfCode'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
  toBatteryLevel?: int32(name='ToBatteryLevel'),
  type?: string(name='Type'),
  vendor?: string(name='Vendor'),
}

model DescribeEslDevicesResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  eslDevices?: {
    eslDeviceInfo?: [ 
    {
      batteryLevel?: int32(name='BatteryLevel'),
      beBind?: boolean(name='BeBind'),
      companyId?: string(name='CompanyId'),
      connectAp?: string(name='ConnectAp'),
      eslBarCode?: string(name='EslBarCode'),
      eslStatus?: string(name='EslStatus'),
      itemActionPrice?: int32(name='ItemActionPrice'),
      itemBarCode?: string(name='ItemBarCode'),
      itemId?: long(name='ItemId'),
      itemPriceUnit?: string(name='ItemPriceUnit'),
      itemTitle?: string(name='ItemTitle'),
      lastCommunicateTime?: string(name='LastCommunicateTime'),
      mac?: string(name='Mac'),
      model?: string(name='Model'),
      positionCode?: string(name='PositionCode'),
      screenHeight?: int32(name='ScreenHeight'),
      screenWidth?: int32(name='ScreenWidth'),
      shelfCode?: string(name='ShelfCode'),
      storeId?: string(name='StoreId'),
      type?: string(name='Type'),
      vendor?: string(name='Vendor'),
    }
  ](name='EslDeviceInfo')
  }(name='EslDevices'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEslDevicesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEslDevicesResponseBody(name='body'),
}

/**
 * @param request DescribeEslDevicesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEslDevicesResponse
 */
async function describeEslDevicesWithOptions(request: DescribeEslDevicesRequest, runtime: Util.RuntimeOptions): DescribeEslDevicesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.beBind)) {
    body['BeBind'] = request.beBind;
  }
  if (!Util.isUnset(request.eslBarCode)) {
    body['EslBarCode'] = request.eslBarCode;
  }
  if (!Util.isUnset(request.eslStatus)) {
    body['EslStatus'] = request.eslStatus;
  }
  if (!Util.isUnset(request.fromBatteryLevel)) {
    body['FromBatteryLevel'] = request.fromBatteryLevel;
  }
  if (!Util.isUnset(request.itemBarCode)) {
    body['ItemBarCode'] = request.itemBarCode;
  }
  if (!Util.isUnset(request.mac)) {
    body['Mac'] = request.mac;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.shelfCode)) {
    body['ShelfCode'] = request.shelfCode;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  if (!Util.isUnset(request.toBatteryLevel)) {
    body['ToBatteryLevel'] = request.toBatteryLevel;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  if (!Util.isUnset(request.vendor)) {
    body['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEslDevices',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeEslDevicesRequest
 * @return DescribeEslDevicesResponse
 */
async function describeEslDevices(request: DescribeEslDevicesRequest): DescribeEslDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEslDevicesWithOptions(request, runtime);
}

model DescribeItemsRequest {
  bePromotion?: boolean(name='BePromotion'),
  itemBarCode?: string(name='ItemBarCode'),
  itemId?: long(name='ItemId'),
  itemTitle?: string(name='ItemTitle'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  skuId?: string(name='SkuId'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model DescribeItemsResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  items?: {
    itemInfo?: [ 
    {
      actionPrice?: int32(name='ActionPrice'),
      bePromotion?: boolean(name='BePromotion'),
      beSourceCode?: boolean(name='BeSourceCode'),
      brandName?: string(name='BrandName'),
      categoryName?: string(name='CategoryName'),
      companyId?: string(name='CompanyId'),
      customizeFeatureA?: string(name='CustomizeFeatureA'),
      customizeFeatureB?: string(name='CustomizeFeatureB'),
      customizeFeatureC?: string(name='CustomizeFeatureC'),
      customizeFeatureD?: string(name='CustomizeFeatureD'),
      customizeFeatureE?: string(name='CustomizeFeatureE'),
      customizeFeatureF?: string(name='CustomizeFeatureF'),
      customizeFeatureG?: string(name='CustomizeFeatureG'),
      customizeFeatureH?: string(name='CustomizeFeatureH'),
      customizeFeatureI?: string(name='CustomizeFeatureI'),
      customizeFeatureJ?: string(name='CustomizeFeatureJ'),
      energyEfficiency?: string(name='EnergyEfficiency'),
      extraAttribute?: string(name='ExtraAttribute'),
      forestFirstId?: string(name='ForestFirstId'),
      forestSecondId?: string(name='ForestSecondId'),
      itemBarCode?: string(name='ItemBarCode'),
      itemId?: long(name='ItemId'),
      itemInfoIndex?: int32(name='ItemInfoIndex'),
      itemQrCode?: string(name='ItemQrCode'),
      itemShortTitle?: string(name='ItemShortTitle'),
      itemTitle?: string(name='ItemTitle'),
      memberPrice?: int32(name='MemberPrice'),
      modelNumber?: string(name='ModelNumber'),
      optionGroups?: string(name='OptionGroups'),
      originalPrice?: int32(name='OriginalPrice'),
      priceUnit?: string(name='PriceUnit'),
      productionPlace?: string(name='ProductionPlace'),
      promotionEnd?: string(name='PromotionEnd'),
      promotionReason?: string(name='PromotionReason'),
      promotionStart?: string(name='PromotionStart'),
      promotionText?: string(name='PromotionText'),
      rank?: string(name='Rank'),
      saleSpec?: string(name='SaleSpec'),
      skuId?: string(name='SkuId'),
      sourceCode?: string(name='SourceCode'),
      storeId?: string(name='StoreId'),
      suggestPrice?: int32(name='SuggestPrice'),
    }
  ](name='ItemInfo')
  }(name='Items'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeItemsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeItemsResponseBody(name='body'),
}

/**
 * @param request DescribeItemsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeItemsResponse
 */
async function describeItemsWithOptions(request: DescribeItemsRequest, runtime: Util.RuntimeOptions): DescribeItemsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bePromotion)) {
    body['BePromotion'] = request.bePromotion;
  }
  if (!Util.isUnset(request.itemBarCode)) {
    body['ItemBarCode'] = request.itemBarCode;
  }
  if (!Util.isUnset(request.itemId)) {
    body['ItemId'] = request.itemId;
  }
  if (!Util.isUnset(request.itemTitle)) {
    body['ItemTitle'] = request.itemTitle;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.skuId)) {
    body['SkuId'] = request.skuId;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeItems',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeItemsRequest
 * @return DescribeItemsResponse
 */
async function describeItems(request: DescribeItemsRequest): DescribeItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeItemsWithOptions(request, runtime);
}

model DescribeLogisticsRequest {
  orderId?: string(name='OrderId', description='This parameter is required.'),
}

model DescribeLogisticsResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  logistics?: {
    logisticsInfo?: [ 
    {
      acceptStatus?: boolean(name='AcceptStatus'),
      apMacList?: string(name='ApMacList'),
      description?: string(name='Description'),
      eslMacList?: string(name='EslMacList'),
      hasSend?: string(name='HasSend'),
      logisticsDocuments?: string(name='LogisticsDocuments'),
      orderId?: string(name='OrderId'),
      poNumber?: string(name='PoNumber'),
      prNumber?: string(name='PrNumber'),
    }
  ](name='LogisticsInfo')
  }(name='Logistics'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeLogisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLogisticsResponseBody(name='body'),
}

/**
 * @param request DescribeLogisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLogisticsResponse
 */
async function describeLogisticsWithOptions(request: DescribeLogisticsRequest, runtime: Util.RuntimeOptions): DescribeLogisticsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orderId)) {
    body['OrderId'] = request.orderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLogistics',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeLogisticsRequest
 * @return DescribeLogisticsResponse
 */
async function describeLogistics(request: DescribeLogisticsRequest): DescribeLogisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogisticsWithOptions(request, runtime);
}

model DescribePayOrdersRequest {
  fromDate?: string(name='FromDate'),
  orderId?: string(name='OrderId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  toDate?: string(name='ToDate'),
}

model DescribePayOrdersResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  payOrders?: {
    payOrderInfo?: [ 
    {
      commodityCode?: string(name='CommodityCode'),
      commodityName?: string(name='CommodityName'),
      detailName?: string(name='DetailName'),
      gmtCreate?: string(name='GmtCreate'),
      gmtPay?: string(name='GmtPay'),
      isAccepted?: boolean(name='IsAccepted'),
      orderId?: string(name='OrderId'),
      orderStatus?: string(name='OrderStatus'),
      orderType?: string(name='OrderType'),
      originalAmount?: float(name='OriginalAmount'),
      payAmount?: float(name='PayAmount'),
      quantity?: int32(name='Quantity'),
    }
  ](name='PayOrderInfo')
  }(name='PayOrders'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model DescribePayOrdersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePayOrdersResponseBody(name='body'),
}

/**
 * @param request DescribePayOrdersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePayOrdersResponse
 */
async function describePayOrdersWithOptions(request: DescribePayOrdersRequest, runtime: Util.RuntimeOptions): DescribePayOrdersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fromDate)) {
    body['FromDate'] = request.fromDate;
  }
  if (!Util.isUnset(request.orderId)) {
    body['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.toDate)) {
    body['ToDate'] = request.toDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribePayOrders',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribePayOrdersRequest
 * @return DescribePayOrdersResponse
 */
async function describePayOrders(request: DescribePayOrdersRequest): DescribePayOrdersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePayOrdersWithOptions(request, runtime);
}

model DescribePlanogramRailsRequest {
  layer?: string(name='Layer'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  railCode?: string(name='RailCode'),
  shelf?: string(name='Shelf'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model DescribePlanogramRailsResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  planogramRailInfos?: [ 
    {
      gapUnit?: int32(name='GapUnit'),
      layer?: string(name='Layer'),
      railCode?: string(name='RailCode'),
      shelf?: string(name='Shelf'),
    }
  ](name='PlanogramRailInfos'),
  requestId?: string(name='RequestId'),
  storeId?: string(name='StoreId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model DescribePlanogramRailsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePlanogramRailsResponseBody(name='body'),
}

/**
 * @param request DescribePlanogramRailsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePlanogramRailsResponse
 */
async function describePlanogramRailsWithOptions(request: DescribePlanogramRailsRequest, runtime: Util.RuntimeOptions): DescribePlanogramRailsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.layer)) {
    body['Layer'] = request.layer;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.railCode)) {
    body['RailCode'] = request.railCode;
  }
  if (!Util.isUnset(request.shelf)) {
    body['Shelf'] = request.shelf;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribePlanogramRails',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribePlanogramRailsRequest
 * @return DescribePlanogramRailsResponse
 */
async function describePlanogramRails(request: DescribePlanogramRailsRequest): DescribePlanogramRailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlanogramRailsWithOptions(request, runtime);
}

model DescribeStoresRequest {
  brand?: string(name='Brand'),
  companyId?: string(name='CompanyId'),
  fromDate?: string(name='FromDate'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  storeId?: string(name='StoreId'),
  storeName?: string(name='StoreName'),
  toDate?: string(name='ToDate'),
}

model DescribeStoresResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  stores?: {
    storeInfo?: [ 
    {
      brand?: string(name='Brand'),
      comments?: string(name='Comments'),
      companyId?: string(name='CompanyId'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      groups?: string(name='Groups'),
      level?: string(name='Level'),
      outId?: string(name='OutId'),
      parentId?: string(name='ParentId'),
      phone?: string(name='Phone'),
      storeId?: string(name='StoreId'),
      storeName?: string(name='StoreName'),
    }
  ](name='StoreInfo')
  }(name='Stores'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeStoresResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeStoresResponseBody(name='body'),
}

/**
 * @param request DescribeStoresRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeStoresResponse
 */
async function describeStoresWithOptions(request: DescribeStoresRequest, runtime: Util.RuntimeOptions): DescribeStoresResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.brand)) {
    body['Brand'] = request.brand;
  }
  if (!Util.isUnset(request.companyId)) {
    body['CompanyId'] = request.companyId;
  }
  if (!Util.isUnset(request.fromDate)) {
    body['FromDate'] = request.fromDate;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  if (!Util.isUnset(request.storeName)) {
    body['StoreName'] = request.storeName;
  }
  if (!Util.isUnset(request.toDate)) {
    body['ToDate'] = request.toDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeStores',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeStoresRequest
 * @return DescribeStoresResponse
 */
async function describeStores(request: DescribeStoresRequest): DescribeStoresResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeStoresWithOptions(request, runtime);
}

model DescribeUserLogRequest {
  eslBarCode?: string(name='EslBarCode'),
  fromDate?: string(name='FromDate'),
  itemBarCode?: string(name='ItemBarCode'),
  itemId?: long(name='ItemId'),
  itemTitle?: string(name='ItemTitle'),
  operateStatus?: string(name='OperateStatus'),
  operateType?: string(name='OperateType'),
  operateUserId?: long(name='OperateUserId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  reverse?: boolean(name='Reverse'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
  toDate?: string(name='ToDate'),
}

model DescribeUserLogResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
  userLogs?: {
    userLogInfo?: [ 
    {
      eslBarCode?: string(name='EslBarCode'),
      itemActionPrice?: int32(name='ItemActionPrice'),
      itemBarCode?: string(name='ItemBarCode'),
      itemId?: long(name='ItemId'),
      itemTitle?: string(name='ItemTitle'),
      mac?: string(name='Mac'),
      operateStatus?: string(name='OperateStatus'),
      operateTime?: string(name='OperateTime'),
      operateType?: string(name='OperateType'),
      operateUserId?: long(name='OperateUserId'),
      shelfCode?: string(name='ShelfCode'),
      storeId?: string(name='StoreId'),
    }
  ](name='UserLogInfo')
  }(name='UserLogs'),
}

model DescribeUserLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUserLogResponseBody(name='body'),
}

/**
 * @param request DescribeUserLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserLogResponse
 */
async function describeUserLogWithOptions(request: DescribeUserLogRequest, runtime: Util.RuntimeOptions): DescribeUserLogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eslBarCode)) {
    body['EslBarCode'] = request.eslBarCode;
  }
  if (!Util.isUnset(request.fromDate)) {
    body['FromDate'] = request.fromDate;
  }
  if (!Util.isUnset(request.itemBarCode)) {
    body['ItemBarCode'] = request.itemBarCode;
  }
  if (!Util.isUnset(request.itemId)) {
    body['ItemId'] = request.itemId;
  }
  if (!Util.isUnset(request.itemTitle)) {
    body['ItemTitle'] = request.itemTitle;
  }
  if (!Util.isUnset(request.operateStatus)) {
    body['OperateStatus'] = request.operateStatus;
  }
  if (!Util.isUnset(request.operateType)) {
    body['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.operateUserId)) {
    body['OperateUserId'] = request.operateUserId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.reverse)) {
    body['Reverse'] = request.reverse;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  if (!Util.isUnset(request.toDate)) {
    body['ToDate'] = request.toDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserLog',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeUserLogRequest
 * @return DescribeUserLogResponse
 */
async function describeUserLog(request: DescribeUserLogRequest): DescribeUserLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserLogWithOptions(request, runtime);
}

model DescribeUsersRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  userId?: string(name='UserId'),
  userName?: string(name='UserName'),
  userType?: string(name='UserType'),
}

model DescribeUsersResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
  users?: {
    userInfo?: [ 
    {
      stores?: string(name='Stores'),
      userId?: string(name='UserId'),
      userName?: string(name='UserName'),
      userType?: string(name='UserType'),
    }
  ](name='UserInfo')
  }(name='Users'),
}

model DescribeUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUsersResponseBody(name='body'),
}

/**
 * @param request DescribeUsersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUsersResponse
 */
async function describeUsersWithOptions(request: DescribeUsersRequest, runtime: Util.RuntimeOptions): DescribeUsersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.userType)) {
    body['UserType'] = request.userType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUsers',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeUsersRequest
 * @return DescribeUsersResponse
 */
async function describeUsers(request: DescribeUsersRequest): DescribeUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUsersWithOptions(request, runtime);
}

model GetCompanyResponseBody = {
  bid?: long(name='Bid'),
  code?: string(name='Code'),
  companyId?: string(name='CompanyId'),
  companyType?: string(name='CompanyType'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  ownerId?: long(name='OwnerId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  success?: boolean(name='Success'),
}

model GetCompanyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCompanyResponseBody(name='body'),
}

/**
 * @param request GetCompanyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCompanyResponse
 */
async function getCompanyWithOptions(runtime: Util.RuntimeOptions): GetCompanyResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetCompany',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return GetCompanyResponse
 */
async function getCompany(): GetCompanyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCompanyWithOptions(runtime);
}

model GetUserRequest {
  userId?: string(name='UserId'),
}

model GetUserResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  user?: {
    stores?: string(name='Stores'),
    userId?: string(name='UserId'),
    userName?: string(name='UserName'),
    userType?: string(name='UserType'),
  }(name='User'),
}

model GetUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserResponseBody(name='body'),
}

/**
 * @param request GetUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetUserResponse
 */
async function getUserWithOptions(request: GetUserRequest, runtime: Util.RuntimeOptions): GetUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetUser',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetUserRequest
 * @return GetUserResponse
 */
async function getUser(request: GetUserRequest): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserWithOptions(request, runtime);
}

model MapPlanogramRailRequest {
  layer?: string(name='Layer', description='This parameter is required.'),
  railCode?: string(name='RailCode', description='This parameter is required.'),
  shelf?: string(name='Shelf', description='This parameter is required.'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model MapPlanogramRailResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model MapPlanogramRailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MapPlanogramRailResponseBody(name='body'),
}

/**
 * @param request MapPlanogramRailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MapPlanogramRailResponse
 */
async function mapPlanogramRailWithOptions(request: MapPlanogramRailRequest, runtime: Util.RuntimeOptions): MapPlanogramRailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.layer)) {
    body['Layer'] = request.layer;
  }
  if (!Util.isUnset(request.railCode)) {
    body['RailCode'] = request.railCode;
  }
  if (!Util.isUnset(request.shelf)) {
    body['Shelf'] = request.shelf;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'MapPlanogramRail',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request MapPlanogramRailRequest
 * @return MapPlanogramRailResponse
 */
async function mapPlanogramRail(request: MapPlanogramRailRequest): MapPlanogramRailResponse {
  var runtime = new Util.RuntimeOptions{};
  return mapPlanogramRailWithOptions(request, runtime);
}

model RefreshTaobaoItemRequest {
  outerId?: string(name='OuterId'),
  skuId?: string(name='SkuId'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
  taobaoItemId?: string(name='TaobaoItemId'),
}

model RefreshTaobaoItemResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RefreshTaobaoItemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RefreshTaobaoItemResponseBody(name='body'),
}

/**
 * @param request RefreshTaobaoItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshTaobaoItemResponse
 */
async function refreshTaobaoItemWithOptions(request: RefreshTaobaoItemRequest, runtime: Util.RuntimeOptions): RefreshTaobaoItemResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.outerId)) {
    body['OuterId'] = request.outerId;
  }
  if (!Util.isUnset(request.skuId)) {
    body['SkuId'] = request.skuId;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  if (!Util.isUnset(request.taobaoItemId)) {
    body['TaobaoItemId'] = request.taobaoItemId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RefreshTaobaoItem',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RefreshTaobaoItemRequest
 * @return RefreshTaobaoItemResponse
 */
async function refreshTaobaoItem(request: RefreshTaobaoItemRequest): RefreshTaobaoItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshTaobaoItemWithOptions(request, runtime);
}

model UnassignUserRequest {
  userId?: string(name='UserId', description='This parameter is required.'),
}

model UnassignUserResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UnassignUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnassignUserResponseBody(name='body'),
}

/**
 * @param request UnassignUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnassignUserResponse
 */
async function unassignUserWithOptions(request: UnassignUserRequest, runtime: Util.RuntimeOptions): UnassignUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UnassignUser',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UnassignUserRequest
 * @return UnassignUserResponse
 */
async function unassignUser(request: UnassignUserRequest): UnassignUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassignUserWithOptions(request, runtime);
}

model UnbindEslDeviceRequest {
  eslBarCode?: string(name='EslBarCode', description='This parameter is required.'),
  itemBarCode?: string(name='ItemBarCode'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model UnbindEslDeviceResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UnbindEslDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindEslDeviceResponseBody(name='body'),
}

/**
 * @param request UnbindEslDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnbindEslDeviceResponse
 */
async function unbindEslDeviceWithOptions(request: UnbindEslDeviceRequest, runtime: Util.RuntimeOptions): UnbindEslDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eslBarCode)) {
    body['EslBarCode'] = request.eslBarCode;
  }
  if (!Util.isUnset(request.itemBarCode)) {
    body['ItemBarCode'] = request.itemBarCode;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UnbindEslDevice',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UnbindEslDeviceRequest
 * @return UnbindEslDeviceResponse
 */
async function unbindEslDevice(request: UnbindEslDeviceRequest): UnbindEslDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindEslDeviceWithOptions(request, runtime);
}

model UnbindEslDeviceShelfRequest {
  eslBarCode?: string(name='EslBarCode'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model UnbindEslDeviceShelfResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UnbindEslDeviceShelfResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindEslDeviceShelfResponseBody(name='body'),
}

/**
 * @param request UnbindEslDeviceShelfRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnbindEslDeviceShelfResponse
 */
async function unbindEslDeviceShelfWithOptions(request: UnbindEslDeviceShelfRequest, runtime: Util.RuntimeOptions): UnbindEslDeviceShelfResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eslBarCode)) {
    body['EslBarCode'] = request.eslBarCode;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UnbindEslDeviceShelf',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UnbindEslDeviceShelfRequest
 * @return UnbindEslDeviceShelfResponse
 */
async function unbindEslDeviceShelf(request: UnbindEslDeviceShelfRequest): UnbindEslDeviceShelfResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindEslDeviceShelfWithOptions(request, runtime);
}

model UnmapPlanogramRailRequest {
  railCode?: string(name='RailCode', description='This parameter is required.'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model UnmapPlanogramRailResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UnmapPlanogramRailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnmapPlanogramRailResponseBody(name='body'),
}

/**
 * @param request UnmapPlanogramRailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnmapPlanogramRailResponse
 */
async function unmapPlanogramRailWithOptions(request: UnmapPlanogramRailRequest, runtime: Util.RuntimeOptions): UnmapPlanogramRailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.railCode)) {
    body['RailCode'] = request.railCode;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UnmapPlanogramRail',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UnmapPlanogramRailRequest
 * @return UnmapPlanogramRailResponse
 */
async function unmapPlanogramRail(request: UnmapPlanogramRailRequest): UnmapPlanogramRailResponse {
  var runtime = new Util.RuntimeOptions{};
  return unmapPlanogramRailWithOptions(request, runtime);
}

model UpdateEslDeviceLightRequest {
  eslBarCode?: string(name='EslBarCode'),
  frequency?: string(name='Frequency', description='This parameter is required.'),
  itemBarCode?: string(name='ItemBarCode'),
  ledColor?: string(name='LedColor', description='This parameter is required.'),
  lightUpTime?: int32(name='LightUpTime', description='This parameter is required.'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
}

model UpdateEslDeviceLightResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  failCount?: long(name='FailCount'),
  failEslBarCodes?: string(name='FailEslBarCodes'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  successCount?: long(name='SuccessCount'),
}

model UpdateEslDeviceLightResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateEslDeviceLightResponseBody(name='body'),
}

/**
 * @param request UpdateEslDeviceLightRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEslDeviceLightResponse
 */
async function updateEslDeviceLightWithOptions(request: UpdateEslDeviceLightRequest, runtime: Util.RuntimeOptions): UpdateEslDeviceLightResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eslBarCode)) {
    body['EslBarCode'] = request.eslBarCode;
  }
  if (!Util.isUnset(request.frequency)) {
    body['Frequency'] = request.frequency;
  }
  if (!Util.isUnset(request.itemBarCode)) {
    body['ItemBarCode'] = request.itemBarCode;
  }
  if (!Util.isUnset(request.ledColor)) {
    body['LedColor'] = request.ledColor;
  }
  if (!Util.isUnset(request.lightUpTime)) {
    body['LightUpTime'] = request.lightUpTime;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEslDeviceLight',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateEslDeviceLightRequest
 * @return UpdateEslDeviceLightResponse
 */
async function updateEslDeviceLight(request: UpdateEslDeviceLightRequest): UpdateEslDeviceLightResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEslDeviceLightWithOptions(request, runtime);
}

model UpdateStoreRequest {
  brand?: string(name='Brand'),
  comments?: string(name='Comments'),
  groups?: string(name='Groups'),
  outId?: string(name='OutId'),
  phone?: string(name='Phone'),
  storeId?: string(name='StoreId', description='This parameter is required.'),
  storeName?: string(name='StoreName'),
}

model UpdateStoreResponseBody = {
  code?: string(name='Code'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateStoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateStoreResponseBody(name='body'),
}

/**
 * @param request UpdateStoreRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateStoreResponse
 */
async function updateStoreWithOptions(request: UpdateStoreRequest, runtime: Util.RuntimeOptions): UpdateStoreResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.brand)) {
    body['Brand'] = request.brand;
  }
  if (!Util.isUnset(request.comments)) {
    body['Comments'] = request.comments;
  }
  if (!Util.isUnset(request.groups)) {
    body['Groups'] = request.groups;
  }
  if (!Util.isUnset(request.outId)) {
    body['OutId'] = request.outId;
  }
  if (!Util.isUnset(request.phone)) {
    body['Phone'] = request.phone;
  }
  if (!Util.isUnset(request.storeId)) {
    body['StoreId'] = request.storeId;
  }
  if (!Util.isUnset(request.storeName)) {
    body['StoreName'] = request.storeName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateStore',
    version = '2019-08-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateStoreRequest
 * @return UpdateStoreResponse
 */
async function updateStore(request: UpdateStoreRequest): UpdateStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateStoreWithOptions(request, runtime);
}

