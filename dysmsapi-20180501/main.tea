/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  @endpointMap = {
    ap-southeast-1 = 'dysmsapi.ap-southeast-1.aliyuncs.com',
    ap-southeast-5 = 'dysmsapi-xman.ap-southeast-5.aliyuncs.com',
    cn-beijing = 'dysmsapi-proxy.cn-beijing.aliyuncs.com',
    cn-hongkong = 'dysmsapi-xman.cn-hongkong.aliyuncs.com',
  };
  checkConfig(config);
  @endpoint = getEndpoint('dysmsapi', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model QueryMessageRequest {
  messageId?: string(name='MessageId'),
}

model QueryMessageResponseBody = {
  status?: string(name='Status'),
  errorDescription?: string(name='ErrorDescription'),
  responseCode?: string(name='ResponseCode'),
  receiveDate?: string(name='ReceiveDate'),
  numberDetail?: {
    carrier?: string(name='Carrier'),
    region?: string(name='Region'),
    country?: string(name='Country'),
  }(name='NumberDetail'),
  message?: string(name='Message'),
  responseDescription?: string(name='ResponseDescription'),
  errorCode?: string(name='ErrorCode'),
  sendDate?: string(name='SendDate'),
  to?: string(name='To'),
  messageId?: string(name='MessageId'),
}

model QueryMessageResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMessageResponseBody(name='body'),
}

async function queryMessageWithOptions(request: QueryMessageRequest, runtime: Util.RuntimeOptions): QueryMessageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMessage', '2018-05-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMessage(request: QueryMessageRequest): QueryMessageResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMessageWithOptions(request, runtime);
}

model BatchSendMessageToGlobeRequest {
  to?: string(name='To'),
  from?: string(name='From'),
  message?: string(name='Message'),
  type?: string(name='Type'),
  taskId?: string(name='TaskId'),
}

model BatchSendMessageToGlobeResponseBody = {
  responseCode?: string(name='ResponseCode'),
  requestId?: string(name='RequestId'),
  failedList?: string(name='FailedList'),
  responseDescription?: string(name='ResponseDescription'),
  from?: string(name='From'),
  messageIdList?: string(name='MessageIdList'),
  successCount?: string(name='SuccessCount'),
}

model BatchSendMessageToGlobeResponse = {
  headers: map[string]string(name='headers'),
  body: BatchSendMessageToGlobeResponseBody(name='body'),
}

async function batchSendMessageToGlobeWithOptions(request: BatchSendMessageToGlobeRequest, runtime: Util.RuntimeOptions): BatchSendMessageToGlobeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('BatchSendMessageToGlobe', '2018-05-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function batchSendMessageToGlobe(request: BatchSendMessageToGlobeRequest): BatchSendMessageToGlobeResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchSendMessageToGlobeWithOptions(request, runtime);
}

model SmsConversionRequest {
  messageId?: string(name='MessageId'),
  delivered?: boolean(name='Delivered'),
  conversionTime?: long(name='ConversionTime'),
}

model SmsConversionResponseBody = {
  responseCode?: string(name='ResponseCode'),
  responseDescription?: string(name='ResponseDescription'),
  requestId?: string(name='RequestId'),
}

model SmsConversionResponse = {
  headers: map[string]string(name='headers'),
  body: SmsConversionResponseBody(name='body'),
}

async function smsConversionWithOptions(request: SmsConversionRequest, runtime: Util.RuntimeOptions): SmsConversionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SmsConversion', '2018-05-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function smsConversion(request: SmsConversionRequest): SmsConversionResponse {
  var runtime = new Util.RuntimeOptions{};
  return smsConversionWithOptions(request, runtime);
}

model SendMessageToGlobeRequest {
  to?: string(name='To'),
  from?: string(name='From'),
  message?: string(name='Message'),
  taskId?: string(name='TaskId'),
}

model SendMessageToGlobeResponseBody = {
  responseCode?: string(name='ResponseCode'),
  numberDetail?: {
    carrier?: string(name='Carrier'),
    region?: string(name='Region'),
    country?: string(name='Country'),
  }(name='NumberDetail'),
  requestId?: string(name='RequestId'),
  segments?: string(name='Segments'),
  responseDescription?: string(name='ResponseDescription'),
  from?: string(name='From'),
  to?: string(name='To'),
  messageId?: string(name='MessageId'),
}

model SendMessageToGlobeResponse = {
  headers: map[string]string(name='headers'),
  body: SendMessageToGlobeResponseBody(name='body'),
}

async function sendMessageToGlobeWithOptions(request: SendMessageToGlobeRequest, runtime: Util.RuntimeOptions): SendMessageToGlobeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SendMessageToGlobe', '2018-05-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function sendMessageToGlobe(request: SendMessageToGlobeRequest): SendMessageToGlobeResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendMessageToGlobeWithOptions(request, runtime);
}

model ConversionDataRequest {
  reportTime?: long(name='ReportTime'),
  conversionRate?: string(name='ConversionRate'),
}

model ConversionDataResponseBody = {
  responseCode?: string(name='ResponseCode'),
  responseDescription?: string(name='ResponseDescription'),
  requestId?: string(name='RequestId'),
}

model ConversionDataResponse = {
  headers: map[string]string(name='headers'),
  body: ConversionDataResponseBody(name='body'),
}

async function conversionDataWithOptions(request: ConversionDataRequest, runtime: Util.RuntimeOptions): ConversionDataResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConversionData', '2018-05-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function conversionData(request: ConversionDataRequest): ConversionDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return conversionDataWithOptions(request, runtime);
}

model SendMessageWithTemplateRequest {
  to?: string(name='To'),
  from?: string(name='From'),
  templateCode?: string(name='TemplateCode'),
  templateParam?: string(name='TemplateParam'),
  smsUpExtendCode?: string(name='SmsUpExtendCode'),
}

model SendMessageWithTemplateResponseBody = {
  responseCode?: string(name='ResponseCode'),
  numberDetail?: {
    carrier?: string(name='Carrier'),
    region?: string(name='Region'),
    country?: string(name='Country'),
  }(name='NumberDetail'),
  responseDescription?: string(name='ResponseDescription'),
  segments?: string(name='Segments'),
  to?: string(name='To'),
  messageId?: string(name='MessageId'),
}

model SendMessageWithTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: SendMessageWithTemplateResponseBody(name='body'),
}

async function sendMessageWithTemplateWithOptions(request: SendMessageWithTemplateRequest, runtime: Util.RuntimeOptions): SendMessageWithTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SendMessageWithTemplate', '2018-05-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function sendMessageWithTemplate(request: SendMessageWithTemplateRequest): SendMessageWithTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendMessageWithTemplateWithOptions(request, runtime);
}

