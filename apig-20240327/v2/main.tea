/**
 *
 */
import OpenApi;
import OpenApi.OpenApiUtil;

extends OpenApi;


init(config: OpenApiUtil.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('apig', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!$isNull(endpoint)) {
    return endpoint;
  }
  
  if (!$isNull(endpointMap) && !$isNull(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AgentServiceConfig {
  address?: string(name='address', description='The address.

This parameter is required.', example='https://dashscope.aliyuncs.com/api/v1'),
  customConfig?: {
    apiKey?: string(name='apiKey', description='apiKey', example='sk-xxx'),
    apiKeyGenerateMode?: string(name='apiKeyGenerateMode', description='API key generation mode.', example='Reference'),
  }(name='customConfig', description='User-defined configuration'),
  dashScopeConfig?: {
    appCredentials?: [ 
      {
        apiKey?: string(name='apiKey', description='apiKey', example='sk-xxx'),
        appId?: string(name='appId', description='The application ID.', example='app-xxx'),
      }
    ](name='appCredentials', description='The application configuration.'),
  }(name='dashScopeConfig', description='The Model Studio service configuration.'),
  difyConfig?: {
    apiKey?: string(name='apiKey', description='API Key', example='sk-xxx'),
    botType?: string(name='botType', description='The interaction type.', example='chatbot'),
  }(name='difyConfig', description='The Dify service configuration.'),
  enableHealthCheck?: boolean(name='enableHealthCheck', description='Specifies whether to enable health check.', example='true'),
  enableOutlierDetection?: boolean(name='enableOutlierDetection', description='Whether to enable outlier detection', example='true'),
  protocols?: [ string ](name='protocols', description='The protocol.'),
  provider?: string(name='provider', description='The service provider.

This parameter is required.', example='aliyun'),
}

model AiServiceConfig {
  apiKeyGenerateMode?: string(name='ApiKeyGenerateMode', description='API key generation mode.', example='-'),
  address?: string(name='address', description='The service endpoint.', example='https://dashscope.aliyun.com'),
  apiKeys?: [ string ](name='apiKeys', description='The API keys.'),
  bedrockServiceConfig?: {
    awsAccessKey?: string(name='awsAccessKey', description='AWS-AccessKey', example='AKIAIOSFODNN7EXAMPLE'),
    awsRegion?: string(name='awsRegion', description='AWS-Region', example='us-west-2'),
    awsSecretKey?: string(name='awsSecretKey', description='AWS-SecretKey', example='wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY'),
  }(name='bedrockServiceConfig', description='Bedrock service configuration.'),
  compatibleProtocols?: [ string ](name='compatibleProtocols', description='Supported compatible protocols.'),
  defaultModelName?: string(name='defaultModelName', description='Default model name.', example='qwen-turbo'),
  enableHealthCheck?: boolean(name='enableHealthCheck', description='Specifies whether to enable health check.', example='true'),
  enableOutlierDetection?: boolean(name='enableOutlierDetection', description='Enable outlier detection.', example='false'),
  paiEASServiceConfig?: {
    endpointType?: string(name='endpointType', description='Type of endpoint.', example='"public"，"private"'),
    serviceId?: string(name='serviceId', description='Service identifier.', example='svc-d33onfmm1hkn5duhuqjg'),
    serviceName?: string(name='serviceName', description='Name of the service.', example='service-hello'),
    workspaceId?: string(name='workspaceId', description='Workspace identifier.', example='plw-d5g7qsem1hkmih54g210'),
  }(name='paiEASServiceConfig', description='PAI-EAS service configuration settings.'),
  protocols?: [ string ](name='protocols', description='The LLM protocols.'),
  provider?: string(name='provider', description='The Large Language Model (LLM) provider.', example='qwen'),
  vertexServiceConfig?: {
    geminiSafetySetting?: map[string]string(name='geminiSafetySetting', description='Gemini safety settings.'),
    vertexAuthKey?: string(name='vertexAuthKey', description='Vertex AI authentication key.', example='{\\\\"type\\\\":\\\\"service_account\\\\",\\\\"project_id\\\\":\\\\"xxx\\\\",\\\\"private_key\\\\":\\\\"-----BEGIN PRIVATE KEY-----\\\\",\\\\"client_email\\\\":\\\\"xxx@xxx.iam.gserviceaccount.com\\\\",\\\\"token_uri\\\\":\\\\"https://oauth2.googleapis.com/token\\\\"}'),
    vertexAuthServiceName?: string(name='vertexAuthServiceName', description='Vertex AI auth service name.', example='custom-vertex-auth'),
    vertexProjectId?: string(name='vertexProjectId', description='Vertex AI project ID.', example='my-gcp-project-123'),
    vertexRegion?: string(name='vertexRegion', description='Vertex AI region.', example='us-central1'),
    vertexTokenRefreshAhead?: int32(name='vertexTokenRefreshAhead', description='Vertex token refresh lead time.', example='300'),
  }(name='vertexServiceConfig', description='Vertex AI service configuration.'),
}

model AkSkIdentityConfig {
  ak?: string(name='ak', description='Access Key', example='xxxx'),
  generateMode?: string(name='generateMode', description='Generation mode', example='System'),
  sk?: string(name='sk', description='Secret Key', example='xxxx'),
  type?: string(name='type', description='Identity authentication type', example='Jwt'),
}

model ApiKeyIdentityConfig {
  apikeySource?: {
    source?: string(name='source', description='The source of the API key.

Valid values:

*   Header
*   QueryString
*   Default', example='Default'),
    value?: string(name='value', description='The value of the API key.', example='xxxx'),
  }(name='apikeySource', description='The source configuration of the API key.'),
  credentials?: [ 
    {
      apikey?: string(name='apikey', description='The API key configuration.', example='xxxxx'),
      generateMode?: string(name='generateMode', description='The production mode.', example='System'),
    }
  ](name='credentials', description='The list of certificates.'),
  type?: string(name='type', description='The type.', example='Apikey'),
}

model ApiRouteConflictInfo {
  conflicts?: [ 
    {
      details?: [ 
        {
          conflictingMatch?: {
            match?: HttpRouteMatch(name='match', description='The matching rule.'),
            operationInfo?: {
              name?: string(name='name', description='The operation name.', example='GetItem'),
              operationId?: string(name='operationId', description='The operation ID.', example='op-cq35jadlhtgrv07***'),
            }(name='operationInfo', description='The corresponding operation information if the conflicting target is an API.'),
          }(name='conflictingMatch', description='The matching rule information of the conflicting target.'),
          detectedMatch?: {
            match?: HttpRouteMatch(name='match', description='The matching rule information of the object being detected.'),
            operationInfo?: {
              name?: string(name='name', description='The operation name.', example='GetItemV2'),
              operationId?: string(name='operationId', description='The operation ID.', example='op-cqf17dllhtgng1m**'),
            }(name='operationInfo', description='If the object is an API, the conflicting operation information needs to be returned.'),
          }(name='detectedMatch', description='The matching rule information of the object being detected.'),
          level?: string(name='level', description='The conflict level. Valid values: Critical, Warning, and Informational.', example='Critical'),
        }
      ](name='details', description='The details about the conflicts.'),
      environmentInfo?: {
        environmentId?: string(name='environmentId', description='The environment ID.', example='env-cquqsollhtgidd***'),
        name?: string(name='name', description='The environment name.', example='itemcenter-dev'),
      }(name='environmentInfo', description='For APIs, conflicts exist in the specific environment. If the conflict object is a route, ignore.'),
      resourceId?: string(name='resourceId', description='The conflicting resource ID.', example='api-crdclqllhtggm***'),
      resourceName?: string(name='resourceName', description='The conflicting resource name.', example='item-stock'),
      resourceType?: string(name='resourceType', description='The type of the conflicting resource.

Valid values:

*   RestApi
*   HttpApiRoute', example='HttpApiRoute'),
      routeInfo?: {
        name?: string(name='name', description='The route name.', example='itemcenter-route'),
        routeId?: string(name='routeId', description='The route ID.', example='hr-cr82undlhtgrlej***'),
      }(name='routeInfo', description='The route information.'),
    }
  ](name='conflicts', description='The conflicts.'),
  domainInfo?: {
    domainId?: string(name='domainId', description='The domain name ID.', example='d-cqookcllhtgvof7e***'),
    name?: string(name='name', description='The domain name.', example='httpbin'),
  }(name='domainInfo', description='The conflicting routes.'),
}

model Attachment {
  attachResourceIds?: [ string ](name='attachResourceIds', description='The resource IDs.'),
  attachResourceType?: string(name='attachResourceType', description='The supported mount point type. Valid values:

*   HttpApi: an HTTP API
*   Operation: an operation in an HTTP API
*   GatewayRoute: a gateway route
*   GatewayService: a gateway service
*   GatewayServicePort: a gateway service port
*   Domain: a gateway domain name
*   Gateway: a gateway instance', example='HttpApi'),
  environmentId?: string(name='environmentId', description='The environment to which the mounted resource belongs. If an asterisk (\\\\*) is returned as the environment ID, the mounted resource is not related to the environment.', example='env-cq7l5s5lhtgi6qasrdc0'),
  gatewayId?: string(name='gatewayId', description='The instance to which the mounted resource belongs.', example='gw-cpr4f9dlhtgq5ksfgmb0'),
  policyAttachmentId?: string(name='policyAttachmentId', description='The mount ID.', example='pr-cq7l5s5lhtgi6qasrdc0'),
}

model AuthConfig {
  authMode?: string(name='authMode', description='The authentication mode.', example='NoAuth'),
  authType?: string(name='authType', description='The authentication type.', example='Jwt'),
}

model AuthorizationResourceInfo {
  environmentId?: string(name='environmentId', example='env-cq7l5s5lhtgi6qasrdc0'),
  parentResourceId?: string(name='parentResourceId', example='api-cujbijem1hkr4voden8g'),
  resourceId?: string(name='resourceId', example='hr-d0mnu16m1hkgujnkgrcg'),
}

model Backend {
  scene?: string(name='scene', description='The backend service scenario. Valid values: Single, MultiServiceByRatio, MultiServiceByTag, Mock, and Redirect.', example='Single'),
  services?: [ 
    {
      name?: string(name='name', description='The service name.', example='item-service'),
      port?: int32(name='port', description='The service port. If you want to use a dynamic port, do not pass this parameter.', example='port'),
      protocol?: string(name='protocol', description='The service protocol. Valid values: HTTP, TCP, and DUBBO.', example='HTTP'),
      serviceId?: string(name='serviceId', description='The service ID.', example='service-cq2bmmdlhtgj***'),
      version?: string(name='version', description='The service version.', example='v1'),
      weight?: int32(name='weight', description='The percentage value of traffic.', example='49'),
    }
  ](name='services', description='The backend services.'),
}

model CheckServiceLinkedRoleResult {
  existed?: boolean(name='existed'),
}

model ConsumerConfig {
  consumerId?: string(name='consumerId'),
  name?: string(name='name'),
}

model ConsumerInfo {
  consumerId?: string(name='consumerId', description='consumerId', example='cs-ctd4l1um1hkph7ki1k80'),
  enable?: boolean(name='enable', description='enable', example='false'),
  name?: string(name='name', description='name', example='test'),
}

model DashboardFilter {
  routeName?: string(name='routeName', example='test'),
}

model DomainInfo {
  certIdentifier?: string(name='certIdentifier', description='The certificate identifier.', example='235556-cn-hangzhou'),
  clientCACert?: string(name='clientCACert', description='The client CA certificate.', example='-----BEGIN CERTIFICATE-----
MIIFBTCCAu2gAwIBAgIUORLpYPGSFD1YOP6PMbE7Wd/mpTQwDQYJKoZIhvcNAQEL
BQAwE************************************************2VwVOJ2gqX3
YuGaxvIbDy0iQJ1GMerPRyzJTeVEtdIKT29u0PdFRr4KZWom35qX7G4=
-----END CERTIFICATE-----'),
  createFrom?: string(name='createFrom', description='The creation source of the domain name.

Valid values:

*   Console
*   Ingress', example='Console'),
  createTimestamp?: long(name='createTimestamp', description='The creation timestamp.', example='1719386834548'),
  domainId?: string(name='domainId', description='The domain name ID.', example='d-cq1lthllhtgja4dk54eg'),
  forceHttps?: boolean(name='forceHttps', description='Specifies whether to enable forcible HTTPS redirection when HTTPS is used as the protocol.', example='false'),
  mTLSEnabled?: boolean(name='mTLSEnabled', description='Specifies whether to enable mutual authentication.', example='true'),
  name?: string(name='name', description='The domain name.', example='abc.com'),
  protocol?: string(name='protocol', description='The supported protocol. Valid values:

*   HTTP
*   HTTPS', example='HTTP'),
  resourceGroupId?: string(name='resourceGroupId', description='The resource group ID.', example='rg-xxxx'),
  status?: string(name='status', description='The domain name status.

Valid values:

*   UnPublished
*   Published', example='Published'),
  updateTimestamp?: long(name='updateTimestamp', description='The update timestamp.', example='1719386834548'),
}

model EnvironmentInfo {
  alias?: string(name='alias', description='The environment alias.', example='test-env'),
  createTimestamp?: long(name='createTimestamp', description='The creation timestamp.', example='1721116090326'),
  default?: boolean(name='default', description='Specifies whether the environment is the default environment.', example='false'),
  description?: string(name='description', description='The environment descriptiont.', example='This is a test environment.'),
  environmentId?: string(name='environmentId', description='The environment ID.', example='env-cq7l5s5lhtgi6qasrdc0'),
  gatewayInfo?: GatewayInfo(name='gatewayInfo', description='The instance information.'),
  name?: string(name='name', description='The environment name.', example='test'),
  resourceGroupId?: string(name='resourceGroupId', description='The resource group ID.', example='rg-xxxx'),
  subDomainInfos?: [
    SubDomainInfo
  ](name='subDomainInfos', description='The subdomains.'),
  updateTimestamp?: long(name='updateTimestamp', description='The update timestamp.', example='1721116090326'),
}

model GatewayInfo {
  engineVersion?: string(name='engineVersion', description='The instance engine version.', example='2.0.7'),
  gatewayId?: string(name='gatewayId', description='The instance ID.', example='gw-cq7og15lhtgi6qasrj60'),
  name?: string(name='name', description='The instance name.', example='apitest-gw'),
  vpcInfo?: {
    name?: string(name='name', description='The VPC name.', example='test-vpc'),
    vpcId?: string(name='vpcId', description='The VPC ID.', example='vpc-uf664nyle5kh***'),
  }(name='vpcInfo', description='The virtual private cloud (VPC) information.'),
}

model GatewayLogConfig {
  slsConfig?: {
    enable?: boolean(name='enable', description='Specifies whether to activate Simple Log Service.', example='true'),
  }(name='slsConfig', description='The Simple Log Service configurations.'),
}

model HttpApiApiInfo {
  agentProtocols?: [ string ](name='agentProtocols', description='Agent protocol list'),
  aiProtocols?: [ string ](name='aiProtocols', description='The AI protocols.'),
  authConfig?: AuthConfig(name='authConfig', description='The authentication configurations.'),
  basePath?: string(name='basePath', description='The base path of the API.', example='/v1'),
  deployCntMap?: map[string]HttpApiApiInfoDeployCntMapValue(name='deployCntMap', description='The API publishing status.'),
  deployConfigs?: [
    HttpApiDeployConfig
  ](name='deployConfigs', description='The API deployment configurations.'),
  description?: string(name='description', description='The API description.', example='for test only'),
  enabelAuth?: boolean(name='enabelAuth', description='Specifies whether to enable authentication.'),
  environments?: [ 
    {
      alias?: string(name='alias', description='The environment alias.', example='test'),
      backendScene?: string(name='backendScene', description='The publishing scenario.

Valid values:

*   SingleService
*   MultiServiceByRatio
*   MultiServiceByContent
*   MultiServiceByTag
*   Mock', example='SingleService'),
      backendType?: string(name='backendType', description='The type of the backend service.

Valid values:

*   DNS: a DNS domain name
*   Service: an existing service
*   VIP: a fixed IP address
*   CloudProduct: a cloud service', example='Service'),
      customDomains?: [
        HttpApiDomainInfo
      ](name='customDomains', description='The custom domain names.'),
      deployStatus?: string(name='deployStatus', description='The publishing status of the API in the current environment.', example='Deployed'),
      environmentId?: string(name='environmentId', description='The environment ID.', example='env-xxx'),
      gatewayInfo?: {
        gatewayId?: string(name='gatewayId', description='The instance ID.', example='gw-xxx'),
        name?: string(name='name', description='The instance name.', example='test'),
      }(name='gatewayInfo', description='The information about the gateway instance to which the environment belongs.'),
      name?: string(name='name', description='The environment name.', example='test'),
      serviceConfigs?: [ 
        {
          gatewayServiceId?: string(name='gatewayServiceId', description='The service ID.', example='gs-xxx'),
          match?: HttpApiBackendMatchConditions(name='match', description='The matching conditions.'),
          name?: string(name='name', description='The service name.', example='demo-service'),
          port?: string(name='port', description='The service port.', example='8080'),
          protocol?: string(name='protocol', description='The protocol.', example='HTTP'),
          serviceId?: string(name='serviceId', description='The service ID.', example='svc-xxx'),
          version?: string(name='version', description='The version of the microservice.', example='v1'),
          weight?: int32(name='weight', description='The service weight.', example='100'),
        }
      ](name='serviceConfigs', description='The configurations of an existing service.'),
      subDomains?: [ 
        {
          domainId?: string(name='domainId', description='The domain name ID.', example='d-xxx'),
          name?: string(name='name', description='The domain name.', example='www.example.com'),
          networkType?: string(name='networkType', description='The network type.', example='Internet'),
          protocol?: string(name='protocol', description='The communication protocol.', example='HTTP'),
        }
      ](name='subDomains', description='The default domain names of the environment.'),
    }
  ](name='environments', description='The API environment information.'),
  gatewayId?: string(name='gatewayId', description='The instance ID.', example='gw-cpv4sqdl****'),
  httpApiId?: string(name='httpApiId', description='The HTTP API ID.', example='api-xxx'),
  ingressInfo?: {
    environmentInfo?: {
      environmentId?: string(name='environmentId', description='The environment ID.', example='env-xxx'),
    }(name='environmentInfo', description='The environment information.'),
    ingressClass?: string(name='ingressClass', description='The Ingress Class for listening.', example='mse'),
    k8sClusterInfo?: {
      clusterId?: string(name='clusterId', description='The cluster ID.', example='ca435c77cba1547cca9311957bcxxxxxx'),
    }(name='k8sClusterInfo', description='The information about the Kubernetes cluster.'),
    overrideIngressIp?: boolean(name='overrideIngressIp', description='Specifies whether to update the address in Ingress Status.', example='true'),
    sourceId?: string(name='sourceId', description='The source ID.', example='src-xxx'),
    watchNamespace?: string(name='watchNamespace', description='The namespace for listening.', example='default'),
  }(name='ingressInfo', description='The information about the HTTP Ingress API.'),
  modelCategory?: string(name='modelCategory', description='Model category', example='Text'),
  name?: string(name='name', description='The API name.', example='test'),
  protocols?: [ string ](name='protocols', description='The protocols.'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group.', example='rg-xxx'),
  type?: string(name='type', description='The API type.

Valid values:

*   HttpIngress
*   Rest
*   Websocket
*   AI
*   Http', example='Rest'),
  versionInfo?: HttpApiVersionInfo(name='versionInfo', description='The API versioning information.'),
}

model HttpApiBackendMatchCondition {
  key?: string(name='key', description='The key of the matching condition.', example='color'),
  operator?: string(name='operator', description='The operator. Exact match, prefix match, and regular expressions are supported.

Valid values:

*   equal
*   regex
*   prefix', example='equal'),
  type?: string(name='type', description='The match type. Query and Header parameters can be matched.', example='Query'),
  value?: string(name='value', description='The value of the matching condition.', example='gray'),
}

model HttpApiBackendMatchConditions {
  conditions?: [
    HttpApiBackendMatchCondition
  ](name='conditions', description='The configurations of the matching conditions.'),
  default?: boolean(name='default', description='Specifies whether the matching condition is the default one.', example='true'),
}

model HttpApiDeployConfig {
  autoDeploy?: boolean(name='autoDeploy', description='Specifies whether to enable automatic deployment.', example='true'),
  backendScene?: string(name='backendScene', description='The publishing scenario.', example='SingleService'),
  customDomainIds?: [ string ](name='customDomainIds', description='The IDs of the custom domain names.'),
  customDomainInfos?: [ 
    {
      domainId?: string(name='domainId', description='The domain name ID.', example='d-cshee6dlhtgkf4muio3g'),
      name?: string(name='name', description='The domain name.', example='hello-server.com'),
      protocol?: string(name='protocol', description='The protocol.', example='HTTP'),
    }
  ](name='customDomainInfos', description='The information about the custom domain names.'),
  environmentId?: string(name='environmentId', description='The environment ID.', example='env-xxx'),
  gatewayId?: string(name='gatewayId', description='The instance ID.', example='gw-xx'),
  gatewayInfo?: GatewayInfo(name='gatewayInfo', description='The instance information.'),
  gatewayType?: string(name='gatewayType', description='网关类型', example='API'),
  mock?: HttpApiMockContract(name='mock', description='The Mock settings.'),
  policyConfigs?: [ 
    {
      aiFallbackConfig?: {
        serviceConfigs?: [ 
          {
            serviceId?: string(name='serviceId', description='Service ID for fallback', example='svc-******'),
            targetModelName?: string(name='targetModelName', description='targetModelName', example='gpt-4/llama3-70b'),
          }
        ](name='serviceConfigs', description='List of fallback service configurations'),
      }(name='aiFallbackConfig', description='The fallback configurations'),
      aiSecurityGuardConfig?: {
        bufferLimit?: int32(name='bufferLimit', description='bufferLimit', example='50'),
        checkRequest?: boolean(name='checkRequest', description='Whether to check request content', example='true'),
        checkRequestImage?: boolean(name='checkRequestImage', description='Whether to check request content', example='true'),
        checkResponse?: boolean(name='checkResponse', description='Whether to check response content', example='true'),
        checkResponseImage?: boolean(name='checkResponseImage', description='Whether to check response content', example='true'),
        consumerRequestCheckService?: [ 
          {
            matchType?: string(name='matchType', description='Match type', example='exact/prefix'),
            modalityType?: string(name='modalityType', description='Modality type', example='text/image'),
            name?: string(name='name', description='Consumer name for matching', example='API'),
            requestCheckService?: string(name='requestCheckService', description='Request check service name', example='https://checker.example.com/validate'),
            requestImageCheckService?: string(name='requestImageCheckService', description='requestImageCheckService', example='https://image-check.example.com/scan'),
          }
        ](name='consumerRequestCheckService', description='Consumer-specific request check configs'),
        consumerResponseCheckService?: [ 
          {
            matchType?: string(name='matchType', description='Match type', example='term'),
            modalityType?: string(name='modalityType', description='Modality type', example='text/image'),
            name?: string(name='name', description='Consumer name for matching', example='AI_API'),
            responseCheckService?: string(name='responseCheckService', description='Response check service name', example='https://checker.example.com/validate-response'),
            responseImageCheckService?: string(name='responseImageCheckService', description='responseImageCheckService', example='https://image-check.example.com/scan-response'),
          }
        ](name='consumerResponseCheckService', description='Consumer-specific Response check configs'),
        consumerRiskLevel?: [ 
          {
            level?: string(name='level', description='Risk alert level', example='Critical'),
            matchType?: string(name='matchType', description='Match type', example='term'),
            name?: string(name='name', description='Consumer name for matching', example='APIG-UI'),
            type?: string(name='type', description='Risk type', example='K8S'),
          }
        ](name='consumerRiskLevel', description='Consumer-specific risk level configs'),
        requestCheckService?: string(name='requestCheckService', description='Request check service name', example='https://checker.example.com/validate-request'),
        requestImageCheckService?: string(name='requestImageCheckService', description='Request check service name', example='https://image-checker.example.com/scan'),
        responseCheckService?: string(name='responseCheckService', description='Response check service name', example='https://checker.example.com/validate-response'),
        responseImageCheckService?: string(name='responseImageCheckService', description='Response check service name', example='https://image-checker.example.com/scan-response'),
        riskAlertLevel?: string(name='riskAlertLevel', description='Risk alert level for content moderation', example='low/medium/high'),
        riskConfig?: [ 
          {
            consumerRules?: {
              matchType?: string(name='matchType', description='Match type', example='term'),
              pattern?: string(name='pattern', description='Pattern for matching', example='first'),
            }(name='consumerRules', description='Consumer-specific rules'),
            level?: string(name='level', description='Risk alert level', example='Critical'),
            type?: string(name='type', description='Risk type identifier', example='K8S'),
          }
        ](name='riskConfig', description='riskConfig'),
        serviceAddress?: string(name='serviceAddress', description='Security guard service address', example='https://api.example.com/v1'),
      }(name='aiSecurityGuardConfig', description='AI Security Guard configuration'),
      aiStatisticsConfig?: {
        logRequestContent?: boolean(name='logRequestContent'),
        logResponseContent?: boolean(name='logResponseContent'),
      }(name='aiStatisticsConfig'),
      aiTokenRateLimitConfig?: {
        enableGlobalRules?: boolean(name='enableGlobalRules', description='Whether to enable global rate limit rules', example='true'),
        globalRules?: [ 
          {
            limitMode?: string(name='limitMode', description='Limit mode for global rules', example='local'),
            limitType?: string(name='limitType', description='Limit type for global rules', example='request'),
            limitValue?: int32(name='limitValue', description='Limit value for global rules', example='100'),
            matchKey?: string(name='matchKey', description='Match key', example='user_id'),
            matchType?: string(name='matchType', description='Match type', example='term'),
            matchValue?: string(name='matchValue', description='Match value', example='user123'),
          }
        ](name='globalRules', description='List of global rate limit rules'),
        rules?: [ 
          {
            limitMode?: string(name='limitMode', description='Limit mode', example='local'),
            limitType?: string(name='limitType', description='Limit type', example='request/token'),
            limitValue?: int32(name='limitValue', description='Limit value', example='100'),
            matchKey?: string(name='matchKey', description='Match key', example='user_id/api_path'),
            matchType?: string(name='matchType', description='Match type', example='term'),
            matchValue?: string(name='matchValue', description='Match value', example='user123'),
          }
        ](name='rules', description='List of rate limit rules'),
      }(name='aiTokenRateLimitConfig', description='AI Token Rate Limit configuration'),
      enable?: boolean(name='enable', description='Specifies whether to enable the policy.', example='true'),
      type?: string(name='type', description='The type of the policy. Valid values:', example='AiFallback'),
    }
  ](name='policyConfigs', description='The policy configurations.'),
  routeBackend?: Backend(name='routeBackend', description='routeBackend'),
  serviceConfigs?: [ 
    {
      gatewayServiceId?: string(name='gatewayServiceId', description='Legacy gateway service ID for backward compatibility', example='gw-svc-abc123'),
      intentCode?: string(name='intentCode', description='Intent classification code', example='INQUIRY'),
      match?: HttpApiBackendMatchConditions(name='match', description='Match conditions'),
      modelName?: string(name='modelName', description='The model name.', example='qwen-max'),
      modelNamePattern?: string(name='modelNamePattern', description='The model name matching rule.', example='qwen-*'),
      multiServiceRouteStrategy?: string(name='multiServiceRouteStrategy', description='Multi-service routing strategy type', example='ByWeight'),
      name?: string(name='name', description='Service display name', example='Qwen-Max-Service'),
      observabilityRouteConfig?: {
        mode?: string(name='mode', description='Routing mode', example='LeastBusy'),
        queueSize?: int32(name='queueSize', description='Queue size', example='100'),
        rateLimit?: float(name='rateLimit', description='Max traffic ratio per single service', example='0.8'),
      }(name='observabilityRouteConfig', description='Observability metrics-based routing config'),
      port?: int32(name='port', description='Service port number', example='80'),
      protocol?: string(name='protocol', description='Service protocol', example='HTTP'),
      serviceId?: string(name='serviceId', description='The service ID.', example='svc-xxx'),
      version?: string(name='version', description='Service version tag for tag-based routing scenarios', example='v2'),
      weight?: long(name='weight', description='The service weight.', example='100'),
    }
  ](name='serviceConfigs', description='The service configurations.'),
  subDomains?: [ 
    {
      domainId?: string(name='domainId', description='The domain name ID.', example='d-csmn42um1hksudfk9eng'),
      name?: string(name='name', description='The domain name.', example='test'),
      networkType?: string(name='networkType', description='The network type.', example='Intranet'),
      protocol?: string(name='protocol', description='The protocol.', example='HTTP'),
    }
  ](name='subDomains', description='The information about the sub-domain names.'),
}

model HttpApiDomainInfo {
  domainId?: string(name='domainId', description='The domain name ID.', example='d-xxx'),
  name?: string(name='name', description='The domain name.', example='www.example.com'),
  protocol?: string(name='protocol', description='The protocol.

Valid values:

*   HTTPS
*   HTTP', example='HTTP'),
}

model HttpApiInfoByName {
  gatewayId?: string(name='GatewayId', example='gw-xx'),
  name?: string(name='name', description='The API name.', example='test-api'),
  type?: string(name='type', description='The API type.', example='Http'),
  versionEnabled?: boolean(name='versionEnabled', description='Specifies whether to enable versioning.', example='true'),
  versionedHttpApis?: [
    HttpApiApiInfo
  ](name='versionedHttpApis', description='The information about the versioned API.'),
}

model HttpApiMockContract {
  enable?: boolean(name='enable', description='Specifies whether to enable the Mock feature.', example='false'),
  responseCode?: int32(name='responseCode', description='The response code.', example='200'),
  responseContent?: string(name='responseContent', description='The response content.', example='Mock content.'),
}

model HttpApiOperation {
  authConfig?: AuthConfig(name='authConfig', description='The authentication configurations.'),
  deployConfigs?: [
    HttpApiDeployConfig
  ](name='deployConfigs', description='The deployment configurations.'),
  description?: string(name='description', description='The operation description.', example='This is a operation description.'),
  enableAuth?: boolean(name='enableAuth', description='Specifies whether to enable authentication.', example='true'),
  method?: string(name='method', description='The HTTP method.

Valid values:

*   TRACE
*   HEAD
*   DELETE
*   POST
*   GET
*   CONNECT
*   OPTIONS
*   PUT
*   PATCH

This parameter is required.', example='GET'),
  mock?: HttpApiMockContract(name='mock', description='The mocking configuration of the operation. This field takes effect only when the API publishing scenario is Mock.'),
  name?: string(name='name', description='The operation name.

This parameter is required.', example='GetUserInfo'),
  path?: string(name='path', description='The operation path.

This parameter is required.', example='/user'),
  request?: HttpApiRequestContract(name='request', description='The request parameters of the operation.'),
  response?: HttpApiResponseContract(name='response', description='The response parameters of the operation.'),
}

model HttpApiOperationInfo {
  authConfig?: AuthConfig(name='authConfig', description='The authentication configurations of the operation.'),
  createTimestamp?: long(name='createTimestamp', description='The creation timestamp.', example='1719386834548'),
  deployConfigs?: [
    HttpApiDeployConfig
  ](name='deployConfigs', description='The backend service deployment information of the operation.'),
  description?: string(name='description', description='The operation description.', example='A example operation.'),
  enableAuth?: boolean(name='enableAuth', description='Specifies whether to enable authentication.', example='true'),
  method?: string(name='method', description='The HTTP method of the operation.

Valid values:

*   TRACE
*   HEAD
*   DELETE
*   POST
*   GET
*   CONNECT
*   OPTIONS
*   PUT
*   PATCH', example='GET'),
  mock?: HttpApiMockContract(name='mock', description='The mocked parameters of the operation.'),
  name?: string(name='name', description='The operation name.', example='GetUserInfo'),
  operationId?: string(name='operationId', description='The operation ID.', example='op-xxx'),
  path?: string(name='path', description='The operation path.', example='/user/123'),
  request?: HttpApiRequestContract(name='request', description='The request parameters of the operation.'),
  response?: HttpApiResponseContract(name='response', description='The response parameters of the operation.'),
  status?: string(name='status', description='The operation publishing status on the instance.', example='Deployed'),
}

model HttpApiParameter {
  defaultValue?: string(name='defaultValue', description='The default value of the parameter.', example='123'),
  description?: string(name='description', description='The parameter description.', example='The example description.'),
  exampleValue?: string(name='exampleValue', description='The sample value of the parameter.', example='123'),
  name?: string(name='name', description='The parameter name.

This parameter is required.', example='userId'),
  required?: boolean(name='required', description='Specifies whether the parameter is required.', example='true'),
  type?: string(name='type', description='The parameter type.

Valid values:

*   Integer
*   Number
*   String
*   Boolean

This parameter is required.', example='String'),
}

model HttpApiPolicyConfigs {
  aiCacheConfig?: {
    cacheKeyStrategy?: string(name='cacheKeyStrategy', description='Strategy for generating cache keys', example='default'),
    cacheMode?: string(name='cacheMode', description='Cache mode type', example='exact'),
    cacheTTL?: int32(name='cacheTTL', description='Cache time-to-live in seconds', example='3600'),
    embeddingConfig?: {
      modelName?: string(name='modelName', description='Embedding model name', example='model-1'),
      serviceId?: string(name='serviceId', description='Embedding service ID', example='svc-1'),
      timeout?: int32(name='timeout', description='Embedding service request timeout in milliseconds', example='2000'),
      type?: string(name='type', description='Embedding service provider type', example='dashscope'),
    }(name='embeddingConfig', description='Embedding Config'),
    pluginStatus?: {
      errorLogs?: map[string]string(name='errorLogs', description='errorLogs'),
      pluginId?: string(name='pluginId', description='pluginId', example='pl-123456'),
      serviceHealthy?: boolean(name='serviceHealthy', description='serviceHealthy', example='true'),
    }(name='pluginStatus', description='pluginStatus'),
    redisConfig?: {
      databaseNumber?: int32(name='databaseNumber', description='Redis database number', example='1'),
      host?: string(name='host', description='Redis host', example='redis.example.com'),
      password?: string(name='password', description='Redis password', example='******'),
      port?: int32(name='port', description='Redis port', example='6379'),
      timeout?: int32(name='timeout', description='Redis timeout', example='60'),
      username?: string(name='username', description='Redis username', example='username'),
    }(name='redisConfig', description='Redis configuration for cache storage'),
    vectorConfig?: {
      apiKey?: string(name='apiKey', description='Vector database API key for authentication', example='vec-api-key-123'),
      collectionId?: string(name='collectionId', description='Vector database collection ID for storing vector embeddings', example='col-1'),
      serviceHost?: string(name='serviceHost', description='Vector database service host address', example='vec.example.com'),
      threshold?: float(name='threshold', description='Similarity threshold for semantic matching', example='0.8'),
      timeout?: int32(name='timeout', description='Vector database request timeout in milliseconds', example='1000'),
      type?: string(name='type', description='Vector database service type', example='dashvector'),
    }(name='vectorConfig', description='vectorConfig'),
  }(name='aiCacheConfig', description='AiCacheConfig'),
  aiFallbackConfig?: {
    onlyRedirectUpstreamCode?: boolean(name='onlyRedirectUpstreamCode', description='Only trigger fallback when backend returns 4xx/5xx status codes', example='true'),
    routeEmbedded?: boolean(name='routeEmbedded', description='Whether the policy is generated from route embedded configuration', example='true'),
    serviceConfigs?: [ 
      {
        name?: string(name='name', description='Service name for frontend display', example='azure.ai'),
        passThroughModelName?: boolean(name='passThroughModelName', description='Whether to pass through the original model name', example='true'),
        serviceId?: string(name='serviceId', description='Fallback service ID', example='svc-123456'),
        targetModelName?: string(name='targetModelName', description='Target model name for fallback', example='kimi-fallback-test'),
      }
    ](name='serviceConfigs', description='List of fallback service configurations'),
  }(name='aiFallbackConfig', description='AiFallbackConfig'),
  aiNetworkSearchConfig?: {
    defaultEnable?: boolean(name='defaultEnable', description='Default enable', example='true'),
    defaultLang?: string(name='defaultLang', description='Default search language code', example='zh-CN'),
    needReference?: boolean(name='needReference', description='Add reference sources in answer', example='true'),
    pluginStatus?: {
      errorLogs?: map[string]string(name='errorLogs', description='errorLogs'),
      pluginId?: string(name='pluginId', description='pluginId', example='pl-123456'),
      serviceHealthy?: boolean(name='serviceHealthy', description='serviceHealthy', example='true'),
    }(name='pluginStatus', description='pluginStatus'),
    referenceFormat?: string(name='referenceFormat', description='Reference format', example='Reference: %s'),
    referenceLocation?: string(name='referenceLocation', description='Reference location', example='head'),
    searchEngineConfig?: {
      apiKey?: string(name='apiKey', description='Search engine API key', example='xxx'),
      contentMode?: string(name='contentMode', description='Content mode', example='summary'),
      count?: int32(name='count', description='Result count', example='10'),
      endpoint?: string(name='endpoint', description='Search engine endpoint', example='******-hangzhou.aliyuncs.com'),
      industry?: string(name='industry', description='Industry', example='tech'),
      optionArgs?: map[string]string(name='optionArgs', description='Additional parameters'),
      start?: int32(name='start', description='Result offset', example='0'),
      timeRange?: string(name='timeRange', description='Time range', example='7d'),
      timeoutMillisecond?: int32(name='timeoutMillisecond', description='API call timeout in milliseconds', example='5000'),
      type?: string(name='type', description='Search engine type: Bing/aliyunQuark', example='Bing'),
    }(name='searchEngineConfig', description='Search engine configuration'),
    searchFrom?: [ 
      {
        apiKey?: string(name='apiKey', description='Search engine API key', example='xxx'),
        contentMode?: string(name='contentMode', description='Content mode', example='summary'),
        count?: int32(name='count', description='Result count', example='10'),
        endpoint?: string(name='endpoint', description='Search engine endpoint', example='******-hangzhou.aliyuncs.com'),
        industry?: string(name='industry', description='Industry', example='tech'),
        optionArgs?: map[string]string(name='optionArgs', description='Additional parameters'),
        start?: int32(name='start', description='Result offset', example='0'),
        timeRange?: string(name='timeRange', description='Time range', example='7d'),
        timeoutMillisecond?: int32(name='timeoutMillisecond', description='API call timeout in milliseconds', example='5000'),
        type?: string(name='type', description='Search engine type', example='Bing'),
      }
    ](name='searchFrom', description='Search engine list'),
    searchRewrite?: {
      enable?: boolean(name='enable', description='Enable search rewrite', example='true'),
      maxCount?: int32(name='maxCount', description='Max rewrite count (1-5)', example='3'),
      modelName?: string(name='modelName', description='Model name', example='qwen-turbo'),
      serviceId?: string(name='serviceId', description='Service ID', example='svc-123456'),
      timeoutMillisecond?: int32(name='timeoutMillisecond', description='Timeout in milliseconds', example='5000'),
    }(name='searchRewrite', description='Search rewrite configuration'),
  }(name='aiNetworkSearchConfig', description='AiNetworkSearchConfig'),
  aiSecurityGuardConfig?: {
    bufferLimit?: int32(name='bufferLimit', description='Buffer limit for content checking', example='1000'),
    checkRequest?: boolean(name='checkRequest', description='Enable request content checking', example='true'),
    checkRequestImage?: boolean(name='checkRequestImage', description='Enable request image checking', example='true'),
    checkResponse?: boolean(name='checkResponse', description='Enable response content checking', example='true'),
    checkResponseImage?: boolean(name='checkResponseImage', description='Enable response image checking', example='true'),
    consumerRequestCheckService?: [ 
      {
        matchType?: string(name='matchType', description='Match type', example='Exact'),
        modalityType?: string(name='modalityType', description='Modality type', example='Text'),
        name?: string(name='name', description='Consumer name', example='consumer-1'),
        requestCheckService?: string(name='requestCheckService', description='requestCheckService', example='query_security_check'),
        requestImageCheckService?: string(name='requestImageCheckService', description='requestImageCheckService', example='nsfw-image-detector'),
      }
    ](name='consumerRequestCheckService', description='consumerRequestCheckService'),
    consumerResponseCheckService?: [ 
      {
        matchType?: string(name='matchType', description='Match type', example='Exact'),
        modalityType?: string(name='modalityType', description='Modality type', example='Text'),
        name?: string(name='name', description='Consumer name', example='consumer-1'),
        responseCheckService?: string(name='responseCheckService', description='responseCheckService', example='response_security_check'),
        responseImageCheckService?: string(name='responseImageCheckService', description='responseImageCheckService', example='watermark-detector'),
      }
    ](name='consumerResponseCheckService', description='consumerResponseCheckService'),
    consumerRiskLevel?: [ 
      {
        level?: string(name='level', description='Risk level', example='high'),
        matchType?: string(name='matchType', description='Match type', example='Exact'),
        name?: string(name='name', description='Consumer name', example='consumer-1'),
        type?: string(name='type', description='Risk type', example='ContentModeration'),
      }
    ](name='consumerRiskLevel', description='consumerRiskLevel'),
    pluginStatus?: {
      errorLogs?: map[string]string(name='errorLogs', description='errorLogs'),
      pluginId?: string(name='pluginId', description='pluginId', example='pl-123456'),
      serviceHealthy?: boolean(name='serviceHealthy', description='serviceHealthy', example='true'),
    }(name='pluginStatus', description='pluginStatus'),
    requestCheckService?: string(name='requestCheckService', description='Request text check service type', example='content-moderation-service'),
    requestImageCheckService?: string(name='requestImageCheckService', description='Request image check service type', example='image-moderation-service'),
    responseCheckService?: string(name='responseCheckService', description='Response text check service type', example='output-moderation-service'),
    responseImageCheckService?: string(name='responseImageCheckService', description='Response image check service type', example='generated-image-scanner'),
    riskAlertLevel?: string(name='riskAlertLevel', description='Global risk alert level', example='high'),
    riskConfig?: [ 
      {
        consumerRules?: {
          matchType?: string(name='matchType', description='matchType', example='Exact'),
          pattern?: string(name='pattern', description='pattern', example='/v1/chat/*'),
        }(name='consumerRules', description='consumerRules'),
        level?: string(name='level', description='Risk level', example='high'),
        type?: string(name='type', description='Risk type', example='ContentModeration'),
      }
    ](name='riskConfig', description='RiskConfig'),
    serviceAddress?: string(name='serviceAddress', description='Security guard service endpoint URL', example='https://api.example.com/v1'),
  }(name='aiSecurityGuardConfig', description='AiSecurityGuardConfig'),
  aiStatisticsConfig?: {
    logRequestContent?: boolean(name='logRequestContent', description='Log request content', example='true'),
    logResponseContent?: boolean(name='logResponseContent', description='Log response content', example='true'),
  }(name='aiStatisticsConfig', description='AiStatisticsConfig'),
  aiTokenRateLimitConfig?: {
    enableGlobalRules?: boolean(name='enableGlobalRules', description='Enable global rate limit rules', example='true'),
    globalRules?: [ 
      {
        limitMode?: string(name='limitMode', description='Limit mode', example='TokenPerSecond'),
        limitType?: string(name='limitType', description='Limit type', example='Global'),
        limitValue?: string(name='limitValue', description='Limit value', example='100'),
        matchKey?: string(name='matchKey', description='Match key', example='user_id'),
        matchType?: string(name='matchType', description='Match type', example='Exact'),
        matchValue?: string(name='matchValue', description='Match value', example='12345'),
      }
    ](name='globalRules', description='List of global rate limit rules'),
    pluginStatus?: {
      errorLogs?: map[string]string(name='errorLogs', description='Array of plugin execution error logs'),
      pluginId?: string(name='pluginId', description='Plugin instance unique identifier', example='pl-123456'),
      serviceHealthy?: boolean(name='serviceHealthy', description='Health status of the cache service', example='true'),
    }(name='pluginStatus', description='pluginStatus'),
    redisConfig?: {
      databaseNumber?: int32(name='databaseNumber', description='Redis database number', example='1'),
      host?: string(name='host', description='Redis host', example='redis.example.com'),
      password?: string(name='password', description='Redis password', example='******'),
      port?: int32(name='port', description='Redis port', example='6379'),
      timeout?: int32(name='timeout', description='Redis timeout', example='60'),
      username?: string(name='username', description='Redis username', example='username'),
    }(name='redisConfig', description='Redis Config'),
    rules?: [ 
      {
        limitMode?: string(name='limitMode', description='Limit mode', example='TokenPerSecond'),
        limitType?: string(name='limitType', description='Limit type', example='Header'),
        limitValue?: string(name='limitValue', description='Limit value', example='100'),
        matchKey?: string(name='matchKey', description='Match key', example='x-api-key'),
        matchType?: string(name='matchType', description='Match type', example='Exact'),
        matchValue?: string(name='matchValue', description='Match value', example='test-value'),
      }
    ](name='rules', description='List of rate limit rules'),
  }(name='aiTokenRateLimitConfig', description='AiTokenRateLimitConfig'),
  aiToolSelectionConfig?: {
    enableConditions?: {
      toolCountThreshold?: int32(name='toolCountThreshold', description='Tool count threshold', example='10'),
    }(name='enableConditions', description='Enable conditions configuration'),
    pluginStatus?: {
      errorLogs?: map[string]string(name='errorLogs', description='errorLogs'),
      pluginId?: string(name='pluginId', description='pluginId', example='pl-123456'),
      serviceHealthy?: boolean(name='serviceHealthy', description='serviceHealthy', example='true'),
    }(name='pluginStatus', description='Plugin status'),
    queryRewriting?: {
      contextSelection?: {
        type?: string(name='type', description='Context type', example='recentMessages'),
        value?: int32(name='value', description='Value', example='5'),
      }(name='contextSelection', description='Context selection'),
      enabled?: boolean(name='enabled', description='Enable query rewriting', example='true'),
      fallbackStrategy?: string(name='fallbackStrategy', description='Fallback strategy', example='skip'),
      maxOutputTokens?: int32(name='maxOutputTokens', description='Max output tokens', example='50'),
      modelService?: {
        modelName?: string(name='modelName', description='Model name', example='qwen-turbo'),
        serviceId?: string(name='serviceId', description='Service ID', example='svc-123456'),
        timeoutMillisecond?: int32(name='timeoutMillisecond', description='Timeout in milliseconds', example='5000'),
      }(name='modelService', description='Model service configuration'),
      promptConfig?: {
        customPrompt?: string(name='customPrompt', description='Custom prompt (required when type=custom)', example='Custom prompt'),
        type?: string(name='type', description='Prompt type: builtIn/custom', example='builtIn'),
      }(name='promptConfig', description='Prompt configuration'),
      triggerConditions?: {
        messageCountThreshold?: int32(name='messageCountThreshold', description='Message count threshold (≥0)', example='1'),
      }(name='triggerConditions', description='Trigger conditions'),
    }(name='queryRewriting', description='Query rewriting configuration'),
    toolReranking?: {
      fallbackStrategy?: string(name='fallbackStrategy', description='Fallback strategy: skip/error', example='skip'),
      filteringMethod?: string(name='filteringMethod', description='Filtering method: topK/topN/combined', example='topK'),
      modelService?: {
        modelName?: string(name='modelName', description='Model name', example='gte-rerank-v2'),
        serviceId?: string(name='serviceId', description='Service ID', example='svc-123456'),
        timeoutMillisecond?: int32(name='timeoutMillisecond', description='Timeout in milliseconds', example='5000'),
      }(name='modelService', description='Model service configuration'),
      scoreThreshold?: float(name='scoreThreshold', description='Score threshold (0.0-1.0, 0 means disabled)', example='0.5'),
      topKPercent?: int32(name='topKPercent', description='TopK percentage (1-100)', example='50'),
      topNCount?: int32(name='topNCount', description='TopN count', example='5'),
    }(name='toolReranking', description='Tool reranking configuration'),
  }(name='aiToolSelectionConfig', description='AiToolSelectionConfig'),
  enable?: boolean(name='enable', description='Policy Enable', example='true'),
  semanticRouterConfig?: {
    timeoutMillisecond?: int32(name='timeoutMillisecond', description='Timeout in milliseconds', example='2000'),
  }(name='semanticRouterConfig', description='SemanticRouterConfig'),
  type?: string(name='type', description='Policy Type', example='AiCache'),
}

model HttpApiPublishRevisionInfo {
  backendScene?: string(name='backendScene', description='The publishing scenario.

Valid values:

*   SingleService
*   MultiServiceByRatio
*   MultiServiceByContent
*   MultiServiceByTag
*   Mock', example='SingleService'),
  backendType?: string(name='backendType', description='The type of the backend service.

Valid values:

*   DNS: a DNS domain name
*   Service: an existing service
*   VIP: a fixed IP address
*   CloudProduct: a cloud service', example='Service'),
  cloudProductConfig?: {
    cloudProductType?: string(name='cloudProductType', description='The type of the cloud service.', example='FC'),
    containerServiceConfigs?: [ 
      {
        gatewayServiceId?: string(name='gatewayServiceId', description='The associated service ID.', example='gs-xxx'),
        match?: HttpApiBackendMatchConditions(name='match', description='The matching conditions.'),
        name?: string(name='name', description='The K8s service name.', example='demo-service'),
        namespace?: string(name='namespace', description='The K8s namespace.', example='default'),
        port?: int32(name='port', description='The service port.', example='8080'),
        protocol?: string(name='protocol', description='The service protocol.', example='HTTP'),
        weight?: string(name='weight', description='The service weight.', example='100'),
      }
    ](name='containerServiceConfigs', description='The ACK configurations.'),
    functionConfigs?: [ 
      {
        gatewayServiceId?: string(name='gatewayServiceId', description='The associated service ID.', example='gs-xxx'),
        match?: HttpApiBackendMatchConditions(name='match', description='The matching conditions.'),
        name?: string(name='name', description='The function name.', example='demo-function'),
        qualifier?: string(name='qualifier', description='The function version or alias.', example='LATEST'),
        weight?: int32(name='weight', description='The service weight.', example='100'),
      }
    ](name='functionConfigs', description='The Function Compute configurations.'),
    mseNacosConfigs?: [ 
      {
        gatewayServiceId?: string(name='gatewayServiceId', description='The associated service ID.', example='gs-xxx'),
        groupName?: string(name='groupName', description='The service group.', example='DEFAULT_GROUP'),
        match?: HttpApiBackendMatchConditions(name='match', description='The matching conditions.'),
        name?: string(name='name', description='The Nacos service name.', example='spring-demo'),
        namespace?: string(name='namespace', description='The Nacos namespace.', example='public'),
        weight?: int32(name='weight', description='The service weight.', example='100'),
      }
    ](name='mseNacosConfigs', description='The MSE Nacos configurations.'),
  }(name='cloudProductConfig', description='The cloud service configurations.'),
  createTimestamp?: long(name='createTimestamp', description='The publishing timestamp.', example='1718807057927'),
  customDomains?: [
    HttpApiDomainInfo
  ](name='customDomains', description='The custom domain names.'),
  dnsConfigs?: [ 
    {
      dnsList?: [ string ](name='dnsList', description='The DNS domain names.'),
      match?: HttpApiBackendMatchConditions(name='match', description='The matching condition. This condition is valid only in content-based routing.'),
      weight?: int32(name='weight', description='The weight. Valid values: [1,100]. This parameter is valid only in proportional routing.', example='100'),
    }
  ](name='dnsConfigs', description='The configurations of DNS domain names. For single-service publishing, only one entry is allowed. For other scenarios, multiple entries are allowed.'),
  environmentInfo?: {
    alias?: string(name='alias', description='The environment alias.', example='Test'),
    environmentId?: string(name='environmentId', description='The environment ID.', example='env-xxx'),
    gatewayInfo?: {
      gatewayId?: string(name='gatewayId', description='The instance ID.', example='gw-xxx'),
      name?: string(name='name', description='The instance name.', example='Instance 1'),
    }(name='gatewayInfo', description='The instance information.'),
    name?: string(name='name', description='The environment name.', example='test'),
  }(name='environmentInfo', description='The environment information.', example='env-xxx'),
  isCurrentVersion?: boolean(name='isCurrentVersion', description='Specifies whether the current version is used.', example='true'),
  operations?: [
    HttpApiOperationInfo
  ](name='operations', description='The operations.'),
  revisionId?: string(name='revisionId', description='The published version.', example='apr-xxx'),
  serviceConfigs?: [ 
    {
      gatewayServiceId?: string(name='gatewayServiceId', description='The service ID.', example='gs-xxx'),
      match?: HttpApiBackendMatchConditions(name='match', description='The matching conditions.'),
      port?: int32(name='port', description='The service port.', example='8080'),
      protocol?: string(name='protocol', description='The service protocol.', example='HTTP'),
      version?: string(name='version', description='The service version.', example='v1'),
      weight?: int32(name='weight', description='The service weight.', example='100'),
    }
  ](name='serviceConfigs', description='The configurations of existing services. For single-service publishing, only one entry is allowed. For other scenarios, multiple entries are allowed.'),
  subDomains?: [
    HttpApiDomainInfo
  ](name='subDomains', description='The default domain names of the environment.', example='env-xxx.com'),
  vipConfigs?: [ 
    {
      endpoints?: [ string ](name='endpoints', description='The IP addresses.'),
      match?: HttpApiBackendMatchConditions(name='match', description='The matching condition. This condition is valid only in content-based routing.'),
      weight?: int32(name='weight', description='The weight. Valid values: [1,100]. This parameter is valid only in proportional routing.', example='100'),
    }
  ](name='vipConfigs', description='The configurations of fixed IP addresses. For single-service publishing, only one entry is allowed. For other scenarios, multiple entries are allowed.'),
}

model HttpApiRequestContract {
  body?: {
    contentType?: string(name='contentType', description='The content type of the request body.', example='application/json'),
    description?: string(name='description', description='The parameter description.', example='This is a description.'),
    example?: string(name='example', description='The sample value.', example='{"result":"ok"}'),
    jsonSchema?: string(name='jsonSchema', description='The JSON definition description of the request body.', example='{
      "type": "object",
      "required": [
          "result"
      ],
      "properties": {
          "result": {
              "type": "string",
              "description": "Operation result. \\\\"ok\\\\" indicates success."
          }
      }
  }'),
  }(name='body', description='The body parameters.'),
  headerParameters?: [
    HttpApiParameter
  ](name='headerParameters', description='The request header parameters.'),
  pathParameters?: [
    HttpApiParameter
  ](name='pathParameters', description='The path parameters.'),
  queryParameters?: [
    HttpApiParameter
  ](name='queryParameters', description='The query parameters.'),
}

model HttpApiResponseContract {
  contentType?: string(name='contentType', description='The content type.

This parameter is required.', example='application/json'),
  items?: [ 
    {
      code?: int32(name='code', description='The response code.', example='200'),
      description?: string(name='description', description='The response description.', example='This is a description.'),
      example?: string(name='example', description='The sample value.', example='{"result": "ok"}'),
      jsonSchema?: string(name='jsonSchema', description='The JSON definition description of the response body.', example='{
    "type": "object",
    "required": [
        "result"
    ],
    "properties": {
        "result": {
            "type": "string",
            "description": "This is a description."
        }
    }
}'),
    }
  ](name='items', description='The response definition.'),
}

model HttpApiVersionConfig {
  enable?: boolean(name='enable', description='Specifies whether to enable versioning.', example='true'),
  headerName?: string(name='headerName', description='The key in the specified header when the header versioning solution is used.', example='my-version'),
  queryName?: string(name='queryName', description='The key in the specified query parameter when the query versioning solution is used.', example='myVersion'),
  scheme?: string(name='scheme', description='The versioning solution.

Valid values:

*   Path
*   Query
*   Header', example='Query'),
  version?: string(name='version', description='The version number.', example='v1'),
}

model HttpApiVersionInfo {
  enable?: boolean(name='enable', description='Specifies whether to enable versioning.', example='true'),
  headerName?: string(name='headerName', description='The key in the specified header when the header versioning solution is used.', example='my-version'),
  queryName?: string(name='queryName', description='The key in the specified query parameter when the query versioning solution is used.', example='myVersion'),
  scheme?: string(name='scheme', description='The versioning solution.', example='Query'),
  version?: string(name='version', description='The version number.', example='v1'),
}

model HttpDubboTranscoder {
  dubboServiceGroup?: string(name='dubboServiceGroup'),
  dubboServiceName?: string(name='dubboServiceName'),
  dubboServiceVersion?: string(name='dubboServiceVersion'),
  mothedMapList?: [ 
    {
      dubboMothedName?: string(name='dubboMothedName'),
      httpMothed?: string(name='httpMothed', example='ALL_GET'),
      mothedpath?: string(name='mothedpath', example='/mytestzbk/sayhello'),
      paramMapsList?: [ 
        {
          extractKey?: string(name='extractKey', example='name'),
          extractKeySpec?: string(name='extractKeySpec', example='ALL_QUERY_PARAMETER'),
          mappingType?: string(name='mappingType', example='java.lang.String'),
        }
      ](name='paramMapsList'),
      passThroughAllHeaders?: string(name='passThroughAllHeaders', example='PASS_NOT'),
      passThroughList?: [ string ](name='passThroughList'),
    }
  ](name='mothedMapList'),
}

model HttpRoute {
  backend?: Backend(name='backend', description='The backend configuration'),
  builtin?: string(name='builtin', description='builtin', example='true'),
  createTimestamp?: long(name='createTimestamp', description='The creation timestamp in milliseconds', example='1726649310593'),
  deployStatus?: string(name='deployStatus', description='The deployment status', example='Deployed'),
  description?: string(name='description', description='The description of the route', example='Route for user management API'),
  domainInfos?: [ 
    {
      domainId?: string(name='domainId', description='The domain ID', example='d-cr3v7dllhtgi9s***'),
      name?: string(name='name', description='The domain name', example='itemcenter.dev'),
      protocol?: string(name='protocol', description='The domain protocol', example='HTTP'),
    }
  ](name='domainInfos', description='List of domain information'),
  environmentInfo?: {
    alias?: string(name='alias', description='The environment alias', example='prod'),
    environmentId?: string(name='environmentId', description='The environment ID', example='env-crhq1u5lhtgju***'),
    gatewayInfo?: {
      gatewayId?: string(name='gatewayId', description='The gateway ID', example='gw-cqoohqtlh***'),
      name?: string(name='name', description='The gateway name', example='itemcenter-gateway'),
    }(name='gatewayInfo', description='The gateway information'),
    name?: string(name='name', description='The environment name', example='itemcenter-pre'),
    subDomains?: [ 
      {
        domainId?: string(name='domainId', description='The subdomain ID', example='d-cqu19hdlhtgjuv4***'),
        name?: string(name='name', description='The subdomain name', example='env-crmic3llht***-cn-hangzhou-vpc.alicloudapi.com'),
        networkType?: string(name='networkType', description='networkType', example='Internet'),
        protocol?: string(name='protocol', description='The subdomain protocol', example='HTTP'),
      }
    ](name='subDomains', description='List of subdomain information'),
  }(name='environmentInfo', description='The environment information'),
  gatewayStatus?: map[string]string(name='gatewayStatus', description='gatewayStatus'),
  match?: HttpRouteMatch(name='match', description='The route matching rules'),
  mcpServerInfo?: {
    createFromType?: string(name='createFromType', description='The creation type', example='Nacos'),
    importInstanceId?: string(name='importInstanceId', description='The imported instance ID', example='import-001'),
    importMcpServerId?: string(name='importMcpServerId', description='The imported Nacos MCP server ID', example='mcp-002'),
    importNamespace?: string(name='importNamespace', description='The imported namespace', example='default'),
    mcpRouteConfig?: {
      exposedUriPath?: string(name='exposedUriPath', description='mcp route path', example='/mcp'),
      protocol?: string(name='protocol', description='The MCP protocol', example='SSE'),
    }(name='mcpRouteConfig', description='The MCP route configuration'),
    mcpServerConfig?: string(name='mcpServerConfig', description='The MCP server configuration content', example='{\\\\"config\\\\":{}}'),
  }(name='mcpServerInfo', description='The MCP server information'),
  name?: string(name='name', description='The name of the route', example='itemcenter-pre-route'),
  routeId?: string(name='routeId', description='The unique identifier of the route', example='hr-crf5l7tlhtgp91t***'),
  updateTimestamp?: long(name='updateTimestamp', description='The last update timestamp in milliseconds', example='1726819895636'),
}

model HttpRouteMatch {
  headers?: [ 
    {
      name?: string(name='name', description='The header name.', example='dev'),
      type?: string(name='type', description='The match type. Valid values:

*   Exact: exact match
*   Prefix: prefix match
*   Regex: regular expression', example='Exact'),
      value?: string(name='value', description='The header value.', example='true'),
    }
  ](name='headers', description='The rules for matching based on HTTP request headers.'),
  ignoreUriCase?: boolean(name='ignoreUriCase', description='Specifies whether the path is case-insensitive.', example='true'),
  methods?: [ string ](name='methods', description='The HTTP methods.'),
  path?: {
    type?: string(name='type', description='The path matching type. Valid values:

*   Exact: exact match
*   Prefix: prefix match
*   Regex: regular expression', example='Prefix'),
    value?: string(name='value', description='The path.', example='/user'),
  }(name='path', description='The path rule.'),
  queryParams?: [ 
    {
      name?: string(name='name', description='The parameter name.', example='age'),
      type?: string(name='type', description='The match type. Valid values:

*   Exact: exact match
*   Prefix: prefix match
*   Regex: regular expression', example='Exact'),
      value?: string(name='value', description='The parameter value.', example='17'),
    }
  ](name='queryParams', description='The rules for matching based on query parameters.'),
}

model JwtIdentityConfig {
  jwks?: string(name='jwks', description='The JWKS configuration.', example='xxxx'),
  jwtPayloadConfig?: {
    payloadKeyName?: string(name='payloadKeyName', description='The key in the JWT payload.', example='uid'),
    payloadKeyValue?: string(name='payloadKeyValue', description='The value for the JWT payload key.', example='2222'),
  }(name='jwtPayloadConfig', description='The JWT payload configuration.'),
  jwtTokenConfig?: {
    key?: string(name='key', description='The key used for the JWT.', example='Authorization'),
    pass?: boolean(name='pass', description='Indicates whether acceptance is granted.', example='true'),
    position?: string(name='position', description='The location where the JWT is stored.', example='HEADER'),
    prefix?: string(name='prefix', description='The token prefix configuration.', example='test'),
  }(name='jwtTokenConfig', description='The JWT token configuration.'),
  secretType?: string(name='secretType', description='The type of the secret used.

Valid values:

*   Asymmetry: asymmetric encryption.
*   Symmetry: symmetric encryption.', example='Symmetry'),
  type?: string(name='type', description='The authentication configuration type.', example='Jwt'),
}

model KMSConfig {
  kmsInstanceId?: string(name='kmsInstanceId', description='The KMS instance ID', example='kst-xxxxxxxx'),
  kmsKeyId?: string(name='kmsKeyId', description='The KMS key ID', example='key-xxxxxxxx'),
}

model LabelDetail {
  key?: string(name='key', description='The label key', example='version'),
  values?: [ string ](name='values', description='The list of available values for this label'),
}

model McpServerConfig {
}

model ParentResourceInfo {
  apiInfo?: HttpApiApiInfo(name='apiInfo', description='The API information.'),
  resourceType?: string(name='resourceType', description='The resource type. Valid values: HttpApi/Operation/GatewayRoute/Gateway/GatewayDomain', example='Gateway'),
}

model PluginClassInfo {
  alias?: string(name='alias'),
  configExample?: string(name='configExample'),
  description?: string(name='description'),
  executePriority?: int32(name='executePriority'),
  executeStage?: string(name='executeStage'),
  imageName?: string(name='imageName'),
  innerPlugin?: boolean(name='innerPlugin'),
  mode?: string(name='mode'),
  name?: string(name='name'),
  pluginClassId?: string(name='pluginClassId'),
  source?: string(name='source'),
  supportedMinGatewayVersion?: string(name='supportedMinGatewayVersion'),
  type?: string(name='type'),
  version?: string(name='version'),
  versionDescription?: string(name='versionDescription'),
  wasmLanguage?: string(name='wasmLanguage'),
  wasmUrl?: string(name='wasmUrl'),
}

model PolicyClassInfo {
  alias?: string(name='alias', description='The template alias.', example='Rate Limit'),
  attachableResourceTypes?: [ string ](name='attachableResourceTypes', description='The list of resource types that can be mounted.'),
  classId?: string(name='classId', description='The template identifier.', example='pc-cpqm0s94ckt1displ8ng'),
  configExample?: string(name='configExample', description='A configuration example.', example='{}'),
  deprecated?: boolean(name='deprecated', description='Specifies whether the policy has been deprecated.', example='false'),
  description?: string(name='description', description='The template description.', example='Limits the number of requests per unit of time'),
  direction?: string(name='direction', description='The direction of traffic on which the policy takes effect.', example='InBound'),
  enableLog?: boolean(name='enableLog', description='Specifies whether to enable logging.', example='true'),
  executePriority?: string(name='executePriority', description='The execution priority.', example='1'),
  executeStage?: string(name='executeStage', description='The execution phase.', example='POST'),
  name?: string(name='name', description='The template name.', example='ConcurrencyLimit'),
  type?: string(name='type', description='The policy type.', example='FlowControl'),
  version?: string(name='version', description='The template version.', example='1.0.0'),
}

model PolicyDetailInfo {
  classId?: string(name='classId'),
  className?: string(name='className'),
  config?: string(name='config'),
  description?: string(name='description'),
  name?: string(name='name'),
  policyId?: string(name='policyId'),
}

model PolicyInfo {
  attachments?: [
    Attachment
  ](name='attachments', description='The mount information.'),
  classAlias?: string(name='classAlias', description='The policy class alias.'),
  className?: string(name='className', description='The class name supported by the policy. Different policies support different mount points. This parameter is used in combination with AttachResourceType.

*   RateLimit: throttles traffic. Supported: HttpApi, Operation, and GatewayRoute.
*   ConcurrencyLimit: controls concurrency. Supported: HttpApi, Operation, and GatewayRoute.
*   CircuitBreaker: breaks circuits and downgrades traffic. Supported: HttpApi, Operation, and GatewayRoute.
*   HttpRewrite: rewrites HTTP traffic. Supported: HttpApi, Operation, and GatewayRoute.
*   HeaderModify: modifies headers. Supported: HttpApi, Operation, and GatewayRoute.
*   Cors: supports CORS. Supported: HttpApi, Operation, and GatewayRoute.
*   FlowCopy: replicates traffic. Supported: HttpApi, Operation, and GatewayRoute.
*   Timeout: times out requests. Supported: HttpApi, Operation, and GatewayRoute.
*   Retry: retries requests. Supported: HttpApi, Operation, and GatewayRoute.
*   IpAccessControl: implements IP address-based access control. Supported: HttpApi, Operation, GatewayRoute, Domain, and Gateway.
*   DirectResponse: mocks responses. Supported: Operation and GatewayRoute.
*   Redirect: redirects traffic. Supported: GatewayRoute.
*   Fallback: implements fallback. Supported: Operation and GatewayRoute.
*   ServiceTls: implements TLS authentication. Supported: GatewayService.
*   ServiceLb: balances loads. Supported: GatewayService.
*   ServicePortTls: implements service port TLS authentication. Supported: GatewayServicePort.
*   Waf: implements WAF protection. Supported: GatewayRoute and Gateway.
*   JWTAuth: implements global JWT authentication. Supported: Gateway.
*   OIDCAuth: implements global OIDC authentication. Supported: Gateway.
*   ExternalZAuth: implements custom authentication. Supported: Gateway.'),
  config?: string(name='config', description='The policy configurations.', example='{"enable":false}'),
  direction?: string(name='direction', description='The direction of traffic on which the policy takes effect. Valid values:

*   OutBound
*   InBound
*   Both', example='InBound'),
  executePriority?: string(name='executePriority', description='The execution priority.', example='310'),
  executeStage?: string(name='executeStage', description='The execution phase.

Valid values:

*   PluginStatistic
*   PluginAuthorization
*   PluginPre
*   PluginAuthentication
*   PluginDefault
*   PluginPost', example='PluginPost'),
  name?: string(name='name', description='The policy name.', example='test-policy'),
  policyId?: string(name='policyId', description='The policy ID.', example='p-cq7l5s5lhtgi6qasrdc0'),
  type?: string(name='type', description='The policy type.'),
}

model ResourceInfo {
  resourceId?: string(name='resourceId', description='The resource ID.', example='api-1nsu2d****'),
  resourceName?: string(name='resourceName', description='The resource name.', example='test1023'),
  resourceType?: string(name='resourceType', description='The resource type. Valid values: HttpApi, Operation, GatewayRoute, Gateway, and GatewayDomain.', example='HttpApi'),
  resourceVersion?: string(name='resourceVersion', description='The resource version.', example='1.0.0'),
}

model ResourceStatistic {
  resourceCount?: int32(name='resourceCount', description='The number of online resources.', example='10'),
  resourceType?: string(name='resourceType', description='The resource type.

Valid values:

*   HttpApi
*   GatewayRoute', example='HttpApi'),
}

model RiskCheckResults {
  checkTime?: long(name='checkTime', description='The check time', example='1234567890000'),
  gatewayId?: string(name='gatewayId', description='The gateway ID', example='gw-0364f863b1a04474911b48cd6d51d03d'),
  metadata?: {
    clusterType?: string(name='clusterType', description='The cluster type', example='Ingress'),
    replica?: int32(name='replica', description='The replica count', example='3'),
    spec?: string(name='spec', description='The specification', example='apigw.small.x1'),
    version?: string(name='version', description='The version', example='2.0.14'),
  }(name='metadata', description='The instance metadata'),
  riskDetails?: [ 
    {
      checkModule?: string(name='checkModule', description='The check module', example='BaseInfo'),
      data?: map[string]string(name='data', description='The risk detailed data'),
      description?: string(name='description', description='The risk description', example='The version is outdated'),
      isNoticeMute?: boolean(name='isNoticeMute', description='Whether to mute notifications', example='false'),
      riskCode?: string(name='riskCode', description='The risk code', example='30010010001'),
      riskLevel?: string(name='riskLevel', description='The risk level', example='HIGH'),
      riskName?: string(name='riskName', description='The risk title', example='Version Risk'),
      riskType?: string(name='riskType', description='The risk type', example='SYSTEM'),
      situation?: string(name='situation', description='The risk situation', example='Current version is 2 releases behind'),
      suggestion?: string(name='suggestion', description='The fix suggestion', example='Upgrade to the latest version'),
    }
  ](name='riskDetails', description='The risk details list'),
  riskLevel?: string(name='riskLevel', description='The risk level', example='MEDIUM'),
  score?: int32(name='score', description='The risk score', example='85'),
  snapshotTime?: long(name='snapshotTime', description='The snapshot time', example='1234567890000'),
  status?: string(name='status', description='The execution status', example='SUCCESS'),
  totalRisk?: int32(name='totalRisk', description='The total number of risks', example='1'),
}

model Service {
  addresses?: [ string ](name='addresses', description='The address details, which can be IP addresses or domain names.'),
  agentServiceConfig?: AgentServiceConfig(name='agentServiceConfig', description='The agent service configuration'),
  aiServiceConfig?: AiServiceConfig(name='aiServiceConfig', description='The AI service configurations.'),
  createTimestamp?: long(name='createTimestamp', description='The creation time (unix timestamp).', example='1725617840096'),
  expressType?: string(name='expressType', description='The express type', example='StartExecution'),
  gatewayId?: string(name='gatewayId', description='The gateway instance ID.', example='gw-xxxx'),
  groupName?: string(name='groupName', description='The service group name.', example='publich'),
  healthCheck?: ServiceHealthCheck(name='healthCheck', description='The health check configurations.'),
  healthStatus?: string(name='healthStatus', description='The health check status.

Valid values:

*   Unhealthy
*   Healthy', example='Healthy'),
  labelDetails?: [
    LabelDetail
  ](name='labelDetails', description='The label details for service version configuration'),
  name?: string(name='name', description='The service name.', example='user-service'),
  namespace?: string(name='namespace', description='The namespace of the service.', example='PUBLIC'),
  outlierEndpoints?: [ string ](name='outlierEndpoints', description='The outlier endpoints list'),
  ports?: [ 
    {
      name?: string(name='name', description='The port name.', example='user-service'),
      port?: int32(name='port', description='The port number.', example='8080'),
      protocol?: string(name='protocol', description='The protocol. Valid values: TCP and UDP.', example='TCP'),
    }
  ](name='ports', description='The list of objects containing port details.'),
  protocol?: string(name='protocol', description='The service protocol type.', example='HTTP'),
  qualifier?: string(name='qualifier', description='The function qualifier name.', example='LATEST'),
  resourceGroupId?: string(name='resourceGroupId', description='The resource group ID.', example='rg-xxx'),
  serviceId?: string(name='serviceId', description='The service unique ID.', example='svc-cr6pk4tlhtgm***'),
  sourceType?: string(name='sourceType', description='The source type.', example='MSE_NACOS'),
  unhealthyEndpoints?: [ string ](name='unhealthyEndpoints', description='The list of unhealthy endpoints.'),
  updateTimestamp?: long(name='updateTimestamp', description='The last modified time (unix timestamp).', example='1725868548440'),
  versions?: [ 
    {
      labels?: [ 
        {
          key?: string(name='key'),
          value?: string(name='value'),
        }
      ](name='labels'),
      name?: string(name='name'),
    }
  ](name='versions'),
}

model ServiceHealthCheck {
  enable?: boolean(name='enable', example='true'),
  healthyThreshold?: int32(name='healthyThreshold'),
  httpHost?: string(name='httpHost'),
  httpPath?: string(name='httpPath'),
  interval?: int32(name='interval'),
  protocol?: string(name='protocol', example='TCP'),
  timeout?: int32(name='timeout'),
  unhealthyThreshold?: int32(name='unhealthyThreshold'),
}

model ServiceLinkedRole {
  arn?: string(name='arn'),
  assumeRolePolicyDocument?: string(name='assumeRolePolicyDocument'),
  createDate?: string(name='createDate'),
  description?: string(name='description'),
  isServiceLinkedRole?: boolean(name='isServiceLinkedRole'),
  roleId?: string(name='roleId'),
  roleName?: string(name='roleName'),
  rolePrincipalName?: string(name='rolePrincipalName'),
}

model SslCertMetaInfo {
  algorithm?: string(name='algorithm', description='The algorithm.', example='RSA2048'),
  certId?: long(name='certId', description='The certificate ID.', example='1234567890'),
  certIdentifier?: string(name='certIdentifier', description='The certificate ID.', example='cert-123'),
  certName?: string(name='certName', description='The certificate name.', example='example.com'),
  commonName?: string(name='commonName', description='The name.', example='example.com'),
  domain?: string(name='domain', description='The domain name.', example='api.example.com'),
  domainMatchCert?: boolean(name='domainMatchCert', description='The certificate matching the domain name.', example='true'),
  fingerprint?: string(name='fingerprint', description='The certificate fingerprint.', example='A1:B2:C3:D4:E5:F6:78:90:AB:CD:EF:12:34:56:78:90'),
  instanceId?: string(name='instanceId', description='The instance ID.', example='i-bp1234567890'),
  isChainCompleted?: boolean(name='isChainCompleted', description='isChainCompleted', example='true'),
  issuer?: string(name='issuer', description='The certificate issuer.', example='DigiCert Inc'),
  keySize?: string(name='keySize', description='The key size.', example='2048'),
  md5?: string(name='md5', description='The md5 value.', example='A1B2C3D4E5F67890ABCDEF1234567890'),
  notAfterTimestamp?: long(name='notAfterTimestamp', description='The time when the certificate expires.', example='1234567890000'),
  notBeforeTimestamp?: long(name='notBeforeTimestamp', description='The time when the certificate starts to take effect.', example='1234567890000'),
  sans?: string(name='sans', description='sans', example='*.example.com,api.example.com,www.example.com'),
  serialNo?: string(name='serialNo', description='The serial number.', example='03:A1:B2:C3:D4:E5:F6:78:90:AB:CD:EF:12:34:56:78:90'),
  sha2?: string(name='sha2', description='The sha2 value.', example='A1B2C3D4E5F67890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890'),
  signAlgorithm?: string(name='signAlgorithm', description='The signature algorithm.', example='sha256WithRSAEncryption'),
}

model SubDomainInfo {
  domainId?: string(name='domainId', description='The domain name ID.', example='d-cpudb0llhtgl2djvq2sg'),
  name?: string(name='name', description='The domain name.', example='abc.com'),
  networkType?: string(name='networkType', description='The network type. Valid values:

Valid values:

*   Intranet
*   Internet', example='Intranet'),
  protocol?: string(name='protocol', description='The protocol.

Valid values:

*   HTTPS
*   HTTP', example='HTTP'),
}

model TlsCipherSuitesConfig {
  configType?: string(name='configType', description='The configuration type.', example='Default'),
  tlsCipherSuite?: [ 
    {
      name?: string(name='name', description='The suite name.', example='ECDHE-ECDSA-AES256-GCM-SHA384'),
      supportVersions?: [ string ](name='supportVersions', description='The supported versions.'),
    }
  ](name='tlsCipherSuite', description='tlsCipherSuite'),
}

model ValidationOptions {
  skipVerifyAIChatCompletion?: boolean(name='skipVerifyAIChatCompletion'),
}

model HttpApiApiInfoDeployCntMapValue = {
  deployedCnt?: long(name='deployedCnt', description='deployedCnt', example='3'),
  cnt?: long(name='Cnt', description='Cnt', example='5'),
}

model AddGatewaySecurityGroupRuleRequest {
  description?: string(name='description', description='The description of security group rule N.', example='ProductCenterSG'),
  portRanges?: [ string ](name='portRanges', description='The port ranges.'),
  securityGroupId?: string(name='securityGroupId', description='The security group ID.', example='sg-wz929kxhcdp****'),
}

model AddGatewaySecurityGroupRuleResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='2A6E90D5-A711-54F4-A489-E33C2021EDDF'),
}

model AddGatewaySecurityGroupRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddGatewaySecurityGroupRuleResponseBody(name='body'),
}

/**
 * @summary Adds a security group that authorizes an instance to access services.
 *
 * @param request AddGatewaySecurityGroupRuleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddGatewaySecurityGroupRuleResponse
 */
@context("addGatewaySecurityGroupRuleWithContext")
async function addGatewaySecurityGroupRuleWithOptions(gatewayId: string, request: AddGatewaySecurityGroupRuleRequest, headers: map[string]string, runtime: $RuntimeOptions): AddGatewaySecurityGroupRuleResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.portRanges)) {
    body['portRanges'] = request.portRanges;
  }
  if (!$isNull(request.securityGroupId)) {
    body['securityGroupId'] = request.securityGroupId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'AddGatewaySecurityGroupRule',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/gateways/${$URL.percentEncode(gatewayId)}/security-group-rules`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds a security group that authorizes an instance to access services.
 *
 * @param request AddGatewaySecurityGroupRuleRequest
 * @return AddGatewaySecurityGroupRuleResponse
 */
async function addGatewaySecurityGroupRule(gatewayId: string, request: AddGatewaySecurityGroupRuleRequest): AddGatewaySecurityGroupRuleResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return addGatewaySecurityGroupRuleWithOptions(gatewayId, request, headers, runtime);
}

model BatchDeleteConsumerAuthorizationRuleRequest {
  consumerAuthorizationRuleIds?: string(name='consumerAuthorizationRuleIds', description='The rule IDs.', example='car-cus2d1em1hkg7732kuk0'),
}

model BatchDeleteConsumerAuthorizationRuleResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The returned message.', example='success'),
  requestId?: string(name='requestId', description='Id of the request', example='464F9EA0-1052-51BD-8187-D292AA2D8D24'),
}

model BatchDeleteConsumerAuthorizationRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteConsumerAuthorizationRuleResponseBody(name='body'),
}

/**
 * @summary Removes consumer authentication rules.
 *
 * @param request BatchDeleteConsumerAuthorizationRuleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDeleteConsumerAuthorizationRuleResponse
 */
@context("batchDeleteConsumerAuthorizationRuleWithContext")
async function batchDeleteConsumerAuthorizationRuleWithOptions(request: BatchDeleteConsumerAuthorizationRuleRequest, headers: map[string]string, runtime: $RuntimeOptions): BatchDeleteConsumerAuthorizationRuleResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.consumerAuthorizationRuleIds)) {
    query['consumerAuthorizationRuleIds'] = request.consumerAuthorizationRuleIds;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchDeleteConsumerAuthorizationRule',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/authorization-rules`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Removes consumer authentication rules.
 *
 * @param request BatchDeleteConsumerAuthorizationRuleRequest
 * @return BatchDeleteConsumerAuthorizationRuleResponse
 */
async function batchDeleteConsumerAuthorizationRule(request: BatchDeleteConsumerAuthorizationRuleRequest): BatchDeleteConsumerAuthorizationRuleResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return batchDeleteConsumerAuthorizationRuleWithOptions(request, headers, runtime);
}

model ChangeResourceGroupRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='Target resource group ID.', example='rg-aekzdrfx2xdnaja'),
  resourceId?: string(name='ResourceId', description='Resource ID', example='gw-ct4i14um1hkn0tpqfae0'),
  resourceType?: string(name='ResourceType', description='Resource type', example='gateway'),
  service?: string(name='Service', description='Service name, fixed value apig', example='apig'),
}

model ChangeResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='Request ID.', example='59F86F37-787A-52DB-9475-DB5A255517F0'),
}

model ChangeResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeResourceGroupResponseBody(name='body'),
}

/**
 * @summary Moves a resource from one resource group to another.
 *
 * @param request ChangeResourceGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeResourceGroupResponse
 */
@context("changeResourceGroupWithContext")
async function changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, headers: map[string]string, runtime: $RuntimeOptions): ChangeResourceGroupResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.service)) {
    query['Service'] = request.service;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ChangeResourceGroup',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/move-resource-group`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Moves a resource from one resource group to another.
 *
 * @param request ChangeResourceGroupRequest
 * @return ChangeResourceGroupResponse
 */
async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return changeResourceGroupWithOptions(request, headers, runtime);
}

model CreateAndAttachPolicyRequest {
  attachResourceIds?: [ string ](name='attachResourceIds', description='The IDs of the resources to be associated with the policy.

This parameter is required.'),
  attachResourceType?: string(name='attachResourceType', description='The supported resource type. Valid values:

*   HttpApi: an HTTP API
*   Operation: an operation in an HTTP API
*   GatewayRoute: a route
*   GatewayService: a service
*   GatewayServicePort: a service port
*   Domain: a domain name
*   Gateway: an instance

This parameter is required.', example='HttpApi'),
  className?: string(name='className', description='The class name supported by the policy. Different policies support different resources. This parameter is used in combination with AttachResourceType.

*   RateLimit: throttles traffic. Supported: HttpApi, Operation, and GatewayRoute.
*   ConcurrencyLimit: controls concurrency. Supported: HttpApi, Operation, and GatewayRoute.
*   CircuitBreaker: breaks circuits and downgrades traffic. Supported: HttpApi, Operation, and GatewayRoute.
*   HttpRewrite: rewrites HTTP traffic. Supported: HttpApi, Operation, and GatewayRoute.
*   HeaderModify: modifies headers. Supported: HttpApi, Operation, and GatewayRoute.
*   Cors: supports CORS. Supported: HttpApi, Operation, and GatewayRoute.
*   FlowCopy: replicates traffic. Supported: HttpApi, Operation, and GatewayRoute.
*   Timeout: times out requests. Supported: HttpApi, Operation, and GatewayRoute.
*   Retry: retries requests. Supported: HttpApi, Operation, and GatewayRoute.
*   IpAccessControl: implements IP address-based access control. Supported: HttpApi, Operation, GatewayRoute, Domain, and Gateway.
*   DirectResponse: mocks responses. Supported: Operation and GatewayRoute.
*   Redirect: redirects traffic. Supported: GatewayRoute.
*   Fallback: implements fallback. Supported: Operation and GatewayRoute.
*   ServiceTls: implements TLS authentication. Supported: GatewayService.
*   ServiceLb: balances loads. Supported: GatewayService.
*   ServicePortTls: implements service port TLS authentication. Supported: GatewayServicePort.
*   Waf: implements WAF protection. Supported: GatewayRoute and Gateway.
*   JWTAuth: implements global JWT authentication. Supported: Gateway.
*   OIDCAuth: implements global OIDC authentication. Supported: Gateway.
*   ExternalZAuth: implements custom authentication. Supported: Gateway.

This parameter is required.', example='IpAccessControl'),
  config?: string(name='config', description='The policy configurations.

This parameter is required.', example='{\\\\"enable\\\\":false}'),
  description?: string(name='description', description='The policy description.', example='This is the policy description.'),
  environmentId?: string(name='environmentId', description='The environment ID.', example='env-cq7l5s5lhtgi6qasrdc0'),
  gatewayId?: string(name='gatewayId', description='The instance ID.', example='gw-cq7l5s5lhtgi6qasrdc0'),
  name?: string(name='name', description='The policy name.', example='test'),
}

model CreateAndAttachPolicyResponseBody = {
  code?: string(name='code', description='The status code returned.', example='Ok'),
  data?: {
    attachment?: Attachment(name='attachment', description='The association information of the policy.'),
    policyId?: string(name='policyId', description='The policy ID.', example='p-cq7l5s5lhtgi6qasrdc0'),
  }(name='data', description='The returned data.'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID, which is used to trace the call link.', example='585657D2-1C20-5B8A-AF17-D727C6490BE4'),
}

model CreateAndAttachPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAndAttachPolicyResponseBody(name='body'),
}

/**
 * @summary Creates and associates a policy.
 *
 * @param request CreateAndAttachPolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAndAttachPolicyResponse
 */
@context("createAndAttachPolicyWithContext")
async function createAndAttachPolicyWithOptions(request: CreateAndAttachPolicyRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateAndAttachPolicyResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.attachResourceIds)) {
    body['attachResourceIds'] = request.attachResourceIds;
  }
  if (!$isNull(request.attachResourceType)) {
    body['attachResourceType'] = request.attachResourceType;
  }
  if (!$isNull(request.className)) {
    body['className'] = request.className;
  }
  if (!$isNull(request.config)) {
    body['config'] = request.config;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.environmentId)) {
    body['environmentId'] = request.environmentId;
  }
  if (!$isNull(request.gatewayId)) {
    body['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateAndAttachPolicy',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/policies`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates and associates a policy.
 *
 * @param request CreateAndAttachPolicyRequest
 * @return CreateAndAttachPolicyResponse
 */
async function createAndAttachPolicy(request: CreateAndAttachPolicyRequest): CreateAndAttachPolicyResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createAndAttachPolicyWithOptions(request, headers, runtime);
}

model CreateConsumerRequest {
  akSkIdentityConfigs?: [
    AkSkIdentityConfig
  ](name='akSkIdentityConfigs', description='The list of AK/SK identity configurations.'),
  apikeyIdentityConfig?: ApiKeyIdentityConfig(name='apikeyIdentityConfig', description='The configuration for the API key authentication method.'),
  description?: string(name='description', description='The description of the consumer.', example='consumer for test'),
  enable?: boolean(name='enable', description='Indicates if enabled.', example='false'),
  gatewayType?: string(name='gatewayType', description='The type of the gateway.', example='API'),
  jwtIdentityConfig?: JwtIdentityConfig(name='jwtIdentityConfig', description='The configuration of the JWT identity.'),
  name?: string(name='name', description='The name of the consumer.', example='test'),
}

model CreateConsumerResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    consumerId?: string(name='consumerId', description='The consumer ID.', example='cs-cvnjramm1hks1r3fmmug'),
  }(name='data', description='The response payload.'),
  message?: string(name='message', description='The status message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='479AE38F-A574-52F7-87EA-E91199999F9E'),
}

model CreateConsumerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateConsumerResponseBody(name='body'),
}

/**
 * @summary Creates a consumer.
 *
 * @param request CreateConsumerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConsumerResponse
 */
@context("createConsumerWithContext")
async function createConsumerWithOptions(request: CreateConsumerRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateConsumerResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.akSkIdentityConfigs)) {
    body['akSkIdentityConfigs'] = request.akSkIdentityConfigs;
  }
  if (!$isNull(request.apikeyIdentityConfig)) {
    body['apikeyIdentityConfig'] = request.apikeyIdentityConfig;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.enable)) {
    body['enable'] = request.enable;
  }
  if (!$isNull(request.gatewayType)) {
    body['gatewayType'] = request.gatewayType;
  }
  if (!$isNull(request.jwtIdentityConfig)) {
    body['jwtIdentityConfig'] = request.jwtIdentityConfig;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateConsumer',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/consumers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a consumer.
 *
 * @param request CreateConsumerRequest
 * @return CreateConsumerResponse
 */
async function createConsumer(request: CreateConsumerRequest): CreateConsumerResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createConsumerWithOptions(request, headers, runtime);
}

model CreateConsumerAuthorizationRuleRequest {
  authorizationResourceInfos?: [
    AuthorizationResourceInfo
  ](name='authorizationResourceInfos', description='The list of resource authorization information.'),
  expireMode?: string(name='expireMode', description='The expiry mode. Valid values: LongTerm and ShortTerm.', example='LongTerm'),
  expireTimestamp?: long(name='expireTimestamp', description='The expiration time.', example='1750852089975'),
  parentResourceType?: string(name='parentResourceType', description='The type of the parent resource.', example='API'),
  resourceType?: string(name='resourceType', description='The resource type,', example='API'),
}

model CreateConsumerAuthorizationRuleResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    consumerAuthorizationRuleId?: string(name='consumerAuthorizationRuleId', description='Filters the list of operations based on a specific consumer authorization rule ID. Only authorized operations are returned in the response.', example='car-d06p196m1hkg9ukum5pg'),
  }(name='data', description='The response payload.'),
  message?: string(name='message', description='The status message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='6CC83C32-3B5A-57EE-9AFE-D0D51822C7BA'),
}

model CreateConsumerAuthorizationRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateConsumerAuthorizationRuleResponseBody(name='body'),
}

/**
 * @summary Creates a consumer authorization rule.
 *
 * @param request CreateConsumerAuthorizationRuleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConsumerAuthorizationRuleResponse
 */
@context("createConsumerAuthorizationRuleWithContext")
async function createConsumerAuthorizationRuleWithOptions(consumerId: string, request: CreateConsumerAuthorizationRuleRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateConsumerAuthorizationRuleResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.authorizationResourceInfos)) {
    body['authorizationResourceInfos'] = request.authorizationResourceInfos;
  }
  if (!$isNull(request.expireMode)) {
    body['expireMode'] = request.expireMode;
  }
  if (!$isNull(request.expireTimestamp)) {
    body['expireTimestamp'] = request.expireTimestamp;
  }
  if (!$isNull(request.parentResourceType)) {
    body['parentResourceType'] = request.parentResourceType;
  }
  if (!$isNull(request.resourceType)) {
    body['resourceType'] = request.resourceType;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateConsumerAuthorizationRule',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/consumers/${$URL.percentEncode(consumerId)}/authorization-rules`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a consumer authorization rule.
 *
 * @param request CreateConsumerAuthorizationRuleRequest
 * @return CreateConsumerAuthorizationRuleResponse
 */
async function createConsumerAuthorizationRule(consumerId: string, request: CreateConsumerAuthorizationRuleRequest): CreateConsumerAuthorizationRuleResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createConsumerAuthorizationRuleWithOptions(consumerId, request, headers, runtime);
}

model CreateConsumerAuthorizationRulesRequest {
  authorizationRules?: [ 
    {
      consumerId?: string(name='consumerId', description='The consumer ID.', example='cs-cu08olem1hkokaut34i0'),
      expireMode?: string(name='expireMode', description='The expiration mode. Valid values: LongTerm and ShortTerm.', example='LongTerm'),
      expireTimestamp?: long(name='expireTimestamp', description='The expiration timestamp.', example='174116222x'),
      resourceIdentifier?: {
        environmentId?: string(name='environmentId', description='The environment ID.', example='env-cti17hem1hktoruj98ug'),
        parentResourceId?: string(name='parentResourceId', description='Parent resource ID', example='api-******'),
        resourceId?: string(name='resourceId', description='The resource ID.', example='ha-cn-li942gy8p03'),
        resources?: [ string ](name='resources', description='List of resources'),
      }(name='resourceIdentifier', description='The resource identifier, which is provided to non-standard code sources for space reuse.'),
      resourceType?: string(name='resourceType', description='The resource type.', example='HttpApiRoute'),
    }
  ](name='authorizationRules', description='The consumer authentication rules to be created.'),
}

model CreateConsumerAuthorizationRulesResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    consumerAuthorizationRuleIds?: [ string ](name='consumerAuthorizationRuleIds', description='The authentication rule IDs.'),
  }(name='data', description='The response parameters.'),
  message?: string(name='message', description='The returned message.', example='success'),
  requestId?: string(name='requestId', description='Id of the request', example='3ACFC7A7-45A9-58CF-B2D5-765B60254695'),
}

model CreateConsumerAuthorizationRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateConsumerAuthorizationRulesResponseBody(name='body'),
}

/**
 * @summary Creates a consumer authentication rule.
 *
 * @param request CreateConsumerAuthorizationRulesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConsumerAuthorizationRulesResponse
 */
@context("createConsumerAuthorizationRulesWithContext")
async function createConsumerAuthorizationRulesWithOptions(request: CreateConsumerAuthorizationRulesRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateConsumerAuthorizationRulesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.authorizationRules)) {
    body['authorizationRules'] = request.authorizationRules;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateConsumerAuthorizationRules',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/authorization-rules`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a consumer authentication rule.
 *
 * @param request CreateConsumerAuthorizationRulesRequest
 * @return CreateConsumerAuthorizationRulesResponse
 */
async function createConsumerAuthorizationRules(request: CreateConsumerAuthorizationRulesRequest): CreateConsumerAuthorizationRulesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createConsumerAuthorizationRulesWithOptions(request, headers, runtime);
}

model CreateDomainRequest {
  caCertIdentifier?: string(name='caCertIdentifier', description='The CA certificate ID.', example='1ef1da5f-38ed-69b3-****-037781890265'),
  certIdentifier?: string(name='certIdentifier', description='The certificate identifier.', example='1ef1da5f-38ed-69b3-****-037781890265'),
  clientCACert?: string(name='clientCACert', description='The client CA certificate content.', example='-----BEGIN CERTIFICATE-----
MIIFBTCCAu2gAwIBAgIUORLpYPGSFD1YOP6PMbE7Wd/mpTQwDQYJKoZIhvcNAQEL
BQAwE************************************************2VwVOJ2gqX3
YuGaxvIbDy0iQJ1GMerPRyzJTeVEtdIKT29u0PdFRr4KZWom35qX7G4=
-----END CERTIFICATE-----'),
  forceHttps?: boolean(name='forceHttps', description='Specifies whether to enable forced HTTP to HTTPS redirection.', example='false'),
  gatewayType?: string(name='gatewayType', description='The gateway type.

Valid values:

*   AI
*   API', example='API'),
  http2Option?: string(name='http2Option', description='HTTP/2 configuration options.

Valid values:

*   GlobalConfig
*   Close
*   Open', example='Open'),
  mTLSEnabled?: boolean(name='mTLSEnabled', description='Specifies whether to enable mutual Transport Layer Security (mTLS) authentication.'),
  name?: string(name='name', description='The domain name.

This parameter is required.', example='abc.com'),
  protocol?: string(name='protocol', description='The protocol type supported by the domain name.

*   HTTP: HTTP only
*   HTTPS: HTTPS only

This parameter is required.', example='HTTP'),
  resourceGroupId?: string(name='resourceGroupId', description='The [resource group ID](https://help.aliyun.com/document_detail/151181.html).', example='rg-aekzoiafjtr7zyq'),
  tlsCipherSuitesConfig?: TlsCipherSuitesConfig(name='tlsCipherSuitesConfig', description='The cipher suite configuration.'),
  tlsMax?: string(name='tlsMax', description='The maximum TLS protocol version (up to TLS 1.3).', example='TLS1.3'),
  tlsMin?: string(name='tlsMin', description='The minimum TLS protocol version (minimum TLS 1.0).', example='TLS1.0'),
}

model CreateDomainResponseBody = {
  code?: string(name='code', description='The status code returned.', example='Ok'),
  data?: {
    domainId?: string(name='domainId', description='The ID of the domain name.', example='d-cpu1aullhtgkidg7sa4g'),
  }(name='data', description='The response data.'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID, which is used to trace the API call link.', example='0C2D1C68-0D93-5561-8EE6-FDB7BF067A30'),
}

model CreateDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDomainResponseBody(name='body'),
}

/**
 * @summary Creates a domain name.
 *
 * @description Create Domain.
 *
 * @param request CreateDomainRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDomainResponse
 */
@context("createDomainWithContext")
async function createDomainWithOptions(request: CreateDomainRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateDomainResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.caCertIdentifier)) {
    body['caCertIdentifier'] = request.caCertIdentifier;
  }
  if (!$isNull(request.certIdentifier)) {
    body['certIdentifier'] = request.certIdentifier;
  }
  if (!$isNull(request.clientCACert)) {
    body['clientCACert'] = request.clientCACert;
  }
  if (!$isNull(request.forceHttps)) {
    body['forceHttps'] = request.forceHttps;
  }
  if (!$isNull(request.gatewayType)) {
    body['gatewayType'] = request.gatewayType;
  }
  if (!$isNull(request.http2Option)) {
    body['http2Option'] = request.http2Option;
  }
  if (!$isNull(request.mTLSEnabled)) {
    body['mTLSEnabled'] = request.mTLSEnabled;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }
  if (!$isNull(request.protocol)) {
    body['protocol'] = request.protocol;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.tlsCipherSuitesConfig)) {
    body['tlsCipherSuitesConfig'] = request.tlsCipherSuitesConfig;
  }
  if (!$isNull(request.tlsMax)) {
    body['tlsMax'] = request.tlsMax;
  }
  if (!$isNull(request.tlsMin)) {
    body['tlsMin'] = request.tlsMin;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateDomain',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/domains`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a domain name.
 *
 * @description Create Domain.
 *
 * @param request CreateDomainRequest
 * @return CreateDomainResponse
 */
async function createDomain(request: CreateDomainRequest): CreateDomainResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createDomainWithOptions(request, headers, runtime);
}

model CreateEnvironmentRequest {
  alias?: string(name='alias', description='The request body.

This parameter is required.', example='The environment name.'),
  description?: string(name='description', description='The environment alias.', example='Test environment'),
  gatewayId?: string(name='gatewayId', description='The environment description, such as its purpose and owner.

This parameter is required.', example='gw-cq7l5s5lhtgi6qasrdc0'),
  name?: string(name='name', description='Create environment.

This parameter is required.', example='test'),
  resourceGroupId?: string(name='resourceGroupId', description='Testing environment for xx project of xxx', example='rg-ahr5uil8raz0rq3b'),
}

model CreateEnvironmentResponseBody = {
  code?: string(name='code', description='The resource group ID.', example='Ok'),
  data?: {
    environmentId?: string(name='environmentId', description='The request ID, which is used to trace the call link.', example='env-cq7l5s5lhtgi6qasrdc0'),
  }(name='data', description='Schema of Response'),
  message?: string(name='message', description='rg-acfmycs5expl7oq', example='success'),
  requestId?: string(name='requestId', description='The instance ID.', example='3C3B9A12-3868-5EB9-8BEA-F99E03DD125C'),
}

model CreateEnvironmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEnvironmentResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI CreateEnvironment is deprecated
 *
 * @summary Creates an environment.
 *
 * @param request CreateEnvironmentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEnvironmentResponse
 */
// Deprecated
@context("createEnvironmentWithContext")
async function createEnvironmentWithOptions(request: CreateEnvironmentRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateEnvironmentResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.alias)) {
    body['alias'] = request.alias;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.gatewayId)) {
    body['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateEnvironment',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/environments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @deprecated OpenAPI CreateEnvironment is deprecated
 *
 * @summary Creates an environment.
 *
 * @param request CreateEnvironmentRequest
 * @return CreateEnvironmentResponse
 */
// Deprecated
async function createEnvironment(request: CreateEnvironmentRequest): CreateEnvironmentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createEnvironmentWithOptions(request, headers, runtime);
}

model CreateGatewayRequest {
  chargeType?: string(name='chargeType', description='The logging configurations.', example='POSTPAY'),
  gatewayEdition?: string(name='gatewayEdition', example='Professional'),
  gatewayType?: string(name='gatewayType', description='The ID of the resource group.', example='API'),
  logConfig?: {
    sls?: {
      enable?: boolean(name='enable', example='false'),
    }(name='sls'),
  }(name='logConfig'),
  name?: string(name='name', description='The ID of the vSwitch.', example='test-ceshi'),
  networkAccessConfig?: {
    type?: string(name='type', description='-', example='Internet'),
  }(name='networkAccessConfig', description='The gateway edition.'),
  resourceGroupId?: string(name='resourceGroupId', example='rg-ahr5uil8raz0rq3b'),
  spec?: string(name='spec', description='The tag key.', example='apigw.dev.x2'),
  tag?: [ 
    {
      key?: string(name='key', example='key'),
      value?: string(name='value', example='value'),
    }
  ](name='tag'),
  vpcId?: string(name='vpcId', description='The tag value.', example='vpc-zm0x16tomfiat1mk9f6rs'),
  zoneConfig?: {
    selectOption?: string(name='selectOption', description='The response payload.', example='Manual'),
    vSwitchId?: string(name='vSwitchId', example='vsw-xxx'),
    zones?: [ 
      {
        vSwitchId?: string(name='vSwitchId', example='vsw-xx'),
        zoneId?: string(name='zoneId', example='cn-wulanchabu-a'),
      }
    ](name='zones'),
  }(name='zoneConfig', description='The status message.'),
}

model CreateGatewayResponseBody = {
  code?: string(name='code', example='Ok'),
  data?: {
    gatewayId?: string(name='gatewayId', example='gw-cq2vundlhtg***'),
  }(name='data'),
  message?: string(name='message', example='success'),
  requestId?: string(name='requestId', description='Id of the request', example='9CDE3E69-69C2-5402-83AD-ACA80B1AF35B'),
}

model CreateGatewayResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateGatewayResponseBody(name='body'),
}

/**
 * @summary Creates a cloud-native gateway.
 *
 * @param request CreateGatewayRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateGatewayResponse
 */
@context("createGatewayWithContext")
async function createGatewayWithOptions(request: CreateGatewayRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateGatewayResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.chargeType)) {
    body['chargeType'] = request.chargeType;
  }
  if (!$isNull(request.gatewayEdition)) {
    body['gatewayEdition'] = request.gatewayEdition;
  }
  if (!$isNull(request.gatewayType)) {
    body['gatewayType'] = request.gatewayType;
  }
  if (!$isNull(request.logConfig)) {
    body['logConfig'] = request.logConfig;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }
  if (!$isNull(request.networkAccessConfig)) {
    body['networkAccessConfig'] = request.networkAccessConfig;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.spec)) {
    body['spec'] = request.spec;
  }
  if (!$isNull(request.tag)) {
    body['tag'] = request.tag;
  }
  if (!$isNull(request.vpcId)) {
    body['vpcId'] = request.vpcId;
  }
  if (!$isNull(request.zoneConfig)) {
    body['zoneConfig'] = request.zoneConfig;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateGateway',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/gateways`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a cloud-native gateway.
 *
 * @param request CreateGatewayRequest
 * @return CreateGatewayResponse
 */
async function createGateway(request: CreateGatewayRequest): CreateGatewayResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createGatewayWithOptions(request, headers, runtime);
}

model CreateHttpApiRequest {
  agentProtocols?: [ string ](name='agentProtocols', description='Agent protocols'),
  aiProtocols?: [ string ](name='aiProtocols', description='$.parameters[0].schema.properties.authConfig.enumValueTitles'),
  authConfig?: AuthConfig(name='authConfig', description='The request parameters for API creation.'),
  basePath?: string(name='basePath', description='$.parameters[0].schema.properties.deployConfigs.items.example', example='/v1'),
  belongGatewayId?: string(name='belongGatewayId'),
  deployConfigs?: [
    HttpApiDeployConfig
  ](name='deployConfigs', description='$.parameters[0].schema.example'),
  description?: string(name='description', description='$.parameters[0].schema.properties.aiProtocols.items.description', example='$.parameters[0].schema.properties.aiProtocols.items.example'),
  dryRun?: boolean(name='dryRun', deprecated=true),
  enableAuth?: boolean(name='enableAuth', description='Create an API of HTTP type', example='true'),
  firstByteTimeout?: int32(name='firstByteTimeout', description='First byte timeout', example='30'),
  ingressConfig?: {
    clusterId?: string(name='clusterId', description='Cluster ID.', example='k7v5eobfzttudni2pw***'),
    environmentId?: string(name='environmentId', description='$.parameters[0].schema.properties.deployConfigs.enumValueTitles', example='env-cq146allhtgk***'),
    ingressClass?: string(name='ingressClass', description='$.parameters[0].schema.properties.enableAuth.example', example='mse'),
    overrideIngressIp?: boolean(name='overrideIngressIp', description='$.parameters[0].schema.properties.authConfig.description', example='false'),
    sourceId?: string(name='sourceId', description='$.parameters[0].schema.properties.enableAuth.description', example='src-crdddallhtgtr***', deprecated=true),
    watchNamespace?: string(name='watchNamespace', description='$.parameters[0].schema.properties.enableAuth.enumValueTitles', example='default'),
  }(name='ingressConfig', description='$.parameters[0].schema.properties.deployConfigs.example'),
  modelCategory?: string(name='modelCategory', description='Model category', example='llm/text-to-image'),
  name?: string(name='name', description='$.parameters[0].schema.example

This parameter is required.', example='test-api'),
  protocols?: [ string ](name='protocols', description='$.parameters[0].schema.properties.aiProtocols.description'),
  removeBasePathOnForward?: boolean(name='removeBasePathOnForward', description='Whether to remove base path when forwarding', example='true'),
  resourceGroupId?: string(name='resourceGroupId', description='$.parameters[0].schema.properties.authConfig.example', example='rg-xxx'),
  strategy?: string(name='strategy'),
  type?: string(name='type', description='$.parameters[0].schema.properties.deployConfigs.description', example='Http'),
  versionConfig?: HttpApiVersionConfig(name='versionConfig', description='$.parameters[0].schema.properties.deployConfigs.items.enumValueTitles'),
}

model CreateHttpApiResponseBody = {
  code?: string(name='code', description='API for testing', example='Ok'),
  data?: {
    httpApiId?: string(name='httpApiId', description='HTTP API ID。', example='api-xxx'),
    name?: string(name='name', description='The API base path, which must start with a forward slash (/).', example='test-api'),
  }(name='data', description='A protocol.'),
  message?: string(name='message', description='The protocol list for API access.', example='success'),
  requestId?: string(name='requestId', description='The API description.', example='A1994B10-C6A8-58FA-8347-6A08B0D4EFDE'),
}

model CreateHttpApiResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateHttpApiResponseBody(name='body'),
}

/**
 * @summary Creates an HTTP API.
 *
 * @param request CreateHttpApiRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHttpApiResponse
 */
@context("createHttpApiWithContext")
async function createHttpApiWithOptions(request: CreateHttpApiRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateHttpApiResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.agentProtocols)) {
    body['agentProtocols'] = request.agentProtocols;
  }
  if (!$isNull(request.aiProtocols)) {
    body['aiProtocols'] = request.aiProtocols;
  }
  if (!$isNull(request.authConfig)) {
    body['authConfig'] = request.authConfig;
  }
  if (!$isNull(request.basePath)) {
    body['basePath'] = request.basePath;
  }
  if (!$isNull(request.belongGatewayId)) {
    body['belongGatewayId'] = request.belongGatewayId;
  }
  if (!$isNull(request.deployConfigs)) {
    body['deployConfigs'] = request.deployConfigs;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.dryRun)) {
    body['dryRun'] = request.dryRun;
  }
  if (!$isNull(request.enableAuth)) {
    body['enableAuth'] = request.enableAuth;
  }
  if (!$isNull(request.firstByteTimeout)) {
    body['firstByteTimeout'] = request.firstByteTimeout;
  }
  if (!$isNull(request.ingressConfig)) {
    body['ingressConfig'] = request.ingressConfig;
  }
  if (!$isNull(request.modelCategory)) {
    body['modelCategory'] = request.modelCategory;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }
  if (!$isNull(request.protocols)) {
    body['protocols'] = request.protocols;
  }
  if (!$isNull(request.removeBasePathOnForward)) {
    body['removeBasePathOnForward'] = request.removeBasePathOnForward;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.strategy)) {
    body['strategy'] = request.strategy;
  }
  if (!$isNull(request.type)) {
    body['type'] = request.type;
  }
  if (!$isNull(request.versionConfig)) {
    body['versionConfig'] = request.versionConfig;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateHttpApi',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an HTTP API.
 *
 * @param request CreateHttpApiRequest
 * @return CreateHttpApiResponse
 */
async function createHttpApi(request: CreateHttpApiRequest): CreateHttpApiResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createHttpApiWithOptions(request, headers, runtime);
}

model CreateHttpApiOperationRequest {
  operations?: [
    HttpApiOperation
  ](name='operations', description='The operation definitions.'),
}

model CreateHttpApiOperationResponseBody = {
  code?: string(name='code', description='Response status code.', example='Ok'),
  data?: {
    operations?: [ 
      {
        operationId?: string(name='operationId', description='Operation ID.', example='op-xxx'),
      }
    ](name='operations', description='Operation information.'),
  }(name='data', description='Operation information.'),
  message?: string(name='message', description='Response message.', example='success'),
  requestId?: string(name='requestId', description='Request ID.', example='393E2630-DBE7-5221-AB35-9E740675491A'),
}

model CreateHttpApiOperationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateHttpApiOperationResponseBody(name='body'),
}

/**
 * @summary Create an Operation for HTTP API
 *
 * @param request CreateHttpApiOperationRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHttpApiOperationResponse
 */
@context("createHttpApiOperationWithContext")
async function createHttpApiOperationWithOptions(httpApiId: string, request: CreateHttpApiOperationRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateHttpApiOperationResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.operations)) {
    body['operations'] = request.operations;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateHttpApiOperation',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis/${$URL.percentEncode(httpApiId)}/operations`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create an Operation for HTTP API
 *
 * @param request CreateHttpApiOperationRequest
 * @return CreateHttpApiOperationResponse
 */
async function createHttpApiOperation(httpApiId: string, request: CreateHttpApiOperationRequest): CreateHttpApiOperationResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createHttpApiOperationWithOptions(httpApiId, request, headers, runtime);
}

model CreateHttpApiRouteRequest {
  backendConfig?: {
    scene?: string(name='scene', description='The backend service scenario. Valid values:

*   SingleService
*   MultiServiceByRatio
*   Mock
*   Redirect', example='SingleService'),
    services?: [ 
      {
        port?: int32(name='port', description='The service port (omit for dynamic ports).', example='8080'),
        protocol?: string(name='protocol', description='The service protocol. Valid values:

*   HTTP
*   HTTPS', example='HTTP'),
        serviceId?: string(name='serviceId', description='The service ID.', example='svc-crbgq0dlhtgr***'),
        version?: string(name='version', description='The service version (valid only in tag-based scenarios).', example='v1'),
        weight?: int32(name='weight', description='The traffic weight percentage.', example='49'),
      }
    ](name='services', description='The list of backend services.'),
  }(name='backendConfig', description='The backend service configurations for the route.'),
  deployConfigs?: [
    HttpApiDeployConfig
  ](name='deployConfigs', description='deployConfigs'),
  description?: string(name='description', description='The route description.', example='User logon route'),
  domainIds?: [ string ](name='domainIds', description='The list of domain IDs.'),
  environmentId?: string(name='environmentId', description='The environment ID.', example='env-cpqnr6tlhtgubcv***'),
  match?: HttpRouteMatch(name='match', description='The route match rule.'),
  mcpRouteConfig?: {
    exposedUriPath?: string(name='exposedUriPath', description='The exposed URI path', example='/v1/chat/completions'),
    mcpStatisticsEnable?: boolean(name='mcpStatisticsEnable', description='mcpStatisticsEnable', example='false'),
    protocol?: string(name='protocol', description='The MCP protocol', example='HTTP,HTTPS'),
  }(name='mcpRouteConfig', description='The MCP route configuration'),
  name?: string(name='name', description='The route name.', example='login'),
  policyConfigs?: [
    HttpApiPolicyConfigs
  ](name='policyConfigs', description='The route-level policy configurations'),
}

model CreateHttpApiRouteResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    routeId?: string(name='routeId', description='The route ID.', example='hr-cr82undlhtgrlej***'),
  }(name='data', description='The response data.'),
  message?: string(name='message', description='The returned message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='3ACFC7A7-45A9-58CF-B2D5-765B60254695'),
}

model CreateHttpApiRouteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateHttpApiRouteResponseBody(name='body'),
}

/**
 * @summary Creates a route for an HTTP API.
 *
 * @param request CreateHttpApiRouteRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHttpApiRouteResponse
 */
@context("createHttpApiRouteWithContext")
async function createHttpApiRouteWithOptions(httpApiId: string, request: CreateHttpApiRouteRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateHttpApiRouteResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.backendConfig)) {
    body['backendConfig'] = request.backendConfig;
  }
  if (!$isNull(request.deployConfigs)) {
    body['deployConfigs'] = request.deployConfigs;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.domainIds)) {
    body['domainIds'] = request.domainIds;
  }
  if (!$isNull(request.environmentId)) {
    body['environmentId'] = request.environmentId;
  }
  if (!$isNull(request.match)) {
    body['match'] = request.match;
  }
  if (!$isNull(request.mcpRouteConfig)) {
    body['mcpRouteConfig'] = request.mcpRouteConfig;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }
  if (!$isNull(request.policyConfigs)) {
    body['policyConfigs'] = request.policyConfigs;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateHttpApiRoute',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis/${$URL.percentEncode(httpApiId)}/routes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a route for an HTTP API.
 *
 * @param request CreateHttpApiRouteRequest
 * @return CreateHttpApiRouteResponse
 */
async function createHttpApiRoute(httpApiId: string, request: CreateHttpApiRouteRequest): CreateHttpApiRouteResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createHttpApiRouteWithOptions(httpApiId, request, headers, runtime);
}

model CreateMcpServerRequest {
  assembledSources?: [ 
    {
      mcpServerId?: string(name='mcpServerId', description='MCP Server ID', example='mcp-sdfa3qgavz'),
      mcpServerName?: string(name='mcpServerName', description='Source MCP server name', example='test-mcp'),
      tools?: [ string ](name='tools', description='List of tool names to include'),
    }
  ](name='assembledSources', description='Assembled MCP server sources'),
  backendConfig?: {
    scene?: string(name='scene', description='Backend scene type', example='SingleService'),
    services?: [ 
      {
        port?: int32(name='port', description='Service port', example='8080'),
        protocol?: string(name='protocol', description='Service protocol', example='HTTP'),
        serviceId?: string(name='serviceId', description='Service ID', example='svc-crbgq0dlhtgr***'),
        version?: string(name='version', description='Service version', example='2.1.6'),
        weight?: int32(name='weight', description='Service weight', example='49'),
      }
    ](name='services', description='List of backend services'),
  }(name='backendConfig', description='Backend configuration'),
  createFromType?: string(name='createFromType', description='Creation source type', example='ApiGatewayMcpHosting'),
  description?: string(name='description', description='MCP server description', example='mcp tool fetch time'),
  domainIds?: [ string ](name='domainIds', description='List of domain IDs for the MCP server'),
  exposedUriPath?: string(name='exposedUriPath', description='Exposed URI path for SSE/StreamableHTTP protocols', example='/sse'),
  gatewayId?: string(name='gatewayId', description='Gateway ID

This parameter is required.', example='gw-cq7l5s5lhtgi6qac0'),
  grayMcpServerConfigs?: [ 
    {
      backendConfig?: {
        scene?: string(name='scene', description='Must be SingleService', example='SingleService'),
        services?: [ 
          {
            port?: int32(name='port', description='Service port number', example='8080'),
            protocol?: string(name='protocol', description='Service protocol type', example='HTTP'),
            serviceId?: string(name='serviceId', description='Service ID', example='svc-gray'),
            version?: string(name='version', description='Service version', example='v2.0.0'),
            weight?: int32(name='weight', description='Service weight for load balancing', example='100'),
          }
        ](name='services', description='Exactly one service'),
      }(name='backendConfig', description='Backend configuration for gray route'),
      match?: HttpRouteMatch(name='match', description='Route matching rules'),
      routeId?: string(name='routeId', description='Route ID for update operations', example='gray-route-123'),
    }
  ](name='grayMcpServerConfigs', description='Gray route configurations'),
  match?: HttpRouteMatch(name='match', description='Route matching conditions'),
  mcpServerConfig?: {
    mcpServerSpec?: string(name='mcpServerSpec', description='Converted MCP server spec YAML', example='mcp-spec.yaml'),
    swaggerConfig?: string(name='swaggerConfig', description='Raw Swagger/OpenAPI document', example='swagger.yaml'),
  }(name='mcpServerConfig', description='MCP server specification'),
  mcpStatisticsEnable?: boolean(name='mcpStatisticsEnable', description='Enable MCP statistics', example='false'),
  name?: string(name='name', description='MCP server name

This parameter is required.', example='fetch-time'),
  protocol?: string(name='protocol', description='MCP protocol', example='HTTP'),
  type?: string(name='type', description='MCP server type

This parameter is required.', example='RealMCP'),
}

model CreateMcpServerResponseBody = {
  code?: string(name='code', description='code', example='200'),
  data?: {
    mcpServerId?: string(name='mcpServerId', description='MCP Server ID', example='mcp-afegaijoijaoji24a'),
    name?: string(name='name', description='MCP server name', example='test-mcp'),
  }(name='data', description='object'),
  message?: string(name='message', description='message', example='success'),
  requestId?: string(name='requestId', description='Id of the request', example='464F9EA0-1052-51BD-8187-D292AA2D8D24'),
}

model CreateMcpServerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcpServerResponseBody(name='body'),
}

/**
 * @summary Creates an MCP server.
 *
 * @param request CreateMcpServerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcpServerResponse
 */
@context("createMcpServerWithContext")
async function createMcpServerWithOptions(request: CreateMcpServerRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateMcpServerResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.assembledSources)) {
    body['assembledSources'] = request.assembledSources;
  }
  if (!$isNull(request.backendConfig)) {
    body['backendConfig'] = request.backendConfig;
  }
  if (!$isNull(request.createFromType)) {
    body['createFromType'] = request.createFromType;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.domainIds)) {
    body['domainIds'] = request.domainIds;
  }
  if (!$isNull(request.exposedUriPath)) {
    body['exposedUriPath'] = request.exposedUriPath;
  }
  if (!$isNull(request.gatewayId)) {
    body['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.grayMcpServerConfigs)) {
    body['grayMcpServerConfigs'] = request.grayMcpServerConfigs;
  }
  if (!$isNull(request.match)) {
    body['match'] = request.match;
  }
  if (!$isNull(request.mcpServerConfig)) {
    body['mcpServerConfig'] = request.mcpServerConfig;
  }
  if (!$isNull(request.mcpStatisticsEnable)) {
    body['mcpStatisticsEnable'] = request.mcpStatisticsEnable;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }
  if (!$isNull(request.protocol)) {
    body['protocol'] = request.protocol;
  }
  if (!$isNull(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcpServer',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/mcp-servers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an MCP server.
 *
 * @param request CreateMcpServerRequest
 * @return CreateMcpServerResponse
 */
async function createMcpServer(request: CreateMcpServerRequest): CreateMcpServerResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createMcpServerWithOptions(request, headers, runtime);
}

model CreatePluginAttachmentRequest {
  attachResourceIds?: [ string ](name='attachResourceIds', description='The attachment IDs.'),
  attachResourceType?: string(name='attachResourceType', description='The type of the resource to which the plug-in is attached. Valid values: GatewayRoute, Gateway, GatewayDomain, HttpApi, and Operation.', example='HttpApi'),
  enable?: boolean(name='enable', description='Specifies whether to enable the plug-in. Default value: false.', example='false'),
  environmentId?: string(name='environmentId', description='The environment ID.', example='env-xxx'),
  gatewayId?: string(name='gatewayId', description='The instance ID.', example='gw-cq7l5s5lhtg***'),
  pluginConfig?: string(name='pluginConfig', description='The Base64-encoded configurations of the plug-in.', example='cHJlcGVuZDoKLSByb2xlOiBzeXN0ZW0KICBjb250ZW50OiDor7fkvb/nlKjoi7Hor63lm57nrZTpl67popgKYXBwZW5kOgotIHJvbGU6IHVzZXIKICBjb250ZW50OiDmr4/mrKHlm57nrZTlrozpl67popjvvIzlsJ3or5Xov5vooYzlj43pl64K'),
  pluginId?: string(name='pluginId', description='The plug-in ID.', example='pl-cvo8udem1hkob1qd67i0'),
}

model CreatePluginAttachmentResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    pluginAttachmentId?: string(name='pluginAttachmentId', description='The plug-in ID.', example='pa-cvs7jpmm1hkgihaqv4a0'),
  }(name='data', description='The returned data.'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='EBCB8485-24F9-54CD-B258-CB15FDB27677'),
}

model CreatePluginAttachmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePluginAttachmentResponseBody(name='body'),
}

/**
 * @summary Attaches a plug-in.
 *
 * @param request CreatePluginAttachmentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePluginAttachmentResponse
 */
@context("createPluginAttachmentWithContext")
async function createPluginAttachmentWithOptions(request: CreatePluginAttachmentRequest, headers: map[string]string, runtime: $RuntimeOptions): CreatePluginAttachmentResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.attachResourceIds)) {
    body['attachResourceIds'] = request.attachResourceIds;
  }
  if (!$isNull(request.attachResourceType)) {
    body['attachResourceType'] = request.attachResourceType;
  }
  if (!$isNull(request.enable)) {
    body['enable'] = request.enable;
  }
  if (!$isNull(request.environmentId)) {
    body['environmentId'] = request.environmentId;
  }
  if (!$isNull(request.gatewayId)) {
    body['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.pluginConfig)) {
    body['pluginConfig'] = request.pluginConfig;
  }
  if (!$isNull(request.pluginId)) {
    body['pluginId'] = request.pluginId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreatePluginAttachment',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/plugin-attachments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Attaches a plug-in.
 *
 * @param request CreatePluginAttachmentRequest
 * @return CreatePluginAttachmentResponse
 */
async function createPluginAttachment(request: CreatePluginAttachmentRequest): CreatePluginAttachmentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createPluginAttachmentWithOptions(request, headers, runtime);
}

model CreatePolicyRequest {
  className?: string(name='className', description='Policy type, including RateLimit, ConcurrencyLimit, CircuitBreaker, HttpRewrite, HeaderModify, Cors, Authentication, FlowCopy, Timeout, Retry, IpAccessControl, DirectResponse, Redirect, Fallback, ServiceTls, ServiceLb, ServicePortTls, Waf, JWTAuth, OIDCAuth, ExternalZAuth, AiProxy, ModelRouter, AiStatistics, AiSecurityGuard, AiFallback, ModelMapper, AiTokenRateLimit, AiCache, DynamicRoute

This parameter is required.', example='Timeout'),
  config?: string(name='config', description='Policy configuration

This parameter is required.', example='{"unitNum":1,"timeUnit":"s","enable":true}'),
  description?: string(name='description', description='Policy description', example='timeout policy'),
  name?: string(name='name', description='Policy name

This parameter is required.', example='test-policy'),
}

model CreatePolicyResponseBody = {
  code?: string(name='code', description='Response status code.', example='Ok'),
  data?: {
    policyId?: string(name='policyId', description='Policy ID', example='p-cq7l5s5lhtgi6qasr***'),
  }(name='data', description='Response data.'),
  message?: string(name='message', description='Response message.', example='success'),
  requestId?: string(name='requestId', description='ID of the request', example='393E2630-DBE7-5221-AB35-9E7406754***'),
}

model CreatePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePolicyResponseBody(name='body'),
}

/**
 * @summary Creates a policy.
 *
 * @param request CreatePolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePolicyResponse
 */
@context("createPolicyWithContext")
async function createPolicyWithOptions(request: CreatePolicyRequest, headers: map[string]string, runtime: $RuntimeOptions): CreatePolicyResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.className)) {
    body['className'] = request.className;
  }
  if (!$isNull(request.config)) {
    body['config'] = request.config;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreatePolicy',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v2/policies`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a policy.
 *
 * @param request CreatePolicyRequest
 * @return CreatePolicyResponse
 */
async function createPolicy(request: CreatePolicyRequest): CreatePolicyResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createPolicyWithOptions(request, headers, runtime);
}

model CreatePolicyAttachmentRequest {
  attachResourceId?: string(name='attachResourceId', description='Attached resource ID

This parameter is required.', example='api-cu07jj6m1hkokaus***'),
  attachResourceType?: string(name='attachResourceType', description='Attached resource type, such as HttpApi, GatewayRoute, Operation, GatewayService, GatewayServicePort, Gateway, Domain

This parameter is required.', example='HttpApi'),
  environmentId?: string(name='environmentId', description='Environment ID

This parameter is required.', example='env-cquqsollhtgid***'),
  gatewayId?: string(name='gatewayId', description='Gateway instance ID

This parameter is required.', example='gw-cq7l5s5lhtgi6qas***'),
  policyId?: string(name='policyId', description='Policy ID

This parameter is required.', example='p-cq787etlhtghrptjg***'),
}

model CreatePolicyAttachmentResponseBody = {
  code?: string(name='code', description='Response code.', example='Ok'),
  data?: {
    policyAttachmentId?: string(name='policyAttachmentId', description='Policy Mount ID', example='pr-cqooju5lhtgquuj6***'),
  }(name='data', description='Response data.'),
  message?: string(name='message', description='Response message.', example='success'),
  requestId?: string(name='requestId', description='ID of the request', example='585657D2-1C20-5B8A-AF17-D727C64***'),
}

model CreatePolicyAttachmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePolicyAttachmentResponseBody(name='body'),
}

/**
 * @summary Creates a policy attachment.
 *
 * @param request CreatePolicyAttachmentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePolicyAttachmentResponse
 */
@context("createPolicyAttachmentWithContext")
async function createPolicyAttachmentWithOptions(request: CreatePolicyAttachmentRequest, headers: map[string]string, runtime: $RuntimeOptions): CreatePolicyAttachmentResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.attachResourceId)) {
    body['attachResourceId'] = request.attachResourceId;
  }
  if (!$isNull(request.attachResourceType)) {
    body['attachResourceType'] = request.attachResourceType;
  }
  if (!$isNull(request.environmentId)) {
    body['environmentId'] = request.environmentId;
  }
  if (!$isNull(request.gatewayId)) {
    body['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.policyId)) {
    body['policyId'] = request.policyId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreatePolicyAttachment',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/policy-attachments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a policy attachment.
 *
 * @param request CreatePolicyAttachmentRequest
 * @return CreatePolicyAttachmentResponse
 */
async function createPolicyAttachment(request: CreatePolicyAttachmentRequest): CreatePolicyAttachmentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createPolicyAttachmentWithOptions(request, headers, runtime);
}

model CreateSecretRequest {
  description?: string(name='description'),
  gatewayType?: string(name='gatewayType'),
  kmsConfig?: KMSConfig(name='kmsConfig'),
  name?: string(name='name'),
  secretData?: string(name='secretData'),
  secretSource?: string(name='secretSource'),
}

model CreateSecretResponseBody = {
  code?: string(name='code'),
  data?: {
    secretId?: string(name='secretId'),
  }(name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId', description='Id of the request'),
}

model CreateSecretResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSecretResponseBody(name='body'),
}

/**
 * @summary 创建密钥
 *
 * @param request CreateSecretRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSecretResponse
 */
@context("createSecretWithContext")
async function createSecretWithOptions(request: CreateSecretRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateSecretResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.gatewayType)) {
    body['gatewayType'] = request.gatewayType;
  }
  if (!$isNull(request.kmsConfig)) {
    body['kmsConfig'] = request.kmsConfig;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }
  if (!$isNull(request.secretData)) {
    body['secretData'] = request.secretData;
  }
  if (!$isNull(request.secretSource)) {
    body['secretSource'] = request.secretSource;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateSecret',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/secrets`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建密钥
 *
 * @param request CreateSecretRequest
 * @return CreateSecretResponse
 */
async function createSecret(request: CreateSecretRequest): CreateSecretResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createSecretWithOptions(request, headers, runtime);
}

model CreateServiceRequest {
  gatewayId?: string(name='gatewayId', description='The gateway instance ID.', example='gw-cq7l5s5lhtg***'),
  resourceGroupId?: string(name='resourceGroupId', description='The resource group ID.', example='rg-xxx'),
  serviceConfigs?: [ 
    {
      addresses?: [ string ](name='addresses', description='The list of domain names or fixed IP addresses.'),
      agentServiceConfig?: AgentServiceConfig(name='agentServiceConfig', description='Agent service configuration'),
      aiServiceConfig?: AiServiceConfig(name='aiServiceConfig', description='The AI service configurations.'),
      dnsServers?: [ string ](name='dnsServers', description='The list of DNS service addresses.'),
      expressType?: string(name='expressType', description='Express type', example='Standard'),
      groupName?: string(name='groupName', description='The service group name. This parameter is required if sourceType is set to MSE_NACOS.', example='DEFAULT_GROUP'),
      name?: string(name='name', description='The service name.', example='user-service'),
      namespace?: string(name='namespace', description='The service namespace. This parameter is required when sourceType is set to K8S or MSE_NACOS.

*   If sourceType is set to K8S, this parameter specifies the namespace where the K8s service resides.
*   If sourceType is set to MSE_NACOS, this parameter specifies a namespace in Nacos.

This parameter is required if sourceType is set to K8S or MSE_NACOS.', example='PUBLIC'),
      qualifier?: string(name='qualifier', description='The function version/alias.', example='LATEST'),
      sourceId?: string(name='sourceId', description='Service source ID', example='nacos-instance-001'),
      validationOptions?: {
        skipVerifyAIChatCompletion?: boolean(name='skipVerifyAIChatCompletion', description='Skip AI chat completion verification'),
      }(name='validationOptions', description='Validation options'),
    }
  ](name='serviceConfigs', description='The list of service configurations.'),
  sourceType?: string(name='sourceType', description='The service source type. Valid values:

*   MSE_NACOS: MSE Nacos instance services
*   K8S: Container Service for Kubernetes (ACK) cluster services
*   VIP: fixed IP addresses
*   DNS: Domain Name System (DNS) domains
*   FC3: Function Compute services
*   SAE_K8S_SERVICE: Serverless App Engine (SAE) Kubernetes services

Valid values:

*   SAE_K8S_SERVICE
*   K8S
*   FC3
*   DNS
*   VIP
*   MSE_NACOS', example='MSE_NACOS'),
  clientToken?: string(name='clientToken', description='clientToken', example='xxx'),
}

model CreateServiceResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    serviceIds?: [ string ](name='serviceIds', description='The list of service IDs.'),
  }(name='data', description='The response data.'),
  message?: string(name='message', description='The returned message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='C67DED2B-F19B-5BEC-88C1-D6EB854CD0D4'),
}

model CreateServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateServiceResponseBody(name='body'),
}

/**
 * @summary Creates a service.
 *
 * @description You can call this operation to create multiple services at a time.
 *
 * @param request CreateServiceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateServiceResponse
 */
@context("createServiceWithContext")
async function createServiceWithOptions(request: CreateServiceRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateServiceResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!$isNull(request.gatewayId)) {
    body['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.serviceConfigs)) {
    body['serviceConfigs'] = request.serviceConfigs;
  }
  if (!$isNull(request.sourceType)) {
    body['sourceType'] = request.sourceType;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateService',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/services`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a service.
 *
 * @description You can call this operation to create multiple services at a time.
 *
 * @param request CreateServiceRequest
 * @return CreateServiceResponse
 */
async function createService(request: CreateServiceRequest): CreateServiceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceWithOptions(request, headers, runtime);
}

model CreateServiceVersionRequest {
  labels?: [ 
    {
      key?: string(name='key', description='The tag key.

This parameter is required.', example='topology.kubernetes.io/zone'),
      value?: string(name='value', description='The tag value.', example='cn-hangzhou-j'),
    }
  ](name='labels', description='The service tags.

This parameter is required.'),
  name?: string(name='name', description='The version name.

This parameter is required.', example='v1'),
}

model CreateServiceVersionResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The message returned.', example='Success'),
  requestId?: string(name='requestId', description='The request ID.', example='0B373A13-9BB8-5068-9C94-AD6D39E6BBA2'),
}

model CreateServiceVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateServiceVersionResponseBody(name='body'),
}

/**
 * @summary Creates a service version.
 *
 * @param request CreateServiceVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateServiceVersionResponse
 */
@context("createServiceVersionWithContext")
async function createServiceVersionWithOptions(serviceId: string, request: CreateServiceVersionRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateServiceVersionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.labels)) {
    body['labels'] = request.labels;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateServiceVersion',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/services/${$URL.percentEncode(serviceId)}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a service version.
 *
 * @param request CreateServiceVersionRequest
 * @return CreateServiceVersionResponse
 */
async function createServiceVersion(serviceId: string, request: CreateServiceVersionRequest): CreateServiceVersionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceVersionWithOptions(serviceId, request, headers, runtime);
}

model CreateSourceRequest {
  gatewayId?: string(name='gatewayId', description='The gateway instance ID.', example='gw-cq7l5s5lhtgi6q***'),
  k8sSourceConfig?: {
    authorizeSecurityGroupRules?: [ 
      {
        description?: string(name='description', description='The rule description.'),
        portRanges?: [ string ](name='portRanges', description='The list of port ranges.'),
        securityGroupId?: string(name='securityGroupId', description='The ID of a security group.', example='sg-bp14w4fa4j***'),
      }
    ](name='authorizeSecurityGroupRules', description='The security group rules.'),
    clusterId?: string(name='clusterId', description='The ID of the ACK cluster.', example='c3fbe6caaaece4062b*****'),
  }(name='k8sSourceConfig', description='The source configuration when the source type is K8S.'),
  nacosSourceConfig?: {
    instanceId?: string(name='instanceId', description='The Nacos instance ID.', example='mse-cn-0dw3w***'),
  }(name='nacosSourceConfig', description='The source configuration when the source type is MSE_NACOS.'),
  resourceGroupId?: string(name='resourceGroupId', description='The resource group ID.', example='rg-xxx'),
  type?: string(name='type', description='The source type. Valid values:

*   MSE_NACOS: MSE Nacos
*   K8S: Container Service for Kubernetes (ACK)', example='MSE_NACOS'),
}

model CreateSourceResponseBody = {
  code?: string(name='code', example='Ok'),
  data?: {
    sourceId?: string(name='sourceId', example='src-crdddallhtgt***'),
  }(name='data'),
  message?: string(name='message', example='success'),
  requestId?: string(name='requestId', example='393E2630-DBE7-5221-AB35-9E740675491A'),
}

model CreateSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSourceResponseBody(name='body'),
}

/**
 * @summary Creates a service source.
 *
 * @param request CreateSourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSourceResponse
 */
@context("createSourceWithContext")
async function createSourceWithOptions(request: CreateSourceRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateSourceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.gatewayId)) {
    body['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.k8sSourceConfig)) {
    body['k8sSourceConfig'] = request.k8sSourceConfig;
  }
  if (!$isNull(request.nacosSourceConfig)) {
    body['nacosSourceConfig'] = request.nacosSourceConfig;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateSource',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/sources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a service source.
 *
 * @param request CreateSourceRequest
 * @return CreateSourceResponse
 */
async function createSource(request: CreateSourceRequest): CreateSourceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createSourceWithOptions(request, headers, runtime);
}

model DeleteConsumerResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The status message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='40C8A4FF-7AF1-5B52-A662-02EEE24C6908'),
}

model DeleteConsumerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteConsumerResponseBody(name='body'),
}

/**
 * @summary Deletes a consumer.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConsumerResponse
 */
@context("deleteConsumerWithContext")
async function deleteConsumerWithOptions(consumerId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteConsumerResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteConsumer',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/consumers/${$URL.percentEncode(consumerId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a consumer.
 *
 * @return DeleteConsumerResponse
 */
async function deleteConsumer(consumerId: string): DeleteConsumerResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConsumerWithOptions(consumerId, headers, runtime);
}

model DeleteConsumerAuthorizationRuleResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The status message.', example='ok'),
  requestId?: string(name='requestId', description='The request ID.', example='3C3B9A12-3868-5EB9-8BEA-F99E03DD125C'),
}

model DeleteConsumerAuthorizationRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteConsumerAuthorizationRuleResponseBody(name='body'),
}

/**
 * @summary Deletes a consumer authorization rule.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConsumerAuthorizationRuleResponse
 */
@context("deleteConsumerAuthorizationRuleWithContext")
async function deleteConsumerAuthorizationRuleWithOptions(consumerAuthorizationRuleId: string, consumerId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteConsumerAuthorizationRuleResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteConsumerAuthorizationRule',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/consumers/${$URL.percentEncode(consumerId)}/authorization-rules/${$URL.percentEncode(consumerAuthorizationRuleId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a consumer authorization rule.
 *
 * @return DeleteConsumerAuthorizationRuleResponse
 */
async function deleteConsumerAuthorizationRule(consumerAuthorizationRuleId: string, consumerId: string): DeleteConsumerAuthorizationRuleResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConsumerAuthorizationRuleWithOptions(consumerAuthorizationRuleId, consumerId, headers, runtime);
}

model DeleteDomainResponseBody = {
  code?: string(name='code', description='The status code returned.', example='Ok'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID, which is used to trace the API call link.', example='A60EE5CA-1294-532A-9775-8D2FD1C6EFBF'),
}

model DeleteDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDomainResponseBody(name='body'),
}

/**
 * @summary Deletes a domain name.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDomainResponse
 */
@context("deleteDomainWithContext")
async function deleteDomainWithOptions(domainId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteDomainResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteDomain',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/domains/${$URL.percentEncode(domainId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a domain name.
 *
 * @return DeleteDomainResponse
 */
async function deleteDomain(domainId: string): DeleteDomainResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDomainWithOptions(domainId, headers, runtime);
}

model DeleteEnvironmentResponseBody = {
  code?: string(name='code', description='The status code returned.', example='Ok'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID. You can use the ID to trace the request link.', example='C61E30D3-579A-5B43-994E-31E02EDC9129'),
}

model DeleteEnvironmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteEnvironmentResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI DeleteEnvironment is deprecated
 *
 * @summary Deletes an environment.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEnvironmentResponse
 */
// Deprecated
@context("deleteEnvironmentWithContext")
async function deleteEnvironmentWithOptions(environmentId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteEnvironmentResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteEnvironment',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/environments/${$URL.percentEncode(environmentId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @deprecated OpenAPI DeleteEnvironment is deprecated
 *
 * @summary Deletes an environment.
 *
 * @return DeleteEnvironmentResponse
 */
// Deprecated
async function deleteEnvironment(environmentId: string): DeleteEnvironmentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEnvironmentWithOptions(environmentId, headers, runtime);
}

model DeleteGatewayResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The returned message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='DE97DFDB-7DF0-5AB9-941C-10D27D769E4B'),
}

model DeleteGatewayResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGatewayResponseBody(name='body'),
}

/**
 * @summary Deletes a Cloud-native API Gateway instance.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGatewayResponse
 */
@context("deleteGatewayWithContext")
async function deleteGatewayWithOptions(gatewayId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteGatewayResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteGateway',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/gateways/${$URL.percentEncode(gatewayId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a Cloud-native API Gateway instance.
 *
 * @return DeleteGatewayResponse
 */
async function deleteGateway(gatewayId: string): DeleteGatewayResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteGatewayWithOptions(gatewayId, headers, runtime);
}

model DeleteGatewaySecurityGroupRuleRequest {
  cascadingDelete?: boolean(name='cascadingDelete', description='Specifies whether to delete the cascaded security group rule.', example='true'),
}

model DeleteGatewaySecurityGroupRuleResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='8F94B3CC-F4BA-511E-8367-ECBBE486E595'),
}

model DeleteGatewaySecurityGroupRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGatewaySecurityGroupRuleResponseBody(name='body'),
}

/**
 * @summary Deletes a security group rule from a Cloud-native API Gateway instance.
 *
 * @param request DeleteGatewaySecurityGroupRuleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGatewaySecurityGroupRuleResponse
 */
@context("deleteGatewaySecurityGroupRuleWithContext")
async function deleteGatewaySecurityGroupRuleWithOptions(gatewayId: string, securityGroupRuleId: string, request: DeleteGatewaySecurityGroupRuleRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteGatewaySecurityGroupRuleResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.cascadingDelete)) {
    query['cascadingDelete'] = request.cascadingDelete;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteGatewaySecurityGroupRule',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/gateways/${$URL.percentEncode(gatewayId)}/security-group-rules/${$URL.percentEncode(securityGroupRuleId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a security group rule from a Cloud-native API Gateway instance.
 *
 * @param request DeleteGatewaySecurityGroupRuleRequest
 * @return DeleteGatewaySecurityGroupRuleResponse
 */
async function deleteGatewaySecurityGroupRule(gatewayId: string, securityGroupRuleId: string, request: DeleteGatewaySecurityGroupRuleRequest): DeleteGatewaySecurityGroupRuleResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteGatewaySecurityGroupRuleWithOptions(gatewayId, securityGroupRuleId, request, headers, runtime);
}

model DeleteHttpApiResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The returned message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='5B626361-070A-56A7-B127-ADAC8F3655DB'),
}

model DeleteHttpApiResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteHttpApiResponseBody(name='body'),
}

/**
 * @summary Deletes an HTTP API.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHttpApiResponse
 */
@context("deleteHttpApiWithContext")
async function deleteHttpApiWithOptions(httpApiId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteHttpApiResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteHttpApi',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis/${$URL.percentEncode(httpApiId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an HTTP API.
 *
 * @return DeleteHttpApiResponse
 */
async function deleteHttpApi(httpApiId: string): DeleteHttpApiResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteHttpApiWithOptions(httpApiId, headers, runtime);
}

model DeleteHttpApiOperationResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The returned message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='585657D2-1C20-5B8A-AF17-D727C6490BE4'),
}

model DeleteHttpApiOperationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteHttpApiOperationResponseBody(name='body'),
}

/**
 * @summary Deletes an operation from an HTTP API.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHttpApiOperationResponse
 */
@context("deleteHttpApiOperationWithContext")
async function deleteHttpApiOperationWithOptions(httpApiId: string, operationId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteHttpApiOperationResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteHttpApiOperation',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis/${$URL.percentEncode(httpApiId)}/operations/${$URL.percentEncode(operationId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an operation from an HTTP API.
 *
 * @return DeleteHttpApiOperationResponse
 */
async function deleteHttpApiOperation(httpApiId: string, operationId: string): DeleteHttpApiOperationResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteHttpApiOperationWithOptions(httpApiId, operationId, headers, runtime);
}

model DeleteHttpApiRouteResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='0F138FFC-6E2B-56C1-9BAB-A67462E339D1'),
}

model DeleteHttpApiRouteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteHttpApiRouteResponseBody(name='body'),
}

/**
 * @summary Deletes a route in an HTTP API.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHttpApiRouteResponse
 */
@context("deleteHttpApiRouteWithContext")
async function deleteHttpApiRouteWithOptions(httpApiId: string, routeId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteHttpApiRouteResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteHttpApiRoute',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis/${$URL.percentEncode(httpApiId)}/routes/${$URL.percentEncode(routeId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a route in an HTTP API.
 *
 * @return DeleteHttpApiRouteResponse
 */
async function deleteHttpApiRoute(httpApiId: string, routeId: string): DeleteHttpApiRouteResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteHttpApiRouteWithOptions(httpApiId, routeId, headers, runtime);
}

model DeleteMcpServerResponseBody = {
  code?: string(name='code', description='The request ID.', example='Ok'),
  message?: string(name='message', description='The status code.', example='Success'),
  requestId?: string(name='requestId', description='The MCP server ID.', example='393E2630-DBE7-5221-AB35-9E740675491A'),
}

model DeleteMcpServerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcpServerResponseBody(name='body'),
}

/**
 * @summary Deletes an MCP server.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMcpServerResponse
 */
@context("deleteMcpServerWithContext")
async function deleteMcpServerWithOptions(mcpServerId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteMcpServerResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteMcpServer',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/mcp-servers/${$URL.percentEncode(mcpServerId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an MCP server.
 *
 * @return DeleteMcpServerResponse
 */
async function deleteMcpServer(mcpServerId: string): DeleteMcpServerResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMcpServerWithOptions(mcpServerId, headers, runtime);
}

model DeletePluginAttachmentResponseBody = {
  code?: string(name='code', description='The response code.', example='Ok'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='76BDFFC7-0764-5168-B047-92EE0BC7FDDE'),
}

model DeletePluginAttachmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePluginAttachmentResponseBody(name='body'),
}

/**
 * @summary Deletes a plug-in attachment.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePluginAttachmentResponse
 */
@context("deletePluginAttachmentWithContext")
async function deletePluginAttachmentWithOptions(pluginAttachmentId: string, headers: map[string]string, runtime: $RuntimeOptions): DeletePluginAttachmentResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeletePluginAttachment',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/plugin-attachments/${$URL.percentEncode(pluginAttachmentId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a plug-in attachment.
 *
 * @return DeletePluginAttachmentResponse
 */
async function deletePluginAttachment(pluginAttachmentId: string): DeletePluginAttachmentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePluginAttachmentWithOptions(pluginAttachmentId, headers, runtime);
}

model DeletePolicyResponseBody = {
  code?: string(name='code', description='Response status code.', example='Ok'),
  message?: string(name='message', description='Response message.', example='success'),
  requestId?: string(name='requestId', description='ID of the request', example='393E2630-DBE7-5221-AB35-9E7406754***'),
}

model DeletePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePolicyResponseBody(name='body'),
}

/**
 * @summary Deletes a policy.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePolicyResponse
 */
@context("deletePolicyWithContext")
async function deletePolicyWithOptions(policyId: string, headers: map[string]string, runtime: $RuntimeOptions): DeletePolicyResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeletePolicy',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v2/policies/${$URL.percentEncode(policyId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a policy.
 *
 * @return DeletePolicyResponse
 */
async function deletePolicy(policyId: string): DeletePolicyResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePolicyWithOptions(policyId, headers, runtime);
}

model DeletePolicyAttachmentResponseBody = {
  code?: string(name='code', description='Response status code.', example='200'),
  message?: string(name='message', description='Response message.', example='success'),
  requestId?: string(name='requestId', description='ID of the request', example='CE857A85-251D-5018-8103-A38957D71***'),
}

model DeletePolicyAttachmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePolicyAttachmentResponseBody(name='body'),
}

/**
 * @summary Deletes a policy attachment.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePolicyAttachmentResponse
 */
@context("deletePolicyAttachmentWithContext")
async function deletePolicyAttachmentWithOptions(policyAttachmentId: string, headers: map[string]string, runtime: $RuntimeOptions): DeletePolicyAttachmentResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeletePolicyAttachment',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/policy-attachments/${$URL.percentEncode(policyAttachmentId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a policy attachment.
 *
 * @return DeletePolicyAttachmentResponse
 */
async function deletePolicyAttachment(policyAttachmentId: string): DeletePolicyAttachmentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePolicyAttachmentWithOptions(policyAttachmentId, headers, runtime);
}

model DeleteSecretResponseBody = {
  code?: string(name='code'),
  message?: string(name='message'),
  requestId?: string(name='requestId', description='Id of the request'),
}

model DeleteSecretResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSecretResponseBody(name='body'),
}

/**
 * @summary 删除密钥
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSecretResponse
 */
@context("deleteSecretWithContext")
async function deleteSecretWithOptions(secretId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteSecretResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteSecret',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/secrets/${$URL.percentEncode(secretId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除密钥
 *
 * @return DeleteSecretResponse
 */
async function deleteSecret(secretId: string): DeleteSecretResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSecretWithOptions(secretId, headers, runtime);
}

model DeleteServiceResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The status message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='3C3B9A12-3868-5EB9-8BEA-F99E03DD125C'),
}

model DeleteServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteServiceResponseBody(name='body'),
}

/**
 * @summary Deletes a service.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteServiceResponse
 */
@context("deleteServiceWithContext")
async function deleteServiceWithOptions(serviceId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteServiceResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteService',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/services/${$URL.percentEncode(serviceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a service.
 *
 * @return DeleteServiceResponse
 */
async function deleteService(serviceId: string): DeleteServiceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceWithOptions(serviceId, headers, runtime);
}

model DeleteServiceVersionResponseBody = {
  code?: string(name='code', description='The status code returned.', example='Ok'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='A1994B10-C6A8-58FA-8347-6A08B0D4EFDE'),
}

model DeleteServiceVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteServiceVersionResponseBody(name='body'),
}

/**
 * @summary Deletes a service version.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteServiceVersionResponse
 */
@context("deleteServiceVersionWithContext")
async function deleteServiceVersionWithOptions(serviceId: string, name: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteServiceVersionResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteServiceVersion',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/services/${$URL.percentEncode(serviceId)}/versions/${$URL.percentEncode(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a service version.
 *
 * @return DeleteServiceVersionResponse
 */
async function deleteServiceVersion(serviceId: string, name: string): DeleteServiceVersionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceVersionWithOptions(serviceId, name, headers, runtime);
}

model DeleteSourceResponseBody = {
  code?: string(name='code', example='Ok'),
  message?: string(name='message', example='success'),
  requestId?: string(name='requestId', example='C67DED2B-F19B-5BEC-88C1-D6EB854CD0D4'),
}

model DeleteSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSourceResponseBody(name='body'),
}

/**
 * @summary Deletes a service source.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSourceResponse
 */
@context("deleteSourceWithContext")
async function deleteSourceWithOptions(sourceId: string, headers: map[string]string, runtime: $RuntimeOptions): DeleteSourceResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteSource',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/sources/${$URL.percentEncode(sourceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a service source.
 *
 * @return DeleteSourceResponse
 */
async function deleteSource(sourceId: string): DeleteSourceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSourceWithOptions(sourceId, headers, runtime);
}

model DeployHttpApiRequest {
  httpApiConfig?: {
    gatewayId?: string(name='gatewayId', description='The gateway ID.', example='gw-csrhgfmm1hknf0hu6o3g'),
    routeIds?: [ string ](name='routeIds', description='routeIds'),
  }(name='httpApiConfig', description='httpApiConfig', deprecated=true),
  restApiConfig?: {
    description?: string(name='description', description='The publish description.', example='The user service API'),
    environment?: {
      backendScene?: string(name='backendScene', description='The publishing scenario.

Valid values:

*   SingleService
*   MultiServiceByRatio
*   MultiServiceByContent
*   Mock', example='SingleService', deprecated=true),
      customDomainIds?: [ string ](name='customDomainIds', description='The custom domain names.'),
      environmentId?: string(name='environmentId', description='The environment ID.', example='env-cpqnr6tlhtgubc***', deprecated=true),
      serviceConfigs?: [ 
        {
          match?: HttpApiBackendMatchConditions(name='match', description='The matching condition configurations related to API publishing.', example='{\\\\"change_order_revision\\\\":\\\\"3.657.33_fc-hz-yunqi.1662568293908382_faas-eerouter\\\\"}'),
          port?: int32(name='port', description='The service port. If you want to use a dynamic port, do not pass this parameter.', example='8080'),
          protocol?: string(name='protocol', description='The service protocol. Valid values:

*   HTTP
*   HTTPS', example='HTTP'),
          serviceId?: string(name='serviceId', description='The service ID.', example='svc-cr6pk4tlhtgm58e***'),
          version?: string(name='version', description='The version of the microservice.', example='v1'),
          weight?: int32(name='weight', description='The weight. Valid values: [1,100]. This parameter is valid only in proportional routing.', example='49'),
        }
      ](name='serviceConfigs', description='The configurations of existing services. For single-service publishing, only one entry is allowed. For other scenarios, multiple entries are allowed.', deprecated=true),
    }(name='environment', description='The environment configurations.'),
    gatewayId?: string(name='gatewayId', description='The gateway ID.', example='gw-cvn2u46m1hkun04oll8g'),
    operationDeployments?: [ 
      {
        action?: string(name='action', description='Operation type', example='Publish'),
        operationId?: string(name='operationId', description='Unique identifier of the operation', example='op-xxx'),
      }
    ](name='operationDeployments', description='Operation-level deployment control list'),
    operationIds?: [ string ](name='operationIds', description='operationIds', deprecated=true),
    revisionId?: string(name='revisionId', description='The historical version of the API. If you specify this parameter, the corresponding version of the API is published.', example='apr-xxx'),
  }(name='restApiConfig', description='The REST API deployment configuration. This parameter is required when you publish a REST API.'),
  routeId?: string(name='routeId', description='The route ID. You must specify this parameter when you publish an HTTP API.', example='hr-cr82undlhtgrl***'),
}

model DeployHttpApiResponseBody = {
  code?: string(name='code', description='Response status code.', example='Ok'),
  message?: string(name='message', description='Response message.', example='success'),
  requestId?: string(name='requestId', description='Request ID.', example='0C2D1C68-0D93-5561-8EE6-FDB7BF067A30'),
}

model DeployHttpApiResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeployHttpApiResponseBody(name='body'),
}

/**
 * @summary Deploy HttpApi
 *
 * @param request DeployHttpApiRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeployHttpApiResponse
 */
@context("deployHttpApiWithContext")
async function deployHttpApiWithOptions(httpApiId: string, request: DeployHttpApiRequest, headers: map[string]string, runtime: $RuntimeOptions): DeployHttpApiResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.httpApiConfig)) {
    body['httpApiConfig'] = request.httpApiConfig;
  }
  if (!$isNull(request.restApiConfig)) {
    body['restApiConfig'] = request.restApiConfig;
  }
  if (!$isNull(request.routeId)) {
    body['routeId'] = request.routeId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeployHttpApi',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis/${$URL.percentEncode(httpApiId)}/deploy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deploy HttpApi
 *
 * @param request DeployHttpApiRequest
 * @return DeployHttpApiResponse
 */
async function deployHttpApi(httpApiId: string, request: DeployHttpApiRequest): DeployHttpApiResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deployHttpApiWithOptions(httpApiId, request, headers, runtime);
}

model DeployMcpServerResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The status message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='393E2630-DBE7-5221-AB35-9E740675491A'),
}

model DeployMcpServerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeployMcpServerResponseBody(name='body'),
}

/**
 * @summary Deploys an MCP server.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeployMcpServerResponse
 */
@context("deployMcpServerWithContext")
async function deployMcpServerWithOptions(mcpServerId: string, headers: map[string]string, runtime: $RuntimeOptions): DeployMcpServerResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DeployMcpServer',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/mcp-servers/${$URL.percentEncode(mcpServerId)}/deploy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deploys an MCP server.
 *
 * @return DeployMcpServerResponse
 */
async function deployMcpServer(mcpServerId: string): DeployMcpServerResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deployMcpServerWithOptions(mcpServerId, headers, runtime);
}

model ExportHttpApiResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    specContentBase64?: string(name='specContentBase64', description='The Base64-encoded API definition.', example='b3BlbmFwaTogMy4wLjAKaW5mbzoKICAgIHRpdGxlOiBkZW1vCiAgICBkZXNjcmlwdGlvbjogdGhpc2lzZGVtbwogICAgdmVyc2lvbjogIiIKcGF0aHM6CiAgICAvdXNlci97dXNlcklkfToKICAgICAgICBnZXQ6CiAgICAgICAgICAgIHN1bW1hcnk6IOiOt+WPlueUqOaIt+S/oeaBrwogICAgICAgICAgICBkZXNjcmlwdGlvbjog6I635Y+W55So5oi35L+h5oGvCiAgICAgICAgICAgIG9wZXJhdGlvbklkOiBHZXRVc2VySW5mbwogICAgICAgICAgICByZXNwb25zZXM6CiAgICAgICAgICAgICAgICAiMjAwIjoKICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjog5oiQ5YqfCiAgICAgICAgICAgICAgICAgICAgY29udGVudDoKICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBudWxsCnNlcnZlcnM6CiAgICAtIHVybDogaHR0cDovL2FwaS5leGFtcGxlLmNvbS92MQo='),
  }(name='data', description='The API definition.'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='4BACB05C-3FE2-588F-9148-700C5C026B74'),
}

model ExportHttpApiResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExportHttpApiResponseBody(name='body'),
}

/**
 * @summary Exports an HTTP API.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportHttpApiResponse
 */
@context("exportHttpApiWithContext")
async function exportHttpApiWithOptions(httpApiId: string, headers: map[string]string, runtime: $RuntimeOptions): ExportHttpApiResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ExportHttpApi',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis/${$URL.percentEncode(httpApiId)}/export`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Exports an HTTP API.
 *
 * @return ExportHttpApiResponse
 */
async function exportHttpApi(httpApiId: string): ExportHttpApiResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return exportHttpApiWithOptions(httpApiId, headers, runtime);
}

model GetConsumerResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    akSkIdentityConfigs?: [
      AkSkIdentityConfig
    ](name='akSkIdentityConfigs', description='The AK/SK authentication configurations.'),
    apiKeyIdentityConfig?: ApiKeyIdentityConfig(name='apiKeyIdentityConfig', description='The API key authentication configurations.'),
    consumerId?: string(name='consumerId', description='The consumer ID.', example='cs-cvgbtk6m1hkji5sb8dr0'),
    createTimestamp?: long(name='createTimestamp', description='The creation timestamp.', example='1719386834548'),
    deployStatus?: string(name='deployStatus', description='The publishing status of the API in the current environment.', example='""'),
    description?: string(name='description', description='The description.', example='This is the description.'),
    enable?: boolean(name='enable', description='Indicates if enabled.', example='true'),
    jwtIdentityConfig?: JwtIdentityConfig(name='jwtIdentityConfig', description='The JWT authentication configurations.'),
    name?: string(name='name', description='The consumer name.', example='consumer-1'),
    updateTimestamp?: long(name='updateTimestamp', description='The last update timestamp.', example='1719386834548'),
  }(name='data', description='The response payload.'),
  message?: string(name='message', description='The status message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='880C61B3-7B90-5570-A3F7-D6D92C0E2D36'),
}

model GetConsumerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetConsumerResponseBody(name='body'),
}

/**
 * @summary Obtains the information of a consumer.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetConsumerResponse
 */
@context("getConsumerWithContext")
async function getConsumerWithOptions(consumerId: string, headers: map[string]string, runtime: $RuntimeOptions): GetConsumerResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetConsumer',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/consumers/${$URL.percentEncode(consumerId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the information of a consumer.
 *
 * @return GetConsumerResponse
 */
async function getConsumer(consumerId: string): GetConsumerResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getConsumerWithOptions(consumerId, headers, runtime);
}

model GetConsumerAuthorizationRuleResponseBody = {
  apiInfo?: HttpApiApiInfo(name='apiInfo', description='The API information.'),
  consumerAuthorizationRuleId?: string(name='consumerAuthorizationRuleId', description='Filters the list of operations by a specific consumer authorization rule ID. Only authorized operations are returned in the response.', example='car-ctgdn8em1hko5krqq03g'),
  consumerId?: string(name='consumerId', description='The consumer ID.', example='cs-ctgdn2um1hkossul8gvg'),
  createTimestamp?: long(name='createTimestamp', description='The creation timestamp. Unit: milliseconds.', example='1750852089975'),
  deployStatus?: string(name='deployStatus', description='The publishing status of the API in the current environment.', example='""'),
  environmentInfo?: EnvironmentInfo(name='environmentInfo', description='The environment information.'),
  expireMode?: string(name='expireMode', description='The expiry mode. Valid values: LongTerm and ShortTerm.', example='LongTerm'),
  expireStatus?: string(name='expireStatus', description='The rule status.', example='true'),
  expireTimestamp?: long(name='expireTimestamp', description='The expiration time.', example='1750852089975'),
  gatewayInfo?: GatewayInfo(name='gatewayInfo', description='The gateway information.'),
  requestId?: string(name='requestId', description='The request ID.', example='53102737-1E4E-5A8B-8E0A-4184B0959B84'),
  resourceType?: string(name='resourceType', description='The resource type.', example='API'),
  updateTimestamp?: long(name='updateTimestamp', description='The update timestamp. Unit: milliseconds.', example='1750852089975'),
}

model GetConsumerAuthorizationRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetConsumerAuthorizationRuleResponseBody(name='body'),
}

/**
 * @summary Obtains a consumer authentication rule.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetConsumerAuthorizationRuleResponse
 */
@context("getConsumerAuthorizationRuleWithContext")
async function getConsumerAuthorizationRuleWithOptions(consumerAuthorizationRuleId: string, consumerId: string, headers: map[string]string, runtime: $RuntimeOptions): GetConsumerAuthorizationRuleResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetConsumerAuthorizationRule',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/consumers/${$URL.percentEncode(consumerId)}/authorization-rules/${$URL.percentEncode(consumerAuthorizationRuleId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a consumer authentication rule.
 *
 * @return GetConsumerAuthorizationRuleResponse
 */
async function getConsumerAuthorizationRule(consumerAuthorizationRuleId: string, consumerId: string): GetConsumerAuthorizationRuleResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getConsumerAuthorizationRuleWithOptions(consumerAuthorizationRuleId, consumerId, headers, runtime);
}

model GetDashboardRequest {
  acceptLanguage?: string(name='acceptLanguage', description='The language. Valid values: zh (Chinese) and en (English).', example='zh'),
  apiId?: string(name='apiId', description='API ID', example='api-c9uuekzmia8q2****'),
  filter?: {
    routeName?: string(name='routeName', description='The route name.', example='test-route'),
  }(name='filter', description='The filter configurations.'),
  name?: string(name='name', description='The dashboard name.

*   LOG: access logs
*   PLUGIN: plug-in logs', example='PLUGIN'),
  pluginClassId?: string(name='pluginClassId', description='The plug-in type ID.', example='pls-dn82a9djd8z****'),
  pluginId?: string(name='pluginId', description='The plug-in ID.', example='inner-ai-search-cvd3mcum1hks660icn10'),
  routeId?: string(name='routeId', description='The route ID.', example='route-xxx'),
  source?: string(name='source', description='The dashboard source. Valid values:

*   SLS: Simple Log Service', example='SLS'),
  upstreamCluster?: string(name='upstreamCluster', description='The AI service identifier.', example='outbound|443||ds.ai'),
}

model GetDashboardShrinkRequest {
  acceptLanguage?: string(name='acceptLanguage', description='The language. Valid values: zh (Chinese) and en (English).', example='zh'),
  apiId?: string(name='apiId', description='API ID', example='api-c9uuekzmia8q2****'),
  filterShrink?: string(name='filter', description='The filter configurations.'),
  name?: string(name='name', description='The dashboard name.

*   LOG: access logs
*   PLUGIN: plug-in logs', example='PLUGIN'),
  pluginClassId?: string(name='pluginClassId', description='The plug-in type ID.', example='pls-dn82a9djd8z****'),
  pluginId?: string(name='pluginId', description='The plug-in ID.', example='inner-ai-search-cvd3mcum1hks660icn10'),
  routeId?: string(name='routeId', description='The route ID.', example='route-xxx'),
  source?: string(name='source', description='The dashboard source. Valid values:

*   SLS: Simple Log Service', example='SLS'),
  upstreamCluster?: string(name='upstreamCluster', description='The AI service identifier.', example='outbound|443||ds.ai'),
}

model GetDashboardResponseBody = {
  code?: int32(name='code', description='The HTTP status code.', example='200'),
  data?: {
    gatewayId?: string(name='gatewayId', description='The instance ID.', example='gw-co370icmjeu****'),
    name?: string(name='name', description='The dashboard name.', example='PLUGIN'),
    title?: string(name='title', description='The dashboard title.', example='APIG Plugin'),
    url?: string(name='url', description='The dashboard URL.', example='https://sls.console.aliyun.com/lognext/project/xxxxx'),
  }(name='data', description='The data returned.'),
  errorCode?: string(name='errorCode', description='The error code.', example='Ok'),
  message?: string(name='message', description='The error message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='2F46B9E7-67EF-5C8A-BA52-D38D5B32AF2C'),
  success?: boolean(name='success', description='Indicates whether the request was successful.', example='true'),
}

model GetDashboardResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDashboardResponseBody(name='body'),
}

/**
 * @summary Obtains data from dashboards.
 *
 * @param tmpReq GetDashboardRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDashboardResponse
 */
@context("getDashboardWithContext")
async function getDashboardWithOptions(gatewayId: string, tmpReq: GetDashboardRequest, headers: map[string]string, runtime: $RuntimeOptions): GetDashboardResponse {
  tmpReq.validate();
  var request = new GetDashboardShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.filter)) {
    request.filterShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filter, 'filter', 'json');
  }
  var query : map[string]any = {};
  if (!$isNull(request.acceptLanguage)) {
    query['acceptLanguage'] = request.acceptLanguage;
  }
  if (!$isNull(request.apiId)) {
    query['apiId'] = request.apiId;
  }
  if (!$isNull(request.filterShrink)) {
    query['filter'] = request.filterShrink;
  }
  if (!$isNull(request.name)) {
    query['name'] = request.name;
  }
  if (!$isNull(request.pluginClassId)) {
    query['pluginClassId'] = request.pluginClassId;
  }
  if (!$isNull(request.pluginId)) {
    query['pluginId'] = request.pluginId;
  }
  if (!$isNull(request.routeId)) {
    query['routeId'] = request.routeId;
  }
  if (!$isNull(request.source)) {
    query['source'] = request.source;
  }
  if (!$isNull(request.upstreamCluster)) {
    query['upstreamCluster'] = request.upstreamCluster;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDashboard',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/gateways/${$URL.percentEncode(gatewayId)}/dashboards`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains data from dashboards.
 *
 * @param request GetDashboardRequest
 * @return GetDashboardResponse
 */
async function getDashboard(gatewayId: string, request: GetDashboardRequest): GetDashboardResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getDashboardWithOptions(gatewayId, request, headers, runtime);
}

model GetDomainRequest {
  withStatistics?: boolean(name='withStatistics', description='Specifies whether to return online resource information.', example='true'),
}

model GetDomainResponseBody = {
  code?: string(name='code', description='The status code returned.', example='Ok'),
  data?: {
    algorithm?: string(name='algorithm', description='The encryption algorithm.', example='RSA'),
    caCertIdentifier?: string(name='caCertIdentifier', description='The CA certificate ID.', example='876****-cn-hangzhou'),
    certIdentifier?: string(name='certIdentifier', description='The certificate ID.', example='645****-cn-hangzhou'),
    certName?: string(name='certName', description='The certificate name.', example='test-cert'),
    clientCACert?: string(name='clientCACert', description='The client CA certificate.', example='-----BEGIN CERTIFICATE-----
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/mpTQwDQYJKoZIhvcNAQEL
BxSbrGeJ8i0576Gn7Qezyho9abZOUhGaPeoB
AIHWWl428uUSG/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy+ZMJ8r4swA4swHwYDVR0jBBgwFoAU
qroVyYKk7ylhcSn+ZMJ8r4swA4swDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG9w0B
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx=
-----END CERTIFICATE-----'),
    createFrom?: string(name='createFrom', description='The creation source.

Valid values:

*   Console
*   Ingress', example='Console'),
    createTimestamp?: long(name='createTimestamp', description='The creation timestamp.', example='1719386834548'),
    default?: boolean(name='default', description='Indicates whether the domain name is the default domain name.', example='false'),
    domainId?: string(name='domainId', description='The ID of the domain name.', example='d-cq1m3utlhtgvgkv7sitg'),
    forceHttps?: boolean(name='forceHttps', description='Indicates whether forcible HTTPS redirection is enabled.', example='false'),
    http2Option?: string(name='http2Option', description='The HTTP/2 configuration.

Valid values:

*   GlobalConfig
*   Close
*   Open', example='Open'),
    issuer?: string(name='issuer', description='The certificate issuer.', example='Alibaba'),
    mTLSEnabled?: boolean(name='mTLSEnabled', description='Indicates whether mutual authentication is enabled.

Valid values:

*   false
*   true', example='false'),
    name?: string(name='name', description='The domain name.', example='abc.com'),
    notAfterTimstamp?: long(name='notAfterTimstamp', description='The expiration time of the certificate.', example='1719386834548'),
    notBeforeTimestamp?: long(name='notBeforeTimestamp', description='The time when the certificate started to take effect.', example='1719386834548'),
    protocol?: string(name='protocol', description='The supported protocol. Valid values:

*   HTTP: Only HTTP is supported.
*   HTTPS: Only HTTPS is supported.', example='HTTP'),
    resourceGroupId?: string(name='resourceGroupId', description='The resource group ID.', example='rg-aekzvlxzgo5b4si'),
    sans?: string(name='sans', description='All domain names that are bound to the certificate.', example='aliyun.com'),
    statisticsInfo?: {
      resourceStatistics?: [
        ResourceStatistic
      ](name='resourceStatistics', description='The resource statistics.'),
      totalCount?: string(name='totalCount', description='The total number of resources.', example='1'),
    }(name='statisticsInfo', description='The information about online resources.'),
    tlsCipherSuitesConfig?: TlsCipherSuitesConfig(name='tlsCipherSuitesConfig', description='The cipher suite configuration.'),
    tlsMax?: string(name='tlsMax', description='The maximum version of the TLS protocol. Up to TLS 1.3 is supported.', example='TLS 1.3'),
    tlsMin?: string(name='tlsMin', description='The minimum version of the TLS protocol. Down to TLS 1.0 is supported.', example='TLS 1.0'),
    updatetimestamp?: long(name='updatetimestamp', description='The update timestamp.', example='1719386834548'),
  }(name='data', description='The response data.'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID, which is used to trace the API call link.', example='3ACFC7A7-45A9-58CF-B2D5-765B60254695'),
}

model GetDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDomainResponseBody(name='body'),
}

/**
 * @summary Queries the information about a domain name.
 *
 * @param request GetDomainRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDomainResponse
 */
@context("getDomainWithContext")
async function getDomainWithOptions(domainId: string, request: GetDomainRequest, headers: map[string]string, runtime: $RuntimeOptions): GetDomainResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.withStatistics)) {
    query['withStatistics'] = request.withStatistics;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDomain',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/domains/${$URL.percentEncode(domainId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about a domain name.
 *
 * @param request GetDomainRequest
 * @return GetDomainResponse
 */
async function getDomain(domainId: string, request: GetDomainRequest): GetDomainResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getDomainWithOptions(domainId, request, headers, runtime);
}

model GetEnvironmentRequest {
  withStatistics?: boolean(name='withStatistics', description='The request ID, which is used to trace the API call link.', example='true'),
  withVpcInfo?: boolean(name='withVpcInfo', description='Schema of Response', example='true'),
}

model GetEnvironmentResponseBody = {
  code?: string(name='code', description='The response message returned.', example='Ok'),
  data?: {
    alias?: string(name='alias', description='Test environment', example='The environment description.'),
    createTimestamp?: long(name='createTimestamp', description='The update timestamp.', example='1719386834548'),
    default?: boolean(name='default', description='The creation timestamp.', example='true'),
    description?: string(name='description', description='Testing environment for xx project of xxx', example='The instance information.'),
    environmentId?: string(name='environmentId', description='The environment name.', example='env-cq7l5s5lhtgi6qasrdc0'),
    gatewayInfo?: GatewayInfo(name='gatewayInfo', description='The subdomains.'),
    name?: string(name='name', description='The environment alias.', example='test'),
    resourceGroupId?: string(name='resourceGroupId', description='rg-aekzzzntl5njbpi', example='rg-aekz4us4iruleja'),
    statisticsInfo?: {
      resourceStatistics?: [
        ResourceStatistic
      ](name='resourceStatistics', description='4'),
      totalCount?: int32(name='totalCount', description='The total number of entries.', example='1'),
    }(name='statisticsInfo', description='The information about online resources.'),
    subDomainInfos?: [
      SubDomainInfo
    ](name='subDomainInfos', description='The subdomain information.'),
    updateTimestamp?: long(name='updateTimestamp', description='The resource group ID.', example='1719386834548'),
  }(name='data', description='The environment ID.'),
  message?: string(name='message', description='The response data.', example='success'),
  requestId?: string(name='requestId', description='The status code returned.', example='3F8EE674-BB08-5E92-BE6F-E4756A748B0F'),
}

model GetEnvironmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEnvironmentResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI GetEnvironment is deprecated
 *
 * @summary Queries an environment.
 *
 * @param request GetEnvironmentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEnvironmentResponse
 */
// Deprecated
@context("getEnvironmentWithContext")
async function getEnvironmentWithOptions(environmentId: string, request: GetEnvironmentRequest, headers: map[string]string, runtime: $RuntimeOptions): GetEnvironmentResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.withStatistics)) {
    query['withStatistics'] = request.withStatistics;
  }
  if (!$isNull(request.withVpcInfo)) {
    query['withVpcInfo'] = request.withVpcInfo;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetEnvironment',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/environments/${$URL.percentEncode(environmentId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @deprecated OpenAPI GetEnvironment is deprecated
 *
 * @summary Queries an environment.
 *
 * @param request GetEnvironmentRequest
 * @return GetEnvironmentResponse
 */
// Deprecated
async function getEnvironment(environmentId: string, request: GetEnvironmentRequest): GetEnvironmentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getEnvironmentWithOptions(environmentId, request, headers, runtime);
}

model GetGatewayResponseBody = {
  code?: string(name='code', description='The environment alias.', example='Ok'),
  data?: {
    chargeType?: string(name='chargeType', description='The vSwitch associated with the instance.', example='POSTPAY'),
    createFrom?: string(name='createFrom', description='The mode in which the load balancer is provided. Valid values:

*   Managed: Cloud-native API Gateway manages and provides the load balancer.', example='Console'),
    createTimestamp?: long(name='createTimestamp', description='The zone ID.', example='1719386834548'),
    environments?: [ 
      {
        alias?: string(name='alias', description='The port information.', example='The protocol. Valid values:

*   TCP
*   UDP'),
        environmentId?: string(name='environmentId', description='The load balancer type. Valid values:

*   NLB: Network Load Balancer
*   CLB: Classic Load Balancer', example='env-cp9uhudlht***'),
        name?: string(name='name', description='The list of listened ports.', example='default-gw-cp9ugg5***'),
      }
    ](name='environments', description='The IP version of the address. Valid values:

*   ipv4
*   ipv6'),
    expireTimestamp?: long(name='expireTimestamp', description='The ingress information.', example='1719386834548'),
    gatewayEdition?: string(name='gatewayEdition', description='gatewayEdition', example='Serverless'),
    gatewayId?: string(name='gatewayId', description='The security group ID.', example='gw-cq2vundlhtg***'),
    gatewayType?: string(name='gatewayType', description='The vSwitch ID.', example='API'),
    isp?: string(name='isp', description='The ISP type for traffic routing', example='BGP'),
    loadBalancers?: [ 
      {
        address?: string(name='address', description='The IP address of the load balancer', example='nlb-xoh3pghr***.cn-hangzhou.nlb.aliyuncs.com'),
        addressIpVersion?: string(name='addressIpVersion', description='The IP version of the load balancer address', example='ipv4'),
        addressType?: string(name='addressType', description='The address type of the load balancer', example='Internet'),
        gatewayDefault?: boolean(name='gatewayDefault', description='Whether this is the default gateway ingress', example='true'),
        ipv4Addresses?: [ string ](name='ipv4Addresses', description='List of IPv4 addresses'),
        ipv6Addresses?: [ string ](name='ipv6Addresses', description='List of IPv6 addresses'),
        loadBalancerId?: string(name='loadBalancerId', description='The unique identifier of the load balancer', example='nlb-xoh3pghru7c***'),
        mode?: string(name='mode', description='The mode of the load balancer', example='Managed'),
        ports?: [ 
          {
            port?: int32(name='port', description='The listening port number', example='443'),
            protocol?: string(name='protocol', description='The protocol of the port', example='TCP'),
          }
        ](name='ports', description='List of port configurations for the load balancer'),
        status?: string(name='status', description='The current status of the load balancer', example='Ready'),
        type?: string(name='type', description='The type of load balancer', example='NLB'),
      }
    ](name='loadBalancers', description='loadBalancers'),
    maintenancePeriod?: {
      endTime?: string(name='endTime', description='The maintenance end time', example='06:00'),
      startTime?: string(name='startTime', description='The maintenance start time', example='02:00'),
    }(name='maintenancePeriod', description='The maintenance period configuration'),
    name?: string(name='name', description='The security group name.', example='itemcenter-gateway'),
    replicas?: string(name='replicas', description='HangzhouZoneE', example='2'),
    resourceGroupId?: string(name='resourceGroupId', description='The resource group ID', example='rg-acfm2ij6pwxsvua'),
    securityGroup?: {
      name?: string(name='name', description='The resource group ID.', example='APIG-sg-gw-cq7ke5ll***'),
      securityGroupId?: string(name='securityGroupId', description='The load balancer status. Valid values:

*   Ready: The load balancer is available.
*   NotCreate: The load balancer is not associated with the instance.', example='sg-bp16tafq9***'),
    }(name='securityGroup', description='The port number.'),
    spec?: string(name='spec', description='The zone name.', example='apigw.small.x1'),
    status?: string(name='status', description='The VPC associated with the instance.', example='Running'),
    tags?: [ 
      {
        key?: string(name='key', description='The tag key', example='owner'),
        value?: string(name='value', description='The tag value', example='zhangsan'),
      }
    ](name='tags', description='List of tags associated with the gateway'),
    targetVersion?: string(name='targetVersion', description='The load balancer address type. Valid values:

*   Internet
*   Intranet', example='2.0.2'),
    updateTimestamp?: long(name='updateTimestamp', description='The ingress addresses of the instance.', example='1719386834548'),
    vSwitch?: {
      name?: string(name='name', description='The resource tags.', example='The resource tag.'),
      vSwitchId?: string(name='vSwitchId', description='The tag value.', example='vsw-bp1c7ggkj***'),
    }(name='vSwitch', description='rg-aek2s3cvc4jzfxi'),
    version?: string(name='version', description='The load balancer IP address.', example='2.0.2'),
    vpc?: {
      name?: string(name='name', description='=', example='$.errorCode'),
      vpcId?: string(name='vpcId', description='Query Gateway Details', example='vpc-bp1llj52lvj6xc***'),
    }(name='vpc', description='The tag key.'),
    zones?: [ 
      {
        name?: string(name='name', description='The zone name', example='Hangzhou Zone I'),
        vSwitch?: {
          name?: string(name='name', description='The VSwitch name', example='vswitch-name'),
          vSwitchId?: string(name='vSwitchId', description='The VSwitch ID', example='vsw-bp1c7ggkj***'),
        }(name='vSwitch', description='The VSwitch information in the zone'),
        zoneId?: string(name='zoneId', description='The zone ID', example='cn-hangzhou-e'),
      }
    ](name='zones', description='List of zone information'),
  }(name='data', description='The security group of the instance.'),
  message?: string(name='message', description='Default environment', example='success'),
  requestId?: string(name='requestId', description='The environment name.', example='0F138FFC-6E2B-56C1-9BAB-A67462E339D1'),
}

model GetGatewayResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetGatewayResponseBody(name='body'),
}

/**
 * @summary Queries the basic information about an instance, such as the virtual private cloud (VPC) and vSwitch to which the instance belongs and its ingress.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetGatewayResponse
 */
@context("getGatewayWithContext")
async function getGatewayWithOptions(gatewayId: string, headers: map[string]string, runtime: $RuntimeOptions): GetGatewayResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetGateway',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/gateways/${$URL.percentEncode(gatewayId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the basic information about an instance, such as the virtual private cloud (VPC) and vSwitch to which the instance belongs and its ingress.
 *
 * @return GetGatewayResponse
 */
async function getGateway(gatewayId: string): GetGatewayResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getGatewayWithOptions(gatewayId, headers, runtime);
}

model GetHttpApiResponseBody = {
  code?: string(name='code', description='Response status code.', example='Ok'),
  data?: HttpApiApiInfo(name='data', description='The API information.'),
  message?: string(name='message', description='Response message.', example='success'),
  requestId?: string(name='requestId', description='Request ID.', example='8FA9BB94-915B-5299-A694-49FCC7F5DD00'),
}

model GetHttpApiResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetHttpApiResponseBody(name='body'),
}

/**
 * @summary Read HttpApi
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHttpApiResponse
 */
@context("getHttpApiWithContext")
async function getHttpApiWithOptions(httpApiId: string, headers: map[string]string, runtime: $RuntimeOptions): GetHttpApiResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetHttpApi',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis/${$URL.percentEncode(httpApiId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Read HttpApi
 *
 * @return GetHttpApiResponse
 */
async function getHttpApi(httpApiId: string): GetHttpApiResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getHttpApiWithOptions(httpApiId, headers, runtime);
}

model GetHttpApiOperationResponseBody = {
  code?: string(name='code', description='Response status code.', example='Ok'),
  data?: HttpApiOperationInfo(name='data', description='The operation information.'),
  message?: string(name='message', description='Response message.', example='success'),
  requestId?: string(name='requestId', description='Request ID.', example='B725275B-50C6-5A49-A9FD-F0332FCB3351'),
}

model GetHttpApiOperationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetHttpApiOperationResponseBody(name='body'),
}

/**
 * @summary Get Operation
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHttpApiOperationResponse
 */
@context("getHttpApiOperationWithContext")
async function getHttpApiOperationWithOptions(httpApiId: string, operationId: string, headers: map[string]string, runtime: $RuntimeOptions): GetHttpApiOperationResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetHttpApiOperation',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis/${$URL.percentEncode(httpApiId)}/operations/${$URL.percentEncode(operationId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get Operation
 *
 * @return GetHttpApiOperationResponse
 */
async function getHttpApiOperation(httpApiId: string, operationId: string): GetHttpApiOperationResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getHttpApiOperationWithOptions(httpApiId, operationId, headers, runtime);
}

model GetHttpApiRouteResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: HttpRoute(name='data', description='The route details.'),
  message?: string(name='message', description='The returned message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='3ACFC7A7-45A9-58CF-B2D5-765B60254695'),
}

model GetHttpApiRouteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetHttpApiRouteResponseBody(name='body'),
}

/**
 * @summary Queries the details of a route of an HTTP API.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHttpApiRouteResponse
 */
@context("getHttpApiRouteWithContext")
async function getHttpApiRouteWithOptions(httpApiId: string, routeId: string, headers: map[string]string, runtime: $RuntimeOptions): GetHttpApiRouteResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetHttpApiRoute',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis/${$URL.percentEncode(httpApiId)}/routes/${$URL.percentEncode(routeId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a route of an HTTP API.
 *
 * @return GetHttpApiRouteResponse
 */
async function getHttpApiRoute(httpApiId: string, routeId: string): GetHttpApiRouteResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getHttpApiRouteWithOptions(httpApiId, routeId, headers, runtime);
}

model GetMcpServerResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    assembledSources?: [ 
      {
        mcpServerId?: string(name='mcpServerId', description='The ID of the MCP server.', example='mcp-xdafeafzz'),
        mcpServerName?: string(name='mcpServerName', description='The name of the MCP server.', example='test-mcp'),
        tools?: [ string ](name='tools', description='The list of the MCP tools.'),
      }
    ](name='assembledSources', description='The list of assembly sources. This parameter is required when the type parameter is set to AssemblyMCP.'),
    backend?: Backend(name='backend', description='The backend service of the route.'),
    createFromType?: string(name='createFromType', description='Indicates the type of source for MCP server creation. Valid values: 

ApiGatewayHttpToMCP 
ApiGatewayMcpHosting 
ApiGatewayAssembly 
NacosHttpToMCP 
NacosMcpHosting', example='ApiGatewayHttpToMCP'),
    deployStatus?: string(name='deployStatus', description='The publishing status of the API in the current environment.', example='Deployed'),
    description?: string(name='description', description='The description.', example='A sample MCP server'),
    domainIds?: [ string ](name='domainIds', description='The domain name IDs.'),
    domainInfos?: [ 
      {
        domainId?: string(name='domainId', description='The domain name ID.', example='www.abc.com'),
        name?: string(name='name', description='The domain name.', example='verifyicket'),
        protocol?: string(name='protocol', description='The protocol. Valid values: HTTP and HTTPS.', example='HTTP'),
      }
    ](name='domainInfos', description='The list of domain information.'),
    environmentId?: string(name='environmentId', description='The environment ID.', example='env-cq7l5s5lhtgi6qasrdc0'),
    exposedUriPath?: string(name='exposedUriPath', description='The exposed URI path. This parameter is required when the protocol parameter is set to SSE or StreamableHTTP, and the type parameter is set to RealMCP.', example='/sse'),
    gatewayId?: string(name='gatewayId', description='The gateway instance ID.', example='gw-cq2vundlhtg***'),
    grayMcpServerConfigs?: [ 
      {
        backendConfig?: {
          scene?: string(name='scene', description='The backend scene type', example='SingleService'),
          services?: [ 
            {
              port?: int32(name='port', description='The service port', example='8080'),
              protocol?: string(name='protocol', description='The service protocol', example='HTTP'),
              serviceId?: string(name='serviceId', description='The gray service ID', example='svc-xxx'),
              version?: string(name='version', description='The service version', example='v2.0.0'),
              weight?: int32(name='weight', description='The service weight', example='100'),
            }
          ](name='services', description='List of backend services'),
        }(name='backendConfig', description='The gray route backend configuration'),
        match?: HttpRouteMatch(name='match', description='The gray route matching rules'),
        routeId?: string(name='routeId', description='The gray route ID', example='gray-route-xxx'),
      }
    ](name='grayMcpServerConfigs', description='List of gray MCP server configurations'),
    match?: HttpRouteMatch(name='match', description='The route match rule.', example='{\\\\"product_code\\\\":\\\\"apigw\\\\"}'),
    mcpServerConfig?: string(name='mcpServerConfig', description='The HTTP-to-MCP configurations.', example='config-yaml-content'),
    mcpServerConfigPluginAttachmentId?: string(name='mcpServerConfigPluginAttachmentId', description='The attachment ID for the MCP server plug-in configuration.', example='pa-adfaefwaef'),
    mcpServerId?: string(name='mcpServerId', description='The ID of the MCP server.', example='mcp-adfefz24afg'),
    mcpServerPath?: string(name='mcpServerPath', description='The MCP server access path provided by the gateway.', example='/mcp-servers/test-mcp'),
    mcpStatisticsEnable?: boolean(name='mcpStatisticsEnable', description='Indicates whether MCP observability is enabled. Default value: false.', example='false'),
    nacosMcpSyncInfo?: {
      importInstanceId?: string(name='importInstanceId', description='The Nacos instance.', example='mse-xxxxx'),
      importMcpServerId?: string(name='importMcpServerId', description='The synchronized MCP server ID.', example='test-mcp'),
      importNamespace?: string(name='importNamespace', description='The Nacos namespace.', example='test-ns'),
    }(name='nacosMcpSyncInfo', description='The MCP information managed and synchronized by Nacos.'),
    name?: string(name='name', description='The name of the MCP server.', example='test-mcp'),
    protocol?: string(name='protocol', description='The service protocol.', example='HTTP'),
    routeId?: string(name='routeId', description='The route ID.', example='hr-cr82undlhtgrlej***'),
    type?: string(name='type', description='The type of the MCP server.', example='RealMCP'),
  }(name='data', description='The response payload.'),
  message?: string(name='message', description='The status message.', example='Success'),
  requestId?: string(name='requestId', description='The request ID.', example='2A6E90D5-A711-54F4-A489-E33C2021EDDF'),
}

model GetMcpServerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcpServerResponseBody(name='body'),
}

/**
 * @summary Queries the detailed information of an MCP server.
 *
 * @description You can call this operation to create multiple services at a time.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMcpServerResponse
 */
@context("getMcpServerWithContext")
async function getMcpServerWithOptions(mcpServerId: string, headers: map[string]string, runtime: $RuntimeOptions): GetMcpServerResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetMcpServer',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/mcp-servers/${$URL.percentEncode(mcpServerId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the detailed information of an MCP server.
 *
 * @description You can call this operation to create multiple services at a time.
 *
 * @return GetMcpServerResponse
 */
async function getMcpServer(mcpServerId: string): GetMcpServerResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getMcpServerWithOptions(mcpServerId, headers, runtime);
}

model GetPluginAttachmentResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    enable?: boolean(name='enable', description='Indicates whether the plug-in is enabled.', example='true'),
    environmentInfo?: EnvironmentInfo(name='environmentInfo', description='The environment information.'),
    gatewayInfo?: GatewayInfo(name='gatewayInfo', description='The instance information.'),
    parentResourceInfo?: ParentResourceInfo(name='parentResourceInfo', description='The information about the parent resource to which the plug-in is attached.'),
    pluginAttachmentId?: string(name='pluginAttachmentId', description='The attachment ID.', example='pa-d05f1tmm1hku195dd8j0'),
    pluginClassInfo?: PluginClassInfo(name='pluginClassInfo', description='The plug-in type information.'),
    pluginConfig?: string(name='pluginConfig', description='The Base64-encoded configurations of the plug-in.', example='cHJlcGVuZDoKLSByb2xlOiBzeXN0ZW0KICBjb250ZW50OiDor7fkvb/nlKjoi7Hor63lm57nrZTpl67popgKYXBwZW5kOgotIHJvbGU6IHVzZXIKICBjb250ZW50OiDmr4/mrKHlm57nrZTlrozpl67popjvvIzlsJ3or5Xov5vooYzlj43pl64K'),
    pluginId?: string(name='pluginId', description='The plug-in ID.', example='pl-cvo8ub6m1hkvgv03r3k0'),
    resourceInfos?: [
      ResourceInfo
    ](name='resourceInfos', description='The resource information.'),
  }(name='data', description='The response payload.'),
  message?: string(name='message', description='The status message.', example='success'),
  requestId?: string(name='requestId', description='Id of the request', example='C61E30D3-579A-5B43-994E-31E02EDC9129'),
}

model GetPluginAttachmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPluginAttachmentResponseBody(name='body'),
}

/**
 * @summary Queries a plug-in attachment.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPluginAttachmentResponse
 */
@context("getPluginAttachmentWithContext")
async function getPluginAttachmentWithOptions(pluginAttachmentId: string, headers: map[string]string, runtime: $RuntimeOptions): GetPluginAttachmentResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetPluginAttachment',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/plugin-attachments/${$URL.percentEncode(pluginAttachmentId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a plug-in attachment.
 *
 * @return GetPluginAttachmentResponse
 */
async function getPluginAttachment(pluginAttachmentId: string): GetPluginAttachmentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getPluginAttachmentWithOptions(pluginAttachmentId, headers, runtime);
}

model GetPolicyResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: PolicyDetailInfo(name='data', description='The data returned.'),
  message?: string(name='message', description='The returned message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='2F46B9E7-67EF-5C8A-BA52-D38D5B32A***'),
}

model GetPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPolicyResponseBody(name='body'),
}

/**
 * @summary Queries a policy.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPolicyResponse
 */
@context("getPolicyWithContext")
async function getPolicyWithOptions(policyId: string, headers: map[string]string, runtime: $RuntimeOptions): GetPolicyResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetPolicy',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v2/policies/${$URL.percentEncode(policyId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a policy.
 *
 * @return GetPolicyResponse
 */
async function getPolicy(policyId: string): GetPolicyResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getPolicyWithOptions(policyId, headers, runtime);
}

model GetPolicyAttachmentResponseBody = {
  code?: string(name='code', description='Response code.', example='200'),
  data?: {
    attachResourceId?: string(name='attachResourceId', description='Attached Resource ID', example='op-csbkd9llhtgqhqua***'),
    attachResourceType?: string(name='attachResourceType', description='Attached resource type, HttpApi, GatewayRoute, Operation, GatewayService, GatewayServicePort, Gateway, Domain', example='Operation'),
    config?: string(name='config', description='Policy attachment configuration', example='{"unitNum":1,"timeUnit":"s","enable":true}'),
    environmentId?: string(name='environmentId', description='Environment ID', example='env-cq7l5s5lhtgi6qa***'),
    gatewayId?: string(name='gatewayId', description='Gateway Instance ID', example='gw-cq2vundlhtg***'),
    policyAttachmentId?: string(name='policyAttachmentId', description='Policy Attachment ID', example='pr-cqoojualhtgquuj***'),
    policyId?: string(name='policyId', description='Policy ID', example='p-cq7l5s5bblhtgi6qas***'),
  }(name='data', description='Response data.'),
  message?: string(name='message', description='Response message.', example='success'),
  requestId?: string(name='requestId', description='ID of the request', example='2C3B9A12-3868-5EB9-fBEA-F99E03DD1***'),
}

model GetPolicyAttachmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPolicyAttachmentResponseBody(name='body'),
}

/**
 * @summary Queries a policy attachment.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPolicyAttachmentResponse
 */
@context("getPolicyAttachmentWithContext")
async function getPolicyAttachmentWithOptions(policyAttachmentId: string, headers: map[string]string, runtime: $RuntimeOptions): GetPolicyAttachmentResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetPolicyAttachment',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/policy-attachments/${$URL.percentEncode(policyAttachmentId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a policy attachment.
 *
 * @return GetPolicyAttachmentResponse
 */
async function getPolicyAttachment(policyAttachmentId: string): GetPolicyAttachmentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getPolicyAttachmentWithOptions(policyAttachmentId, headers, runtime);
}

model GetResourceOverviewRequest {
  gatewayType?: string(name='gatewayType', description='The gateway type.', example='AI'),
}

model GetResourceOverviewResponseBody = {
  code?: string(name='code', description='Response status code.', example='Ok'),
  data?: {
    api?: {
      publishedCount?: long(name='publishedCount', description='Number of published APIs.', example='1'),
      totalCount?: long(name='totalCount', description='Number of APIs.', example='1'),
    }(name='api', description='API information.'),
    gateway?: {
      runningCount?: long(name='runningCount', description='Number of running gateways.', example='1'),
      totalCount?: long(name='totalCount', description='Number of gateway instances.', example='1'),
    }(name='gateway', description='Gateway information.'),
    riskOverview?: [ 
      {
        count?: string(name='count', description='The number of instances at a risk level.', example='1'),
        riskDetails?: [ 
          {
            gatewayId?: string(name='gatewayId', description='The gateway ID.', example='gw-xxxxxx'),
            gatewayName?: string(name='gatewayName', description='The gateway name.', example='test-gateway'),
            riskLevel?: string(name='riskLevel', description='The risk level.', example='LOW'),
            riskNames?: [ string ](name='riskNames', description='The risk name list.'),
            score?: string(name='score', description='The risk score.', example='100'),
          }
        ](name='riskDetails', description='The risk details list.'),
        riskLevel?: string(name='riskLevel', description='The risk level.', example='LOW'),
      }
    ](name='riskOverview', description='The risk overview.'),
  }(name='data', description='The resource information.'),
  message?: string(name='message', description='Response message.', example='success'),
  requestId?: string(name='requestId', description='Request ID.', example='DD19A442-93C5-5C97-AFA0-B9C57EBD781B'),
}

model GetResourceOverviewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetResourceOverviewResponseBody(name='body'),
}

/**
 * @summary Get resource overview information
 *
 * @param request GetResourceOverviewRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetResourceOverviewResponse
 */
@context("getResourceOverviewWithContext")
async function getResourceOverviewWithOptions(request: GetResourceOverviewRequest, headers: map[string]string, runtime: $RuntimeOptions): GetResourceOverviewResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.gatewayType)) {
    query['gatewayType'] = request.gatewayType;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetResourceOverview',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/overview/resources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get resource overview information
 *
 * @param request GetResourceOverviewRequest
 * @return GetResourceOverviewResponse
 */
async function getResourceOverview(request: GetResourceOverviewRequest): GetResourceOverviewResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getResourceOverviewWithOptions(request, headers, runtime);
}

model GetSecretResponseBody = {
  code?: string(name='code'),
  data?: {
    createTimestamp?: long(name='createTimestamp'),
    gatewayType?: string(name='gatewayType'),
    kmsConfig?: KMSConfig(name='kmsConfig'),
    name?: string(name='name'),
    referenceCount?: int32(name='referenceCount'),
    secretId?: string(name='secretId'),
    secretSource?: string(name='secretSource'),
    status?: string(name='status'),
    updateTimestamp?: long(name='updateTimestamp'),
  }(name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId', description='Id of the request'),
}

model GetSecretResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSecretResponseBody(name='body'),
}

/**
 * @summary 查询密钥
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSecretResponse
 */
@context("getSecretWithContext")
async function getSecretWithOptions(secretId: string, headers: map[string]string, runtime: $RuntimeOptions): GetSecretResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetSecret',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/secrets/${$URL.percentEncode(secretId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询密钥
 *
 * @return GetSecretResponse
 */
async function getSecret(secretId: string): GetSecretResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getSecretWithOptions(secretId, headers, runtime);
}

model GetSecretValueResponseBody = {
  code?: string(name='code'),
  data?: {
    secretData?: string(name='secretData'),
  }(name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId', description='Id of the request'),
}

model GetSecretValueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSecretValueResponseBody(name='body'),
}

/**
 * @summary 查询密钥值
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSecretValueResponse
 */
@context("getSecretValueWithContext")
async function getSecretValueWithOptions(name: string, headers: map[string]string, runtime: $RuntimeOptions): GetSecretValueResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetSecretValue',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/secrets/name/${$URL.percentEncode(name)}/value`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询密钥值
 *
 * @return GetSecretValueResponse
 */
async function getSecretValue(name: string): GetSecretValueResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getSecretValueWithOptions(name, headers, runtime);
}

model GetServiceResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: Service(name='data', description='The service details.'),
  message?: string(name='message', description='The returned message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='8FA9BB94-915B-5299-A694-49FCC7F5DD00'),
}

model GetServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetServiceResponseBody(name='body'),
}

/**
 * @summary Queries a service.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetServiceResponse
 */
@context("getServiceWithContext")
async function getServiceWithOptions(serviceId: string, headers: map[string]string, runtime: $RuntimeOptions): GetServiceResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetService',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/services/${$URL.percentEncode(serviceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a service.
 *
 * @return GetServiceResponse
 */
async function getService(serviceId: string): GetServiceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceWithOptions(serviceId, headers, runtime);
}

model GetSourceResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    createTimestamp?: long(name='createTimestamp', description='The creation timestamp.', example='1719386834548'),
    gatewayId?: string(name='gatewayId', description='The gateway ID.', example='gw-cq2vundlhtg***'),
    k8SSourceInfo?: {
      clusterId?: string(name='clusterId', description='The ID of the Container Service for Kubernetes (ACK) cluster.', example='c2d290b2d8b5d4935864cace5f0173f31'),
    }(name='k8SSourceInfo', description='Kubernetes source information.'),
    nacosSourceInfo?: {
      address?: string(name='address', description='The endpoint of the Nacos instance.', example='mse'),
      clusterId?: string(name='clusterId', description='The cluster ID.', example='fluss-cn-w7k4hann601'),
      instanceId?: string(name='instanceId', description='The Nacos instance ID.', example='hgprecn-cn-cfn47q7oh001'),
    }(name='nacosSourceInfo', description='The source information when the source type is MSE_NACOS.'),
    name?: string(name='name', description='The name.', example='import-test'),
    resourceGroupId?: string(name='resourceGroupId', description='The resource group ID.', example='rg-aekz4us4iruleja'),
    sourceId?: string(name='sourceId', description='The source ID.', example='src-crdddallhtgt***'),
    type?: string(name='type', description='The type.', example='K8S'),
    updateTimestamp?: long(name='updateTimestamp', description='The update timestamp.', example='1719386834548'),
  }(name='data', description='The response data.'),
  message?: string(name='message', description='The response message.', example='success'),
  requestId?: string(name='requestId', description='Id of the request', example='DE10E3C0-A676-5169-812D-6610AACBFAFF'),
}

model GetSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSourceResponseBody(name='body'),
}

/**
 * @summary Obtains the details of a service source.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSourceResponse
 */
@context("getSourceWithContext")
async function getSourceWithOptions(sourceId: string, headers: map[string]string, runtime: $RuntimeOptions): GetSourceResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetSource',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/sources/${$URL.percentEncode(sourceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the details of a service source.
 *
 * @return GetSourceResponse
 */
async function getSource(sourceId: string): GetSourceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getSourceWithOptions(sourceId, headers, runtime);
}

model GetTraceConfigRequest {
  acceptLanguage?: string(name='acceptLanguage', description='The language in which you want results to be returned. Valid values: zh: Chinese. en: English.', example='zh'),
}

model GetTraceConfigResponseBody = {
  code?: int32(name='code', description='The response code.', example='200'),
  data?: {
    enable?: boolean(name='enable', description='Indicates whether tracing analysis is enabled. Valid values: true and false', example='true'),
    sampleRatio?: int32(name='sampleRatio', description='The sampling rate.', example='50'),
    serviceId?: string(name='serviceId', description='The service ID. This parameter exists when the traceType value is SKYWALKING.', example='ss-co370icmjeu****'),
    servicePort?: string(name='servicePort', description='The service port. This parameter exists when the traceType value is SKYWALKING.', example='8090'),
    traceType?: string(name='traceType', description='The type of tracing analysis. Valid values:

*   XTRACE
*   SKYWALKING
*   OPENTELEMETRY
*   OTSKYWALKING', example='SKYWALKING'),
  }(name='data', description='The data returned.'),
  message?: string(name='message', description='The error message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='2F46B9E7-67EF-5C8A-BA52-D38D5B32AF2C'),
  success?: boolean(name='success', description='Indicates whether the request was successful. Valid values: true false', example='true'),
}

model GetTraceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTraceConfigResponseBody(name='body'),
}

/**
 * @summary Queries the tracing configurations of a Cloud-native API Gateway instance.
 *
 * @param request GetTraceConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTraceConfigResponse
 */
@context("getTraceConfigWithContext")
async function getTraceConfigWithOptions(gatewayId: string, request: GetTraceConfigRequest, headers: map[string]string, runtime: $RuntimeOptions): GetTraceConfigResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.acceptLanguage)) {
    query['acceptLanguage'] = request.acceptLanguage;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetTraceConfig',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/gateways/${$URL.percentEncode(gatewayId)}/trace`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the tracing configurations of a Cloud-native API Gateway instance.
 *
 * @param request GetTraceConfigRequest
 * @return GetTraceConfigResponse
 */
async function getTraceConfig(gatewayId: string, request: GetTraceConfigRequest): GetTraceConfigResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getTraceConfigWithOptions(gatewayId, request, headers, runtime);
}

model ImportHttpApiRequest {
  deployConfigs?: [
    HttpApiDeployConfig
  ](name='deployConfigs', description='The API deployment configuration.'),
  description?: string(name='description', description='The imported API description (255-byte limit). If not specified, a description is extracted from the API definition file. A maximum of 255 bytes is supported.', example='API for testing'),
  dryRun?: boolean(name='dryRun', description='Specifies whether to perform a precheck. If set to true, a check is performed without actual import.', example='false'),
  gatewayId?: string(name='gatewayId', description='Gateway ID.', example='gw-xxx'),
  mcpRouteId?: string(name='mcpRouteId', description='The MCP route ID.', example='xxx'),
  name?: string(name='name', description='The imported API name. If not specified, a name is extracted from the API definition file. If the API name and versioning configuration already exist, this import will update the existing API definition based on the strategy field.', example='import-test'),
  resourceGroupId?: string(name='resourceGroupId', description='The [resource group ID](https://help.aliyun.com/document_detail/151181.html).', example='rg-acfm3q4zjh7fkki'),
  specContentBase64?: string(name='specContentBase64', description='The Base64-encoded API definition (supports OAS 2.0/OAS 3.0 in YAML/JSON). This parameter has higher priority than the specFileUrl parameter. However, if the file size exceeds 10 MB, use the specFileUrl parameter to pass the definition.', example='b3BlbmFwaTogMy4wLjAKaW5mbzoKICAgIHRpdGxlOiBkZW1vCiAgICBkZXNjcmlwdGlvbjogdGhpc2lzZGVtbwogICAgdmVyc2lvbjogIiIKcGF0aHM6CiAgICAvdXNlci97dXNlcklkfToKICAgICAgICBnZXQ6CiAgICAgICAgICAgIHN1bW1hcnk6IOiOt+WPlueUqOaIt+S/oeaBrwogICAgICAgICAgICBkZXNjcmlwdGlvbjog6I635Y+W55So5oi35L+h5oGvCiAgICAgICAgICAgIG9wZXJhdGlvbklkOiBHZXRVc2VySW5mbwogICAgICAgICAgICByZXNwb25zZXM6CiAgICAgICAgICAgICAgICAiMjAwIjoKICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjog5oiQ5YqfCiAgICAgICAgICAgICAgICAgICAgY29udGVudDoKICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBudWxsCnNlcnZlcnM6CiAgICAtIHVybDogaHR0cDovL2FwaS5leGFtcGxlLmNvbS92MQo='),
  specFileUrl?: string(name='specFileUrl', description='The download URL of the API definition file. Must be either a publicly accessible Object Storage Service (OSS) URL or an OSS intranet endpoint within the same region. Requires download permissions. For OSS URLs that are not publicly readable, refer to [https://www.alibabacloud.com/help/en/oss/user-guide/how-to-obtain-the-url-of-a-single-object-or-the-urls-of-multiple-objects](https://help.aliyun.com/document_detail/39607.html) and use URLs with download permissions. Currently, only OSS URLs are supported.', example='https://my-bucket.oss-cn-hangzhou.aliyuncs.com/my-api/api.yaml'),
  specOssConfig?: {
    bucketName?: string(name='bucketName', description='The OSS bucket name.', example='api-1'),
    objectKey?: string(name='objectKey', description='The full file path in OSS.', example='/test/swagger.json'),
    regionId?: string(name='regionId', description='The region ID.', example='cn-hangzhou'),
  }(name='specOssConfig', description='The OSS configuration details.'),
  strategy?: string(name='strategy', description='The conflict resolution strategy when the API to be imported has the same name and version as an existing one. Valid values:

*   SpecOnly: full override.
*   SpecFirst: Merge with priority on the newly imported file. New APIs are created and existing ones are updated. APIs not included in the file remain unchanged.
*   ExistFirst (default): Merge with priority on existing APIs. New APIs are created but existing ones remain unchanged. If this parameter is not specified, the ExistFirst policy takes effect.', example='ExistFirst'),
  targetHttpApiId?: string(name='targetHttpApiId', description='The target REST API ID for direct updates. If specified, the import operation will directly update the designated API instead of creating new APIs or updating existing APIs based on the name and version. Only REST APIs can be specified.', example='api-xxxx'),
  versionConfig?: HttpApiVersionConfig(name='versionConfig', description='The API versioning configuration. If versioning is enabled, an imported API that matches both the version number and the API name of an existing API will update that API. If versioning is disabled, an imported API that matches the API name of an existing API will update it.'),
}

model ImportHttpApiResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    dryRunInfo?: {
      errorMessages?: [ string ](name='errorMessages', description='The error messages. If an error message is returned, the API fails to be imported.'),
      existHttpApiInfo?: HttpApiApiInfo(name='existHttpApiInfo', description='The existing APIs. If an existing API is returned, the import updates the existing API.'),
      failureComponents?: [ 
        {
          errorMessage?: string(name='errorMessage', description='The error message.', example='The data struct is incorrectly defined.'),
          name?: string(name='name', description='The data struct name.', example='orderDTO'),
        }
      ](name='failureComponents', description='The data structs that fail the dry run.'),
      failureOperations?: [ 
        {
          errorMessage?: string(name='errorMessage', description='The error message.', example='Missing response definition.'),
          method?: string(name='method', description='The HTTP method of the operation.', example='GET'),
          path?: string(name='path', description='The operation path.', example='/v1/orders'),
        }
      ](name='failureOperations', description='The operations that fail the dry run.'),
      successComponents?: [ 
        {
          action?: string(name='action', description='The action that will be performed for the data struct after the dry run.

*   Create: The data struct is created.
*   Update: The data struct is updated.', example='Create'),
          name?: string(name='name', description='The data struct name.', example='userDTO'),
        }
      ](name='successComponents', description='The data structs that pass the dry run.'),
      successOperations?: [ 
        {
          action?: string(name='action', description='The action that will be performed for the operation after the dry run.

*   Create: The operation is created.
*   Update: The operation is updated.', example='Create'),
          method?: string(name='method', description='The HTTP method of the operation.', example='POST'),
          name?: string(name='name', description='The operation name.', example='CreateUser'),
          path?: string(name='path', description='The operation path.', example='/v1/users'),
        }
      ](name='successOperations', description='The operations that pass the dry run.'),
      warningMessages?: [ string ](name='warningMessages', description='The alerts. If an alert is returned, specific operations or structs may fail to be imported.'),
    }(name='dryRunInfo', description='The dry run result.'),
    httpApiId?: string(name='httpApiId', description='The API ID.', example='api-xxx'),
    name?: string(name='name', description='The API name.', example='import-test'),
  }(name='data', description='The API information.'),
  message?: string(name='message', description='The returned message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='CE857A85-251D-5018-8103-A38957D71E20'),
}

model ImportHttpApiResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ImportHttpApiResponseBody(name='body'),
}

/**
 * @summary Imports HTTP APIs. You can call this operation to import OpenAPI 2.0 and OpenAPI 3.0.x definition files to create REST APIs.
 *
 * @param request ImportHttpApiRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportHttpApiResponse
 */
@context("importHttpApiWithContext")
async function importHttpApiWithOptions(request: ImportHttpApiRequest, headers: map[string]string, runtime: $RuntimeOptions): ImportHttpApiResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.deployConfigs)) {
    body['deployConfigs'] = request.deployConfigs;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.dryRun)) {
    body['dryRun'] = request.dryRun;
  }
  if (!$isNull(request.gatewayId)) {
    body['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.mcpRouteId)) {
    body['mcpRouteId'] = request.mcpRouteId;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.specContentBase64)) {
    body['specContentBase64'] = request.specContentBase64;
  }
  if (!$isNull(request.specFileUrl)) {
    body['specFileUrl'] = request.specFileUrl;
  }
  if (!$isNull(request.specOssConfig)) {
    body['specOssConfig'] = request.specOssConfig;
  }
  if (!$isNull(request.strategy)) {
    body['strategy'] = request.strategy;
  }
  if (!$isNull(request.targetHttpApiId)) {
    body['targetHttpApiId'] = request.targetHttpApiId;
  }
  if (!$isNull(request.versionConfig)) {
    body['versionConfig'] = request.versionConfig;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ImportHttpApi',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis/import`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Imports HTTP APIs. You can call this operation to import OpenAPI 2.0 and OpenAPI 3.0.x definition files to create REST APIs.
 *
 * @param request ImportHttpApiRequest
 * @return ImportHttpApiResponse
 */
async function importHttpApi(request: ImportHttpApiRequest): ImportHttpApiResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return importHttpApiWithOptions(request, headers, runtime);
}

model InstallPluginRequest {
  gatewayIds?: [ string ](name='gatewayIds', description='The list of gateway IDs.'),
  pluginClassId?: string(name='pluginClassId', description='The plug-in type ID.', example='pls-csqmjndlhtguk0loef21'),
}

model InstallPluginResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    installPluginResults?: [ 
      {
        gatewayId?: string(name='gatewayId', description='The gateway ID.', example='gw-d28mjcmm1hkub84mdbi0'),
        pluginId?: string(name='pluginId', description='The plug-in ID.', example='pl-cvs7gbum1hkhs6us6vbg'),
      }
    ](name='installPluginResults', description='The installation result.'),
  }(name='data', description='The response payload.'),
  message?: string(name='message', description='The status message.', example='Success'),
  requestId?: string(name='requestId', description='The request ID.', example='201CFCA0-3AF5-52D0-A0F3-FBA697AF55CB'),
}

model InstallPluginResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallPluginResponseBody(name='body'),
}

/**
 * @summary Installs a plug-in.
 *
 * @param request InstallPluginRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallPluginResponse
 */
@context("installPluginWithContext")
async function installPluginWithOptions(request: InstallPluginRequest, headers: map[string]string, runtime: $RuntimeOptions): InstallPluginResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.gatewayIds)) {
    body['gatewayIds'] = request.gatewayIds;
  }
  if (!$isNull(request.pluginClassId)) {
    body['pluginClassId'] = request.pluginClassId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'InstallPlugin',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/plugins/`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Installs a plug-in.
 *
 * @param request InstallPluginRequest
 * @return InstallPluginResponse
 */
async function installPlugin(request: InstallPluginRequest): InstallPluginResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return installPluginWithOptions(request, headers, runtime);
}

model ListConsumerAuthorizationRulesRequest {
  apiNameLike?: string(name='apiNameLike', example='qwen3'),
  pageNumber?: int32(name='pageNumber', example='1'),
  pageSize?: int32(name='pageSize', example='10'),
}

model ListConsumerAuthorizationRulesResponseBody = {
  code?: string(name='code', example='Ok'),
  data?: {
    items?: [ 
      {
        apiInfo?: HttpApiApiInfo(name='apiInfo'),
        consumerAuthorizationRuleId?: string(name='consumerAuthorizationRuleId', example='car-csgeka5lhtggrjcprok0'),
        consumerId?: string(name='consumerId', example='cs-csheiftlhtgmp0j0hp4g'),
        createTimestamp?: long(name='createTimestamp', example='1719386834548'),
        deployStatus?: string(name='deployStatus', example='{}'),
        environmentInfo?: EnvironmentInfo(name='environmentInfo'),
        expireMode?: string(name='expireMode', example='ShortTerm'),
        expireStatus?: string(name='expireStatus', example='InEffect'),
        expireTimestamp?: long(name='expireTimestamp', example='172086834548'),
        gatewayInfo?: GatewayInfo(name='gatewayInfo'),
        resourceId?: string(name='resourceId', example='2351944'),
        resourceType?: string(name='resourceType', example='HttpApiRoute'),
        updateTimestamp?: long(name='updateTimestamp', example='1721116090326'),
      }
    ](name='items'),
    pageNumber?: int32(name='pageNumber', example='1'),
    pageSize?: int32(name='pageSize', example='10'),
    totalSize?: string(name='totalSize', example='9'),
  }(name='data'),
  message?: string(name='message', example='success'),
  requestId?: string(name='requestId', description='Id of the request', example='294382D9-EE60-5735-A4CD-F2AC2840423D'),
}

model ListConsumerAuthorizationRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListConsumerAuthorizationRulesResponseBody(name='body'),
}

/**
 * @summary 查询消费者授权规则列表
 *
 * @param request ListConsumerAuthorizationRulesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListConsumerAuthorizationRulesResponse
 */
@context("listConsumerAuthorizationRulesWithContext")
async function listConsumerAuthorizationRulesWithOptions(consumerId: string, request: ListConsumerAuthorizationRulesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListConsumerAuthorizationRulesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.apiNameLike)) {
    query['apiNameLike'] = request.apiNameLike;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListConsumerAuthorizationRules',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/consumers/${$URL.percentEncode(consumerId)}/authorization-rules`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询消费者授权规则列表
 *
 * @param request ListConsumerAuthorizationRulesRequest
 * @return ListConsumerAuthorizationRulesResponse
 */
async function listConsumerAuthorizationRules(consumerId: string, request: ListConsumerAuthorizationRulesRequest): ListConsumerAuthorizationRulesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listConsumerAuthorizationRulesWithOptions(consumerId, request, headers, runtime);
}

model ListConsumersRequest {
  gatewayType?: string(name='gatewayType', description='The instance type. Valid values: **AI** and **API**.', example='AI'),
  nameLike?: string(name='nameLike', description='The name used to perform a fuzzy search for operations.', example='UI-test'),
  pageNumber?: int32(name='pageNumber', description='The page number to return. Pages start from 1. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
}

model ListConsumersResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    items?: [ 
      {
        consumerId?: string(name='consumerId', description='The consumer ID.', example='cs-csheiftlhtgmp0j0hp4g'),
        createTimestamp?: long(name='createTimestamp', description='The creation timestamp.', example='1721097861050'),
        deployStatus?: string(name='deployStatus', description='The deployment status of the API in the current environment.', example='{}'),
        description?: string(name='description', description='The description.', example='This is the description.'),
        enable?: boolean(name='enable', description='Indicates if enabled.', example='true'),
        name?: string(name='name', description='The consumer name.', example='user-service'),
        updateTimestamp?: long(name='updateTimestamp', description='The last update timestamp.', example='1721123855214'),
      }
    ](name='items', description='The list of consumer information.'),
    pageNumber?: int32(name='pageNumber', description='The page number.', example='1'),
    pageSize?: int32(name='pageSize', description='The number of entries per page.', example='10'),
    totalSize?: int32(name='totalSize', description='The total number of entries returned.', example='18'),
  }(name='data', description='The response payload.'),
  message?: string(name='message', description='The status message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='9BDD6A7C-CBA7-504F-B8C5-51B9F16590F7'),
}

model ListConsumersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListConsumersResponseBody(name='body'),
}

/**
 * @summary Queries a list of consumers.
 *
 * @param request ListConsumersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListConsumersResponse
 */
@context("listConsumersWithContext")
async function listConsumersWithOptions(request: ListConsumersRequest, headers: map[string]string, runtime: $RuntimeOptions): ListConsumersResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.gatewayType)) {
    query['gatewayType'] = request.gatewayType;
  }
  if (!$isNull(request.nameLike)) {
    query['nameLike'] = request.nameLike;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListConsumers',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/consumers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of consumers.
 *
 * @param request ListConsumersRequest
 * @return ListConsumersResponse
 */
async function listConsumers(request: ListConsumersRequest): ListConsumersResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listConsumersWithOptions(request, headers, runtime);
}

model ListDomainsRequest {
  gatewayId?: string(name='gatewayId', description='The instance ID.', example='gw-xxx'),
  gatewayType?: string(name='gatewayType', description='The gateway type to filter. Valid values: **AI** and **API**.', example='API'),
  nameLike?: string(name='nameLike', description='The domain name keyword for fuzzy search.', example='test'),
  pageNumber?: int32(name='pageNumber', description='The page number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the resource group.', example='rg-ahr5uil8raz0rq3b'),
}

model ListDomainsResponseBody = {
  code?: string(name='code', description='The status code returned.', example='Ok'),
  data?: {
    items?: [
      DomainInfo
    ](name='items', description='The list of domain information.'),
    pageNumber?: int32(name='pageNumber', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='pageSize', description='The number of entries per page.', example='10'),
    totalSize?: int32(name='totalSize', description='The total number of entries returned.', example='9'),
  }(name='data', description='Response parameters.'),
  message?: string(name='message', description='The message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID, which is used to trace the API call link.', example='C61E30D3-579A-5B43-994E-31E02EDC9129'),
}

model ListDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDomainsResponseBody(name='body'),
}

/**
 * @summary Queries a list of domain names.
 *
 * @param request ListDomainsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDomainsResponse
 */
@context("listDomainsWithContext")
async function listDomainsWithOptions(request: ListDomainsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListDomainsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.gatewayId)) {
    query['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.gatewayType)) {
    query['gatewayType'] = request.gatewayType;
  }
  if (!$isNull(request.nameLike)) {
    query['nameLike'] = request.nameLike;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListDomains',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/domains`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of domain names.
 *
 * @param request ListDomainsRequest
 * @return ListDomainsResponse
 */
async function listDomains(request: ListDomainsRequest): ListDomainsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listDomainsWithOptions(request, headers, runtime);
}

model ListEnvironmentsRequest {
  aliasLike?: string(name='aliasLike', description='Environment alias, fuzzy search.', example='production'),
  gatewayId?: string(name='gatewayId', description='Gateway ID, exact search.', example='gw-cptv6ktlhtgnqr73h8d1'),
  gatewayNameLike?: string(name='gatewayNameLike', description='Gateway name, fuzzy search.', example='test-gw'),
  gatewayType?: string(name='gatewayType', description='The gateway type', example='APIGateway'),
  nameLike?: string(name='nameLike', description='Environment name, fuzzy search.', example='test'),
  pageNumber?: int32(name='pageNumber', description='Page number, default is 1.', example='1'),
  pageSize?: int32(name='pageSize', description='Page size, default is 10.', example='10'),
  resourceGroupId?: string(name='resourceGroupId', description='Resource group ID.', example='rg-aek2sy66mftleiq'),
}

model ListEnvironmentsResponseBody = {
  code?: string(name='code', description='Response code.', example='Ok'),
  data?: {
    items?: [
      EnvironmentInfo
    ](name='items', description='List of environment information.'),
    pageNumber?: int32(name='pageNumber', description='Page number.', example='1'),
    pageSize?: int32(name='pageSize', description='Number of items per page.', example='10'),
    totalSize?: int32(name='totalSize', description='Total number of items.', example='25'),
  }(name='data', description='Paged query environment list response.'),
  message?: string(name='message', description='Response message.', example='success'),
  requestId?: string(name='requestId', description='Request ID, used for tracing the call chain.', example='CE857A85-251D-5018-8103-A38957D71E20'),
}

model ListEnvironmentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEnvironmentsResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI ListEnvironments is deprecated
 *
 * @summary ListEnvironments
 *
 * @param request ListEnvironmentsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListEnvironmentsResponse
 */
// Deprecated
@context("listEnvironmentsWithContext")
async function listEnvironmentsWithOptions(request: ListEnvironmentsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListEnvironmentsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.aliasLike)) {
    query['aliasLike'] = request.aliasLike;
  }
  if (!$isNull(request.gatewayId)) {
    query['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.gatewayNameLike)) {
    query['gatewayNameLike'] = request.gatewayNameLike;
  }
  if (!$isNull(request.gatewayType)) {
    query['gatewayType'] = request.gatewayType;
  }
  if (!$isNull(request.nameLike)) {
    query['nameLike'] = request.nameLike;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListEnvironments',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/environments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @deprecated OpenAPI ListEnvironments is deprecated
 *
 * @summary ListEnvironments
 *
 * @param request ListEnvironmentsRequest
 * @return ListEnvironmentsResponse
 */
// Deprecated
async function listEnvironments(request: ListEnvironmentsRequest): ListEnvironmentsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listEnvironmentsWithOptions(request, headers, runtime);
}

model ListGatewayFeaturesResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    items?: [ 
      {
        definition?: {
          defaultValue?: string(name='defaultValue', description='The default value of the parameter.', example='"true"'),
          description?: string(name='description', description='The parameter description.'),
          displayName?: string(name='displayName', description='The display name of the parameter.', example='EnableGzip'),
          group?: string(name='group', description='The parameter group to which the parameter belongs. Valid values:

*   Telemetry: an observability parameter
*   Engine: an engine parameter', example='Engine'),
          inputType?: string(name='inputType', description='The input type of the parameter. Valid values:

*   Trigger
*   Input
*   SingleSelect
*   MultiSelect', example='Trigger'),
          maxLength?: int32(name='maxLength', description='The maximum length of the value. This parameter is valid when the value type is string.', example='64'),
          maxValue?: string(name='maxValue', description='The maximum value of the parameter. This parameter is valid when the value type is int32, int64, or float.', example='65535'),
          minLength?: int32(name='minLength', description='The minimum length of the value. This parameter is valid when the value type is string.', example='8'),
          minValue?: string(name='minValue', description='The minimum value of the parameter. This parameter is valid when the value type is int32, int64, or float.', example='100'),
          name?: string(name='name', description='The parameter name.', example='enable-gzip'),
          readOnly?: boolean(name='readOnly', description='Indicates whether the parameter is read-only.', example='false'),
          regex?: string(name='regex', description='The regular expression that the parameter value must fulfill. This parameter is valid when the value type is string.', example='[a-z].*'),
          valueOptions?: [ 
            {
              key?: string(name='key', description='The key to pass the parameter.', example='KEEP_UNCHANGED'),
              label?: string(name='label', description='The display value.'),
            }
          ](name='valueOptions', description='The list of options supported by the parameter value.'),
          valueType?: string(name='valueType', description='The value type of the parameter. Valid values:

*   bool: boolean
*   string
*   int32: integer
*   int64: long integer
*   json
*   array: JSON array
*   float: floating point', example='bool'),
          valueUnit?: string(name='valueUnit', description='The value unit.', example='byte'),
        }(name='definition', description='The parameter definition.'),
        value?: string(name='value', description='The parameter value.', example='"true"'),
      }
    ](name='items', description='The list of parameter configurations.'),
  }(name='data', description='The returned data.'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='393E2630-DBE7-5221-AB35-9E740675491A'),
}

model ListGatewayFeaturesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListGatewayFeaturesResponseBody(name='body'),
}

/**
 * @summary Queries the feature parameter configurations of an instance.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGatewayFeaturesResponse
 */
@context("listGatewayFeaturesWithContext")
async function listGatewayFeaturesWithOptions(gatewayId: string, headers: map[string]string, runtime: $RuntimeOptions): ListGatewayFeaturesResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ListGatewayFeatures',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/gateways/${$URL.percentEncode(gatewayId)}/gateway-features`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the feature parameter configurations of an instance.
 *
 * @return ListGatewayFeaturesResponse
 */
async function listGatewayFeatures(gatewayId: string): ListGatewayFeaturesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listGatewayFeaturesWithOptions(gatewayId, headers, runtime);
}

model ListGatewaysRequest {
  gatewayId?: string(name='gatewayId', description='Retrieve the list of created cloud-native gateways', example='gw-cpv4sqdl****'),
  gatewayType?: string(name='gatewayType', description='The search keyword. A full match is performed. The search is case-insensitive.', example='API'),
  keyword?: string(name='keyword', description='The instance name. If you specify a name, an exact search is performed.', example='dev'),
  name?: string(name='name', description='The number of entries per page.', example='itemcenter-gateway'),
  pageNumber?: int32(name='pageNumber', description='The instance ID. If you specify an ID, an exact search is performed.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of the page to return.', example='10'),
  resourceGroupId?: string(name='resourceGroupId', description='rg-aekz3wes3hnre5a', example='rg-aekzq6bzz5uyg2q'),
  tag?: [ 
    {
      key?: string(name='key', description='The key of tag N.', example='owner'),
      value?: string(name='value', description='The value of tag N.', example='zhangsan'),
    }
  ](name='tag', description='The tags that you want to use for the search.'),
}

model ListGatewaysShrinkRequest {
  gatewayId?: string(name='gatewayId', description='Retrieve the list of created cloud-native gateways', example='gw-cpv4sqdl****'),
  gatewayType?: string(name='gatewayType', description='The search keyword. A full match is performed. The search is case-insensitive.', example='API'),
  keyword?: string(name='keyword', description='The instance name. If you specify a name, an exact search is performed.', example='dev'),
  name?: string(name='name', description='The number of entries per page.', example='itemcenter-gateway'),
  pageNumber?: int32(name='pageNumber', description='The instance ID. If you specify an ID, an exact search is performed.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of the page to return.', example='10'),
  resourceGroupId?: string(name='resourceGroupId', description='rg-aekz3wes3hnre5a', example='rg-aekzq6bzz5uyg2q'),
  tagShrink?: string(name='tag', description='The tags that you want to use for the search.'),
}

model ListGatewaysResponseBody = {
  code?: string(name='code', description='The request ID.', example='Ok'),
  data?: {
    items?: [ 
      {
        chargeType?: string(name='chargeType', description='The instance name.', example='POSTPAY'),
        createFrom?: string(name='createFrom', description='Indicates whether the address is the default ingress address of the instance.', example='Console'),
        createTimestamp?: long(name='createTimestamp', description='The load balancer IP address.', example='1719386834548'),
        expireTimestamp?: long(name='expireTimestamp', description='The mode in which the load balancer is provided. Valid values:

*   Managed: Cloud-native API Gateway manages and provides the load balancer.', example='172086834548'),
        gatewayEdition?: string(name='gatewayEdition', description='The gateway edition', example='Serverless'),
        gatewayId?: string(name='gatewayId', description='The information about a gateway.', example='gw-cpv54p5***'),
        gatewayType?: string(name='gatewayType', description='The instance state. Valid values:

*   Running: The instance is running.
*   Creating: The instance is being created.
*   CreateFailed: The instance fails to be created.
*   Upgrading: The instance is being upgraded.
*   UpgradeFailed: The instance fails to be upgraded.
*   Restarting: The instance is being restarted.
*   RestartFailed: The instance fails to be restarted.
*   Deleting: The instance is being released.
*   DeleteFailed: The instance failed to be released.', example='API'),
        legacy?: boolean(name='legacy', description='Whether the gateway is a legacy instance', example='true'),
        loadBalancers?: [ 
          {
            address?: string(name='address', description='vsw-xxxxx', example='nlb-xoh3pghr***.cn-hangzhou.nlb.aliyuncs.com'),
            addressIpVersion?: string(name='addressIpVersion', description='The vSwitch information.', example='ipv4'),
            addressType?: string(name='addressType', description='sg-xxxx', example='Internet'),
            gatewayDefault?: boolean(name='gatewayDefault', description='vsw-xxxxx', example='true'),
            ipv4Addresses?: [ string ](name='ipv4Addresses', description='The IPv4 addresses'),
            ipv6Addresses?: [ string ](name='ipv6Addresses', description='The IPv6 addresses'),
            loadBalancerId?: string(name='loadBalancerId', description='The security group ID.', example='nlb-xqwioje1c91r***'),
            mode?: string(name='mode', description='The vSwitch ID.', example='Managed'),
            ports?: [ 
              {
                port?: int32(name='port', description='The resource group ID.', example='443'),
                protocol?: string(name='protocol', description='vpc-xxxxx', example='TCP'),
              }
            ](name='ports', description='The virtual private cloud (VPC) information of the instance.'),
            status?: string(name='status', description='The vSwitch ID.', example='Ready'),
            type?: string(name='type', description='The zone ID.', example='NLB'),
          }
        ](name='loadBalancers', description='The port number.'),
        name?: string(name='name', description='The instance ID.', example='itemcenter-gateway'),
        replicas?: string(name='replicas', description='The load balancer status. Valid values:

*   Ready: The load balancer is available.
*   NotCreate: The load balancer is not associated with the instance.', example='2'),
        resourceGroupId?: string(name='resourceGroupId', description='The resource group ID', example='rg-xxxx'),
        securityGroup?: {
          securityGroupId?: string(name='securityGroupId', description='The tags.', example='sg-bp1apxihjdbt3***'),
        }(name='securityGroup', description='rg-xxx'),
        spec?: string(name='spec', description='The load balancer type. Valid values:

*   NLB: Network Load Balancer
*   CLB: Classic Load Balancer', example='apigw.small.x1'),
        status?: string(name='status', description='The time when the instance was created. This value is a UNIX timestamp. Unit: milliseconds.', example='Running'),
        subDomainInfos?: [
          SubDomainInfo
        ](name='subDomainInfos', description='The subdomain information'),
        tags?: [ 
          {
            key?: string(name='key', description='The tag key', example='owner'),
            value?: string(name='value', description='The tag value', example='zhangsan'),
          }
        ](name='tags', description='The tags'),
        targetVersion?: string(name='targetVersion', description='The protocol. Valid values:

*   TCP
*   UDP', example='2.0.2'),
        updateTimestamp?: long(name='updateTimestamp', description='The IP version of the address. Valid values:

*   ipv4: IPv4
*   ipv6: IPv6', example='1719386834548'),
        vSwitch?: {
          vSwitchId?: string(name='vSwitchId', description='List Gateways', example='vsw-bp14efv***'),
        }(name='vSwitch', description='Indicates whether the gateway instance was created before AI Gateway launch.'),
        version?: string(name='version', description='The information about the port.', example='2.0.2'),
        vpc?: {
          vpcId?: string(name='vpcId', description='The VPC ID', example='vpc-uf664ny***'),
        }(name='vpc', description='The VPC information'),
        zones?: [ 
          {
            vSwitch?: {
              vSwitchId?: string(name='vSwitchId', description='The second-level domain name.', example='vsw-bp14efvkcfbrt4***'),
            }(name='vSwitch', description='The second-level domain names.'),
            zoneId?: string(name='zoneId', description='The tag value.', example='cn-hangzhou-i'),
          }
        ](name='zones', description='The tag.'),
      }
    ](name='items', description='The total number of entries returned.'),
    pageNumber?: int32(name='pageNumber', description='The gateway list query result.', example='1'),
    pageSize?: int32(name='pageSize', description='The page number of the returned page.', example='10'),
    totalSize?: long(name='totalSize', description='The number of entries per page.', example='6'),
  }(name='data', description='The returned message.'),
  message?: string(name='message', description='The status code.', example='success'),
  requestId?: string(name='requestId', description='Schema of Response', example='5B626361-070A-56A7-B127-ADAC8F3655DB'),
}

model ListGatewaysResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListGatewaysResponseBody(name='body'),
}

/**
 * @summary Queries a list of instances.
 *
 * @param tmpReq ListGatewaysRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGatewaysResponse
 */
@context("listGatewaysWithContext")
async function listGatewaysWithOptions(tmpReq: ListGatewaysRequest, headers: map[string]string, runtime: $RuntimeOptions): ListGatewaysResponse {
  tmpReq.validate();
  var request = new ListGatewaysShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.tag)) {
    request.tagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tag, 'tag', 'json');
  }
  var query : map[string]any = {};
  if (!$isNull(request.gatewayId)) {
    query['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.gatewayType)) {
    query['gatewayType'] = request.gatewayType;
  }
  if (!$isNull(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!$isNull(request.name)) {
    query['name'] = request.name;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.tagShrink)) {
    query['tag'] = request.tagShrink;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListGateways',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/gateways`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of instances.
 *
 * @param request ListGatewaysRequest
 * @return ListGatewaysResponse
 */
async function listGateways(request: ListGatewaysRequest): ListGatewaysResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listGatewaysWithOptions(request, headers, runtime);
}

model ListHttpApiOperationsRequest {
  consumerAuthorizationRuleId?: string(name='consumerAuthorizationRuleId', description='Filter the operation list based on a specific consumer authorization rule ID, and the interface list in the response only contains authorized operations.', example='cas-xxx'),
  enableAuth?: boolean(name='enableAuth', description='Filter operations by authentication status', example='true'),
  forDeploy?: boolean(name='forDeploy', description='Whether to filter for deployment scenario', example='true'),
  gatewayId?: string(name='gatewayId', description='The gateway ID', example='gw-001'),
  method?: string(name='method', description='List interfaces by Method.', example='GET'),
  name?: string(name='name', description='Search operations by exact name.', example='getUserInfo'),
  nameLike?: string(name='nameLike', description='Search operations by name prefix.', example='GetUser'),
  pageNumber?: int32(name='pageNumber', description='Page number, starting from 1, default is 1 if not specified.', example='1'),
  pageSize?: int32(name='pageSize', description='Page size, valid range [1, 100], default is 10 if not specified.', example='10'),
  pathLike?: string(name='pathLike', description='Search operations by path prefix.', example='/v1'),
  withConsumerInEnvironmentId?: string(name='withConsumerInEnvironmentId', description='Each operation information in the response carries a list of authorization rules for the specified consumer under the specified environment ID. The withConsumerInEnvironmentId field needs to be additionally specified.', example='env-xxx'),
  withConsumerInfoById?: string(name='withConsumerInfoById', description='Each operation information in the response carries a list of authorization rules for the specified consumer under the specified environment ID. The withConsumerInEnvironmentId field needs to be additionally specified.', example='cs-xxx'),
  withPluginAttachmentByPluginId?: string(name='withPluginAttachmentByPluginId', description='Plugin ID, use this plugin ID to retrieve the plugin release information.', example='pl-xxx'),
}

model ListHttpApiOperationsResponseBody = {
  code?: string(name='code', description='Response status code.', example='Ok'),
  data?: {
    items?: [
      HttpApiOperationInfo
    ](name='items', description='The operations.'),
    pageNumber?: int32(name='pageNumber', description='Page number.', example='1'),
    pageSize?: int32(name='pageSize', description='Page size.', example='10'),
    totalSize?: int32(name='totalSize', description='Total count.', example='10'),
  }(name='data', description='The operations.'),
  message?: string(name='message', description='Response message.', example='success'),
  requestId?: string(name='requestId', description='Request ID.', example='585657D2-1C20-5B8A-AF17-D727C6490BE4'),
}

model ListHttpApiOperationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListHttpApiOperationsResponseBody(name='body'),
}

/**
 * @summary List Operations
 *
 * @param request ListHttpApiOperationsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHttpApiOperationsResponse
 */
@context("listHttpApiOperationsWithContext")
async function listHttpApiOperationsWithOptions(httpApiId: string, request: ListHttpApiOperationsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListHttpApiOperationsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.consumerAuthorizationRuleId)) {
    query['consumerAuthorizationRuleId'] = request.consumerAuthorizationRuleId;
  }
  if (!$isNull(request.enableAuth)) {
    query['enableAuth'] = request.enableAuth;
  }
  if (!$isNull(request.forDeploy)) {
    query['forDeploy'] = request.forDeploy;
  }
  if (!$isNull(request.gatewayId)) {
    query['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.method)) {
    query['method'] = request.method;
  }
  if (!$isNull(request.name)) {
    query['name'] = request.name;
  }
  if (!$isNull(request.nameLike)) {
    query['nameLike'] = request.nameLike;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.pathLike)) {
    query['pathLike'] = request.pathLike;
  }
  if (!$isNull(request.withConsumerInEnvironmentId)) {
    query['withConsumerInEnvironmentId'] = request.withConsumerInEnvironmentId;
  }
  if (!$isNull(request.withConsumerInfoById)) {
    query['withConsumerInfoById'] = request.withConsumerInfoById;
  }
  if (!$isNull(request.withPluginAttachmentByPluginId)) {
    query['withPluginAttachmentByPluginId'] = request.withPluginAttachmentByPluginId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListHttpApiOperations',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis/${$URL.percentEncode(httpApiId)}/operations`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary List Operations
 *
 * @param request ListHttpApiOperationsRequest
 * @return ListHttpApiOperationsResponse
 */
async function listHttpApiOperations(httpApiId: string, request: ListHttpApiOperationsRequest): ListHttpApiOperationsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listHttpApiOperationsWithOptions(httpApiId, request, headers, runtime);
}

model ListHttpApiRoutesRequest {
  consumerAuthorizationRuleId?: string(name='consumerAuthorizationRuleId', description='The string that is used to filter routes based on consumer authentication rules. Only authorized APIs are returned.', example='cas-xxx'),
  deployStatuses?: string(name='deployStatuses', description='The deployment state of the route.

Enumerated values:

*   Deploying: The route is being deployed.
*   DeployedWithChanges: The route is deployed and modified.
*   Undeploying: The route is being undeployed.
*   NotDeployed: The route is not deployed.
*   Deployed: The route is deployed.
*   UndeployFailed: The route failed to be undeployed.
*   DeployFailed: The route failed to be deployed.', example='NotDeployed'),
  domainId?: string(name='domainId', description='Specifies to filter routes by domain ID.', example='d-xxx'),
  environmentId?: string(name='environmentId', description='The environment ID.', example='env-cpqnr6tlhtgubc***'),
  forDeploy?: boolean(name='forDeploy', description='Whether to filter for deployment scenario', example='true'),
  gatewayId?: string(name='gatewayId', description='The ID of the Cloud-native API Gateway instance.', example='gw-cpv4sqdl****'),
  name?: string(name='name', description='The route name.', example='itemcenter-gateway'),
  nameLike?: string(name='nameLike', description='The route name keyword for a fuzzy search.', example='item'),
  pageNumber?: int32(name='pageNumber', description='The page number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Valid values: 1 to 100. Default value: 10.', example='10'),
  pathLike?: string(name='pathLike', description='The route path keyword for a fuzzy search.', example='/v1'),
  withAuthPolicyInfo?: boolean(name='withAuthPolicyInfo', description='The consumer authorization information in the response.', example='true'),
  withConsumerInfoById?: string(name='withConsumerInfoById', description='The authentication rules of the specified consumer in each route returned.', example='cs-xxx'),
  withPluginAttachmentByPluginId?: string(name='withPluginAttachmentByPluginId', description='The mounting information of the specified plug-in in each route returned.', example='pl-xxx'),
}

model ListHttpApiRoutesResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    items?: [
      HttpRoute
    ](name='items', description='The routes.'),
    pageNumber?: int32(name='pageNumber', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='pageSize', description='The number of entries per page.', example='20'),
    totalSize?: int32(name='totalSize', description='The total number of entries returned.', example='9'),
  }(name='data', description='The response payload.'),
  message?: string(name='message', description='The returned message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='CBEEB8C1-108E-50F0-9BEA-DED79553C309'),
}

model ListHttpApiRoutesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListHttpApiRoutesResponseBody(name='body'),
}

/**
 * @summary Queries the routes of an HTTP API.
 *
 * @param request ListHttpApiRoutesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHttpApiRoutesResponse
 */
@context("listHttpApiRoutesWithContext")
async function listHttpApiRoutesWithOptions(httpApiId: string, request: ListHttpApiRoutesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListHttpApiRoutesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.consumerAuthorizationRuleId)) {
    query['consumerAuthorizationRuleId'] = request.consumerAuthorizationRuleId;
  }
  if (!$isNull(request.deployStatuses)) {
    query['deployStatuses'] = request.deployStatuses;
  }
  if (!$isNull(request.domainId)) {
    query['domainId'] = request.domainId;
  }
  if (!$isNull(request.environmentId)) {
    query['environmentId'] = request.environmentId;
  }
  if (!$isNull(request.forDeploy)) {
    query['forDeploy'] = request.forDeploy;
  }
  if (!$isNull(request.gatewayId)) {
    query['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.name)) {
    query['name'] = request.name;
  }
  if (!$isNull(request.nameLike)) {
    query['nameLike'] = request.nameLike;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.pathLike)) {
    query['pathLike'] = request.pathLike;
  }
  if (!$isNull(request.withAuthPolicyInfo)) {
    query['withAuthPolicyInfo'] = request.withAuthPolicyInfo;
  }
  if (!$isNull(request.withConsumerInfoById)) {
    query['withConsumerInfoById'] = request.withConsumerInfoById;
  }
  if (!$isNull(request.withPluginAttachmentByPluginId)) {
    query['withPluginAttachmentByPluginId'] = request.withPluginAttachmentByPluginId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListHttpApiRoutes',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis/${$URL.percentEncode(httpApiId)}/routes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the routes of an HTTP API.
 *
 * @param request ListHttpApiRoutesRequest
 * @return ListHttpApiRoutesResponse
 */
async function listHttpApiRoutes(httpApiId: string, request: ListHttpApiRoutesRequest): ListHttpApiRoutesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listHttpApiRoutesWithOptions(httpApiId, request, headers, runtime);
}

model ListHttpApisRequest {
  gatewayId?: string(name='gatewayId', description='Specifies whether to include policy configurations.', example='gw-cq2avtllh****'),
  gatewayType?: string(name='gatewayType', description='The API information.', example='API'),
  keyword?: string(name='keyword', description='The consumer authentication policy in the specified environment in each returned API.', example='test-'),
  name?: string(name='name', description='Specifies whether authentication is enabled.', example='login'),
  pageNumber?: int32(name='pageNumber', description='The environment information.', example='1'),
  pageSize?: int32(name='pageSize', description='The resource group ID.', example='10'),
  resourceGroupId?: string(name='resourceGroupId', description='The returned message.', example='rg-ahr5uil8raz0rq3b'),
  types?: string(name='types', description='The Ingress information.', example='Http,Rest'),
  withAPIsPublishedToEnvironment?: boolean(name='withAPIsPublishedToEnvironment', description='Whether to return all APIs published to a specific environment', example='true'),
  withAuthPolicyInEnvironmentId?: string(name='withAuthPolicyInEnvironmentId', description='The gateway type to filter. Valid values: **AI** and **API**.', example='env-xxx'),
  withAuthPolicyList?: boolean(name='withAuthPolicyList', description='The page number of the returned page.', example='true'),
  withConsumerInfoById?: string(name='withConsumerInfoById', description='The response body.', example='cs-xxx'),
  withEnvironmentInfo?: boolean(name='withEnvironmentInfo', description='The request ID.', example='true'),
  withEnvironmentInfoById?: string(name='withEnvironmentInfoById', description='The APIs.', example='env-ctovu5mm1hksb4q8ln40'),
  withIngressInfo?: boolean(name='withIngressInfo', description='The number of entries per page.', example='false'),
  withPluginAttachmentByPluginId?: string(name='withPluginAttachmentByPluginId', description='The status code.', example='pl-ct9qn3um1hktue8dqol0'),
  withPolicyConfigs?: boolean(name='withPolicyConfigs', description='The total number of entries returned.', example='false'),
}

model ListHttpApisResponseBody = {
  code?: string(name='code', description='The status code.', example='200'),
  data?: {
    items?: [
      HttpApiInfoByName
    ](name='items', description='object'),
    pageNumber?: int32(name='pageNumber', description='Page number.', example='1'),
    pageSize?: int32(name='pageSize', description='Page size.', example='10'),
    totalSize?: int32(name='totalSize', description='Total number of items.', example='10'),
  }(name='data', description='Response data.'),
  message?: string(name='message', description='Response message.', example='success'),
  requestId?: string(name='requestId', description='Get HTTP API List', example='585657D2-1C20-5B8A-AF17-D727C6490BE4'),
}

model ListHttpApisResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListHttpApisResponseBody(name='body'),
}

/**
 * @summary Queries a list of HTTP APIs.
 *
 * @param request ListHttpApisRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHttpApisResponse
 */
@context("listHttpApisWithContext")
async function listHttpApisWithOptions(request: ListHttpApisRequest, headers: map[string]string, runtime: $RuntimeOptions): ListHttpApisResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.gatewayId)) {
    query['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.gatewayType)) {
    query['gatewayType'] = request.gatewayType;
  }
  if (!$isNull(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!$isNull(request.name)) {
    query['name'] = request.name;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.types)) {
    query['types'] = request.types;
  }
  if (!$isNull(request.withAPIsPublishedToEnvironment)) {
    query['withAPIsPublishedToEnvironment'] = request.withAPIsPublishedToEnvironment;
  }
  if (!$isNull(request.withAuthPolicyInEnvironmentId)) {
    query['withAuthPolicyInEnvironmentId'] = request.withAuthPolicyInEnvironmentId;
  }
  if (!$isNull(request.withAuthPolicyList)) {
    query['withAuthPolicyList'] = request.withAuthPolicyList;
  }
  if (!$isNull(request.withConsumerInfoById)) {
    query['withConsumerInfoById'] = request.withConsumerInfoById;
  }
  if (!$isNull(request.withEnvironmentInfo)) {
    query['withEnvironmentInfo'] = request.withEnvironmentInfo;
  }
  if (!$isNull(request.withEnvironmentInfoById)) {
    query['withEnvironmentInfoById'] = request.withEnvironmentInfoById;
  }
  if (!$isNull(request.withIngressInfo)) {
    query['withIngressInfo'] = request.withIngressInfo;
  }
  if (!$isNull(request.withPluginAttachmentByPluginId)) {
    query['withPluginAttachmentByPluginId'] = request.withPluginAttachmentByPluginId;
  }
  if (!$isNull(request.withPolicyConfigs)) {
    query['withPolicyConfigs'] = request.withPolicyConfigs;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListHttpApis',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of HTTP APIs.
 *
 * @param request ListHttpApisRequest
 * @return ListHttpApisResponse
 */
async function listHttpApis(request: ListHttpApisRequest): ListHttpApisResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listHttpApisWithOptions(request, headers, runtime);
}

model ListMcpServersRequest {
  createFromTypes?: string(name='createFromTypes', description='The type of source to create from.', example='ApiGatewayHttpToMCP'),
  deployStatuses?: string(name='deployStatuses', description='The deployment status of the MCP server.', example='Deployed'),
  gatewayId?: string(name='gatewayId', description='The gateway instance ID.

This parameter is required.', example='gw-co370icmjeu****'),
  nameLike?: string(name='nameLike', description='The name to perform a fuzzy search on the MCP server.', example='test'),
  pageNumber?: int32(name='pageNumber', description='The page number to return. Pages start from 1. Default value: 1.

This parameter is required.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.

This parameter is required.', example='10'),
  type?: string(name='type', description='The type of the MCP server.', example='RealMCP'),
}

model ListMcpServersResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    items?: [ 
      {
        apiId?: string(name='apiId', description='The API ID.', example='api-xxx'),
        assembledSources?: [ 
          {
            mcpServerId?: string(name='mcpServerId', description='The MCP server ID.', example='mcp-adfef2334fa'),
            mcpServerName?: string(name='mcpServerName', description='The name of the MCP server.', example='test-mcp'),
            tools?: [ string ](name='tools', description='The list of MCP tools.'),
          }
        ](name='assembledSources', description='The list of assembly sources. This parameter is required when the type parameter is set to AssemblyMCP.'),
        backend?: Backend(name='backend', description='The backend service of the route.'),
        createFromType?: string(name='createFromType', description='The type of source for MCP server creation. Valid values: 

ApiGatewayHttpToMCP 
ApiGatewayMcpHosting 
ApiGatewayAssembly 
NacosHttpToMCP 
NacosMcpHosting', example='ApiGatewayHttpToMCP'),
        deployStatus?: string(name='deployStatus', description='The publishing status of the API in the current environment.', example='Deployed'),
        description?: string(name='description', description='The description.', example='My MCP Server'),
        domainIds?: [ string ](name='domainIds', description='The domain name IDs.'),
        domainInfos?: [
          HttpApiDomainInfo
        ](name='domainInfos', description='The list of domain information.'),
        environmentId?: string(name='environmentId', description='The environment ID.', example='env-cq7l5s5lhtgi6qasrdc0'),
        exposedUriPath?: string(name='exposedUriPath', description='The exposed URI path. This parameter is required when the protocol parameter is set to SSE or StreamableHTTP, and the type parameter is set to RealMCP.', example='/sse'),
        gatewayId?: string(name='gatewayId', description='The gateway instance ID.', example='gw-cpv54p5***'),
        match?: HttpRouteMatch(name='match', description='The route match rule.'),
        mcpServerConfig?: string(name='mcpServerConfig', description='The HTTP-to-MCP configurations.', example='mcp spec content'),
        mcpServerId?: string(name='mcpServerId', description='The MCP server ID.', example='mcp-feaff34va'),
        mcpServerPath?: string(name='mcpServerPath', description='The MCP server access path provided by the gateway.', example='/mcp-servers/test-mcp'),
        mcpStatisticsEnable?: boolean(name='mcpStatisticsEnable', description='Indicates whether MCP observability is enabled. Default value: false.', example='false'),
        nacosMcpSyncInfo?: {
          importInstanceId?: string(name='importInstanceId', description='The Nacos instance.', example='mse-faefrefxz'),
          importMcpServerId?: string(name='importMcpServerId', description='The synchronized MCP server ID.', example='nacos-mcp-001'),
          importNamespace?: string(name='importNamespace', description='The Nacos namespace.', example='test-ns'),
        }(name='nacosMcpSyncInfo', description='The MCP information synchronized and managed by Nacos.'),
        name?: string(name='name', description='The name of the MCP server.', example='itemcenter-dev-cluster'),
        protocol?: string(name='protocol', description='The service protocol.', example='HTTP'),
        routeId?: string(name='routeId', description='The ID of the MCP server associated route.', example='hr-d11cj86m1hkvop6mp42g'),
        type?: string(name='type', description='The type of the MCP server. Valid values: RealMCP and AssemblyMCP.', example='RealMCP'),
      }
    ](name='items', description='The list of MCP servers.'),
    pageNumber?: int32(name='pageNumber', description='The page number.', example='1'),
    pageSize?: int32(name='pageSize', description='The page size.', example='10'),
    totalSize?: int32(name='totalSize', description='The total number of entries returned.', example='25'),
  }(name='data', description='The response payload.'),
  message?: string(name='message', description='The status message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='585657D2-1C20-5B8A-AF17-D727C6490BE4'),
}

model ListMcpServersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcpServersResponseBody(name='body'),
}

/**
 * @summary Retrieves a list of MCP servers.
 *
 * @description You can call this operation to create multiple services at a time.
 *
 * @param request ListMcpServersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcpServersResponse
 */
@context("listMcpServersWithContext")
async function listMcpServersWithOptions(request: ListMcpServersRequest, headers: map[string]string, runtime: $RuntimeOptions): ListMcpServersResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.createFromTypes)) {
    query['createFromTypes'] = request.createFromTypes;
  }
  if (!$isNull(request.deployStatuses)) {
    query['deployStatuses'] = request.deployStatuses;
  }
  if (!$isNull(request.gatewayId)) {
    query['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.nameLike)) {
    query['nameLike'] = request.nameLike;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcpServers',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/mcp-servers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Retrieves a list of MCP servers.
 *
 * @description You can call this operation to create multiple services at a time.
 *
 * @param request ListMcpServersRequest
 * @return ListMcpServersResponse
 */
async function listMcpServers(request: ListMcpServersRequest): ListMcpServersResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listMcpServersWithOptions(request, headers, runtime);
}

model ListPluginAttachmentsRequest {
  attachResourceId?: string(name='attachResourceId', description='The resource attachment ID.', example='hr-cv2h58em1hkg7c6vt43g'),
  attachResourceType?: string(name='attachResourceType', description='The resource attachment type (not yet in use).', example='GatewayRoute'),
  attachResourceTypes?: string(name='attachResourceTypes', description='The resource attachment types, separated by commas.', example='GatewayRoute'),
  environmentId?: string(name='environmentId', description='The environment ID.', example='env-crlnqhtlhtgqflkqislg'),
  gatewayId?: string(name='gatewayId', description='The gateway ID.', example='gw-cr79f75lhtgme744084g'),
  pageNumber?: int32(name='pageNumber', description='The page number to return. Pages start from 1. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
  pluginId?: string(name='pluginId', description='The plug-in ID.', example='pl-ct8181um1hkiqns9f6e0'),
  withParentResource?: boolean(name='withParentResource', description='Specifies whether to return parent resource attachments.', example='false'),
}

model ListPluginAttachmentsResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    items?: [ 
      {
        attachResourceType?: string(name='attachResourceType', description='The types of resource attachments.
- HttpApi
- Operation
- GatewayRoute
- GatewayDomain
- Gateway', example='GatewayRoute'),
        enable?: boolean(name='enable', description='Indicates if enabled.', example='true'),
        environmentInfo?: EnvironmentInfo(name='environmentInfo', description='The environment metadata.'),
        parentResourceInfo?: ParentResourceInfo(name='parentResourceInfo', description='The parent resource metadata.'),
        pluginAttachmentId?: string(name='pluginAttachmentId', description='The ID of the resource attachment.', example='pa-d0j9t5em1hkncrlo51mg'),
        pluginClassInfo?: PluginClassInfo(name='pluginClassInfo', description='The plug-in type metadata.'),
        pluginConfig?: string(name='pluginConfig', description='The plug-in configurations (Base64-encoded).', example='bGltaXRfYnlfaGVhZGVyOiB4LWFwaS1rZXkKbGltaXRfa2V5czoKLSBrZXk6IGV4YW1wbGUta2V5LWEKICBxdWVyeV9wZXJfc2Vjb25kOiAxMAotIGtleTogZXhhbXBsZS1rZXktYgogIHF1ZXJ5X3Blcl9zZWNvbmQ6IDEK'),
        pluginId?: string(name='pluginId', description='The plug-in ID.', example='pl-cvu6r4um1hko3b3ti0a0'),
        resourceInfos?: [
          ResourceInfo
        ](name='resourceInfos', description='The information of resource attachments.'),
      }
    ](name='items', description='The details of resource attachments.'),
    pageNumber?: int32(name='pageNumber', description='The page number.', example='1'),
    pageSize?: int32(name='pageSize', description='The page size.', example='10'),
    totalSize?: int32(name='totalSize', description='The total number of entries returned.', example='10'),
  }(name='data', description='The response payload.'),
  message?: string(name='message', description='The status message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='9640D776-794A-5077-9184-A247CA4B45C1'),
}

model ListPluginAttachmentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPluginAttachmentsResponseBody(name='body'),
}

/**
 * @summary Retrieves a list of plug-in attachments.
 *
 * @param request ListPluginAttachmentsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPluginAttachmentsResponse
 */
@context("listPluginAttachmentsWithContext")
async function listPluginAttachmentsWithOptions(request: ListPluginAttachmentsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListPluginAttachmentsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.attachResourceId)) {
    query['attachResourceId'] = request.attachResourceId;
  }
  if (!$isNull(request.attachResourceType)) {
    query['attachResourceType'] = request.attachResourceType;
  }
  if (!$isNull(request.attachResourceTypes)) {
    query['attachResourceTypes'] = request.attachResourceTypes;
  }
  if (!$isNull(request.environmentId)) {
    query['environmentId'] = request.environmentId;
  }
  if (!$isNull(request.gatewayId)) {
    query['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.pluginId)) {
    query['pluginId'] = request.pluginId;
  }
  if (!$isNull(request.withParentResource)) {
    query['withParentResource'] = request.withParentResource;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListPluginAttachments',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/plugin-attachments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Retrieves a list of plug-in attachments.
 *
 * @param request ListPluginAttachmentsRequest
 * @return ListPluginAttachmentsResponse
 */
async function listPluginAttachments(request: ListPluginAttachmentsRequest): ListPluginAttachmentsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listPluginAttachmentsWithOptions(request, headers, runtime);
}

model ListPluginClassesRequest {
  aliasLike?: string(name='aliasLike'),
  direction?: string(name='direction', example='InBound'),
  excludeBuiltinAiProxy?: boolean(name='excludeBuiltinAiProxy', example='true'),
  gatewayId?: string(name='gatewayId', example='gw-d1j8tjum1hkhxxxxxxxx'),
  gatewayType?: string(name='gatewayType', example='API'),
  installed?: boolean(name='installed', example='false'),
  nameLike?: string(name='nameLike', example='oauth'),
  pageNumber?: int32(name='pageNumber', example='1'),
  pageSize?: int32(name='pageSize', example='10'),
  source?: string(name='source', example='HigressOfficial'),
  type?: string(name='type', example='Auth'),
}

model ListPluginClassesResponseBody = {
  code?: string(name='code', example='200'),
  data?: {
    items?: [ 
      {
        alias?: string(name='alias'),
        description?: string(name='description'),
        installed?: boolean(name='installed', example='true'),
        name?: string(name='name', example='oauth'),
        pluginClassId?: string(name='pluginClassId', example='pls-d4ghv6em1hkixxxxxxxx'),
        pluginId?: string(name='pluginId', example='pl-cvu6r4um1hkoxxxxxxxx'),
        publishStatus?: string(name='publishStatus', example='Success'),
        source?: string(name='source', example='HigressOfficial'),
        supportedMinGatewayVersion?: string(name='supportedMinGatewayVersion', example='2.0.0'),
        type?: string(name='type', example='Auth'),
        version?: string(name='version', example='1.0.0'),
      }
    ](name='items'),
    pageNumber?: int32(name='pageNumber', example='1'),
    pageSize?: int32(name='pageSize', example='10'),
    totalSize?: int32(name='totalSize', example='10'),
  }(name='data'),
  message?: string(name='message', example='success'),
  requestId?: string(name='requestId', example='61EBF577-1601-51E1-B136-9CD6xxxxxxxx'),
}

model ListPluginClassesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPluginClassesResponseBody(name='body'),
}

/**
 * @summary ListPluginClasses
 *
 * @param request ListPluginClassesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPluginClassesResponse
 */
@context("listPluginClassesWithContext")
async function listPluginClassesWithOptions(request: ListPluginClassesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListPluginClassesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.aliasLike)) {
    query['aliasLike'] = request.aliasLike;
  }
  if (!$isNull(request.direction)) {
    query['direction'] = request.direction;
  }
  if (!$isNull(request.excludeBuiltinAiProxy)) {
    query['excludeBuiltinAiProxy'] = request.excludeBuiltinAiProxy;
  }
  if (!$isNull(request.gatewayId)) {
    query['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.gatewayType)) {
    query['gatewayType'] = request.gatewayType;
  }
  if (!$isNull(request.installed)) {
    query['installed'] = request.installed;
  }
  if (!$isNull(request.nameLike)) {
    query['nameLike'] = request.nameLike;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.source)) {
    query['source'] = request.source;
  }
  if (!$isNull(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListPluginClasses',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/plugin-classes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary ListPluginClasses
 *
 * @param request ListPluginClassesRequest
 * @return ListPluginClassesResponse
 */
async function listPluginClasses(request: ListPluginClassesRequest): ListPluginClassesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listPluginClassesWithOptions(request, headers, runtime);
}

model ListPluginsRequest {
  attachResourceId?: string(name='attachResourceId', description='The resource attachment ID.', example='api-cuip2pum1hksng6oni3g'),
  attachResourceType?: string(name='attachResourceType', description='The resource attachment type.

- HttpApi: HttpApi.
- Operation: Operation of HttpApi.
- GatewayRoute: Gateway route.
- GatewayService: Gateway service.
- GatewayServicePort: Gateway service port.
- Domain: Gateway domain.
- Gateway: Gateway.', example='HttpApi'),
  gatewayId?: string(name='gatewayId', description='The gateway instance ID for filtering.', example='gw-csrhgn6m1hkt65qbxxgg'),
  gatewayType?: string(name='gatewayType', description='The instance type. Valid values: **AI** and **API**.', example='AI'),
  includeBuiltinAiGateway?: boolean(name='includeBuiltinAiGateway', description='Specifies whether to include built-in AI plug-ins in the returned results. Default: false.', example='false'),
  pageNumber?: int32(name='pageNumber', description='The page number to return. Pages start from 1. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
  pluginClassId?: string(name='pluginClassId', description='The plug-in type ID for filtering.', example='pls-dn82a9djd8z****'),
  pluginClassName?: string(name='pluginClassName', description='The plug-in type name for filtering.', example='key-auth'),
  withAttachmentInfo?: boolean(name='withAttachmentInfo', description='Specifies whether the returned results should include plug-in attachment information corresponding to the attachResourceId.', example='false'),
}

model ListPluginsResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    items?: [ 
      {
        attachmentInfo?: {
          enable?: string(name='enable', description='Indicates if enabled.', example='false'),
          pluginAttachmentId?: string(name='pluginAttachmentId', description='The attachment ID.', example='pa-ct2irn6m1hkreaen0t40'),
        }(name='attachmentInfo', description='The attachment information.'),
        gatewayInfo?: {
          gatewayId?: string(name='gatewayId', description='The instance ID.', example='gw-cq7og15lhtxx6qasrj60'),
          name?: string(name='name', description='The instance name.', example='apitest-gw'),
        }(name='gatewayInfo', description='The gateway instance information.'),
        pluginClassInfo?: {
          alias?: string(name='alias', description='The alias.', example='key-based rate limit'),
          executePriority?: string(name='executePriority', description='The execution priority.', example='999'),
          executeStage?: string(name='executeStage', description='The execution stage.', example='AUTHZ'),
          name?: string(name='name', description='The name of the plug-in.', example='key-rate-limit'),
          pluginClassId?: string(name='pluginClassId', description='The plug-in type ID.', example='pls-cqebrgh46ppatmpri'),
          source?: string(name='source', description='The source of the plug-in.', example='HigressOfficial'),
          version?: string(name='version', description='The version.', example='2.0.3'),
          versionDescription?: string(name='versionDescription', description='The description of the version.', example='version description'),
        }(name='pluginClassInfo', description='The plug-in type information.'),
        pluginId?: string(name='pluginId', description='The plug-in ID.', example='pl-cvu6r4um1hko3b3ti0a0'),
      }
    ](name='items', description='The list of plug-in information.'),
    pageNumber?: int32(name='pageNumber', description='The page number.', example='1'),
    pageSize?: int32(name='pageSize', description='The page size.', example='10'),
    totalSize?: int32(name='totalSize', description='The total number of entries returned.', example='10'),
  }(name='data', description='The response payload.'),
  message?: string(name='message', description='The status message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='168BA42D-F822-569D-A67F-FC59E6ABC2B1'),
}

model ListPluginsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPluginsResponseBody(name='body'),
}

/**
 * @summary Queries plug-ins.
 *
 * @param request ListPluginsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPluginsResponse
 */
@context("listPluginsWithContext")
async function listPluginsWithOptions(request: ListPluginsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListPluginsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.attachResourceId)) {
    query['attachResourceId'] = request.attachResourceId;
  }
  if (!$isNull(request.attachResourceType)) {
    query['attachResourceType'] = request.attachResourceType;
  }
  if (!$isNull(request.gatewayId)) {
    query['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.gatewayType)) {
    query['gatewayType'] = request.gatewayType;
  }
  if (!$isNull(request.includeBuiltinAiGateway)) {
    query['includeBuiltinAiGateway'] = request.includeBuiltinAiGateway;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.pluginClassId)) {
    query['pluginClassId'] = request.pluginClassId;
  }
  if (!$isNull(request.pluginClassName)) {
    query['pluginClassName'] = request.pluginClassName;
  }
  if (!$isNull(request.withAttachmentInfo)) {
    query['withAttachmentInfo'] = request.withAttachmentInfo;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListPlugins',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/plugins`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries plug-ins.
 *
 * @param request ListPluginsRequest
 * @return ListPluginsResponse
 */
async function listPlugins(request: ListPluginsRequest): ListPluginsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listPluginsWithOptions(request, headers, runtime);
}

model ListPoliciesRequest {
  attachResourceId?: string(name='attachResourceId', description='The attachment point ID.', example='api-cq7l5s5lhtgi6qasrdc0'),
  attachResourceType?: string(name='attachResourceType', description='The types of attachment points supported by the policy. Valid values: 

- HttpApi
- Operation
- GatewayRoute
- GatewayService
- GatewayServicePort
- Domain
- Gateway', example='HttpApi'),
  environmentId?: string(name='environmentId', description='The environment ID.', example='env-cq7l5s5lhtgi6qasrdc0'),
  gatewayId?: string(name='gatewayId', description='The gateway ID.', example='gw-cq2fm65lhtgm9nrrl7ag'),
  withAttachments?: boolean(name='withAttachments', description='Specifies whether to return attachment information.', example='false'),
  withSystemPolicy?: boolean(name='withSystemPolicy', description='Specifies whether it is a system policy.', example='true'),
}

model ListPoliciesResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    items?: [
      PolicyInfo
    ](name='items', description='The list of policies.'),
    pageNumber?: int32(name='pageNumber', description='The page number.', example='1'),
    pageSize?: int32(name='pageSize', description='The page size.', example='10'),
    totalSize?: int32(name='totalSize', description='The total number of entries returned.', example='18'),
  }(name='data', description='The response payload.'),
  message?: string(name='message', description='The status message.', example='success'),
  requestId?: string(name='requestId', description='The request ID for API call tracing.', example='393E2630-DBE7-5221-AB35-9E740675491A'),
}

model ListPoliciesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPoliciesResponseBody(name='body'),
}

/**
 * @summary Queries policies.
 *
 * @param request ListPoliciesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPoliciesResponse
 */
@context("listPoliciesWithContext")
async function listPoliciesWithOptions(request: ListPoliciesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListPoliciesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.attachResourceId)) {
    query['attachResourceId'] = request.attachResourceId;
  }
  if (!$isNull(request.attachResourceType)) {
    query['attachResourceType'] = request.attachResourceType;
  }
  if (!$isNull(request.environmentId)) {
    query['environmentId'] = request.environmentId;
  }
  if (!$isNull(request.gatewayId)) {
    query['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.withAttachments)) {
    query['withAttachments'] = request.withAttachments;
  }
  if (!$isNull(request.withSystemPolicy)) {
    query['withSystemPolicy'] = request.withSystemPolicy;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListPolicies',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/policies`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries policies.
 *
 * @param request ListPoliciesRequest
 * @return ListPoliciesResponse
 */
async function listPolicies(request: ListPoliciesRequest): ListPoliciesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listPoliciesWithOptions(request, headers, runtime);
}

model ListPolicyClassesRequest {
  attachResourceId?: string(name='attachResourceId', description='The resource ID to attach the policy', example='route-001'),
  attachResourceType?: string(name='attachResourceType', description='The supported mount point type. Valid values:

*   HttpApi: an HTTP API
*   Operation: an operation in an HTTP API
*   GatewayRoute: a route
*   GatewayService: a service
*   GatewayServicePort: a service port
*   Domain: a domain name
*   Gateway: an instance', example='Operation'),
  direction?: string(name='direction', description='The direction of traffic on which the policy takes effect. Valid values:

*   OutBound
*   InBound
*   Both', example='InBound'),
  gatewayId?: string(name='gatewayId', description='The gateway ID', example='gw-001'),
  pageNumber?: int32(name='pageNumber', description='The page number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page.', example='10'),
  type?: string(name='type', description='The template type.', example='FlowControl'),
}

model ListPolicyClassesResponseBody = {
  code?: string(name='code', description='The status code returned.', example='Ok'),
  data?: {
    items?: [
      PolicyClassInfo
    ](name='items', description='The templates.'),
    pageNumber?: int32(name='pageNumber', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='pageSize', description='The number of entries per page.', example='10'),
    totalSize?: int32(name='totalSize', description='The total number of entries.', example='10'),
  }(name='data', description='An array of policy template information.'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='23B45FA9-7208-5E55-B5CE-B6B2567DD822'),
}

model ListPolicyClassesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPolicyClassesResponseBody(name='body'),
}

/**
 * @summary Queries policy templates.
 *
 * @param request ListPolicyClassesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPolicyClassesResponse
 */
@context("listPolicyClassesWithContext")
async function listPolicyClassesWithOptions(request: ListPolicyClassesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListPolicyClassesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.attachResourceId)) {
    query['attachResourceId'] = request.attachResourceId;
  }
  if (!$isNull(request.attachResourceType)) {
    query['attachResourceType'] = request.attachResourceType;
  }
  if (!$isNull(request.direction)) {
    query['direction'] = request.direction;
  }
  if (!$isNull(request.gatewayId)) {
    query['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListPolicyClasses',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/policy-classes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries policy templates.
 *
 * @param request ListPolicyClassesRequest
 * @return ListPolicyClassesResponse
 */
async function listPolicyClasses(request: ListPolicyClassesRequest): ListPolicyClassesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listPolicyClassesWithOptions(request, headers, runtime);
}

model ListSecretReferencesRequest {
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
}

model ListSecretReferencesResponseBody = {
  code?: string(name='code'),
  data?: {
    items?: [ 
      {
        pluginConfig?: {
          name?: string(name='name'),
          pluginClassId?: string(name='pluginClassId'),
          pluginId?: string(name='pluginId'),
        }(name='PluginConfig'),
        serviceConfig?: {
          name?: string(name='name'),
          serviceId?: string(name='serviceId'),
        }(name='ServiceConfig'),
        consumerConfig?: {
          consumerId?: string(name='consumerId'),
          name?: string(name='name'),
        }(name='consumerConfig'),
        gatewayId?: string(name='gatewayId'),
        mcpServerConfig?: {
          httpApiId?: string(name='httpApiId'),
          name?: string(name='name'),
          routeId?: string(name='routeId'),
        }(name='mcpServerConfig'),
        resourceType?: string(name='resourceType'),
      }
    ](name='items'),
    pageNumber?: int32(name='pageNumber'),
    pageSize?: int32(name='pageSize'),
    totalSize?: int32(name='totalSize'),
  }(name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId', description='Id of the request'),
}

model ListSecretReferencesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSecretReferencesResponseBody(name='body'),
}

/**
 * @summary 查询密钥的引用详情
 *
 * @param request ListSecretReferencesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSecretReferencesResponse
 */
@context("listSecretReferencesWithContext")
async function listSecretReferencesWithOptions(secretId: string, request: ListSecretReferencesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListSecretReferencesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListSecretReferences',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/secrets/${$URL.percentEncode(secretId)}/references`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询密钥的引用详情
 *
 * @param request ListSecretReferencesRequest
 * @return ListSecretReferencesResponse
 */
async function listSecretReferences(secretId: string, request: ListSecretReferencesRequest): ListSecretReferencesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listSecretReferencesWithOptions(secretId, request, headers, runtime);
}

model ListSecretsRequest {
  gatewayType?: string(name='gatewayType', description='Gateway type for filtering secrets of specific gateway type', example='API'),
  nameLike?: string(name='nameLike', description='Secret name for fuzzy matching, supports filtering secrets by name', example='test-secret'),
  pageNumber?: int32(name='pageNumber', description='Page number', example='1'),
  pageSize?: int32(name='pageSize', description='Number of items per page', example='10'),
}

model ListSecretsResponseBody = {
  code?: string(name='code', description='Code of the request', example='200'),
  data?: {
    items?: [ 
      {
        createTimestamp?: long(name='createTimestamp', description='Unix timestamp when the secret was created', example='1234567890'),
        gatewayType?: string(name='gatewayType', description='Gateway type associated with the secret', example='API'),
        kmsConfig?: KMSConfig(name='kmsConfig', description='KMS configuration object'),
        name?: string(name='name', description='Name of the secret', example='test-secret'),
        referenceCount?: int32(name='referenceCount', description='Number of resources referencing this secret', example='5'),
        secretId?: string(name='secretId', description='Source of the ID', example='xxxxxx'),
        secretSource?: string(name='secretSource', description='Source of the secret', example='KMS'),
        status?: string(name='status', description='Current status of the secret', example='ENABLE'),
        updateTimestamp?: long(name='updateTimestamp', description='Unix timestamp when the secret was last updated', example='1234567890'),
      }
    ](name='items', description='Array of secret details'),
    pageNumber?: int32(name='pageNumber', description='Page number', example='1'),
    pageSize?: int32(name='pageSize', description='Number of items per page', example='10'),
    totalSize?: int32(name='totalSize', description='Total number of records matching the query', example='104'),
  }(name='data', description='Data'),
  message?: string(name='message', description='message', example='success'),
  requestId?: string(name='requestId', description='Id of the request', example='2F270C0B-7D6A-5DA7-93E2-******'),
}

model ListSecretsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSecretsResponseBody(name='body'),
}

/**
 * @summary 查询密钥列表
 *
 * @param request ListSecretsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSecretsResponse
 */
@context("listSecretsWithContext")
async function listSecretsWithOptions(request: ListSecretsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListSecretsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.gatewayType)) {
    query['gatewayType'] = request.gatewayType;
  }
  if (!$isNull(request.nameLike)) {
    query['nameLike'] = request.nameLike;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListSecrets',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/secrets`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询密钥列表
 *
 * @param request ListSecretsRequest
 * @return ListSecretsResponse
 */
async function listSecrets(request: ListSecretsRequest): ListSecretsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listSecretsWithOptions(request, headers, runtime);
}

model ListServicesRequest {
  gatewayId?: string(name='gatewayId', description='The ID of the Cloud-native API Gateway instance.', example='gw-cpv4sqdl*****'),
  name?: string(name='name', description='The service name.', example='user-service'),
  pageNumber?: int32(name='pageNumber', description='The page number to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Valid values: 1 to 100. Default value: 10.', example='10'),
  resourceGroupId?: string(name='resourceGroupId', description='The resource group ID.', example='rg-acfmxxe5rc6cvla'),
  sourceType?: string(name='sourceType', description='The service source. Valid values:

*   MSE_NACOS: a service in an MSE Nacos instance
*   K8S: a service in a Kubernetes (K8s) cluster in Container Service for Kubernetes (ACK)
*   FC3: a service in Function Compute
*   VIP: a fixed address
*   DNS: a domain name

Enumerated values:

*   K8S
*   FC3
*   DNS
*   VIP
*   MSE_NACOS', example='MSE_NACOS'),
  sourceTypes?: string(name='sourceTypes', description='List of service source types', example='["K8S", "FC3"]'),
}

model ListServicesResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    items?: [
      Service
    ](name='items', description='The list of services.'),
    pageNumber?: int32(name='pageNumber', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='pageSize', description='The number of entries per page.', example='10'),
    totalSize?: int32(name='totalSize', description='The total number of entries returned.', example='18'),
  }(name='data', description='The response payload.'),
  message?: string(name='message', description='The returned message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='585657D2-1C20-5B8A-AF17-D727C6490BE4'),
}

model ListServicesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListServicesResponseBody(name='body'),
}

/**
 * @summary Queries a list of services.
 *
 * @param request ListServicesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListServicesResponse
 */
@context("listServicesWithContext")
async function listServicesWithOptions(request: ListServicesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListServicesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.gatewayId)) {
    query['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.name)) {
    query['name'] = request.name;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.sourceType)) {
    query['sourceType'] = request.sourceType;
  }
  if (!$isNull(request.sourceTypes)) {
    query['sourceTypes'] = request.sourceTypes;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListServices',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/services`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of services.
 *
 * @param request ListServicesRequest
 * @return ListServicesResponse
 */
async function listServices(request: ListServicesRequest): ListServicesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listServicesWithOptions(request, headers, runtime);
}

model ListSslCertsRequest {
  certNameLike?: string(name='certNameLike', description='The name keyword for matching.', example='ali'),
  domainName?: string(name='domainName', description='The domain name.', example='fun.iot.evideocloud.com.cn'),
  pageNumber?: int32(name='pageNumber', description='The page number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page. Default value: 10.', example='10'),
}

model ListSslCertsResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    items?: [
      SslCertMetaInfo
    ](name='items', description='The list of certificate information.'),
    pageNumber?: int32(name='pageNumber', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='pageSize', description='The number of entries per page.', example='10'),
    totalSize?: int32(name='totalSize', description='The total number of entries returned.', example='2'),
  }(name='data', description='The data returned.'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='AADF7197-3384-52AF-A2DE-A66696734129'),
}

model ListSslCertsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSslCertsResponseBody(name='body'),
}

/**
 * @summary Queries SSL certificates.
 *
 * @param request ListSslCertsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSslCertsResponse
 */
@context("listSslCertsWithContext")
async function listSslCertsWithOptions(request: ListSslCertsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListSslCertsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.certNameLike)) {
    query['certNameLike'] = request.certNameLike;
  }
  if (!$isNull(request.domainName)) {
    query['domainName'] = request.domainName;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListSslCerts',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/ssl/certs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries SSL certificates.
 *
 * @param request ListSslCertsRequest
 * @return ListSslCertsResponse
 */
async function listSslCerts(request: ListSslCertsRequest): ListSslCertsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listSslCertsWithOptions(request, headers, runtime);
}

model ListZonesResponseBody = {
  code?: string(name='code', description='Response status code.', example='Ok'),
  data?: {
    items?: [ 
      {
        supportQat?: string(name='supportQat', description='Whether QAT (Quality Assurance Testing) is supported in this zone', example='true'),
        zoneId?: string(name='zoneId', description='The zone identifier', example='cn-shenzhen-c'),
      }
    ](name='items', description='The list of queried zones.'),
  }(name='data', description='The data returned.'),
  message?: string(name='message', description='Response message.', example='success'),
  requestId?: string(name='requestId', description='Request ID.', example='E8079207-B651-592A-A565-23E9EE5673B0'),
}

model ListZonesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListZonesResponseBody(name='body'),
}

/**
 * @summary Retrieve the availability zones under a cloud-native API gateway region
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListZonesResponse
 */
@context("listZonesWithContext")
async function listZonesWithOptions(headers: map[string]string, runtime: $RuntimeOptions): ListZonesResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ListZones',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/zones`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Retrieve the availability zones under a cloud-native API gateway region
 *
 * @return ListZonesResponse
 */
async function listZones(): ListZonesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listZonesWithOptions(headers, runtime);
}

model QueryConsumerAuthorizationRulesRequest {
  apiNameLike?: string(name='apiNameLike', description='The API name.', example='api-xx'),
  consumerId?: string(name='consumerId', description='The consumer ID.', example='cs-ct21c16m1hkp64hk6qmg'),
  consumerNameLike?: string(name='consumerNameLike', description='The consumer name.', example='consumer-xxx'),
  environmentId?: string(name='environmentId', description='The environment ID.', example='env-cpqnr6tlhtgubc***'),
  groupByApi?: boolean(name='groupByApi', description='Specifies whether to group the results by API.', example='true'),
  pageNumber?: int32(name='pageNumber', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='pageSize', description='The number of entries per page.', example='10'),
  parentResourceId?: string(name='parentResourceId', description='The parent resource ID.', example='ha-cn-li942gy8p01'),
  resourceId?: string(name='resourceId', description='The resource ID.', example='ha-cn-li942gy8p03'),
  resourceType?: string(name='resourceType', description='The resource type.', example='HttpApiRoute'),
  resourceTypes?: string(name='resourceTypes', description='The resource types.', example='K8S'),
}

model QueryConsumerAuthorizationRulesResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    items?: [ 
      {
        apiInfo?: HttpApiApiInfo(name='apiInfo', description='The API details.'),
        consumerAuthorizationRuleId?: string(name='consumerAuthorizationRuleId', description='The rule ID.', example='car-csgeka5lhtggrjcprok0'),
        consumerId?: string(name='consumerId', description='The consumer ID.', example='cs-csheiftlhtgmp0j0hp4g'),
        consumerInfo?: ConsumerInfo(name='consumerInfo', description='The consumer information.'),
        createTimestamp?: long(name='createTimestamp', description='The creation timestamp. Unit: milliseconds.', example='1719386834548'),
        deployStatus?: string(name='deployStatus', description='The deployment status of the API in the current environment.', example='{}'),
        environmentInfo?: EnvironmentInfo(name='environmentInfo', description='The environment information.'),
        expireMode?: string(name='expireMode', description='The expiry mode. Valid values: LongTerm and ShortTerm.', example='ShortTerm'),
        expireStatus?: string(name='expireStatus', description='The rule status.', example='InEffect'),
        expireTimestamp?: long(name='expireTimestamp', description='The time when the rule expires.', example='172086834548'),
        gatewayInfo?: GatewayInfo(name='gatewayInfo', description='The instance information.'),
        resourceId?: string(name='resourceId', description='The resource IDs.', example='2351944'),
        resourceInfo?: {
          operationInfo?: HttpApiOperationInfo(name='operationInfo', description='The operation information.'),
          route?: HttpRoute(name='route', description='The route.'),
        }(name='resourceInfo', description='The resource information.'),
        resourceType?: string(name='resourceType', description='The resource type.', example='HttpApiRoute'),
        updateTimestamp?: long(name='updateTimestamp', description='The update timestamp. Unit: milliseconds.', example='1719386834548'),
      }
    ](name='items', description='The rules.'),
    pageNumber?: int32(name='pageNumber', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='pageSize', description='The number of entries per page.', example='10'),
    totalSize?: string(name='totalSize', description='The total number of entries returned.', example='6'),
  }(name='data', description='The response payload.'),
  message?: string(name='message', description='The returned message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='A60EE5CA-1294-532A-9775-8D2FD1C6EFBF'),
}

model QueryConsumerAuthorizationRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryConsumerAuthorizationRulesResponseBody(name='body'),
}

/**
 * @summary Queries a list of consumer authentication rules.
 *
 * @param request QueryConsumerAuthorizationRulesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryConsumerAuthorizationRulesResponse
 */
@context("queryConsumerAuthorizationRulesWithContext")
async function queryConsumerAuthorizationRulesWithOptions(request: QueryConsumerAuthorizationRulesRequest, headers: map[string]string, runtime: $RuntimeOptions): QueryConsumerAuthorizationRulesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.apiNameLike)) {
    query['apiNameLike'] = request.apiNameLike;
  }
  if (!$isNull(request.consumerId)) {
    query['consumerId'] = request.consumerId;
  }
  if (!$isNull(request.consumerNameLike)) {
    query['consumerNameLike'] = request.consumerNameLike;
  }
  if (!$isNull(request.environmentId)) {
    query['environmentId'] = request.environmentId;
  }
  if (!$isNull(request.groupByApi)) {
    query['groupByApi'] = request.groupByApi;
  }
  if (!$isNull(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!$isNull(request.parentResourceId)) {
    query['parentResourceId'] = request.parentResourceId;
  }
  if (!$isNull(request.resourceId)) {
    query['resourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }
  if (!$isNull(request.resourceTypes)) {
    query['resourceTypes'] = request.resourceTypes;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryConsumerAuthorizationRules',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/authorization-rules`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of consumer authentication rules.
 *
 * @param request QueryConsumerAuthorizationRulesRequest
 * @return QueryConsumerAuthorizationRulesResponse
 */
async function queryConsumerAuthorizationRules(request: QueryConsumerAuthorizationRulesRequest): QueryConsumerAuthorizationRulesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return queryConsumerAuthorizationRulesWithOptions(request, headers, runtime);
}

model RemoveConsumerAuthorizationRuleResponseBody = {
  code?: string(name='code', description='The status code returned.', example='Ok'),
  message?: string(name='message', description='The returned message.', example='success'),
  requestId?: string(name='requestId', description='Id of the request', example='5B626361-070A-56A7-B127-ADAC8F3655DB'),
}

model RemoveConsumerAuthorizationRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveConsumerAuthorizationRuleResponseBody(name='body'),
}

/**
 * @summary Deletes a consumer authorization rule.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveConsumerAuthorizationRuleResponse
 */
@context("removeConsumerAuthorizationRuleWithContext")
async function removeConsumerAuthorizationRuleWithOptions(consumerAuthorizationRuleId: string, headers: map[string]string, runtime: $RuntimeOptions): RemoveConsumerAuthorizationRuleResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'RemoveConsumerAuthorizationRule',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/authorization-rules/${$URL.percentEncode(consumerAuthorizationRuleId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a consumer authorization rule.
 *
 * @return RemoveConsumerAuthorizationRuleResponse
 */
async function removeConsumerAuthorizationRule(consumerAuthorizationRuleId: string): RemoveConsumerAuthorizationRuleResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return removeConsumerAuthorizationRuleWithOptions(consumerAuthorizationRuleId, headers, runtime);
}

model RestartGatewayResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='585657D2-1C20-5B8A-AF17-D727C6490BE4'),
}

model RestartGatewayResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestartGatewayResponseBody(name='body'),
}

/**
 * @summary Restarts an instance.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RestartGatewayResponse
 */
@context("restartGatewayWithContext")
async function restartGatewayWithOptions(gatewayId: string, headers: map[string]string, runtime: $RuntimeOptions): RestartGatewayResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'RestartGateway',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/gateways/${$URL.percentEncode(gatewayId)}/restart`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Restarts an instance.
 *
 * @return RestartGatewayResponse
 */
async function restartGateway(gatewayId: string): RestartGatewayResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return restartGatewayWithOptions(gatewayId, headers, runtime);
}

model SyncMCPServersRequest {
  domainIds?: [ string ](name='domainIds', description='The domain ID.'),
  gatewayId?: string(name='gatewayId', description='The ID of the gateway.', example='gw-cq7l5s5lhtg***'),
  nacosMcpServers?: [ 
    {
      exposedUriPath?: string(name='exposedUriPath', description='The exposed URI path. This parameter is required when the protocol parameter is set to SSE or StreamableHTTP and the type parameter is set to RealMCP.', example='/sse'),
      instanceId?: string(name='instanceId', description='The Nacos instance ID.', example='mse-24afmoioxxx'),
      mcpServerId?: string(name='mcpServerId', description='The MCP server ID.', example='mcp-d3s8qo6m1hknegofa3bg'),
      mcpServerName?: string(name='mcpServerName', description='The name of the MCP server.', example='test'),
      protocols?: [ string ](name='protocols', description='The protocol.'),
    }
  ](name='nacosMcpServers', description='The synchronized Nacos MCP server list. If the synchronized MCP server is included, add the mcpServerId parameter.'),
  namespace?: string(name='namespace', description='The Nacos namespace.', example='default'),
  sourceId?: string(name='sourceId', description='The source ID.', example='src-d40mff6m1hkpt84vep60'),
}

model SyncMCPServersResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    failedMcpServers?: [ 
      {
        mcpServerName?: string(name='mcpServerName', description='The name of the MCP server.', example='mcp-fail'),
        protocols?: [ string ](name='protocols', description='The protocol.'),
      }
    ](name='failedMcpServers', description='The list of MCP servers that failed to synchronize.'),
    succeedMcpServers?: [ 
      {
        mcpServerName?: string(name='mcpServerName', description='The name of the MCP server.', example='mcp-success'),
        protocols?: [ string ](name='protocols', description='The protocol.'),
      }
    ](name='succeedMcpServers', description='The list of MCP servers successfully synchronized.'),
  }(name='data', description='The response data.'),
  message?: string(name='message', description='The response message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='2F46B9E7-67EF-5C8A-BA52-D38D5B32AF2C'),
}

model SyncMCPServersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SyncMCPServersResponseBody(name='body'),
}

/**
 * @summary Synchronizes Nacos Model Context Protocol (MCP) server configurations to Cloud-native API Gateway.
 *
 * @param request SyncMCPServersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SyncMCPServersResponse
 */
@context("syncMCPServersWithContext")
async function syncMCPServersWithOptions(request: SyncMCPServersRequest, headers: map[string]string, runtime: $RuntimeOptions): SyncMCPServersResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.domainIds)) {
    body['domainIds'] = request.domainIds;
  }
  if (!$isNull(request.gatewayId)) {
    body['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.nacosMcpServers)) {
    body['nacosMcpServers'] = request.nacosMcpServers;
  }
  if (!$isNull(request.namespace)) {
    body['namespace'] = request.namespace;
  }
  if (!$isNull(request.sourceId)) {
    body['sourceId'] = request.sourceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'SyncMCPServers',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/mcp-servers/sync-mcp-server`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Synchronizes Nacos Model Context Protocol (MCP) server configurations to Cloud-native API Gateway.
 *
 * @param request SyncMCPServersRequest
 * @return SyncMCPServersResponse
 */
async function syncMCPServers(request: SyncMCPServersRequest): SyncMCPServersResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return syncMCPServersWithOptions(request, headers, runtime);
}

model UnDeployMcpServerResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The status message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='CE857A85-251D-5018-8103-A38957D71E20'),
}

model UnDeployMcpServerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnDeployMcpServerResponseBody(name='body'),
}

/**
 * @summary Undeploys an MCP server.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnDeployMcpServerResponse
 */
@context("unDeployMcpServerWithContext")
async function unDeployMcpServerWithOptions(mcpServerId: string, headers: map[string]string, runtime: $RuntimeOptions): UnDeployMcpServerResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'UnDeployMcpServer',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/mcp-servers/${$URL.percentEncode(mcpServerId)}/undeploy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Undeploys an MCP server.
 *
 * @return UnDeployMcpServerResponse
 */
async function unDeployMcpServer(mcpServerId: string): UnDeployMcpServerResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return unDeployMcpServerWithOptions(mcpServerId, headers, runtime);
}

model UndeployHttpApiRequest {
  environmentId?: string(name='environmentId', description='The environment ID.', example='env-cqsmtellhtgvo***'),
  gatewayId?: string(name='gatewayId', description='Gateway ID.', example='gw-cq7l5s5lhtg***'),
  operationId?: string(name='operationId', description='The operation ID.', example='op-d4favr6m1hk***'),
  routeId?: string(name='routeId', description='The route ID. You must specify this parameter when you unpublish the route of an HTTP API.', example='hr-cr82undlhtgrle***'),
}

model UndeployHttpApiResponseBody = {
  code?: string(name='code', description='Response code.', example='Ok'),
  message?: string(name='message', description='Response message.', example='success'),
  requestId?: string(name='requestId', description='Request ID.', example='3ACFC7A7-45A9-58CF-B2D5-765B60254695'),
}

model UndeployHttpApiResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UndeployHttpApiResponseBody(name='body'),
}

/**
 * @summary Unpublishes an HTTP API.
 *
 * @param request UndeployHttpApiRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UndeployHttpApiResponse
 */
@context("undeployHttpApiWithContext")
async function undeployHttpApiWithOptions(httpApiId: string, request: UndeployHttpApiRequest, headers: map[string]string, runtime: $RuntimeOptions): UndeployHttpApiResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.environmentId)) {
    body['environmentId'] = request.environmentId;
  }
  if (!$isNull(request.gatewayId)) {
    body['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.operationId)) {
    body['operationId'] = request.operationId;
  }
  if (!$isNull(request.routeId)) {
    body['routeId'] = request.routeId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UndeployHttpApi',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis/${$URL.percentEncode(httpApiId)}/undeploy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Unpublishes an HTTP API.
 *
 * @param request UndeployHttpApiRequest
 * @return UndeployHttpApiResponse
 */
async function undeployHttpApi(httpApiId: string, request: UndeployHttpApiRequest): UndeployHttpApiResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return undeployHttpApiWithOptions(httpApiId, request, headers, runtime);
}

model UninstallPluginResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The status message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='F61D96E8-4E6D-5896-86E7-F1202AC31280'),
}

model UninstallPluginResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UninstallPluginResponseBody(name='body'),
}

/**
 * @summary Uninstalls a plug-in.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UninstallPluginResponse
 */
@context("uninstallPluginWithContext")
async function uninstallPluginWithOptions(pluginId: string, headers: map[string]string, runtime: $RuntimeOptions): UninstallPluginResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'UninstallPlugin',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/plugins/${$URL.percentEncode(pluginId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Uninstalls a plug-in.
 *
 * @return UninstallPluginResponse
 */
async function uninstallPlugin(pluginId: string): UninstallPluginResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return uninstallPluginWithOptions(pluginId, headers, runtime);
}

model UpdateAndAttachPolicyRequest {
  attachResourceIds?: [ string ](name='attachResourceIds', description='The association IDs.

This parameter is required.'),
  attachResourceType?: string(name='attachResourceType', description='The supported associated resource type. Valid values:

*   HttpApi: an HTTP API
*   Operation: an operation in an HTTP API
*   GatewayRoute: a route
*   GatewayService: a service
*   GatewayServicePort: a service port
*   Domain: a domain name
*   Gateway: an instance

This parameter is required.', example='HttpApi'),
  config?: string(name='config', description='The policy configurations. The value is a JSON string.

This parameter is required.', example='{\\\\"enable\\\\":false}'),
  description?: string(name='description', description='The policy description.', example='This is the description.'),
  environmentId?: string(name='environmentId', description='The environment ID.', example='env-cq2avtllhtgja4dk5djg'),
  gatewayId?: string(name='gatewayId', description='The instance ID.', example='gw-cq2avtllhtgja4dk5djg'),
  name?: string(name='name', description='The policy name.', example='test'),
}

model UpdateAndAttachPolicyResponseBody = {
  code?: string(name='code', description='The status code returned.', example='Ok'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID, which is used to trace the call link.', example='585657D2-1C20-5B8A-AF17-D727C6490BE4'),
}

model UpdateAndAttachPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAndAttachPolicyResponseBody(name='body'),
}

/**
 * @summary Updates and associates a policy.
 *
 * @param request UpdateAndAttachPolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAndAttachPolicyResponse
 */
@context("updateAndAttachPolicyWithContext")
async function updateAndAttachPolicyWithOptions(policyId: string, request: UpdateAndAttachPolicyRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateAndAttachPolicyResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.attachResourceIds)) {
    body['attachResourceIds'] = request.attachResourceIds;
  }
  if (!$isNull(request.attachResourceType)) {
    body['attachResourceType'] = request.attachResourceType;
  }
  if (!$isNull(request.config)) {
    body['config'] = request.config;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.environmentId)) {
    body['environmentId'] = request.environmentId;
  }
  if (!$isNull(request.gatewayId)) {
    body['gatewayId'] = request.gatewayId;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateAndAttachPolicy',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/policies/${$URL.percentEncode(policyId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates and associates a policy.
 *
 * @param request UpdateAndAttachPolicyRequest
 * @return UpdateAndAttachPolicyResponse
 */
async function updateAndAttachPolicy(policyId: string, request: UpdateAndAttachPolicyRequest): UpdateAndAttachPolicyResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAndAttachPolicyWithOptions(policyId, request, headers, runtime);
}

model UpdateConsumerRequest {
  akSkIdentityConfigs?: [
    AkSkIdentityConfig
  ](name='akSkIdentityConfigs', description='The list of AK/SK authentication configurations.'),
  apikeyIdentityConfig?: ApiKeyIdentityConfig(name='apikeyIdentityConfig', description='The API key authentication configurations.'),
  description?: string(name='description', description='The description.', example='This is the description.'),
  enable?: boolean(name='enable', description='Specifies the enablement status.', example='false'),
  jwtIdentityConfig?: JwtIdentityConfig(name='jwtIdentityConfig', description='The JWT authentication configuration.'),
}

model UpdateConsumerResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The status message.', example='ok'),
  requestId?: string(name='requestId', description='The request ID.', example='B917B12C-030A-597A-AF2B-6C4353FC9F10'),
}

model UpdateConsumerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateConsumerResponseBody(name='body'),
}

/**
 * @summary Updates a consumer.
 *
 * @param request UpdateConsumerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateConsumerResponse
 */
@context("updateConsumerWithContext")
async function updateConsumerWithOptions(consumerId: string, request: UpdateConsumerRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateConsumerResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.akSkIdentityConfigs)) {
    body['akSkIdentityConfigs'] = request.akSkIdentityConfigs;
  }
  if (!$isNull(request.apikeyIdentityConfig)) {
    body['apikeyIdentityConfig'] = request.apikeyIdentityConfig;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.enable)) {
    body['enable'] = request.enable;
  }
  if (!$isNull(request.jwtIdentityConfig)) {
    body['jwtIdentityConfig'] = request.jwtIdentityConfig;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateConsumer',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/consumers/${$URL.percentEncode(consumerId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a consumer.
 *
 * @param request UpdateConsumerRequest
 * @return UpdateConsumerResponse
 */
async function updateConsumer(consumerId: string, request: UpdateConsumerRequest): UpdateConsumerResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateConsumerWithOptions(consumerId, request, headers, runtime);
}

model UpdateConsumerAuthorizationRuleRequest {
  authorizationResourceInfos?: [
    AuthorizationResourceInfo
  ](name='authorizationResourceInfos', description='The list of resource authorization information.'),
  expireMode?: string(name='expireMode', description='The expiry mode. Valid values: LongTerm and ShortTerm.', example='LongTerm'),
  expireTimestamp?: long(name='expireTimestamp', description='The expiration time.', example='1750852089975'),
}

model UpdateConsumerAuthorizationRuleResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The status message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='C67DED2B-F19B-5BEC-88C1-D6EB854CD0D4'),
}

model UpdateConsumerAuthorizationRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateConsumerAuthorizationRuleResponseBody(name='body'),
}

/**
 * @summary Updates a consumer authorization rule.
 *
 * @param request UpdateConsumerAuthorizationRuleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateConsumerAuthorizationRuleResponse
 */
@context("updateConsumerAuthorizationRuleWithContext")
async function updateConsumerAuthorizationRuleWithOptions(consumerId: string, consumerAuthorizationRuleId: string, request: UpdateConsumerAuthorizationRuleRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateConsumerAuthorizationRuleResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.authorizationResourceInfos)) {
    body['authorizationResourceInfos'] = request.authorizationResourceInfos;
  }
  if (!$isNull(request.expireMode)) {
    body['expireMode'] = request.expireMode;
  }
  if (!$isNull(request.expireTimestamp)) {
    body['expireTimestamp'] = request.expireTimestamp;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateConsumerAuthorizationRule',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/consumers/${$URL.percentEncode(consumerId)}/authorization-rules/${$URL.percentEncode(consumerAuthorizationRuleId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a consumer authorization rule.
 *
 * @param request UpdateConsumerAuthorizationRuleRequest
 * @return UpdateConsumerAuthorizationRuleResponse
 */
async function updateConsumerAuthorizationRule(consumerId: string, consumerAuthorizationRuleId: string, request: UpdateConsumerAuthorizationRuleRequest): UpdateConsumerAuthorizationRuleResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateConsumerAuthorizationRuleWithOptions(consumerId, consumerAuthorizationRuleId, request, headers, runtime);
}

model UpdateDomainRequest {
  caCertIdentifier?: string(name='caCertIdentifier', description='The CA certificate ID.', example='1ef1da5f-38ed-69b3-****-037781890265'),
  certIdentifier?: string(name='certIdentifier', description='The certificate ID.', example='1ef1da5f-38ed-69b3-****-037781890265'),
  clientCACert?: string(name='clientCACert', description='The client CA certificate.', example='-----BEGIN CERTIFICATE-----
MIIFBTCCAu2gAwIBAgIUORLpYPGSFD1YOP6PMbE7Wd/mpTQwDQYJKoZIhvcNAQEL
BQAwE************************************************2VwVOJ2gqX3
YuGaxvIbDy0iQJ1GMerPRyzJTeVEtdIKT29u0PdFRr4KZWom35qX7G4=
-----END CERTIFICATE-----'),
  forceHttps?: boolean(name='forceHttps', description='Specifies whether to enable forcible HTTPS redirection. If protocol is set to HTTPS, forceHttps is required.', example='false'),
  http2Option?: string(name='http2Option', description='The HTTP/2 configuration.

Enumerated values:

*   GlobalConfig
*   Close
*   Open', example='Open'),
  mTLSEnabled?: boolean(name='mTLSEnabled', description='Specifies whether to enable mutual TLS (mTLS) authentication.'),
  protocol?: string(name='protocol', description='The protocol type to be supported by the domain name. Valid values:

*   HTTP
*   HTTPS

This parameter is required.', example='HTTP'),
  tlsCipherSuitesConfig?: TlsCipherSuitesConfig(name='tlsCipherSuitesConfig', description='The cipher suite configuration.'),
  tlsMax?: string(name='tlsMax', description='The maximum TLS version. Up to TLS 1.3 is supported.', example='TLS 1.3'),
  tlsMin?: string(name='tlsMin', description='The minimum TLS version. Down to TLS 1.0 is supported.', example='TLS 1.0'),
}

model UpdateDomainResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  data?: {
    deployRevisionId?: string(name='deployRevisionId', description='The released version ID.', example='apr-xxx'),
  }(name='data', description='The response parameters.'),
  message?: string(name='message', description='The returned message.', example='success'),
  requestId?: string(name='requestId', description='The request ID. You can use this value to trace the API call.', example='4BACB05C-3FE2-588F-9148-700C5C026B74'),
}

model UpdateDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDomainResponseBody(name='body'),
}

/**
 * @summary Updates a domain name.
 *
 * @description You can update the listening Ingress only for sources whose types are **ACK**.
 *
 * @param request UpdateDomainRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDomainResponse
 */
@context("updateDomainWithContext")
async function updateDomainWithOptions(domainId: string, request: UpdateDomainRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateDomainResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.caCertIdentifier)) {
    body['caCertIdentifier'] = request.caCertIdentifier;
  }
  if (!$isNull(request.certIdentifier)) {
    body['certIdentifier'] = request.certIdentifier;
  }
  if (!$isNull(request.clientCACert)) {
    body['clientCACert'] = request.clientCACert;
  }
  if (!$isNull(request.forceHttps)) {
    body['forceHttps'] = request.forceHttps;
  }
  if (!$isNull(request.http2Option)) {
    body['http2Option'] = request.http2Option;
  }
  if (!$isNull(request.mTLSEnabled)) {
    body['mTLSEnabled'] = request.mTLSEnabled;
  }
  if (!$isNull(request.protocol)) {
    body['protocol'] = request.protocol;
  }
  if (!$isNull(request.tlsCipherSuitesConfig)) {
    body['tlsCipherSuitesConfig'] = request.tlsCipherSuitesConfig;
  }
  if (!$isNull(request.tlsMax)) {
    body['tlsMax'] = request.tlsMax;
  }
  if (!$isNull(request.tlsMin)) {
    body['tlsMin'] = request.tlsMin;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateDomain',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/domains/${$URL.percentEncode(domainId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a domain name.
 *
 * @description You can update the listening Ingress only for sources whose types are **ACK**.
 *
 * @param request UpdateDomainRequest
 * @return UpdateDomainResponse
 */
async function updateDomain(domainId: string, request: UpdateDomainRequest): UpdateDomainResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDomainWithOptions(domainId, request, headers, runtime);
}

model UpdateEnvironmentRequest {
  alias?: string(name='alias', description='Schema of Response

This parameter is required.', example='The request ID, which is used to trace the API call link.'),
  description?: string(name='description', description='The status code returned.', example='The response message returned.'),
}

model UpdateEnvironmentResponseBody = {
  code?: string(name='code', example='Ok'),
  message?: string(name='message', example='success'),
  requestId?: string(name='requestId', example='52FB803B-3CD8-5FF8-AAE9-C2B841F6A483'),
}

model UpdateEnvironmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateEnvironmentResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI UpdateEnvironment is deprecated
 *
 * @summary Modifies an environment.
 *
 * @param request UpdateEnvironmentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEnvironmentResponse
 */
// Deprecated
@context("updateEnvironmentWithContext")
async function updateEnvironmentWithOptions(environmentId: string, request: UpdateEnvironmentRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateEnvironmentResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.alias)) {
    body['alias'] = request.alias;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateEnvironment',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/environments/${$URL.percentEncode(environmentId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @deprecated OpenAPI UpdateEnvironment is deprecated
 *
 * @summary Modifies an environment.
 *
 * @param request UpdateEnvironmentRequest
 * @return UpdateEnvironmentResponse
 */
// Deprecated
async function updateEnvironment(environmentId: string, request: UpdateEnvironmentRequest): UpdateEnvironmentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateEnvironmentWithOptions(environmentId, request, headers, runtime);
}

model UpdateGatewayFeatureRequest {
  value?: string(name='value', description='The parameter value.', example='"true"'),
}

model UpdateGatewayFeatureResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='043360DA-ED3B-5386-9B7A-D94DECF99A30'),
}

model UpdateGatewayFeatureResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateGatewayFeatureResponseBody(name='body'),
}

/**
 * @summary Updates the configuration of an instance feature parameter.
 *
 * @param request UpdateGatewayFeatureRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateGatewayFeatureResponse
 */
@context("updateGatewayFeatureWithContext")
async function updateGatewayFeatureWithOptions(gatewayId: string, name: string, request: UpdateGatewayFeatureRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateGatewayFeatureResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.value)) {
    body['value'] = request.value;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateGatewayFeature',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/gateways/${$URL.percentEncode(gatewayId)}/gateway-features/${$URL.percentEncode(name)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the configuration of an instance feature parameter.
 *
 * @param request UpdateGatewayFeatureRequest
 * @return UpdateGatewayFeatureResponse
 */
async function updateGatewayFeature(gatewayId: string, name: string, request: UpdateGatewayFeatureRequest): UpdateGatewayFeatureResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateGatewayFeatureWithOptions(gatewayId, name, request, headers, runtime);
}

model UpdateGatewayNameRequest {
  name?: string(name='name', example='dev-itemcenter-router'),
}

model UpdateGatewayNameResponseBody = {
  code?: string(name='code', example='Ok'),
  message?: string(name='message', example='success'),
  requestId?: string(name='requestId', example='585657D2-1C20-5B8A-AF17-D727C6490BE4'),
}

model UpdateGatewayNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateGatewayNameResponseBody(name='body'),
}

/**
 * @summary Changes the name of a Cloud-native API Gateway instance.
 *
 * @param request UpdateGatewayNameRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateGatewayNameResponse
 */
@context("updateGatewayNameWithContext")
async function updateGatewayNameWithOptions(gatewayId: string, request: UpdateGatewayNameRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateGatewayNameResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.name)) {
    query['name'] = request.name;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateGatewayName',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/gateways/${$URL.percentEncode(gatewayId)}/name`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the name of a Cloud-native API Gateway instance.
 *
 * @param request UpdateGatewayNameRequest
 * @return UpdateGatewayNameResponse
 */
async function updateGatewayName(gatewayId: string, request: UpdateGatewayNameRequest): UpdateGatewayNameResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateGatewayNameWithOptions(gatewayId, request, headers, runtime);
}

model UpdateHttpApiRequest {
  agentProtocols?: [ string ](name='agentProtocols', description='The list of agent protocols'),
  aiProtocols?: [ string ](name='aiProtocols', description='The status code.'),
  authConfig?: AuthConfig(name='authConfig', description='The authentication configuration'),
  basePath?: string(name='basePath', description='The list of API deployment configurations.

This parameter is required.', example='/v1'),
  deployConfigs?: [
    HttpApiDeployConfig
  ](name='deployConfigs', description='The deployment configurations'),
  description?: string(name='description', description='The environment ID.', example='The source ID.'),
  enableAuth?: boolean(name='enableAuth', description='Whether authentication is enabled', example='true'),
  firstByteTimeout?: int32(name='firstByteTimeout', description='The first byte timeout in nanoseconds', example='30s'),
  ingressConfig?: {
    environmentId?: string(name='environmentId', description='The authentication configuration.', example='env-cr6ql0tlhtgmc****'),
    ingressClass?: string(name='ingressClass', description='The response parameters.', example='mse'),
    overrideIngressIp?: boolean(name='overrideIngressIp', description='The returned message.', example='false'),
    sourceId?: string(name='sourceId', description='json', example='src-crdddallhtgtr****'),
    watchNamespace?: string(name='watchNamespace', description='The request ID.', example='default'),
  }(name='ingressConfig', description='Specifies whether to enable authentication.'),
  onlyChangeConfig?: boolean(name='onlyChangeConfig', description='Whether to only change configuration without redeployment', example='true'),
  protocols?: [ string ](name='protocols', description='The listened namespace.'),
  removeBasePathOnForward?: boolean(name='removeBasePathOnForward', description='Whether to remove base path when forwarding', example='true'),
  versionConfig?: HttpApiVersionConfig(name='versionConfig', description='A deployment configuration.'),
}

model UpdateHttpApiResponseBody = {
  code?: string(name='code', description='Response status code.', example='200'),
  message?: string(name='message', description='Response message.', example='success'),
  requestId?: string(name='requestId', description='Request ID.', example='393E2630-DBE7-5221-AB35-9E740675491A'),
}

model UpdateHttpApiResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateHttpApiResponseBody(name='body'),
}

/**
 * @summary Updates an HTTP API.
 *
 * @param request UpdateHttpApiRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateHttpApiResponse
 */
@context("updateHttpApiWithContext")
async function updateHttpApiWithOptions(httpApiId: string, request: UpdateHttpApiRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateHttpApiResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.agentProtocols)) {
    body['agentProtocols'] = request.agentProtocols;
  }
  if (!$isNull(request.aiProtocols)) {
    body['aiProtocols'] = request.aiProtocols;
  }
  if (!$isNull(request.authConfig)) {
    body['authConfig'] = request.authConfig;
  }
  if (!$isNull(request.basePath)) {
    body['basePath'] = request.basePath;
  }
  if (!$isNull(request.deployConfigs)) {
    body['deployConfigs'] = request.deployConfigs;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.enableAuth)) {
    body['enableAuth'] = request.enableAuth;
  }
  if (!$isNull(request.firstByteTimeout)) {
    body['firstByteTimeout'] = request.firstByteTimeout;
  }
  if (!$isNull(request.ingressConfig)) {
    body['ingressConfig'] = request.ingressConfig;
  }
  if (!$isNull(request.onlyChangeConfig)) {
    body['onlyChangeConfig'] = request.onlyChangeConfig;
  }
  if (!$isNull(request.protocols)) {
    body['protocols'] = request.protocols;
  }
  if (!$isNull(request.removeBasePathOnForward)) {
    body['removeBasePathOnForward'] = request.removeBasePathOnForward;
  }
  if (!$isNull(request.versionConfig)) {
    body['versionConfig'] = request.versionConfig;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateHttpApi',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis/${$URL.percentEncode(httpApiId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates an HTTP API.
 *
 * @param request UpdateHttpApiRequest
 * @return UpdateHttpApiResponse
 */
async function updateHttpApi(httpApiId: string, request: UpdateHttpApiRequest): UpdateHttpApiResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateHttpApiWithOptions(httpApiId, request, headers, runtime);
}

model UpdateHttpApiOperationRequest {
  operation?: HttpApiOperation(name='operation', description='The operation definition.'),
}

model UpdateHttpApiOperationResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='043360DA-ED3B-5386-9B7A-D94DECF99A30'),
}

model UpdateHttpApiOperationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateHttpApiOperationResponseBody(name='body'),
}

/**
 * @summary Updates an operation of an HTTP API.
 *
 * @param request UpdateHttpApiOperationRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateHttpApiOperationResponse
 */
@context("updateHttpApiOperationWithContext")
async function updateHttpApiOperationWithOptions(httpApiId: string, operationId: string, request: UpdateHttpApiOperationRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateHttpApiOperationResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.operation)) {
    body['operation'] = request.operation;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateHttpApiOperation',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis/${$URL.percentEncode(httpApiId)}/operations/${$URL.percentEncode(operationId)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates an operation of an HTTP API.
 *
 * @param request UpdateHttpApiOperationRequest
 * @return UpdateHttpApiOperationResponse
 */
async function updateHttpApiOperation(httpApiId: string, operationId: string, request: UpdateHttpApiOperationRequest): UpdateHttpApiOperationResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateHttpApiOperationWithOptions(httpApiId, operationId, request, headers, runtime);
}

model UpdateHttpApiRouteRequest {
  backendConfig?: {
    scene?: string(name='scene', description='The backend service scenario. Valid values:

*   SingleService
*   MultiServiceByRatio
*   Redirect
*   Mock', example='SingleService'),
    services?: [ 
      {
        port?: int32(name='port', description='The service port (omit for dynamic ports).', example='8080'),
        protocol?: string(name='protocol', description='The service protocol. Valid values:

*   HTTP
*   HTTPS', example='HTTP'),
        serviceId?: string(name='serviceId', description='The service ID.', example='svc-cr6pk4tlhtgm58e***'),
        version?: string(name='version', description='The service version.', example='v1'),
        weight?: int32(name='weight', description='The traffic weight percentage.', example='49'),
      }
    ](name='services', description='The list of backend services.'),
  }(name='backendConfig', description='The backend service configurations for the route.'),
  deployConfigs?: [
    HttpApiDeployConfig
  ](name='deployConfigs'),
  description?: string(name='description', description='The route description.', example='test route'),
  domainIds?: [ string ](name='domainIds', description='The list of domain IDs.'),
  environmentId?: string(name='environmentId', description='The environment ID.', example='env-cquqsollhtgid***'),
  match?: HttpRouteMatch(name='match', description='The route match rule.'),
  mcpRouteConfig?: {
    exposedUriPath?: string(name='exposedUriPath'),
    mcpStatisticsEnable?: boolean(name='mcpStatisticsEnable'),
    protocol?: string(name='protocol'),
  }(name='mcpRouteConfig'),
  name?: string(name='name'),
  policyConfigs?: [ 
    {
      aiCacheConfig?: {
        cacheKeyStrategy?: string(name='cacheKeyStrategy'),
        cacheMode?: string(name='cacheMode'),
        cacheTTL?: int32(name='cacheTTL'),
        embeddingConfig?: {
          modelName?: string(name='modelName'),
          serviceId?: string(name='serviceId'),
          timeout?: int32(name='timeout'),
          type?: string(name='type'),
        }(name='embeddingConfig'),
        pluginStatus?: {
          errorLogs?: map[string]string(name='errorLogs'),
          pluginId?: string(name='pluginId'),
          serviceHealthy?: boolean(name='serviceHealthy'),
        }(name='pluginStatus'),
        redisConfig?: {
          databaseNumber?: int32(name='databaseNumber'),
          host?: string(name='host'),
          password?: string(name='password'),
          port?: int32(name='port'),
          timeout?: int32(name='timeout'),
          username?: string(name='username'),
        }(name='redisConfig'),
        vectorConfig?: {
          apiKey?: string(name='apiKey', description='apiKey'),
          collectionId?: string(name='collectionId'),
          serviceHost?: string(name='serviceHost'),
          threshold?: float(name='threshold'),
          timeout?: int32(name='timeout', example='6000'),
          type?: string(name='type'),
        }(name='vectorConfig'),
      }(name='aiCacheConfig'),
      aiFallbackConfig?: {
        onlyRedirectUpstreamCode?: boolean(name='onlyRedirectUpstreamCode'),
        routeEmbedded?: boolean(name='routeEmbedded'),
        serviceConfigs?: [ 
          {
            name?: string(name='name'),
            passThroughModelName?: boolean(name='passThroughModelName'),
            serviceId?: string(name='serviceId'),
            targetModelName?: string(name='targetModelName'),
          }
        ](name='serviceConfigs'),
      }(name='aiFallbackConfig'),
      aiNetworkSearchConfig?: {
        defaultEnable?: boolean(name='defaultEnable'),
        defaultLang?: string(name='defaultLang'),
        needReference?: boolean(name='needReference'),
        pluginStatus?: {
          errorLogs?: map[string]string(name='errorLogs'),
          pluginId?: string(name='pluginId'),
          serviceHealthy?: boolean(name='serviceHealthy'),
        }(name='pluginStatus'),
        referenceFormat?: string(name='referenceFormat'),
        referenceLocation?: string(name='referenceLocation'),
        searchEngineConfig?: {
          apiKey?: string(name='apiKey'),
          contentMode?: string(name='contentMode'),
          count?: int32(name='count'),
          endpoint?: string(name='endpoint'),
          industry?: string(name='industry'),
          optionArgs?: map[string]string(name='optionArgs'),
          start?: int32(name='start'),
          timeRange?: string(name='timeRange'),
          timeoutMillisecond?: int32(name='timeoutMillisecond'),
          type?: string(name='type'),
        }(name='searchEngineConfig'),
        searchFrom?: [ 
          {
            apiKey?: string(name='apiKey'),
            contentMode?: string(name='contentMode'),
            count?: int32(name='count'),
            endpoint?: string(name='endpoint'),
            industry?: string(name='industry'),
            optionArgs?: map[string]string(name='optionArgs'),
            start?: int32(name='start'),
            timeRange?: string(name='timeRange'),
            timeoutMillisecond?: int32(name='timeoutMillisecond'),
            type?: string(name='type'),
          }
        ](name='searchFrom'),
        searchRewrite?: {
          enable?: boolean(name='enable'),
          maxCount?: int32(name='maxCount'),
          modelName?: string(name='modelName'),
          serviceId?: string(name='serviceId'),
          timeoutMillisecond?: int32(name='timeoutMillisecond'),
        }(name='searchRewrite'),
      }(name='aiNetworkSearchConfig'),
      aiSecurityGuardConfig?: {
        bufferLimit?: int32(name='bufferLimit'),
        checkRequest?: boolean(name='checkRequest'),
        checkRequestImage?: boolean(name='checkRequestImage'),
        checkResponse?: boolean(name='checkResponse'),
        checkResponseImage?: boolean(name='checkResponseImage'),
        consumerRequestCheckService?: [ 
          {
            matchType?: string(name='matchType'),
            modalityType?: string(name='modalityType'),
            name?: string(name='name'),
            requestCheckService?: string(name='requestCheckService'),
            requestImageCheckService?: string(name='requestImageCheckService'),
          }
        ](name='consumerRequestCheckService'),
        consumerResponseCheckService?: [ 
          {
            matchType?: string(name='matchType'),
            modalityType?: string(name='modalityType'),
            name?: string(name='name'),
            responseCheckService?: string(name='responseCheckService'),
            responseImageCheckService?: string(name='responseImageCheckService'),
          }
        ](name='consumerResponseCheckService'),
        consumerRiskLevel?: [ 
          {
            level?: string(name='level'),
            matchType?: string(name='matchType'),
            name?: string(name='name'),
            type?: string(name='type'),
          }
        ](name='consumerRiskLevel'),
        pluginStatus?: {
          errorLogs?: map[string]string(name='errorLogs'),
          pluginId?: string(name='pluginId'),
          serviceHealthy?: boolean(name='serviceHealthy'),
        }(name='pluginStatus'),
        requestCheckService?: string(name='requestCheckService'),
        requestImageCheckService?: string(name='requestImageCheckService'),
        responseCheckService?: string(name='responseCheckService'),
        responseImageCheckService?: string(name='responseImageCheckService'),
        riskAlertLevel?: string(name='riskAlertLevel'),
        riskConfig?: [ 
          {
            consumerRules?: {
              matchType?: string(name='matchType'),
              pattern?: string(name='pattern'),
            }(name='consumerRules'),
            level?: string(name='level'),
            type?: string(name='type'),
          }
        ](name='riskConfig'),
        serviceAddress?: string(name='serviceAddress'),
      }(name='aiSecurityGuardConfig'),
      aiStatisticsConfig?: {
        logRequestContent?: boolean(name='logRequestContent'),
        logResponseContent?: boolean(name='logResponseContent'),
      }(name='aiStatisticsConfig'),
      aiTokenRateLimitConfig?: {
        enableGlobalRules?: boolean(name='enableGlobalRules'),
        globalRules?: [ 
          {
            limitMode?: string(name='limitMode'),
            limitType?: string(name='limitType'),
            limitValue?: int32(name='limitValue'),
            matchKey?: string(name='matchKey'),
            matchType?: string(name='matchType'),
            matchValue?: string(name='matchValue'),
          }
        ](name='globalRules'),
        pluginStatus?: {
          errorLogs?: map[string]string(name='errorLogs'),
          pluginId?: string(name='pluginId'),
          serviceHealthy?: boolean(name='serviceHealthy'),
        }(name='pluginStatus'),
        redisConfig?: {
          databaseNumber?: int32(name='databaseNumber'),
          host?: string(name='host'),
          password?: string(name='password'),
          port?: int32(name='port'),
          timeout?: int32(name='timeout'),
          username?: string(name='username'),
        }(name='redisConfig'),
        rules?: [ 
          {
            limitMode?: string(name='limitMode'),
            limitType?: string(name='limitType'),
            limitValue?: int32(name='limitValue'),
            matchKey?: string(name='matchKey'),
            matchType?: string(name='matchType'),
            matchValue?: string(name='matchValue'),
          }
        ](name='rules'),
      }(name='aiTokenRateLimitConfig'),
      aiToolSelectionConfig?: {
        enableConditions?: {
          toolCountThreshold?: int32(name='toolCountThreshold'),
        }(name='enableConditions'),
        pluginStatus?: {
          errorLogs?: map[string]string(name='errorLogs'),
          pluginId?: string(name='pluginId'),
          serviceHealthy?: boolean(name='serviceHealthy'),
        }(name='pluginStatus'),
        queryRewriting?: {
          contextSelection?: {
            type?: string(name='type'),
            value?: int32(name='value'),
          }(name='contextSelection'),
          enabled?: boolean(name='enabled'),
          fallbackStrategy?: string(name='fallbackStrategy'),
          maxOutputTokens?: int32(name='maxOutputTokens'),
          modelService?: {
            modelName?: string(name='modelName'),
            serviceId?: string(name='serviceId'),
            timeoutMillisecond?: int32(name='timeoutMillisecond'),
          }(name='modelService'),
          promptConfig?: {
            customPrompt?: string(name='customPrompt'),
            type?: string(name='type'),
          }(name='promptConfig'),
          triggerConditions?: {
            messageCountThreshold?: int32(name='messageCountThreshold'),
          }(name='triggerConditions'),
        }(name='queryRewriting'),
        toolReranking?: {
          fallbackStrategy?: string(name='fallbackStrategy'),
          filteringMethod?: string(name='filteringMethod'),
          modelService?: {
            modelName?: string(name='modelName'),
            serviceId?: string(name='serviceId'),
            timeoutMillisecond?: int32(name='timeoutMillisecond'),
          }(name='modelService'),
          scoreThreshold?: float(name='scoreThreshold'),
          topKPercent?: int32(name='topKPercent'),
          topNCount?: int32(name='topNCount'),
        }(name='toolReranking'),
      }(name='aiToolSelectionConfig'),
      enable?: boolean(name='enable'),
      semanticRouterConfig?: {
        timeoutMillisecond?: int32(name='timeoutMillisecond'),
      }(name='semanticRouterConfig'),
      type?: string(name='type'),
    }
  ](name='policyConfigs'),
}

model UpdateHttpApiRouteResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The returned message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='CBEEB8C1-108E-50F0-9BEA-DED79553C309'),
}

model UpdateHttpApiRouteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateHttpApiRouteResponseBody(name='body'),
}

/**
 * @summary Updates the route of an HTTP API.
 *
 * @param request UpdateHttpApiRouteRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateHttpApiRouteResponse
 */
@context("updateHttpApiRouteWithContext")
async function updateHttpApiRouteWithOptions(httpApiId: string, routeId: string, request: UpdateHttpApiRouteRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateHttpApiRouteResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.backendConfig)) {
    body['backendConfig'] = request.backendConfig;
  }
  if (!$isNull(request.deployConfigs)) {
    body['deployConfigs'] = request.deployConfigs;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.domainIds)) {
    body['domainIds'] = request.domainIds;
  }
  if (!$isNull(request.environmentId)) {
    body['environmentId'] = request.environmentId;
  }
  if (!$isNull(request.match)) {
    body['match'] = request.match;
  }
  if (!$isNull(request.mcpRouteConfig)) {
    body['mcpRouteConfig'] = request.mcpRouteConfig;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }
  if (!$isNull(request.policyConfigs)) {
    body['policyConfigs'] = request.policyConfigs;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateHttpApiRoute',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/http-apis/${$URL.percentEncode(httpApiId)}/routes/${$URL.percentEncode(routeId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the route of an HTTP API.
 *
 * @param request UpdateHttpApiRouteRequest
 * @return UpdateHttpApiRouteResponse
 */
async function updateHttpApiRoute(httpApiId: string, routeId: string, request: UpdateHttpApiRouteRequest): UpdateHttpApiRouteResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateHttpApiRouteWithOptions(httpApiId, routeId, request, headers, runtime);
}

model UpdateMcpServerRequest {
  assembledSources?: [ 
    {
      mcpServerId?: string(name='mcpServerId', description='The MCP server ID.', example='mcp-afaefaefaf'),
      mcpServerName?: string(name='mcpServerName', description='The name of the MCP server.', example='test-mcp'),
      tools?: [ string ](name='tools', description='The MCP tools.'),
    }
  ](name='assembledSources', description='The list of assembly sources. This parameter is required when the type parameter is set to AssemblyMCP.'),
  backendConfig?: {
    scene?: string(name='scene', description='The backend service scenario.', example='SingleService'),
    services?: [ 
      {
        port?: int32(name='port', description='The service port (omit for dynamic ports).', example='8080'),
        protocol?: string(name='protocol', description='The service protocol. Valid values:

*   TCP
*   HTTP
*   DUBBO', example='HTTP'),
        serviceId?: string(name='serviceId', description='The service ID.', example='svc-cr6pk4tlhtgm58e***'),
        version?: string(name='version', description='The service version.', example='v1'),
        weight?: int32(name='weight', description='The traffic weight percentage.', example='49'),
      }
    ](name='services', description='The backend services.'),
  }(name='backendConfig', description='The backend service configurations for the route.'),
  createFromType?: string(name='createFromType', description='Specifies the type of source for MCP server creation.', example='ApiGatewayMcpHosting'),
  description?: string(name='description', description='The description.', example='Updated MCP server description'),
  domainIds?: [ string ](name='domainIds', description='The domain IDs.'),
  exposedUriPath?: string(name='exposedUriPath', description='The exposed URI path. This parameter is required when the protocol parameter is set to SSE or StreamableHTTP and the type parameter is set to RealMCP.', example='/sse'),
  grayMcpServerConfigs?: [ 
    {
      backendConfig?: {
        scene?: string(name='scene', description='The backend scene', example='SingleService'),
        services?: [ 
          {
            port?: int32(name='port', description='The service port', example='8080'),
            protocol?: string(name='protocol', description='The service protocol', example='HTTP'),
            serviceId?: string(name='serviceId', description='The service ID', example='gray-svc-123'),
            version?: string(name='version', description='The service version', example='v1'),
            weight?: int32(name='weight', description='The service weight', example='100'),
          }
        ](name='services', description='The list of backend services'),
      }(name='backendConfig', description='The backend configuration'),
      match?: HttpRouteMatch(name='match', description='The route match rules'),
      routeId?: string(name='routeId', description='The route ID', example='route-123'),
    }
  ](name='grayMcpServerConfigs', description='The gray MCP server configurations'),
  match?: HttpRouteMatch(name='match', description='The route match rule.'),
  mcpServerConfig?: {
    mcpServerSpec?: string(name='mcpServerSpec', description='The converted mcp server spec yaml', example='mcp-server-spec-yaml'),
    swaggerConfig?: string(name='swaggerConfig', description='The raw swagger/openapi document', example='swagger-content'),
  }(name='mcpServerConfig', description='The MCP server configuration'),
  mcpStatisticsEnable?: boolean(name='mcpStatisticsEnable', description='Specifies if MCP observability is enabled. Default value: false.', example='false'),
  protocol?: string(name='protocol', description='The service protocol. Valid values: HTTP, HTTPS, SSE, and StreamableHTTP.

This parameter is required.', example='HTTP'),
  type?: string(name='type', description='The MCP server type. Valid values: RealMCP and AssemblyMCP.

This parameter is required.', example='RealMCP'),
}

model UpdateMcpServerResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The status message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='3ACFC7A7-45A9-58CF-B2D5-765B60254695'),
}

model UpdateMcpServerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMcpServerResponseBody(name='body'),
}

/**
 * @summary Updates an MCP server.
 *
 * @description You can only update the listening Ingress configuration for sources of the **ACK** type.
 *
 * @param request UpdateMcpServerRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMcpServerResponse
 */
@context("updateMcpServerWithContext")
async function updateMcpServerWithOptions(mcpServerId: string, request: UpdateMcpServerRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateMcpServerResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.assembledSources)) {
    body['assembledSources'] = request.assembledSources;
  }
  if (!$isNull(request.backendConfig)) {
    body['backendConfig'] = request.backendConfig;
  }
  if (!$isNull(request.createFromType)) {
    body['createFromType'] = request.createFromType;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.domainIds)) {
    body['domainIds'] = request.domainIds;
  }
  if (!$isNull(request.exposedUriPath)) {
    body['exposedUriPath'] = request.exposedUriPath;
  }
  if (!$isNull(request.grayMcpServerConfigs)) {
    body['grayMcpServerConfigs'] = request.grayMcpServerConfigs;
  }
  if (!$isNull(request.match)) {
    body['match'] = request.match;
  }
  if (!$isNull(request.mcpServerConfig)) {
    body['mcpServerConfig'] = request.mcpServerConfig;
  }
  if (!$isNull(request.mcpStatisticsEnable)) {
    body['mcpStatisticsEnable'] = request.mcpStatisticsEnable;
  }
  if (!$isNull(request.protocol)) {
    body['protocol'] = request.protocol;
  }
  if (!$isNull(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateMcpServer',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/mcp-servers/${$URL.percentEncode(mcpServerId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates an MCP server.
 *
 * @description You can only update the listening Ingress configuration for sources of the **ACK** type.
 *
 * @param request UpdateMcpServerRequest
 * @return UpdateMcpServerResponse
 */
async function updateMcpServer(mcpServerId: string, request: UpdateMcpServerRequest): UpdateMcpServerResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMcpServerWithOptions(mcpServerId, request, headers, runtime);
}

model UpdatePluginAttachmentRequest {
  attachResourceIds?: [ string ](name='attachResourceIds', description='The IDs of the resources to which the plug-in is attached.'),
  enable?: boolean(name='enable', description='Specifies whether to enable the plug-in.', example='false'),
  pluginConfig?: string(name='pluginConfig', description='The Base64-encoded configurations of the plug-in.', example='cHJlcGVuZDoKLSByb2xlOiBzeXN0ZW0KICBjb250ZW50OiDor7fkvb/nlKjoi7Hor63lm57nrZTpl67popgKYXBwZW5kOgotIHJvbGU6IHVzZXIKICBjb250ZW50OiDmr4/mrKHlm57nrZTlrozpl67popjvvIzlsJ3or5Xov5vooYzlj43pl64K'),
}

model UpdatePluginAttachmentResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The status message.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='F330090D-80F8-557B-8610-7EC7E386B4A4'),
}

model UpdatePluginAttachmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePluginAttachmentResponseBody(name='body'),
}

/**
 * @summary Updates a plug-in attachment.
 *
 * @param request UpdatePluginAttachmentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePluginAttachmentResponse
 */
@context("updatePluginAttachmentWithContext")
async function updatePluginAttachmentWithOptions(pluginAttachmentId: string, request: UpdatePluginAttachmentRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdatePluginAttachmentResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.attachResourceIds)) {
    body['attachResourceIds'] = request.attachResourceIds;
  }
  if (!$isNull(request.enable)) {
    body['enable'] = request.enable;
  }
  if (!$isNull(request.pluginConfig)) {
    body['pluginConfig'] = request.pluginConfig;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdatePluginAttachment',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/plugin-attachments/${$URL.percentEncode(pluginAttachmentId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a plug-in attachment.
 *
 * @param request UpdatePluginAttachmentRequest
 * @return UpdatePluginAttachmentResponse
 */
async function updatePluginAttachment(pluginAttachmentId: string, request: UpdatePluginAttachmentRequest): UpdatePluginAttachmentResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePluginAttachmentWithOptions(pluginAttachmentId, request, headers, runtime);
}

model UpdatePolicyRequest {
  config?: string(name='config', description='Policy configuration

This parameter is required.', example='{"unitNum":1,"timeUnit":"s","enable":true}'),
  description?: string(name='description', description='Description', example='this is a timeout policy description'),
  name?: string(name='name', description='Policy name

This parameter is required.', example='celue-timeout-test'),
}

model UpdatePolicyResponseBody = {
  code?: string(name='code', description='Response status code.', example='Ok'),
  message?: string(name='message', description='Response message.', example='success'),
  requestId?: string(name='requestId', description='Request ID.', example='C67DED2B-F19B-5BEC-88C1-D6EB854C***'),
}

model UpdatePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePolicyResponseBody(name='body'),
}

/**
 * @summary Updates a policy.
 *
 * @param request UpdatePolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePolicyResponse
 */
@context("updatePolicyWithContext")
async function updatePolicyWithOptions(policyId: string, request: UpdatePolicyRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdatePolicyResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.config)) {
    body['config'] = request.config;
  }
  if (!$isNull(request.description)) {
    body['description'] = request.description;
  }
  if (!$isNull(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdatePolicy',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v2/policies/${$URL.percentEncode(policyId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a policy.
 *
 * @param request UpdatePolicyRequest
 * @return UpdatePolicyResponse
 */
async function updatePolicy(policyId: string, request: UpdatePolicyRequest): UpdatePolicyResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePolicyWithOptions(policyId, request, headers, runtime);
}

model UpdateSecretRequest {
  secretData?: string(name='secretData'),
}

model UpdateSecretResponseBody = {
  code?: string(name='code'),
  message?: string(name='message'),
  requestId?: string(name='requestId', description='Id of the request'),
}

model UpdateSecretResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSecretResponseBody(name='body'),
}

/**
 * @summary 更新消费者
 *
 * @param request UpdateSecretRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSecretResponse
 */
@context("updateSecretWithContext")
async function updateSecretWithOptions(secretId: string, request: UpdateSecretRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateSecretResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.secretData)) {
    body['secretData'] = request.secretData;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateSecret',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/secrets/${$URL.percentEncode(secretId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新消费者
 *
 * @param request UpdateSecretRequest
 * @return UpdateSecretResponse
 */
async function updateSecret(secretId: string, request: UpdateSecretRequest): UpdateSecretResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSecretWithOptions(secretId, request, headers, runtime);
}

model UpdateServiceRequest {
  addresses?: [ string ](name='addresses', description='The list of domain names or fixed addresses.'),
  agentServiceConfig?: AgentServiceConfig(name='agentServiceConfig', description='The agent service configurations.'),
  aiServiceConfig?: AiServiceConfig(name='aiServiceConfig', description='The AI service configurations.'),
  dnsServers?: [ string ](name='dnsServers', description='A DNS service address.'),
  healthCheckConfig?: {
    enable?: boolean(name='enable', description='Specifies whether to enable health checks.', example='true'),
    expectedStatuses?: [ string ](name='expectedStatuses', description='The normal status codes to be returned. This parameter is required if the health check protocol is HTTP.'),
    healthyThreshold?: int32(name='healthyThreshold', description='The healthy threshold.', example='2'),
    httpHost?: string(name='httpHost', description='The domain name that you want to use for health checks. Optional. This parameter is available if the health check protocol is HTTP.', example='dev.itemcener.com'),
    httpPath?: string(name='httpPath', description='The request path of health checks. This parameter is required if the health check protocol is HTTP.', example='/healthz'),
    interval?: int32(name='interval', description='The health check interval. Unit: seconds', example='2'),
    protocol?: string(name='protocol', description='The protocol over which the system performs health checks.

Valid values:

*   TCP
*   HTTP', example='HTTP'),
    timeout?: int32(name='timeout', description='The timeout period for a health check response. Unit: seconds', example='2'),
    unhealthyThreshold?: int32(name='unhealthyThreshold', description='The unhealthy threshold.', example='22'),
  }(name='healthCheckConfig', description='The health check configurations.'),
  healthyPanicThreshold?: float(name='healthyPanicThreshold', description='The health check threshold.', example='80'),
  outlierDetectionConfig?: {
    baseEjectionTime?: int32(name='baseEjectionTime', description='The initial isolation duration after a node is isolated (e.g., 30 seconds). The isolation time is calculated as: k \\\\* base_ejection_time (with k initially set to 1). Each subsequent isolation increases the isolation time (k is incremented by 1), while consecutive healthy checks gradually decrease the isolation time (k is decremented by 1).', example='30'),
    enable?: boolean(name='enable', description='enable', example='false'),
    failurePercentageMinimumHosts?: int32(name='failurePercentageMinimumHosts', description='The panic threshold.

When the proportion of healthy nodes in the service is greater than the panic threshold, health checks take effect normally, and requests are only sent to healthy nodes, not to ejected nodes. When the proportion of healthy nodes in the service is less than or equal to the panic threshold, health checks are effectively disabled, and requests are sent to all nodes, including those that have been ejected nodes.', example='1'),
    failurePercentageThreshold?: int32(name='failurePercentageThreshold', description='When the request failure rate of a node reaches this threshold, the system triggers the isolation mechanism of the node.', example='80'),
    interval?: int32(name='interval', description='The detection interval.', example='30'),
  }(name='outlierDetectionConfig', description='The passive health check configurations.'),
  ports?: [ 
    {
      name?: string(name='name', description='The port name.', example='catalog'),
      port?: int32(name='port', description='The port.', example='80'),
      protocol?: string(name='protocol', description='The protocol.', example='TCP|UDP'),
    }
  ](name='ports', description='The port information.'),
  protocol?: string(name='protocol', description='The service protocol.', example='HTTP'),
}

model UpdateServiceResponseBody = {
  code?: string(name='code', example='Ok'),
  message?: string(name='message', example='success'),
  requestId?: string(name='requestId', example='B725275B-50C6-5A49-A9FD-F0332FCB3351'),
}

model UpdateServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateServiceResponseBody(name='body'),
}

/**
 * @summary Updates a service. You can call this operation to update the health check, DNS domain name, and fixed address configurations of a service.
 *
 * @param request UpdateServiceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateServiceResponse
 */
@context("updateServiceWithContext")
async function updateServiceWithOptions(serviceId: string, request: UpdateServiceRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateServiceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.addresses)) {
    body['addresses'] = request.addresses;
  }
  if (!$isNull(request.agentServiceConfig)) {
    body['agentServiceConfig'] = request.agentServiceConfig;
  }
  if (!$isNull(request.aiServiceConfig)) {
    body['aiServiceConfig'] = request.aiServiceConfig;
  }
  if (!$isNull(request.dnsServers)) {
    body['dnsServers'] = request.dnsServers;
  }
  if (!$isNull(request.healthCheckConfig)) {
    body['healthCheckConfig'] = request.healthCheckConfig;
  }
  if (!$isNull(request.healthyPanicThreshold)) {
    body['healthyPanicThreshold'] = request.healthyPanicThreshold;
  }
  if (!$isNull(request.outlierDetectionConfig)) {
    body['outlierDetectionConfig'] = request.outlierDetectionConfig;
  }
  if (!$isNull(request.ports)) {
    body['ports'] = request.ports;
  }
  if (!$isNull(request.protocol)) {
    body['protocol'] = request.protocol;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateService',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/services/${$URL.percentEncode(serviceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a service. You can call this operation to update the health check, DNS domain name, and fixed address configurations of a service.
 *
 * @param request UpdateServiceRequest
 * @return UpdateServiceResponse
 */
async function updateService(serviceId: string, request: UpdateServiceRequest): UpdateServiceResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceWithOptions(serviceId, request, headers, runtime);
}

model UpdateServiceVersionRequest {
  labels?: [ 
    {
      key?: string(name='key', description='The tag key.

This parameter is required.', example='topology.kubernetes.io/zone'),
      value?: string(name='value', description='The tag value.', example='cn-hangzhou-k'),
    }
  ](name='labels', description='The list of tags.

This parameter is required.'),
}

model UpdateServiceVersionResponseBody = {
  code?: string(name='code', description='The status code returned.', example='Ok'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='A60EE5CA-1294-532A-9775-8D2FD1C6EFBF'),
}

model UpdateServiceVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateServiceVersionResponseBody(name='body'),
}

/**
 * @summary Updates a service version.
 *
 * @param request UpdateServiceVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateServiceVersionResponse
 */
@context("updateServiceVersionWithContext")
async function updateServiceVersionWithOptions(serviceId: string, name: string, request: UpdateServiceVersionRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateServiceVersionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.labels)) {
    body['labels'] = request.labels;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateServiceVersion',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/services/${$URL.percentEncode(serviceId)}/versions/${$URL.percentEncode(name)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a service version.
 *
 * @param request UpdateServiceVersionRequest
 * @return UpdateServiceVersionResponse
 */
async function updateServiceVersion(serviceId: string, name: string, request: UpdateServiceVersionRequest): UpdateServiceVersionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateServiceVersionWithOptions(serviceId, name, request, headers, runtime);
}

model UpgradeGatewayRequest {
  version?: string(name='version', description='The destination instance version.', example='2.0.2'),
}

model UpgradeGatewayResponseBody = {
  code?: string(name='code', description='The status code.', example='Ok'),
  message?: string(name='message', description='The response message returned.', example='success'),
  requestId?: string(name='requestId', description='The request ID.', example='043360DA-ED3B-5386-9B7A-D94DECF99A30'),
}

model UpgradeGatewayResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeGatewayResponseBody(name='body'),
}

/**
 * @summary Updates the version of a Cloud-native API Gateway instance.
 *
 * @param request UpgradeGatewayRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeGatewayResponse
 */
@context("upgradeGatewayWithContext")
async function upgradeGatewayWithOptions(gatewayId: string, request: UpgradeGatewayRequest, headers: map[string]string, runtime: $RuntimeOptions): UpgradeGatewayResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.version)) {
    query['version'] = request.version;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpgradeGateway',
    version = '2024-03-27',
    protocol = 'HTTPS',
    pathname = `/v1/gateways/${$URL.percentEncode(gatewayId)}/upgrade`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the version of a Cloud-native API Gateway instance.
 *
 * @param request UpgradeGatewayRequest
 * @return UpgradeGatewayResponse
 */
async function upgradeGateway(gatewayId: string, request: UpgradeGatewayRequest): UpgradeGatewayResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return upgradeGatewayWithOptions(gatewayId, request, headers, runtime);
}

