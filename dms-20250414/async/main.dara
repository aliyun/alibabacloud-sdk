/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Dms';
  @version = '2025-04-14';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model DLCatalog {
  description?: string(name='Description'),
  location?: string(name='Location'),
  name?: string(name='Name'),
}

model DLColumn {
  comment?: string(name='Comment'),
  name?: string(name='Name'),
  type?: string(name='Type'),
}

model DLDatabase {
  catalogName?: string(name='CatalogName'),
  dbId?: long(name='DbId'),
  description?: string(name='Description'),
  location?: string(name='Location'),
  name?: string(name='Name'),
  parameters?: map[string]any(name='Parameters'),
}

model DLFunction {
  catalogName?: string(name='CatalogName'),
  className?: string(name='ClassName'),
  createTime?: int32(name='CreateTime'),
  creatorId?: long(name='CreatorId'),
  dbName?: string(name='DbName'),
  functionName?: string(name='FunctionName'),
  functionType?: string(name='FunctionType'),
  modifierId?: long(name='ModifierId'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  resourceUris?: [
    DLResourceUri
  ](name='ResourceUris'),
}

model DLFunctionInput {
  className?: string(name='ClassName'),
  createTime?: int32(name='CreateTime'),
  creatorId?: long(name='CreatorId'),
  functionName?: string(name='FunctionName'),
  functionType?: string(name='FunctionType'),
  modifierId?: long(name='ModifierId'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  resourceUris?: [
    DLResourceUri
  ](name='ResourceUris'),
}

model DLOrder {
  col?: string(name='Col'),
  order?: int32(name='Order'),
}

model DLPartition {
  catalogName?: string(name='CatalogName'),
  createTime?: int32(name='CreateTime'),
  dbName?: string(name='DbName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  parameters?: map[string]string(name='Parameters'),
  sd?: DLStorageDescriptor(name='Sd'),
  tableName?: string(name='TableName'),
  values?: [ string ](name='Values'),
}

model DLPartitionInput {
  createTime?: int32(name='CreateTime'),
  lastAccessTime?: int32(name='LastAccessTime'),
  parameters?: map[string]string(name='Parameters'),
  storageDescriptor?: DLStorageDescriptor(name='StorageDescriptor'),
  values?: [ string ](name='Values'),
}

model DLResourceUri {
  resourceType?: string(name='ResourceType'),
  uri?: string(name='Uri'),
}

model DLSerdeInfo {
  description?: string(name='Description'),
  deserializerClass?: string(name='DeserializerClass'),
  name?: string(name='Name'),
  parameters?: map[string]any(name='Parameters'),
  serdeType?: int32(name='SerdeType'),
  serializationLib?: string(name='SerializationLib'),
  serializerClass?: string(name='SerializerClass'),
}

model DLSkewedInfo {
  skewedColNames?: [ string ](name='SkewedColNames'),
  skewedColValueLocationMaps?: map[string]any(name='SkewedColValueLocationMaps'),
  skewedColValues?: [[ string ]  ](name='SkewedColValues'),
}

model DLStorageDescriptor {
  bucketCols?: [ string ](name='BucketCols'),
  columns?: [
    DLColumn
  ](name='Columns'),
  inputFormat?: string(name='InputFormat'),
  isCompressed?: boolean(name='IsCompressed'),
  location?: string(name='Location'),
  numBuckets?: int32(name='NumBuckets'),
  originalColumns?: [
    DLColumn
  ](name='OriginalColumns'),
  outputFormat?: string(name='OutputFormat'),
  parameters?: map[string]any(name='Parameters'),
  serdeInfo?: DLSerdeInfo(name='SerdeInfo'),
  skewedInfo?: DLSkewedInfo(name='SkewedInfo'),
  sortCols?: [
    DLOrder
  ](name='SortCols'),
}

model DLTable {
  catalogName?: string(name='CatalogName'),
  createTime?: int32(name='CreateTime'),
  creatorId?: long(name='CreatorId'),
  dbId?: long(name='DbId'),
  dbName?: string(name='DbName'),
  description?: string(name='Description'),
  lastAccessTime?: int32(name='LastAccessTime'),
  location?: string(name='Location'),
  modifierId?: long(name='ModifierId'),
  name?: string(name='Name'),
  owner?: string(name='Owner'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]any(name='Parameters'),
  partitionKeys?: [
    DLColumn
  ](name='PartitionKeys'),
  retention?: int32(name='Retention'),
  storageDescriptor?: DLStorageDescriptor(name='StorageDescriptor'),
  tableType?: string(name='TableType'),
  viewExpandedText?: string(name='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText'),
}

model DLTableInput {
  createTime?: int32(name='CreateTime'),
  creatorId?: long(name='CreatorId'),
  description?: string(name='Description'),
  lastAccessTime?: int32(name='LastAccessTime'),
  location?: string(name='Location'),
  modifierId?: long(name='ModifierId'),
  name?: string(name='Name'),
  owner?: string(name='Owner'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
    DLColumn
  ](name='PartitionKeys'),
  retention?: int32(name='Retention'),
  storageDescriptor?: DLStorageDescriptor(name='StorageDescriptor'),
  tableType?: string(name='TableType'),
  viewExpandedText?: string(name='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText'),
}

model DLTablebaseInfo {
  catalogName?: string(name='CatalogName'),
  createTime?: int32(name='CreateTime'),
  creatorId?: long(name='CreatorId'),
  dbId?: long(name='DbId'),
  dbName?: string(name='DbName'),
  description?: string(name='Description'),
  lastAccessTime?: int32(name='LastAccessTime'),
  location?: string(name='Location'),
  modifierId?: long(name='ModifierId'),
  name?: string(name='Name'),
  owner?: string(name='Owner'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]any(name='Parameters'),
  partitionKeys?: [
    DLColumn
  ](name='PartitionKeys'),
  retention?: int32(name='Retention'),
  tableType?: string(name='TableType'),
  viewExpandedText?: string(name='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText'),
}

model ForeignInstance {
  dataLinkName?: string(name='DataLinkName'),
  host?: string(name='Host'),
  instanceSource?: string(name='InstanceSource'),
  instanceType?: string(name='InstanceType'),
  port?: int32(name='Port'),
  properties?: map[string]string(name='Properties'),
  regionId?: string(name='RegionId'),
  sid?: string(name='Sid'),
}

model ForeignInstanceCredInfo {
  credInfo?: map[string]string(name='CredInfo'),
  credType?: string(name='CredType'),
}

model PartitionError {
  errorDetail?: string(name='ErrorDetail'),
  values?: [ string ](name='Values'),
}

model BatchCreateDataLakePartitionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  ifNotExists?: boolean(name='IfNotExists', example='true', position='Query'),
  needResult?: boolean(name='NeedResult', example='true', position='Query'),
  partitionInputs: [
    DLPartitionInput
  ](name='PartitionInputs', description='This parameter is required.', shrink='json', position='Body'),
  tableName: string(name='TableName', description='This parameter is required.', example='test_table', position='Query'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model BatchCreateDataLakePartitionsResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  partitions?: [
    DLPartition
  ](name='Partitions'),
  requestId?: string(name='RequestId', example='0C1CB646-1DE4-4AD0-B4A4-7D47DD52****'),
  success?: string(name='Success', example='true'),
}

model BatchCreateDataLakePartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchCreateDataLakePartitionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchCreateDataLakePartitions  BatchCreateDataLakePartitionsRequest
  * @return BatchCreateDataLakePartitionsResponse
 */
async function batchCreateDataLakePartitions(request: BatchCreateDataLakePartitionsRequest): BatchCreateDataLakePartitionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchCreateDataLakePartitions', 'POST', '/', 'json', true, 'form', request);
}

model BatchDeleteDataLakePartitionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  ifExists?: boolean(name='IfExists', example='true', position='Query'),
  partitionValuesList: [[ string ]  ](name='PartitionValuesList', description='This parameter is required.', position='Query'),
  tableName: string(name='TableName', description='This parameter is required.', example='table_name', position='Query'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model BatchDeleteDataLakePartitionsResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors'),
  requestId?: string(name='RequestId', example='5B96E35F-A58E-5399-9041-09CF9A1E****'),
  success?: string(name='Success', example='true'),
}

model BatchDeleteDataLakePartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteDataLakePartitionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchDeleteDataLakePartitions  BatchDeleteDataLakePartitionsRequest
  * @return BatchDeleteDataLakePartitionsResponse
 */
async function batchDeleteDataLakePartitions(request: BatchDeleteDataLakePartitionsRequest): BatchDeleteDataLakePartitionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchDeleteDataLakePartitions', 'POST', '/', 'json', false, 'json', request);
}

model BatchUpdateDataLakePartitionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  partitionInputs: [
    DLPartitionInput
  ](name='PartitionInputs', description='This parameter is required.', shrink='json', position='Body'),
  tableName: string(name='TableName', description='This parameter is required.', example='test_table', position='Query'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model BatchUpdateDataLakePartitionsResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors'),
  requestId?: string(name='RequestId', example='C5B8E84B-42B6-4374-AD5A-6264E175****'),
  success?: boolean(name='Success', example='true'),
}

model BatchUpdateDataLakePartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchUpdateDataLakePartitionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchUpdateDataLakePartitions  BatchUpdateDataLakePartitionsRequest
  * @return BatchUpdateDataLakePartitionsResponse
 */
async function batchUpdateDataLakePartitions(request: BatchUpdateDataLakePartitionsRequest): BatchUpdateDataLakePartitionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchUpdateDataLakePartitions', 'POST', '/', 'json', true, 'form', request);
}

model CreateAirflowRequest {
  regionId?: string(name='RegionId', position='Host'),
  airflowName: string(name='AirflowName', description='This parameter is required.', example='testairflow', position='Query'),
  appSpec: string(name='AppSpec', description='This parameter is required.', example='SMALL', position='Query'),
  clientToken?: string(name='ClientToken', example='token-****', position='Query'),
  dagsDir?: string(name='DagsDir', example='default/dags', position='Query'),
  description: string(name='Description', description='This parameter is required.', example='order scheduler', position='Query'),
  ossBucketName: string(name='OssBucketName', description='This parameter is required.', example='oss-test', position='Query'),
  ossPath: string(name='OssPath', description='This parameter is required.', example='/airflow', position='Query'),
  pluginsDir?: string(name='PluginsDir', example='default/plugins', position='Query'),
  requirementFile?: string(name='RequirementFile', example='default/requirements.txt', position='Query'),
  securityGroupId: string(name='SecurityGroupId', description='This parameter is required.', example='sg-bp108t8ldzeyk1****', position='Query'),
  startupFile?: string(name='StartupFile', example='default/startup.sh', position='Query'),
  vSwitchId: string(name='VSwitchId', description='This parameter is required.', example='vsw-8vbaf073jawozfp****', position='Query'),
  vpcId: string(name='VpcId', description='VPC ID。

This parameter is required.', example='vpc-uf63r6coyiw9o5****', position='Query'),
  workerServerlessReplicas: int32(name='WorkerServerlessReplicas', description='This parameter is required.', example='0', position='Query'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', example='8630242382****', position='Query'),
  zoneId: string(name='ZoneId', description='This parameter is required.', example='cn-hangzhou-h', position='Query'),
}

model CreateAirflowResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail', example='NOT_FOUND'),
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  httpStatusCode?: long(name='HttpStatusCode', example='200'),
  message?: string(name='Message', example='Successful'),
  requestId?: string(name='RequestId', example='67E910F2-4B62-5B0C-ACA3-7547695C****'),
  root?: {
    airflowId?: string(name='AirflowId', example='af-****'),
    airflowName?: string(name='AirflowName', example='testairflow'),
    appSpec?: string(name='AppSpec', example='SMALL'),
    appType?: string(name='AppType', example='airflow'),
    dagsDir?: string(name='DagsDir', example='default/dags'),
    deployErrorMsg?: string(name='DeployErrorMsg', example='vpc not found'),
    description?: string(name='Description', example='order scheduler'),
    gmtCreated?: string(name='GmtCreated', example='2025-08-12T05:46:01.000+0000'),
    ossBucketName?: string(name='OssBucketName', example='oss-test'),
    ossPath?: string(name='OssPath', example='/airflow'),
    pluginsDir?: string(name='PluginsDir', example='default/plugins'),
    requirementFile?: string(name='RequirementFile', example='default/requirements.txt'),
    securityGroupId?: string(name='SecurityGroupId', example='sg-2ze1nak7h0alg1xxx'),
    startupFile?: string(name='StartupFile', example='default/startup.sh'),
    status?: string(name='Status', example='DEPLOYING'),
    vSwitchId?: string(name='VSwitchId', example='vsw-8vbaf073jawozfpbg****'),
    vpcId?: string(name='VpcId', description='VPC ID。', example='vpc-uf63r6coyiw9o5gf****'),
    workerServerlessReplicas?: int32(name='WorkerServerlessReplicas', example='0'),
    workspaceId?: string(name='WorkspaceId', example='86302423828****'),
    zoneId?: string(name='ZoneId', example='cn-hangzhou-h'),
  }(name='Root'),
  success?: boolean(name='Success', example='true'),
}

model CreateAirflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAirflowResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateAirflow  CreateAirflowRequest
  * @return CreateAirflowResponse
 */
async function createAirflow(request: CreateAirflowRequest): CreateAirflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAirflow', 'POST', '/', 'json', false, 'json', request);
}

model CreateAirflowLoginTokenRequest {
  regionId?: string(name='RegionId', position='Host'),
  airflowId: string(name='AirflowId', description='The ID of the Airflow instance. You can view the instance ID on the [Airflow Instances](https://help.aliyun.com/document_detail/2881043.html) page.

This parameter is required.', example='af-b3a7f110a6vmvn7xxxxxx', position='Query'),
}

model CreateAirflowLoginTokenResponseBody = {
  code?: string(name='Code', description='The status code. The status code 200 indicates that the request was successful.', example='200'),
  data?: {
    host?: string(name='Host', description='The endpoint that is used to access the Airflow instance.', example='https://data-dms.aliyuncs.com/airflow/x/xxxx/af-ehrmszbxxxxxxx'),
    token?: string(name='Token', description='The generated token.', example='f432d77de03b6b95fc24f91414e29c'),
  }(name='Data', description='The result of the site monitoring task.'),
  errorCode?: string(name='ErrorCode', description='The error code returned if the call failed. Variable description:

*   If the request was successful, this parameter is not returned.
*   This parameter is returned only if the request failed.

For more information, see the "Error codes" section in this topic.', example='Success'),
  httpStatusCode?: int32(name='HttpStatusCode', description='The description of the error code.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='Successful'),
  requestId?: string(name='RequestId', description='The request ID. You can use the ID to locate logs and troubleshoot issues.', example='4284D079-30F4-5B23-ADC4-28F291622C9A'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   True
*   False', example='True'),
}

model CreateAirflowLoginTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAirflowLoginTokenResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateAirflowLoginToken  CreateAirflowLoginTokenRequest
  * @return CreateAirflowLoginTokenResponse
 */
async function createAirflowLoginToken(request: CreateAirflowLoginTokenRequest): CreateAirflowLoginTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAirflowLoginToken', 'POST', '/', 'json', false, 'json', request);
}

model CreateDataLakeDatabaseRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  description?: string(name='Description', example='test', position='Query'),
  location: string(name='Location', description='This parameter is required.', example='oss://path/to/database', position='Query'),
  parameters?: map[string]string(name='Parameters', shrink='json', position='Query'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model CreateDataLakeDatabaseResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  requestId?: string(name='RequestId', example='D911009F-3E95-5AFD-8CF1-73F7B4F1****'),
  success?: boolean(name='Success', example='true'),
}

model CreateDataLakeDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDataLakeDatabaseResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateDataLakeDatabase  CreateDataLakeDatabaseRequest
  * @return CreateDataLakeDatabaseResponse
 */
async function createDataLakeDatabase(request: CreateDataLakeDatabaseRequest): CreateDataLakeDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDataLakeDatabase', 'POST', '/', 'json', false, 'json', request);
}

model CreateDataLakeFunctionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  functionInput: DLFunctionInput(name='FunctionInput', description='This parameter is required.', shrink='json', position='Body'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model CreateDataLakeFunctionResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  function?: DLFunction(name='Function'),
  requestId?: string(name='RequestId', example='EE214ECD-4330-503A-82F0-FFB03975****'),
  success?: boolean(name='Success', example='true'),
}

model CreateDataLakeFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDataLakeFunctionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateDataLakeFunction  CreateDataLakeFunctionRequest
  * @return CreateDataLakeFunctionResponse
 */
async function createDataLakeFunction(request: CreateDataLakeFunctionRequest): CreateDataLakeFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDataLakeFunction', 'POST', '/', 'json', true, 'form', request);
}

model CreateDataLakePartitionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  ifNotExists?: boolean(name='IfNotExists', example='true', position='Query'),
  needResult?: boolean(name='NeedResult', example='true', position='Query'),
  partitionInput: DLPartitionInput(name='PartitionInput', description='This parameter is required.', shrink='json', position='Body'),
  tableName: string(name='TableName', description='This parameter is required.', example='test_table', position='Query'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model CreateDataLakePartitionResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  partition?: DLPartition(name='Partition'),
  requestId?: string(name='RequestId', example='427688B8-ADFB-4C4E-9D45-EF5C1FD6****'),
  success?: boolean(name='Success', example='true'),
}

model CreateDataLakePartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDataLakePartitionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateDataLakePartition  CreateDataLakePartitionRequest
  * @return CreateDataLakePartitionResponse
 */
async function createDataLakePartition(request: CreateDataLakePartitionRequest): CreateDataLakePartitionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDataLakePartition', 'POST', '/', 'json', true, 'form', request);
}

model CreateDataLakeTableRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  tableInput: DLTableInput(name='TableInput', description='This parameter is required.', shrink='json', position='Body'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model CreateDataLakeTableResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  requestId?: string(name='RequestId', example='7FAD400F-7A5C-4193-8F9A-39D86C4F****'),
  success?: boolean(name='Success', example='true'),
  table?: DLTable(name='Table'),
}

model CreateDataLakeTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDataLakeTableResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateDataLakeTable  CreateDataLakeTableRequest
  * @return CreateDataLakeTableResponse
 */
async function createDataLakeTable(request: CreateDataLakeTableRequest): CreateDataLakeTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDataLakeTable', 'POST', '/', 'json', true, 'form', request);
}

model DeleteAirflowRequest {
  regionId?: string(name='RegionId', position='Host'),
  airflowId: string(name='AirflowId', description='This parameter is required.', example='af-test****', position='Query'),
  clientToken?: string(name='ClientToken', example='token-****', position='Query'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', example='86302423828****', position='Query'),
}

model DeleteAirflowResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail', example='NOT_FOUND'),
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  httpStatusCode?: long(name='HttpStatusCode', example='200'),
  message?: string(name='Message', example='Instance not found.'),
  requestId?: string(name='RequestId', example='E0D21075-CD3E-4D98-8264-****'),
  root?: {
    responses?: [ 
      {
        success?: boolean(name='Success', example='true'),
        uuid?: string(name='Uuid', example='af-test****'),
      }
    ](name='Responses'),
  }(name='Root'),
  success?: boolean(name='Success', example='true'),
}

model DeleteAirflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAirflowResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteAirflow  DeleteAirflowRequest
  * @return DeleteAirflowResponse
 */
async function deleteAirflow(request: DeleteAirflowRequest): DeleteAirflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAirflow', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDataLakeDatabaseRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model DeleteDataLakeDatabaseResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  requestId?: string(name='RequestId', example='C51420E3-144A-4A94-B473-8662FCF4****'),
  success?: boolean(name='Success', example='true'),
}

model DeleteDataLakeDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDataLakeDatabaseResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteDataLakeDatabase  DeleteDataLakeDatabaseRequest
  * @return DeleteDataLakeDatabaseResponse
 */
async function deleteDataLakeDatabase(request: DeleteDataLakeDatabaseRequest): DeleteDataLakeDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDataLakeDatabase', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDataLakeFunctionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  functionName: string(name='FunctionName', description='This parameter is required.', example='my_funciton', position='Query'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model DeleteDataLakeFunctionResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  requestId?: string(name='RequestId', example='B4B07137-F6AE-4756-8474-7F92BB6C****'),
  success?: boolean(name='Success', example='true'),
}

model DeleteDataLakeFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDataLakeFunctionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteDataLakeFunction  DeleteDataLakeFunctionRequest
  * @return DeleteDataLakeFunctionResponse
 */
async function deleteDataLakeFunction(request: DeleteDataLakeFunctionRequest): DeleteDataLakeFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDataLakeFunction', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDataLakePartitionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  ifExists?: boolean(name='IfExists', example='true', position='Query'),
  partitionValues: [ string ](name='PartitionValues', description='This parameter is required.', shrink='simple', position='Query'),
  tableName: string(name='TableName', description='This parameter is required.', example='table_name', position='Query'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model DeleteDataLakePartitionResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  requestId?: string(name='RequestId', example='0C1CB646-1DE4-4AD0-B4A4-7D47DD52****'),
  success?: boolean(name='Success', example='true'),
}

model DeleteDataLakePartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDataLakePartitionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteDataLakePartition  DeleteDataLakePartitionRequest
  * @return DeleteDataLakePartitionResponse
 */
async function deleteDataLakePartition(request: DeleteDataLakePartitionRequest): DeleteDataLakePartitionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDataLakePartition', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDataLakeTableRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  tableName: string(name='TableName', description='This parameter is required.', example='test_table', position='Query'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model DeleteDataLakeTableResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  requestId?: string(name='RequestId', example='8E88933E-E3D4-5BA8-8CBF-0A1CAE66****'),
  success?: boolean(name='Success', example='true'),
}

model DeleteDataLakeTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDataLakeTableResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteDataLakeTable  DeleteDataLakeTableRequest
  * @return DeleteDataLakeTableResponse
 */
async function deleteDataLakeTable(request: DeleteDataLakeTableRequest): DeleteDataLakeTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDataLakeTable', 'POST', '/', 'json', false, 'json', request);
}

model GetAirflowRequest {
  regionId?: string(name='RegionId', position='Host'),
  airflowId: string(name='AirflowId', description='This parameter is required.', example='af-b3a7f110a6vmvn7****', position='Query'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', example='8630242382****', position='Query'),
}

model GetAirflowResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail', example='NOT_FOUND'),
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  httpStatusCode?: long(name='HttpStatusCode', example='200'),
  message?: string(name='Message', example='Unknown error'),
  requestId?: string(name='RequestId', description='Reuqest ID。', example='E0D21075-CD3E-4D98-8264-****'),
  root?: {
    airflowId?: string(name='AirflowId', example='af-7a6ygsh80dx1jn****'),
    airflowName?: string(name='AirflowName', example='testairflow'),
    appSpec?: string(name='AppSpec', example='SMALL'),
    appType?: string(name='AppType', example='AIRFLOW'),
    customAirflowCfg?: [ string ](name='CustomAirflowCfg'),
    dagsDir?: string(name='DagsDir', example='default/dags'),
    deployErrorMsg?: string(name='DeployErrorMsg', example='Deployed'),
    description?: string(name='Description', example='test airflow'),
    gmtCreated?: string(name='GmtCreated', example='2025-08-12T05:46:01.000+0000'),
    ossBucketName?: string(name='OssBucketName', example='osstest'),
    ossPath?: string(name='OssPath', example='/airflow'),
    pluginsDir?: string(name='PluginsDir', example='default/plugins'),
    regionId?: string(name='RegionId', example='cn-hangzhou'),
    requirementFile?: string(name='RequirementFile', example='default/requirements.txt'),
    securityGroupId?: string(name='SecurityGroupId', example='sg-2ze9gj646bkv****'),
    startupFile?: string(name='StartupFile', example='default/startup.sh'),
    status?: string(name='Status', example='DEPLOYED'),
    vSwitchId?: string(name='VSwitchId', example='vsw-bp1931trfxkvf74v****'),
    vpcId?: string(name='VpcId', description='VPC ID。', example='vpc-2zevqv4obraqd5p****'),
    workerServerlessReplicas?: int32(name='WorkerServerlessReplicas', example='0'),
    workspaceId?: string(name='WorkspaceId', example='8630242382****'),
    zoneId?: string(name='ZoneId', example='cn-hangzhou-h'),
  }(name='Root'),
  success?: boolean(name='Success', example='true'),
}

model GetAirflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAirflowResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetAirflow  GetAirflowRequest
  * @return GetAirflowResponse
 */
async function getAirflow(request: GetAirflowRequest): GetAirflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAirflow', 'POST', '/', 'json', false, 'json', request);
}

model GetDataLakeCatalogRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  tid?: long(name='Tid', example='3****', minimum=1, maximum=9223372036854775807, position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model GetDataLakeCatalogResponseBody = {
  catalog?: DLCatalog(name='Catalog'),
  errorCode?: string(name='ErrorCode', example='400'),
  errorMessage?: string(name='ErrorMessage', example='code: 404, can not find catalog, name : hiv request id: 6090E571-E5B1-1E6D-BF44-F9E10E8B****'),
  requestId?: string(name='RequestId', example='FE8EE2F1-4880-46BC-A704-5CF63EAF****'),
  success?: boolean(name='Success', example='true'),
}

model GetDataLakeCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDataLakeCatalogResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetDataLakeCatalog  GetDataLakeCatalogRequest
  * @return GetDataLakeCatalogResponse
 */
async function getDataLakeCatalog(request: GetDataLakeCatalogRequest): GetDataLakeCatalogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataLakeCatalog', 'POST', '/', 'json', false, 'json', request);
}

model GetDataLakeDatabaseRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  name: string(name='Name', description='This parameter is required.', example='default', position='Query'),
  tid?: long(name='Tid', example='3****', minimum=1, maximum=9223372036854775807, position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model GetDataLakeDatabaseResponseBody = {
  database?: DLDatabase(name='Database'),
  errorCode?: string(name='ErrorCode', example='404'),
  errorMessage?: string(name='ErrorMessage', example='code: 404, can not find catalog, name : hive1 request id: FF737753-9641-1F51-AFDA-7DF54111****'),
  requestId?: string(name='RequestId', example='E5EE2B9E-2F95-57FA-B284-CB441CEE****'),
  success?: boolean(name='Success', example='true'),
}

model GetDataLakeDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDataLakeDatabaseResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetDataLakeDatabase  GetDataLakeDatabaseRequest
  * @return GetDataLakeDatabaseResponse
 */
async function getDataLakeDatabase(request: GetDataLakeDatabaseRequest): GetDataLakeDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataLakeDatabase', 'POST', '/', 'json', false, 'json', request);
}

model GetDataLakeFunctionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  functionName: string(name='FunctionName', description='This parameter is required.', example='my_funciton', position='Query'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model GetDataLakeFunctionResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  function?: DLFunction(name='Function'),
  requestId?: string(name='RequestId', example='D911009F-3E95-5AFD-8CF1-73F7B4F1****'),
  success?: boolean(name='Success', example='true'),
}

model GetDataLakeFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDataLakeFunctionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetDataLakeFunction  GetDataLakeFunctionRequest
  * @return GetDataLakeFunctionResponse
 */
async function getDataLakeFunction(request: GetDataLakeFunctionRequest): GetDataLakeFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataLakeFunction', 'POST', '/', 'json', false, 'json', request);
}

model GetDataLakePartitionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  partitionValues: [ string ](name='PartitionValues', description='This parameter is required.', shrink='simple', position='Query'),
  tableName: string(name='TableName', description='This parameter is required.', example='test_table', position='Query'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model GetDataLakePartitionResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  partition?: DLPartition(name='Partition'),
  requestId?: string(name='RequestId', example='FE8EE2F1-4880-46BC-A704-5CF63EAF****'),
  success?: boolean(name='Success', example='true'),
}

model GetDataLakePartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDataLakePartitionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetDataLakePartition  GetDataLakePartitionRequest
  * @return GetDataLakePartitionResponse
 */
async function getDataLakePartition(request: GetDataLakePartitionRequest): GetDataLakePartitionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataLakePartition', 'POST', '/', 'json', false, 'json', request);
}

model GetDataLakeTableRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  name: string(name='Name', description='This parameter is required.', example='100g_customer', position='Query'),
  tid?: long(name='Tid', example='3****', minimum=1, maximum=9223372036854775807, position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model GetDataLakeTableResponseBody = {
  errorCode?: string(name='ErrorCode', example='400'),
  errorMessage?: string(name='ErrorMessage', example='Unknown server error'),
  requestId?: string(name='RequestId', example='4E1D2B4D-3E53-4ABC-999D-1D2520B3****'),
  success?: string(name='Success', example='true'),
  table?: DLTable(name='Table'),
}

model GetDataLakeTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDataLakeTableResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetDataLakeTable  GetDataLakeTableRequest
  * @return GetDataLakeTableResponse
 */
async function getDataLakeTable(request: GetDataLakeTableRequest): GetDataLakeTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDataLakeTable', 'POST', '/', 'json', false, 'json', request);
}

model ListAirflowsRequest {
  regionId?: string(name='RegionId', position='Host'),
  maxResults?: int32(name='MaxResults', example='20', minimum=0, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', example='f056501ada12****', position='Query'),
  pageIndex?: int32(name='PageIndex', example='1', position='Query'),
  skip?: int32(name='Skip', example='5', position='Query'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', example='86302423828****', position='Query'),
}

model ListAirflowsResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail', example='NOT_FOUND'),
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  httpStatusCode?: long(name='HttpStatusCode', example='200'),
  maxResults?: int32(name='MaxResults', example='20'),
  message?: string(name='Message', example='Successful'),
  nextToken?: string(name='NextToken', example='NesLoKLEdIZrKhDT7I2gS****'),
  requestId?: string(name='RequestId', description='Reuqest ID。', example='67E910F2-4B62-5B0C-ACA3-7547695C****'),
  root?: {
    list?: [ 
      {
        airflowId?: string(name='AirflowId', example='af-7a6ygsh80d****'),
        airflowName?: string(name='AirflowName', example='test-airflow'),
        appSpec?: string(name='AppSpec', example='SMALL'),
        appType?: string(name='AppType', example='AIRFLOW'),
        customAirflowCfg?: [ string ](name='CustomAirflowCfg'),
        dagsDir?: string(name='DagsDir', example='default/dags'),
        deployErrorMsg?: string(name='DeployErrorMsg', example='quota exists'),
        description?: string(name='Description', example='test'),
        gmtCreated?: string(name='GmtCreated', example='2025-08-12T05:46:01.000+0000'),
        ossBucketName?: string(name='OssBucketName', example='osstest'),
        ossPath?: string(name='OssPath', example='/airflow'),
        pluginsDir?: string(name='PluginsDir', example='default/plugins'),
        requirementFile?: string(name='RequirementFile', example='default/requirements.txt'),
        securityGroupId?: string(name='SecurityGroupId', example='sg-2ze1nak7h0alg1w****'),
        startupFile?: string(name='StartupFile', example='default/startup.sh'),
        status?: string(name='Status', example='DEPLOYED'),
        vSwitchId?: string(name='VSwitchId', example='vsw-uf6sxdc22x7sbdb****'),
        vpcId?: string(name='VpcId', description='VPC ID。', example='vpc-8vbbfm33dy0y1pek****'),
        workerServerlessReplicas?: int32(name='WorkerServerlessReplicas', example='0'),
        workspaceId?: string(name='WorkspaceId', example='8630242382****'),
        zoneId?: string(name='ZoneId', example='cn-hangzhou-h'),
      }
    ](name='List'),
    totalCount?: int32(name='TotalCount', example='100'),
  }(name='Root'),
  success?: boolean(name='Success', example='true'),
}

model ListAirflowsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAirflowsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListAirflows  ListAirflowsRequest
  * @return ListAirflowsResponse
 */
async function listAirflows(request: ListAirflowsRequest): ListAirflowsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAirflows', 'POST', '/', 'json', false, 'json', request);
}

model ListDataLakeCatalogRequest {
  regionId?: string(name='RegionId', position='Host'),
  searchKey?: string(name='SearchKey', example='hive', position='Query'),
  tid?: long(name='Tid', example='3****', minimum=1, maximum=9223372036854775807, position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model ListDataLakeCatalogResponseBody = {
  cataLogList?: [
    DLCatalog
  ](name='CataLogList'),
  errorCode?: string(name='ErrorCode', example='400'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  requestId?: string(name='RequestId', example='E76DD2E7-EBAC-5724-B163-19AAC233****'),
  success?: boolean(name='Success', example='true'),
}

model ListDataLakeCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataLakeCatalogResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListDataLakeCatalog  ListDataLakeCatalogRequest
  * @return ListDataLakeCatalogResponse
 */
async function listDataLakeCatalog(request: ListDataLakeCatalogRequest): ListDataLakeCatalogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataLakeCatalog', 'POST', '/', 'json', false, 'json', request);
}

model ListDataLakeDatabaseRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  maxResults?: int32(name='MaxResults', example='20', minimum=0, position='Query'),
  nextToken?: string(name='NextToken', example='f056501ada12****', position='Query'),
  searchKey?: string(name='SearchKey', example='default', position='Query'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model ListDataLakeDatabaseResponseBody = {
  databaseList?: [
    DLDatabase
  ](name='DatabaseList'),
  errorCode?: string(name='ErrorCode', example='400'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  maxResults?: int32(name='MaxResults', example='20'),
  nextToken?: string(name='NextToken', example='NesLoKLEdIZrKhDT7I2g****'),
  requestId?: string(name='RequestId', example='4E1D2B4D-3E53-4ABC-999D-1D2520B3****'),
  success?: boolean(name='Success', example='true'),
}

model ListDataLakeDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataLakeDatabaseResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListDataLakeDatabase  ListDataLakeDatabaseRequest
  * @return ListDataLakeDatabaseResponse
 */
async function listDataLakeDatabase(request: ListDataLakeDatabaseRequest): ListDataLakeDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataLakeDatabase', 'POST', '/', 'json', false, 'json', request);
}

model ListDataLakeFunctionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName?: string(name='DbName', example='default', position='Query'),
  functionNamePattern?: string(name='FunctionNamePattern', example='.*', position='Query'),
  maxResults?: int32(name='MaxResults', example='20', minimum=0, position='Query'),
  nextToken?: string(name='NextToken', example='f056501ada12****', position='Query'),
  tid?: long(name='Tid', example='3****', minimum=1, maximum=9223372036854775807, position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model ListDataLakeFunctionResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  functionList?: [
    DLFunction
  ](name='FunctionList'),
  maxResults?: int32(name='MaxResults', example='20'),
  nextToken?: string(name='NextToken', example='f056501ada12****'),
  requestId?: string(name='RequestId', example='7FAD400F-7A5C-4193-8F9A-39D86C4F****'),
  success?: boolean(name='Success', example='true'),
}

model ListDataLakeFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataLakeFunctionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListDataLakeFunction  ListDataLakeFunctionRequest
  * @return ListDataLakeFunctionResponse
 */
async function listDataLakeFunction(request: ListDataLakeFunctionRequest): ListDataLakeFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataLakeFunction', 'POST', '/', 'json', false, 'json', request);
}

model ListDataLakeFunctionNameRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  functionNamePattern?: string(name='FunctionNamePattern', example='.*', position='Query'),
  maxResults?: int32(name='MaxResults', example='20', minimum=0, position='Query'),
  nextToken?: string(name='NextToken', example='f056501ada12****', position='Query'),
  tid?: long(name='Tid', example='3****', minimum=1, maximum=9223372036854775807, position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model ListDataLakeFunctionNameResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  functionNameList?: [ string ](name='FunctionNameList'),
  maxResults?: int32(name='MaxResults', example='20'),
  nextToken?: string(name='NextToken', example='f056501ada12****'),
  requestId?: string(name='RequestId', example='F1C78D32-1AFD-58AD-9DD2-C8A08969****'),
  success?: boolean(name='Success', example='true'),
}

model ListDataLakeFunctionNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataLakeFunctionNameResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListDataLakeFunctionName  ListDataLakeFunctionNameRequest
  * @return ListDataLakeFunctionNameResponse
 */
async function listDataLakeFunctionName(request: ListDataLakeFunctionNameRequest): ListDataLakeFunctionNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataLakeFunctionName', 'POST', '/', 'json', false, 'json', request);
}

model ListDataLakePartitionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  maxResults?: int32(name='MaxResults', example='20', minimum=0, position='Query'),
  nextToken?: string(name='NextToken', example='f056501ada12****', position='Query'),
  partNames?: [ string ](name='PartNames', shrink='json', position='Body'),
  tableName: string(name='TableName', description='This parameter is required.', example='test_table', position='Query'),
  tid?: long(name='Tid', example='3****', minimum=1, maximum=9223372036854775807, position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model ListDataLakePartitionResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  maxResults?: int32(name='MaxResults', example='20'),
  nextToken?: string(name='NextToken', example='NesLoKLEdIZrKhDT7I2gS****'),
  partitionList?: [
    DLPartition
  ](name='PartitionList'),
  requestId?: string(name='RequestId', example='0C1CB646-1DE4-4AD0-B4A4-7D47DD52****'),
  success?: boolean(name='Success', example='true'),
}

model ListDataLakePartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataLakePartitionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListDataLakePartition  ListDataLakePartitionRequest
  * @return ListDataLakePartitionResponse
 */
async function listDataLakePartition(request: ListDataLakePartitionRequest): ListDataLakePartitionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataLakePartition', 'POST', '/', 'json', true, 'form', request);
}

model ListDataLakePartitionByFilterRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  filter: string(name='Filter', description='This parameter is required.', example='ds>20241201', position='Body'),
  maxResults?: int32(name='MaxResults', example='20', minimum=0, position='Query'),
  nextToken?: string(name='NextToken', example='f056501ada12****', position='Query'),
  tableName: string(name='TableName', description='This parameter is required.', example='test_table', position='Query'),
  tid?: long(name='Tid', example='3****', minimum=1, maximum=9223372036854775807, position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model ListDataLakePartitionByFilterResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  maxResults?: int32(name='MaxResults', example='20'),
  nextToken?: string(name='NextToken', example='NesLoKLEdIZrKhDT7I2gS****'),
  partitionList?: [
    DLPartition
  ](name='PartitionList'),
  requestId?: string(name='RequestId', example='427688B8-ADFB-4C4E-9D45-EF5C1FD6****'),
  success?: boolean(name='Success', example='true'),
}

model ListDataLakePartitionByFilterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataLakePartitionByFilterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListDataLakePartitionByFilter  ListDataLakePartitionByFilterRequest
  * @return ListDataLakePartitionByFilterResponse
 */
async function listDataLakePartitionByFilter(request: ListDataLakePartitionByFilterRequest): ListDataLakePartitionByFilterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataLakePartitionByFilter', 'POST', '/', 'json', true, 'form', request);
}

model ListDataLakePartitionNameRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  maxResults?: int32(name='MaxResults', example='20', minimum=0, position='Query'),
  nextToken?: string(name='NextToken', example='f056501ada12****', position='Query'),
  tableName: string(name='TableName', description='This parameter is required.', example='table_name', position='Query'),
  tid?: long(name='Tid', example='3****', minimum=1, maximum=9223372036854775807, position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model ListDataLakePartitionNameResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  maxResults?: int32(name='MaxResults', example='20'),
  nextToken?: string(name='NextToken', example='NesLoKLEdIZrKhDT7I2gS****'),
  partitionNameList?: [ string ](name='PartitionNameList'),
  requestId?: string(name='RequestId', example='0C1CB646-1DE4-4AD0-B4A4-7D47DD52****'),
  success?: boolean(name='Success', example='true'),
}

model ListDataLakePartitionNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataLakePartitionNameResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListDataLakePartitionName  ListDataLakePartitionNameRequest
  * @return ListDataLakePartitionNameResponse
 */
async function listDataLakePartitionName(request: ListDataLakePartitionNameRequest): ListDataLakePartitionNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataLakePartitionName', 'POST', '/', 'json', false, 'json', request);
}

model ListDataLakeTableRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  maxResults?: int32(name='MaxResults', example='20', minimum=0, position='Query'),
  nextToken?: string(name='NextToken', example='f056501ada12****', position='Query'),
  tableNamePattern?: string(name='TableNamePattern', example='.*', position='Query'),
  tableType?: string(name='TableType', example='MANAGED_TABLE', position='Query'),
  tid?: long(name='Tid', example='3****', minimum=1, maximum=9223372036854775807, position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model ListDataLakeTableResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  maxResults?: int32(name='MaxResults', example='20'),
  nextToken?: string(name='NextToken', example='NesLoKLEdIZrKhDT7I2gS****'),
  requestId?: string(name='RequestId', example='3D3FB827-E667-50DB-AD59-C83F8237****'),
  success?: boolean(name='Success', example='true'),
  tableList?: [
    DLTable
  ](name='TableList'),
}

model ListDataLakeTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataLakeTableResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListDataLakeTable  ListDataLakeTableRequest
  * @return ListDataLakeTableResponse
 */
async function listDataLakeTable(request: ListDataLakeTableRequest): ListDataLakeTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataLakeTable', 'POST', '/', 'json', false, 'json', request);
}

model ListDataLakeTableNameRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  maxResults?: int32(name='MaxResults', example='20', minimum=0, position='Query'),
  nextToken?: string(name='NextToken', example='f056501ada12****', position='Query'),
  tableNamePattern?: string(name='TableNamePattern', example='.*', position='Query'),
  tableType?: string(name='TableType', example='MANAGED_TABLE', position='Query'),
  tid?: long(name='Tid', example='3****', minimum=1, maximum=9223372036854775807, position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model ListDataLakeTableNameResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  maxResults?: int32(name='MaxResults', example='20'),
  nextToken?: string(name='NextToken', example='NesLoKLEdIZrKhDT7I2gS****'),
  requestId?: string(name='RequestId', example='C5B8E84B-42B6-4374-AD5A-6264E175****'),
  success?: boolean(name='Success', example='true'),
  tableNameList?: [ string ](name='TableNameList'),
}

model ListDataLakeTableNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataLakeTableNameResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListDataLakeTableName  ListDataLakeTableNameRequest
  * @return ListDataLakeTableNameResponse
 */
async function listDataLakeTableName(request: ListDataLakeTableNameRequest): ListDataLakeTableNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataLakeTableName', 'POST', '/', 'json', false, 'json', request);
}

model ListDataLakeTablebaseInfoRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  page?: int32(name='Page', example='1', minimum=1, position='Query'),
  rows?: int32(name='Rows', example='10', minimum=0, maximum=200, position='Query'),
  searchKey?: string(name='SearchKey', example='test', position='Query'),
  tid?: long(name='Tid', example='3****', minimum=1, maximum=9223372036854775807, position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model ListDataLakeTablebaseInfoResponseBody = {
  errorCode?: string(name='ErrorCode', example='400'),
  errorMessage?: string(name='ErrorMessage', example='Specified parameter Rows is not valid.'),
  requestId?: string(name='RequestId', example='B43AD641-49C2-5299-9E06-1B37EC1B****'),
  success?: boolean(name='Success', example='true'),
  tablebaseInfoList?: [
    DLTablebaseInfo
  ](name='TablebaseInfoList'),
  totalCount?: string(name='TotalCount', example='100'),
}

model ListDataLakeTablebaseInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataLakeTablebaseInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListDataLakeTablebaseInfo  ListDataLakeTablebaseInfoRequest
  * @return ListDataLakeTablebaseInfoResponse
 */
async function listDataLakeTablebaseInfo(request: ListDataLakeTablebaseInfoRequest): ListDataLakeTablebaseInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataLakeTablebaseInfo', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAirflowRequest {
  regionId?: string(name='RegionId', position='Host'),
  airflowId: string(name='AirflowId', description='This parameter is required.', example='af-test****', position='Query'),
  airflowName?: string(name='AirflowName', example='testairflow', position='Query'),
  appSpec?: string(name='AppSpec', example='SMALL', position='Query'),
  clientToken?: string(name='ClientToken', example='token-****', position='Query'),
  dagsDir?: string(name='DagsDir', example='default/dags', position='Query'),
  description?: string(name='Description', example='test airflow', position='Query'),
  pluginsDir?: string(name='PluginsDir', example='default/plugins', position='Query'),
  requirementFile?: string(name='RequirementFile', example='default/requirements.txt', position='Query'),
  startupFile?: string(name='StartupFile', example='default/startup.sh', position='Query'),
  workerServerlessReplicas?: int32(name='WorkerServerlessReplicas', example='0', position='Query'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', example='863024238280****', position='Query'),
}

model UpdateAirflowResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail', example='NOT_FOUND'),
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  httpStatusCode?: long(name='HttpStatusCode', example='200'),
  message?: string(name='Message', example='Unknown error'),
  requestId?: string(name='RequestId', example='E0D21075-CD3E-4D98-8264-F****'),
  root?: {
    airflowName?: string(name='AirflowName', example='test airflow'),
    appSpec?: string(name='AppSpec', description='SMALL。', example='SMALL'),
    appType?: string(name='AppType', example='AIRFLOW'),
    customAirflowCfg?: [ string ](name='CustomAirflowCfg'),
    dagsDir?: string(name='DagsDir', example='default/dags'),
    deployErrorMsg?: string(name='DeployErrorMsg', example='quota exists'),
    description?: string(name='Description', example='order schedule'),
    environments?: string(name='Environments', example='k=v'),
    gmtCreated?: string(name='GmtCreated', example='2025-01-07T15:10:32+08:00'),
    ossBucketName?: string(name='OssBucketName', example='osstest'),
    ossPath?: string(name='OssPath', example='/airflow'),
    pluginsDir?: string(name='PluginsDir', example='default/plugins'),
    requirementFile?: string(name='RequirementFile', example='default/requirements.txt'),
    requirements?: string(name='Requirements', example='jieba==0.42'),
    securityGroupId?: string(name='SecurityGroupId', example='sg-2ze1nak7h0alg1w5****'),
    startupFile?: string(name='StartupFile', example='default/startup.sh'),
    status?: string(name='Status', example='DEPLOYED'),
    uuid?: string(name='Uuid', example='af-xxx'),
    vSwitchId?: string(name='VSwitchId', example='vsw-hp3hyga33aur8tj36****'),
    vpcId?: string(name='VpcId', description='VPC ID。', example='vpc-bp16ko44pgciwv0****'),
    workerServerlessReplicas?: int32(name='WorkerServerlessReplicas', example='0'),
    workspaceId?: string(name='WorkspaceId', example='86302423828****'),
    zoneId?: string(name='ZoneId', example='cn-hangzhou-j'),
  }(name='Root'),
  success?: boolean(name='Success', example='true'),
}

model UpdateAirflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAirflowResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateAirflow  UpdateAirflowRequest
  * @return UpdateAirflowResponse
 */
async function updateAirflow(request: UpdateAirflowRequest): UpdateAirflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAirflow', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDataLakeDatabaseRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  description?: string(name='Description', example='test', position='Query'),
  location: string(name='Location', description='This parameter is required.', example='oss://path/to/database', position='Query'),
  parameters?: map[string]string(name='Parameters', shrink='json', position='Query'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model UpdateDataLakeDatabaseResponseBody = {
  database?: DLDatabase(name='Database'),
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  requestId?: string(name='RequestId', example='4E1D2B4D-3E53-4ABC-999D-1D2520B3****'),
  success?: boolean(name='Success', example='true'),
}

model UpdateDataLakeDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDataLakeDatabaseResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateDataLakeDatabase  UpdateDataLakeDatabaseRequest
  * @return UpdateDataLakeDatabaseResponse
 */
async function updateDataLakeDatabase(request: UpdateDataLakeDatabaseRequest): UpdateDataLakeDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDataLakeDatabase', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDataLakeFunctionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  functionInput: DLFunctionInput(name='FunctionInput', description='This parameter is required.', shrink='json', position='Body'),
  functionName: string(name='FunctionName', description='This parameter is required.', example='my_funciton', position='Query'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model UpdateDataLakeFunctionResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  function?: DLFunction(name='Function'),
  requestId?: string(name='RequestId', example='C1D39814-9808-47F8-AFE0-AF167239****'),
  success?: boolean(name='Success', example='true'),
}

model UpdateDataLakeFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDataLakeFunctionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateDataLakeFunction  UpdateDataLakeFunctionRequest
  * @return UpdateDataLakeFunctionResponse
 */
async function updateDataLakeFunction(request: UpdateDataLakeFunctionRequest): UpdateDataLakeFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDataLakeFunction', 'POST', '/', 'json', true, 'form', request);
}

model UpdateDataLakePartitionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  partitionInput: DLPartitionInput(name='PartitionInput', description='This parameter is required.', shrink='json', position='Body'),
  tableName: string(name='TableName', description='This parameter is required.', example='table_name', position='Query'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model UpdateDataLakePartitionResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  requestId?: string(name='RequestId', example='427688B8-ADFB-4C4E-9D45-EF5C1FD6****'),
  success?: boolean(name='Success', example='true'),
}

model UpdateDataLakePartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDataLakePartitionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateDataLakePartition  UpdateDataLakePartitionRequest
  * @return UpdateDataLakePartitionResponse
 */
async function updateDataLakePartition(request: UpdateDataLakePartitionRequest): UpdateDataLakePartitionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDataLakePartition', 'POST', '/', 'json', true, 'form', request);
}

model UpdateDataLakeTableRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogName: string(name='CatalogName', description='This parameter is required.', example='hive', position='Query'),
  dbName: string(name='DbName', description='This parameter is required.', example='default', position='Query'),
  tableInput: DLTableInput(name='TableInput', description='This parameter is required.', shrink='json', position='Body'),
  tableName?: string(name='TableName', example='100g_customer', position='Query'),
  tid?: long(name='Tid', example='3****', position='Query'),
  workspaceId?: long(name='WorkspaceId', example='12****', position='Query'),
}

model UpdateDataLakeTableResponseBody = {
  errorCode?: string(name='ErrorCode', example='UnknownError'),
  errorMessage?: string(name='ErrorMessage', example='UnknownError'),
  requestId?: string(name='RequestId', example='C5B8E84B-42B6-4374-AD5A-6264E175****'),
  success?: boolean(name='Success', example='true'),
  table?: DLTable(name='Table'),
}

model UpdateDataLakeTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDataLakeTableResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateDataLakeTable  UpdateDataLakeTableRequest
  * @return UpdateDataLakeTableResponse
 */
async function updateDataLakeTable(request: UpdateDataLakeTableRequest): UpdateDataLakeTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDataLakeTable', 'POST', '/', 'json', true, 'form', request);
}

