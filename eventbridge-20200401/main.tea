/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('eventbridge', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateApiDestinationRequest {
  apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination. The name must be 2 to 127 characters in length.

This parameter is required.', example='api-destination-name'),
  connectionName?: string(name='ConnectionName', description='The name of the connection. The name must be 2 to 127 characters in length.

> 
>  Before you configure this parameter, you must call the CreateConnection operation to create a connection. Then, set this parameter to the name of the connection that you created.

This parameter is required.', example='connection-name'),
  description?: string(name='Description', description='The description of the API destination. The description can be up to 255 characters in length.'),
  httpApiParameters?: {
    endpoint?: string(name='Endpoint', description='The endpoint of the API destination. The endpoint can be up to 127 characters in length.

This parameter is required.', example='http://127.0.0.1:8001/api'),
    method?: string(name='Method', description='The HTTP request method. Valid values:

*   GET
*   POST
*   HEAD
*   DELETE
*   PUT
*   PATCH

This parameter is required.', example='POST'),
  }(name='HttpApiParameters', description='The parameters that are configured for the API destination.

This parameter is required.'),
}

model CreateApiDestinationShrinkRequest {
  apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination. The name must be 2 to 127 characters in length.

This parameter is required.', example='api-destination-name'),
  connectionName?: string(name='ConnectionName', description='The name of the connection. The name must be 2 to 127 characters in length.

> 
>  Before you configure this parameter, you must call the CreateConnection operation to create a connection. Then, set this parameter to the name of the connection that you created.

This parameter is required.', example='connection-name'),
  description?: string(name='Description', description='The description of the API destination. The description can be up to 255 characters in length.'),
  httpApiParametersShrink?: string(name='HttpApiParameters', description='The parameters that are configured for the API destination.

This parameter is required.'),
}

model CreateApiDestinationResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  date?: {
    apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination.', example='ApiDestinationName'),
  }(name='Date', description='The data returned if the API destination is created.'),
  message?: string(name='Message', description='The returned message.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='5DAF96FB-A4B6-548C-B999-0BFDCB2261B9'),
}

model CreateApiDestinationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateApiDestinationResponseBody(name='body'),
}

/**
 * @summary Creates an API destination.
 *
 * @description You can call this API operation to create an API destination.
 *
 * @param tmpReq CreateApiDestinationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateApiDestinationResponse
 */
async function createApiDestinationWithOptions(tmpReq: CreateApiDestinationRequest, runtime: Util.RuntimeOptions): CreateApiDestinationResponse {
  Util.validateModel(tmpReq);
  var request = new CreateApiDestinationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.httpApiParameters)) {
    request.httpApiParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.httpApiParameters, 'HttpApiParameters', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.apiDestinationName)) {
    query['ApiDestinationName'] = request.apiDestinationName;
  }
  if (!Util.isUnset(request.connectionName)) {
    query['ConnectionName'] = request.connectionName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.httpApiParametersShrink)) {
    query['HttpApiParameters'] = request.httpApiParametersShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateApiDestination',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an API destination.
 *
 * @description You can call this API operation to create an API destination.
 *
 * @param request CreateApiDestinationRequest
 * @return CreateApiDestinationResponse
 */
async function createApiDestination(request: CreateApiDestinationRequest): CreateApiDestinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApiDestinationWithOptions(request, runtime);
}

model CreateConnectionRequest {
  authParameters?: {
    apiKeyAuthParameters?: {
      apiKeyName?: string(name='ApiKeyName', description='The key of the API key.', example='Token'),
      apiKeyValue?: string(name='ApiKeyValue', description='The value of the API key.', example='adkjnakddh****'),
    }(name='ApiKeyAuthParameters', description='The parameters that are configured for API key authentication.'),
    authorizationType?: string(name='AuthorizationType', description='The authentication type. Valid values:

BASIC_AUTH: basic authentication.

Introduction: Basic authentication is a simple authentication scheme built into the HTTP protocol. When you use the HTTP protocol for communications, the authentication method that the HTTP server uses to authenticate user identities on the client is defined in the protocol. The request header is in the Authorization: Basic Base64-encoded string (Username:Password) format.

1.  Username and Password are required.

API_KEY_AUTH: API key authentication.

Introduction: The request header is in the Token: Token value format.

*   ApiKeyName and ApiKeyValue are required.

OAUTH_AUTH: OAuth authentication.

Introduction: OAuth2.0 is an authentication mechanism. In normal cases, a system that does not use OAuth2.0 can access the resources of the server from the client. To ensure access security, access tokens are used to authenticate users in OAuth 2.0. The client must use an access token to access protected resources. This way, OAuth 2.0 protects resources from being accessed from malicious clients and improves system security.

*   AuthorizationEndpoint, OAuthHttpParameters, and HttpMethod are required.', example='BASIC_AUTH'),
    basicAuthParameters?: {
      password?: string(name='Password', description='The password for basic authentication.', example='*******'),
      username?: string(name='Username', description='The username for basic authentication.', example='admin'),
    }(name='BasicAuthParameters', description='The parameters that are configured for basic authentication.'),
    OAuthParameters?: {
      authorizationEndpoint?: string(name='AuthorizationEndpoint', description='The IP address of the authorized endpoint. The default value of a column can be up to 127 characters in length.', example='http://localhost:8080/oauth/token'),
      clientParameters?: {
        clientID?: string(name='ClientID', description='The client ID.', example='ClientID'),
        clientSecret?: string(name='ClientSecret', description='The AccessKey secret of the client.', example='Qo57Q~F249~S74GmNPA36pZJoJK4f4LY****'),
      }(name='ClientParameters', description='The parameters that are configured for the client.'),
      httpMethod?: string(name='HttpMethod', description='The HTTP request method. Valid values:

*   GET
*   POST
*   HEAD
*   DELETE
*   PUT
*   PATCH', example='POST'),
      OAuthHttpParameters?: {
        bodyParameters?: [ 
          {
            isValueSecret?: string(name='IsValueSecret', description='Specifies whether to enable authentication.', example='false'),
            key?: string(name='Key', description='The key of the request body.', example='keyDemo'),
            value?: string(name='Value', description='The value of the request body.', example='keyValue'),
          }
        ](name='BodyParameters', description='The parameters that are configured for the request body.'),
        headerParameters?: [ 
          {
            isValueSecret?: string(name='IsValueSecret', description='Specifies whether to enable authentication.', example='false'),
            key?: string(name='Key', description='The key of the request header.', example='keyDemo'),
            value?: string(name='Value', description='The value of the request header.', example='keyValue'),
          }
        ](name='HeaderParameters', description='The parameters that are configured for the request header.'),
        queryStringParameters?: [ 
          {
            isValueSecret?: string(name='IsValueSecret', description='Specifies whether to enable authentication.', example='false'),
            key?: string(name='Key', description='The key of the request path.', example='keyDemo'),
            value?: string(name='Value', description='The value of the request path.', example='valueDemo'),
          }
        ](name='QueryStringParameters', description='The parameters that are configured for the request path.'),
      }(name='OAuthHttpParameters', description='The request parameters that are configured for OAuth authentication.'),
    }(name='OAuthParameters', description='The parameters that are configured for OAuth authentication.'),
  }(name='AuthParameters', description='The parameters that are configured for authentication.'),
  connectionName?: string(name='ConnectionName', description='The name of the connection. The name must be 2 to 127 characters in length.

This parameter is required.', example='connection-name'),
  description?: string(name='Description', description='The description of the connection. The description can be up to 255 characters in length.', example='demo'),
  networkParameters?: {
    networkType?: string(name='NetworkType', description='The network type. Valid values:

PublicNetwork and PrivateNetwork.

*   Note: If you set this parameter to PrivateNetwork, you must configure VpcId, VswitcheId, and SecurityGroupId.

This parameter is required.', example='PublicNetwork'),
    securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', example='eb-167adad548759-security_grop/sg-bp1addad26peuh9qh9****'),
    vpcId?: string(name='VpcId', description='The VPC. ID', example='eb-test/vpc-bp1symadadwnwg****'),
    vswitcheId?: string(name='VswitcheId', description='The vSwitch ID.', example='vsw-bp1iu4x7aeradadown1og8,vsw-bp193sqmadadlaszpeq****'),
  }(name='NetworkParameters', description='The parameters that are configured for the network.

This parameter is required.'),
}

model CreateConnectionShrinkRequest {
  authParametersShrink?: string(name='AuthParameters', description='The parameters that are configured for authentication.'),
  connectionName?: string(name='ConnectionName', description='The name of the connection. The name must be 2 to 127 characters in length.

This parameter is required.', example='connection-name'),
  description?: string(name='Description', description='The description of the connection. The description can be up to 255 characters in length.', example='demo'),
  networkParametersShrink?: string(name='NetworkParameters', description='The parameters that are configured for the network.

This parameter is required.'),
}

model CreateConnectionResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  data?: {
    connectionName?: string(name='ConnectionName', description='The connection name.', example='connection-demo'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message. If the request is successful, success is returned. If the request failed, an error code is returned.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='7DA60DED-CD36-5837-B848-C01A23D2****'),
}

model CreateConnectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateConnectionResponseBody(name='body'),
}

/**
 * @summary Creates a connection.
 *
 * @description You can call this API operation to create a connection.
 *
 * @param tmpReq CreateConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConnectionResponse
 */
async function createConnectionWithOptions(tmpReq: CreateConnectionRequest, runtime: Util.RuntimeOptions): CreateConnectionResponse {
  Util.validateModel(tmpReq);
  var request = new CreateConnectionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.authParameters)) {
    request.authParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.authParameters, 'AuthParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.networkParameters)) {
    request.networkParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.networkParameters, 'NetworkParameters', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.authParametersShrink)) {
    query['AuthParameters'] = request.authParametersShrink;
  }
  if (!Util.isUnset(request.connectionName)) {
    query['ConnectionName'] = request.connectionName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.networkParametersShrink)) {
    query['NetworkParameters'] = request.networkParametersShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateConnection',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a connection.
 *
 * @description You can call this API operation to create a connection.
 *
 * @param request CreateConnectionRequest
 * @return CreateConnectionResponse
 */
async function createConnection(request: CreateConnectionRequest): CreateConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConnectionWithOptions(request, runtime);
}

model CreateEventBusRequest {
  description?: string(name='Description', description='The description of the event bus.', example='demo'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='MyEventBus'),
}

model CreateEventBusResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For more information about error codes, see Error codes.', example='Success'),
  data?: {
    eventBusARN?: string(name='EventBusARN', description='The Alibaba Cloud Resource Name (ARN) of the event bus.', example='acs:eventbridge:cn-hangzhou:123456789098****:eventbus/MyEventBus'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='The event bus [xxxx] not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='A995F07C-E503-5881-9962-9CECA8566876'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. The value true indicates that the request is successful.', example='true'),
}

model CreateEventBusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEventBusResponseBody(name='body'),
}

/**
 * @summary Creates an event bus.
 *
 * @description You can call this API operation to create an event bus.
 *
 * @param request CreateEventBusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEventBusResponse
 */
async function createEventBusWithOptions(request: CreateEventBusRequest, runtime: Util.RuntimeOptions): CreateEventBusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEventBus',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an event bus.
 *
 * @description You can call this API operation to create an event bus.
 *
 * @param request CreateEventBusRequest
 * @return CreateEventBusResponse
 */
async function createEventBus(request: CreateEventBusRequest): CreateEventBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEventBusWithOptions(request, runtime);
}

model CreateEventSourceRequest {
  description?: string(name='Description', description='The description of the event source.'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus with which the event source is associated.

This parameter is required.', example='my-event-bus'),
  eventSourceName?: string(name='EventSourceName', description='The name of the event source.

This parameter is required.', example='myrabbitmq.sourc'),
  externalSourceConfig?: map[string]any(name='ExternalSourceConfig'),
  externalSourceType?: bytes(name='ExternalSourceType'),
  linkedExternalSource?: boolean(name='LinkedExternalSource'),
  sourceHttpEventParameters?: {
    ip?: [ string ](name='Ip', description='The CIDR block that is used for security settings. This parameter is required only if you set SecurityConfig to ip. You can enter a CIDR block or an IP address.'),
    method?: [ string ](name='Method', description='The HTTP request method supported by the generated webhook URL. You can select multiple values. Valid values:

*   GET
*   POST
*   PUT
*   PATCH
*   DELETE
*   HEAD
*   OPTIONS
*   TRACE
*   CONNECT'),
    referer?: [ string ](name='Referer', description='The security domain name. This parameter is required only if you set SecurityConfig to referer. You can enter a domain name.'),
    securityConfig?: string(name='SecurityConfig', description='The type of security settings. Valid values:

*   none: No configuration is required.
*   ip: CIDR block.
*   referer: security domain name.', example='none'),
    type?: string(name='Type', description='The protocol type that is supported by the generated webhook URL. Valid values:

*   HTTP
*   HTTPS
*   HTTP\\\\&HTTPS', example='HTTPS'),
  }(name='SourceHttpEventParameters', description='The parameters that are configured if the event source is HTTP events.'),
  sourceKafkaParameters?: {
    consumerGroup?: string(name='ConsumerGroup', description='The ID of the consumer group that subscribes to the topic.', example='wechat_peer_prod'),
    instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache Kafka instance.', example='pc-2zehmg67txzuyuuwlxv4f'),
    maximumTasks?: int32(name='MaximumTasks', description='The maximum number of consumers.', example='1'),
    network?: string(name='Network', description='The network. Valid values: Default and PublicNetwork. Default value: Default. The value PublicNetwork indicates a self-managed network.', example='Default'),
    offsetReset?: string(name='OffsetReset', description='The consumer offset.', example='latest'),
    regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for Apache Kafka instance resides.', example='cn-hangzhou'),
    securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the Message Queue for Apache Kafka instance belongs. This parameter is required only if you set Network to PublicNetwork.', example='sg-8vbf66aoyp0wfzrzxlmy'),
    topic?: string(name='Topic', description='The name of the topic on the Message Queue for Apache Kafka instance.', example='prod_ma_dispatch_center_call_record'),
    vSwitchIds?: string(name='VSwitchIds', description='The ID of the vSwitch with which the Message Queue for Apache Kafka instance is associated. This parameter is required only if you set Network to PublicNetwork.', example='vsw-bp127azpeirmwu4q9ttqi'),
    vpcId?: string(name='VpcId', description='The ID of the VPC in which the Message Queue for Apache Kafka instance resides. This parameter is required only if you set Network to PublicNetwork.', example='vpc-2ze5ejm986a73qq3vshlk'),
  }(name='SourceKafkaParameters', description='The parameters that are configured if the event source is Message Queue for Apache Kafka.'),
  sourceMNSParameters?: {
    isBase64Decode?: boolean(name='IsBase64Decode', description='Specifies whether to enable Base64 decoding. Valid values: true and false.', example='true'),
    queueName?: string(name='QueueName', description='The name of the MNS queue.', example='MyQueue'),
    regionId?: string(name='RegionId', description='The region where the MNS queue resides. Valid values: cn-qingdao, cn-beijing, cn-zhangjiakou, cn-huhehaote, cn-wulanchabu, cn-hangzhou, cn-shanghai, cn-shenzhen, cn-guangzhou, cn-chengdu, cn-hongkong, ap-southeast-1, ap-southeast-2, ap-southeast-3, ap-southeast-5, ap-northeast-1, eu-central-1, us-west-1, us-east-1, ap-south-1, me-east-1, and cn-north-2-gov-1.', example='cn-hangzhou'),
  }(name='SourceMNSParameters', description='The parameters that are configured if the event source is Message Service (MNS). If you specify MNS as the event source, you must configure RegionId, IsBase64Decode, and QueueName.'),
  sourceRabbitMQParameters?: {
    instanceId?: string(name='InstanceId', description='The ID of the Message Queue for RabbitMQ instance. For more information, see Limits.', example='amqp-cn-nif22u74****'),
    queueName?: string(name='QueueName', description='The name of the queue on the Message Queue for RabbitMQ instance. For more information, see [Limits](https://help.aliyun.com/document_detail/163289.html).', example='demo'),
    regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for RabbitMQ instance resides.', example='cn-hangzhou'),
    virtualHostName?: string(name='VirtualHostName', description='The name of the vhost of the Message Queue for RabbitMQ instance. For more information, see [Limits](https://help.aliyun.com/document_detail/163289.html).', example='eb-connect'),
  }(name='SourceRabbitMQParameters', description='The parameters that are configured if the event source is Message Queue for RabbitMQ.'),
  sourceRocketMQParameters?: {
    authType?: string(name='AuthType', description='The authentication type. You can set this parameter to ACL or leave this parameter empty.', example='ACL'),
    groupID?: string(name='GroupID', description='The ID of the consumer group on the Message Queue for Apache RocketMQ instance.', example='GID-test'),
    instanceEndpoint?: string(name='InstanceEndpoint', description='The endpoint that is used to access the Message Queue for Apache RocketMQ instance.', example='registry-vpc****.aliyuncs.com'),
    instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ instance. For more information, see [Limits](https://help.aliyun.com/document_detail/163289.html).', example='MQ_INST_164901546557****_BAAN****'),
    instanceNetwork?: string(name='InstanceNetwork', description='None.', example='None'),
    instancePassword?: string(name='InstancePassword', description='The password that is used to access the Message Queue for Apache RocketMQ instance.', example='******'),
    instanceSecurityGroupId?: string(name='InstanceSecurityGroupId', description='The ID of the security group to which the Message Queue for Apache RocketMQ instance belongs.', example='sg-catalog-eventlistener'),
    instanceType?: string(name='InstanceType', description='The type of the Message Queue for Apache RocketMQ instance. Valid values:

*   Cloud_4: Message Queue for Apache RocketMQ 4.0 instance.
*   Cloud_5: Message Queue for Apache RocketMQ 5.0 instance.', example='Cloud_4'),
    instanceUsername?: string(name='InstanceUsername', description='The username that is used to access the Message Queue for Apache RocketMQ instance.', example='root'),
    instanceVSwitchIds?: string(name='InstanceVSwitchIds', description='The ID of the vSwitch with which the Message Queue for Apache RocketMQ instance is associated.', example='vsw-bp10rbrt6rb6vrd89****'),
    instanceVpcId?: string(name='InstanceVpcId', description='The ID of the virtual private cloud (VPC) in which the Message Queue for Apache RocketMQ instance resides.', example='vpc-bp1a4gmlk31hyg6ptl3ss'),
    offset?: string(name='Offset', description='The offset from which message consumption starts. Valid values: CONSUME_FROM_LAST_OFFSET: Start message consumption from the latest offset. CONSUME_FROM_FIRST_OFFSET: Start message consumption from the earliest offset. CONSUME_FROM_TIMESTAMP: Start message consumption from the offset at the specified point in time. Default value: CONSUME_FROM_LAST_OFFSET.', example='CONSUME_FROM_LAST_OFFSET'),
    regionId?: string(name='RegionId', description='The region where the Message Queue for Apache RocketMQ instance resides.', example='cn-hangzhou'),
    tag?: string(name='Tag', description='The tag that is used to filter messages.', example='test'),
    timestamp?: long(name='Timestamp', description='The timestamp that specifies the time from which messages are consumed. This parameter is valid only if you set Offset to CONSUME_FROM_TIMESTAMP.', example='1636597951964'),
    topic?: string(name='Topic', description='The name of the topic on the Message Queue for Apache RocketMQ instance. For more information, see [Limits](https://help.aliyun.com/document_detail/163289.html).', example='mytopic'),
  }(name='SourceRocketMQParameters', description='The parameters that are configured if the event source is Message Queue for Apache RocketMQ.'),
  sourceSLSParameters?: {
    consumePosition?: string(name='ConsumePosition', description='The starting consumer offset. The value begin specifies the earliest offset, and the value end specifies the latest offset. You can also specify a time in seconds to start consumption.', example='end'),
    logStore?: string(name='LogStore', description='The Log Service Logstore.', example='test-logstore'),
    project?: string(name='Project', description='The Log Service project.', example='test-project'),
    roleName?: string(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the Resource Access Management (RAM) console. For information about the permission policy of this role, see Create a custom event source of the Log Service type.', example='testRole'),
  }(name='SourceSLSParameters', description='The parameters that are configured if the event source is Log Service.'),
  sourceScheduledEventParameters?: {
    schedule?: string(name='Schedule', description='The cron expression.', example='10 * * * * *'),
    timeZone?: string(name='TimeZone', description='The time zone in which the cron expression is executed.', example='GMT+0:00'),
    userData?: string(name='UserData', example='{"a": "b"}'),
  }(name='SourceScheduledEventParameters', description='The parameters that are configured if you specify scheduled events as the event source.'),
}

model CreateEventSourceShrinkRequest {
  description?: string(name='Description', description='The description of the event source.'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus with which the event source is associated.

This parameter is required.', example='my-event-bus'),
  eventSourceName?: string(name='EventSourceName', description='The name of the event source.

This parameter is required.', example='myrabbitmq.sourc'),
  externalSourceConfigShrink?: string(name='ExternalSourceConfig'),
  externalSourceType?: bytes(name='ExternalSourceType'),
  linkedExternalSource?: boolean(name='LinkedExternalSource'),
  sourceHttpEventParametersShrink?: string(name='SourceHttpEventParameters', description='The parameters that are configured if the event source is HTTP events.'),
  sourceKafkaParametersShrink?: string(name='SourceKafkaParameters', description='The parameters that are configured if the event source is Message Queue for Apache Kafka.'),
  sourceMNSParametersShrink?: string(name='SourceMNSParameters', description='The parameters that are configured if the event source is Message Service (MNS). If you specify MNS as the event source, you must configure RegionId, IsBase64Decode, and QueueName.'),
  sourceRabbitMQParametersShrink?: string(name='SourceRabbitMQParameters', description='The parameters that are configured if the event source is Message Queue for RabbitMQ.'),
  sourceRocketMQParametersShrink?: string(name='SourceRocketMQParameters', description='The parameters that are configured if the event source is Message Queue for Apache RocketMQ.'),
  sourceSLSParametersShrink?: string(name='SourceSLSParameters', description='The parameters that are configured if the event source is Log Service.'),
  sourceScheduledEventParametersShrink?: string(name='SourceScheduledEventParameters', description='The parameters that are configured if you specify scheduled events as the event source.'),
}

model CreateEventSourceResponseBody = {
  code?: string(name='Code', description='The returned response code. Valid values:

*   Success: The request is successful.
*   Other codes: The request failed. For more information about error codes, see Error codes.', example='Success'),
  data?: {
    eventSourceARN?: string(name='EventSourceARN', description='The Alibaba Cloud Resource Name (ARN) of the resource.', example='acs:eventbridge:cn-hangzhou:164901546557****:eventbus/my-event-bus/eventsource/mymns.source'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='Remote error. requestId: [A8EFABD2-95B9-1C46-9E01-xxxx], error code: [CreateRelatedResourceFailed], message: [Create related resource failed, EntityNotExist.Role : The role not exists: xxxx. \\\\r\\\\nRequestId : xxxx-168C-54ED-8FEB-BF11CB70AEB7]'),
  requestId?: string(name='RequestId', description='The request ID.', example='2922208e-e1c6-43ee-bfd1-aca50263bc8a'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. The value true indicates that the operation is successful.', example='true'),
}

model CreateEventSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEventSourceResponseBody(name='body'),
}

/**
 * @summary Creates an event source.
 *
 * @description You can call this operation to create an event source.
 *
 * @param tmpReq CreateEventSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEventSourceResponse
 */
async function createEventSourceWithOptions(tmpReq: CreateEventSourceRequest, runtime: Util.RuntimeOptions): CreateEventSourceResponse {
  Util.validateModel(tmpReq);
  var request = new CreateEventSourceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.externalSourceConfig)) {
    request.externalSourceConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.externalSourceConfig, 'ExternalSourceConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceHttpEventParameters)) {
    request.sourceHttpEventParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceHttpEventParameters, 'SourceHttpEventParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceKafkaParameters)) {
    request.sourceKafkaParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceKafkaParameters, 'SourceKafkaParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceMNSParameters)) {
    request.sourceMNSParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceMNSParameters, 'SourceMNSParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceRabbitMQParameters)) {
    request.sourceRabbitMQParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceRabbitMQParameters, 'SourceRabbitMQParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceRocketMQParameters)) {
    request.sourceRocketMQParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceRocketMQParameters, 'SourceRocketMQParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceSLSParameters)) {
    request.sourceSLSParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceSLSParameters, 'SourceSLSParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceScheduledEventParameters)) {
    request.sourceScheduledEventParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceScheduledEventParameters, 'SourceScheduledEventParameters', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    body['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventSourceName)) {
    body['EventSourceName'] = request.eventSourceName;
  }
  if (!Util.isUnset(request.externalSourceConfigShrink)) {
    body['ExternalSourceConfig'] = request.externalSourceConfigShrink;
  }
  if (!Util.isUnset(request.externalSourceType)) {
    body['ExternalSourceType'] = request.externalSourceType;
  }
  if (!Util.isUnset(request.linkedExternalSource)) {
    body['LinkedExternalSource'] = request.linkedExternalSource;
  }
  if (!Util.isUnset(request.sourceHttpEventParametersShrink)) {
    body['SourceHttpEventParameters'] = request.sourceHttpEventParametersShrink;
  }
  if (!Util.isUnset(request.sourceKafkaParametersShrink)) {
    body['SourceKafkaParameters'] = request.sourceKafkaParametersShrink;
  }
  if (!Util.isUnset(request.sourceMNSParametersShrink)) {
    body['SourceMNSParameters'] = request.sourceMNSParametersShrink;
  }
  if (!Util.isUnset(request.sourceRabbitMQParametersShrink)) {
    body['SourceRabbitMQParameters'] = request.sourceRabbitMQParametersShrink;
  }
  if (!Util.isUnset(request.sourceRocketMQParametersShrink)) {
    body['SourceRocketMQParameters'] = request.sourceRocketMQParametersShrink;
  }
  if (!Util.isUnset(request.sourceSLSParametersShrink)) {
    body['SourceSLSParameters'] = request.sourceSLSParametersShrink;
  }
  if (!Util.isUnset(request.sourceScheduledEventParametersShrink)) {
    body['SourceScheduledEventParameters'] = request.sourceScheduledEventParametersShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEventSource',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an event source.
 *
 * @description You can call this operation to create an event source.
 *
 * @param request CreateEventSourceRequest
 * @return CreateEventSourceResponse
 */
async function createEventSource(request: CreateEventSourceRequest): CreateEventSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEventSourceWithOptions(request, runtime);
}

model CreateEventStreamingRequest {
  description?: string(name='Description', description='The description of the event stream.', example='rocketmq2mns'),
  eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream.

This parameter is required.', example='myeventstreaming'),
  filterPattern?: string(name='FilterPattern', description='The rule that is used to filter events. If you leave this parameter empty, all events are matched.

This parameter is required.'),
  runOptions?: {
    batchWindow?: {
      countBasedWindow?: int32(name='CountBasedWindow', description='The maximum number of events that is allowed in the batch window. When this threshold is reached, data in the window is pushed to the downstream service. If multiple batch windows exist, data is pushed if triggering conditions are met in one of the windows.', example='100'),
      timeBasedWindow?: int32(name='TimeBasedWindow', description='The maximum period of time during which events are allowed in the batch window. Unit: seconds. When this threshold is reached, data in the window is pushed to the downstream service. If multiple batch windows exist, data is pushed if triggering conditions are met in one of the windows.', example='10'),
    }(name='BatchWindow', description='The batch window.'),
    deadLetterQueue?: {
      arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the dead-letter queue.', example='acs:ram::1317334647812936:role/rdstoecsassumekms'),
    }(name='DeadLetterQueue', description='Specifies whether to enable dead-letter queues. By default, dead-letter queues are disabled. Messages that fail to be pushed are discarded after the maximum number of retries that is specified by the retry policy is reached.'),
    errorsTolerance?: string(name='ErrorsTolerance', description='The exception tolerance policy. Valid values:

*   NONE: does not tolerate exceptions.
*   ALL: tolerates all exceptions.', example='ALL'),
    logDelivery?: {
      kafkaLogParameters?: [ 
        {
          endpoint?: string(name='Endpoint'),
          instanceId?: string(name='InstanceId'),
          topic?: string(name='Topic'),
        }
      ](name='KafkaLogParameters'),
      SLSLogParameters?: [ 
        {
          logstoreName?: string(name='LogstoreName'),
          projectName?: string(name='ProjectName'),
        }
      ](name='SLSLogParameters'),
    }(name='LogDelivery'),
    maximumTasks?: long(name='MaximumTasks', description='The maximum number of concurrent threads.', example='2'),
    network?: {
      securityGroupId?: string(name='SecurityGroupId'),
      vSwitchIds?: [ string ](name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
    }(name='Network'),
    resourceSpec?: {
      resources?: [ 
        {
          type?: string(name='Type'),
          value?: int32(name='Value'),
        }
      ](name='Resources'),
    }(name='ResourceSpec'),
    retryStrategy?: {
      maximumEventAgeInSeconds?: long(name='MaximumEventAgeInSeconds', description='The maximum timeout period for a retry.', example='512'),
      maximumRetryAttempts?: long(name='MaximumRetryAttempts', description='The maximum number of retries.', example='2'),
      pushRetryStrategy?: string(name='PushRetryStrategy', description='The retry policy. Valid values:

*   BACKOFF_RETRY
*   EXPONENTIAL_DECAY_RETRY', example='BACKOFFRETRY'),
    }(name='RetryStrategy', description='The retry policy that you want to use if events fail to be pushed.'),
    roleName?: string(name='RoleName'),
    scaledObject?: {
      maxReplicaCount?: int32(name='MaxReplicaCount'),
      minReplicaCount?: int32(name='MinReplicaCount'),
      triggers?: [ 
        {
          metadata?: {
            type?: string(name='Type'),
            value?: int32(name='Value'),
          }(name='Metadata'),
          type?: string(name='Type'),
        }
      ](name='Triggers'),
    }(name='ScaledObject'),
  }(name='RunOptions', description='The parameters that are configured for the runtime environment.'),
  sink?: {
    sinkCustomizedKafkaConnectorParameters?: {
      connectorPackageUrl?: string(name='ConnectorPackageUrl'),
      connectorParameters?: {
        config?: map[string]any(name='Config'),
        name?: string(name='Name'),
      }(name='ConnectorParameters'),
      workerParameters?: map[string]any(name='WorkerParameters'),
    }(name='SinkCustomizedKafkaConnectorParameters'),
    sinkCustomizedKafkaParameters?: {
      instanceId?: string(name='InstanceId'),
    }(name='SinkCustomizedKafkaParameters'),
    sinkDataHubParameters?: {
      body?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='ORIGINAL'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The BLOB topic.'),
      }(name='Body', description='The BLOB topic.'),
      project?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The name of the DataHub project.', example='demo-project'),
      }(name='Project', description='The name of the DataHub project.'),
      roleName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The role name.', example='test-role'),
      }(name='RoleName', description='The role name.'),
      topic?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The name of the DataHub topic.', example='demo-topic'),
      }(name='Topic', description='The name of the DataHub topic.'),
      topicSchema?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='{"k1":"${k1}","k2":"${k2}"}'),
        value?: string(name='Value', description='The TUBLE topic.', example='{"k1":"value1","k2":"value2"}'),
      }(name='TopicSchema', description='The TUBLE topic.'),
      topicType?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The topic type. Valid values:

*   TUPLE
*   BLOB', example='TUPLE'),
      }(name='TopicType', description='The topic type. Valid values:

*   TUPLE
*   BLOB'),
    }(name='SinkDataHubParameters', description='The parameters that are configured if you specify DataHub as the event target.'),
    sinkFcParameters?: {
      body?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
      }(name='Body', description='The message body that you want to deliver to Function Compute.'),
      concurrency?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='None'),
        value?: string(name='Value', description='The delivery concurrency. Minimum value: 1.', example='1'),
      }(name='Concurrency', description='The delivery concurrency. Minimum value: 1.'),
      functionName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The function name.', example='myFunction'),
      }(name='FunctionName', description='The function name.'),
      invocationType?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The invocation mode. Valid values: Sync and Async.', example='Async'),
      }(name='InvocationType', description='The invocation mode. Valid values: Sync and Async.'),
      qualifier?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The service version.', example='LATEST'),
      }(name='Qualifier', description='The service version.'),
      serviceName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The service name.', example='myService'),
      }(name='ServiceName', description='The service name.'),
    }(name='SinkFcParameters', description='The parameters that are configured if you specify Function Compute as the event target.'),
    sinkFnfParameters?: {
      executionName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.'),
        value?: string(name='Value', description='The execution name.', example='123'),
      }(name='ExecutionName', description='The execution name.'),
      flowName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.'),
        value?: string(name='Value', description='The flow name.', example='test-streaming-fnf'),
      }(name='FlowName', description='The flow name.'),
      input?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.'),
        value?: string(name='Value', description='The input information of the execution.', example='123'),
      }(name='Input', description='The input information of the execution.'),
      roleName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.'),
        value?: string(name='Value', description='The role name.', example='Al****FNF-x****'),
      }(name='RoleName', description='The role name.'),
    }(name='SinkFnfParameters', description='The parameters that are configured if you specify CloudFlow as the event target.'),
    sinkKafkaParameters?: {
      acks?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The ACK mode.

*   If you set this parameter to 0, no response is returned from the broker. In this mode, the performance is high, but the risk of data loss is also high.
*   If you set this parameter to 1, a response is returned when data is written to the leader. In this mode, the performance and the risk of data loss are moderate. Data loss may occur if a failure occurs on the leader.
*   If you set this parameter to all, a response is returned when data is written to the leader and synchronized to the followers. In this mode, the performance is low, but the risk of data loss is also low. Data loss occurs if the leader and the followers fail at the same time.', example='1'),
      }(name='Acks', description='The acknowledgment (ACK) mode.

*   If you set this parameter to 0, no response is returned from the broker. In this mode, the performance is high, but the risk of data loss is also high.
*   If you set this parameter to 1, a response is returned when data is written to the leader. In this mode, the performance and the risk of data loss are moderate. Data loss may occur if a failure occurs on the leader.
*   If you set this parameter to all, a response is returned when data is written to the leader and synchronized to the followers. In this mode, the performance is low, but the risk of data loss is also low. Data loss occurs if the leader and the followers fail at the same time.'),
      instanceId?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The ID of the ApsaraMQ for Kafka instance.', example='Defaut_1283278472_sadkj'),
      }(name='InstanceId', description='The ID of the ApsaraMQ for Kafka instance.'),
      key?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The message key.', example='key'),
      }(name='Key', description='The message key.'),
      topic?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The name of the topic on the ApsaraMQ for Kafka instance.', example='test'),
      }(name='Topic', description='The name of the topic on the ApsaraMQ for Kafka instance.'),
      value?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
      }(name='Value', description='The message body.'),
    }(name='SinkKafkaParameters', description='The parameters that are configured if you specify ApsaraMQ for Kafka as the event target.'),
    sinkMNSParameters?: {
      body?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
  "key": "value"
}'),
      }(name='Body', description='The message content.'),
      isBase64Encode?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='Specifies whether to enable Base64 encoding.', example='true'),
      }(name='IsBase64Encode', description='Specifies whether to enable Base64 encoding.'),
      queueName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The name of the MNS queue.', example='MyQueue'),
      }(name='QueueName', description='The name of the MNS queue.'),
    }(name='SinkMNSParameters', description='The parameters that are configured if you specify MNS as the event target.'),
    sinkPrometheusParameters?: {
      authorizationType?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The authentication method.', example='BASIC_AUTH'),
      }(name='AuthorizationType', description='The authentication method.'),
      data?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: JSAONPATH.', example='JSAONPATH'),
        template?: string(name='Template', description='The template based on which you want to transform events.'),
        value?: string(name='Value', description='The metric data.', example='$.data'),
      }(name='Data', description='The metric data.'),
      networkType?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The network type.', example='PrivateNetwork'),
      }(name='NetworkType', description='The network type.'),
      password?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The password.', example='*****'),
      }(name='Password', description='The password.'),
      securityGroupId?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The ID of the security group to which the Managed Service for Prometheus instance belongs.', example='sg-mw43*****'),
      }(name='SecurityGroupId', description='The ID of the security group to which the Managed Service for Prometheus instance belongs.'),
      URL?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The URL for the remote write configuration item of the Managed Service for Prometheus instance.'),
      }(name='URL', description='The URL for the remote write configuration item of the Managed Service for Prometheus instance.'),
      username?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The username.', example='****admin'),
      }(name='Username', description='The username.'),
      vSwitchId?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The ID of the vSwitch with which the Managed Service for Prometheus instance is associated.', example='vsw-dwaafds****'),
      }(name='VSwitchId', description='The ID of the vSwitch with which the Managed Service for Prometheus instance is associated.'),
      vpcId?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The ID of the VPC to which the Managed Service for Prometheus instance belongs.', example='i-2ze7u5i17mbqtx1p****'),
      }(name='VpcId', description='The ID of the VPC to which the Managed Service for Prometheus instance belongs.'),
    }(name='SinkPrometheusParameters', description='The parameters that are configured if you specify Managed Service for Prometheus as the event target.'),
    sinkRabbitMQParameters?: {
      body?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
  "key": "value"
}'),
      }(name='Body', description='The message content.'),
      exchange?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The name of the exchange on the ApsaraMQ for RabbitMQ instance.', example='a_exchange'),
      }(name='Exchange', description='The exchange mode. This parameter is required only if you set TargetType to Exchange.'),
      instanceId?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The ID of the ApsaraMQ for RabbitMQ instance.', example='a5ff91ad4f3f24947887fe184fc20d07'),
      }(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance.'),
      messageId?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
  "key": "value"
}'),
      }(name='MessageId', description='The message ID.'),
      properties?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
  "key": "value"
}'),
      }(name='Properties', description='The properties that you want to use to filter messages.'),
      queueName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The name of the queue on the ApsaraMQ for RabbitMQ instance.', example='MyQueue'),
      }(name='QueueName', description='The queue mode. This parameter is required only if you set TargetType to Queue.'),
      routingKey?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The rule that you want to use to route messages.', example='housekeeping'),
      }(name='RoutingKey', description='The rule that you want to use to route messages. This parameter is required only if you set TargetType to Exchange.'),
      targetType?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The type of the resource to which you want to deliver events. Valid values:

*   Exchange
*   Queue', example='Exchange/Queue'),
      }(name='TargetType', description='The type of the resource to which you want to deliver events.'),
      virtualHostName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The name of the vhost to which the ApsaraMQ for RabbitMQ instance belongs.', example='rabbit-host'),
      }(name='VirtualHostName', description='The name of the vhost to which the ApsaraMQ for RabbitMQ instance belongs.'),
    }(name='SinkRabbitMQParameters', description='The parameters that are configured if you specify ApsaraMQ for RabbitMQ as the event target.'),
    sinkRocketMQParameters?: {
      body?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
  "key": "value"
}'),
      }(name='Body', description='The message content.'),
      instanceEndpoint?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The endpoint that is used to access the ApsaraMQ for RocketMQ instance.', example='vbr-8vbsvkkbpf3vb0zefs7ex'),
      }(name='InstanceEndpoint', description='The endpoint that is used to access the ApsaraMQ for RocketMQ instance.'),
      instanceId?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The ID of the ApsaraMQ for RocketMQ instance.', example='MQ_INST_164901546557****_BAAN****'),
      }(name='InstanceId', description='The ID of the ApsaraMQ for RocketMQ instance.'),
      instancePassword?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The password that is used to access the ApsaraMQ for RocketMQ instance.', example='admin'),
      }(name='InstancePassword', description='The password that is used to access the ApsaraMQ for RocketMQ instance.'),
      instanceType?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The type of the ApsaraMQ for RocketMQ instance.', example='2'),
      }(name='InstanceType', description='The type of the ApsaraMQ for RocketMQ instance.'),
      instanceUsername?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The username that is used to access the ApsaraMQ for RocketMQ instance.', example='admin'),
      }(name='InstanceUsername', description='The username that is used to access the ApsaraMQ for RocketMQ instance.'),
      keys?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
  "key": "value"
}'),
      }(name='Keys', description='The keys that you want to use to filter messages.'),
      network?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The network type. Valid values:

*   PublicNetwork and
*   PrivateNetwork.', example='PublicNetwork'),
      }(name='Network', description='The network type. Valid values:

*   PublicNetwork and
*   PrivateNetwork.'),
      properties?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
  "key": "value"
}'),
      }(name='Properties', description='The properties that you want to use to filter messages.'),
      securityGroupId?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The ID of the security group to which the ApsaraMQ for RocketMQ instance belongs.', example='b4bf375515f6440f942e3a20c33d5b9c'),
      }(name='SecurityGroupId', description='The ID of the security group to which the ApsaraMQ for RocketMQ instance belongs.'),
      tags?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
  "key": "value"
}'),
      }(name='Tags', description='The tags that you want to use to filter messages.'),
      topic?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The name of the topic on the ApsaraMQ for RocketMQ instance.', example='Mytopic'),
      }(name='Topic', description='The name of the topic on the ApsaraMQ for RocketMQ instance.'),
      vSwitchIds?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The ID of the vSwitch with which the ApsaraMQ for RocketMQ instance is associated.', example='vbr-8vb835n3zf9shwlvbwlmp'),
      }(name='VSwitchIds', description='The ID of the vSwitch with which the ApsaraMQ for RocketMQ instance is associated.'),
      vpcId?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The ID of the VPC to which the ApsaraMQ for RocketMQ instance belongs.', example='vbr-8vb835n3zf9shwlvbwlmp'),
      }(name='VpcId', description='The ID of the VPC to which the ApsaraMQ for RocketMQ instance belongs.'),
    }(name='SinkRocketMQParameters', description='The parameters that are configured if you specify ApsaraMQ for RocketMQ as the event target.'),
    sinkSLSParameters?: {
      body?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
      }(name='Body', description='The message body that you want to deliver to Simple Log Service.'),
      contentSchema?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='ContentSchema'),
      contentType?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='ContentType'),
      logStore?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The Simple Log Service Logstore.', example='test-logstore'),
      }(name='LogStore', description='The Simple Log Service Logstore.'),
      project?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The Simple Log Service project.', example='test-project'),
      }(name='Project', description='The Simple Log Service project.'),
      roleName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The role name. If you want to authorize EventBridge to use this role to read logs in Simple Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the RAM console.', example='testRole'),
      }(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Simple Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the RAM console.'),
      topic?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The topic that you want to use to store logs. This parameter corresponds to the reserved field **topic** in Simple Log Service.', example='testTopic'),
      }(name='Topic', description='The topic that you want to use to store logs. This parameter corresponds to the reserved field **topic** in Simple Log Service.'),
    }(name='SinkSLSParameters', description='The parameters that are configured if you specify Simple Log Service as the event target.'),
  }(name='Sink', description='The event target. You must and can specify only one event target.

This parameter is required.'),
  source?: {
    sourceApacheKafkaParameters?: {
      bootstraps?: string(name='Bootstraps'),
      consumerGroup?: string(name='ConsumerGroup'),
      networkType?: string(name='NetworkType'),
      offsetReset?: string(name='OffsetReset'),
      saslMechanism?: string(name='SaslMechanism'),
      saslPassword?: string(name='SaslPassword'),
      saslUser?: string(name='SaslUser'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityProtocol?: string(name='SecurityProtocol'),
      topic?: string(name='Topic'),
      vSwitchIds?: string(name='VSwitchIds'),
      valueDataType?: string(name='ValueDataType'),
      vpcId?: string(name='VpcId'),
    }(name='SourceApacheKafkaParameters'),
    sourceCustomizedKafkaConnectorParameters?: {
      connectorPackageUrl?: string(name='ConnectorPackageUrl'),
      connectorParameters?: {
        config?: map[string]any(name='Config'),
        name?: string(name='Name'),
      }(name='ConnectorParameters'),
      workerParameters?: map[string]any(name='WorkerParameters'),
    }(name='SourceCustomizedKafkaConnectorParameters'),
    sourceCustomizedKafkaParameters?: {
      instanceId?: string(name='InstanceId'),
    }(name='SourceCustomizedKafkaParameters'),
    sourceDTSParameters?: {
      brokerUrl?: string(name='BrokerUrl', description='The URL and port number of the change tracking instance.'),
      initCheckPoint?: long(name='InitCheckPoint', description='The UNIX timestamp that is generated when the SDK client consumes the first data record.', example='1620962769'),
      password?: string(name='Password', description='The consumer group password.', example='admin'),
      sid?: string(name='Sid', description='The consumer group ID.', example='HD3'),
      taskId?: string(name='TaskId', description='The task ID.', example='f86e5814-b223-482c-b768-3b873297dade'),
      topic?: string(name='Topic', description='The name of the tracked topic of the change tracking instance.', example='LTC_CACHE_PRD'),
      username?: string(name='Username', description='The consumer group username.', example='admin'),
    }(name='SourceDTSParameters', description='The parameters that are configured if you specify Data Transmission Service (DTS) as the event source.'),
    sourceKafkaParameters?: {
      consumerGroup?: string(name='ConsumerGroup', description='The group ID of the consumer that subscribes to the topic.', example='DEFAULT_GROUP'),
      instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for Kafka instance.', example='r-8vb64581862cd814'),
      network?: string(name='Network', description='The network type. Default value: Default. The value PublicNetwork specifies a virtual private cloud (VPC).', example='Default'),
      offsetReset?: string(name='OffsetReset', description='The offset from which messages are consumed.', example='latest'),
      regionId?: string(name='RegionId', description='The ID of the region where the ApsaraMQ for Kafka instance resides.', example='cn-hangzhou'),
      securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the ApsaraMQ for Kafka instance belongs.', example='sg-bp1iv19sp1msc7zot4wr'),
      topic?: string(name='Topic', description='The name of the topic on the ApsaraMQ for Kafka instance.', example='popvip_center_robot_order'),
      vSwitchIds?: string(name='VSwitchIds', description='The ID of the vSwitch with which the ApsaraMQ for Kafka instance is associated.', example='vsw-bp179l3llg3jjxwrq72hh'),
      valueDataType?: string(name='ValueDataType'),
      vpcId?: string(name='VpcId', description='The ID of the VPC to which the ApsaraMQ for Kafka instance belongs.', example='vpc-8vblalsi0vbhizr77cbhu'),
    }(name='SourceKafkaParameters', description='The parameters that are configured if you specify ApsaraMQ for Kafka as the event source.'),
    sourceMNSParameters?: {
      isBase64Decode?: boolean(name='IsBase64Decode', description='Specifies whether to enable Base64 encoding. Default value: true.', example='true'),
      queueName?: string(name='QueueName', description='The name of the MNS queue.', example='queue_api_1642474203601'),
      regionId?: string(name='RegionId', description='The ID of the region where the MNS queue resides.', example='cn-beijing'),
    }(name='SourceMNSParameters', description='The parameters that are configured if you specify Message Service (MNS) as the event source.'),
    sourceMQTTParameters?: {
      bodyDataType?: string(name='BodyDataType'),
      instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance.', example='r-bp1b5ncun5lqerzg4r'),
      regionId?: string(name='RegionId', description='The ID of the region where the ApsaraMQ for MQTT instance resides.', example='cn-shenzhen'),
      topic?: string(name='Topic', description='The topic from which messages are sent.', example='CANAL_VICUTU_UAT'),
    }(name='SourceMQTTParameters', description='The parameters that are configured if you specify ApsaraMQ for MQTT as the event source.'),
    sourcePrometheusParameters?: {
      clusterId?: string(name='ClusterId', description='The cluster ID.', example='c83555068b6******ad213f565f209'),
      dataType?: string(name='DataType', description='The data type.', example='json'),
      labels?: string(name='Labels', description='The labels.', example='__name__=.*'),
      regionId?: string(name='RegionId'),
    }(name='SourcePrometheusParameters', description='Parameters that are configured if you specify Managed Service for Prometheus as the event source.'),
    sourceRabbitMQParameters?: {
      instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance.', example='gtm-cn-k2c2yfgzt02'),
      queueName?: string(name='QueueName', description='The name of the queue on the ApsaraMQ for RabbitMQ instance.', example='demo'),
      regionId?: string(name='RegionId', description='The ID of the region where the ApsaraMQ for RabbitMQ instance resides. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/62010.html) operation to query the most recent region list.', example='cn-hangzhou'),
      virtualHostName?: string(name='VirtualHostName', description='The name of the vhost to which the ApsaraMQ for RabbitMQ instance belongs.', example='eb-connect'),
    }(name='SourceRabbitMQParameters', description='The parameters that are configured if you specify ApsaraMQ for RabbitMQ as the event source.'),
    sourceRocketMQParameters?: {
      authType?: string(name='AuthType', description='The authentication method.', example='ACL'),
      bodyDataType?: string(name='BodyDataType'),
      filterSql?: string(name='FilterSql', description='The SQL statement that you want to use to filter messages.', example='index > 10'),
      filterType?: string(name='FilterType', description='The method that you want to use to filter messages.', example='Tag'),
      groupID?: string(name='GroupID', description='The ID of the consumer group on the ApsaraMQ for RocketMQ instance.', example='GID_group1'),
      instanceEndpoint?: string(name='InstanceEndpoint', description='The endpoint that is used to access the ApsaraMQ for RocketMQ instance.', example='registry-vpc.cn-zhangjiakou.aliyuncs.com'),
      instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for RocketMQ instance.', example='default_C56C360261515'),
      instanceNetwork?: string(name='InstanceNetwork', description='The network type. Valid values:

*   PublicNetwork and
*   PrivateNetwork.', example='PublicNetwork'),
      instancePassword?: string(name='InstancePassword', description='The password that is used to access the ApsaraMQ for RocketMQ instance.', example='admin'),
      instanceSecurityGroupId?: string(name='InstanceSecurityGroupId', description='The ID of the security group to which the ApsaraMQ for RocketMQ instance belongs.', example='sg-m5edtu24f123456789'),
      instanceType?: string(name='InstanceType', description='The type of the ApsaraMQ for RocketMQ instance.', example='2'),
      instanceUsername?: string(name='InstanceUsername', description='The username that is used to access the ApsaraMQ for RocketMQ instance.', example='admin'),
      instanceVSwitchIds?: string(name='InstanceVSwitchIds', description='The ID of the vSwitch with which the ApsaraMQ for RocketMQ instance is associated.', example='vsw-m5ev8asdc6h123456789'),
      instanceVpcId?: string(name='InstanceVpcId', description='The ID of the VPC to which the ApsaraMQ for RocketMQ instance belongs.', example='vpc-m5e3sv4b123456789'),
      network?: string(name='Network', description='The network type. Valid values: PublicNetwork and PrivateNetwork.', example='PrivateNetwork'),
      offset?: string(name='Offset', description='The offset from which messages are consumed. Valid values:

*   CONSUME_FROM_LAST_OFFSET: Messages are consumed from the latest offset.
*   CONSUME_FROM_FIRST_OFFSET: Messages are consumed from the earliest offset.
*   CONSUME_FROM_TIMESTAMP: Messages are consumed from the offset at the specified point in time.

Default value: CONSUME_FROM_LAST_OFFSET.', example='CONSUMEFROMLAST_OFFSET'),
      regionId?: string(name='RegionId', description='The ID of the region where the ApsaraMQ for RocketMQ instance resides.', example='cn-qingdao'),
      securityGroupId?: string(name='SecurityGroupId', description='The security group ID of the cross-border task.', example='sg-m5edtu24f123456789'),
      tag?: string(name='Tag', description='The tag that you want to use to filter messages.', example='test'),
      timestamp?: long(name='Timestamp', description='The timestamp that specifies the time from which messages are consumed. This parameter is valid only if you set Offset to CONSUME_FROM_TIMESTAMP.', example='1670656652009'),
      topic?: string(name='Topic', description='The name of the topic on the ApsaraMQ for RocketMQ instance.', example='Topic_publicRule_api_1667273421288'),
      vSwitchIds?: string(name='VSwitchIds', description='The vSwitch ID of the cross-border task.', example='vsw-m5ev8asdc6h123456789'),
      vpcId?: string(name='VpcId', description='The VPC ID of the cross-border task.', example='vpc-m5e3sv4b123456789'),
    }(name='SourceRocketMQParameters', description='The parameters that are configured if you specify ApsaraMQ for RocketMQ as the event source.'),
    sourceSLSParameters?: {
      consumePosition?: string(name='ConsumePosition', description='The consumer offset. The value begin specifies the earliest offset. The value end specifies the latest offset. You can also specify a time in seconds to start consumption.', example='end'),
      logStore?: string(name='LogStore', description='The Simple Log Service Logstore.', example='sas-log'),
      project?: string(name='Project', description='The Simple Log Service project.', example='test'),
      roleName?: string(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Simple Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the Resource Access Management (RAM) console.', example='testRole'),
    }(name='SourceSLSParameters', description='The parameters that are configured if you specify Simple Log Service as the event source.'),
  }(name='Source', description='The event provider, which is also known as the event source. You must and can specify only one event source.

This parameter is required.'),
  transforms?: [ 
    {
      arn?: string(name='Arn', example='acs:fc:cn-hangzhou:*****:services/demo-service.LATEST/functions/demo-func'),
    }
  ](name='Transforms'),
}

model CreateEventStreamingShrinkRequest {
  description?: string(name='Description', description='The description of the event stream.', example='rocketmq2mns'),
  eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream.

This parameter is required.', example='myeventstreaming'),
  filterPattern?: string(name='FilterPattern', description='The rule that is used to filter events. If you leave this parameter empty, all events are matched.

This parameter is required.'),
  runOptionsShrink?: string(name='RunOptions', description='The parameters that are configured for the runtime environment.'),
  sinkShrink?: string(name='Sink', description='The event target. You must and can specify only one event target.

This parameter is required.'),
  sourceShrink?: string(name='Source', description='The event provider, which is also known as the event source. You must and can specify only one event source.

This parameter is required.'),
  transformsShrink?: string(name='Transforms'),
}

model CreateEventStreamingResponseBody = {
  code?: string(name='Code', description='The response code. Valid values:

*   Success: The request is successful.
*   Other codes: The request failed. For more information about error codes, see Error codes.', example='200'),
  data?: {
    eventStreamingARN?: string(name='EventStreamingARN', description='The ARN of the event stream.', example='acs:eventbridge:cn-hangzhou:164901546557****:eventstreaming/myeventstreaming'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='The name [xxxx] of event streaming in request is already exist!'),
  requestId?: string(name='RequestId', description='The request ID.', example='B896B484-F16D-59DE-9E23-DD0E5C361108'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. The value true indicates that the operation is successful.', example='true'),
}

model CreateEventStreamingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEventStreamingResponseBody(name='body'),
}

/**
 * @summary Creates an event stream.
 *
 * @description You can call this API operation to create an event stream.
 *
 * @param tmpReq CreateEventStreamingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEventStreamingResponse
 */
async function createEventStreamingWithOptions(tmpReq: CreateEventStreamingRequest, runtime: Util.RuntimeOptions): CreateEventStreamingResponse {
  Util.validateModel(tmpReq);
  var request = new CreateEventStreamingShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.runOptions)) {
    request.runOptionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.runOptions, 'RunOptions', 'json');
  }
  if (!Util.isUnset(tmpReq.sink)) {
    request.sinkShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sink, 'Sink', 'json');
  }
  if (!Util.isUnset(tmpReq.source)) {
    request.sourceShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.source, 'Source', 'json');
  }
  if (!Util.isUnset(tmpReq.transforms)) {
    request.transformsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.transforms, 'Transforms', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  if (!Util.isUnset(request.filterPattern)) {
    body['FilterPattern'] = request.filterPattern;
  }
  if (!Util.isUnset(request.runOptionsShrink)) {
    body['RunOptions'] = request.runOptionsShrink;
  }
  if (!Util.isUnset(request.sinkShrink)) {
    body['Sink'] = request.sinkShrink;
  }
  if (!Util.isUnset(request.sourceShrink)) {
    body['Source'] = request.sourceShrink;
  }
  if (!Util.isUnset(request.transformsShrink)) {
    body['Transforms'] = request.transformsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an event stream.
 *
 * @description You can call this API operation to create an event stream.
 *
 * @param request CreateEventStreamingRequest
 * @return CreateEventStreamingResponse
 */
async function createEventStreaming(request: CreateEventStreamingRequest): CreateEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEventStreamingWithOptions(request, runtime);
}

model CreateRuleRequest {
  description?: string(name='Description', description='The description of the event bus.'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='MyEventBus'),
  eventTargets?: [ 
    {
      deadLetterQueue?: {
        arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the dead-letter queue. Events that are not processed or whose maximum retries are exceeded are written to the dead-letter queue. The ARN feature is supported by the following queue types: MNS and Message Queue for Apache RocketMQ.', example='acs:mns:cn-hangzhou:123456789098****:/queues/rule-deadletterqueue'),
      }(name='DeadLetterQueue', description='The dead-letter queue. Events that are not processed or whose maximum retries are exceeded are written to the dead-letter queue. The dead-letter queue feature is supported by the following queue types: Message Queue for Apache RocketMQ, Message Service (MNS), Message Queue for Apache Kafka, and EventBridge.'),
      endpoint?: string(name='Endpoint', description='The endpoint of the event target.', example='acs:mns:cn-hangzhou:123456789098****:queues/myqueue'),
      errorsTolerance?: string(name='ErrorsTolerance', description='The fault tolerance policy. Valid values: ALL: allows fault tolerance. If an error occurs, the event processing is not blocked. If the message fails to be sent after the maximum number of retries specified by the retry policy is reached, the message is delivered to the dead-letter queue or discarded based on your configurations. NONE: does not allow fault tolerance. If an error occurs and the message fails to be sent after the maximum number of retries specified by the retry policy is reached, the event processing is blocked.', example='ALL'),
      id?: string(name='Id', description='The ID of the custom event target.

This parameter is required.', example='12021'),
      paramList?: [ 
        {
          form?: string(name='Form', description='The format that is used by the event target parameter. For more information, see [Limits.](https://www.alibabacloud.com/help/en/eventbridge/latest/limits)', example='TEMPLATE'),
          resourceKey?: string(name='ResourceKey', description='The resource parameter of the event target. For more information, see [Limits](https://www.alibabacloud.com/help/en/eventbridge/latest/limits)', example='body'),
          template?: string(name='Template', description='The template that is used by the event target parameter.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value of the event target parameter.', example='{\\\\"key\\\\"=\\\\"value\\\\"}'),
        }
      ](name='ParamList', description='The parameters that are configured for the event target.'),
      pushRetryStrategy?: string(name='PushRetryStrategy', description='The retry policy that is used to push events. Valid values: BACKOFF_RETRY: backoff retry. If an event failed to be pushed, it can be retried up to three times. The interval between two consecutive retries is a random value between 10 and 20 seconds. EXPONENTIAL_DECAY_RETRY: exponential decay retry. If an event failed to be pushed, it can be retried up to 176 times. The interval between two consecutive retries exponentially increases to 512 seconds, and the total retry time is one day. The specific retry intervals are 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 512, ..., and 512 seconds. The interval of 512 seconds is used for 167 retries.', example='BACKOFF_RETRY'),
      type?: string(name='Type', description='The type of the event target. For more information, see [Event target parameters.](https://www.alibabacloud.com/help/en/eventbridge/latest/event-target-parameters)

This parameter is required.', example='acs.mns.queue'),
    }
  ](name='EventTargets', description='The event targets.'),
  filterPattern?: string(name='FilterPattern', description='The event pattern, in JSON format. Valid values: stringEqual and stringExpression. You can specify up to five expressions in the map data structure in each field.

You can specify up to five expressions in the map data structure in each field.

This parameter is required.', example='{\\\\"source\\\\": [{\\\\"prefix\\\\": \\\\"acs.\\\\"}],\\\\"type\\\\": [{\\\\"prefix\\\\":\\\\"oss:ObjectReplication\\\\"}],\\\\"subject\\\\":[{\\\\"prefix\\\\":\\\\"acs:oss:cn-hangzhou:123456789098****:my-movie-bucket/\\\\", \\\\"suffix\\\\":\\\\".txt\\\\"}]}'),
  ruleName?: string(name='RuleName', description='The name of the event rule.

This parameter is required.', example='MNSRule'),
  status?: string(name='Status', description='The status of the event rule. Valid values: ENABLE: enables the event rule. It is the default status of the event rule. DISABLE: disables the event rule.', example='ENABLE'),
}

model CreateRuleShrinkRequest {
  description?: string(name='Description', description='The description of the event bus.'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='MyEventBus'),
  eventTargetsShrink?: string(name='EventTargets', description='The event targets.'),
  filterPattern?: string(name='FilterPattern', description='The event pattern, in JSON format. Valid values: stringEqual and stringExpression. You can specify up to five expressions in the map data structure in each field.

You can specify up to five expressions in the map data structure in each field.

This parameter is required.', example='{\\\\"source\\\\": [{\\\\"prefix\\\\": \\\\"acs.\\\\"}],\\\\"type\\\\": [{\\\\"prefix\\\\":\\\\"oss:ObjectReplication\\\\"}],\\\\"subject\\\\":[{\\\\"prefix\\\\":\\\\"acs:oss:cn-hangzhou:123456789098****:my-movie-bucket/\\\\", \\\\"suffix\\\\":\\\\".txt\\\\"}]}'),
  ruleName?: string(name='RuleName', description='The name of the event rule.

This parameter is required.', example='MNSRule'),
  status?: string(name='Status', description='The status of the event rule. Valid values: ENABLE: enables the event rule. It is the default status of the event rule. DISABLE: disables the event rule.', example='ENABLE'),
}

model CreateRuleResponseBody = {
  code?: string(name='Code', description='The returned HTTP status code. The HTTP status code 200 indicates that the request is successful.', example='200'),
  data?: {
    ruleARN?: string(name='RuleARN', description='The ARN of the event rule. The ARN is used for authorization.', example='acs:eventbridge:cn-hangzhou:123456789098****:eventbus/default/rule/MNSRule'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='Remote error. requestId: [xxxx], error code: [xxx], message: [The target in event rule is invalid! Endpoint is xxx'),
  requestId?: string(name='RequestId', description='The request ID.', example='1AD6D598-7506-5D2C-81EA-30E3241A903A'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model CreateRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRuleResponseBody(name='body'),
}

/**
 * @summary Creates an event rule.
 *
 * @description You can call this API operation to create an event rule.
 *
 * @param tmpReq CreateRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRuleResponse
 */
async function createRuleWithOptions(tmpReq: CreateRuleRequest, runtime: Util.RuntimeOptions): CreateRuleResponse {
  Util.validateModel(tmpReq);
  var request = new CreateRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.eventTargets)) {
    request.eventTargetsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.eventTargets, 'EventTargets', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventTargetsShrink)) {
    query['EventTargets'] = request.eventTargetsShrink;
  }
  if (!Util.isUnset(request.filterPattern)) {
    query['FilterPattern'] = request.filterPattern;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an event rule.
 *
 * @description You can call this API operation to create an event rule.
 *
 * @param request CreateRuleRequest
 * @return CreateRuleResponse
 */
async function createRule(request: CreateRuleRequest): CreateRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRuleWithOptions(request, runtime);
}

model CreateServiceLinkedRoleForProductRequest {
  productName?: string(name='ProductName', description='The name of the cloud service or the name of the service-linked role with which the cloud service is associated.

This parameter is required.', example='AliyunServiceRoleForEventBridgeSendToMNS'),
}

model CreateServiceLinkedRoleForProductResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For more information about error codes, see Error codes.', example='Success'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message', description='The returned message. If the request is successful, success is returned.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='C36345A1-75F3-5A1A-BFCF-33B8271971FA'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model CreateServiceLinkedRoleForProductResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateServiceLinkedRoleForProductResponseBody(name='body'),
}

/**
 * @summary Creates a service-linked role for your cloud service.
 *
 * @description You can call this API operation to create a service-linked role for your cloud service.
 *
 * @param request CreateServiceLinkedRoleForProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateServiceLinkedRoleForProductResponse
 */
async function createServiceLinkedRoleForProductWithOptions(request: CreateServiceLinkedRoleForProductRequest, runtime: Util.RuntimeOptions): CreateServiceLinkedRoleForProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.productName)) {
    query['ProductName'] = request.productName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceLinkedRoleForProduct',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a service-linked role for your cloud service.
 *
 * @description You can call this API operation to create a service-linked role for your cloud service.
 *
 * @param request CreateServiceLinkedRoleForProductRequest
 * @return CreateServiceLinkedRoleForProductResponse
 */
async function createServiceLinkedRoleForProduct(request: CreateServiceLinkedRoleForProductRequest): CreateServiceLinkedRoleForProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceLinkedRoleForProductWithOptions(request, runtime);
}

model DeleteApiDestinationRequest {
  apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination.

This parameter is required.', example='ApiDestinationName'),
}

model DeleteApiDestinationResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  message?: string(name='Message', description='The returned message. If the request is successful, success is returned. If the request failed, an error code is returned.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='382E6272-8E9C-5681-AC96-A8AF0BFAC1A5'),
}

model DeleteApiDestinationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteApiDestinationResponseBody(name='body'),
}

/**
 * @summary Deletes an API destination.
 *
 * @description You can call this API operation to delete an API destination.
 *
 * @param request DeleteApiDestinationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteApiDestinationResponse
 */
async function deleteApiDestinationWithOptions(request: DeleteApiDestinationRequest, runtime: Util.RuntimeOptions): DeleteApiDestinationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apiDestinationName)) {
    query['ApiDestinationName'] = request.apiDestinationName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteApiDestination',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an API destination.
 *
 * @description You can call this API operation to delete an API destination.
 *
 * @param request DeleteApiDestinationRequest
 * @return DeleteApiDestinationResponse
 */
async function deleteApiDestination(request: DeleteApiDestinationRequest): DeleteApiDestinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteApiDestinationWithOptions(request, runtime);
}

model DeleteConnectionRequest {
  connectionName?: string(name='ConnectionName', description='The name of the connection that you want to delete.

This parameter is required.', example='connection-name'),
}

model DeleteConnectionResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  message?: string(name='Message', description='The returned message. If the request is successful, success is returned. If the request failed, an error code is returned.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='8EF25E37-1750-5D7A-BA56-F8AE081A69C8'),
}

model DeleteConnectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteConnectionResponseBody(name='body'),
}

/**
 * @summary Deletes a connection.
 *
 * @description You can call this API operation to delete a connection.
 *
 * @param request DeleteConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConnectionResponse
 */
async function deleteConnectionWithOptions(request: DeleteConnectionRequest, runtime: Util.RuntimeOptions): DeleteConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionName)) {
    query['ConnectionName'] = request.connectionName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteConnection',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a connection.
 *
 * @description You can call this API operation to delete a connection.
 *
 * @param request DeleteConnectionRequest
 * @return DeleteConnectionResponse
 */
async function deleteConnection(request: DeleteConnectionRequest): DeleteConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteConnectionWithOptions(request, runtime);
}

model DeleteEventBusRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='MyEventBus'),
}

model DeleteEventBusResponseBody = {
  code?: string(name='Code', description='The returned HTTP status code. The HTTP status code 200 indicates that the request is successful.', example='200'),
  data?: boolean(name='Data'),
  message?: string(name='Message', description='The returned error message.', example='EventBusNotExist'),
  requestId?: string(name='RequestId', description='The request ID.', example='C229E140-1A5C-5D55-8904-CFC5BA4CAA98'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='true'),
}

model DeleteEventBusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteEventBusResponseBody(name='body'),
}

/**
 * @summary Deletes an event bus.
 *
 * @description You can call this API operation to delete an event bus.
 *
 * @param request DeleteEventBusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEventBusResponse
 */
async function deleteEventBusWithOptions(request: DeleteEventBusRequest, runtime: Util.RuntimeOptions): DeleteEventBusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEventBus',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an event bus.
 *
 * @description You can call this API operation to delete an event bus.
 *
 * @param request DeleteEventBusRequest
 * @return DeleteEventBusResponse
 */
async function deleteEventBus(request: DeleteEventBusRequest): DeleteEventBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventBusWithOptions(request, runtime);
}

model DeleteEventSourceRequest {
  eventBusName?: string(name='EventBusName'),
  eventSourceName?: string(name='EventSourceName', description='The name of the event source.

This parameter is required.', example='myrabbitmq.source'),
}

model DeleteEventSourceResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For more information about error codes, see Error codes.', example='Success'),
  message?: string(name='Message', description='The returned error message.', example='Remote error. requestId: [78B66E68-E778-1F33-84BD-xxxx], error code: [EventSourceNotExist], message: [The event source in request is not exist! ]'),
  requestId?: string(name='RequestId', description='The request ID.', example='5f80e9b3-98d5-4f51-8412-c758818a03e4'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model DeleteEventSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteEventSourceResponseBody(name='body'),
}

/**
 * @summary Deletes an event source.
 *
 * @description You can call this API operation to delete an event source.
 *
 * @param request DeleteEventSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEventSourceResponse
 */
async function deleteEventSourceWithOptions(request: DeleteEventSourceRequest, runtime: Util.RuntimeOptions): DeleteEventSourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventBusName)) {
    body['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventSourceName)) {
    body['EventSourceName'] = request.eventSourceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEventSource',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an event source.
 *
 * @description You can call this API operation to delete an event source.
 *
 * @param request DeleteEventSourceRequest
 * @return DeleteEventSourceResponse
 */
async function deleteEventSource(request: DeleteEventSourceRequest): DeleteEventSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventSourceWithOptions(request, runtime);
}

model DeleteEventStreamingRequest {
  eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream that you want to delete.

This parameter is required.', example='rocketmq-sync'),
}

model DeleteEventStreamingResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  message?: string(name='Message', description='The returned error message.', example='The event streaming [xxxx] not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='499A9ACF-70CD-5D43-87F3-1B60529EE446'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='true'),
}

model DeleteEventStreamingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteEventStreamingResponseBody(name='body'),
}

/**
 * @summary Deletes an event stream.
 *
 * @description You can call this API operation to delete an event stream.
 *
 * @param request DeleteEventStreamingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEventStreamingResponse
 */
async function deleteEventStreamingWithOptions(request: DeleteEventStreamingRequest, runtime: Util.RuntimeOptions): DeleteEventStreamingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an event stream.
 *
 * @description You can call this API operation to delete an event stream.
 *
 * @param request DeleteEventStreamingRequest
 * @return DeleteEventStreamingResponse
 */
async function deleteEventStreaming(request: DeleteEventStreamingRequest): DeleteEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventStreamingWithOptions(request, runtime);
}

model DeleteRuleRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='tf-testacc-event-bus'),
  ruleName?: string(name='RuleName', description='The name of the event rule that you want to delete.

This parameter is required.', example='ramrolechange-mns'),
}

model DeleteRuleResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  message?: string(name='Message', description='The returned error message.', example='The event rule not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='FF942675-F937-549C-A942-EB94FFE28DD3'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model DeleteRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRuleResponseBody(name='body'),
}

/**
 * @summary Deletes an event rule.
 *
 * @description You can call this API operation to delete an event rule.
 *
 * @param request DeleteRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRuleResponse
 */
async function deleteRuleWithOptions(request: DeleteRuleRequest, runtime: Util.RuntimeOptions): DeleteRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an event rule.
 *
 * @description You can call this API operation to delete an event rule.
 *
 * @param request DeleteRuleRequest
 * @return DeleteRuleResponse
 */
async function deleteRule(request: DeleteRuleRequest): DeleteRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRuleWithOptions(request, runtime);
}

model DeleteTargetsRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='MyEventBus'),
  ruleName?: string(name='RuleName', description='The name of the event rule.

This parameter is required.', example='ramrolechange-mns'),
  targetIds?: [ string ](name='TargetIds', description='The IDs of the event targets that you want to delete.'),
}

model DeleteTargetsShrinkRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='MyEventBus'),
  ruleName?: string(name='RuleName', description='The name of the event rule.

This parameter is required.', example='ramrolechange-mns'),
  targetIdsShrink?: string(name='TargetIds', description='The IDs of the event targets that you want to delete.'),
}

model DeleteTargetsResponseBody = {
  code?: string(name='Code', description='The returned HTTP status code. The HTTP status code 200 indicates that the request is successful.', example='200'),
  data?: {
    errorEntries?: [ 
      {
        entryId?: string(name='EntryId', description='The ID of the event body that failed to be processed.', example='target5'),
        errorCode?: string(name='ErrorCode', description='The returned error code.', example='EventRuleTargetIdDuplicate'),
        errorMessage?: string(name='ErrorMessage', description='The returned error message.', example='The id of event target is duplicate!'),
      }
    ](name='ErrorEntries', description='The information about the event body that failed to be processed.'),
    errorEntriesCount?: int32(name='ErrorEntriesCount', description='The number of event bodies that failed to be processed. Valid values: 0: No event bodies failed to be processed. An integer other than 0: the number of event bodies that failed to be processed.', example='0'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='EventBusNotExist'),
  requestId?: string(name='RequestId', description='The request ID.', example='78FA9EAC-F0C0-58B0-871E-9F9756CE1D29'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='true'),
}

model DeleteTargetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTargetsResponseBody(name='body'),
}

/**
 * @summary Deletes one or more event targets of an event rule.
 *
 * @description You can call this API operation to delete one or more event targets of an event rule.
 *
 * @param tmpReq DeleteTargetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTargetsResponse
 */
async function deleteTargetsWithOptions(tmpReq: DeleteTargetsRequest, runtime: Util.RuntimeOptions): DeleteTargetsResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteTargetsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.targetIds)) {
    request.targetIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.targetIds, 'TargetIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.targetIdsShrink)) {
    query['TargetIds'] = request.targetIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTargets',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes one or more event targets of an event rule.
 *
 * @description You can call this API operation to delete one or more event targets of an event rule.
 *
 * @param request DeleteTargetsRequest
 * @return DeleteTargetsResponse
 */
async function deleteTargets(request: DeleteTargetsRequest): DeleteTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTargetsWithOptions(request, runtime);
}

model DisableRuleRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='MyEventBus'),
  ruleName?: string(name='RuleName', description='The name of the event rule.

This parameter is required.', example='tf-testacc-rule'),
}

model DisableRuleResponseBody = {
  code?: string(name='Code', description='The error code. The value Success indicates that the request is successful.', example='Success'),
  message?: string(name='Message', description='The returned error message.', example='EventRuleNotExisted'),
  requestId?: string(name='RequestId', description='The request ID.', example='C36345A1-75F3-5A1A-BFCF-33B8271971FA'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='true'),
}

model DisableRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableRuleResponseBody(name='body'),
}

/**
 * @summary Disables an event rule.
 *
 * @description You can call this API operation to disable an event rule.
 *
 * @param request DisableRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableRuleResponse
 */
async function disableRuleWithOptions(request: DisableRuleRequest, runtime: Util.RuntimeOptions): DisableRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disables an event rule.
 *
 * @description You can call this API operation to disable an event rule.
 *
 * @param request DisableRuleRequest
 * @return DisableRuleResponse
 */
async function disableRule(request: DisableRuleRequest): DisableRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableRuleWithOptions(request, runtime);
}

model EnableRuleRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='MyEventBus'),
  ruleName?: string(name='RuleName', description='The name of the event rule.

This parameter is required.', example='ramrolechange'),
}

model EnableRuleResponseBody = {
  code?: string(name='Code', description='The error code. The value Success indicates that the request is successful.', example='Success'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='EventRuleNotExisted'),
  requestId?: string(name='RequestId', description='The request ID.', example='580A938B-6107-586C-8EC7-F22EEBEDA9E6'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='true'),
}

model EnableRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableRuleResponseBody(name='body'),
}

/**
 * @summary Enables an event rule.
 *
 * @description You can call this API operation to enable an event rule.
 *
 * @param request EnableRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableRuleResponse
 */
async function enableRuleWithOptions(request: EnableRuleRequest, runtime: Util.RuntimeOptions): EnableRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables an event rule.
 *
 * @description You can call this API operation to enable an event rule.
 *
 * @param request EnableRuleRequest
 * @return EnableRuleResponse
 */
async function enableRule(request: EnableRuleRequest): EnableRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableRuleWithOptions(request, runtime);
}

model EventCenterCheckEnabledOnDefaultBusResponseBody = {
  code?: string(name='Code', example='Success'),
  data?: {
    enabled?: boolean(name='Enabled', example='true'),
  }(name='Data'),
  message?: string(name='Message', example='Unknown system error'),
  requestId?: string(name='RequestId', example='382E6272-8E9C-5681-AC96-XXXXXXXXX'),
  success?: boolean(name='Success', example='true'),
}

model EventCenterCheckEnabledOnDefaultBusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EventCenterCheckEnabledOnDefaultBusResponseBody(name='body'),
}

/**
 * @summary EventCenterCheckEnabledOnDefaultBus
 *
 * @param request EventCenterCheckEnabledOnDefaultBusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EventCenterCheckEnabledOnDefaultBusResponse
 */
async function eventCenterCheckEnabledOnDefaultBusWithOptions(runtime: Util.RuntimeOptions): EventCenterCheckEnabledOnDefaultBusResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'EventCenterCheckEnabledOnDefaultBus',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary EventCenterCheckEnabledOnDefaultBus
 *
 * @return EventCenterCheckEnabledOnDefaultBusResponse
 */
async function eventCenterCheckEnabledOnDefaultBus(): EventCenterCheckEnabledOnDefaultBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return eventCenterCheckEnabledOnDefaultBusWithOptions(runtime);
}

model EventCenterDisableOnDefaultBusResponseBody = {
  code?: string(name='Code', example='Success'),
  message?: string(name='Message', example='Unknown system error'),
  requestId?: string(name='RequestId', example='382E6272-8E9C-5681-AC96-XXXXXXXX'),
  success?: boolean(name='Success', example='true'),
}

model EventCenterDisableOnDefaultBusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EventCenterDisableOnDefaultBusResponseBody(name='body'),
}

/**
 * @summary EventCenterDisableOnDefaultBus
 *
 * @param request EventCenterDisableOnDefaultBusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EventCenterDisableOnDefaultBusResponse
 */
async function eventCenterDisableOnDefaultBusWithOptions(runtime: Util.RuntimeOptions): EventCenterDisableOnDefaultBusResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'EventCenterDisableOnDefaultBus',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary EventCenterDisableOnDefaultBus
 *
 * @return EventCenterDisableOnDefaultBusResponse
 */
async function eventCenterDisableOnDefaultBus(): EventCenterDisableOnDefaultBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return eventCenterDisableOnDefaultBusWithOptions(runtime);
}

model EventCenterEnableOnDefaultBusResponseBody = {
  code?: string(name='Code', example='Success'),
  message?: string(name='Message', example='Unknown system error'),
  requestId?: string(name='RequestId', example='1AD6D598-7506-5D2C-81EA-XXXXXXXX'),
  success?: boolean(name='Success', example='true'),
}

model EventCenterEnableOnDefaultBusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EventCenterEnableOnDefaultBusResponseBody(name='body'),
}

/**
 * @summary EventCenterEnableOnDefaultBus
 *
 * @param request EventCenterEnableOnDefaultBusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EventCenterEnableOnDefaultBusResponse
 */
async function eventCenterEnableOnDefaultBusWithOptions(runtime: Util.RuntimeOptions): EventCenterEnableOnDefaultBusResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'EventCenterEnableOnDefaultBus',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary EventCenterEnableOnDefaultBus
 *
 * @return EventCenterEnableOnDefaultBusResponse
 */
async function eventCenterEnableOnDefaultBus(): EventCenterEnableOnDefaultBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return eventCenterEnableOnDefaultBusWithOptions(runtime);
}

model EventCenterQueryEventsRequest {
  body?: {
    parameters?: {
      breakdowns?: [ string ](name='Breakdowns'),
      calculations?: [ 
        {
          column?: string(name='Column', example='source'),
          op?: string(name='Op', example='COUNT_DISTINCT'),
        }
      ](name='Calculations'),
      endTime?: integer(name='EndTime', example='1687861201814'),
      filterCombination?: string(name='FilterCombination', example='AND'),
      filters?: [ 
        {
          column?: string(name='Column', example='source'),
          op?: string(name='Op', example='='),
          values?: [ string ](name='Values'),
        }
      ](name='Filters'),
      granularity?: integer(name='Granularity', example='30'),
      limit?: integer(name='Limit', example='100'),
      offset?: integer(name='Offset', example='0'),
      orders?: [ 
        {
          column?: string(name='Column', example='source'),
          desc?: boolean(name='Desc', example='true'),
          op?: string(name='Op', example='AVG'),
        }
      ](name='Orders'),
      startTime?: integer(name='StartTime', example='1687860901814'),
      timeRange?: integer(name='TimeRange', example='1000000'),
    }(name='Parameters', description='This parameter is required.'),
    queryType?: string(name='QueryType', description='This parameter is required.', example='timeseries_and_table'),
    schemaId?: string(name='SchemaId', description='Schema ID。

This parameter is required.', example='ecs:GeneralSchema'),
  }(name='Body', description='This parameter is required.'),
  busName?: string(name='BusName', example='default'),
  maxResults?: int32(name='MaxResults', description='本次读取的最大数据量，默认值为100。', example='100'),
  nextToken?: string(name='NextToken', description='用来标记当前开始读取的位置。置空表示从头开始。', example='100'),
}

model EventCenterQueryEventsShrinkRequest {
  bodyShrink?: string(name='Body', description='This parameter is required.'),
  busName?: string(name='BusName', example='default'),
  maxResults?: int32(name='MaxResults', description='本次读取的最大数据量，默认值为100。', example='100'),
  nextToken?: string(name='NextToken', description='用来标记当前开始读取的位置。置空表示从头开始。', example='100'),
}

model EventCenterQueryEventsResponseBody = {
  code?: string(name='Code', example='Success'),
  data?: {
    maxResults?: int32(name='MaxResults', example='100'),
    nextToken?: string(name='NextToken', example='100'),
    table?: [ 
      {
        rowData?: map[string]any(name='RowData', example='{
  "id":"xxx",
  "source":"acs.ecs"
}'),
      }
    ](name='Table'),
    timeSeries?: [ 
      {
        rowData?: map[string]any(name='RowData', example='{
  "id":"xxx",
  "source":"acs.ecs"
}'),
        time?: string(name='Time', example='1683561600000'),
      }
    ](name='TimeSeries'),
    totalCount?: int32(name='TotalCount', example='76'),
  }(name='Data'),
  message?: string(name='Message', example='Specified parameter Limit is not valid.'),
  requestId?: string(name='RequestId', example='5DAF96FB-A4B6-548C-B999-XXXXXXXX'),
  success?: boolean(name='Success', example='true'),
}

model EventCenterQueryEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EventCenterQueryEventsResponseBody(name='body'),
}

/**
 * @summary EventCenterQueryEvents
 *
 * @param tmpReq EventCenterQueryEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EventCenterQueryEventsResponse
 */
async function eventCenterQueryEventsWithOptions(tmpReq: EventCenterQueryEventsRequest, runtime: Util.RuntimeOptions): EventCenterQueryEventsResponse {
  Util.validateModel(tmpReq);
  var request = new EventCenterQueryEventsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.body)) {
    request.bodyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.body, 'Body', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.busName)) {
    query['BusName'] = request.busName;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.bodyShrink)) {
    body['Body'] = request.bodyShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EventCenterQueryEvents',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary EventCenterQueryEvents
 *
 * @param request EventCenterQueryEventsRequest
 * @return EventCenterQueryEventsResponse
 */
async function eventCenterQueryEvents(request: EventCenterQueryEventsRequest): EventCenterQueryEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return eventCenterQueryEventsWithOptions(request, runtime);
}

model GetApiDestinationRequest {
  apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination.

This parameter is required.', example='api-destination-name'),
}

model GetApiDestinationResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  data?: {
    apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination.', example='demo'),
    connectionName?: string(name='ConnectionName', description='The connection name.', example='test-basic'),
    description?: string(name='Description', description='The description of the API destination.', example='demo'),
    gmtCreate?: long(name='GmtCreate', description='The time when the API destination was created.', example='1649055710565'),
    httpApiParameters?: {
      endpoint?: string(name='Endpoint', description='The endpoint of the API destination.', example='http://127.0.0.1:8001/api'),
      method?: string(name='Method', description='The HTTP request method. Valid values:

*   POST
*   GET
*   DELETE
*   PUT
*   HEAD
*   TRACE
*   PATCH', example='POST'),
    }(name='HttpApiParameters', description='The request parameters that are configured for the API destination.'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message. If the request is successful, success is returned. If the request failed, an error code is returned.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='B896B484-F16D-59DE-9E23-DD0E5C361108'),
}

model GetApiDestinationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetApiDestinationResponseBody(name='body'),
}

/**
 * @summary Queries the information about an API destination.
 *
 * @description You can call this API operation to query the information about an API destination.
 *
 * @param request GetApiDestinationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetApiDestinationResponse
 */
async function getApiDestinationWithOptions(request: GetApiDestinationRequest, runtime: Util.RuntimeOptions): GetApiDestinationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apiDestinationName)) {
    query['ApiDestinationName'] = request.apiDestinationName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetApiDestination',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about an API destination.
 *
 * @description You can call this API operation to query the information about an API destination.
 *
 * @param request GetApiDestinationRequest
 * @return GetApiDestinationResponse
 */
async function getApiDestination(request: GetApiDestinationRequest): GetApiDestinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getApiDestinationWithOptions(request, runtime);
}

model GetConnectionRequest {
  connectionName?: string(name='ConnectionName', description='The connection name.

This parameter is required.', example='connection-name'),
}

model GetConnectionResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  data?: {
    connections?: [ 
      {
        authParameters?: {
          apiKeyAuthParameters?: {
            apiKeyName?: string(name='ApiKeyName', description='The key of the API key.', example='key'),
            apiKeyValue?: string(name='ApiKeyValue', description='The value of the API key.', example='value'),
          }(name='ApiKeyAuthParameters', description='The information about API key authentication.'),
          authorizationType?: string(name='AuthorizationType', description='The authentication method. Valid values:

*   BASIC_AUTH: basic authentication.
*   API_KEY_AUTH: API key authentication.
*   OAUTH_AUTH: OAuth authentication.', example='BASIC_AUTH'),
          basicAuthParameters?: {
            password?: string(name='Password', description='The password of basic authentication.', example='********'),
            username?: string(name='Username', description='The username of basic authentication.', example='admin'),
          }(name='BasicAuthParameters', description='The information about basic authentication.'),
          OAuthParameters?: {
            authorizationEndpoint?: string(name='AuthorizationEndpoint', description='The endpoint that is used to obtain the OAuth token.', example='http://localhost:8080/oauth/token'),
            clientParameters?: {
              clientID?: string(name='ClientID', description='The client ID.', example='ClientID'),
              clientSecret?: string(name='ClientSecret', description='The AccessKey secret of the client.', example='Qo57Q~F249~S74GmNPA36pZJoJK4f****'),
            }(name='ClientParameters', description='The information about the client.'),
            httpMethod?: string(name='HttpMethod', description='The HTTP request method. Valid values:

*   GET
*   POST
*   HEAD', example='POST'),
            OAuthHttpParameters?: {
              bodyParameters?: [ 
                {
                  isValueSecret?: string(name='IsValueSecret', description='Indicates whether authentication is enabled.', example='false'),
                  key?: string(name='Key', description='The key of the request body.', example='keyDemo'),
                  value?: string(name='Value', description='The value of the request body.', example='valueDemo'),
                }
              ](name='BodyParameters', description='The information about the request body.'),
              headerParameters?: [ 
                {
                  isValueSecret?: string(name='IsValueSecret', description='Indicates whether authentication is enabled.', example='false'),
                  key?: string(name='Key', description='The key of the request header.', example='keyDemo'),
                  value?: string(name='Value', description='The value of the request header.', example='keyDemo'),
                }
              ](name='HeaderParameters', description='The information about the request header.'),
              queryStringParameters?: [ 
                {
                  isValueSecret?: string(name='IsValueSecret', description='Indicates whether authentication is enabled.', example='false'),
                  key?: string(name='Key', description='The key of the request path.', example='keyDemo'),
                  value?: string(name='Value', description='The value of the request path.', example='valueDemo'),
                }
              ](name='QueryStringParameters', description='The information about the request path.'),
            }(name='OAuthHttpParameters', description='The request parameters of OAuth authentication.'),
          }(name='OAuthParameters', description='The information about OAuth authentication.'),
        }(name='AuthParameters', description='The authentication methods.'),
        connectionName?: string(name='ConnectionName', description='The connection name.', example='demo'),
        description?: string(name='Description', description='The connection description.', example='demo'),
        gmtCreate?: long(name='GmtCreate', description='The time when the connection was created.', example='1669648905'),
        id?: long(name='Id', description='The data source ID.', example='5668'),
        networkParameters?: {
          networkType?: string(name='NetworkType', description='*   PublicNetwork: the Internet.
*   PrivateNetwork: virtual private cloud (VPC).', example='PublicNetwork'),
          securityGroupId?: string(name='SecurityGroupId', description='The security group ID.', example='eb-167adad548759-security_grop/sg-bp1addad26peuh9qh9****'),
          vpcId?: string(name='VpcId', description='The VPC ID.', example='eb-test/vpc-bp1symadadwnwg****'),
          vswitcheId?: string(name='VswitcheId', description='The vSwitch ID.', example='vsw-bp1iu4x7aeradadown****,vsw-bp193sqmadadlaszpeq****'),
        }(name='NetworkParameters', description='The information about the network.'),
      }
    ](name='Connections', description='The queried connections.'),
  }(name='Data', description='The returned data.'),
  httpCode?: int32(name='HttpCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='success'),
  requestId?: string(name='RequestId', description='The returned request ID.', example='34AD682D-5B91-5773-8132-AA38C130****'),
}

model GetConnectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetConnectionResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of a connection.
 *
 * @description You can call this API operation to query the configurations of a connection.
 *
 * @param request GetConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetConnectionResponse
 */
async function getConnectionWithOptions(request: GetConnectionRequest, runtime: Util.RuntimeOptions): GetConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionName)) {
    query['ConnectionName'] = request.connectionName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetConnection',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the configurations of a connection.
 *
 * @description You can call this API operation to query the configurations of a connection.
 *
 * @param request GetConnectionRequest
 * @return GetConnectionResponse
 */
async function getConnection(request: GetConnectionRequest): GetConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConnectionWithOptions(request, runtime);
}

model GetEventBusRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='MyEventBus'),
}

model GetEventBusResponseBody = {
  code?: string(name='Code', description='The response code. The value Success indicates that the request is successful.', example='Success'),
  data?: {
    createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates when the event bus was created.', example='1641781825000'),
    description?: string(name='Description', description='The description of the event bus.', example='demo'),
    eventBusARN?: string(name='EventBusARN', description='The Alibaba Cloud Resource Name (ARN) of the event bus.', example='acs:eventbridge:cn-hangzhou:123456789098****:eventbus/MyEventBus'),
    eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='MyEventBus'),
  }(name='Data', description='The data returned.'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='EventBusNotExist'),
  requestId?: string(name='RequestId', description='The request ID.', example='d5bfc188-4452-4ba7-b73a-a9005e522439'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='true'),
}

model GetEventBusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEventBusResponseBody(name='body'),
}

/**
 * @summary Queries the detailed information about an event bus.
 *
 * @description You can call this API operation to query the detailed information about an event bus.
 *
 * @param request GetEventBusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEventBusResponse
 */
async function getEventBusWithOptions(request: GetEventBusRequest, runtime: Util.RuntimeOptions): GetEventBusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEventBus',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the detailed information about an event bus.
 *
 * @description You can call this API operation to query the detailed information about an event bus.
 *
 * @param request GetEventBusRequest
 * @return GetEventBusResponse
 */
async function getEventBus(request: GetEventBusRequest): GetEventBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEventBusWithOptions(request, runtime);
}

model GetEventStreamingRequest {
  eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream whose details you want to query.

This parameter is required.', example='myeventstreaming'),
}

model GetEventStreamingResponseBody = {
  code?: string(name='Code', description='The response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For a list of error codes, see Error codes.', example='Success'),
  data?: {
    description?: string(name='Description', description='The description of the event stream that is returned.', example='RocketMQ-to-RocketMQ'),
    detailedStatus?: {
      delayTime?: long(name='DelayTime'),
      diffOffset?: long(name='DiffOffset'),
      extensions?: map[string]any(name='Extensions'),
      TPS?: double(name='TPS'),
    }(name='DetailedStatus'),
    eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream that is returned.', example='rocketmq-sync'),
    filterPattern?: string(name='FilterPattern', description='The rule that is used to filter events. If you leave this parameter empty, all events are matched.'),
    runOptions?: {
      batchWindow?: {
        countBasedWindow?: int32(name='CountBasedWindow', description='The maximum number of events that are allowed in the batch window. If this threshold is reached, data in the window is pushed downstream. When multiple batch windows exist, data is pushed if triggering conditions are met in one of the windows.', example='100'),
        timeBasedWindow?: int32(name='TimeBasedWindow', description='The maximum period of time during which events are allowed in the batch window. Unit: seconds. If this threshold is reached, data in the window is pushed downstream. When multiple batch windows exist, data is pushed if triggering conditions are met in one of the windows.', example='10'),
      }(name='BatchWindow', description='The batch window.'),
      deadLetterQueue?: {
        arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the dead-letter queue.', example='acs:ram::1550203943326350:role/edskmstoecs'),
      }(name='DeadLetterQueue', description='Indicates whether dead-letter queues are enabled. By default, dead-letter queues are disabled. Messages that fail to be pushed after allowed retries as specified by the retry policy are discarded.'),
      errorsTolerance?: string(name='ErrorsTolerance', description='The fault tolerance policy. The value NONE specifies that faults are not tolerated, and the value All specifies that all faults are tolerated.', example='ALL'),
      logDelivery?: {
        kafkaLogParameters?: [ 
          {
            endpoint?: string(name='Endpoint'),
            instanceId?: string(name='InstanceId'),
            topic?: string(name='Topic'),
          }
        ](name='KafkaLogParameters'),
        SLSLogParameters?: [ 
          {
            logstoreName?: string(name='LogstoreName'),
            projectName?: string(name='ProjectName'),
          }
        ](name='SLSLogParameters'),
      }(name='LogDelivery'),
      maximumTasks?: int32(name='MaximumTasks', description='The concurrency level.', example='2'),
      network?: {
        securityGroupId?: string(name='SecurityGroupId'),
        vSwitchIds?: [ string ](name='VSwitchIds'),
        vpcId?: string(name='VpcId'),
      }(name='Network'),
      resourceSpec?: {
        resources?: [ 
          {
            type?: string(name='Type'),
            value?: int32(name='Value'),
          }
        ](name='Resources'),
      }(name='ResourceSpec'),
      retryStrategy?: {
        maximumEventAgeInSeconds?: float(name='MaximumEventAgeInSeconds', description='The maximum period of time during which retries are performed.', example='512'),
        maximumRetryAttempts?: float(name='MaximumRetryAttempts', description='The maximum number of retries.', example='2'),
        pushRetryStrategy?: string(name='PushRetryStrategy', description='The retry policy. Valid values: BACKOFFRETRY and EXPONENTIALDECAY_RETRY.', example='BACKOFFRETRY'),
      }(name='RetryStrategy', description='The information about the retry policy that is used if the event fails to be pushed.'),
      roleName?: string(name='RoleName'),
      scaledObject?: {
        maxReplicaCount?: int32(name='MaxReplicaCount'),
        minReplicaCount?: int32(name='MinReplicaCount'),
        triggers?: [ 
          {
            metadata?: {
              type?: string(name='Type'),
              value?: int32(name='Value'),
            }(name='Metadata'),
            type?: string(name='Type'),
          }
        ](name='Triggers'),
      }(name='ScaledObject'),
    }(name='RunOptions', description='The parameters that are configured for the runtime environment.'),
    sink?: {
      sinkCustomizedKafkaConnectorParameters?: {
        connectorPackageUrl?: string(name='ConnectorPackageUrl'),
        connectorParameters?: {
          config?: map[string]any(name='Config'),
          name?: string(name='Name'),
        }(name='ConnectorParameters'),
        workerParameters?: map[string]any(name='WorkerParameters'),
      }(name='SinkCustomizedKafkaConnectorParameters'),
      sinkCustomizedKafkaParameters?: {
        instanceId?: string(name='InstanceId'),
      }(name='SinkCustomizedKafkaParameters'),
      sinkDataHubParameters?: {
        body?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Body'),
        project?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Project'),
        roleName?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='RoleName'),
        topic?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Topic'),
        topicSchema?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='TopicSchema'),
        topicType?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='TopicType'),
      }(name='SinkDataHubParameters'),
      sinkFcParameters?: {
        body?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Body', description='The message body that is sent to the function.'),
        concurrency?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.', example='None'),
          value?: string(name='Value', description='The delivery concurrency. Minimum value: 1.', example='1'),
        }(name='Concurrency', description='The delivery concurrency. Minimum value: 1.'),
        functionName?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The function name.', example='mFunction'),
        }(name='FunctionName', description='The function name.'),
        invocationType?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The invocation type.', example='Async'),
        }(name='InvocationType', description='The invocation type. Valid values: Sync: synchronous Async: asynchronous'),
        qualifier?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The alias of the service to which the function belongs.', example='LATEST'),
        }(name='Qualifier', description='The alias of the service to which the function belongs.'),
        serviceName?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The name of the service.', example='myService'),
        }(name='ServiceName', description='The service name.'),
      }(name='SinkFcParameters', description='The parameters that are returned if the event target is Function Compute.'),
      sinkFnfParameters?: {
        executionName?: {
          form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.', example='None'),
          value?: string(name='Value', description='The execution name.', example='123'),
        }(name='ExecutionName', description='The execution name.'),
        flowName?: {
          form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.', example='None'),
          value?: string(name='Value', description='The flow name.', example='test-streaming-fnf'),
        }(name='FlowName', description='The flow name.'),
        input?: {
          form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.', example='None'),
          value?: string(name='Value', description='The execution input information.', example='123'),
        }(name='Input', description='The execution input information.'),
        roleName?: {
          form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.', example='None'),
          value?: string(name='Value', description='The role configuration.', example='Al****FNF-x****'),
        }(name='RoleName', description='The role name.'),
      }(name='SinkFnfParameters', description='The Sink Fnf parameters.'),
      sinkKafkaParameters?: {
        acks?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The acknowledgment information.', example='1'),
        }(name='Acks', description='The acknowledgment information.'),
        instanceId?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The instance ID.', example='Defaut_1283278472_sadkj'),
        }(name='InstanceId', description='The target service type is Message Queue for Apache Kafka.'),
        key?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The message key.', example='key'),
        }(name='Key', description='The message key.'),
        topic?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The topic name.', example='topic-test'),
        }(name='Topic', description='The topic name.'),
        value?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Value', description='The message content.'),
      }(name='SinkKafkaParameters', description='The parameters that are returned if the event target is Message Queue for Apache Kafka.'),
      sinkMNSParameters?: {
        body?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Body', description='The message content.'),
        isBase64Encode?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='Specifies that Base64 encoding is enabled.', example='true'),
        }(name='IsBase64Encode', description='Indicates whether Base64 encoding is enabled.'),
        queueName?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The name of the MNS queue.', example='MyQueue'),
        }(name='QueueName', description='The target service type is MNS.'),
      }(name='SinkMNSParameters', description='The parameters that are returned if the event target is Message Service (MNS).'),
      sinkRabbitMQParameters?: {
        body?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Body', description='The message content.'),
        exchange?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The name of the exchange in the Message Queue for RabbitMQ instance.', example='a_exchange'),
        }(name='Exchange', description='The exchange mode. This parameter is available only if TargetType is set to Exchange.'),
        instanceId?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The ID of the Message Queue for RabbitMQ instance.', example='e5c9b727-e06c-4d7e-84d5-f8ce644e00bf'),
        }(name='InstanceId', description='The target service type is Message Queue for RabbitMQ instance.'),
        messageId?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='MessageId', description='The message ID.'),
        properties?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Properties', description='The tags that are used to filter messages.'),
        queueName?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The name of the queue in the Message Queue for RabbitMQ instance.', example='MyQueue'),
        }(name='QueueName', description='The queue mode. This parameter is available only if TargetType is set to Queue.'),
        routingKey?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The routing rule for the message.', example='housekeeping'),
        }(name='RoutingKey', description='The routing rule for the message. This parameter is available only if TargetType is set to Exchange.'),
        targetType?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The type of the resource to which the event is delivered. Valid values: Exchange: exchanges. Queue: queues.', example='Exchange/Queue'),
        }(name='TargetType', description='The target type.'),
        virtualHostName?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The vhost name of the Message Queue for RabbitMQ instance.', example='rabbit-host'),
        }(name='VirtualHostName', description='The name of the vhost of the Message Queue for RabbitMQ instance.'),
      }(name='SinkRabbitMQParameters', description='The parameters that are returned if the event target is Message Queue for RabbitMQ.'),
      sinkRocketMQParameters?: {
        body?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Body', description='The message content.'),
        instanceEndpoint?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='InstanceEndpoint'),
        instanceId?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The ID of the Message Queue for Apache RocketMQ instance.', example='MQ_INST_164901546557****_BAAN****'),
        }(name='InstanceId', description='The target service type is Message Queue for Apache RocketMQ.'),
        instancePassword?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='InstancePassword'),
        instanceType?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='InstanceType'),
        instanceUsername?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='InstanceUsername'),
        keys?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Keys', description='The tags that are used to filter messages.'),
        network?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Network'),
        properties?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Properties', description='The tags that are used to filter messages.'),
        securityGroupId?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='SecurityGroupId'),
        tags?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Tags', description='The tags that are used to filter messages.'),
        topic?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The name of the topic in the Message Queue for Apache RocketMQ instance.', example='Mytopic'),
        }(name='Topic', description='The name of the topic in the Message Queue for Apache RocketMQ instance.'),
        vSwitchIds?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='VSwitchIds'),
        vpcId?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='VpcId'),
      }(name='SinkRocketMQParameters', description='Sink RocketMQ Parameters'),
      sinkSLSParameters?: {
        body?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Body', description='The message content.'),
        contentSchema?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='ContentSchema'),
        contentType?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='ContentType'),
        logStore?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The Log Service Logstore.', example='test-logstore'),
        }(name='LogStore', description='The Simple Log Service Logstore.'),
        project?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The Log Service project.', example='test-project'),
        }(name='Project', description='The Simple Log Service project.'),
        roleName?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The role name. If you want to authorize EventBridge to use this role to read logs in Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the RAM console.', example='testRole'),
        }(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Simple Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the Resource Access Management (RAM) console.'),
        topic?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The name of the topic in which logs are stored. The topic corresponds to the topic reserved field in Log Service.', example='testTopic'),
        }(name='Topic', description='The name of the topic in which logs are stored. The topic corresponds to the topic reserved field in Simple Log Service.'),
      }(name='SinkSLSParameters', description='Sink SLS Parameters'),
    }(name='Sink', description='The event target.'),
    source?: {
      sourceApacheKafkaParameters?: {
        bootstraps?: string(name='Bootstraps'),
        consumerGroup?: string(name='ConsumerGroup'),
        networkType?: string(name='NetworkType'),
        offsetReset?: string(name='OffsetReset'),
        saslMechanism?: string(name='SaslMechanism'),
        saslPassword?: string(name='SaslPassword'),
        saslUser?: string(name='SaslUser'),
        securityGroupId?: string(name='SecurityGroupId'),
        securityProtocol?: string(name='SecurityProtocol'),
        topic?: string(name='Topic'),
        vSwitchIds?: string(name='VSwitchIds'),
        valueDataType?: string(name='ValueDataType'),
        vpcId?: string(name='VpcId'),
      }(name='SourceApacheKafkaParameters'),
      sourceCustomizedKafkaConnectorParameters?: {
        connectorPackageUrl?: string(name='ConnectorPackageUrl'),
        connectorParameters?: {
          config?: map[string]any(name='Config'),
          name?: string(name='Name'),
        }(name='ConnectorParameters'),
        workerParameters?: map[string]any(name='WorkerParameters'),
      }(name='SourceCustomizedKafkaConnectorParameters'),
      sourceCustomizedKafkaParameters?: {
        instanceId?: string(name='InstanceId'),
      }(name='SourceCustomizedKafkaParameters'),
      sourceDTSParameters?: {
        brokerUrl?: string(name='BrokerUrl', description='The URL and port number of the data subscription channel.'),
        initCheckPoint?: string(name='InitCheckPoint', description='The consumer offset. A consumer offset is a timestamp that indicates when the SDK client consumes the first data record. The value is a UNIX timestamp.', example='1620962769'),
        password?: string(name='Password', description='The password of the consumer group.', example='admin'),
        sid?: string(name='Sid', description='The ID of the consumer group.', example='HD1'),
        taskId?: string(name='TaskId', description='The task ID.', example='f86e5814-b223-482c-b768-3b873297dade'),
        topic?: string(name='Topic', description='The topic to which you want to subscribe by using the data subscription channel.', example='TP_TEST_UNDERWRITE_ISSUE'),
        username?: string(name='Username', description='The account of the consumer group.', example='admin'),
      }(name='SourceDTSParameters', description='The parameters that are returned if the event source is Data Transmission Service (DTS).'),
      sourceKafkaParameters?: {
        consumerGroup?: string(name='ConsumerGroup', description='The ID of the consumer group that subscribes to the topic.', example='GID_TEST'),
        instanceId?: string(name='InstanceId', description='The instance ID.', example='i-bp1fbtrnqmjvgq66ajdw'),
        network?: string(name='Network', description='The network. Default value: Default. The value PublicNetwork specifies a virtual private cloud (VPC).', example='Default'),
        offsetReset?: string(name='OffsetReset', description='The offset.', example='latest'),
        regionId?: string(name='RegionId', description='The region ID of the Message Queue for Apache Kafka instance.', example='cn-hangzhou'),
        securityGroupId?: string(name='SecurityGroupId', description='The security group ID.', example='sg-2vcgdxz7o1n9zappuimt'),
        topic?: string(name='Topic', description='The name of the topic.', example='topic_empower_1642473600414'),
        vSwitchIds?: string(name='VSwitchIds', description='The vSwitch ID.', example='vsw-wz9qqeovkwjxlu9uc8rst'),
        valueDataType?: string(name='ValueDataType', description='The encoding or decoding format. Valid values: Json, Text, and Binary. The value Json indicates that bytes are decoded into UTF-8 strings and then parsed into JSON format. The value Text indicates that bytes are decoded into UTF-8 strings and then put into the payload. The value Binary indicates that bytes are encoded into Base64 strings and put into the payload.', example='Text'),
        vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-2zehizpoendb3nwwu9w5o'),
      }(name='SourceKafkaParameters', description='The parameters that are returned if ApsaraMQ for Kafka is specified as the event source.'),
      sourceMNSParameters?: {
        isBase64Decode?: boolean(name='IsBase64Decode', description='Indicates whether Base64 encoding is enabled.', example='true'),
        queueName?: string(name='QueueName', description='The name of the MNS queue.', example='demo'),
        regionId?: string(name='RegionId', description='The region ID of the MNS queue.', example='cn-hangzhou'),
      }(name='SourceMNSParameters', description='Source MNS Parameters'),
      sourceMQTTParameters?: {
        bodyDataType?: string(name='BodyDataType'),
        instanceId?: string(name='InstanceId', description='The instance ID.', example='i-2ze06wqdwk0uq14krrzv'),
        regionId?: string(name='RegionId', description='The region ID of the Message Queue for MQTT instance.', example='cn-shanghai'),
        topic?: string(name='Topic', description='The name of the topic in the Message Queue for MQTT instance.', example='TOPIC-cainiao-pcs-wms-instock-noPrealertPrintLabel'),
      }(name='SourceMQTTParameters', description='The parameters that are returned if the event source is Message Queue for MQTT.'),
      sourcePrometheusParameters?: {
        clusterId?: string(name='ClusterId', example='c83555068b6******ad213f565f209'),
        dataType?: string(name='DataType', example='json'),
        labels?: string(name='Labels', example='__name__=.*'),
        regionId?: string(name='RegionId'),
      }(name='SourcePrometheusParameters'),
      sourceRabbitMQParameters?: {
        instanceId?: string(name='InstanceId', description='The ID of the Message Queue for RabbitMQ instance.', example='i-f8z9a9mcgwri1c1idd0z'),
        queueName?: string(name='QueueName', description='The name of the queue in the Message Queue for RabbitMQ instance.', example='comp'),
        regionId?: string(name='RegionId', description='The region ID of the Message Queue for RabbitMQ instance.', example='cn-hangzhou'),
        virtualHostName?: string(name='VirtualHostName', description='The vhost name of the Message Queue for RabbitMQ instance.', example='eb-connect'),
      }(name='SourceRabbitMQParameters', description='Source RabbitMQ Parameters'),
      sourceRocketMQParameters?: {
        authType?: string(name='AuthType', example='ACL'),
        bodyDataType?: string(name='BodyDataType'),
        filterSql?: string(name='FilterSql'),
        filterType?: string(name='FilterType'),
        groupID?: string(name='GroupID', description='The ID of the consumer group in the Message Queue for Apache RocketMQ instance.', example='GID_group1'),
        instanceEndpoint?: string(name='InstanceEndpoint', example='reg****-vpc.cn-zhangjiakou.aliyuncs.com'),
        instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ instance.', example='i-f8zbher64dlm58plyfte'),
        instanceNetwork?: string(name='InstanceNetwork', example='PublicNetwork'),
        instancePassword?: string(name='InstancePassword', example='xxxa'),
        instanceSecurityGroupId?: string(name='InstanceSecurityGroupId', example='sg-m5edtu24f12345****'),
        instanceType?: string(name='InstanceType', example='2'),
        instanceUsername?: string(name='InstanceUsername', example='xxxa'),
        instanceVSwitchIds?: string(name='InstanceVSwitchIds', example='vsw-m5ev8asdc6h12****'),
        instanceVpcId?: string(name='InstanceVpcId', example='vpc-m5e3sv4b12345****'),
        network?: string(name='Network'),
        offset?: string(name='Offset', description='The consumer offset of messages. Valid values: CONSUME_FROM_LAST_OFFSET: Start consumption from the latest offset. CONSUME_FROM_FIRST_OFFSET: Start consumption from the earliest offset. CONSUME_FROM_TIMESTAMP: Start consumption from the offset at the specified point in time.', example='CONSUMEFROMLASTOFFSET'),
        regionId?: string(name='RegionId', description='The region ID of the Message Queue for Apache RocketMQ instance.', example='cn-hangzhou'),
        securityGroupId?: string(name='SecurityGroupId'),
        tag?: string(name='Tag', description='The tags that are used to filter messages.', example='v1'),
        timestamp?: long(name='Timestamp', description='The timestamp of the offset from which consumption starts. This parameter is valid only if you set the Offset parameter to CONSUME_FROM_TIMESTAMP.', example='1636597951964'),
        topic?: string(name='Topic', description='The topic to which the message belongs.', example='topic_add_anima'),
        vSwitchIds?: string(name='VSwitchIds'),
        vpcId?: string(name='VpcId'),
      }(name='SourceRocketMQParameters', description='Source RocketMQ Parameters'),
      sourceSLSParameters?: {
        consumePosition?: string(name='ConsumePosition', description='The starting consumer offset. The value begin indicates the earliest offset, and the value end indicates the latest offset. You can also specify a time in seconds to start consumption.', example='begin'),
        consumerGroup?: string(name='ConsumerGroup', description='The consumer group.'),
        logStore?: string(name='LogStore', description='The Log Service Logstore.', example='waf-logstore'),
        project?: string(name='Project', description='The Log Service project.', example='dmmzk'),
        roleName?: string(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the RAM console.', example='testRole'),
      }(name='SourceSLSParameters', description='The parameters that are returned if the event provider is Simple Log Service.'),
    }(name='Source', description='The event provider, which is also known as the event source.'),
    status?: string(name='Status', description='The status of the event stream that is returned.', example='RUNNING'),
    transforms?: [ 
      {
        arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the cloud service, such as the ARN of a Function Compute function.', example='acs:fc:cn-hangzhou:*****:services/demo-service.LATEST/functions/demo-func'),
      }
    ](name='Transforms'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='The event streaming [xxxx] not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='7892F480-58C9-5067-AB35-8A7BEF0F726A'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. The value true indicates that the operation is successful.', example='true'),
}

model GetEventStreamingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEventStreamingResponseBody(name='body'),
}

/**
 * @summary Queries the details of an event stream.
 *
 * @description You can call this API operation to query the details of an event stream.
 *
 * @param request GetEventStreamingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEventStreamingResponse
 */
async function getEventStreamingWithOptions(request: GetEventStreamingRequest, runtime: Util.RuntimeOptions): GetEventStreamingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of an event stream.
 *
 * @description You can call this API operation to query the details of an event stream.
 *
 * @param request GetEventStreamingRequest
 * @return GetEventStreamingResponse
 */
async function getEventStreaming(request: GetEventStreamingRequest): GetEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEventStreamingWithOptions(request, runtime);
}

model GetRuleRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='default'),
  ruleName?: string(name='RuleName', description='The name of the event rule.

This parameter is required.', example='ram-changes'),
}

model GetRuleResponseBody = {
  code?: string(name='Code', description='The response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For a list of error codes, see Error codes.', example='Success'),
  data?: {
    createdTimestamp?: long(name='CreatedTimestamp', description='The timestamp that indicates when the event rule was created.', example='1607071602000'),
    description?: string(name='Description', description='The description of the event rule.', example='test'),
    eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='Housekeeping-Bus'),
    filterPattern?: string(name='FilterPattern', description='The event pattern, in JSON format. Valid values: stringEqual and stringExpression. You can specify up to five expressions in the map data structure in each field.

You can specify up to five expressions in the map data structure in each field.', example='{\\\\"source\\\\":[\\\\"acs.oss\\\\"],\\\\"type\\\\":[\\\\"oss:BucketQueried:GetBucketStat\\\\"]}'),
    ruleARN?: string(name='RuleARN', description='The Alibaba Cloud Resource Name (ARN) of the event rule.', example='acs:eventbridge:cn-hangzhou:123456789098****:eventbus/default/rule/myRule3'),
    ruleName?: string(name='RuleName', description='The name of the event rule.', example='ramrolechange-fc'),
    status?: string(name='Status', description='The status of the event rule. Valid values: ENABLE (default): The event rule is enabled. DISABLE: The event rule is disabled.', example='ENABLE'),
    targets?: [ 
      {
        concurrentConfig?: {
          concurrency?: long(name='Concurrency'),
        }(name='ConcurrentConfig'),
        deadLetterQueue?: {
          arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the dead-letter queue.', example='acs:eventbridge:cn-hangzhou:164901546557****:eventbus/my-event-bus/eventsource/myRocketMQ.source'),
        }(name='DeadLetterQueue', description='The dead-letter queue.'),
        detailMap?: map[string]any(name='DetailMap', description='The information about the event target.'),
        endpoint?: string(name='Endpoint', description='The endpoint of the event target.', example='acs:mns:cn-hangzhou:123456789098****:queues/myqueue'),
        errorsTolerance?: string(name='ErrorsTolerance', description='The fault tolerance policy. Valid values: ALL: Fault tolerance is allowed. If an error occurs in an event, event processing is not blocked. If the event fails to be sent after the maximum number of retries specified by the retry policy is reached, the event is delivered to the dead-letter queue or discarded based on your configurations. NONE: Fault tolerance is not allowed. If an error occurs in an event and the event fails to be sent after the maximum number of retries specified by the retry policy is reached, event processing is blocked.', example='ALL'),
        id?: string(name='Id', description='The ID of the event target.', example='1'),
        paramList?: [ 
          {
            form?: string(name='Form', description='The method that is used to deliver events to the event target. For more information, see [Limits](https://help.aliyun.com/document_detail/163289.html).', example='TEMPLATE'),
            resourceKey?: string(name='ResourceKey', description='The resource key of the event target. For more information, see [Limits](https://help.aliyun.com/document_detail/163289.html).', example='body'),
            template?: string(name='Template', description='The template based on which events are delivered to the event target.', example='The value of ${key} is ${value}!'),
            value?: string(name='Value', description='The event target.', example='{\\\\"key\\\\"=\\\\"value\\\\"}'),
          }
        ](name='ParamList', description='The parameters that are configured for the event target.'),
        pushRetryStrategy?: string(name='PushRetryStrategy', description='The retry policy that is used to push failed events. Valid values: BACKOFF_RETRY: backoff retry. A failed event can be retried up to three times. The interval between two consecutive retries is a random value between 10 seconds and 20 seconds. EXPONENTIAL_DECAY_RETRY: exponential decay retry. A failed event can be retried up to 176 times. The interval between two consecutive retries exponentially increases to a maximum of 512 seconds. The total retry time is 1 day. The specific retry intervals are 1, 2, 4, 8, 16, 32, 64, 128, 256, and 512 seconds. The interval of 512 seconds is used for 167 retries.', example='BACKOFF_RETRY'),
        pushSelector?: string(name='PushSelector', description='The transformer that is used to push events.', example='MATCHED_EVENT'),
        type?: string(name='Type', description='The type of the event target. For more information, see [Event target parameters](https://help.aliyun.com/document_detail/185887.html).', example='acs.mns.queue'),
      }
    ](name='Targets', description='The event targets.'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='The event rule not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='2BC1857D-E633-5E79-B2C2-43EF5F7730D8'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. If the operation is successful, the value true is returned.', example='true'),
}

model GetRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRuleResponseBody(name='body'),
}

/**
 * @summary Queries the details of an event rule.
 *
 * @description You can call this API operation to query the details of an event rule.
 *
 * @param request GetRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRuleResponse
 */
async function getRuleWithOptions(request: GetRuleRequest, runtime: Util.RuntimeOptions): GetRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of an event rule.
 *
 * @description You can call this API operation to query the details of an event rule.
 *
 * @param request GetRuleRequest
 * @return GetRuleResponse
 */
async function getRule(request: GetRuleRequest): GetRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRuleWithOptions(request, runtime);
}

model ListAliyunOfficialEventSourcesResponseBody = {
  code?: string(name='Code', description='The response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For a list of error codes, see Error codes.', example='Success'),
  data?: {
    eventSourceList?: [ 
      {
        arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the event bus.', example='acs:eventbridge:cn-hangzhou:SYSTEM:eventsource/acs.aliyuncvc'),
        ctime?: float(name='Ctime', description='The time when the event source was created. Unit: milliseconds.', example='1607071602000'),
        description?: string(name='Description', description='The description of the event source.'),
        eventBusName?: string(name='EventBusName', description='The name of the event source to which the event type belongs.', example='acs.aliyuncvc'),
        eventTypes?: [ 
          {
            eventSourceName?: string(name='EventSourceName', description='The name of the event source.', example='name'),
            groupName?: string(name='GroupName', description='The name of the group to which the event type belongs.', example='aliyuncvc:MeetingEvent'),
            name?: string(name='Name', description='The full name of the event type.', example='aliyuncvc:MeetingEvent:MeetingStateEvent'),
            shortName?: string(name='ShortName', description='The short name of the event type.', example='MeetingStateEvent'),
          }
        ](name='EventTypes', description='The event types.'),
        fullName?: string(name='FullName', description='The full name of the event source.', example='E-MapReduce'),
        name?: string(name='Name', description='The name of the event source.', example='acs.aliyuncvc'),
        status?: string(name='Status', description='The status of the event source. Valid value: Activated.', example='Activated'),
        type?: string(name='Type', description='The type of the event source.', example='1'),
      }
    ](name='EventSourceList', description='The event sources.'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='InvalidArgument'),
  requestId?: string(name='RequestId', description='The request ID.', example='5f80e9b3-98d5-4f51-8412-c758818a03e4'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. If the operation is successful, the value true is returned.', example='true'),
}

model ListAliyunOfficialEventSourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAliyunOfficialEventSourcesResponseBody(name='body'),
}

/**
 * @summary Queries all Alibaba Cloud service event sources.
 *
 * @description You can call this API operation to query all Alibaba Cloud service event sources.
 *
 * @param request ListAliyunOfficialEventSourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAliyunOfficialEventSourcesResponse
 */
async function listAliyunOfficialEventSourcesWithOptions(runtime: Util.RuntimeOptions): ListAliyunOfficialEventSourcesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListAliyunOfficialEventSources',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all Alibaba Cloud service event sources.
 *
 * @description You can call this API operation to query all Alibaba Cloud service event sources.
 *
 * @return ListAliyunOfficialEventSourcesResponse
 */
async function listAliyunOfficialEventSources(): ListAliyunOfficialEventSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAliyunOfficialEventSourcesWithOptions(runtime);
}

model ListApiDestinationsRequest {
  apiDestinationNamePrefix?: string(name='ApiDestinationNamePrefix', description='The prefix of the API destination name.', example='api-demo'),
  connectionName?: string(name='ConnectionName', description='The connection name.', example='connection-name'),
  maxResults?: long(name='MaxResults', description='The maximum number of entries to be returned in a call. You can use this parameter and NextToken to implement paging.

*   Default value: 10.', example='10'),
  nextToken?: string(name='NextToken', description='If you set Limit and excess return values exist, this parameter is returned.

*   Default value: 0.', example='0'),
}

model ListApiDestinationsResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  data?: {
    apiDestinations?: [ 
      {
        apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination.', example='api-destination-2'),
        connectionName?: string(name='ConnectionName', description='The connection name.', example='connection-name'),
        description?: string(name='Description', description='The description of the connection.', example='demo'),
        gmtCreate?: long(name='GmtCreate', description='The time when the API destination was created.', example='1665223213000'),
        httpApiParameters?: {
          endpoint?: string(name='Endpoint', description='The endpoint of the API destination.', example='http://127.0.0.1:8001/api'),
          method?: string(name='Method', description='The HTTP request method. Valid values:

- POST

- GET

- DELETE

- PUT

- HEAD

- TRACE

- PATCH', example='POST'),
        }(name='HttpApiParameters', description='The request parameters that are configured for the API destination.'),
      }
    ](name='ApiDestinations', description='The API destinations.'),
    maxResults?: float(name='MaxResults', description='The maximum number of entries returned per page.', example='10'),
    nextToken?: string(name='NextToken', description='If excess return values exist, this parameter is returned.', example='1'),
    total?: float(name='Total', description='The total number of entries returned.', example='2'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message. If the request is successful, success is returned. If the request failed, an error code is returned.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='96D7C0AB-DCE5-5E82-96B8-4725E1706BB1'),
}

model ListApiDestinationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListApiDestinationsResponseBody(name='body'),
}

/**
 * @summary Queries a list of API destinations.
 *
 * @description You can use this API operation to query a list of API destinations.
 *
 * @param request ListApiDestinationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListApiDestinationsResponse
 */
async function listApiDestinationsWithOptions(request: ListApiDestinationsRequest, runtime: Util.RuntimeOptions): ListApiDestinationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apiDestinationNamePrefix)) {
    query['ApiDestinationNamePrefix'] = request.apiDestinationNamePrefix;
  }
  if (!Util.isUnset(request.connectionName)) {
    query['ConnectionName'] = request.connectionName;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListApiDestinations',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of API destinations.
 *
 * @description You can use this API operation to query a list of API destinations.
 *
 * @param request ListApiDestinationsRequest
 * @return ListApiDestinationsResponse
 */
async function listApiDestinations(request: ListApiDestinationsRequest): ListApiDestinationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApiDestinationsWithOptions(request, runtime);
}

model ListConnectionsRequest {
  connectionNamePrefix?: string(name='ConnectionNamePrefix', description='The key word that you specify to query connections. Connections can be queried by prefixes.', example='connection-name'),
  maxResults?: long(name='MaxResults', description='The maximum number of entries to be returned in a single call. You can use this parameter and the NextToken parameter to implement paging.

*   Default value: 10.', example='10'),
  nextToken?: string(name='NextToken', description='If you set the Limit parameter and excess return values exist, this parameter is returned.

*   Default value: 0.', example='0'),
}

model ListConnectionsResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The value Success indicates that the request is successful.', example='Success'),
  data?: {
    connections?: [ 
      {
        authParameters?: {
          apiKeyAuthParameters?: {
            apiKeyName?: string(name='ApiKeyName', description='The API key.', example='Token'),
            apiKeyValue?: string(name='ApiKeyValue', description='The value of the API key.', example='asdkjnqkwejooa'),
          }(name='ApiKeyAuthParameters', description='The parameters that are configured for API key authentication.'),
          authorizationType?: string(name='AuthorizationType', description='The authentication type. Valid values:

- BASIC_AUTH: basic authentication.

- API_KEY_AUTH: API key authentication.

- OAUTH_AUTH: OAuth authentication.', example='BASIC_AUTH'),
          basicAuthParameters?: {
            password?: string(name='Password', description='The password for basic authentication.', example='admin'),
            username?: string(name='Username', description='The username for basic authentication.', example='admin'),
          }(name='BasicAuthParameters', description='The parameters that are configured for basic authentication.'),
          OAuthParameters?: {
            authorizationEndpoint?: string(name='AuthorizationEndpoint', description='The endpoint that is used to obtain the OAuth token.', example='http://localhost:8080/oauth/token'),
            clientParameters?: {
              clientID?: string(name='ClientID', description='The client ID.', example='ClientID'),
              clientSecret?: string(name='ClientSecret', description='The client key secret of the application.', example='ClientSecret'),
            }(name='ClientParameters', description='The parameters that are configured for the client.'),
            httpMethod?: string(name='HttpMethod', description='The HTTP request method. Valid values:

- GET

- POST

- HEAD', example='POST'),
            OAuthHttpParameters?: {
              bodyParameters?: [ 
                {
                  isValueSecret?: string(name='IsValueSecret', description='Indicates whether authentication is enabled.', example='false'),
                  key?: string(name='Key', description='The key in the request body.', example='name'),
                  value?: string(name='Value', description='The value of the key in the request body.', example='demo'),
                }
              ](name='BodyParameters', description='The parameters that are configured for the request.'),
              headerParameters?: [ 
                {
                  isValueSecret?: string(name='IsValueSecret', description='Indicates whether authentication is enabled.', example='false'),
                  key?: string(name='Key', description='The key in the request header.', example='name'),
                  value?: string(name='Value', description='The value of the key in the request header.', example='demo'),
                }
              ](name='HeaderParameters', description='The parameters that are configured for the request header.'),
              queryStringParameters?: [ 
                {
                  isValueSecret?: string(name='IsValueSecret', description='Indicates whether authentication is enabled.', example='false'),
                  key?: string(name='Key', description='The key in the request path.', example='name'),
                  value?: string(name='Value', description='The value of the key in the request path.', example='demo'),
                }
              ](name='QueryStringParameters', description='The parameters that are configured for the request path.'),
            }(name='OAuthHttpParameters', description='The request parameters for OAuth authentication.'),
          }(name='OAuthParameters', description='The parameters that are configured for OAuth authentication.'),
        }(name='AuthParameters', description='The parameters that are configured for authentication.'),
        connectionName?: string(name='ConnectionName', description='The connection name.', example='connection-name'),
        description?: string(name='Description', description='The connection description.', example='The description of the connection.'),
        gmtCreate?: long(name='GmtCreate', description='The time when the connection was created.', example='1592838994234'),
        id?: long(name='Id', description='The connection ID.', example='1141093'),
        networkParameters?: {
          networkType?: string(name='NetworkType', description='The network type. Valid values:PublicNetwork and PrivateNetwork.', example='PublicNetwork'),
          securityGroupId?: string(name='SecurityGroupId', description='The security group ID.', example='eb-167adad548759-security_grop/sg-bp1addad26peuh9qh9rtyb'),
          vpcId?: string(name='VpcId', description='The virtual private cloud (VPC) ID.', example='eb-test/vpc-bp1symadadwnwgmqud'),
          vswitcheId?: string(name='VswitcheId', description='The vSwitch ID.', example='vsw-bp1iu4x7aeradadown1og8,vsw-bp193sqmadadlaszpeqbt2c'),
        }(name='NetworkParameters'),
      }
    ](name='Connections', description='The value of the key in the request path.'),
    maxResults?: float(name='MaxResults', description='The number of entries returned per page.', example='10'),
    nextToken?: string(name='NextToken', description='If excess return values exist, this parameter is returned.', example='0'),
    total?: float(name='Total', description='The total number of entries returned.', example='1'),
  }(name='Data', description='The information about the connections returned.'),
  message?: string(name='Message', description='The message returned.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use the ID to troubleshoot issues.', example='E3619976-8714-5D88-BBA2-6983D798A8BB'),
}

model ListConnectionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListConnectionsResponseBody(name='body'),
}

/**
 * @summary Queries connections.
 *
 * @description You can call this API operation to query connections.
 *
 * @param request ListConnectionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListConnectionsResponse
 */
async function listConnectionsWithOptions(request: ListConnectionsRequest, runtime: Util.RuntimeOptions): ListConnectionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.connectionNamePrefix)) {
    body['ConnectionNamePrefix'] = request.connectionNamePrefix;
  }
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListConnections',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries connections.
 *
 * @description You can call this API operation to query connections.
 *
 * @param request ListConnectionsRequest
 * @return ListConnectionsResponse
 */
async function listConnections(request: ListConnectionsRequest): ListConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConnectionsWithOptions(request, runtime);
}

model ListEventBusesRequest {
  limit?: int32(name='Limit', description='The maximum number of entries to be returned in a call. You can use this parameter and NextToken to implement paging. Note: Up to 100 entries can be returned in a call.', example='10'),
  namePrefix?: string(name='NamePrefix', description='The prefix of the names of the event buses that you want to query.', example='My'),
  nextToken?: string(name='NextToken', description='If you set Limit and excess return values exist, this parameter is returned.', example='10'),
}

model ListEventBusesResponseBody = {
  code?: string(name='Code', description='The returned HTTP status code. The HTTP status code 200 indicates that the request is successful.', example='200'),
  data?: {
    eventBuses?: [ 
      {
        createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates when the event bus was created.', example='1607071602000'),
        description?: string(name='Description', description='The description of the queried event bus.', example='bus_description'),
        eventBusARN?: string(name='EventBusARN', description='The Alibaba Cloud Resource Name (ARN) of the queried event bus.', example='acs:eventbridge:cn-hangzhou:123456789098***:eventbus/default'),
        eventBusName?: string(name='EventBusName', description='The name of the queried event bus.', example='default'),
      }
    ](name='EventBuses', description='The timestamp that indicates when the event bus was created.'),
    nextToken?: string(name='NextToken', description='If excess return values exist, this parameter is returned.', example='10'),
    total?: int32(name='Total', description='The total number of entries.', example='2'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='InvalidArgument'),
  requestId?: string(name='RequestId', description='The request ID.', example='D1DCF64A-3F2C-5323-ADCB-3F4DF30FAD2D'),
  success?: boolean(name='Success', description='Indicates whether the event buses are successfully queried. Valid values: true and false.', example='true'),
}

model ListEventBusesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEventBusesResponseBody(name='body'),
}

/**
 * @summary Queries all event buses.
 *
 * @description You can call this API operation to query all event buses.
 *
 * @param request ListEventBusesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListEventBusesResponse
 */
async function listEventBusesWithOptions(request: ListEventBusesRequest, runtime: Util.RuntimeOptions): ListEventBusesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namePrefix)) {
    query['NamePrefix'] = request.namePrefix;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEventBuses',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all event buses.
 *
 * @description You can call this API operation to query all event buses.
 *
 * @param request ListEventBusesRequest
 * @return ListEventBusesResponse
 */
async function listEventBuses(request: ListEventBusesRequest): ListEventBusesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventBusesWithOptions(request, runtime);
}

model ListEventStreamingsRequest {
  limit?: int32(name='Limit', description='The maximum number of entries to be returned in a call. You can use this parameter and NextToken to implement paging. A maximum of 100 entries can be returned in a call.', example='10'),
  namePrefix?: string(name='NamePrefix', description='The name of the event stream that you want to query.', example='name'),
  nextToken?: string(name='NextToken', description='If you configure Limit and excess return values exist, this parameter is returned.', example='10'),
  sinkArn?: string(name='SinkArn', description='The ARN of the event target.', example='acs:fc:cn-hangzhou:118609547428****:services/fw1.LATEST/functions/log1'),
  sourceArn?: string(name='SourceArn', description='The Alibaba Cloud Resource Name (ARN) of the event source.'),
}

model ListEventStreamingsResponseBody = {
  code?: string(name='Code', description='The response code. Valid values:

Success: The request is successful.

Other codes: The request failed. For more information about error codes, see Error codes.', example='Success'),
  data?: {
    eventStreamings?: [ 
      {
        description?: string(name='Description', description='The description of the event stream.', example='demo'),
        eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream.', example='name'),
        filterPattern?: string(name='FilterPattern', description='The rule that is used to filter events. If you leave this parameter empty, all events are matched.'),
        runOptions?: {
          batchWindow?: {
            countBasedWindow?: int32(name='CountBasedWindow', description='The maximum number of events that are allowed in the batch window. When this threshold is reached, data in the window is pushed to the downstream service. If multiple batch windows exist, data is pushed if triggering conditions are met in one of the windows.', example='100'),
            timeBasedWindow?: int32(name='TimeBasedWindow', description='The maximum period of time during which events are allowed in the batch window. Unit: seconds. When this threshold is reached, data in the window is pushed to the downstream service. If multiple batch windows exist, data is pushed if triggering conditions are met in one of the windows.', example='10'),
          }(name='BatchWindow', description='The batch window.'),
          deadLetterQueue?: {
            arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the dead-letter queue.', example='acs:ram::1597871211794192:role/aliyunsaedefaultrole'),
          }(name='DeadLetterQueue', description='Indicates whether dead-letter queues are enabled. By default, dead-letter queues are disabled. Messages that fail to be pushed are discarded after the maximum number of retries that is specified by the retry policy is reached.'),
          errorsTolerance?: string(name='ErrorsTolerance', description='The exception tolerance policy. Valid values: NONE and ALL.', example='ALL'),
          logDelivery?: {
            kafkaLogParameters?: [ 
              {
                endpoint?: string(name='Endpoint'),
                instanceId?: string(name='InstanceId'),
                topic?: string(name='Topic'),
              }
            ](name='KafkaLogParameters'),
            SLSLogParameters?: [ 
              {
                logstoreName?: string(name='LogstoreName'),
                projectName?: string(name='ProjectName'),
              }
            ](name='SLSLogParameters'),
          }(name='LogDelivery'),
          maximumTasks?: int32(name='MaximumTasks', description='The number of concurrent threads.', example='2'),
          network?: {
            securityGroupId?: string(name='SecurityGroupId'),
            vSwitchIds?: [ string ](name='VSwitchIds'),
            vpcId?: string(name='VpcId'),
          }(name='Network'),
          resourceSpec?: {
            resources?: [ 
              {
                type?: string(name='Type'),
                value?: int32(name='Value'),
              }
            ](name='Resources'),
          }(name='ResourceSpec'),
          retryStrategy?: {
            maximumEventAgeInSeconds?: float(name='MaximumEventAgeInSeconds', description='The maximum timeout period for a retry.', example='512'),
            maximumRetryAttempts?: float(name='MaximumRetryAttempts', description='The maximum number of retries.', example='2'),
            pushRetryStrategy?: string(name='PushRetryStrategy', description='Valid values: BACKOFFRETRY and EXPONENTIALDECAY_RETRY.', example='EXPONENTIALDECAY_RETRY'),
          }(name='RetryStrategy', description='The retry policy that is used if events fail to be pushed.'),
          roleName?: string(name='RoleName'),
          scaledObject?: {
            maxReplicaCount?: int32(name='MaxReplicaCount'),
            minReplicaCount?: int32(name='MinReplicaCount'),
            triggers?: [ 
              {
                metadata?: {
                  type?: string(name='Type'),
                  value?: int32(name='Value'),
                }(name='Metadata'),
                type?: string(name='Type'),
              }
            ](name='Triggers'),
          }(name='ScaledObject'),
        }(name='RunOptions', description='The parameters that are returned for the runtime environment.'),
        sink?: {
          sinkCustomizedKafkaConnectorParameters?: {
            connectorPackageUrl?: string(name='ConnectorPackageUrl'),
            connectorParameters?: {
              config?: map[string]any(name='Config'),
              name?: string(name='Name'),
            }(name='ConnectorParameters'),
            workerParameters?: map[string]any(name='WorkerParameters'),
          }(name='SinkCustomizedKafkaConnectorParameters'),
          sinkCustomizedKafkaParameters?: {
            instanceId?: string(name='InstanceId'),
          }(name='SinkCustomizedKafkaParameters'),
          sinkDataHubParameters?: {
            body?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Body'),
            project?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Project'),
            roleName?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='RoleName'),
            topic?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Topic'),
            topicSchema?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='TopicSchema'),
            topicType?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='TopicType'),
          }(name='SinkDataHubParameters'),
          sinkFcParameters?: {
            body?: {
              form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
              template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
            }(name='Body', description='The message body that is delivered to Function Compute.'),
            concurrency?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The delivery concurrency. Minimum value: 1.', example='1'),
            }(name='Concurrency', description='The delivery concurrency. Minimum value: 1.'),
            functionName?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The function name.', example='mFunction'),
            }(name='FunctionName', description='The function name.'),
            invocationType?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The invocation mode. Valid values:

*   Sync: the synchronous mode
*   Async: the asynchronous mode', example='Async'),
            }(name='InvocationType', description='The invocation mode. Valid values:

*   Sync: the synchronous mode
*   Async: the asynchronous mode'),
            qualifier?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The alias of the service to which the function belongs.', example='LATEST'),
            }(name='Qualifier', description='The alias of the service to which the function belongs.'),
            serviceName?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The service name.', example='myService'),
            }(name='ServiceName', description='The service name.'),
          }(name='SinkFcParameters', description='The parameters that are returned if Function Compute is specified as the event target.'),
          sinkFnfParameters?: {
            executionName?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='The template based on which events are transformed.', example='None'),
              value?: string(name='Value', description='The execution name.', example='123'),
            }(name='ExecutionName', description='The execution name.'),
            flowName?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='The template based on which events are transformed.', example='None'),
              value?: string(name='Value', description='The flow name.', example='test-streaming-fnf'),
            }(name='FlowName', description='The flow name.'),
            input?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='The template based on which events are transformed.', example='None'),
              value?: string(name='Value', description='The input information of the execution.', example='123'),
            }(name='Input', description='The input information of the execution.'),
            roleName?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='The template based on which events are transformed.', example='None'),
              value?: string(name='Value', description='The role name.', example='Al****FNF-x****'),
            }(name='RoleName', description='The role name.'),
          }(name='SinkFnfParameters', description='The parameters that are returned if Serverless Workflow is specified as the event target.'),
          sinkKafkaParameters?: {
            acks?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The ACK mode.

*   If this parameter is set to 0, no response is returned from the broker. In this mode, the performance is high, but the risk of data loss is also high.
*   If this parameter is set to 1, a response is returned when data is written to the leader. In this mode, the performance and the risk of data loss are moderate. Data loss may occur if a failure occurs on the leader.
*   If this parameter is set to all, a response is returned when data is written to the leader and synchronized to the followers. In this mode, the performance is low, but the risk of data loss is also low. Data loss occurs if the leader and the followers fail at the same time.', example='1'),
            }(name='Acks', description='The acknowledgment (ACK) mode.

*   If this parameter is set to 0, no response is returned from the broker. In this mode, the performance is high, but the risk of data loss is also high.
*   If this parameter is set to 1, a response is returned when data is written to the leader. In this mode, the performance and the risk of data loss are moderate. Data loss may occur if a failure occurs on the leader.
*   If this parameter is set to all, a response is returned when data is written to the leader and synchronized to the followers. In this mode, the performance is low, but the risk of data loss is also low. Data loss occurs if the leader and the followers fail at the same time.'),
            instanceId?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The ID of the Message Queue for Apache Kafka instance.', example='Defaut_1283278472_sadkj'),
            }(name='InstanceId', description='The ID of the Message Queue for Apache Kafka instance.'),
            key?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The message key.', example='key'),
            }(name='Key', description='The message key.'),
            topic?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The topic name.', example='topic'),
            }(name='Topic', description='The topic name.'),
            value?: {
              form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
              template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
            }(name='Value', description='The message body.'),
          }(name='SinkKafkaParameters', description='The parameters that are returned if Message Queue for Apache Kafka is specified as the event target.'),
          sinkMNSParameters?: {
            body?: {
              form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
              template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
            }(name='Body', description='The message body.'),
            isBase64Encode?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='Indicates that Base64 encoding is enabled.', example='true'),
            }(name='IsBase64Encode', description='Indicates whether Base64 encoding is enabled.'),
            queueName?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The name of the MNS queue.', example='MyQueue'),
            }(name='QueueName', description='The name of the MNS queue.'),
          }(name='SinkMNSParameters', description='The parameters that are returned if MNS is specified as the event target.'),
          sinkRabbitMQParameters?: {
            body?: {
              form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
              template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
            }(name='Body', description='The message body.'),
            exchange?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The name of the exchange on the Message Queue for RabbitMQ instance.', example='a_exchange'),
            }(name='Exchange', description='The exchange to which events are delivered. This parameter is returned only if TargetType is set to Exchange.'),
            instanceId?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The ID of the Message Queue for RabbitMQ instance.', example='si-296cd57939a1421b94ec'),
            }(name='InstanceId', description='The ID of the Message Queue for RabbitMQ instance.'),
            messageId?: {
              form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
              template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
            }(name='MessageId', description='The message ID.'),
            properties?: {
              form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
              template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
            }(name='Properties', description='The attributes that are used to filter messages.'),
            queueName?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The name of the queue on the Message Queue for RabbitMQ instance.', example='MyQueue'),
            }(name='QueueName', description='The queue to which events are delivered. This parameter is returned only if TargetType is set to Queue.'),
            routingKey?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The rule that is used to route messages.', example='housekeeping'),
            }(name='RoutingKey', description='The rule that is used to route messages. This parameter is returned only if TargetType is set to Exchange.'),
            targetType?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The type of the resource to which events are delivered. Valid values: Exchange and Queue.', example='Queue'),
            }(name='TargetType', description='The type of the resource to which events are delivered.'),
            virtualHostName?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The name of the vhost of the Message Queue for RabbitMQ instance.', example='rabbit-host'),
            }(name='VirtualHostName', description='The name of the vhost of the Message Queue for RabbitMQ instance.'),
          }(name='SinkRabbitMQParameters', description='The parameters that are returned if Message Queue for RabbitMQ is specified as the event target.'),
          sinkRocketMQParameters?: {
            body?: {
              form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
              template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
            }(name='Body', description='The message body.'),
            instanceId?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The ID of the Message Queue for Apache RocketMQ instance.', example='MQ_INST_164901546557****_BAAN****'),
            }(name='InstanceId', description='The parameters that are returned if Message Queue for Apache RocketMQ is specified as the event target.'),
            keys?: {
              form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
              template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
            }(name='Keys', description='The keys that are used to filter messages.'),
            properties?: {
              form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
              template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
            }(name='Properties', description='The attributes that are used to filter messages.'),
            tags?: {
              form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
              template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
            }(name='Tags', description='The tags that are used to filter messages.'),
            topic?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The name of the topic on the Message Queue for Apache RocketMQ instance.', example='topic'),
            }(name='Topic', description='The name of the topic on the Message Queue for Apache RocketMQ instance.'),
          }(name='SinkRocketMQParameters', description='Sink RocketMQ Parameters'),
          sinkSLSParameters?: {
            body?: {
              form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
              template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
            }(name='Body', description='The message body that is delivered to Log Service.'),
            contentSchema?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='ContentSchema'),
            contentType?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='ContentType'),
            logStore?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The Log Service Logstore.', example='test-logstore'),
            }(name='LogStore', description='The Log Service Logstore.'),
            project?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The Log Service project.', example='test-project'),
            }(name='Project', description='The Log Service project.'),
            roleName?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The role name. If you want to authorize EventBridge to use this role to read logs in Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the RAM console.', example='test-role'),
            }(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the RAM console.'),
            topic?: {
              form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
              template?: string(name='Template', description='None'),
              value?: string(name='Value', description='The name of the topic in which logs are stored. The topic corresponds to the topic reserved field in Log Service.', example='topic'),
            }(name='Topic', description='The name of the topic in which logs are stored. The topic corresponds to the topic reserved field in Log Service.'),
          }(name='SinkSLSParameters', description='Sink SLS Parameters'),
        }(name='Sink', description='The event target.'),
        source?: {
          sourceApacheKafkaParameters?: {
            bootstraps?: string(name='Bootstraps'),
            consumerGroup?: string(name='ConsumerGroup'),
            networkType?: string(name='NetworkType'),
            offsetReset?: string(name='OffsetReset'),
            saslMechanism?: string(name='SaslMechanism'),
            saslPassword?: string(name='SaslPassword'),
            saslUser?: string(name='SaslUser'),
            securityGroupId?: string(name='SecurityGroupId'),
            securityProtocol?: string(name='SecurityProtocol'),
            topic?: string(name='Topic'),
            vSwitchIds?: string(name='VSwitchIds'),
            valueDataType?: string(name='ValueDataType'),
            vpcId?: string(name='VpcId'),
          }(name='SourceApacheKafkaParameters'),
          sourceCustomizedKafkaConnectorParameters?: {
            connectorPackageUrl?: string(name='ConnectorPackageUrl'),
            connectorParameters?: {
              config?: map[string]any(name='Config'),
              name?: string(name='Name'),
            }(name='ConnectorParameters'),
            workerParameters?: map[string]any(name='WorkerParameters'),
          }(name='SourceCustomizedKafkaConnectorParameters'),
          sourceCustomizedKafkaParameters?: {
            instanceId?: string(name='InstanceId'),
          }(name='SourceCustomizedKafkaParameters'),
          sourceDTSParameters?: {
            brokerUrl?: string(name='BrokerUrl', description='The URL and port number of the change tracking instance.'),
            initCheckPoint?: string(name='InitCheckPoint', description='The consumer offset. It is the timestamp that indicates when the SDK client consumes the first data record.', example='1620962769'),
            password?: string(name='Password', description='The consumer group password.', example='123456'),
            sid?: string(name='Sid', description='The consumer group ID.', example='HG9'),
            taskId?: string(name='TaskId', description='The task ID.', example='1611b337285f44e2936a2c4170bbbb7f'),
            topic?: string(name='Topic', description='The name of the tracked topic on the change tracking instance.', example='TP_TEST_UNDERWRITE_ISSUE'),
            username?: string(name='Username', description='The consumer group username.', example='admin'),
          }(name='SourceDTSParameters', description='The parameters that are returned if Data Transmission Service (DTS) is specified as the event source.'),
          sourceKafkaParameters?: {
            consumerGroup?: string(name='ConsumerGroup', description='The ID of the consumer group that subscribes to the topic.', example='GID_TEST'),
            instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache Kafka instance.', example='bastionhost-cn-i7m2gwt7z1n'),
            network?: string(name='Network', description='The network type. Valid values: Default and PublicNetwork. Default value: Default. The value PublicNetwork indicates a VPC.', example='Default'),
            offsetReset?: string(name='OffsetReset', description='The offset.', example='latest'),
            regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for Apache Kafka instance resides.', example='cn-chengdu'),
            securityGroupId?: string(name='SecurityGroupId', description='The security group ID.', example='sg-5ud5f3p0rqqis69tpp8eho7cp'),
            topic?: string(name='Topic', description='The name of the topic on the Message Queue for Apache Kafka instance.', example='topic_empower_1642473600414'),
            vSwitchIds?: string(name='VSwitchIds', description='The vSwitch ID.', example='vsw-bp1rmi8rind7eo50cbied'),
            valueDataType?: string(name='ValueDataType'),
            vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-wz9ki1qdlx3cx5cbbhowf'),
          }(name='SourceKafkaParameters', description='The parameters that are returned if Message Queue for Apache Kafka is specified as the event source.'),
          sourceMNSParameters?: {
            isBase64Decode?: boolean(name='IsBase64Decode', description='Indicates whether Base64 encoding is enabled.', example='true'),
            queueName?: string(name='QueueName', description='The name of the MNS queue.', example='work4'),
            regionId?: string(name='RegionId', description='The ID of the region where the MNS queue resides.', example='cn-zhangjiakou'),
          }(name='SourceMNSParameters', description='The parameters that are returned if Message Service (MNS) is specified as the event source.'),
          sourceMQTTParameters?: {
            bodyDataType?: string(name='BodyDataType'),
            instanceId?: string(name='InstanceId', description='The ID of the Message Queue for MQTT instance.', example='bastionhost-cn-zvp27kcha1r'),
            regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for MQTT instance resides.', example='cn-qingdao'),
            topic?: string(name='Topic', description='The name of the topic on the Message Queue for MQTT instance.', example='migration_instance'),
          }(name='SourceMQTTParameters', description='The parameters that are returned if Message Queue for MQTT is specified as the event source.'),
          sourcePrometheusParameters?: {
            clusterId?: string(name='ClusterId'),
            dataType?: string(name='DataType'),
            labels?: string(name='Labels'),
            regionId?: string(name='RegionId'),
          }(name='SourcePrometheusParameters'),
          sourceRabbitMQParameters?: {
            instanceId?: string(name='InstanceId', description='The ID of the Message Queue for RabbitMQ instance.', example='dbaudit-cn-7mz2hqolc06'),
            queueName?: string(name='QueueName', description='The name of the queue on the Message Queue for RabbitMQ instance.', example='liuyang'),
            regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for RabbitMQ instance resides.', example='cn-zhangjiakou'),
            virtualHostName?: string(name='VirtualHostName', description='The name of the vhost of the Message Queue for RabbitMQ instance.', example='eb-connect'),
          }(name='SourceRabbitMQParameters', description='The parameters that are returned if Message Queue for RabbitMQ is specified as the event source.'),
          sourceRocketMQParameters?: {
            authType?: string(name='AuthType', description='The authentication method.', example='ACL'),
            bodyDataType?: string(name='BodyDataType'),
            filterSql?: string(name='FilterSql'),
            filterType?: string(name='FilterType'),
            groupID?: string(name='GroupID', description='The ID of the group on the Message Queue for Apache RocketMQ instance.', example='GID_group1'),
            instanceEndpoint?: string(name='InstanceEndpoint', description='The instance endpoint.', example='registry-vpc.cn-hangzhou.aliyuncs.com'),
            instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ instance.', example='i-f8zbher64dlm58plyfte'),
            instanceNetwork?: string(name='InstanceNetwork', description='The network type of the instance. Valid values:

*   PublicNetwork
*   PrivateNetwork', example='PublicNetwork'),
            instancePassword?: string(name='InstancePassword', description='The instance password.', example='123'),
            instanceSecurityGroupId?: string(name='InstanceSecurityGroupId', description='The security group ID of the instance.', example='sg-m5edtu24f12345****'),
            instanceType?: string(name='InstanceType', description='The instance type.', example='2'),
            instanceUsername?: string(name='InstanceUsername', description='The instance username.', example='admin**'),
            instanceVSwitchIds?: string(name='InstanceVSwitchIds', description='The vSwitch ID of the instance.', example='vsw-m5ev8asdc6h123456****'),
            instanceVpcId?: string(name='InstanceVpcId', description='The virtual private cloud (VPC) ID.', example='vpc-bp1a4gmlk31hy***l3ss'),
            network?: string(name='Network'),
            offset?: string(name='Offset', description='The consumer offset of the message. Valid values: CONSUMEFROMLASTOFFSET: Messages are consumed from the latest offset. CONSUMEFROMFIRSTOFFSET: Messages are consumed from the earliest offset. CONSUMEFROMTIMESTAMP: Messages are consumed from the offset at the specified point in time.', example='CONSUMEFROMTIMESTAMP'),
            regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for Apache RocketMQ instance resides.', example='cn-chengdu'),
            securityGroupId?: string(name='SecurityGroupId'),
            tag?: string(name='Tag', description='The tag that is used to filter messages.', example='v1'),
            timestamp?: long(name='Timestamp', description='The timestamp that indicates the time from which messages are consumed. This parameter is valid only if you set Offset to CONSUMEFROMTIMESTAMP.', example='1670742074043'),
            topic?: string(name='Topic', description='The topic in which messages are stored.', example='topic_add_anima'),
            vSwitchIds?: string(name='VSwitchIds'),
            vpcId?: string(name='VpcId'),
          }(name='SourceRocketMQParameters', description='Source RocketMQ Parameters'),
          sourceSLSParameters?: {
            consumePosition?: string(name='ConsumePosition', description='The consumer offset. The value begin indicates the earliest offset, and the value end indicates the latest offset. You can also specify a time in seconds to start message consumption.', example='begin'),
            consumerGroup?: string(name='ConsumerGroup', description='The ID of the consumer group that subscribes to the topic.', example='go-dts-shelf-group'),
            logStore?: string(name='LogStore', description='The Log Service Logstore.', example='waf-logstore'),
            project?: string(name='Project', description='The Log Service project.', example='dmmzk'),
            roleName?: string(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the Resource Access Management (RAM) console.', example='testRole'),
          }(name='SourceSLSParameters', description='The parameters that are returned if Log Service is specified as the event source.'),
        }(name='Source', description='The event provider, which is also known as the event source.'),
        status?: string(name='Status', description='The status of the event stream that is returned.', example='RUNNING'),
        transforms?: [ 
          {
            arn?: string(name='Arn'),
          }
        ](name='Transforms'),
      }
    ](name='EventStreamings', description='The event streams.'),
    nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists. You must specify the pagination token in the next request.', example='177'),
    total?: int32(name='Total', description='The total number of records.', example='10'),
  }(name='Data', description='The information about the event streams.'),
  message?: string(name='Message', description='The returned error message.', example='The event streaming [xxxx] not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='283FF852-C4B8-58C9-9777-F88A5A16A79F'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. The value true indicates that the request is successful.', example='true'),
}

model ListEventStreamingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEventStreamingsResponseBody(name='body'),
}

/**
 * @summary Queries event streams.
 *
 * @description You can call this API operation to query event streams.
 *
 * @param request ListEventStreamingsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListEventStreamingsResponse
 */
async function listEventStreamingsWithOptions(request: ListEventStreamingsRequest, runtime: Util.RuntimeOptions): ListEventStreamingsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namePrefix)) {
    body['NamePrefix'] = request.namePrefix;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.sinkArn)) {
    body['SinkArn'] = request.sinkArn;
  }
  if (!Util.isUnset(request.sourceArn)) {
    body['SourceArn'] = request.sourceArn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListEventStreamings',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries event streams.
 *
 * @description You can call this API operation to query event streams.
 *
 * @param request ListEventStreamingsRequest
 * @return ListEventStreamingsResponse
 */
async function listEventStreamings(request: ListEventStreamingsRequest): ListEventStreamingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventStreamingsWithOptions(request, runtime);
}

model ListRulesRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='default'),
  limit?: int32(name='Limit', description='The maximum number of entries to be returned in a single call. You can use this parameter and the NextToken parameter to implement paging. A maximum of 100 entries can be returned in a single call.', example='50'),
  nextToken?: string(name='NextToken', description='If you set the Limit parameter and excess return values exist, this parameter is returned.', example='1000'),
  ruleNamePrefix?: string(name='RuleNamePrefix', description='The prefix of the rule name.', example='test'),
}

model ListRulesResponseBody = {
  code?: string(name='Code', description='The error code. The value Success indicates that the request is successful.', example='Success'),
  data?: {
    nextToken?: string(name='NextToken', description='If excess return values exist, this parameter is returned.', example='1000'),
    rules?: [ 
      {
        createdTimestamp?: long(name='CreatedTimestamp', description='The creation timestamp.', example='1607071602000'),
        description?: string(name='Description', description='The rule description.', example='demo'),
        detailMap?: map[string]any(name='DetailMap', description='The details of the event rule.'),
        eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='demo'),
        filterPattern?: string(name='FilterPattern', description='The event pattern, in JSON format. Valid values: stringEqual pattern stringExpression pattern Each field can have a maximum of five expressions in the map data structure.

Each field can have a maximum of five expressions in the map data structure.', example='{\\\\"source\\\\":[\\\\"acs.oss\\\\"],\\\\"type\\\\":[\\\\"oss:BucketQueried:GetBucketStat\\\\"]}'),
        ruleARN?: string(name='RuleARN', description='The Alibaba Cloud Resource Name (ARN) of the rule.', example='acs:eventbridge:cn-hangzhou:123456789098****:eventbus/default/rule/myRule3'),
        ruleName?: string(name='RuleName', description='The name of the event rule.', example='tf-testacc-rule'),
        status?: string(name='Status', description='The status of the event rule. Valid values: ENABLE: The event rule is enabled. It is the default state of the event rule. DISABLE: The event rule is disabled.', example='ENABLE'),
        targets?: [ 
          {
            endpoint?: string(name='Endpoint', description='The endpoint of the event target.', example='acs:mns:cn-hangzhou:123456789098****:queues/myqueue'),
            errorsTolerance?: string(name='ErrorsTolerance', example='ALL'),
            id?: string(name='Id', description='The ID of the custom event target.', example='177'),
            pushSelector?: string(name='PushSelector', description='The transformer that is used to push events.', example='MATCHED_EVENT'),
            type?: string(name='Type', description='The type of the event target. For more information, see [Event target parameters.](https://www.alibabacloud.com/help/en/eventbridge/latest/event-target-parameters)', example='acs.mns.queue'),
          }
        ](name='Targets', description='The event targets.'),
      }
    ](name='Rules', description='The rules.'),
    total?: int32(name='Total', description='The total number of entries.', example='6'),
  }(name='Data', description='The data returned.'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='Specified parameter Limit is not valid.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C7043799-F4DA-5290-9249-97C359876D97'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: true and false.', example='true'),
}

model ListRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRulesResponseBody(name='body'),
}

/**
 * @summary Queries all rules of an event bus.
 *
 * @description You can call this API operation to query all rules of an event bus.
 *
 * @param request ListRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRulesResponse
 */
async function listRulesWithOptions(request: ListRulesRequest, runtime: Util.RuntimeOptions): ListRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ruleNamePrefix)) {
    query['RuleNamePrefix'] = request.ruleNamePrefix;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRules',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all rules of an event bus.
 *
 * @description You can call this API operation to query all rules of an event bus.
 *
 * @param request ListRulesRequest
 * @return ListRulesResponse
 */
async function listRules(request: ListRulesRequest): ListRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRulesWithOptions(request, runtime);
}

model ListTargetsRequest {
  arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the event rule.', example='acs:fc:cn-hangzhou:118609547428****:services/fc-connector.a1/functions/event'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='my-event-bus'),
  limit?: int32(name='Limit', description='The maximum number of returned entries in a call.', example='10'),
  nextToken?: string(name='NextToken', description='If you configure Limit and excess return values exist, this parameter is returned.', example='0'),
  ruleName?: string(name='RuleName', description='The name of the event rule.', example='tf-testacc-rule'),
}

model ListTargetsResponseBody = {
  code?: string(name='Code', description='The returned response code. Valid values:

*   Success: The request is successful.
*   Other codes: The request failed. For a list of error codes, see Error codes.', example='Success'),
  data?: {
    nextToken?: string(name='NextToken', description='If excess return values exist, this parameter is returned.', example='1'),
    targets?: [ 
      {
        endpoint?: string(name='Endpoint', description='The endpoint of the event target.', example='acs:fc:cn-hangzhou:123456789098****:services/guide.LATEST/functions/HelloFC'),
        errorsTolerance?: string(name='ErrorsTolerance'),
        eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='sls-beijing-one1-tf'),
        id?: string(name='Id', description='The ID of the event target.', example='1453'),
        paramList?: [ 
          {
            form?: string(name='Form', description='The format that is used by the event target parameter.', example='TEMPLATE'),
            resourceKey?: string(name='ResourceKey', description='The resource parameter of the event target.', example='body'),
            template?: string(name='Template', description='The template that is used by the event target parameter.', example='The value of ${key} is ${value}!'),
            value?: string(name='Value', description='The value of the event target parameter.', example='{\\\\"key\\\\"=\\\\"value\\\\"}'),
          }
        ](name='ParamList', description='The parameters that are configured for the event target.'),
        ruleName?: string(name='RuleName', description='The name of the event rule.', example='rule-uKAK2'),
        type?: string(name='Type', description='The type of the event target. For more information, see [Event target parameters](https://help.aliyun.com/document_detail/183698.html).', example='acs.fc.function'),
      }
    ](name='Targets', description='The event targets.'),
    total?: int32(name='Total', description='The total number of entries.', example='18'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='EventRuleNotExisted'),
  requestId?: string(name='RequestId', description='The request ID.', example='5DAF96FB-A4B6-548C-B999-0BFDCB2261B9'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   true
*   false', example='true'),
}

model ListTargetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTargetsResponseBody(name='body'),
}

/**
 * @summary Queries all event targets of an event rule.
 *
 * @param request ListTargetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTargetsResponse
 */
async function listTargetsWithOptions(request: ListTargetsRequest, runtime: Util.RuntimeOptions): ListTargetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.arn)) {
    query['Arn'] = request.arn;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTargets',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all event targets of an event rule.
 *
 * @param request ListTargetsRequest
 * @return ListTargetsResponse
 */
async function listTargets(request: ListTargetsRequest): ListTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTargetsWithOptions(request, runtime);
}

model ListUserDefinedEventSourcesRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='testBus'),
  limit?: int32(name='Limit', description='The maximum number of entries to be returned in a call. You can use this parameter and NextToken to implement paging. Note: Up to 100 entries can be returned in a call.', example='50'),
  namePrefix?: string(name='NamePrefix', description='The name of the event source.', example='testName'),
  nextToken?: string(name='NextToken', description='If you configure Limit and excess return values exist, this parameter is returned.', example='100'),
}

model ListUserDefinedEventSourcesResponseBody = {
  code?: string(name='Code', description='The returned response code. Valid values:

*   Success: The request is successful.
*   Other codes: The request failed. For more information about error codes, see Error codes.', example='Success'),
  data?: {
    eventSourceList?: [ 
      {
        arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the queried event source.', example='acs:eventbridge:cn-hangzhou:164901546557****:eventbus/my-event-bus/eventsource/myRocketMQ.source'),
        ctime?: float(name='Ctime', description='The timestamp that indicates when the event source was created.', example='1607071602000'),
        eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='test-custom-bus'),
        externalSourceType?: string(name='ExternalSourceType', description='The type of the event source.', example='RabbitMQ'),
        name?: string(name='Name', description='The name of the queried event source.', example='rocketmq.source'),
        sourceHttpEventParameters?: {
          ip?: [ string ](name='Ip', description='The CIDR block that is used for security settings. This parameter is required only if SecurityConfig is set to ip. You can enter a CIDR block or an IP address.'),
          method?: [ string ](name='Method', description='The HTTP request method that is supported by the generated webhook URL. You can select multiple values. Valid values:

*   GET
*   POST
*   PUT
*   PATCH
*   DELETE
*   HEAD
*   OPTIONS
*   TRACE
*   CONNECT'),
          publicWebHookUrl?: [ string ](name='PublicWebHookUrl', description='The Internet request URL.'),
          referer?: [ string ](name='Referer', description='The security domain name. This parameter is required only if SecurityConfig is set to referer. You can enter a domain name.'),
          securityConfig?: string(name='SecurityConfig', description='The type of security settings. Valid values:

*   none: No configuration is required.
*   ip: CIDR block.
*   referer: security domain name.', example='none'),
          type?: string(name='Type', description='The protocol type that is supported by the generated webhook URL. Valid values:

*   HTTP
*   HTTPS
*   HTTP\\\\&HTTPS', example='HTTPS'),
          vpcWebHookUrl?: [ string ](name='VpcWebHookUrl', description='The internal request URL.'),
        }(name='SourceHttpEventParameters', description='The parameters that are returned if HTTP events are specified as the event source.'),
        sourceKafkaParameters?: {
          consumerGroup?: string(name='ConsumerGroup', description='The ID of the consumer group that subscribes to the topic on the Message Queue for Apache Kafka instance.', example='test-gid'),
          instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache Kafka instance.', example='i-2ze6kiwzkebf04s5h8ds'),
          maximumTasks?: int32(name='MaximumTasks', description='The maximum number of consumers.', example='2'),
          network?: string(name='Network', description='The network type. Valid values: Default and PublicNetwork. Default value: Default. The value PublicNetwork indicates a self-managed network.', example='Default'),
          offsetReset?: string(name='OffsetReset', description='The consumer offset.', example='earliest'),
          regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for Apache Kafka instance resides.', example='cn-hangzhou'),
          securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the Message Queue for Apache Kafka instance belongs.', example='sg-f8zatts5g97x0j***'),
          topic?: string(name='Topic', description='The topic name.', example='topic_api_1674441611897'),
          vSwitchIds?: string(name='VSwitchIds', description='The ID of the vSwitch with which the Message Queue for Apache Kafka instance is associated.', example='vsw-bp1hcrxq3mkcik***e'),
          vpcId?: string(name='VpcId', description='The ID of the VPC in which the Message Queue for Apache Kafka instance is deployed.', example='vpc-bp1kz3ohhzgrau2***'),
        }(name='SourceKafkaParameters', description='The parameters that are returned if Message Queue for Apache Kafka is specified as the event source.'),
        sourceMNSParameters?: {
          isBase64Decode?: boolean(name='IsBase64Decode', description='Indicates whether Base64 decoding is enabled. By default, Base64 decoding is enabled.', example='true'),
          queueName?: string(name='QueueName', description='The name of the MNS queue.', example='queue.openapi-sign-callback'),
          regionId?: string(name='RegionId', description='The ID of the region where the MNS queue resides.', example='cn-hangzhou'),
        }(name='SourceMNSParameters', description='The parameters that are returned if Message Service (MNS) is specified as the event source.'),
        sourceRabbitMQParameters?: {
          instanceId?: string(name='InstanceId', description='The ID of the Message Queue for RabbitMQ instance. For more information, see [Limits](https://help.aliyun.com/document_detail/163289.html).', example='bastionhost-cn-0ju2x28fj07'),
          queueName?: string(name='QueueName', description='The name of the queue on the Message Queue for RabbitMQ instance. For more information, see [Limits](https://help.aliyun.com/document_detail/163289.html).', example='file-upload-queue'),
          regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for RabbitMQ instance resides.', example='cn-hangzhou'),
          virtualHostName?: string(name='VirtualHostName', description='The name of the vhost of the Message Queue for RabbitMQ instance. For more information, see [Limits](https://help.aliyun.com/document_detail/163289.html).', example='eb-connect'),
        }(name='SourceRabbitMQParameters', description='The parameters that are returned if Message Queue for RabbitMQ is specified as the event source.'),
        sourceRocketMQParameters?: {
          authType?: string(name='AuthType', description='The authentication type. This parameter can be set to ACL or left empty.', example='ACL'),
          groupId?: string(name='GroupId', description='The ID of the consumer group on the Message Queue for Apache RocketMQ instance.', example='GID-test'),
          instanceEndpoint?: string(name='InstanceEndpoint', description='The endpoint that is used to access the Message Queue for Apache RocketMQ instance.', example='registry-vpc.cn-hangzhou.aliyuncs.com'),
          instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ instance. For more information, see [Limits](https://help.aliyun.com/document_detail/163289.html).', example='bastionhost-cn-7mz293s9d1p'),
          instanceNetwork?: string(name='InstanceNetwork', description='The type of network over which the Message Queue for Apache RocketMQ instance is accessed.', example='PublicNetwork'),
          instancePassword?: string(name='InstancePassword', description='The password that is used to access the Message Queue for Apache RocketMQ instance.', example='***'),
          instanceSecurityGroupId?: string(name='InstanceSecurityGroupId', description='The ID of the security group to which the Message Queue for Apache RocketMQ instance belongs.', example='eb-167adad548***'),
          instanceType?: string(name='InstanceType', description='The instance type. Valid values: CLOUD_4, CLOUD_5, and SELF_BUILT. The value CLOUD_4 indicates that the instance is a Message Queue for Apache RocketMQ 4.0 instance. The value CLOUD_5 indicates that the instance is a Message Queue for Apache RocketMQ 5.0 instance. The value SELF_BUILT indicates that the instance is a self-managed RocketMQ instance.', example='CLOUD_5'),
          instanceUsername?: string(name='InstanceUsername', description='The username that is used to access the Message Queue for Apache RocketMQ instance.', example='root'),
          instanceVSwitchIds?: string(name='InstanceVSwitchIds', description='The ID of the vSwitch with which the Message Queue for Apache RocketMQ instance is associated.', example='vsw-bp1iu***'),
          instanceVpcId?: string(name='InstanceVpcId', description='The ID of the virtual private cloud (VPC) in which the Message Queue for Apache RocketMQ instance is deployed.', example='vpc-***'),
          offset?: string(name='Offset', description='The offset from which messages are consumed. Valid values:

*   CONSUME_FROM_LAST_OFFSET: Messages are consumed from the latest offset.
*   CONSUME_FROM_FIRST_OFFSET: Messages are consumed from the earliest offset.
*   CONSUME_FROM_TIMESTAMP: Messages are consumed from the offset at the specified point in time.

Default value: CONSUME_FROM_LAST_OFFSET.', example='CONSUMEFROMLASTOFFSET'),
          regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for Apache RocketMQ instance resides.', example='cn-shenzhen'),
          tag?: string(name='Tag', description='The tag that is used to filter messages.', example='dataact'),
          timestamp?: float(name='Timestamp', description='The timestamp that indicates the time from which messages are consumed. This parameter is valid only if Offset is set to CONSUME_FROM_TIMESTAMP.', example='1664591760'),
          topic?: string(name='Topic', description='The name of the topic on the Message Queue for Apache RocketMQ instance. For more information, see [Limits](https://help.aliyun.com/document_detail/163289.html).', example='migration_instance'),
        }(name='SourceRocketMQParameters', description='The parameters that are returned if Message Queue for Apache RocketMQ is specified as the event source.'),
        sourceSLSParameters?: {
          consumePosition?: string(name='ConsumePosition', description='The consumer offset. The value begin indicates the earliest offset, and the value end indicates the latest offset. You can also specify a time in seconds to start consumption.', example='end'),
          logStore?: string(name='LogStore', description='The Simple Log Service Logstore.', example='cloudfirewall-logstore'),
          project?: string(name='Project', description='The Simple Log Service project.', example='VideoTestProject'),
          roleName?: string(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Simple Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the Resource Access Management (RAM) console. For information about the permission policy of this role, see Create a custom event source of the Log Service type.', example='testRole'),
        }(name='SourceSLSParameters', description='The parameters that are returned if Simple Log Service is specified as the event source.'),
        sourceScheduledEventParameters?: {
          schedule?: string(name='Schedule', description='The cron expression.', example='0 1 * * * *'),
          timeZone?: string(name='TimeZone', description='The time zone in which the cron expression is executed.', example='GMT+0:00'),
          userData?: string(name='UserData', description='The JSON string.', example='{"a": "b"}'),
        }(name='SourceScheduledEventParameters', description='The parameters that are returned if scheduled events are specified as the event source.'),
        status?: string(name='Status', description='The status of the queried event source. The returned value Activated indicates that the event source is activated.', example='Activated'),
        type?: string(name='Type', description='The type of the queried event source. The returned value UserDefined indicates that the event source is a custom event source.', example='UserDefined'),
      }
    ](name='EventSourceList', description='The event sources.'),
    nextToken?: string(name='NextToken'),
    total?: int32(name='Total'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='InvalidArgument'),
  requestId?: string(name='RequestId', description='The request ID.', example='5169654A-7059-57E3-BFD9-33C7E012EA1B'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. The value true indicates that the operation is successful.', example='true'),
}

model ListUserDefinedEventSourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserDefinedEventSourcesResponseBody(name='body'),
}

/**
 * @summary Queries all custom event sources.
 *
 * @description You can call this API operation to query custom event sources.
 *
 * @param request ListUserDefinedEventSourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUserDefinedEventSourcesResponse
 */
async function listUserDefinedEventSourcesWithOptions(request: ListUserDefinedEventSourcesRequest, runtime: Util.RuntimeOptions): ListUserDefinedEventSourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namePrefix)) {
    query['NamePrefix'] = request.namePrefix;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserDefinedEventSources',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all custom event sources.
 *
 * @description You can call this API operation to query custom event sources.
 *
 * @param request ListUserDefinedEventSourcesRequest
 * @return ListUserDefinedEventSourcesResponse
 */
async function listUserDefinedEventSources(request: ListUserDefinedEventSourcesRequest): ListUserDefinedEventSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserDefinedEventSourcesWithOptions(request, runtime);
}

model PauseEventStreamingRequest {
  eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream that you want to stop.

This parameter is required.', example='rocketmq-sync'),
}

model PauseEventStreamingResponseBody = {
  code?: string(name='Code', description='The response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For more information about error codes, see Error codes.', example='Success'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='The event streaming [xxxx] not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='72ce027c-546a-4231-9cf6-ec58766027f9'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model PauseEventStreamingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PauseEventStreamingResponseBody(name='body'),
}

/**
 * @summary Stops an event stream that is running.
 *
 * @description You can call this API operation to stop an event stream that is running.
 *
 * @param request PauseEventStreamingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PauseEventStreamingResponse
 */
async function pauseEventStreamingWithOptions(request: PauseEventStreamingRequest, runtime: Util.RuntimeOptions): PauseEventStreamingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PauseEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Stops an event stream that is running.
 *
 * @description You can call this API operation to stop an event stream that is running.
 *
 * @param request PauseEventStreamingRequest
 * @return PauseEventStreamingResponse
 */
async function pauseEventStreaming(request: PauseEventStreamingRequest): PauseEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return pauseEventStreamingWithOptions(request, runtime);
}

model PutTargetsRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='eventTest'),
  ruleName?: string(name='RuleName', description='The name of the event rule.

This parameter is required.', example='ssr-send-to-vendor-test01'),
  targets?: [ 
    {
      deadLetterQueue?: {
        arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the dead-letter queue. Events that are not processed or whose maximum retries have been exceeded are written to the dead-letter queue.', example='acs:mns:cn-hangzhou:123456789098****:/queues/deadletterqueue or acs:mq:cn-hangzhou:123456789098****:/instances/MQ_INST_123456789098****_BX8QbBPL/topic/deadlettertopic or acs:alikafka:cn-hangzhou:123456789098****:instance/alikafka_post-cn-123456/topic/deadlettertopic or acs:eventbridge:cn-hangzhou:123456789098****:eventbus/deadletterbus'),
      }(name='DeadLetterQueue', description='The dead-letter queue. Events that are not processed or whose maximum retries have been exceeded are written to the dead-letter queue. The dead-letter queue feature supports the following queue types: Message Queue for Apache RocketMQ, Message Service, Message Queue for Apache Kafka, and event bus.'),
      endpoint?: string(name='Endpoint', description='The endpoint of the event target.', example='acs:fc:cn-hangzhou:123456789098****:services/guide.LATEST/functions/HelloFC'),
      errorsTolerance?: string(name='ErrorsTolerance', description='The fault tolerance policy. Valid values:

* **ALL**: ignores the error. Fault tolerance is allowed. If an error occurs, event processing is not blocked. If the message exceeds the number of retries specified by the retry policy, the message is delivered to a dead-letter queue or discarded based on your configurations.

* **NONE**: does not ignore the error. Fault tolerance is prohibited. If an error occurs and the message exceeds the number of retries specified by the retry policy, event processing is blocked.', example='ALL'),
      id?: string(name='Id', description='The ID of the custom event target.

This parameter is required.', example='Mlm123456JHd2RsRoKw'),
      paramList?: [ 
        {
          form?: string(name='Form', description='The method that is used to deliver events to the event target. For more information,see [Event target parameters.](https://www.alibabacloud.com/help/en/eventbridge/latest/event-target-parameters)', example='TEMPLATE'),
          resourceKey?: string(name='ResourceKey', description='The resource parameter of the event target. For more information,see [Event target parameters.](https://www.alibabacloud.com/help/en/eventbridge/latest/event-target-parameters)', example='body'),
          template?: string(name='Template', description='The template based on which events are delivered to the event target.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value of the event target parameter.', example='{\\\\"key\\\\"=\\\\"value\\\\"}'),
        }
      ](name='ParamList', description='The parameters that are configured for the event target.'),
      pushRetryStrategy?: string(name='PushRetryStrategy', description='The retry policy for pushing the event. Valid values:

* **BACKOFF_RETRY**: backoff retry. A failed event can be retried up to three times. The interval between two consecutive retries is a random value from 10 to 20. Unit: seconds.

* **EXPONENTIAL_DECAY_RETRY**: exponential decay retry. The request can be retried up to 176 times. The interval between two consecutive retries exponentially increases to 512 seconds, and the total retry time is one day. The specific retry intervals are 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 512, ..., and 512 seconds. The interval of 512 seconds can be used up to one hundred and sixty-seven times in total.', example='BACKOFFRETRY'),
      type?: string(name='Type', description='The type of the event target. For more information, see [Event target parameters.](https://www.alibabacloud.com/help/en/eventbridge/latest/event-target-parameters)

This parameter is required.', example='acs.fc.function'),
    }
  ](name='Targets', description='The event targets to be created or updated. For more information, see [Limits.](https://www.alibabacloud.com/help/en/eventbridge/latest/limits)

This parameter is required.'),
}

model PutTargetsShrinkRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='eventTest'),
  ruleName?: string(name='RuleName', description='The name of the event rule.

This parameter is required.', example='ssr-send-to-vendor-test01'),
  targetsShrink?: string(name='Targets', description='The event targets to be created or updated. For more information, see [Limits.](https://www.alibabacloud.com/help/en/eventbridge/latest/limits)

This parameter is required.'),
}

model PutTargetsResponseBody = {
  code?: string(name='Code', description='The response code. Valid values:

*   Success: The call succeeded.
*   Other codes: The call failed. For more information about error codes, see Error codes.', example='Success'),
  data?: {
    errorEntries?: [ 
      {
        entryId?: string(name='EntryId', description='The ID of the failed event target.', example='Mlm123456JHd2RsRoKw'),
        errorCode?: string(name='ErrorCode', description='The error code returned.', example='EventRuleTargetIdDuplicate'),
        errorMessage?: string(name='ErrorMessage', description='The error message returned.', example='The id of event target is duplicate!'),
      }
    ](name='ErrorEntries', description='The ID of the failed event target.'),
    errorEntriesCount?: int32(name='ErrorEntriesCount', description='The number of failed event targets. Valid values:

*   0: All event targets succeeded.
*   An integer other than 0: indicates the number of failed event targets.', example='0'),
  }(name='Data', description='The returned result.'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='The event rule not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='6FB52207-7621-5292-BDF2-A17E2E984160'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request is successful.
*   **false**: The request failed.', example='true'),
}

model PutTargetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PutTargetsResponseBody(name='body'),
}

/**
 * @summary Creates or updates event targets under a rule.
 *
 * @description You can call this API operation to create or update event targets under a rule.
 *
 * @param tmpReq PutTargetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutTargetsResponse
 */
async function putTargetsWithOptions(tmpReq: PutTargetsRequest, runtime: Util.RuntimeOptions): PutTargetsResponse {
  Util.validateModel(tmpReq);
  var request = new PutTargetsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.targets)) {
    request.targetsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.targets, 'Targets', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.targetsShrink)) {
    query['Targets'] = request.targetsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutTargets',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates or updates event targets under a rule.
 *
 * @description You can call this API operation to create or update event targets under a rule.
 *
 * @param request PutTargetsRequest
 * @return PutTargetsResponse
 */
async function putTargets(request: PutTargetsRequest): PutTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return putTargetsWithOptions(request, runtime);
}

model QueryEventRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='demo'),
  eventId?: string(name='EventId', description='The event ID.

This parameter is required.', example='1935debf-ddac-49dc-a090-d4f2857a046d'),
  eventSource?: string(name='EventSource', description='EventSource is required for querying default bus events.', example='testEventSourceName'),
}

model QueryEventResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code 200 indicates that the request was successful.', example='200'),
  data?: map[string]any(name='Data', description='The content of the event.'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='EventBusNotExist'),
  requestId?: string(name='RequestId', description='The request ID.', example='580A938B-6107-586C-8EC7-F22EEBEDA9E6'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model QueryEventResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryEventResponseBody(name='body'),
}

/**
 * @summary Queries the content of an event.
 *
 * @description You can call this API operation to query the content of an event.
 *
 * @param request QueryEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEventResponse
 */
async function queryEventWithOptions(request: QueryEventRequest, runtime: Util.RuntimeOptions): QueryEventResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.eventSource)) {
    query['EventSource'] = request.eventSource;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEvent',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the content of an event.
 *
 * @description You can call this API operation to query the content of an event.
 *
 * @param request QueryEventRequest
 * @return QueryEventResponse
 */
async function queryEvent(request: QueryEventRequest): QueryEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEventWithOptions(request, runtime);
}

model QueryEventTracesRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='MyEventBus'),
  eventId?: string(name='EventId', description='The event ID.

This parameter is required.', example='1935debf-ddac-49dc-a090-d4f2857a046d'),
}

model QueryEventTracesResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code 200 indicates that the request was successful.', example='200'),
  data?: [ 
    {
      action?: string(name='Action', description='The type of the event trace. Valid values: PutEvent: a delivery event. FilterEvent: a filtering event. PushEvent: a pushing event.', example='PutEvent'),
      actionTime?: long(name='ActionTime', description='The execution time of the event trace.', example='1659495343896'),
      endpoint?: string(name='Endpoint', description='The endpoint of the event target. This parameter is returned if the value of the Action parameter is PushEvent.', example='acs:mns:cn-zhangjiakou:123456789098****:queues/testQueue'),
      eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='demo'),
      eventId?: string(name='EventId', description='The event ID.', example='a5747e4f-2af2-40b6-b262-d0140e995bf7'),
      eventSource?: string(name='EventSource', description='The name of the event source.', example='cert-api'),
      notifyLatency?: string(name='NotifyLatency', description='The delivery delay of the event target. This parameter is returned if the value of the Action parameter is PushEvent.', example='80'),
      notifyStatus?: string(name='NotifyStatus', description='The event target delivery status.', example='[200]Ok'),
      notifyTime?: long(name='NotifyTime', description='The delivery time of the event target. This parameter is returned if the value of the Action parameter is PushEvent.', example='1659495343896'),
      receivedTime?: long(name='ReceivedTime', description='The time when the event was delivered to the event bus. This parameter is returned if the value of the Action parameter is PutEvent.', example='1659495343896'),
      ruleMatchingTime?: string(name='RuleMatchingTime', description='The time when the event rule was matched. This parameter is returned if the value of the Action parameter is FilterEvent.', example='1659495343896'),
      ruleName?: string(name='RuleName', description='The name of the event rule.', example='ramrolechange-mns'),
    }
  ](name='Data', description='The name of the event source.'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='EventBusNotExist'),
  requestId?: string(name='RequestId', description='The request ID.', example='BB934571-1F5A-5E17-91DD-E2BC3E1BFBFF'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model QueryEventTracesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryEventTracesResponseBody(name='body'),
}

/**
 * @summary Queries event traces.
 *
 * @description You can call this API operation to query event traces.
 *
 * @param request QueryEventTracesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEventTracesResponse
 */
async function queryEventTracesWithOptions(request: QueryEventTracesRequest, runtime: Util.RuntimeOptions): QueryEventTracesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEventTraces',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries event traces.
 *
 * @description You can call this API operation to query event traces.
 *
 * @param request QueryEventTracesRequest
 * @return QueryEventTracesResponse
 */
async function queryEventTraces(request: QueryEventTracesRequest): QueryEventTracesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEventTracesWithOptions(request, runtime);
}

model QueryTracedEventByEventIdRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='demo'),
  eventId?: string(name='EventId', description='The event ID.

This parameter is required.', example='1935debf-ddac-49dc-a090-d4f2857a046d'),
  eventSource?: string(name='EventSource', description='The name of the event source.', example='mse'),
}

model QueryTracedEventByEventIdResponseBody = {
  code?: string(name='Code', description='The returned HTTP status code. The HTTP status code 200 indicates that the request is successful.', example='200'),
  data?: [ 
    {
      events?: [ 
        {
          eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='default'),
          eventId?: string(name='EventId', description='The event ID.', example='37C-1P6Yn6EM7TcH37Vod8w7rbSeimJ'),
          eventReceivedTime?: long(name='EventReceivedTime', description='The time when the event was delivered to the event bus.', example='1661773573100'),
          eventSource?: string(name='EventSource', description='The name of the event source.', example='cert-api'),
          eventType?: string(name='EventType', description='The event type.', example='eventbridge:Events:HTTPEvent'),
        }
      ](name='Events', description='The events.'),
      nextToken?: string(name='NextToken', description='If excess return values exist, this parameter is returned.', example='1000'),
      total?: int32(name='Total', description='The total number of entries returned.', example='18'),
    }
  ](name='Data', description='The total number of entries returned.'),
  message?: string(name='Message', description='The returned error message.', example='EventBusNotExist'),
  requestId?: string(name='RequestId', description='The request ID.', example='A5D7B9F4-BF96-51A9-90B1-928955FABB5B'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model QueryTracedEventByEventIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryTracedEventByEventIdResponseBody(name='body'),
}

/**
 * @summary Queries event traces by event ID.
 *
 * @description You can call this API operation to query event traces by event ID.
 *
 * @param request QueryTracedEventByEventIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryTracedEventByEventIdResponse
 */
async function queryTracedEventByEventIdWithOptions(request: QueryTracedEventByEventIdRequest, runtime: Util.RuntimeOptions): QueryTracedEventByEventIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.eventSource)) {
    query['EventSource'] = request.eventSource;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTracedEventByEventId',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries event traces by event ID.
 *
 * @description You can call this API operation to query event traces by event ID.
 *
 * @param request QueryTracedEventByEventIdRequest
 * @return QueryTracedEventByEventIdResponse
 */
async function queryTracedEventByEventId(request: QueryTracedEventByEventIdRequest): QueryTracedEventByEventIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTracedEventByEventIdWithOptions(request, runtime);
}

model QueryTracedEventsRequest {
  endTime?: long(name='EndTime', description='The end of the time range when event traces are queried. Unit: milliseconds.

This parameter is required.', example='1661773509000'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='MyEventBus'),
  eventSource?: string(name='EventSource', description='The name of the event source.', example='mse'),
  eventType?: string(name='EventType', description='The event type.', example='eventbridge:Events:HTTPEvent'),
  limit?: int32(name='Limit', description='The maximum number of entries to be returned in a call. You can use this parameter and NextToken to implement paging. Up to 100 entries can be returned in a call.', example='50'),
  matchedRule?: string(name='MatchedRule', description='The name of the event rule that is matched.', example='test-mnsrule'),
  nextToken?: string(name='NextToken', description='If you configure Limit and excess return values exist, this parameter is returned.', example='1000'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query event traces. Unit: milliseconds.

This parameter is required.', example='1661773509000'),
}

model QueryTracedEventsResponseBody = {
  code?: string(name='Code', description='The returned HTTP status code. The HTTP status code 200 indicates that the request is successful.', example='200'),
  data?: {
    events?: [ 
      {
        eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='test-custom-bus'),
        eventId?: string(name='EventId', description='The event ID.', example='07E-1OCckaVzNB92BIFFh4xgydOF1wd'),
        eventReceivedTime?: long(name='EventReceivedTime', description='The time when the event was delivered to the event bus.', example='1661773573100'),
        eventSource?: string(name='EventSource', description='The name of the event source.', example='acs.resourcemanager'),
        eventType?: string(name='EventType', description='The event type.', example='eventbridge:Events:HTTPEvent'),
      }
    ](name='Events', description='The event type.'),
    nextToken?: string(name='NextToken', description='If excess return values exist, this parameter is returned.', example='1000'),
    total?: int32(name='Total', description='The total number of entries.', example='6'),
  }(name='Data', description='The data returned.'),
  message?: string(name='Message', description='The returned error message.', example='EventBusNotExist'),
  requestId?: string(name='RequestId', description='The request ID.', example='d9e4628b-8b34-4f33-82be-5aac50aac0ba'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model QueryTracedEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryTracedEventsResponseBody(name='body'),
}

/**
 * @summary Queries event traces by time range.
 *
 * @description You can call this API operation to query event traces by time range.
 *
 * @param request QueryTracedEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryTracedEventsResponse
 */
async function queryTracedEventsWithOptions(request: QueryTracedEventsRequest, runtime: Util.RuntimeOptions): QueryTracedEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventSource)) {
    query['EventSource'] = request.eventSource;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.matchedRule)) {
    query['MatchedRule'] = request.matchedRule;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTracedEvents',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries event traces by time range.
 *
 * @description You can call this API operation to query event traces by time range.
 *
 * @param request QueryTracedEventsRequest
 * @return QueryTracedEventsResponse
 */
async function queryTracedEvents(request: QueryTracedEventsRequest): QueryTracedEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTracedEventsWithOptions(request, runtime);
}

model StartEventStreamingRequest {
  eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream that you want to enable.

This parameter is required.', example='rocketmq-sync'),
}

model StartEventStreamingResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For more information about error codes, see Error codes.', example='Success'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='The event streaming [xxxx] not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='8CEAD24D-328D-5539-9D30-FD2D33204FBB'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. The value true indicates that the operation is successful.', example='true'),
}

model StartEventStreamingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartEventStreamingResponseBody(name='body'),
}

/**
 * @summary Enables a created or deactivated event stream.
 *
 * @description You can call this API operation to enable a created or deactivated event stream.
 *
 * @param request StartEventStreamingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartEventStreamingResponse
 */
async function startEventStreamingWithOptions(request: StartEventStreamingRequest, runtime: Util.RuntimeOptions): StartEventStreamingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables a created or deactivated event stream.
 *
 * @description You can call this API operation to enable a created or deactivated event stream.
 *
 * @param request StartEventStreamingRequest
 * @return StartEventStreamingResponse
 */
async function startEventStreaming(request: StartEventStreamingRequest): StartEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return startEventStreamingWithOptions(request, runtime);
}

model TestEventPatternRequest {
  event?: string(name='Event', description='The event.

This parameter is required.', example='{
    "datacontenttype": "application/json;charset=utf-8",
    "aliyunaccountid": "*****",
    "aliyunpublishtime": "2023-04-****:54:57.939Z",
    "data": {
        "resourceEventType": "****",
        "resourceCreateTime": "****",
        "resourceId": "sls-code-***-debug",
        "captureTime": "***"
    },
    "aliyunoriginalaccountid": "****",
    "specversion": "1.0",
    "aliyuneventbusname": "****",
    "id": "295e6bd2-bb72-4f70-****-204a0680ee41",
    "source": "acs.sls",
    "time": "2023-04-***:37:56Z",
    "aliyunregionid": "cn-***",
    "type": "sls:Config:****"
}'),
  eventPattern?: string(name='EventPattern', description='The event pattern.

This parameter is required.', example='{"key1": "value1"}'),
}

model TestEventPatternResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For more information about error codes, see Error codes.', example='Success'),
  data?: {
    result?: boolean(name='Result', description='The value true indicates that the event pattern matches the provided JSON format. The value false indicates that the event pattern does not match the provided JSON format.', example='true'),
  }(name='Data', description='The returned result.'),
  message?: string(name='Message', description='The error message returned if the request failed.'),
  requestId?: string(name='RequestId', description='The request ID.', example='96D7C0AB-DCE5-5E82-96B8-4725E1706BB1'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model TestEventPatternResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TestEventPatternResponseBody(name='body'),
}

/**
 * @summary Checks whether the event pattern matches the provided JSON format.
 *
 * @description You can call this API operation to check whether the event pattern matches the provided JSON format.
 *
 * @param request TestEventPatternRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TestEventPatternResponse
 */
async function testEventPatternWithOptions(request: TestEventPatternRequest, runtime: Util.RuntimeOptions): TestEventPatternResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.event)) {
    body['Event'] = request.event;
  }
  if (!Util.isUnset(request.eventPattern)) {
    body['EventPattern'] = request.eventPattern;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TestEventPattern',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Checks whether the event pattern matches the provided JSON format.
 *
 * @description You can call this API operation to check whether the event pattern matches the provided JSON format.
 *
 * @param request TestEventPatternRequest
 * @return TestEventPatternResponse
 */
async function testEventPattern(request: TestEventPatternRequest): TestEventPatternResponse {
  var runtime = new Util.RuntimeOptions{};
  return testEventPatternWithOptions(request, runtime);
}

model UpdateApiDestinationRequest {
  apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination. The name must be 2 to 127 characters in length.

This parameter is required.', example='api-destination-name'),
  connectionName?: string(name='ConnectionName', description='The name of the connection. The name must be 2 to 127 characters in length.

Note: Before you configure this parameter, you must call the CreateConnection operation to create a connection. Then, set this parameter to the name of the connection that you created.', example='connection-name'),
  description?: string(name='Description', description='The description of the API destination. The description can be up to 255 characters in length.', example='demo'),
  httpApiParameters?: {
    endpoint?: string(name='Endpoint', description='The endpoint of the API destination. The endpoint can be up to 127 characters in length.', example='http://127.0.0.1:8001/api'),
    method?: string(name='Method', description='The HTTP request method. Valid values:

- GET
- POST
- HEAD
- DELETE
- PUT
- PATCH', example='POST'),
  }(name='HttpApiParameters', description='The parameters that are configured for the API destination.'),
}

model UpdateApiDestinationShrinkRequest {
  apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination. The name must be 2 to 127 characters in length.

This parameter is required.', example='api-destination-name'),
  connectionName?: string(name='ConnectionName', description='The name of the connection. The name must be 2 to 127 characters in length.

Note: Before you configure this parameter, you must call the CreateConnection operation to create a connection. Then, set this parameter to the name of the connection that you created.', example='connection-name'),
  description?: string(name='Description', description='The description of the API destination. The description can be up to 255 characters in length.', example='demo'),
  httpApiParametersShrink?: string(name='HttpApiParameters', description='The parameters that are configured for the API destination.'),
}

model UpdateApiDestinationResponseBody = {
  apiDestinationName?: string(name='ApiDestinationName', description='api-destination-name', example='api-destination-name'),
  code?: string(name='Code', description='The response code. If the request is successful, Success is returned.', example='Success'),
  message?: string(name='Message', description='The returned message. If the request is successful, success is returned.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='382E6272-8E9C-5681-AC96-A8AF0BFAC1A5'),
}

model UpdateApiDestinationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateApiDestinationResponseBody(name='body'),
}

/**
 * @summary Updates an API destination.
 *
 * @description You can call this API operation to update an API destination.
 *
 * @param tmpReq UpdateApiDestinationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateApiDestinationResponse
 */
async function updateApiDestinationWithOptions(tmpReq: UpdateApiDestinationRequest, runtime: Util.RuntimeOptions): UpdateApiDestinationResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateApiDestinationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.httpApiParameters)) {
    request.httpApiParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.httpApiParameters, 'HttpApiParameters', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.apiDestinationName)) {
    query['ApiDestinationName'] = request.apiDestinationName;
  }
  if (!Util.isUnset(request.connectionName)) {
    query['ConnectionName'] = request.connectionName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.httpApiParametersShrink)) {
    query['HttpApiParameters'] = request.httpApiParametersShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApiDestination',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates an API destination.
 *
 * @description You can call this API operation to update an API destination.
 *
 * @param request UpdateApiDestinationRequest
 * @return UpdateApiDestinationResponse
 */
async function updateApiDestination(request: UpdateApiDestinationRequest): UpdateApiDestinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateApiDestinationWithOptions(request, runtime);
}

model UpdateConnectionRequest {
  authParameters?: {
    apiKeyAuthParameters?: {
      apiKeyName?: string(name='ApiKeyName', description='The key of the API key.', example='name'),
      apiKeyValue?: string(name='ApiKeyValue', description='The value of the API key.', example='demo'),
    }(name='ApiKeyAuthParameters', description='The parameters for API key authentication.'),
    authorizationType?: string(name='AuthorizationType', description='The authentication type. Valid values:

BASIC_AUTH: basic authentication.

Introduction: Basic authentication is a simple authentication scheme built into the HTTP protocol. When you use the HTTP protocol for communications, the authentication method that the HTTP server uses to authenticate user identities on the client is defined in the protocol. The request header is in the Authorization: Basic Base64-encoded string (Username:Password) format.

1.  Username and Password are required.

API_KEY_AUTH: API key authentication.

Introduction: The request header is in the Token : Token value format.

*   ApiKeyName and ApiKeyValue are required.

OAUTH_AUTH: OAuth authentication.

Introduction: OAuth2.0 is an authentication mechanism. In normal cases, a system that does not use OAuth2.0 can access the resources of the server from the client. To ensure access security, access tokens are used to identify users in OAuth 2.0. The client must use an access token to access protected resources. This way, OAuth 2.0 protects resources from being accessed from malicious clients and improves system security.

*   AuthorizationEndpoint, OAuthHttpParameters, and HttpMethod are required.', example='BASIC_AUTH'),
    basicAuthParameters?: {
      password?: string(name='Password', description='The password for basic authentication.', example='admin'),
      username?: string(name='Username', description='The username for basic authentication.', example='admin'),
    }(name='BasicAuthParameters', description='The parameters that are configured for basic authentication.'),
    OAuthParameters?: {
      authorizationEndpoint?: string(name='AuthorizationEndpoint', description='The endpoint that is used to obtain the OAuth token. The endpoint can be up to 127 characters in length.', example='http://localhost:8080/oauth/token'),
      clientParameters?: {
        clientID?: string(name='ClientID', description='The client ID.', example='ClientID'),
        clientSecret?: string(name='ClientSecret', description='The AccessKey secret of the client.', example='ClientSecret'),
      }(name='ClientParameters', description='The parameters that are configured for the client.'),
      httpMethod?: string(name='HttpMethod', description='The HTTP request method. Valid values:

*   GET
*   POST
*   HEAD
*   DELETE
*   PUT
*   PATCH', example='POST'),
      OAuthHttpParameters?: {
        bodyParameters?: [ 
          {
            isValueSecret?: string(name='IsValueSecret', description='Specifies whether to enable authentication.', example='false'),
            key?: string(name='Key', description='The key of the request body.', example='name'),
            value?: string(name='Value', description='The value of the request body.', example='demo'),
          }
        ](name='BodyParameters', description='The parameters that are configured for the request body.'),
        headerParameters?: [ 
          {
            isValueSecret?: string(name='IsValueSecret', description='Specifies whether to enable authentication.', example='false'),
            key?: string(name='Key', description='The key of the request header.', example='name'),
            value?: string(name='Value', description='The value of the request header.', example='demo'),
          }
        ](name='HeaderParameters', description='The value of the request header.'),
        queryStringParameters?: [ 
          {
            isValueSecret?: string(name='IsValueSecret', description='Specifies whether to enable authentication.', example='false'),
            key?: string(name='Key', description='The key of the request path.', example='name'),
            value?: string(name='Value', description='The value of the request path.', example='demo'),
          }
        ](name='QueryStringParameters', description='The parameters that are configured for the request path.'),
      }(name='OAuthHttpParameters', description='The request parameters for OAuth authentication.'),
    }(name='OAuthParameters', description='The parameters that are configured for OAuth authentication.'),
  }(name='AuthParameters', description='The parameters that are configured for authentication.'),
  connectionName?: string(name='ConnectionName', description='The name of the connection that you want to update. The name must be 2 to 127 characters in length.

This parameter is required.', example='connection-name'),
  description?: string(name='Description', description='The description of the connection. The description can be up to 255 characters in length.', example='The description of the connection.'),
  networkParameters?: {
    networkType?: string(name='NetworkType', description='PublicNetwork: the Internet.

PrivateNetwork: virtual private cloud (VPC).

Note: If you set this parameter to PrivateNetwork, you must configure VpcId, VswitcheId, and SecurityGroupId.

This parameter is required.', example='PublicNetwork'),
    securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', example='eb-167adad548759-security_grop/sg-bp1addad26peuh9qh9rtyb'),
    vpcId?: string(name='VpcId', description='The VPC ID.', example='eb-test/vpc-bp1symadadwnwgmqud'),
    vswitcheId?: string(name='VswitcheId', description='The vSwitch ID.', example='vsw-bp1iu4x7aeradadown1og8,vsw-bp193sqmadadlaszpeqbt2c'),
  }(name='NetworkParameters', description='The parameters that are configured for the network.

This parameter is required.'),
}

model UpdateConnectionShrinkRequest {
  authParametersShrink?: string(name='AuthParameters', description='The parameters that are configured for authentication.'),
  connectionName?: string(name='ConnectionName', description='The name of the connection that you want to update. The name must be 2 to 127 characters in length.

This parameter is required.', example='connection-name'),
  description?: string(name='Description', description='The description of the connection. The description can be up to 255 characters in length.', example='The description of the connection.'),
  networkParametersShrink?: string(name='NetworkParameters', description='The parameters that are configured for the network.

This parameter is required.'),
}

model UpdateConnectionResponseBody = {
  code?: string(name='Code', description='The returned response code.', example='Success'),
  message?: string(name='Message', description='The returned message.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='8346BE8F-40F3-533D-A0B8-1359C31BD5BA'),
}

model UpdateConnectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateConnectionResponseBody(name='body'),
}

/**
 * @summary Updates a connection.
 *
 * @description You can call this API operation to update a connection.
 *
 * @param tmpReq UpdateConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateConnectionResponse
 */
async function updateConnectionWithOptions(tmpReq: UpdateConnectionRequest, runtime: Util.RuntimeOptions): UpdateConnectionResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateConnectionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.authParameters)) {
    request.authParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.authParameters, 'AuthParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.networkParameters)) {
    request.networkParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.networkParameters, 'NetworkParameters', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.authParametersShrink)) {
    query['AuthParameters'] = request.authParametersShrink;
  }
  if (!Util.isUnset(request.connectionName)) {
    query['ConnectionName'] = request.connectionName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.networkParametersShrink)) {
    query['NetworkParameters'] = request.networkParametersShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConnection',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a connection.
 *
 * @description You can call this API operation to update a connection.
 *
 * @param request UpdateConnectionRequest
 * @return UpdateConnectionResponse
 */
async function updateConnection(request: UpdateConnectionRequest): UpdateConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConnectionWithOptions(request, runtime);
}

model UpdateEventBusRequest {
  description?: string(name='Description', description='The description of the event bus.', example='test'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='eventTest'),
}

model UpdateEventBusResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For more information about error codes, see Error codes.', example='Success'),
  message?: string(name='Message', description='The error message returned if the request failed.', example='The event bus [xxxx] not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='f2099962-1628-45f1-9782-2bf6daad823f'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model UpdateEventBusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateEventBusResponseBody(name='body'),
}

/**
 * @summary Modifies an event bus.
 *
 * @description You can call this API operation to modify an event bus.
 *
 * @param request UpdateEventBusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEventBusResponse
 */
async function updateEventBusWithOptions(request: UpdateEventBusRequest, runtime: Util.RuntimeOptions): UpdateEventBusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEventBus',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies an event bus.
 *
 * @description You can call this API operation to modify an event bus.
 *
 * @param request UpdateEventBusRequest
 * @return UpdateEventBusResponse
 */
async function updateEventBus(request: UpdateEventBusRequest): UpdateEventBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEventBusWithOptions(request, runtime);
}

model UpdateEventSourceRequest {
  description?: string(name='Description', description='The description of the event source.'),
  eventBusName?: string(name='EventBusName', description='The event bus with which the event source is associated.

This parameter is required.', example='my-event-bus'),
  eventSourceName?: string(name='EventSourceName', description='The name of the event source.

This parameter is required.', example='myrabbitmq.source'),
  externalSourceConfig?: map[string]any(name='ExternalSourceConfig'),
  externalSourceType?: string(name='ExternalSourceType'),
  linkedExternalSource?: boolean(name='LinkedExternalSource'),
  sourceHttpEventParameters?: {
    ip?: [ string ](name='Ip', description='The CIDR block that is used for security settings. This parameter is required only if SecurityConfig is set to ip. You can enter a CIDR block or an IP address.'),
    method?: [ string ](name='Method', description='The HTTP request method supported by the generated webhook URL. You can select multiple values. Valid values:

*   GET
*   POST
*   PUT
*   PATCH
*   DELETE
*   HEAD
*   OPTIONS
*   TRACE
*   CONNECT'),
    referer?: [ string ](name='Referer', description='The security domain name. This parameter is required only if SecurityConfig is set to referer. You can enter a domain name.'),
    securityConfig?: string(name='SecurityConfig', description='The type of security settings. Valid values:

*   none: No configuration is required.
*   ip: CIDR block.
*   referer: security domain name.', example='none'),
    type?: string(name='Type', description='The protocol type that is supported by the generated webhook URL. Valid values:

*   HTTP
*   HTTPS
*   HTTP\\\\&HTTPS', example='HTTPS'),
  }(name='SourceHttpEventParameters', description='The parameters that are configured if the event source is HTTP events.'),
  sourceKafkaParameters?: {
    consumerGroup?: string(name='ConsumerGroup', description='The ID of the consumer group that subscribes to the topic.', example='dsp_online_ml_request'),
    instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache Kafka instance.', example='cbwp-bp1o3m66wcjgbkssm3k5m'),
    maximumTasks?: int32(name='MaximumTasks', description='The maximum number of consumers.', example='1'),
    network?: string(name='Network', description='The network. Valid values: Default and PublicNetwork. Default value: Default. The value PublicNetwork indicates a self-managed network.', example='Default'),
    offsetReset?: string(name='OffsetReset', description='The consumer offset.', example='latest'),
    regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for Apache Kafka instance resides.', example='cn-shanghai'),
    securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the Message Queue for Apache Kafka instance belongs. This parameter is required only if you set Network to PublicNetwork.', example='sg-5wz3mjgo9wpvdnwpwnhkjdjwn'),
    topic?: string(name='Topic', description='The name of the topic on the Message Queue for Apache Kafka instance.', example='billing_notify'),
    vSwitchIds?: string(name='VSwitchIds', description='The ID of the vSwitch with which the Message Queue for Apache Kafka instance is associated. This parameter is required only if you set Network to PublicNetwork.', example='vsw-bp1xyntcxiwplhqxjybuk'),
    vpcId?: string(name='VpcId', description='The ID of the VPC in which the Message Queue for Apache Kafka instance resides. This parameter is required only if you set Network to PublicNetwork.', example='vpc-2zefu4vfmx6siogujmo0b'),
  }(name='SourceKafkaParameters', description='The parameters that are configured if the event source is Message Queue for Apache Kafka.'),
  sourceMNSParameters?: {
    isBase64Decode?: boolean(name='IsBase64Decode', description='Indicates whether Base64 decoding is enabled. By default, Base64 decoding is enabled.', example='true'),
    queueName?: string(name='QueueName', description='The name of the MNS queue.', example='queue_api_bind_1672194645178'),
    regionId?: string(name='RegionId', description='The region where the MNS queue resides.', example='cn-beijing'),
  }(name='SourceMNSParameters', description='The parameters that are configured if the event source is Message Service (MNS).'),
  sourceRabbitMQParameters?: {
    instanceId?: string(name='InstanceId', description='The ID of the Message Queue for RabbitMQ instance. For more information, see [Limits](https://help.aliyun.com/document_detail/163289.html).', example='bastionhost-cn-7mz2zkyff09'),
    queueName?: string(name='QueueName', description='The name of the queue on the Message Queue for RabbitMQ instance. For more information, see [Limits](https://help.aliyun.com/document_detail/163289.html).', example='eb-connect'),
    regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for RabbitMQ instance resides.', example='cn-hangzhou'),
    virtualHostName?: string(name='VirtualHostName', description='The name of the vhost of the Message Queue for RabbitMQ instance. For more information, see [Limits](https://help.aliyun.com/document_detail/163289.html).', example='amqp-cn-nif22u74****'),
  }(name='SourceRabbitMQParameters', description='The parameters that are configured if the event source is Message Queue for RabbitMQ.'),
  sourceRocketMQParameters?: {
    authType?: string(name='AuthType', description='The authentication type. You can set this parameter to ACL or leave this parameter empty.', example='ACL'),
    groupID?: string(name='GroupID', description='The ID of the consumer group on the Message Queue for Apache RocketMQ instance.', example='GID-test'),
    instanceEndpoint?: string(name='InstanceEndpoint', description='The endpoint that is used to access the Message Queue for Apache RocketMQ instance.', example='registry-vpc****.aliyuncs.com'),
    instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ instance. For more information, see [Limits](https://help.aliyun.com/document_detail/163289.html).', example='dbaudit-cn-i7m2nx2or01'),
    instanceNetwork?: string(name='InstanceNetwork', description='None.', example='None'),
    instancePassword?: string(name='InstancePassword', description='The password that is used to access the Message Queue for Apache RocketMQ instance.', example='******'),
    instanceSecurityGroupId?: string(name='InstanceSecurityGroupId', description='The ID of the security group to which the Message Queue for Apache RocketMQ instance belongs.', example='sg-catalog-eventlistener'),
    instanceType?: string(name='InstanceType', description='The type of the Message Queue for Apache RocketMQ instance. Valid values:

*   Cloud_4: Message Queue for Apache RocketMQ 4.0 instance.
*   Cloud_5: Message Queue for Apache RocketMQ 5.0 instance.', example='Cloud_4'),
    instanceUsername?: string(name='InstanceUsername', description='The username that is used to access the Message Queue for Apache RocketMQ instance.', example='root'),
    instanceVSwitchIds?: string(name='InstanceVSwitchIds', description='The ID of the vSwitch with which the Message Queue for Apache RocketMQ instance is associated.', example='vsw-bp10rbrt6rb6vrd89****'),
    instanceVpcId?: string(name='InstanceVpcId', description='The ID of the virtual private cloud (VPC) in which the Message Queue for Apache RocketMQ instance resides.', example='vpc-bp1a4gmlk31hyg6ptl3ss'),
    offset?: string(name='Offset', description='The offset from which message consumption starts. Valid values:

*   CONSUME_FROM_LAST_OFFSET: Start message consumption from the latest offset.
*   CONSUME_FROM_FIRST_OFFSET: Start message consumption from the earliest offset.
*   CONSUME_FROM_TIMESTAMP: Start message consumption from the offset at the specified point in time.

Default value: CONSUME_FROM_LAST_OFFSET.', example='CONSUMEFROMLASTOFFSET'),
    regionId?: string(name='RegionId', description='The region where the Message Queue for Apache RocketMQ instance resides.', example='cn-zhangjiakou'),
    tag?: string(name='Tag', description='The tag that is used to filter messages.', example='KEY2'),
    timestamp?: long(name='Timestamp', description='The timestamp that specifies the time from which messages are consumed. This parameter is valid only if you set Offset to CONSUME_FROM_TIMESTAMP.', example='1663555399032'),
    topic?: string(name='Topic', description='The name of the topic on the Message Queue for Apache RocketMQ instance. For more information, see [Limits](https://help.aliyun.com/document_detail/163289.html).', example='topic_default_195820716552192'),
  }(name='SourceRocketMQParameters', description='The parameters that are configured if the event source is Message Queue for Apache RocketMQ.'),
  sourceSLSParameters?: {
    consumePosition?: string(name='ConsumePosition', description='The starting consumer offset. The value begin indicates the earliest offset, and the value end indicates the latest offset. You can also specify a time in seconds to start consumption.', example='end'),
    logStore?: string(name='LogStore', description='The Log Service Logstore.', example='waf-logstore'),
    project?: string(name='Project', description='The Log Service project.', example='VideoTestProject'),
    roleName?: string(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the RAM console. For information about the permission policy of this role, see Create a custom event source of the Log Service type.', example='testRole'),
  }(name='SourceSLSParameters', description='SourceSLSParameters'),
  sourceScheduledEventParameters?: {
    schedule?: string(name='Schedule', description='The cron expression.', example='10 * * * * *'),
    timeZone?: string(name='TimeZone', description='The time zone in which the cron expression is executed.', example='GMT+0:00'),
    userData?: string(name='UserData', description='The user data that is displayed in a JSON string.', example='{"a": "b"}'),
  }(name='SourceScheduledEventParameters', description='The parameters that are configured if you specify scheduled events as the event source.'),
}

model UpdateEventSourceShrinkRequest {
  description?: string(name='Description', description='The description of the event source.'),
  eventBusName?: string(name='EventBusName', description='The event bus with which the event source is associated.

This parameter is required.', example='my-event-bus'),
  eventSourceName?: string(name='EventSourceName', description='The name of the event source.

This parameter is required.', example='myrabbitmq.source'),
  externalSourceConfigShrink?: string(name='ExternalSourceConfig'),
  externalSourceType?: string(name='ExternalSourceType'),
  linkedExternalSource?: boolean(name='LinkedExternalSource'),
  sourceHttpEventParametersShrink?: string(name='SourceHttpEventParameters', description='The parameters that are configured if the event source is HTTP events.'),
  sourceKafkaParametersShrink?: string(name='SourceKafkaParameters', description='The parameters that are configured if the event source is Message Queue for Apache Kafka.'),
  sourceMNSParametersShrink?: string(name='SourceMNSParameters', description='The parameters that are configured if the event source is Message Service (MNS).'),
  sourceRabbitMQParametersShrink?: string(name='SourceRabbitMQParameters', description='The parameters that are configured if the event source is Message Queue for RabbitMQ.'),
  sourceRocketMQParametersShrink?: string(name='SourceRocketMQParameters', description='The parameters that are configured if the event source is Message Queue for Apache RocketMQ.'),
  sourceSLSParametersShrink?: string(name='SourceSLSParameters', description='SourceSLSParameters'),
  sourceScheduledEventParametersShrink?: string(name='SourceScheduledEventParameters', description='The parameters that are configured if you specify scheduled events as the event source.'),
}

model UpdateEventSourceResponseBody = {
  code?: string(name='Code', description='The returned response code. Valid values:

*   Success: The request is successful.
*   Other codes: The request failed. For more information about error codes, see Error codes.', example='200'),
  data?: boolean(name='Data', description='The result of the operation.', example='true'),
  message?: string(name='Message', description='The returned error message.', example='Remote error. requestId: [xxxx-9D10-65DFDFA3A75D], error code: [EventSourceNotExist], message: [The event source in request is not exist! ]'),
  requestId?: string(name='RequestId', description='The request ID.', example='c057d379-ea65-41ec-a8a8-90627a968204'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. The value true indicates that the operation is successful.', example='true'),
}

model UpdateEventSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateEventSourceResponseBody(name='body'),
}

/**
 * @summary Updates an event source.
 *
 * @description You can call this API operation to update an event source.
 *
 * @param tmpReq UpdateEventSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEventSourceResponse
 */
async function updateEventSourceWithOptions(tmpReq: UpdateEventSourceRequest, runtime: Util.RuntimeOptions): UpdateEventSourceResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateEventSourceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.externalSourceConfig)) {
    request.externalSourceConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.externalSourceConfig, 'ExternalSourceConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceHttpEventParameters)) {
    request.sourceHttpEventParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceHttpEventParameters, 'SourceHttpEventParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceKafkaParameters)) {
    request.sourceKafkaParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceKafkaParameters, 'SourceKafkaParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceMNSParameters)) {
    request.sourceMNSParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceMNSParameters, 'SourceMNSParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceRabbitMQParameters)) {
    request.sourceRabbitMQParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceRabbitMQParameters, 'SourceRabbitMQParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceRocketMQParameters)) {
    request.sourceRocketMQParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceRocketMQParameters, 'SourceRocketMQParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceSLSParameters)) {
    request.sourceSLSParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceSLSParameters, 'SourceSLSParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceScheduledEventParameters)) {
    request.sourceScheduledEventParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceScheduledEventParameters, 'SourceScheduledEventParameters', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    body['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventSourceName)) {
    body['EventSourceName'] = request.eventSourceName;
  }
  if (!Util.isUnset(request.externalSourceConfigShrink)) {
    body['ExternalSourceConfig'] = request.externalSourceConfigShrink;
  }
  if (!Util.isUnset(request.externalSourceType)) {
    body['ExternalSourceType'] = request.externalSourceType;
  }
  if (!Util.isUnset(request.linkedExternalSource)) {
    body['LinkedExternalSource'] = request.linkedExternalSource;
  }
  if (!Util.isUnset(request.sourceHttpEventParametersShrink)) {
    body['SourceHttpEventParameters'] = request.sourceHttpEventParametersShrink;
  }
  if (!Util.isUnset(request.sourceKafkaParametersShrink)) {
    body['SourceKafkaParameters'] = request.sourceKafkaParametersShrink;
  }
  if (!Util.isUnset(request.sourceMNSParametersShrink)) {
    body['SourceMNSParameters'] = request.sourceMNSParametersShrink;
  }
  if (!Util.isUnset(request.sourceRabbitMQParametersShrink)) {
    body['SourceRabbitMQParameters'] = request.sourceRabbitMQParametersShrink;
  }
  if (!Util.isUnset(request.sourceRocketMQParametersShrink)) {
    body['SourceRocketMQParameters'] = request.sourceRocketMQParametersShrink;
  }
  if (!Util.isUnset(request.sourceSLSParametersShrink)) {
    body['SourceSLSParameters'] = request.sourceSLSParametersShrink;
  }
  if (!Util.isUnset(request.sourceScheduledEventParametersShrink)) {
    body['SourceScheduledEventParameters'] = request.sourceScheduledEventParametersShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEventSource',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates an event source.
 *
 * @description You can call this API operation to update an event source.
 *
 * @param request UpdateEventSourceRequest
 * @return UpdateEventSourceResponse
 */
async function updateEventSource(request: UpdateEventSourceRequest): UpdateEventSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEventSourceWithOptions(request, runtime);
}

model UpdateEventStreamingRequest {
  description?: string(name='Description', description='The description of the event stream.', example='rocketmq2mns'),
  eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream.

This parameter is required.', example='myeventstreaming'),
  filterPattern?: string(name='FilterPattern', description='The rule that is used to filter events. If you leave this parameter empty, all events are matched.

This parameter is required.'),
  runOptions?: {
    batchWindow?: {
      countBasedWindow?: int32(name='CountBasedWindow', description='The maximum number of events that are allowed in the batch window. When this threshold is reached, data in the window is pushed to the downstream service. If multiple batch windows exist, data is pushed if triggering conditions are met in one of the windows.', example='100'),
      timeBasedWindow?: int32(name='TimeBasedWindow', description='The maximum period of time during which events are allowed in the batch window. Unit: seconds. When this threshold is reached, data in the window is pushed to the downstream service. If multiple batch windows exist, data is pushed if triggering conditions are met in one of the windows.', example='10'),
    }(name='BatchWindow', description='The batch window.'),
    deadLetterQueue?: {
      arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the dead-letter queue.', example='acs:ram::1317334647812936:role/rdstoecsassumekms'),
    }(name='DeadLetterQueue', description='Specifies whether to enable dead-letter queues. By default, dead-letter queues are disabled. Events that fail to be pushed are discarded after the maximum number of retries that is specified by the retry policy is reached.'),
    errorsTolerance?: string(name='ErrorsTolerance', description='The exception tolerance policy. Valid values: NONE and ALL.', example='ALL'),
    logDelivery?: {
      kafkaLogParameters?: [ 
        {
          endpoint?: string(name='Endpoint'),
          instanceId?: string(name='InstanceId'),
          topic?: string(name='Topic'),
        }
      ](name='KafkaLogParameters'),
      SLSLogParameters?: [ 
        {
          logstoreName?: string(name='LogstoreName'),
          projectName?: string(name='ProjectName'),
        }
      ](name='SLSLogParameters'),
    }(name='LogDelivery'),
    maximumTasks?: long(name='MaximumTasks', description='The maximum number of concurrent tasks.', example='2'),
    network?: {
      securityGroupId?: string(name='SecurityGroupId'),
      vSwitchIds?: [ string ](name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
    }(name='Network'),
    resourceSpec?: {
      resources?: [ 
        {
          type?: string(name='Type'),
          value?: int32(name='Value'),
        }
      ](name='Resources'),
    }(name='ResourceSpec'),
    retryStrategy?: {
      maximumEventAgeInSeconds?: long(name='MaximumEventAgeInSeconds', description='The maximum timeout period for a retry.', example='512'),
      maximumRetryAttempts?: long(name='MaximumRetryAttempts', description='The maximum number of retries.', example='2'),
      pushRetryStrategy?: string(name='PushRetryStrategy', description='The retry policy. Valid values: BACKOFF_RETRY and EXPONENTIAL_DECAY_RETRY.', example='BACKOFFRETRY'),
    }(name='RetryStrategy', description='The retry policy that you want to use if events fail to be pushed.'),
    roleName?: string(name='RoleName'),
    scaledObject?: {
      maxReplicaCount?: int32(name='MaxReplicaCount'),
      minReplicaCount?: int32(name='MinReplicaCount'),
      triggers?: [ 
        {
          metadata?: {
            type?: string(name='Type'),
            value?: int32(name='Value'),
          }(name='Metadata'),
          type?: string(name='Type'),
        }
      ](name='Triggers'),
    }(name='ScaledObject'),
  }(name='RunOptions', description='The parameters that are configured for the runtime environment.'),
  sink?: {
    sinkCustomizedKafkaConnectorParameters?: {
      connectorPackageUrl?: string(name='ConnectorPackageUrl'),
      connectorParameters?: {
        config?: map[string]any(name='Config'),
        name?: string(name='Name'),
      }(name='ConnectorParameters'),
      workerParameters?: map[string]any(name='WorkerParameters'),
    }(name='SinkCustomizedKafkaConnectorParameters'),
    sinkCustomizedKafkaParameters?: {
      instanceId?: string(name='InstanceId'),
    }(name='SinkCustomizedKafkaParameters'),
    sinkDataHubParameters?: {
      body?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Body'),
      contentSchema?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='ContentSchema'),
      contentType?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='ContentType'),
      project?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Project'),
      roleName?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='RoleName'),
      topic?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Topic'),
      topicSchema?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='TopicSchema'),
      topicType?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='TopicType'),
    }(name='SinkDataHubParameters'),
    sinkFcParameters?: {
      body?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
      }(name='Body', description='The message body that you want to deliver to the function.'),
      concurrency?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.', example='None'),
        value?: string(name='Value', description='The delivery concurrency. Minimum value: 1.', example='1'),
      }(name='Concurrency', description='The delivery concurrency. Minimum value: 1.'),
      functionName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The function name.', example='mFunction'),
      }(name='FunctionName', description='The function name.'),
      invocationType?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The invocation mode.', example='Async'),
      }(name='InvocationType', description='The invocation mode. Valid values: Sync and Async.'),
      qualifier?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The alias of the service to which the function belongs.', example='LATEST'),
      }(name='Qualifier', description='The alias of the service to which the function belongs.'),
      serviceName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The service name.', example='myService'),
      }(name='ServiceName', description='The service name.'),
    }(name='SinkFcParameters', description='The parameters that are configured if you specify Function Compute as the event target.'),
    sinkFnfParameters?: {
      executionName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.'),
        value?: string(name='Value', description='The execution name.', example='123'),
      }(name='ExecutionName', description='The execution name.'),
      flowName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.'),
        value?: string(name='Value', description='The flow name.', example='test-streaming-fnf'),
      }(name='FlowName', description='The flow name.'),
      input?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.'),
        value?: string(name='Value', description='The input information of the execution.', example='123'),
      }(name='Input', description='The input information of the execution.'),
      roleName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.'),
        value?: string(name='Value', description='The role name.', example='Al****FNF-x****'),
      }(name='RoleName', description='The role name.'),
    }(name='SinkFnfParameters', description='The parameters that are configured if you specify CloudFlow as the event target.'),
    sinkKafkaParameters?: {
      acks?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The ACK mode.

*   If you set this parameter to 0, no response is returned from the broker. In this mode, the performance is high, but the risk of data loss is also high.
*   If you set this parameter to 1, a response is returned when data is written to the leader. In this mode, the performance and the risk of data loss are moderate. Data loss may occur if a failure occurs on the leader.
*   If you set this parameter to all, a response is returned when data is written to the leader and synchronized to the followers. In this mode, the performance is low, but the risk of data loss is also low. Data loss occurs if the leader and the followers fail at the same time.', example='1'),
      }(name='Acks', description='The acknowledgment (ACK) mode.

*   If you set this parameter to 0, no response is returned from the broker. In this mode, the performance is high, but the risk of data loss is also high.
*   If you set this parameter to 1, a response is returned when data is written to the leader. In this mode, the performance and the risk of data loss are moderate. Data loss may occur if a failure occurs on the leader.
*   If you set this parameter to all, a response is returned when data is written to the leader and synchronized to the followers. In this mode, the performance is low, but the risk of data loss is also low. Data loss occurs if the leader and the followers fail at the same time.'),
      instanceId?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The ID of the ApsaraMQ for Kafka instance.', example='Defaut_1283278472_sadkj'),
      }(name='InstanceId', description='The ID of the ApsaraMQ for Kafka instance.'),
      key?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The message key.', example='key'),
      }(name='Key', description='The message key.'),
      topic?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The name of the topic on the ApsaraMQ for Kafka instance.', example='test'),
      }(name='Topic', description='The name of the topic on the ApsaraMQ for Kafka instance.'),
      value?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
      }(name='Value', description='The message body.'),
    }(name='SinkKafkaParameters', description='The parameters that are configured if you specify ApsaraMQ for Kafka as the event target.'),
    sinkMNSParameters?: {
      body?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
      }(name='Body', description='The message content.'),
      isBase64Encode?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='Specifies whether to enable Base64 encoding.', example='true'),
      }(name='IsBase64Encode', description='Specifies whether to enable Base64 encoding.'),
      queueName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The name of the MNS queue.', example='MyQueue'),
      }(name='QueueName', description='The name of the MNS queue.'),
    }(name='SinkMNSParameters', description='The parameters that are configured if you specify MNS as the event target.'),
    sinkPrometheusParameters?: {
      authorizationType?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The authentication method.', example='BASIC_AUTH'),
      }(name='AuthorizationType', description='The authentication method.'),
      data?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: JSONPATH.', example='JSONPATH'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The metric data.', example='$.data'),
      }(name='Data', description='The metric data.'),
      networkType?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The network type.', example='PrivateNetwork'),
      }(name='NetworkType', description='The network type.'),
      password?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The password.', example='abc'),
      }(name='Password', description='The password.'),
      securityGroupId?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The ID of the security group to which the Managed Service for Prometheus instance belongs.', example='sg-mw43*****'),
      }(name='SecurityGroupId', description='The ID of the security group to which the Managed Service for Prometheus instance belongs.'),
      URL?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The URL for the remote write configuration item of the Managed Service for Prometheus instance.'),
      }(name='URL', description='The URL for the remote write configuration item of the Managed Service for Prometheus instance.'),
      username?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The username.', example='***admin'),
      }(name='Username', description='The username.'),
      vSwitchId?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The ID of the vSwitch with which the Managed Service for Prometheus instance is associated.', example='vsw-dwaafds****'),
      }(name='VSwitchId', description='The ID of the vSwitch with which the Managed Service for Prometheus instance is associated.'),
      vpcId?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The ID of the VPC to which the Managed Service for Prometheus instance belongs.', example='vpc-adw1awdw*****'),
      }(name='VpcId', description='The ID of the VPC to which the Managed Service for Prometheus instance belongs.'),
    }(name='SinkPrometheusParameters', description='The parameters that are configured if you specify Managed Service for Prometheus as the event target.'),
    sinkRabbitMQParameters?: {
      body?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
      }(name='Body', description='The message content.'),
      exchange?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The name of the exchange on the ApsaraMQ for RabbitMQ instance.', example='a_exchange'),
      }(name='Exchange', description='The exchange mode. This parameter is required only if you set TargetType to Exchange.'),
      instanceId?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The ID of the ApsaraMQ for RabbitMQ instance.', example='amqp-cn-2r42e73o****'),
      }(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance.'),
      messageId?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
      }(name='MessageId', description='The message ID.'),
      properties?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
      }(name='Properties', description='The attributes that you want to use to filter messages.'),
      queueName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The name of the queue on the ApsaraMQ for RabbitMQ instance.', example='MyQueue'),
      }(name='QueueName', description='The queue mode. This parameter is required only if you set TargetType to Queue.'),
      routingKey?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The rule that you want to use to route messages.', example='housekeeping'),
      }(name='RoutingKey', description='The rule that you want to use to route messages. This parameter is required only if you set TargetType to Exchange.'),
      targetType?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The type of the resource to which you want to deliver events. Valid values:

*   Exchange
*   Queue', example='Exchange/Queue'),
      }(name='TargetType', description='The type of the resource to which you want to deliver events.'),
      virtualHostName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The name of the vhost to which the ApsaraMQ for RabbitMQ instance belongs.', example='rabbit-host'),
      }(name='VirtualHostName', description='The name of the vhost to which the ApsaraMQ for RabbitMQ instance belongs.'),
    }(name='SinkRabbitMQParameters', description='The parameters that are configured if you specify ApsaraMQ for RabbitMQ as the event target.'),
    sinkRocketMQParameters?: {
      body?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
      }(name='Body', description='The message content.'),
      instanceId?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The ID of the ApsaraMQ for RocketMQ instance.', example='MQ_INST_164901546557****_BAAN****'),
      }(name='InstanceId', description='The ID of the ApsaraMQ for RocketMQ instance.'),
      keys?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
      }(name='Keys', description='The attributes that you want to use to filter messages.'),
      properties?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
      }(name='Properties', description='The attributes that you want to use to filter messages.'),
      tags?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
      }(name='Tags', description='The attributes that you want to use to filter messages.'),
      topic?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The topic on the ApsaraMQ for RocketMQ instance.', example='Mytopic'),
      }(name='Topic', description='The topic on the ApsaraMQ for RocketMQ instance.'),
    }(name='SinkRocketMQParameters', description='The parameters that are configured if you specify ApsaraMQ for RocketMQ as the event target.'),
    sinkSLSParameters?: {
      body?: {
        form?: string(name='Form', description='The method that you want to use to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
      }(name='Body', description='The message body that is sent to Log Service.'),
      logStore?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The Simple Log Service Logstore.', example='test-logstore'),
      }(name='LogStore', description='The Simple Log Service Logstore.'),
      project?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The Simple Log Service project.', example='test-project'),
      }(name='Project', description='The Simple Log Service project.'),
      roleName?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The role name. If you want to authorize EventBridge to use this role to read logs in Simple Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the RAM console.', example='testRole'),
      }(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Simple Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the RAM console.'),
      topic?: {
        form?: string(name='Form', description='The method that you want to use to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The topic that you want to use to store logs. This parameter corresponds to the reserved field topic in Simple Log Service.', example='testTopic'),
      }(name='Topic', description='The topic that you want to use to store logs. This parameter corresponds to the reserved field topic in Simple Log Service.'),
    }(name='SinkSLSParameters', description='The parameters that are configured if you specify Simple Log Service as the event target.'),
  }(name='Sink', description='The event target. You must and can specify only one event target.

This parameter is required.'),
  source?: {
    sourceApacheKafkaParameters?: {
      bootstraps?: string(name='Bootstraps'),
      consumerGroup?: string(name='ConsumerGroup'),
      networkType?: string(name='NetworkType'),
      offsetReset?: string(name='OffsetReset'),
      saslMechanism?: string(name='SaslMechanism'),
      saslPassword?: string(name='SaslPassword'),
      saslUser?: string(name='SaslUser'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityProtocol?: string(name='SecurityProtocol'),
      topic?: string(name='Topic'),
      vSwitchIds?: string(name='VSwitchIds'),
      valueDataType?: string(name='ValueDataType'),
      vpcId?: string(name='VpcId'),
    }(name='SourceApacheKafkaParameters'),
    sourceCustomizedKafkaConnectorParameters?: {
      connectorPackageUrl?: string(name='ConnectorPackageUrl'),
      connectorParameters?: {
        config?: map[string]any(name='Config'),
        name?: string(name='Name'),
      }(name='ConnectorParameters'),
      workerParameters?: map[string]any(name='WorkerParameters'),
    }(name='SourceCustomizedKafkaConnectorParameters'),
    sourceCustomizedKafkaParameters?: {
      instanceId?: string(name='InstanceId'),
    }(name='SourceCustomizedKafkaParameters'),
    sourceDTSParameters?: {
      brokerUrl?: string(name='BrokerUrl', description='The URL and port number of the change tracking instance.'),
      initCheckPoint?: long(name='InitCheckPoint', description='The UNIX timestamp that is generated when the SDK client consumes the first data record.', example='1620962769'),
      password?: string(name='Password', description='The consumer group password.', example='admin'),
      sid?: string(name='Sid', description='The consumer group ID.', example='hkprdb'),
      taskId?: string(name='TaskId', description='The task ID.', example='f86e5814-b223-482c-b768-3b873297dade'),
      topic?: string(name='Topic', description='The name of the tracked topic of the change tracking instance.', example='LTC_CACHE_PRD'),
      username?: string(name='Username', description='The consumer group username.', example='admin'),
    }(name='SourceDTSParameters', description='The parameters that are configured if you specify Data Transmission Service (DTS) as the event source.'),
    sourceKafkaParameters?: {
      consumerGroup?: string(name='ConsumerGroup', description='The group ID of the consumer that subscribes to the topic.', example='DEFAULT_GROUP'),
      instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for Kafka instance.', example='i-8vbh4a5b9yfhgkkzm98f'),
      network?: string(name='Network', description='The network setting. Default value: Default. The value PublicNetwork specifies a virtual private cloud (VPC).', example='Default'),
      offsetReset?: string(name='OffsetReset', description='The offset from which messages are consumed.', example='latest'),
      regionId?: string(name='RegionId', description='The ID of the region where the ApsaraMQ for Kafka instance resides.', example='cn-zhangjiakou'),
      securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the ApsaraMQ for Kafka instance belongs.', example='sg-uf6jcm3y5hcs7hklytxh'),
      topic?: string(name='Topic', description='The name of the topic on the ApsaraMQ for Kafka instance.', example='topic_empower_1641539400786'),
      vSwitchIds?: string(name='VSwitchIds', description='The ID of the vSwitch with which the ApsaraMQ for Kafka instance is associated.', example='vsw-wz9t1l1e8eu2omwjazmtm'),
      valueDataType?: string(name='ValueDataType', description='The encoding or decoding method. Valid values: Json, Text, and Binary. The value Json specifies that binary data is decoded into strings based on UTF-8 encoding and then parsed into the JSON format. The value Text specifies that binary data is decoded into strings based on UTF-8 encoding and then put into the payload. The value Binary specifies that binary data is encoded into strings based on Base64 encoding and then put into the payload.', example='Text'),
      vpcId?: string(name='VpcId', description='The ID of the VPC to which the ApsaraMQ for Kafka instance belongs.', example='vpc-2ze6p0o345nykmekxtuop'),
    }(name='SourceKafkaParameters', description='The parameters that are configured if you specify ApsaraMQ for Kafka as the event source.'),
    sourceMNSParameters?: {
      isBase64Decode?: boolean(name='IsBase64Decode', description='Specifies whether to enable Base64 encoding. Default value: true.', example='true'),
      queueName?: string(name='QueueName', description='The name of the MNS queue.', example='queue_api_1642474203601'),
      regionId?: string(name='RegionId', description='The ID of the region where the MNS queue resides.', example='cn-hangzhou'),
    }(name='SourceMNSParameters', description='The parameters that are configured if you specify Message Service (MNS) as the event source.'),
    sourceMQTTParameters?: {
      instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance.', example='i-bp1dsudbecqwt61jqswt'),
      regionId?: string(name='RegionId', description='The ID of the region where the ApsaraMQ for MQTT instance resides.', example='cn-shanghai'),
      topic?: string(name='Topic', description='The name of the topic on the ApsaraMQ for MQTT instance.', example='topic_empower_1642400400779'),
    }(name='SourceMQTTParameters', description='The parameters that are configured if you specify ApsaraMQ for MQTT as the event source.'),
    sourcePrometheusParameters?: {
      clusterId?: string(name='ClusterId', description='The cluster ID.', example='c83555068b6******ad213f565f209'),
      dataType?: string(name='DataType', description='The data type.', example='json'),
      labels?: string(name='Labels', description='The labels.', example='__name__=.*'),
      regionId?: string(name='RegionId'),
    }(name='SourcePrometheusParameters', description='The parameters that are configured if you specify Managed Service for Prometheus as the event source.'),
    sourceRabbitMQParameters?: {
      instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance.', example='i-f8z9lqkldlb4oxsxwwub'),
      queueName?: string(name='QueueName', description='The name of the queue on the ApsaraMQ for RabbitMQ instance.', example='demo'),
      regionId?: string(name='RegionId', description='The ID of the region where the ApsaraMQ for RabbitMQ instance resides.', example='cn-hangzhou'),
      virtualHostName?: string(name='VirtualHostName', description='The name of the vhost to which the ApsaraMQ for RabbitMQ instance belongs.', example='eb-connect'),
    }(name='SourceRabbitMQParameters', description='The parameters that are configured if you specify ApsaraMQ for RabbitMQ as the event source.'),
    sourceRocketMQParameters?: {
      authType?: string(name='AuthType', description='The authentication method.', example='ACL'),
      bodyDataType?: string(name='BodyDataType'),
      filterSql?: string(name='FilterSql'),
      filterType?: string(name='FilterType'),
      groupID?: string(name='GroupID', description='The ID of the consumer group on the ApsaraMQ for RocketMQ instance.', example='GID_test'),
      instanceEndpoint?: string(name='InstanceEndpoint', description='The endpoint that is used to access the ApsaraMQ for RocketMQ instance.', example='reg****-vpc.cn-zhangjiakou.aliyuncs.com'),
      instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for RocketMQ instance.', example='i-f8z9a9mcgwri1c1idd0e'),
      instanceNetwork?: string(name='InstanceNetwork', description='The network type of the ApsaraMQ for RocketMQ instance. Valid values:

PublicNetwork and PrivateNetwork.', example='PublicNetwork'),
      instancePassword?: string(name='InstancePassword', description='The password that is used to access the ApsaraMQ for RocketMQ instance.', example='admin'),
      instanceSecurityGroupId?: string(name='InstanceSecurityGroupId', description='The ID of the security group to which the ApsaraMQ for RocketMQ instance belongs.', example='sg-m5edtu24f12345****'),
      instanceType?: string(name='InstanceType', description='The type of the ApsaraMQ for RocketMQ instance.', example='2'),
      instanceUsername?: string(name='InstanceUsername', description='The username that is used to access the ApsaraMQ for RocketMQ instance.', example='admin'),
      instanceVSwitchIds?: string(name='InstanceVSwitchIds', description='The ID of the vSwitch with which the ApsaraMQ for RocketMQ instance is associated.', example='vsw-m5ev8asdc6h12****'),
      instanceVpcId?: string(name='InstanceVpcId', description='The ID of the VPC to which the ApsaraMQ for RocketMQ instance belongs.', example='vpc-m5e3sv4b12345****'),
      network?: string(name='Network'),
      offset?: string(name='Offset', description='The offset from which messages are consumed. Valid values:

*   CONSUMEFROMLASTOFFSET: Messages are consumed from the latest offset.
*   CONSUMEFROMFIRSTOFFSET: Messages are consumed from the earliest offset.
*   CONSUMEFROMTIMESTAMP: Messages are consumed from the offset at the specified point in time.

Default value: CONSUMEFROMLASTOFFSET.', example='CONSUMEFROMLASTOFFSET'),
      regionId?: string(name='RegionId', description='The ID of the region where the ApsaraMQ for RocketMQ instance resides.', example='cn-shanghai'),
      securityGroupId?: string(name='SecurityGroupId'),
      tag?: string(name='Tag', description='The tag that you want to use to filter messages.', example='test'),
      timestamp?: long(name='Timestamp', description='The timestamp that specifies the time from which messages are consumed. This parameter is valid only if you set Offset to CONSUMEFROMTIMESTAMP.', example='1670656652009'),
      topic?: string(name='Topic', description='The name of the topic on the ApsaraMQ for RocketMQ instance.', example='TOPIC-cainiao-pcs-order-process-inBoundConditionCheck'),
      vSwitchIds?: string(name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
    }(name='SourceRocketMQParameters', description='The parameters that are configured if you specify ApsaraMQ for RocketMQ as the event source.'),
    sourceSLSParameters?: {
      roleName?: string(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Simple Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the Resource Access Management (RAM) console.', example='testRole'),
    }(name='SourceSLSParameters', description='The parameters that are configured if you specify Simple Log Service as the event source.'),
  }(name='Source', description='The event provider, which is also known as the event source. You must and can specify only one event source.

This parameter is required.'),
  transforms?: [ 
    {
      arn?: string(name='Arn', example='acs:fc:cn-hangzhou:*****:services/demo-service.LATEST/functions/demo-func'),
    }
  ](name='Transforms'),
}

model UpdateEventStreamingShrinkRequest {
  description?: string(name='Description', description='The description of the event stream.', example='rocketmq2mns'),
  eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream.

This parameter is required.', example='myeventstreaming'),
  filterPattern?: string(name='FilterPattern', description='The rule that is used to filter events. If you leave this parameter empty, all events are matched.

This parameter is required.'),
  runOptionsShrink?: string(name='RunOptions', description='The parameters that are configured for the runtime environment.'),
  sinkShrink?: string(name='Sink', description='The event target. You must and can specify only one event target.

This parameter is required.'),
  sourceShrink?: string(name='Source', description='The event provider, which is also known as the event source. You must and can specify only one event source.

This parameter is required.'),
  transformsShrink?: string(name='Transforms'),
}

model UpdateEventStreamingResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For more information about error codes, see Error codes.', example='Success'),
  message?: string(name='Message', description='The returned error message.', example='The name [xxxx] of event streaming in request is already exist!'),
  requestId?: string(name='RequestId', description='The request ID.', example='0FDD73AA-7A2D-5BD4-B4C0-88AFEBF5F0F5'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model UpdateEventStreamingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateEventStreamingResponseBody(name='body'),
}

/**
 * @summary Modifies the information about an event stream, such as the basic information and the information about the event source, event filtering rule, and event target.
 *
 * @description You can call this API operation to modify the information about an event stream, such as the basic information and the information about the event source, event filtering rule, and event target.
 *
 * @param tmpReq UpdateEventStreamingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEventStreamingResponse
 */
async function updateEventStreamingWithOptions(tmpReq: UpdateEventStreamingRequest, runtime: Util.RuntimeOptions): UpdateEventStreamingResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateEventStreamingShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.runOptions)) {
    request.runOptionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.runOptions, 'RunOptions', 'json');
  }
  if (!Util.isUnset(tmpReq.sink)) {
    request.sinkShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sink, 'Sink', 'json');
  }
  if (!Util.isUnset(tmpReq.source)) {
    request.sourceShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.source, 'Source', 'json');
  }
  if (!Util.isUnset(tmpReq.transforms)) {
    request.transformsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.transforms, 'Transforms', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  if (!Util.isUnset(request.filterPattern)) {
    body['FilterPattern'] = request.filterPattern;
  }
  if (!Util.isUnset(request.runOptionsShrink)) {
    body['RunOptions'] = request.runOptionsShrink;
  }
  if (!Util.isUnset(request.sinkShrink)) {
    body['Sink'] = request.sinkShrink;
  }
  if (!Util.isUnset(request.sourceShrink)) {
    body['Source'] = request.sourceShrink;
  }
  if (!Util.isUnset(request.transformsShrink)) {
    body['Transforms'] = request.transformsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the information about an event stream, such as the basic information and the information about the event source, event filtering rule, and event target.
 *
 * @description You can call this API operation to modify the information about an event stream, such as the basic information and the information about the event source, event filtering rule, and event target.
 *
 * @param request UpdateEventStreamingRequest
 * @return UpdateEventStreamingResponse
 */
async function updateEventStreaming(request: UpdateEventStreamingRequest): UpdateEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEventStreamingWithOptions(request, runtime);
}

model UpdateRuleRequest {
  description?: string(name='Description', description='The description of the event bus.', example='demo'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus.

This parameter is required.', example='hw-test'),
  filterPattern?: string(name='FilterPattern', description='The event pattern, in JSON format. Valid values: stringEqual stringExpression Each field can have a maximum of five expressions in the map data structure.

Each field can have a maximum of five expressions in the map data structure.

This parameter is required.', example='{\\\\"source\\\\":[\\\\"acs.oss\\\\"],\\\\"type\\\\":[\\\\"oss:BucketQueried:GetBucketStat\\\\"]}'),
  ruleName?: string(name='RuleName', description='The name of the event rule.

This parameter is required.', example='tf-testacc-rule'),
  status?: string(name='Status', description='The status of the event rule. Valid values: ENABLE: The event rule is enabled. It is the default state of the event rule. DISABLE: The event rule is disabled.', example='ENABLE'),
}

model UpdateRuleResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code 200 indicates that the request was successful.', example='200'),
  data?: boolean(name='Data', description='The result of the operation.', example='true'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='EventRuleFilterPatternSchemaError'),
  requestId?: string(name='RequestId', description='The request ID.', example='7439944D-D9FC-5614-B65E-07A468988924'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='true'),
}

model UpdateRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRuleResponseBody(name='body'),
}

/**
 * @summary Updates the configurations of an event rule.
 *
 * @description You can call this API operation to update the configurations of an event rule.
 *
 * @param request UpdateRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRuleResponse
 */
async function updateRuleWithOptions(request: UpdateRuleRequest, runtime: Util.RuntimeOptions): UpdateRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.filterPattern)) {
    query['FilterPattern'] = request.filterPattern;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the configurations of an event rule.
 *
 * @description You can call this API operation to update the configurations of an event rule.
 *
 * @param request UpdateRuleRequest
 * @return UpdateRuleResponse
 */
async function updateRule(request: UpdateRuleRequest): UpdateRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRuleWithOptions(request, runtime);
}

