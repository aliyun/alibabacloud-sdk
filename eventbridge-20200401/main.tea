/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('eventbridge', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateApiDestinationRequest {
  apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination. The name must be 2 to 127 characters in length.', example='api-destination-name'),
  connectionName?: string(name='ConnectionName', description='The name of the connection. The name must be 2 to 127 characters in length.

> 
>  Before you configure this parameter, you must call the CreateConnection operation to create a connection. Then, set this parameter to the name of the connection that you created.', example='connection-name'),
  description?: string(name='Description', description='The description of the API destination. The description can be up to 255 characters in length.'),
  httpApiParameters?: {
    endpoint?: string(name='Endpoint', description='The endpoint of the API destination. The endpoint can be up to 127 characters in length.', example='http://127.0.0.1:8001/api'),
    method?: string(name='Method', description='The HTTP request method. Valid values:

*   GET
*   POST
*   HEAD
*   DELETE
*   PUT
*   PATCH', example='POST'),
  }(name='HttpApiParameters', description='The parameters that are configured for the API destination.'),
}

model CreateApiDestinationShrinkRequest {
  apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination. The name must be 2 to 127 characters in length.', example='api-destination-name'),
  connectionName?: string(name='ConnectionName', description='The name of the connection. The name must be 2 to 127 characters in length.

> 
>  Before you configure this parameter, you must call the CreateConnection operation to create a connection. Then, set this parameter to the name of the connection that you created.', example='connection-name'),
  description?: string(name='Description', description='The description of the API destination. The description can be up to 255 characters in length.'),
  httpApiParametersShrink?: string(name='HttpApiParameters', description='The parameters that are configured for the API destination.'),
}

model CreateApiDestinationResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  date?: {
    apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination.', example='ApiDestinationName'),
  }(name='Date', description='The data returned if the API destination is created.'),
  message?: string(name='Message', description='The returned message.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='5DAF96FB-A4B6-548C-B999-0BFDCB2261B9'),
}

model CreateApiDestinationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateApiDestinationResponseBody(name='body'),
}

/**
  * You can call this API operation to create an API destination.
  *
  * @param tmpReq CreateApiDestinationRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateApiDestinationResponse
 */
async function createApiDestinationWithOptions(tmpReq: CreateApiDestinationRequest, runtime: Util.RuntimeOptions): CreateApiDestinationResponse {
  Util.validateModel(tmpReq);
  var request = new CreateApiDestinationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.httpApiParameters)) {
    request.httpApiParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.httpApiParameters, 'HttpApiParameters', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.apiDestinationName)) {
    query['ApiDestinationName'] = request.apiDestinationName;
  }
  if (!Util.isUnset(request.connectionName)) {
    query['ConnectionName'] = request.connectionName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.httpApiParametersShrink)) {
    query['HttpApiParameters'] = request.httpApiParametersShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateApiDestination',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to create an API destination.
  *
  * @param request CreateApiDestinationRequest
  * @return CreateApiDestinationResponse
 */
async function createApiDestination(request: CreateApiDestinationRequest): CreateApiDestinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApiDestinationWithOptions(request, runtime);
}

model CreateConnectionRequest {
  authParameters?: {
    apiKeyAuthParameters?: {
      apiKeyName?: string(name='ApiKeyName', description='The key of the API key.', example='Token'),
      apiKeyValue?: string(name='ApiKeyValue', description='The value of the API key.', example='adkjnakddh****'),
    }(name='ApiKeyAuthParameters', description='The parameters that are configured for API key authentication.'),
    authorizationType?: string(name='AuthorizationType', description='The authentication type. Valid values:

BASIC_AUTH: basic authentication.

Introduction: Basic authentication is a simple authentication scheme built into the HTTP protocol. When you use the HTTP protocol for communications, the authentication method that the HTTP server uses to authenticate user identities on the client is defined in the protocol. The request header is in the Authorization: Basic Base64-encoded string (Username:Password) format.

1.  Username and Password are required.

API_KEY_AUTH: API key authentication.

Introduction: The request header is in the Token: Token value format.

*   ApiKeyName and ApiKeyValue are required.

OAUTH_AUTH: OAuth authentication.

Introduction: OAuth2.0 is an authentication mechanism. In normal cases, a system that does not use OAuth2.0 can access the resources of the server from the client. To ensure access security, access tokens are used to authenticate users in OAuth 2.0. The client must use an access token to access protected resources. This way, OAuth 2.0 protects resources from being accessed from malicious clients and improves system security.

*   AuthorizationEndpoint, OAuthHttpParameters, and HttpMethod are required.', example='BASIC_AUTH'),
    basicAuthParameters?: {
      password?: string(name='Password', description='The password for basic authentication.', example='*******'),
      username?: string(name='Username', description='The username for basic authentication.', example='admin'),
    }(name='BasicAuthParameters', description='The parameters that are configured for basic authentication.'),
    OAuthParameters?: {
      authorizationEndpoint?: string(name='AuthorizationEndpoint', description='The IP address of the authorized endpoint. The default value of a column can be up to 127 characters in length.', example='http://localhost:8080/oauth/token'),
      clientParameters?: {
        clientID?: string(name='ClientID', description='The client ID.', example='ClientID'),
        clientSecret?: string(name='ClientSecret', description='The AccessKey secret of the client.', example='Qo57Q~F249~S74GmNPA36pZJoJK4f4LY****'),
      }(name='ClientParameters', description='The parameters that are configured for the client.'),
      httpMethod?: string(name='HttpMethod', description='The HTTP request method. Valid values:

*   GET
*   POST
*   HEAD
*   DELETE
*   PUT
*   PATCH', example='POST'),
      OAuthHttpParameters?: {
        bodyParameters?: [ 
          {
            isValueSecret?: string(name='IsValueSecret', description='Specifies whether to enable authentication.', example='false'),
            key?: string(name='Key', description='The key of the request body.', example='keyDemo'),
            value?: string(name='Value', description='The value of the request body.', example='keyValue'),
          }
        ](name='BodyParameters', description='The parameters that are configured for the request body.'),
        headerParameters?: [ 
          {
            isValueSecret?: string(name='IsValueSecret', description='Specifies whether to enable authentication.', example='false'),
            key?: string(name='Key', description='The key of the request header.', example='keyDemo'),
            value?: string(name='Value', description='The value of the request header.', example='keyValue'),
          }
        ](name='HeaderParameters', description='The parameters that are configured for the request header.'),
        queryStringParameters?: [ 
          {
            isValueSecret?: string(name='IsValueSecret', description='Specifies whether to enable authentication.', example='false'),
            key?: string(name='Key', description='The key of the request path.', example='keyDemo'),
            value?: string(name='Value', description='The value of the request path.', example='valueDemo'),
          }
        ](name='QueryStringParameters', description='The parameters that are configured for the request path.'),
      }(name='OAuthHttpParameters', description='The request parameters that are configured for OAuth authentication.'),
    }(name='OAuthParameters', description='The parameters that are configured for OAuth authentication.'),
  }(name='AuthParameters', description='The parameters that are configured for authentication.'),
  connectionName?: string(name='ConnectionName', description='The name of the connection. The name must be 2 to 127 characters in length.', example='connection-name'),
  description?: string(name='Description', description='The description of the connection. The description can be up to 255 characters in length.', example='demo'),
  networkParameters?: {
    networkType?: string(name='NetworkType', description='The network type. Valid values:

PublicNetwork and PrivateNetwork.

*   Note: If you set this parameter to PrivateNetwork, you must configure VpcId, VswitcheId, and SecurityGroupId.', example='PublicNetwork'),
    securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', example='eb-167adad548759-security_grop/sg-bp1addad26peuh9qh9****'),
    vpcId?: string(name='VpcId', description='The VPC. ID', example='eb-test/vpc-bp1symadadwnwg****'),
    vswitcheId?: string(name='VswitcheId', description='The vSwitch ID.', example='vsw-bp1iu4x7aeradadown1og8,vsw-bp193sqmadadlaszpeq****'),
  }(name='NetworkParameters', description='The parameters that are configured for the network.'),
}

model CreateConnectionShrinkRequest {
  authParametersShrink?: string(name='AuthParameters', description='The parameters that are configured for authentication.'),
  connectionName?: string(name='ConnectionName', description='The name of the connection. The name must be 2 to 127 characters in length.', example='connection-name'),
  description?: string(name='Description', description='The description of the connection. The description can be up to 255 characters in length.', example='demo'),
  networkParametersShrink?: string(name='NetworkParameters', description='The parameters that are configured for the network.'),
}

model CreateConnectionResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  data?: {
    connectionName?: string(name='ConnectionName', description='The connection name.', example='connection-demo'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message. If the request is successful, success is returned. If the request failed, an error code is returned.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='7DA60DED-CD36-5837-B848-C01A23D2****'),
}

model CreateConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateConnectionResponseBody(name='body'),
}

/**
  * You can call this API operation to create a connection.
  *
  * @param tmpReq CreateConnectionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateConnectionResponse
 */
async function createConnectionWithOptions(tmpReq: CreateConnectionRequest, runtime: Util.RuntimeOptions): CreateConnectionResponse {
  Util.validateModel(tmpReq);
  var request = new CreateConnectionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.authParameters)) {
    request.authParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.authParameters, 'AuthParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.networkParameters)) {
    request.networkParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.networkParameters, 'NetworkParameters', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.authParametersShrink)) {
    query['AuthParameters'] = request.authParametersShrink;
  }
  if (!Util.isUnset(request.connectionName)) {
    query['ConnectionName'] = request.connectionName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.networkParametersShrink)) {
    query['NetworkParameters'] = request.networkParametersShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateConnection',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to create a connection.
  *
  * @param request CreateConnectionRequest
  * @return CreateConnectionResponse
 */
async function createConnection(request: CreateConnectionRequest): CreateConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConnectionWithOptions(request, runtime);
}

model CreateEventBusRequest {
  description?: string(name='Description', description='The description of the event bus.', example='demo'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='MyEventBus'),
}

model CreateEventBusResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For more information about error codes, see Error codes.', example='Success'),
  data?: {
    eventBusARN?: string(name='EventBusARN', description='The Alibaba Cloud Resource Name (ARN) of the event bus.', example='acs:eventbridge:cn-hangzhou:123456789098****:eventbus/MyEventBus'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='The event bus [xxxx] not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='A995F07C-E503-5881-9962-9CECA8566876'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. The value true indicates that the request is successful.', example='true'),
}

model CreateEventBusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEventBusResponseBody(name='body'),
}

/**
  * You can call this API operation to create an event bus.
  *
  * @param request CreateEventBusRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateEventBusResponse
 */
async function createEventBusWithOptions(request: CreateEventBusRequest, runtime: Util.RuntimeOptions): CreateEventBusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEventBus',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to create an event bus.
  *
  * @param request CreateEventBusRequest
  * @return CreateEventBusResponse
 */
async function createEventBus(request: CreateEventBusRequest): CreateEventBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEventBusWithOptions(request, runtime);
}

model CreateEventSourceRequest {
  description?: string(name='Description', description='The description of the event source.'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus with which the event source is associated.', example='my-event-bus'),
  eventSourceName?: string(name='EventSourceName', description='The name of the event source.', example='myrabbitmq.sourc'),
  sourceHttpEventParameters?: {
    ip?: [ string ](name='Ip', description='The CIDR block that is used for security settings. This parameter is required only if you set SecurityConfig to ip. You can enter a CIDR block or an IP address.'),
    method?: [ string ](name='Method', description='The HTTP request method supported by the generated webhook URL. You can select multiple values. Valid values:

*   GET
*   POST
*   PUT
*   PATCH
*   DELETE
*   HEAD
*   OPTIONS
*   TRACE
*   CONNECT'),
    referer?: [ string ](name='Referer', description='The security domain name. This parameter is required only if you set SecurityConfig to referer. You can enter a domain name.'),
    securityConfig?: string(name='SecurityConfig', description='The type of security settings. Valid values:

*   none: No configuration is required.
*   ip: CIDR block.
*   referer: security domain name.', example='none'),
    type?: string(name='Type', description='The protocol type that is supported by the generated webhook URL. Valid values:

*   HTTP
*   HTTPS
*   HTTP\\&HTTPS', example='HTTPS'),
  }(name='SourceHttpEventParameters', description='The parameters that are configured if the event source is HTTP events.'),
  sourceKafkaParameters?: {
    consumerGroup?: string(name='ConsumerGroup', description='The ID of the consumer group that subscribes to the topic.', example='wechat_peer_prod'),
    instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache Kafka instance.', example='pc-2zehmg67txzuyuuwlxv4f'),
    maximumTasks?: int32(name='MaximumTasks', description='The maximum number of consumers.', example='1'),
    network?: string(name='Network', description='The network. Valid values: Default and PublicNetwork. Default value: Default. The value PublicNetwork indicates a self-managed network.', example='Default'),
    offsetReset?: string(name='OffsetReset', description='The consumer offset.', example='latest'),
    regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for Apache Kafka instance resides.', example='cn-hangzhou'),
    securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the Message Queue for Apache Kafka instance belongs. This parameter is required only if you set Network to PublicNetwork.', example='sg-8vbf66aoyp0wfzrzxlmy'),
    topic?: string(name='Topic', description='The name of the topic on the Message Queue for Apache Kafka instance.', example='prod_ma_dispatch_center_call_record'),
    vSwitchIds?: string(name='VSwitchIds', description='The ID of the vSwitch with which the Message Queue for Apache Kafka instance is associated. This parameter is required only if you set Network to PublicNetwork.', example='vsw-bp127azpeirmwu4q9ttqi'),
    vpcId?: string(name='VpcId', description='The ID of the VPC in which the Message Queue for Apache Kafka instance resides. This parameter is required only if you set Network to PublicNetwork.', example='vpc-2ze5ejm986a73qq3vshlk'),
  }(name='SourceKafkaParameters', description='The parameters that are configured if the event source is Message Queue for Apache Kafka.'),
  sourceMNSParameters?: {
    isBase64Decode?: boolean(name='IsBase64Decode', description='Specifies whether to enable Base64 decoding. Valid values: true and false.', example='true'),
    queueName?: string(name='QueueName', description='The name of the MNS queue.', example='MyQueue'),
    regionId?: string(name='RegionId', description='The region where the MNS queue resides. Valid values: cn-qingdao, cn-beijing, cn-zhangjiakou, cn-huhehaote, cn-wulanchabu, cn-hangzhou, cn-shanghai, cn-shenzhen, cn-guangzhou, cn-chengdu, cn-hongkong, ap-southeast-1, ap-southeast-2, ap-southeast-3, ap-southeast-5, ap-northeast-1, eu-central-1, us-west-1, us-east-1, ap-south-1, me-east-1, and cn-north-2-gov-1.', example='cn-hangzhou'),
  }(name='SourceMNSParameters', description='The parameters that are configured if the event source is Message Service (MNS). If you specify MNS as the event source, you must configure RegionId, IsBase64Decode, and QueueName.'),
  sourceRabbitMQParameters?: {
    instanceId?: string(name='InstanceId', description='The ID of the Message Queue for RabbitMQ instance. For more information, see Limits.', example='amqp-cn-nif22u74****'),
    queueName?: string(name='QueueName', description='The name of the queue on the Message Queue for RabbitMQ instance. For more information, see [Limits](~~163289~~).', example='demo'),
    regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for RabbitMQ instance resides.', example='cn-hangzhou'),
    virtualHostName?: string(name='VirtualHostName', description='The name of the vhost of the Message Queue for RabbitMQ instance. For more information, see [Limits](~~163289~~).', example='eb-connect'),
  }(name='SourceRabbitMQParameters', description='The parameters that are configured if the event source is Message Queue for RabbitMQ.'),
  sourceRocketMQParameters?: {
    authType?: string(name='AuthType', description='The authentication type. You can set this parameter to ACL or leave this parameter empty.', example='ACL'),
    groupID?: string(name='GroupID', description='The ID of the consumer group on the Message Queue for Apache RocketMQ instance.', example='GID-test'),
    instanceEndpoint?: string(name='InstanceEndpoint', description='The endpoint that is used to access the Message Queue for Apache RocketMQ instance.', example='registry-vpc****.aliyuncs.com'),
    instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ instance. For more information, see [Limits](~~163289~~).', example='MQ_INST_164901546557****_BAAN****'),
    instanceNetwork?: string(name='InstanceNetwork', description='None.', example='None'),
    instancePassword?: string(name='InstancePassword', description='The password that is used to access the Message Queue for Apache RocketMQ instance.', example='******'),
    instanceSecurityGroupId?: string(name='InstanceSecurityGroupId', description='The ID of the security group to which the Message Queue for Apache RocketMQ instance belongs.', example='sg-catalog-eventlistener'),
    instanceType?: string(name='InstanceType', description='The type of the Message Queue for Apache RocketMQ instance. Valid values:

*   Cloud\\_4: Message Queue for Apache RocketMQ 4.0 instance.
*   Cloud\\_5: Message Queue for Apache RocketMQ 5.0 instance.', example='Cloud_4'),
    instanceUsername?: string(name='InstanceUsername', description='The username that is used to access the Message Queue for Apache RocketMQ instance.', example='root'),
    instanceVSwitchIds?: string(name='InstanceVSwitchIds', description='The ID of the vSwitch with which the Message Queue for Apache RocketMQ instance is associated.', example='vsw-bp10rbrt6rb6vrd89****'),
    instanceVpcId?: string(name='InstanceVpcId', description='The ID of the virtual private cloud (VPC) in which the Message Queue for Apache RocketMQ instance resides.', example='vpc-bp1a4gmlk31hyg6ptl3ss'),
    offset?: string(name='Offset', description='The offset from which message consumption starts. Valid values: CONSUME_FROM_LAST_OFFSET: Start message consumption from the latest offset. CONSUME_FROM_FIRST_OFFSET: Start message consumption from the earliest offset. CONSUME_FROM_TIMESTAMP: Start message consumption from the offset at the specified point in time. Default value: CONSUME_FROM_LAST_OFFSET.', example='CONSUME_FROM_LAST_OFFSET'),
    regionId?: string(name='RegionId', description='The region where the Message Queue for Apache RocketMQ instance resides.', example='cn-hangzhou'),
    tag?: string(name='Tag', description='The tag that is used to filter messages.', example='test'),
    timestamp?: long(name='Timestamp', description='The timestamp that specifies the time from which messages are consumed. This parameter is valid only if you set Offset to CONSUME_FROM_TIMESTAMP.', example='1636597951964'),
    topic?: string(name='Topic', description='The name of the topic on the Message Queue for Apache RocketMQ instance. For more information, see [Limits](~~163289~~).', example='mytopic'),
  }(name='SourceRocketMQParameters', description='The parameters that are configured if the event source is Message Queue for Apache RocketMQ.'),
  sourceSLSParameters?: {
    consumePosition?: string(name='ConsumePosition', description='The starting consumer offset. The value begin specifies the earliest offset, and the value end specifies the latest offset. You can also specify a time in seconds to start consumption.', example='end'),
    logStore?: string(name='LogStore', description='The Log Service Logstore.', example='test-logstore'),
    project?: string(name='Project', description='The Log Service project.', example='test-project'),
    roleName?: string(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the Resource Access Management (RAM) console. For information about the permission policy of this role, see Create a custom event source of the Log Service type.', example='testRole'),
  }(name='SourceSLSParameters', description='The parameters that are configured if the event source is Log Service.'),
  sourceScheduledEventParameters?: {
    schedule?: string(name='Schedule', description='The cron expression.', example='10 * * * * *'),
    timeZone?: string(name='TimeZone', description='The time zone in which the cron expression is executed.', example='GMT+0:00'),
    userData?: string(name='UserData'),
  }(name='SourceScheduledEventParameters', description='The parameters that are configured if the event source is scheduled events.'),
}

model CreateEventSourceShrinkRequest {
  description?: string(name='Description', description='The description of the event source.'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus with which the event source is associated.', example='my-event-bus'),
  eventSourceName?: string(name='EventSourceName', description='The name of the event source.', example='myrabbitmq.sourc'),
  sourceHttpEventParametersShrink?: string(name='SourceHttpEventParameters', description='The parameters that are configured if the event source is HTTP events.'),
  sourceKafkaParametersShrink?: string(name='SourceKafkaParameters', description='The parameters that are configured if the event source is Message Queue for Apache Kafka.'),
  sourceMNSParametersShrink?: string(name='SourceMNSParameters', description='The parameters that are configured if the event source is Message Service (MNS). If you specify MNS as the event source, you must configure RegionId, IsBase64Decode, and QueueName.'),
  sourceRabbitMQParametersShrink?: string(name='SourceRabbitMQParameters', description='The parameters that are configured if the event source is Message Queue for RabbitMQ.'),
  sourceRocketMQParametersShrink?: string(name='SourceRocketMQParameters', description='The parameters that are configured if the event source is Message Queue for Apache RocketMQ.'),
  sourceSLSParametersShrink?: string(name='SourceSLSParameters', description='The parameters that are configured if the event source is Log Service.'),
  sourceScheduledEventParametersShrink?: string(name='SourceScheduledEventParameters', description='The parameters that are configured if the event source is scheduled events.'),
}

model CreateEventSourceResponseBody = {
  code?: string(name='Code', description='The returned response code. Valid values:

*   Success: The request is successful.
*   Other codes: The request failed. For more information about error codes, see Error codes.', example='Success'),
  data?: {
    eventSourceARN?: string(name='EventSourceARN', description='The Alibaba Cloud Resource Name (ARN) of the resource.', example='acs:eventbridge:cn-hangzhou:164901546557****:eventbus/my-event-bus/eventsource/mymns.source'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='Remote error. requestId: [A8EFABD2-95B9-1C46-9E01-xxxx], error code: [CreateRelatedResourceFailed], message: [Create related resource failed, EntityNotExist.Role : The role not exists: xxxx. \\r\\nRequestId : xxxx-168C-54ED-8FEB-BF11CB70AEB7]'),
  requestId?: string(name='RequestId', description='The request ID.', example='2922208e-e1c6-43ee-bfd1-aca50263bc8a'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. The value true indicates that the operation is successful.', example='true'),
}

model CreateEventSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEventSourceResponseBody(name='body'),
}

/**
  * You can call this operation to create an event source.
  *
  * @param tmpReq CreateEventSourceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateEventSourceResponse
 */
async function createEventSourceWithOptions(tmpReq: CreateEventSourceRequest, runtime: Util.RuntimeOptions): CreateEventSourceResponse {
  Util.validateModel(tmpReq);
  var request = new CreateEventSourceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.sourceHttpEventParameters)) {
    request.sourceHttpEventParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceHttpEventParameters, 'SourceHttpEventParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceKafkaParameters)) {
    request.sourceKafkaParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceKafkaParameters, 'SourceKafkaParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceMNSParameters)) {
    request.sourceMNSParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceMNSParameters, 'SourceMNSParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceRabbitMQParameters)) {
    request.sourceRabbitMQParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceRabbitMQParameters, 'SourceRabbitMQParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceRocketMQParameters)) {
    request.sourceRocketMQParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceRocketMQParameters, 'SourceRocketMQParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceSLSParameters)) {
    request.sourceSLSParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceSLSParameters, 'SourceSLSParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceScheduledEventParameters)) {
    request.sourceScheduledEventParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceScheduledEventParameters, 'SourceScheduledEventParameters', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    body['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventSourceName)) {
    body['EventSourceName'] = request.eventSourceName;
  }
  if (!Util.isUnset(request.sourceHttpEventParametersShrink)) {
    body['SourceHttpEventParameters'] = request.sourceHttpEventParametersShrink;
  }
  if (!Util.isUnset(request.sourceKafkaParametersShrink)) {
    body['SourceKafkaParameters'] = request.sourceKafkaParametersShrink;
  }
  if (!Util.isUnset(request.sourceMNSParametersShrink)) {
    body['SourceMNSParameters'] = request.sourceMNSParametersShrink;
  }
  if (!Util.isUnset(request.sourceRabbitMQParametersShrink)) {
    body['SourceRabbitMQParameters'] = request.sourceRabbitMQParametersShrink;
  }
  if (!Util.isUnset(request.sourceRocketMQParametersShrink)) {
    body['SourceRocketMQParameters'] = request.sourceRocketMQParametersShrink;
  }
  if (!Util.isUnset(request.sourceSLSParametersShrink)) {
    body['SourceSLSParameters'] = request.sourceSLSParametersShrink;
  }
  if (!Util.isUnset(request.sourceScheduledEventParametersShrink)) {
    body['SourceScheduledEventParameters'] = request.sourceScheduledEventParametersShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEventSource',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this operation to create an event source.
  *
  * @param request CreateEventSourceRequest
  * @return CreateEventSourceResponse
 */
async function createEventSource(request: CreateEventSourceRequest): CreateEventSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEventSourceWithOptions(request, runtime);
}

model CreateEventStreamingRequest {
  description?: string(name='Description', description='The description of the event stream.', example='rocketmq2mns'),
  eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream.', example='myeventstreaming'),
  filterPattern?: string(name='FilterPattern', description='The rule that is used to filter events. If you leave this parameter empty, all events are matched.'),
  runOptions?: {
    batchWindow?: {
      countBasedWindow?: int32(name='CountBasedWindow', description='The maximum number of events that is allowed in the batch window. When this threshold is reached, data in the window is pushed to the downstream service. If multiple batch windows exist, data is pushed if triggering conditions are met in one of the windows.', example='100'),
      timeBasedWindow?: int32(name='TimeBasedWindow', description='The maximum period of time during which events are allowed in the batch window. Unit: seconds. When this threshold is reached, data in the window is pushed to the downstream service. If multiple batch windows exist, data is pushed if triggering conditions are met in one of the windows.', example='10'),
    }(name='BatchWindow', description='The batch window.'),
    deadLetterQueue?: {
      arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the dead-letter queue.', example='acs:ram::1317334647812936:role/rdstoecsassumekms'),
    }(name='DeadLetterQueue', description='Specifies whether to enable dead-letter queues. By default, dead-letter queues are disabled. Messages that fail to be pushed are discarded after the maximum number of retries that is specified by the retry policy is reached.'),
    errorsTolerance?: string(name='ErrorsTolerance', description='The exception tolerance policy. Valid values:

*   NONE: does not tolerate exceptions.
*   ALL: tolerates all exceptions.', example='ALL'),
    maximumTasks?: long(name='MaximumTasks', description='The maximum number of concurrent threads.', example='2'),
    retryStrategy?: {
      maximumEventAgeInSeconds?: long(name='MaximumEventAgeInSeconds', description='The maximum timeout period for a retry.', example='512'),
      maximumRetryAttempts?: long(name='MaximumRetryAttempts', description='The maximum number of retries.', example='2'),
      pushRetryStrategy?: string(name='PushRetryStrategy', description='The retry policy. Valid values:

*   BACKOFF_RETRY
*   EXPONENTIAL_DECAY_RETRY', example='BACKOFFRETRY'),
    }(name='RetryStrategy', description='The retry policy that you want to use if events fail to be pushed.'),
  }(name='RunOptions', description='The parameters that are configured for the runtime environment.'),
  sink?: {
    sinkDataHubParameters?: {
      body?: {
        form?: string(name='Form', description='The format into which you want to transform events.', example='ORIGINAL'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The BLOB topic.'),
      }(name='Body', description='The BLOB topic.'),
      project?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The name of the DataHub project.', example='demo-project'),
      }(name='Project', description='The name of the DataHub project.'),
      roleName?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The role name.', example='test-role'),
      }(name='RoleName', description='The role name.'),
      topic?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The name of the DataHub topic.', example='demo-topic'),
      }(name='Topic', description='The name of the DataHub topic.'),
      topicSchema?: {
        form?: string(name='Form', description='The format into which you want to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='{"k1":"${k1}","k2":"${k2}"}'),
        value?: string(name='Value', description='The TUBLE topic.', example='{"k1":"value1","k2":"value2"}'),
      }(name='TopicSchema', description='The TUBLE topic.'),
      topicType?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The topic type. Valid values:

*   TUPLE
*   BLOB', example='TUPLE'),
      }(name='TopicType', description='The topic type. Valid values:

*   TUPLE
*   BLOB'),
    }(name='SinkDataHubParameters', description='The parameters that are configured if you specify the event target as DataHub.'),
    sinkFcParameters?: {
      body?: {
        form?: string(name='Form', description='The format into which you want to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
      }(name='Body', description='The message body that you want to deliver to Function Compute.'),
      concurrency?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='None'),
        value?: string(name='Value', description='The delivery concurrency. Minimum value: 1.', example='1'),
      }(name='Concurrency', description='The delivery concurrency. Minimum value: 1.'),
      functionName?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The function name.', example='myFunction'),
      }(name='FunctionName', description='The function name.'),
      invocationType?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The invocation method. Valid values: Sync and Async.', example='Async'),
      }(name='InvocationType', description='The invocation method. Valid values: Sync and Async.'),
      qualifier?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The service version.', example='LATEST'),
      }(name='Qualifier', description='The service version.'),
      serviceName?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The service name.', example='myService'),
      }(name='ServiceName', description='The service name.'),
    }(name='SinkFcParameters', description='The parameters that are configured if you specify the event target as Function Compute.'),
    sinkFnfParameters?: {
      executionName?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.'),
        value?: string(name='Value', description='The execution name.', example='123'),
      }(name='ExecutionName', description='The execution name.'),
      flowName?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.'),
        value?: string(name='Value', description='The flow name.', example='test-streaming-fnf'),
      }(name='FlowName', description='The flow name.'),
      input?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.'),
        value?: string(name='Value', description='The input information of the execution.', example='123'),
      }(name='Input', description='The input information of the execution.'),
      roleName?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.'),
        value?: string(name='Value', description='The role name.', example='Al****FNF-x****'),
      }(name='RoleName', description='The role name.'),
    }(name='SinkFnfParameters', description='The parameters that are configured if you specify the event target as Serverless Workflow.'),
    sinkKafkaParameters?: {
      acks?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The ACK mode.

*   If you set this parameter to 0, no response is returned from the broker. In this mode, the performance is high, but the risk of data loss is also high.
*   If you set this parameter to 1, a response is returned when data is written to the leader. In this mode, the performance and the risk of data loss are moderate. Data loss may occur if a failure occurs on the leader.
*   If you set this parameter to all, a response is returned when data is written to the leader and synchronized to the followers. In this mode, the performance is low, but the risk of data loss is also low. Data loss occurs if the leader and the followers fail at the same time.', example='1'),
      }(name='Acks', description='The acknowledgement (ACK) mode.

*   If you set this parameter to 0, no response is returned from the broker. In this mode, the performance is high, but the risk of data loss is also high.
*   If you set this parameter to 1, a response is returned when data is written to the leader. In this mode, the performance and the risk of data loss are moderate. Data loss may occur if a failure occurs on the leader.
*   If you set this parameter to all, a response is returned when data is written to the leader and synchronized to the followers. In this mode, the performance is low, but the risk of data loss is also low. Data loss occurs if the leader and the followers fail at the same time.'),
      instanceId?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The instance ID.', example='Defaut_1283278472_sadkj'),
      }(name='InstanceId', description='The ID of the Message Queue for Apache Kafka instance.'),
      key?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The message key.', example='key'),
      }(name='Key', description='The message key.'),
      topic?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The topic name.', example='test'),
      }(name='Topic', description='The topic name.'),
      value?: {
        form?: string(name='Form', description='The format into which you want to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
      }(name='Value', description='The message body.'),
    }(name='SinkKafkaParameters', description='The parameters that are configured if you specify the event target as Message Queue for Apache Kafka.'),
    sinkMNSParameters?: {
      body?: {
        form?: string(name='Form', description='The format into which you want to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
  "key": "value"
}'),
      }(name='Body', description='The message body.'),
      isBase64Encode?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='Specifies that Base64 encoding is enabled.', example='true'),
      }(name='IsBase64Encode', description='Specifies whether to enable Base64 encoding.'),
      queueName?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The name of the MNS queue.', example='MyQueue'),
      }(name='QueueName', description='The name of the MNS queue.'),
    }(name='SinkMNSParameters', description='The parameters that are configured if you specify the event target as MNS.'),
    sinkRabbitMQParameters?: {
      body?: {
        form?: string(name='Form', description='The format into which you want to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
  "key": "value"
}'),
      }(name='Body', description='The message body.'),
      exchange?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The name of the exchange on the Message Queue for RabbitMQ instance.', example='a_exchange'),
      }(name='Exchange', description='The exchange to which you want to deliver events. This parameter is available only if you set TargetType to Exchange.'),
      instanceId?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The ID of the Message Queue for RabbitMQ instance.', example='a5ff91ad4f3f24947887fe184fc20d07'),
      }(name='InstanceId', description='The information about the Message Queue for RabbitMQ instance.'),
      messageId?: {
        form?: string(name='Form', description='The format into which you want to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
  "key": "value"
}'),
      }(name='MessageId', description='The message ID.'),
      properties?: {
        form?: string(name='Form', description='The format into which you want to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
  "key": "value"
}'),
      }(name='Properties', description='The properties that you want to use to filter messages.'),
      queueName?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The name of the queue on the Message Queue for RabbitMQ instance.', example='MyQueue'),
      }(name='QueueName', description='The queue to which you want to deliver events. This parameter is available only if you set TargetType to Queue.'),
      routingKey?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The rule that you want to use to route messages.', example='housekeeping'),
      }(name='RoutingKey', description='The rule that you want to use to route messages. This parameter is available only if you set TargetType to Exchange.'),
      targetType?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The type of the resource to which you want to deliver events. Valid values:

*   Exchange
*   Queue', example='Exchange/Queue'),
      }(name='TargetType', description='The type of the resource to which you want to deliver events.'),
      virtualHostName?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The name of the vhost of the Message Queue for RabbitMQ instance.', example='rabbit-host'),
      }(name='VirtualHostName', description='The name of the vhost of the Message Queue for RabbitMQ instance.'),
    }(name='SinkRabbitMQParameters', description='The parameters that are configured if you specify the event target as Message Queue for RabbitMQ.'),
    sinkRocketMQParameters?: {
      body?: {
        form?: string(name='Form', description='The format into which you want to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
  "key": "value"
}'),
      }(name='Body', description='The message body.'),
      instanceEndpoint?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The instance endpoint.', example='vbr-8vbsvkkbpf3vb0zefs7ex'),
      }(name='InstanceEndpoint', description='The instance endpoint.'),
      instanceId?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The ID of the Message Queue for Apache RocketMQ instance.', example='MQ_INST_164901546557****_BAAN****'),
      }(name='InstanceId', description='The parameters that are configured if you specify the event target as Message Queue for Apache RocketMQ.'),
      instancePassword?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The instance password.', example='admin'),
      }(name='InstancePassword', description='The instance password.'),
      instanceType?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The instance type.', example='2'),
      }(name='InstanceType', description='The instance type.'),
      instanceUsername?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The instance username.', example='admin'),
      }(name='InstanceUsername', description='The instance username.'),
      keys?: {
        form?: string(name='Form', description='The format into which you want to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
  "key": "value"
}'),
      }(name='Keys', description='The keys that you want to use to filter messages.'),
      network?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The network type. Valid values:

*   PublicNetwork
*   PrivateNetwork', example='PublicNetwork'),
      }(name='Network', description='The network type. Valid values:

*   PublicNetwork
*   PrivateNetwork'),
      properties?: {
        form?: string(name='Form', description='The format into which you want to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
  "key": "value"
}'),
      }(name='Properties', description='The properties that you want to use to filter messages.'),
      securityGroupId?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The security group ID.', example='b4bf375515f6440f942e3a20c33d5b9c'),
      }(name='SecurityGroupId', description='The security group ID.'),
      tags?: {
        form?: string(name='Form', description='The format into which you want to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
  "key": "value"
}'),
      }(name='Tags', description='The tags that you want to use to filter messages.'),
      topic?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The name of the topic on the Message Queue for Apache RocketMQ instance.', example='Mytopic'),
      }(name='Topic', description='The topic on the Message Queue for Apache RocketMQ instance.'),
      vSwitchIds?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The vSwitch ID.', example='vbr-8vb835n3zf9shwlvbwlmp'),
      }(name='VSwitchIds', description='The vSwitch ID.'),
      vpcId?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The VPC ID.', example='vbr-8vb835n3zf9shwlvbwlmp'),
      }(name='VpcId', description='The VPC ID.'),
    }(name='SinkRocketMQParameters', description='The parameters that are configured if you specify the event target as Message Queue for Apache RocketMQ.'),
    sinkSLSParameters?: {
      body?: {
        form?: string(name='Form', description='The format into which you want to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which you want to transform events.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before transformation.', example='{
      "key": "value"
}'),
      }(name='Body', description='The message body that you want to deliver to Simple Log Service.'),
      logStore?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The Simple Log Service Logstore.', example='test-logstore'),
      }(name='LogStore', description='The Simple Log Service Logstore.'),
      project?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The Simple Log Service project.', example='test-project'),
      }(name='Project', description='The Simple Log Service project.'),
      roleName?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The role name. If you want to authorize EventBridge to use this role to read logs in Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the RAM console.', example='testRole'),
      }(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the Resource Access Management (RAM) console.'),
      topic?: {
        form?: string(name='Form', description='The format into which you want to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The topic that you want to use to store logs. This parameter corresponds to the **topic** reserved field in Simple Log Service.', example='testTopic'),
      }(name='Topic', description='The topic that you want to use to store logs. This parameter corresponds to the **topic** reserved field in Simple Log Service.'),
    }(name='SinkSLSParameters', description='The parameters that are configured if you specify the event target as Simple Log Service.'),
  }(name='Sink', description='The event target. You must and can specify only one event target.'),
  source?: {
    sourceDTSParameters?: {
      brokerUrl?: string(name='BrokerUrl', description='The URL and port number of the data subscription channel.'),
      initCheckPoint?: long(name='InitCheckPoint', description='The consumer offset. It is the timestamp that indicates when the SDK client consumes the first data record.', example='1620962769'),
      password?: string(name='Password', description='The consumer group password.', example='admin'),
      sid?: string(name='Sid', description='The consumer group ID.', example='HD3'),
      taskId?: string(name='TaskId', description='The task ID.', example='f86e5814-b223-482c-b768-3b873297dade'),
      topic?: string(name='Topic', description='The topic to which you want to subscribe by using the data subscription channel.', example='LTC_CACHE_PRD'),
      username?: string(name='Username', description='The consumer group username.', example='admin'),
    }(name='SourceDTSParameters', description='The parameters that are configured if you specify the event source as Data Transmission Service (DTS).'),
    sourceKafkaParameters?: {
      consumerGroup?: string(name='ConsumerGroup', description='The ID of the consumer group that subscribes to the topic.', example='DEFAULT_GROUP'),
      instanceId?: string(name='InstanceId', description='The instance ID.', example='r-8vb64581862cd814'),
      network?: string(name='Network', description='The network type. Default value: Default. The value PublicNetwork specifies virtual private clouds (VPCs).', example='Default'),
      offsetReset?: string(name='OffsetReset', description='The offset.', example='latest'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
      securityGroupId?: string(name='SecurityGroupId', description='The security group ID.', example='sg-bp1iv19sp1msc7zot4wr'),
      topic?: string(name='Topic', description='The topic name.', example='popvip_center_robot_order'),
      vSwitchIds?: string(name='VSwitchIds', description='The vSwitch ID.', example='vsw-bp179l3llg3jjxwrq72hh'),
      vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-8vblalsi0vbhizr77cbhu'),
    }(name='SourceKafkaParameters', description='The parameters that are configured if you specify the event source as Message Queue for Apache Kafka.'),
    sourceMNSParameters?: {
      isBase64Decode?: boolean(name='IsBase64Decode', description='Specifies whether to enable Base64 encoding. Default value: true.', example='true'),
      queueName?: string(name='QueueName', description='The queue name.', example='queue_api_1642474203601'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-beijing'),
    }(name='SourceMNSParameters', description='The parameters that are configured if you specify the event source as Message Service (MNS).'),
    sourceMQTTParameters?: {
      instanceId?: string(name='InstanceId', description='The instance ID.', example='r-bp1b5ncun5lqerzg4r'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-shenzhen'),
      topic?: string(name='Topic', description='The topic in which messages are stored.', example='CANAL_VICUTU_UAT'),
    }(name='SourceMQTTParameters', description='The parameters that are configured if you specify the event source as Message Queue for MQTT.'),
    sourceRabbitMQParameters?: {
      instanceId?: string(name='InstanceId', description='The ID of the Message Queue for RabbitMQ instance.', example='gtm-cn-k2c2yfgzt02'),
      queueName?: string(name='QueueName', description='The name of the queue on the Message Queue for RabbitMQ instance.', example='demo'),
      regionId?: string(name='RegionId', description='The region ID. You can call the [describeregions](~~62010~~) operation to query the most recent region list.', example='cn-hangzhou'),
      virtualHostName?: string(name='VirtualHostName', description='The name of the vhost of the Message Queue for RabbitMQ instance.', example='eb-connect'),
    }(name='SourceRabbitMQParameters', description='The parameters that are configured if you specify the event source as Message Queue for RabbitMQ.'),
    sourceRocketMQParameters?: {
      authType?: string(name='AuthType', description='The authentication method.', example='ACL'),
      filterSql?: string(name='FilterSql', description='The SQL statement that is used to filter messages.', example='index > 10'),
      filterType?: string(name='FilterType', description='The message filter type.', example='Tag'),
      groupID?: string(name='GroupID', description='The ID of the consumer group on the Message Queue for Apache RocketMQ instance.', example='GID_group1'),
      instanceEndpoint?: string(name='InstanceEndpoint', description='The instance endpoint.', example='registry-vpc.cn-zhangjiakou.aliyuncs.com'),
      instanceId?: string(name='InstanceId', description='The region where the Message Queue for Apache RocketMQ instance resides.', example='default_C56C360261515'),
      instanceNetwork?: string(name='InstanceNetwork', description='The network type of the instance. Valid values:

*   PublicNetwork
*   PrivateNetwork', example='PublicNetwork'),
      instancePassword?: string(name='InstancePassword', description='The instance password.', example='admin'),
      instanceSecurityGroupId?: string(name='InstanceSecurityGroupId', description='The security group ID of the instance.', example='sg-m5edtu24f123456789'),
      instanceType?: string(name='InstanceType', description='The instance type.', example='2'),
      instanceUsername?: string(name='InstanceUsername', description='The instance username.', example='admin'),
      instanceVSwitchIds?: string(name='InstanceVSwitchIds', description='The vSwitch ID of the instance.', example='vsw-m5ev8asdc6h123456789'),
      instanceVpcId?: string(name='InstanceVpcId', description='The VPC ID of the instance.', example='vpc-m5e3sv4b123456789'),
      network?: string(name='Network', description='The network type. Valid values: PublicNetwork and PrivateNetwork.', example='PrivateNetwork'),
      offset?: string(name='Offset', description='The offset from which message consumption starts. Valid values:

*   CONSUME_FROM_LAST_OFFSET: Start message consumption from the latest offset.
*   CONSUME_FROM_FIRST_OFFSET: Start message consumption from the earliest offset.
*   CONSUME_FROM_TIMESTAMP: Start message consumption from the offset at the specified point in time.

Default value: CONSUME_FROM_LAST_OFFSET.', example='CONSUMEFROMLAST_OFFSET'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-qingdao'),
      securityGroupId?: string(name='SecurityGroupId', description='The security group of the cross-border task.', example='sg-m5edtu24f123456789'),
      tag?: string(name='Tag', description='The tag that is used to filter messages.', example='test'),
      timestamp?: long(name='Timestamp', description='The timestamp that specifies the time from which messages are consumed. This parameter is valid only if you set Offset to CONSUME_FROM_TIMESTAMP.', example='1670656652009'),
      topic?: string(name='Topic', description='The name of the topic on the Message Queue for Apache RocketMQ instance.', example='Topic_publicRule_api_1667273421288'),
      vSwitchIds?: string(name='VSwitchIds', description='The vSwitch ID of the cross-border task.', example='vsw-m5ev8asdc6h123456789'),
      vpcId?: string(name='VpcId', description='The VPC ID of the cross-border task.', example='vpc-m5e3sv4b123456789'),
    }(name='SourceRocketMQParameters', description='The parameters that are configured if you specify the event source as Message Queue for Apache RocketMQ.'),
    sourceSLSParameters?: {
      consumePosition?: string(name='ConsumePosition', description='The consumer offset. The value begin indicates the earliest offset, and the value end indicates the latest offset. You can also specify a time in seconds to start message consumption.', example='end'),
      logStore?: string(name='LogStore', description='The Simple Log Service Logstore.', example='sas-log'),
      project?: string(name='Project', description='The Simple Log Service project.', example='test'),
      roleName?: string(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Simple Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the Resource Access Management (RAM) console.', example='testRole'),
    }(name='SourceSLSParameters', description='The parameters that are configured if you specify the event source as Simple Log Service.'),
  }(name='Source', description='The event provider, which is also known as the event source. You must and can specify only one event source.'),
  transforms?: [ 
    {
      arn?: string(name='Arn'),
    }
  ](name='Transforms'),
}

model CreateEventStreamingShrinkRequest {
  description?: string(name='Description', description='The description of the event stream.', example='rocketmq2mns'),
  eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream.', example='myeventstreaming'),
  filterPattern?: string(name='FilterPattern', description='The rule that is used to filter events. If you leave this parameter empty, all events are matched.'),
  runOptionsShrink?: string(name='RunOptions', description='The parameters that are configured for the runtime environment.'),
  sinkShrink?: string(name='Sink', description='The event target. You must and can specify only one event target.'),
  sourceShrink?: string(name='Source', description='The event provider, which is also known as the event source. You must and can specify only one event source.'),
  transformsShrink?: string(name='Transforms'),
}

model CreateEventStreamingResponseBody = {
  code?: string(name='Code', description='The response code. Valid values:

*   Success: The request is successful.
*   Other codes: The request failed. For more information about error codes, see Error codes.', example='200'),
  data?: {
    eventStreamingARN?: string(name='EventStreamingARN', description='The ARN of the event stream.', example='acs:eventbridge:cn-hangzhou:164901546557****:eventstreaming/myeventstreaming'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='The name [xxxx] of event streaming in request is already exist!'),
  requestId?: string(name='RequestId', description='The request ID.', example='B896B484-F16D-59DE-9E23-DD0E5C361108'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. The value true indicates that the operation is successful.', example='true'),
}

model CreateEventStreamingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEventStreamingResponseBody(name='body'),
}

/**
  * You can call this API operation to create an event stream.
  *
  * @param tmpReq CreateEventStreamingRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateEventStreamingResponse
 */
async function createEventStreamingWithOptions(tmpReq: CreateEventStreamingRequest, runtime: Util.RuntimeOptions): CreateEventStreamingResponse {
  Util.validateModel(tmpReq);
  var request = new CreateEventStreamingShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.runOptions)) {
    request.runOptionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.runOptions, 'RunOptions', 'json');
  }
  if (!Util.isUnset(tmpReq.sink)) {
    request.sinkShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sink, 'Sink', 'json');
  }
  if (!Util.isUnset(tmpReq.source)) {
    request.sourceShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.source, 'Source', 'json');
  }
  if (!Util.isUnset(tmpReq.transforms)) {
    request.transformsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.transforms, 'Transforms', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  if (!Util.isUnset(request.filterPattern)) {
    body['FilterPattern'] = request.filterPattern;
  }
  if (!Util.isUnset(request.runOptionsShrink)) {
    body['RunOptions'] = request.runOptionsShrink;
  }
  if (!Util.isUnset(request.sinkShrink)) {
    body['Sink'] = request.sinkShrink;
  }
  if (!Util.isUnset(request.sourceShrink)) {
    body['Source'] = request.sourceShrink;
  }
  if (!Util.isUnset(request.transformsShrink)) {
    body['Transforms'] = request.transformsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to create an event stream.
  *
  * @param request CreateEventStreamingRequest
  * @return CreateEventStreamingResponse
 */
async function createEventStreaming(request: CreateEventStreamingRequest): CreateEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEventStreamingWithOptions(request, runtime);
}

model CreateRuleRequest {
  description?: string(name='Description', description='The description of the event bus.'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='MyEventBus'),
  eventTargets?: [ 
    {
      deadLetterQueue?: {
        arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the dead-letter queue. Events that are not processed or whose maximum retries are exceeded are written to the dead-letter queue. The ARN feature is supported by the following queue types: MNS and Message Queue for Apache RocketMQ.', example='acs:mns:cn-hangzhou:123456789098****:/queues/rule-deadletterqueue'),
      }(name='DeadLetterQueue', description='The dead-letter queue. Events that are not processed or whose maximum retries are exceeded are written to the dead-letter queue. The dead-letter queue feature is supported by the following queue types: Message Queue for Apache RocketMQ, Message Service (MNS), Message Queue for Apache Kafka, and EventBridge.'),
      endpoint?: string(name='Endpoint', description='The endpoint of the event target.', example='acs:mns:cn-hangzhou:123456789098****:queues/myqueue'),
      errorsTolerance?: string(name='ErrorsTolerance', description='The fault tolerance policy. Valid values: ALL: allows fault tolerance. If an error occurs, the event processing is not blocked. If the message fails to be sent after the maximum number of retries specified by the retry policy is reached, the message is delivered to the dead-letter queue or discarded based on your configurations. NONE: does not allow fault tolerance. If an error occurs and the message fails to be sent after the maximum number of retries specified by the retry policy is reached, the event processing is blocked.', example='ALL'),
      id?: string(name='Id', description='The ID of the custom event target.', example='12021'),
      paramList?: [ 
        {
          form?: string(name='Form', description='The format that is used by the event target parameter. For more information, see [Limits.](https://www.alibabacloud.com/help/en/eventbridge/latest/limits)', example='TEMPLATE'),
          resourceKey?: string(name='ResourceKey', description='The resource parameter of the event target. For more information, see [Limits](https://www.alibabacloud.com/help/en/eventbridge/latest/limits)', example='body'),
          template?: string(name='Template', description='The template that is used by the event target parameter.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value of the event target parameter.', example='{\\"key\\"=\\"value\\"}'),
        }
      ](name='ParamList', description='The parameters that are configured for the event target.'),
      pushRetryStrategy?: string(name='PushRetryStrategy', description='The retry policy that is used to push events. Valid values: BACKOFF_RETRY: backoff retry. If an event failed to be pushed, it can be retried up to three times. The interval between two consecutive retries is a random value between 10 and 20 seconds. EXPONENTIAL_DECAY_RETRY: exponential decay retry. If an event failed to be pushed, it can be retried up to 176 times. The interval between two consecutive retries exponentially increases to 512 seconds, and the total retry time is one day. The specific retry intervals are 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 512, ..., and 512 seconds. The interval of 512 seconds is used for 167 retries.', example='BACKOFF_RETRY'),
      type?: string(name='Type', description='The type of the event target. For more information, see [Event target parameters.](https://www.alibabacloud.com/help/en/eventbridge/latest/event-target-parameters)', example='acs.mns.queue'),
    }
  ](name='EventTargets', description='The event targets.'),
  filterPattern?: string(name='FilterPattern', description='The event pattern, in JSON format. Valid values: stringEqual and stringExpression. You can specify up to five expressions in the map data structure in each field.

You can specify up to five expressions in the map data structure in each field.', example='{\\"source\\": [{\\"prefix\\": \\"acs.\\"}],\\"type\\": [{\\"prefix\\":\\"oss:ObjectReplication\\"}],\\"subject\\":[{\\"prefix\\":\\"acs:oss:cn-hangzhou:123456789098****:my-movie-bucket/\\", \\"suffix\\":\\".txt\\"}]}'),
  ruleName?: string(name='RuleName', description='The name of the event rule.', example='MNSRule'),
  status?: string(name='Status', description='The status of the event rule. Valid values: ENABLE: enables the event rule. It is the default status of the event rule. DISABLE: disables the event rule.', example='ENABLE'),
}

model CreateRuleShrinkRequest {
  description?: string(name='Description', description='The description of the event bus.'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='MyEventBus'),
  eventTargetsShrink?: string(name='EventTargets', description='The event targets.'),
  filterPattern?: string(name='FilterPattern', description='The event pattern, in JSON format. Valid values: stringEqual and stringExpression. You can specify up to five expressions in the map data structure in each field.

You can specify up to five expressions in the map data structure in each field.', example='{\\"source\\": [{\\"prefix\\": \\"acs.\\"}],\\"type\\": [{\\"prefix\\":\\"oss:ObjectReplication\\"}],\\"subject\\":[{\\"prefix\\":\\"acs:oss:cn-hangzhou:123456789098****:my-movie-bucket/\\", \\"suffix\\":\\".txt\\"}]}'),
  ruleName?: string(name='RuleName', description='The name of the event rule.', example='MNSRule'),
  status?: string(name='Status', description='The status of the event rule. Valid values: ENABLE: enables the event rule. It is the default status of the event rule. DISABLE: disables the event rule.', example='ENABLE'),
}

model CreateRuleResponseBody = {
  code?: string(name='Code', description='The returned HTTP status code. The HTTP status code 200 indicates that the request is successful.', example='200'),
  data?: {
    ruleARN?: string(name='RuleARN', description='The ARN of the event rule. The ARN is used for authorization.', example='acs:eventbridge:cn-hangzhou:123456789098****:eventbus/default/rule/MNSRule'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='Remote error. requestId: [xxxx], error code: [xxx], message: [The target in event rule is invalid! Endpoint is xxx'),
  requestId?: string(name='RequestId', description='The request ID.', example='1AD6D598-7506-5D2C-81EA-30E3241A903A'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model CreateRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRuleResponseBody(name='body'),
}

/**
  * You can call this API operation to create an event rule.
  *
  * @param tmpReq CreateRuleRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateRuleResponse
 */
async function createRuleWithOptions(tmpReq: CreateRuleRequest, runtime: Util.RuntimeOptions): CreateRuleResponse {
  Util.validateModel(tmpReq);
  var request = new CreateRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.eventTargets)) {
    request.eventTargetsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.eventTargets, 'EventTargets', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventTargetsShrink)) {
    query['EventTargets'] = request.eventTargetsShrink;
  }
  if (!Util.isUnset(request.filterPattern)) {
    query['FilterPattern'] = request.filterPattern;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to create an event rule.
  *
  * @param request CreateRuleRequest
  * @return CreateRuleResponse
 */
async function createRule(request: CreateRuleRequest): CreateRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRuleWithOptions(request, runtime);
}

model CreateServiceLinkedRoleForProductRequest {
  productName?: string(name='ProductName', description='The name of the cloud service or the name of the service-linked role with which the cloud service is associated.', example='AliyunServiceRoleForEventBridgeSendToMNS'),
}

model CreateServiceLinkedRoleForProductResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For more information about error codes, see Error codes.', example='Success'),
  message?: string(name='Message', description='The returned message. If the request is successful, success is returned.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='C36345A1-75F3-5A1A-BFCF-33B8271971FA'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model CreateServiceLinkedRoleForProductResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceLinkedRoleForProductResponseBody(name='body'),
}

/**
  * You can call this API operation to create a service-linked role for your cloud service.
  *
  * @param request CreateServiceLinkedRoleForProductRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateServiceLinkedRoleForProductResponse
 */
async function createServiceLinkedRoleForProductWithOptions(request: CreateServiceLinkedRoleForProductRequest, runtime: Util.RuntimeOptions): CreateServiceLinkedRoleForProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.productName)) {
    query['ProductName'] = request.productName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceLinkedRoleForProduct',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to create a service-linked role for your cloud service.
  *
  * @param request CreateServiceLinkedRoleForProductRequest
  * @return CreateServiceLinkedRoleForProductResponse
 */
async function createServiceLinkedRoleForProduct(request: CreateServiceLinkedRoleForProductRequest): CreateServiceLinkedRoleForProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceLinkedRoleForProductWithOptions(request, runtime);
}

model DeleteApiDestinationRequest {
  apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination.', example='ApiDestinationName'),
}

model DeleteApiDestinationResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  message?: string(name='Message', description='The returned message. If the request is successful, success is returned. If the request failed, an error code is returned.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='382E6272-8E9C-5681-AC96-A8AF0BFAC1A5'),
}

model DeleteApiDestinationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteApiDestinationResponseBody(name='body'),
}

/**
  * You can call this API operation to delete an API destination.
  *
  * @param request DeleteApiDestinationRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteApiDestinationResponse
 */
async function deleteApiDestinationWithOptions(request: DeleteApiDestinationRequest, runtime: Util.RuntimeOptions): DeleteApiDestinationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apiDestinationName)) {
    query['ApiDestinationName'] = request.apiDestinationName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteApiDestination',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to delete an API destination.
  *
  * @param request DeleteApiDestinationRequest
  * @return DeleteApiDestinationResponse
 */
async function deleteApiDestination(request: DeleteApiDestinationRequest): DeleteApiDestinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteApiDestinationWithOptions(request, runtime);
}

model DeleteConnectionRequest {
  connectionName?: string(name='ConnectionName', description='The name of the connection that you want to delete.', example='connection-name'),
}

model DeleteConnectionResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  message?: string(name='Message', description='The returned message. If the request is successful, success is returned. If the request failed, an error code is returned.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='8EF25E37-1750-5D7A-BA56-F8AE081A69C8'),
}

model DeleteConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteConnectionResponseBody(name='body'),
}

/**
  * You can call this API operation to delete a connection.
  *
  * @param request DeleteConnectionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteConnectionResponse
 */
async function deleteConnectionWithOptions(request: DeleteConnectionRequest, runtime: Util.RuntimeOptions): DeleteConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionName)) {
    query['ConnectionName'] = request.connectionName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteConnection',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to delete a connection.
  *
  * @param request DeleteConnectionRequest
  * @return DeleteConnectionResponse
 */
async function deleteConnection(request: DeleteConnectionRequest): DeleteConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteConnectionWithOptions(request, runtime);
}

model DeleteEventBusRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='MyEventBus'),
}

model DeleteEventBusResponseBody = {
  code?: string(name='Code', description='The returned HTTP status code. The HTTP status code 200 indicates that the request is successful.', example='200'),
  message?: string(name='Message', description='The returned error message.', example='EventBusNotExist'),
  requestId?: string(name='RequestId', description='The request ID.', example='C229E140-1A5C-5D55-8904-CFC5BA4CAA98'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='true'),
}

model DeleteEventBusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEventBusResponseBody(name='body'),
}

/**
  * You can call this API operation to delete an event bus.
  *
  * @param request DeleteEventBusRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteEventBusResponse
 */
async function deleteEventBusWithOptions(request: DeleteEventBusRequest, runtime: Util.RuntimeOptions): DeleteEventBusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEventBus',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to delete an event bus.
  *
  * @param request DeleteEventBusRequest
  * @return DeleteEventBusResponse
 */
async function deleteEventBus(request: DeleteEventBusRequest): DeleteEventBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventBusWithOptions(request, runtime);
}

model DeleteEventSourceRequest {
  eventSourceName?: string(name='EventSourceName', description='The name of the event source.', example='myrabbitmq.source'),
}

model DeleteEventSourceResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For more information about error codes, see Error codes.', example='Success'),
  message?: string(name='Message', description='The returned error message.', example='Remote error. requestId: [78B66E68-E778-1F33-84BD-xxxx], error code: [EventSourceNotExist], message: [The event source in request is not exist! ]'),
  requestId?: string(name='RequestId', description='The request ID.', example='5f80e9b3-98d5-4f51-8412-c758818a03e4'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model DeleteEventSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEventSourceResponseBody(name='body'),
}

/**
  * You can call this API operation to delete an event source.
  *
  * @param request DeleteEventSourceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteEventSourceResponse
 */
async function deleteEventSourceWithOptions(request: DeleteEventSourceRequest, runtime: Util.RuntimeOptions): DeleteEventSourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventSourceName)) {
    body['EventSourceName'] = request.eventSourceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEventSource',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to delete an event source.
  *
  * @param request DeleteEventSourceRequest
  * @return DeleteEventSourceResponse
 */
async function deleteEventSource(request: DeleteEventSourceRequest): DeleteEventSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventSourceWithOptions(request, runtime);
}

model DeleteEventStreamingRequest {
  eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream that you want to delete.', example='rocketmq-sync'),
}

model DeleteEventStreamingResponseBody = {
  code?: boolean(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  message?: string(name='Message', description='The returned error message.', example='The event streaming [xxxx] not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='499A9ACF-70CD-5D43-87F3-1B60529EE446'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='true'),
}

model DeleteEventStreamingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEventStreamingResponseBody(name='body'),
}

/**
  * You can call this API operation to delete an event stream.
  *
  * @param request DeleteEventStreamingRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteEventStreamingResponse
 */
async function deleteEventStreamingWithOptions(request: DeleteEventStreamingRequest, runtime: Util.RuntimeOptions): DeleteEventStreamingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to delete an event stream.
  *
  * @param request DeleteEventStreamingRequest
  * @return DeleteEventStreamingResponse
 */
async function deleteEventStreaming(request: DeleteEventStreamingRequest): DeleteEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventStreamingWithOptions(request, runtime);
}

model DeleteRuleRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='tf-testacc-event-bus'),
  ruleName?: string(name='RuleName', description='The name of the event rule that you want to delete.', example='ramrolechange-mns'),
}

model DeleteRuleResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  message?: string(name='Message', description='The returned error message.', example='The event rule not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='FF942675-F937-549C-A942-EB94FFE28DD3'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model DeleteRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRuleResponseBody(name='body'),
}

/**
  * You can call this API operation to delete an event rule.
  *
  * @param request DeleteRuleRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteRuleResponse
 */
async function deleteRuleWithOptions(request: DeleteRuleRequest, runtime: Util.RuntimeOptions): DeleteRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to delete an event rule.
  *
  * @param request DeleteRuleRequest
  * @return DeleteRuleResponse
 */
async function deleteRule(request: DeleteRuleRequest): DeleteRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRuleWithOptions(request, runtime);
}

model DeleteTargetsRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='MyEventBus'),
  ruleName?: string(name='RuleName', description='The name of the event rule.', example='ramrolechange-mns'),
  targetIds?: [ string ](name='TargetIds', description='The IDs of the event targets that you want to delete.'),
}

model DeleteTargetsShrinkRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='MyEventBus'),
  ruleName?: string(name='RuleName', description='The name of the event rule.', example='ramrolechange-mns'),
  targetIdsShrink?: string(name='TargetIds', description='The IDs of the event targets that you want to delete.'),
}

model DeleteTargetsResponseBody = {
  code?: string(name='Code', description='The returned HTTP status code. The HTTP status code 200 indicates that the request is successful.', example='200'),
  data?: {
    errorEntries?: [ 
      {
        entryId?: string(name='EntryId', description='The ID of the event body that failed to be processed.', example='target5'),
        errorCode?: string(name='ErrorCode', description='The returned error code.', example='EventRuleTargetIdDuplicate'),
        errorMessage?: string(name='ErrorMessage', description='The returned error message.', example='The id of event target is duplicate!'),
      }
    ](name='ErrorEntries', description='The information about the event body that failed to be processed.'),
    errorEntriesCount?: int32(name='ErrorEntriesCount', description='The number of event bodies that failed to be processed. Valid values: 0: No event bodies failed to be processed. An integer other than 0: the number of event bodies that failed to be processed.', example='0'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='EventBusNotExist'),
  requestId?: string(name='RequestId', description='The request ID.', example='78FA9EAC-F0C0-58B0-871E-9F9756CE1D29'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='true'),
}

model DeleteTargetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTargetsResponseBody(name='body'),
}

/**
  * You can call this API operation to delete one or more event targets of an event rule.
  *
  * @param tmpReq DeleteTargetsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteTargetsResponse
 */
async function deleteTargetsWithOptions(tmpReq: DeleteTargetsRequest, runtime: Util.RuntimeOptions): DeleteTargetsResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteTargetsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.targetIds)) {
    request.targetIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.targetIds, 'TargetIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.targetIdsShrink)) {
    query['TargetIds'] = request.targetIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTargets',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to delete one or more event targets of an event rule.
  *
  * @param request DeleteTargetsRequest
  * @return DeleteTargetsResponse
 */
async function deleteTargets(request: DeleteTargetsRequest): DeleteTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTargetsWithOptions(request, runtime);
}

model DisableRuleRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='MyEventBus'),
  ruleName?: string(name='RuleName', description='The name of the event rule.', example='tf-testacc-rule'),
}

model DisableRuleResponseBody = {
  code?: string(name='Code', description='The error code. The value Success indicates that the request is successful.', example='Success'),
  message?: string(name='Message', description='The returned error message.', example='EventRuleNotExisted'),
  requestId?: string(name='RequestId', description='The request ID.', example='C36345A1-75F3-5A1A-BFCF-33B8271971FA'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='true'),
}

model DisableRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableRuleResponseBody(name='body'),
}

/**
  * You can call this API operation to disable an event rule.
  *
  * @param request DisableRuleRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DisableRuleResponse
 */
async function disableRuleWithOptions(request: DisableRuleRequest, runtime: Util.RuntimeOptions): DisableRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to disable an event rule.
  *
  * @param request DisableRuleRequest
  * @return DisableRuleResponse
 */
async function disableRule(request: DisableRuleRequest): DisableRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableRuleWithOptions(request, runtime);
}

model EnableRuleRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='MyEventBus'),
  ruleName?: string(name='RuleName', description='The name of the event rule.', example='ramrolechange'),
}

model EnableRuleResponseBody = {
  code?: string(name='Code', description='The error code. The value Success indicates that the request is successful.', example='Success'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='EventRuleNotExisted'),
  requestId?: string(name='RequestId', description='The request ID.', example='580A938B-6107-586C-8EC7-F22EEBEDA9E6'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='true'),
}

model EnableRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableRuleResponseBody(name='body'),
}

/**
  * You can call this API operation to enable an event rule.
  *
  * @param request EnableRuleRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return EnableRuleResponse
 */
async function enableRuleWithOptions(request: EnableRuleRequest, runtime: Util.RuntimeOptions): EnableRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to enable an event rule.
  *
  * @param request EnableRuleRequest
  * @return EnableRuleResponse
 */
async function enableRule(request: EnableRuleRequest): EnableRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableRuleWithOptions(request, runtime);
}

model GetApiDestinationRequest {
  apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination.', example='api-destination-name'),
}

model GetApiDestinationResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  data?: {
    apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination.', example='demo'),
    connectionName?: string(name='ConnectionName', description='The connection name.', example='test-basic'),
    description?: string(name='Description', description='The description of the API destination.', example='demo'),
    gmtCreate?: long(name='GmtCreate', description='The time when the API destination was created.', example='1649055710565'),
    httpApiParameters?: {
      endpoint?: string(name='Endpoint', description='The endpoint of the API destination.', example='http://127.0.0.1:8001/api'),
      method?: string(name='Method', description='The HTTP request method. Valid values:

*   POST
*   GET
*   DELETE
*   PUT
*   HEAD
*   TRACE
*   PATCH', example='POST'),
    }(name='HttpApiParameters', description='The request parameters that are configured for the API destination.'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message. If the request is successful, success is returned. If the request failed, an error code is returned.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='B896B484-F16D-59DE-9E23-DD0E5C361108'),
}

model GetApiDestinationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetApiDestinationResponseBody(name='body'),
}

/**
  * You can call this API operation to query the information about an API destination.
  *
  * @param request GetApiDestinationRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetApiDestinationResponse
 */
async function getApiDestinationWithOptions(request: GetApiDestinationRequest, runtime: Util.RuntimeOptions): GetApiDestinationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apiDestinationName)) {
    query['ApiDestinationName'] = request.apiDestinationName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetApiDestination',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to query the information about an API destination.
  *
  * @param request GetApiDestinationRequest
  * @return GetApiDestinationResponse
 */
async function getApiDestination(request: GetApiDestinationRequest): GetApiDestinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getApiDestinationWithOptions(request, runtime);
}

model GetConnectionRequest {
  connectionName?: string(name='ConnectionName', description='The connection name.', example='connection-name'),
}

model GetConnectionResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  data?: {
    connections?: [ 
      {
        authParameters?: {
          apiKeyAuthParameters?: {
            apiKeyName?: string(name='ApiKeyName', description='The key of the API key.', example='key'),
            apiKeyValue?: string(name='ApiKeyValue', description='The value of the API key.', example='value'),
          }(name='ApiKeyAuthParameters', description='The information about API key authentication.'),
          authorizationType?: string(name='AuthorizationType', description='The authentication method. Valid values:

*   BASIC_AUTH: basic authentication.
*   API_KEY_AUTH: API key authentication.
*   OAUTH_AUTH: OAuth authentication.', example='BASIC_AUTH'),
          basicAuthParameters?: {
            password?: string(name='Password', description='The password of basic authentication.', example='********'),
            username?: string(name='Username', description='The username of basic authentication.', example='admin'),
          }(name='BasicAuthParameters', description='The information about basic authentication.'),
          OAuthParameters?: {
            authorizationEndpoint?: string(name='AuthorizationEndpoint', description='The endpoint that is used to obtain the OAuth token.', example='http://localhost:8080/oauth/token'),
            clientParameters?: {
              clientID?: string(name='ClientID', description='The client ID.', example='ClientID'),
              clientSecret?: string(name='ClientSecret', description='The AccessKey secret of the client.', example='Qo57Q~F249~S74GmNPA36pZJoJK4f****'),
            }(name='ClientParameters', description='The information about the client.'),
            httpMethod?: string(name='HttpMethod', description='The HTTP request method. Valid values:

*   GET
*   POST
*   HEAD', example='POST'),
            OAuthHttpParameters?: {
              bodyParameters?: [ 
                {
                  isValueSecret?: string(name='IsValueSecret', description='Indicates whether authentication is enabled.', example='false'),
                  key?: string(name='Key', description='The key of the request body.', example='keyDemo'),
                  value?: string(name='Value', description='The value of the request body.', example='valueDemo'),
                }
              ](name='BodyParameters', description='The information about the request body.'),
              headerParameters?: [ 
                {
                  isValueSecret?: string(name='IsValueSecret', description='Indicates whether authentication is enabled.', example='false'),
                  key?: string(name='Key', description='The key of the request header.', example='keyDemo'),
                  value?: string(name='Value', description='The value of the request header.', example='keyDemo'),
                }
              ](name='HeaderParameters', description='The information about the request header.'),
              queryStringParameters?: [ 
                {
                  isValueSecret?: string(name='IsValueSecret', description='Indicates whether authentication is enabled.', example='false'),
                  key?: string(name='Key', description='The key of the request path.', example='keyDemo'),
                  value?: string(name='Value', description='The value of the request path.', example='valueDemo'),
                }
              ](name='QueryStringParameters', description='The information about the request path.'),
            }(name='OAuthHttpParameters', description='The request parameters of OAuth authentication.'),
          }(name='OAuthParameters', description='The information about OAuth authentication.'),
        }(name='AuthParameters', description='The authentication methods.'),
        connectionName?: string(name='ConnectionName', description='The connection name.', example='demo'),
        description?: string(name='Description', description='The connection description.', example='demo'),
        gmtCreate?: long(name='GmtCreate', description='The time when the connection was created.', example='1669648905'),
        id?: long(name='Id', description='The data source ID.', example='5668'),
        networkParameters?: {
          networkType?: string(name='NetworkType', description='*   PublicNetwork: the Internet.
*   PrivateNetwork: virtual private cloud (VPC).', example='PublicNetwork'),
          securityGroupId?: string(name='SecurityGroupId', description='The security group ID.', example='eb-167adad548759-security_grop/sg-bp1addad26peuh9qh9****'),
          vpcId?: string(name='VpcId', description='The VPC ID.', example='eb-test/vpc-bp1symadadwnwg****'),
          vswitcheId?: string(name='VswitcheId', description='The vSwitch ID.', example='vsw-bp1iu4x7aeradadown****,vsw-bp193sqmadadlaszpeq****'),
        }(name='NetworkParameters', description='The information about the network.'),
      }
    ](name='Connections', description='The queried connections.'),
  }(name='Data', description='The returned data.'),
  httpCode?: int32(name='HttpCode', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='success'),
  requestId?: string(name='RequestId', description='The returned request ID.', example='34AD682D-5B91-5773-8132-AA38C130****'),
}

model GetConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConnectionResponseBody(name='body'),
}

/**
  * You can call this API operation to query the configurations of a connection.
  *
  * @param request GetConnectionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetConnectionResponse
 */
async function getConnectionWithOptions(request: GetConnectionRequest, runtime: Util.RuntimeOptions): GetConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionName)) {
    query['ConnectionName'] = request.connectionName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetConnection',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to query the configurations of a connection.
  *
  * @param request GetConnectionRequest
  * @return GetConnectionResponse
 */
async function getConnection(request: GetConnectionRequest): GetConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConnectionWithOptions(request, runtime);
}

model GetEventBusRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='MyEventBus'),
}

model GetEventBusResponseBody = {
  code?: string(name='Code', description='The response code. The value Success indicates that the request is successful.', example='Success'),
  data?: {
    createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates when the event bus was created.', example='1641781825000'),
    description?: string(name='Description', description='The description of the event bus.', example='demo'),
    eventBusARN?: string(name='EventBusARN', description='The Alibaba Cloud Resource Name (ARN) of the event bus.', example='acs:eventbridge:cn-hangzhou:123456789098****:eventbus/MyEventBus'),
    eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='MyEventBus'),
  }(name='Data', description='The data returned.'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='EventBusNotExist'),
  requestId?: string(name='RequestId', description='The request ID.', example='d5bfc188-4452-4ba7-b73a-a9005e522439'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='true'),
}

model GetEventBusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEventBusResponseBody(name='body'),
}

/**
  * You can call this API operation to query the detailed information about an event bus.
  *
  * @param request GetEventBusRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetEventBusResponse
 */
async function getEventBusWithOptions(request: GetEventBusRequest, runtime: Util.RuntimeOptions): GetEventBusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEventBus',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to query the detailed information about an event bus.
  *
  * @param request GetEventBusRequest
  * @return GetEventBusResponse
 */
async function getEventBus(request: GetEventBusRequest): GetEventBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEventBusWithOptions(request, runtime);
}

model GetEventStreamingRequest {
  eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream whose details you want to query.', example='myeventstreaming'),
}

model GetEventStreamingResponseBody = {
  code?: string(name='Code', description='The response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For a list of error codes, see Error codes.', example='Success'),
  data?: {
    description?: string(name='Description', description='The description of the event stream that is returned.', example='RocketMQ-to-RocketMQ'),
    eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream that is returned.', example='rocketmq-sync'),
    filterPattern?: string(name='FilterPattern', description='The rule that is used to filter events. If you leave this parameter empty, all events are matched.'),
    runOptions?: {
      batchWindow?: {
        countBasedWindow?: int32(name='CountBasedWindow', description='The maximum number of events that are allowed in the batch window. If this threshold is reached, data in the window is pushed downstream. When multiple batch windows exist, data is pushed if triggering conditions are met in one of the windows.', example='100'),
        timeBasedWindow?: int32(name='TimeBasedWindow', description='The maximum period of time during which events are allowed in the batch window. Unit: seconds. If this threshold is reached, data in the window is pushed downstream. When multiple batch windows exist, data is pushed if triggering conditions are met in one of the windows.', example='10'),
      }(name='BatchWindow', description='The batch window.'),
      deadLetterQueue?: {
        arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the dead-letter queue.', example='acs:ram::1550203943326350:role/edskmstoecs'),
      }(name='DeadLetterQueue', description='Indicates whether dead-letter queues are enabled. By default, dead-letter queues are disabled. Messages that fail to be pushed after allowed retries as specified by the retry policy are discarded.'),
      errorsTolerance?: string(name='ErrorsTolerance', description='The fault tolerance policy. The value NONE specifies that faults are not tolerated, and the value All specifies that all faults are tolerated.', example='ALL'),
      maximumTasks?: int32(name='MaximumTasks', description='The concurrency level.', example='2'),
      retryStrategy?: {
        maximumEventAgeInSeconds?: float(name='MaximumEventAgeInSeconds', description='The maximum period of time during which retries are performed.', example='512'),
        maximumRetryAttempts?: float(name='MaximumRetryAttempts', description='The maximum number of retries.', example='2'),
        pushRetryStrategy?: string(name='PushRetryStrategy', description='The retry policy. Valid values: BACKOFFRETRY and EXPONENTIALDECAY_RETRY.', example='BACKOFFRETRY'),
      }(name='RetryStrategy', description='The information about the retry policy that is used if the event fails to be pushed.'),
    }(name='RunOptions', description='The parameters that are configured for the runtime environment.'),
    sink?: {
      sinkFcParameters?: {
        body?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Body', description='The message body that is sent to the function.'),
        concurrency?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.', example='None'),
          value?: string(name='Value', description='The delivery concurrency. Minimum value: 1.', example='1'),
        }(name='Concurrency', description='The delivery concurrency. Minimum value: 1.'),
        functionName?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The function name.', example='mFunction'),
        }(name='FunctionName', description='The function name.'),
        invocationType?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The invocation type.', example='Async'),
        }(name='InvocationType', description='The invocation type. Valid values: Sync: synchronous Async: asynchronous'),
        qualifier?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The alias of the service to which the function belongs.', example='LATEST'),
        }(name='Qualifier', description='The alias of the service to which the function belongs.'),
        serviceName?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The name of the service.', example='myService'),
        }(name='ServiceName', description='The service name.'),
      }(name='SinkFcParameters', description='The parameters that are returned if the event target is Function Compute.'),
      sinkFnfParameters?: {
        executionName?: {
          form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.', example='None'),
          value?: string(name='Value', description='The execution name.', example='123'),
        }(name='ExecutionName', description='The execution name.'),
        flowName?: {
          form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.', example='None'),
          value?: string(name='Value', description='The flow name.', example='test-streaming-fnf'),
        }(name='FlowName', description='The flow name.'),
        input?: {
          form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.', example='None'),
          value?: string(name='Value', description='The execution input information.', example='123'),
        }(name='Input', description='The execution input information.'),
        roleName?: {
          form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.', example='None'),
          value?: string(name='Value', description='The role configuration.', example='Al****FNF-x****'),
        }(name='RoleName', description='The role name.'),
      }(name='SinkFnfParameters', description='The Sink Fnf parameters.'),
      sinkKafkaParameters?: {
        acks?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The acknowledgment information.', example='1'),
        }(name='Acks', description='The acknowledgment information.'),
        instanceId?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The instance ID.', example='Defaut_1283278472_sadkj'),
        }(name='InstanceId', description='The target service type is Message Queue for Apache Kafka.'),
        key?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The message key.', example='key'),
        }(name='Key', description='The message key.'),
        topic?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The topic name.', example='topic-test'),
        }(name='Topic', description='The topic name.'),
        value?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Value', description='The message content.'),
      }(name='SinkKafkaParameters', description='The parameters that are returned if the event target is Message Queue for Apache Kafka.'),
      sinkMNSParameters?: {
        body?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Body', description='The message content.'),
        isBase64Encode?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='Specifies that Base64 encoding is enabled.', example='true'),
        }(name='IsBase64Encode', description='Indicates whether Base64 encoding is enabled.'),
        queueName?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The name of the MNS queue.', example='MyQueue'),
        }(name='QueueName', description='The target service type is MNS.'),
      }(name='SinkMNSParameters', description='The parameters that are returned if the event target is Message Service (MNS).'),
      sinkRabbitMQParameters?: {
        body?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Body', description='The message content.'),
        exchange?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The name of the exchange in the Message Queue for RabbitMQ instance.', example='a_exchange'),
        }(name='Exchange', description='The exchange mode. This parameter is available only if TargetType is set to Exchange.'),
        instanceId?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The ID of the Message Queue for RabbitMQ instance.', example='e5c9b727-e06c-4d7e-84d5-f8ce644e00bf'),
        }(name='InstanceId', description='The target service type is Message Queue for RabbitMQ instance.'),
        messageId?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='MessageId', description='The message ID.'),
        properties?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Properties', description='The tags that are used to filter messages.'),
        queueName?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The name of the queue in the Message Queue for RabbitMQ instance.', example='MyQueue'),
        }(name='QueueName', description='The queue mode. This parameter is available only if TargetType is set to Queue.'),
        routingKey?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The routing rule for the message.', example='housekeeping'),
        }(name='RoutingKey', description='The routing rule for the message. This parameter is available only if TargetType is set to Exchange.'),
        targetType?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The type of the resource to which the event is delivered. Valid values: Exchange: exchanges. Queue: queues.', example='Exchange/Queue'),
        }(name='TargetType', description='The target type.'),
        virtualHostName?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The vhost name of the Message Queue for RabbitMQ instance.', example='rabbit-host'),
        }(name='VirtualHostName', description='The name of the vhost of the Message Queue for RabbitMQ instance.'),
      }(name='SinkRabbitMQParameters', description='The parameters that are returned if the event target is Message Queue for RabbitMQ.'),
      sinkRocketMQParameters?: {
        body?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Body', description='The message content.'),
        instanceId?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The ID of the Message Queue for Apache RocketMQ instance.', example='MQ_INST_164901546557****_BAAN****'),
        }(name='InstanceId', description='The target service type is Message Queue for Apache RocketMQ.'),
        keys?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Keys', description='The tags that are used to filter messages.'),
        properties?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Properties', description='The tags that are used to filter messages.'),
        tags?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Tags', description='The tags that are used to filter messages.'),
        topic?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The name of the topic in the Message Queue for Apache RocketMQ instance.', example='Mytopic'),
        }(name='Topic', description='The name of the topic in the Message Queue for Apache RocketMQ instance.'),
      }(name='SinkRocketMQParameters', description='Sink RocketMQ Parameters'),
      sinkSLSParameters?: {
        body?: {
          form?: string(name='Form', description='The method that is used to transform the event.', example='TEMPLATE'),
          template?: string(name='Template', description='The template based on which the event is transformed.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value before the transformation.', example='{
      "key": "value"
}'),
        }(name='Body', description='The message content.'),
        logStore?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The Log Service Logstore.', example='test-logstore'),
        }(name='LogStore', description='The Simple Log Service Logstore.'),
        project?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The Log Service project.', example='test-project'),
        }(name='Project', description='The Simple Log Service project.'),
        roleName?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The role name. If you want to authorize EventBridge to use this role to read logs in Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the RAM console.', example='testRole'),
        }(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Simple Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the Resource Access Management (RAM) console.'),
        topic?: {
          form?: string(name='Form', description='The method that is used to transform the event. Default value: CONSTANT.', example='CONSTANT'),
          template?: string(name='Template', description='The template style.'),
          value?: string(name='Value', description='The name of the topic in which logs are stored. The topic corresponds to the topic reserved field in Log Service.', example='testTopic'),
        }(name='Topic', description='The name of the topic in which logs are stored. The topic corresponds to the topic reserved field in Simple Log Service.'),
      }(name='SinkSLSParameters', description='Sink SLS Parameters'),
    }(name='Sink', description='The event target.'),
    source?: {
      sourceDTSParameters?: {
        brokerUrl?: string(name='BrokerUrl', description='The URL and port number of the data subscription channel.'),
        initCheckPoint?: string(name='InitCheckPoint', description='The consumer offset. A consumer offset is a timestamp that indicates when the SDK client consumes the first data record. The value is a UNIX timestamp.', example='1620962769'),
        password?: string(name='Password', description='The password of the consumer group.', example='admin'),
        sid?: string(name='Sid', description='The ID of the consumer group.', example='HD1'),
        taskId?: string(name='TaskId', description='The task ID.', example='f86e5814-b223-482c-b768-3b873297dade'),
        topic?: string(name='Topic', description='The topic to which you want to subscribe by using the data subscription channel.', example='TP_TEST_UNDERWRITE_ISSUE'),
        username?: string(name='Username', description='The account of the consumer group.', example='admin'),
      }(name='SourceDTSParameters', description='The parameters that are returned if the event source is Data Transmission Service (DTS).'),
      sourceKafkaParameters?: {
        consumerGroup?: string(name='ConsumerGroup', description='The ID of the consumer group that subscribes to the topic.', example='GID_TEST'),
        instanceId?: string(name='InstanceId', description='The instance ID.', example='i-bp1fbtrnqmjvgq66ajdw'),
        network?: string(name='Network', description='The network. Default value: Default. The value PublicNetwork specifies a virtual private cloud (VPC).', example='Default'),
        offsetReset?: string(name='OffsetReset', description='The offset.', example='latest'),
        regionId?: string(name='RegionId', description='The region ID of the Message Queue for Apache Kafka instance.', example='cn-hangzhou'),
        securityGroupId?: string(name='SecurityGroupId', description='The security group ID.', example='sg-2vcgdxz7o1n9zappuimt'),
        topic?: string(name='Topic', description='The name of the topic.', example='topic_empower_1642473600414'),
        vSwitchIds?: string(name='VSwitchIds', description='The vSwitch ID.', example='vsw-wz9qqeovkwjxlu9uc8rst'),
        vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-2zehizpoendb3nwwu9w5o'),
      }(name='SourceKafkaParameters', description='Source Kafka Parameters'),
      sourceMNSParameters?: {
        isBase64Decode?: boolean(name='IsBase64Decode', description='Indicates whether Base64 encoding is enabled.', example='true'),
        queueName?: string(name='QueueName', description='The name of the MNS queue.', example='demo'),
        regionId?: string(name='RegionId', description='The region ID of the MNS queue.', example='cn-hangzhou'),
      }(name='SourceMNSParameters', description='Source MNS Parameters'),
      sourceMQTTParameters?: {
        instanceId?: string(name='InstanceId', description='The instance ID.', example='i-2ze06wqdwk0uq14krrzv'),
        regionId?: string(name='RegionId', description='The region ID of the Message Queue for MQTT instance.', example='cn-shanghai'),
        topic?: string(name='Topic', description='The name of the topic in the Message Queue for MQTT instance.', example='TOPIC-cainiao-pcs-wms-instock-noPrealertPrintLabel'),
      }(name='SourceMQTTParameters', description='The parameters that are returned if the event source is Message Queue for MQTT.'),
      sourceRabbitMQParameters?: {
        instanceId?: string(name='InstanceId', description='The ID of the Message Queue for RabbitMQ instance.', example='i-f8z9a9mcgwri1c1idd0z'),
        queueName?: string(name='QueueName', description='The name of the queue in the Message Queue for RabbitMQ instance.', example='comp'),
        regionId?: string(name='RegionId', description='The region ID of the Message Queue for RabbitMQ instance.', example='cn-hangzhou'),
        virtualHostName?: string(name='VirtualHostName', description='The vhost name of the Message Queue for RabbitMQ instance.', example='eb-connect'),
      }(name='SourceRabbitMQParameters', description='Source RabbitMQ Parameters'),
      sourceRocketMQParameters?: {
        authType?: string(name='AuthType'),
        groupID?: string(name='GroupID', description='The ID of the consumer group in the Message Queue for Apache RocketMQ instance.', example='GID_group1'),
        instanceEndpoint?: string(name='InstanceEndpoint'),
        instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ instance.', example='i-f8zbher64dlm58plyfte'),
        instanceNetwork?: string(name='InstanceNetwork'),
        instancePassword?: string(name='InstancePassword'),
        instanceSecurityGroupId?: string(name='InstanceSecurityGroupId'),
        instanceType?: string(name='InstanceType'),
        instanceUsername?: string(name='InstanceUsername'),
        instanceVSwitchIds?: string(name='InstanceVSwitchIds'),
        instanceVpcId?: string(name='InstanceVpcId'),
        offset?: string(name='Offset', description='The consumer offset of messages. Valid values: CONSUME_FROM_LAST_OFFSET: Start consumption from the latest offset. CONSUME_FROM_FIRST_OFFSET: Start consumption from the earliest offset. CONSUME_FROM_TIMESTAMP: Start consumption from the offset at the specified point in time.', example='CONSUMEFROMLASTOFFSET'),
        regionId?: string(name='RegionId', description='The region ID of the Message Queue for Apache RocketMQ instance.', example='cn-hangzhou'),
        tag?: string(name='Tag', description='The tags that are used to filter messages.', example='v1'),
        timestamp?: long(name='Timestamp', description='The timestamp of the offset from which consumption starts. This parameter is valid only if you set the Offset parameter to CONSUME_FROM_TIMESTAMP.', example='1636597951964'),
        topic?: string(name='Topic', description='The topic to which the message belongs.', example='topic_add_anima'),
      }(name='SourceRocketMQParameters', description='Source RocketMQ Parameters'),
      sourceSLSParameters?: {
        consumePosition?: string(name='ConsumePosition', description='The starting consumer offset. The value begin indicates the earliest offset, and the value end indicates the latest offset. You can also specify a time in seconds to start consumption.', example='begin'),
        consumerGroup?: string(name='ConsumerGroup', description='The consumer group.'),
        logStore?: string(name='LogStore', description='The Log Service Logstore.', example='waf-logstore'),
        project?: string(name='Project', description='The Log Service project.', example='dmmzk'),
        roleName?: string(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the RAM console.', example='testRole'),
      }(name='SourceSLSParameters', description='The parameters that are returned if the event provider is Simple Log Service.'),
    }(name='Source', description='The event provider.'),
    status?: string(name='Status', description='The status of the event stream that is returned.', example='RUNNING'),
    transforms?: [ 
      {
        arn?: string(name='Arn'),
      }
    ](name='Transforms'),
  }(name='Data', description='The response parameters.'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='The event streaming [xxxx] not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='7892F480-58C9-5067-AB35-8A7BEF0F726A'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. The value true indicates that the operation is successful.', example='true'),
}

model GetEventStreamingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEventStreamingResponseBody(name='body'),
}

/**
  * You can call this API operation to query the details of an event stream.
  *
  * @param request GetEventStreamingRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetEventStreamingResponse
 */
async function getEventStreamingWithOptions(request: GetEventStreamingRequest, runtime: Util.RuntimeOptions): GetEventStreamingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to query the details of an event stream.
  *
  * @param request GetEventStreamingRequest
  * @return GetEventStreamingResponse
 */
async function getEventStreaming(request: GetEventStreamingRequest): GetEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEventStreamingWithOptions(request, runtime);
}

model GetRuleRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='default'),
  ruleName?: string(name='RuleName', description='The name of the event rule.', example='ram-changes'),
}

model GetRuleResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  data?: {
    createdTimestamp?: long(name='CreatedTimestamp', description='The timestamp that indicates when the event rule was created.', example='1607071602000'),
    description?: string(name='Description', description='The description of the event rule.', example='test'),
    eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='Housekeeping-Bus'),
    filterPattern?: string(name='FilterPattern', description='The event pattern, in JSON format. Valid values: stringEqual and stringExpression. You can specify up to five expressions in the map data structure in each field.

You can specify up to five expressions in the map data structure in each field.', example='{\\"source\\":[\\"acs.oss\\"],\\"type\\":[\\"oss:BucketQueried:GetBucketStat\\"]}'),
    ruleARN?: string(name='RuleARN', description='The Alibaba Cloud Resource Name (ARN) of the event rule.', example='acs:eventbridge:cn-hangzhou:123456789098****:eventbus/default/rule/myRule3'),
    ruleName?: string(name='RuleName', description='The name of the event rule.', example='ramrolechange-fc'),
    status?: string(name='Status', description='The status of the event rule. Valid values: ENABLE (default): The event rule is enabled. DISABLE: The event rule is disabled.', example='ENABLE'),
    targets?: [ 
      {
        deadLetterQueue?: {
          arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the event source.', example='acs:eventbridge:cn-hangzhou:164901546557****:eventbus/my-event-bus/eventsource/myRocketMQ.source'),
        }(name='DeadLetterQueue', description='The ID of the custom event target.'),
        detailMap?: map[string]any(name='DetailMap', description='The information about the event target.'),
        endpoint?: string(name='Endpoint', description='The endpoint of the event target.', example='acs:mns:cn-hangzhou:123456789098****:queues/myqueue'),
        errorsTolerance?: string(name='ErrorsTolerance'),
        id?: string(name='Id', description='The ID of the custom event target.', example='1'),
        paramList?: [ 
          {
            form?: string(name='Form', description='The format that is used by the event target parameter. For more information, see [Limits.](https://www.alibabacloud.com/help/en/eventbridge/latest/limits)', example='TEMPLATE'),
            resourceKey?: string(name='ResourceKey', description='The resource parameter of the event target. For more information, see [Limits.](https://www.alibabacloud.com/help/en/eventbridge/latest/limits)', example='body'),
            template?: string(name='Template', description='The template that is used by the event target parameter.', example='The value of ${key} is ${value}!'),
            value?: string(name='Value', description='The value of the event target parameter.', example='{\\"key\\"=\\"value\\"}'),
          }
        ](name='ParamList', description='The parameters that are configured for the event target.'),
        pushRetryStrategy?: string(name='PushRetryStrategy', description='The retry policy that is used to push events. Valid values: BACKOFF_RETRY: backoff retry. If an event failed to be pushed, it can be retried up to three times. The interval between two consecutive retries is a random value from 10 to 20. Unit: seconds. EXPONENTIAL_DECAY_RETRY: exponential decay retry. If an event failed to be pushed, it can be retried up to 176 times. The interval between two consecutive retries exponentially increases to 512 seconds, and the total retry time is one day. The specific retry intervals are 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 512, ..., and 512 seconds. The interval of 512 seconds is used for 167 retries.', example='BACKOFF_RETRY'),
        pushSelector?: string(name='PushSelector', description='The transformer that is used to push events.', example='MATCHED_EVENT'),
        type?: string(name='Type', description='The type of the event target. For more information, see [Event target parameters.](https://www.alibabacloud.com/help/en/eventbridge/latest/event-target-parameters)', example='acs.mns.queue'),
      }
    ](name='Targets', description='The event targets.'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='The event rule not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='2BC1857D-E633-5E79-B2C2-43EF5F7730D8'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='true'),
}

model GetRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRuleResponseBody(name='body'),
}

/**
  * You can call this API operation to query the details of an event rule.
  *
  * @param request GetRuleRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetRuleResponse
 */
async function getRuleWithOptions(request: GetRuleRequest, runtime: Util.RuntimeOptions): GetRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to query the details of an event rule.
  *
  * @param request GetRuleRequest
  * @return GetRuleResponse
 */
async function getRule(request: GetRuleRequest): GetRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRuleWithOptions(request, runtime);
}

model ListAliyunOfficialEventSourcesResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  data?: {
    eventSourceList?: [ 
      {
        arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the event bus.', example='acs:eventbridge:cn-hangzhou:SYSTEM:eventsource/acs.aliyuncvc'),
        ctime?: float(name='Ctime', description='The time when the event source was created. Unit: milliseconds.', example='1607071602000'),
        description?: string(name='Description', description='The description of the queried event source.'),
        eventBusName?: string(name='EventBusName', description='The name of the event source to which the queried event type belongs.', example='acs.aliyuncvc'),
        eventTypes?: [ 
          {
            eventSourceName?: string(name='EventSourceName', description='The name of the event source.', example='name'),
            groupName?: string(name='GroupName', description='The name of the group to which the queried event type belongs.', example='aliyuncvc:MeetingEvent'),
            name?: string(name='Name', description='The full name of the queried event type.', example='aliyuncvc:MeetingEvent:MeetingStateEvent'),
            shortName?: string(name='ShortName', description='The short name of the queried event type.', example='MeetingStateEvent'),
          }
        ](name='EventTypes', description='The queried event types.'),
        fullName?: string(name='FullName', example='E-MapReduce'),
        name?: string(name='Name', description='The name of the queried event source.', example='acs.aliyuncvc'),
        status?: string(name='Status', description='The status of the queried event source. Valid value: Activated.', example='Activated'),
        type?: string(name='Type', description='The type of the queried event source.', example='1'),
      }
    ](name='EventSourceList', description='The name of the event source to which the queried event type belongs.'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='InvalidArgument'),
  requestId?: string(name='RequestId', description='The request ID.', example='5f80e9b3-98d5-4f51-8412-c758818a03e4'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='true'),
}

model ListAliyunOfficialEventSourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAliyunOfficialEventSourcesResponseBody(name='body'),
}

/**
  * You can call this API operation to query all Alibaba Cloud service event sources.
  *
  * @param request ListAliyunOfficialEventSourcesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListAliyunOfficialEventSourcesResponse
 */
async function listAliyunOfficialEventSourcesWithOptions(runtime: Util.RuntimeOptions): ListAliyunOfficialEventSourcesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListAliyunOfficialEventSources',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to query all Alibaba Cloud service event sources.
  *
  * @return ListAliyunOfficialEventSourcesResponse
 */
async function listAliyunOfficialEventSources(): ListAliyunOfficialEventSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAliyunOfficialEventSourcesWithOptions(runtime);
}

model ListApiDestinationsRequest {
  apiDestinationNamePrefix?: string(name='ApiDestinationNamePrefix', description='The prefix of the API destination name.', example='api-demo'),
  connectionName?: string(name='ConnectionName', description='The connection name.', example='connection-name'),
  maxResults?: long(name='MaxResults', description='The maximum number of entries to be returned in a call. You can use this parameter and NextToken to implement paging.

*   Default value: 10.', example='10'),
  nextToken?: string(name='NextToken', description='If you set Limit and excess return values exist, this parameter is returned.

*   Default value: 0.', example='0'),
}

model ListApiDestinationsResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful.', example='Success'),
  data?: {
    apiDestinations?: [ 
      {
        apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination.', example='api-destination-2'),
        connectionName?: string(name='ConnectionName', description='The connection name.', example='connection-name'),
        description?: string(name='Description', description='The description of the connection.', example='demo'),
        gmtCreate?: long(name='GmtCreate', description='The time when the API destination was created.', example='1665223213000'),
        httpApiParameters?: {
          endpoint?: string(name='Endpoint', description='The endpoint of the API destination.', example='http://127.0.0.1:8001/api'),
          method?: string(name='Method', description='The HTTP request method. Valid values:

- POST

- GET

- DELETE

- PUT

- HEAD

- TRACE

- PATCH', example='POST'),
        }(name='HttpApiParameters', description='The request parameters that are configured for the API destination.'),
      }
    ](name='ApiDestinations', description='The API destinations.'),
    maxResults?: float(name='MaxResults', description='The maximum number of entries returned per page.', example='10'),
    nextToken?: string(name='NextToken', description='If excess return values exist, this parameter is returned.', example='1'),
    total?: float(name='Total', description='The total number of entries returned.', example='2'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message. If the request is successful, success is returned. If the request failed, an error code is returned.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='96D7C0AB-DCE5-5E82-96B8-4725E1706BB1'),
}

model ListApiDestinationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListApiDestinationsResponseBody(name='body'),
}

/**
  * You can use this API operation to query a list of API destinations.
  *
  * @param request ListApiDestinationsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListApiDestinationsResponse
 */
async function listApiDestinationsWithOptions(request: ListApiDestinationsRequest, runtime: Util.RuntimeOptions): ListApiDestinationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apiDestinationNamePrefix)) {
    query['ApiDestinationNamePrefix'] = request.apiDestinationNamePrefix;
  }
  if (!Util.isUnset(request.connectionName)) {
    query['ConnectionName'] = request.connectionName;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListApiDestinations',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can use this API operation to query a list of API destinations.
  *
  * @param request ListApiDestinationsRequest
  * @return ListApiDestinationsResponse
 */
async function listApiDestinations(request: ListApiDestinationsRequest): ListApiDestinationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApiDestinationsWithOptions(request, runtime);
}

model ListConnectionsRequest {
  connectionNamePrefix?: string(name='ConnectionNamePrefix', description='The key word that you specify to query connections. Connections can be queried by prefixes.', example='connection-name'),
  maxResults?: long(name='MaxResults', description='The maximum number of entries to be returned in a single call. You can use this parameter and the NextToken parameter to implement paging.

*   Default value: 10.', example='10'),
  nextToken?: string(name='NextToken', description='If you set the Limit parameter and excess return values exist, this parameter is returned.

*   Default value: 0.', example='0'),
}

model ListConnectionsResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The value Success indicates that the request is successful.', example='Success'),
  data?: {
    connections?: [ 
      {
        authParameters?: {
          apiKeyAuthParameters?: {
            apiKeyName?: string(name='ApiKeyName', description='The API key.', example='Token'),
            apiKeyValue?: string(name='ApiKeyValue', description='The value of the API key.', example='asdkjnqkwejooa'),
          }(name='ApiKeyAuthParameters', description='The parameters that are configured for API key authentication.'),
          authorizationType?: string(name='AuthorizationType', description='The authentication type. Valid values:

- BASIC_AUTH: basic authentication.

- API_KEY_AUTH: API key authentication.

- OAUTH_AUTH: OAuth authentication.', example='BASIC_AUTH'),
          basicAuthParameters?: {
            password?: string(name='Password', description='The password for basic authentication.', example='admin'),
            username?: string(name='Username', description='The username for basic authentication.', example='admin'),
          }(name='BasicAuthParameters', description='The parameters that are configured for basic authentication.'),
          OAuthParameters?: {
            authorizationEndpoint?: string(name='AuthorizationEndpoint', description='The endpoint that is used to obtain the OAuth token.', example='http://localhost:8080/oauth/token'),
            clientParameters?: {
              clientID?: string(name='ClientID', description='The client ID.', example='ClientID'),
              clientSecret?: string(name='ClientSecret', description='The client key secret of the application.', example='ClientSecret'),
            }(name='ClientParameters', description='The parameters that are configured for the client.'),
            httpMethod?: string(name='HttpMethod', description='The HTTP request method. Valid values:

- GET

- POST

- HEAD', example='POST'),
            OAuthHttpParameters?: {
              bodyParameters?: [ 
                {
                  isValueSecret?: string(name='IsValueSecret', description='Indicates whether authentication is enabled.', example='false'),
                  key?: string(name='Key', description='The key in the request body.', example='name'),
                  value?: string(name='Value', description='The value of the key in the request body.', example='demo'),
                }
              ](name='BodyParameters', description='The parameters that are configured for the request.'),
              headerParameters?: [ 
                {
                  isValueSecret?: string(name='IsValueSecret', description='Indicates whether authentication is enabled.', example='false'),
                  key?: string(name='Key', description='The key in the request header.', example='name'),
                  value?: string(name='Value', description='The value of the key in the request header.', example='demo'),
                }
              ](name='HeaderParameters', description='The parameters that are configured for the request header.'),
              queryStringParameters?: [ 
                {
                  isValueSecret?: string(name='IsValueSecret', description='Indicates whether authentication is enabled.', example='false'),
                  key?: string(name='Key', description='The key in the request path.', example='name'),
                  value?: string(name='Value', description='The value of the key in the request path.', example='demo'),
                }
              ](name='QueryStringParameters', description='The parameters that are configured for the request path.'),
            }(name='OAuthHttpParameters', description='The request parameters for OAuth authentication.'),
          }(name='OAuthParameters', description='The parameters that are configured for OAuth authentication.'),
        }(name='AuthParameters', description='The parameters that are configured for authentication.'),
        connectionName?: string(name='ConnectionName', description='The connection name.', example='connection-name'),
        description?: string(name='Description', description='The connection description.', example='The description of the connection.'),
        gmtCreate?: long(name='GmtCreate', description='The time when the connection was created.', example='1592838994234'),
        id?: long(name='Id', description='The connection ID.', example='1141093'),
        networkParameters?: {
          networkType?: string(name='NetworkType', description='The network type. Valid values:PublicNetwork and PrivateNetwork.', example='PublicNetwork'),
          securityGroupId?: string(name='SecurityGroupId', description='The security group ID.', example='eb-167adad548759-security_grop/sg-bp1addad26peuh9qh9rtyb'),
          vpcId?: string(name='VpcId', description='The virtual private cloud (VPC) ID.', example='eb-test/vpc-bp1symadadwnwgmqud'),
          vswitcheId?: string(name='VswitcheId', description='The vSwitch ID.', example='vsw-bp1iu4x7aeradadown1og8,vsw-bp193sqmadadlaszpeqbt2c'),
        }(name='NetworkParameters'),
      }
    ](name='Connections', description='The value of the key in the request path.'),
    maxResults?: float(name='MaxResults', description='The number of entries returned per page.', example='10'),
    nextToken?: string(name='NextToken', description='If excess return values exist, this parameter is returned.', example='0'),
    total?: float(name='Total', description='The total number of entries returned.', example='1'),
  }(name='Data', description='The information about the connections returned.'),
  message?: string(name='Message', description='The message returned.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use the ID to troubleshoot issues.', example='E3619976-8714-5D88-BBA2-6983D798A8BB'),
}

model ListConnectionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConnectionsResponseBody(name='body'),
}

/**
  * You can call this API operation to query connections.
  *
  * @param request ListConnectionsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListConnectionsResponse
 */
async function listConnectionsWithOptions(request: ListConnectionsRequest, runtime: Util.RuntimeOptions): ListConnectionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.connectionNamePrefix)) {
    body['ConnectionNamePrefix'] = request.connectionNamePrefix;
  }
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListConnections',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to query connections.
  *
  * @param request ListConnectionsRequest
  * @return ListConnectionsResponse
 */
async function listConnections(request: ListConnectionsRequest): ListConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConnectionsWithOptions(request, runtime);
}

model ListEventBusesRequest {
  limit?: int32(name='Limit', description='The maximum number of entries to be returned in a call. You can use this parameter and NextToken to implement paging. Note: Up to 100 entries can be returned in a call.', example='10'),
  namePrefix?: string(name='NamePrefix', description='The prefix of the names of the event buses that you want to query.', example='My'),
  nextToken?: string(name='NextToken', description='If you set Limit and excess return values exist, this parameter is returned.', example='10'),
}

model ListEventBusesResponseBody = {
  code?: string(name='Code', description='The returned HTTP status code. The HTTP status code 200 indicates that the request is successful.', example='200'),
  data?: {
    eventBuses?: [ 
      {
        createTimestamp?: long(name='CreateTimestamp', description='The timestamp that indicates when the event bus was created.', example='1607071602000'),
        description?: string(name='Description', description='The description of the queried event bus.', example='bus_description'),
        eventBusARN?: string(name='EventBusARN', description='The Alibaba Cloud Resource Name (ARN) of the queried event bus.', example='acs:eventbridge:cn-hangzhou:123456789098***:eventbus/default'),
        eventBusName?: string(name='EventBusName', description='The name of the queried event bus.', example='default'),
      }
    ](name='EventBuses', description='The timestamp that indicates when the event bus was created.'),
    nextToken?: string(name='NextToken', description='If excess return values exist, this parameter is returned.', example='10'),
    total?: int32(name='Total', description='The total number of entries.', example='2'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='InvalidArgument'),
  requestId?: string(name='RequestId', description='The request ID.', example='D1DCF64A-3F2C-5323-ADCB-3F4DF30FAD2D'),
  success?: boolean(name='Success', description='Indicates whether the event buses are successfully queried. Valid values: true and false.', example='true'),
}

model ListEventBusesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventBusesResponseBody(name='body'),
}

/**
  * You can call this API operation to query all event buses.
  *
  * @param request ListEventBusesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListEventBusesResponse
 */
async function listEventBusesWithOptions(request: ListEventBusesRequest, runtime: Util.RuntimeOptions): ListEventBusesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namePrefix)) {
    query['NamePrefix'] = request.namePrefix;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEventBuses',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to query all event buses.
  *
  * @param request ListEventBusesRequest
  * @return ListEventBusesResponse
 */
async function listEventBuses(request: ListEventBusesRequest): ListEventBusesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventBusesWithOptions(request, runtime);
}

model ListEventStreamingsRequest {
  limit?: int32(name='Limit', description='The maximum number of entries to be returned in a call. You can use this parameter and NextToken to implement paging. A maximum of 100 entries can be returned in a call.', example='10'),
  namePrefix?: string(name='NamePrefix', description='The name of the event stream that you want to query.', example='name'),
  nextToken?: string(name='NextToken', description='If you configure Limit and excess return values exist, this parameter is returned.', example='10'),
  sinkArn?: string(name='SinkArn', description='The ARN of the event target.', example='acs:fc:cn-hangzhou:118609547428****:services/fw1.LATEST/functions/log1'),
  sourceArn?: string(name='SourceArn', description='The Alibaba Cloud Resource Name (ARN) of the event source.', example='acs:alikafka:cn-hangzhou:118609547428****:instance/alikafka_pre-cn-zxu36kvi****/topic/test-topic'),
}

model ListEventStreamingsResponseBody = {
  code?: string(name='Code', description='The response code. Valid values:

Success: The request is successful.

Other codes: The request failed. For more information about error codes, see Error codes.', example='Success'),
  data?: {
    eventStreamings?: [ 
      {
        description?: string(name='Description', example='demo'),
        eventStreamingName?: string(name='EventStreamingName', example='name'),
        filterPattern?: string(name='FilterPattern'),
        runOptions?: {
          batchWindow?: {
            countBasedWindow?: int32(name='CountBasedWindow', example='100'),
            timeBasedWindow?: int32(name='TimeBasedWindow', example='10'),
          }(name='BatchWindow'),
          deadLetterQueue?: {
            arn?: string(name='Arn', example='acs:ram::1597871211794192:role/aliyunsaedefaultrole'),
          }(name='DeadLetterQueue'),
          errorsTolerance?: string(name='ErrorsTolerance', example='ALL'),
          maximumTasks?: int32(name='MaximumTasks', example='2'),
          retryStrategy?: {
            maximumEventAgeInSeconds?: float(name='MaximumEventAgeInSeconds', example='512'),
            maximumRetryAttempts?: float(name='MaximumRetryAttempts', example='2'),
            pushRetryStrategy?: string(name='PushRetryStrategy', example='EXPONENTIALDECAY_RETRY'),
          }(name='RetryStrategy'),
        }(name='RunOptions'),
        sink?: {
          sinkFcParameters?: {
            body?: {
              form?: string(name='Form', example='TEMPLATE'),
              template?: string(name='Template', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', example='{
      "key": "value"
}'),
            }(name='Body'),
            concurrency?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='1'),
            }(name='Concurrency'),
            functionName?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='mFunction'),
            }(name='FunctionName'),
            invocationType?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='Async'),
            }(name='InvocationType'),
            qualifier?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='LATEST'),
            }(name='Qualifier'),
            serviceName?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='myService'),
            }(name='ServiceName'),
          }(name='SinkFcParameters'),
          sinkFnfParameters?: {
            executionName?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='ExecutionName'),
            flowName?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='FlowName'),
            input?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Input'),
            roleName?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='RoleName'),
          }(name='SinkFnfParameters'),
          sinkKafkaParameters?: {
            acks?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='1'),
            }(name='Acks'),
            instanceId?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='Defaut_1283278472_sadkj'),
            }(name='InstanceId'),
            key?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='key'),
            }(name='Key'),
            topic?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='topic'),
            }(name='Topic'),
            value?: {
              form?: string(name='Form', example='TEMPLATE'),
              template?: string(name='Template', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', example='{
      "key": "value"
}'),
            }(name='Value'),
          }(name='SinkKafkaParameters'),
          sinkMNSParameters?: {
            body?: {
              form?: string(name='Form', example='TEMPLATE'),
              template?: string(name='Template', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', example='{
      "key": "value"
}'),
            }(name='Body'),
            isBase64Encode?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='true'),
            }(name='IsBase64Encode'),
            queueName?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='MyQueue'),
            }(name='QueueName'),
          }(name='SinkMNSParameters'),
          sinkRabbitMQParameters?: {
            body?: {
              form?: string(name='Form', example='TEMPLATE'),
              template?: string(name='Template', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', example='{
      "key": "value"
}'),
            }(name='Body'),
            exchange?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='a_exchange'),
            }(name='Exchange'),
            instanceId?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='si-296cd57939a1421b94ec'),
            }(name='InstanceId'),
            messageId?: {
              form?: string(name='Form', example='TEMPLATE'),
              template?: string(name='Template', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', example='{
      "key": "value"
}'),
            }(name='MessageId'),
            properties?: {
              form?: string(name='Form', example='TEMPLATE'),
              template?: string(name='Template', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', example='{
      "key": "value"
}'),
            }(name='Properties'),
            queueName?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='MyQueue'),
            }(name='QueueName'),
            routingKey?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='housekeeping'),
            }(name='RoutingKey'),
            targetType?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='Queue'),
            }(name='TargetType'),
            virtualHostName?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='rabbit-host'),
            }(name='VirtualHostName'),
          }(name='SinkRabbitMQParameters'),
          sinkRocketMQParameters?: {
            body?: {
              form?: string(name='Form', example='TEMPLATE'),
              template?: string(name='Template', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', example='{
      "key": "value"
}'),
            }(name='Body'),
            instanceId?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='MQ_INST_164901546557****_BAAN****'),
            }(name='InstanceId'),
            keys?: {
              form?: string(name='Form', example='TEMPLATE'),
              template?: string(name='Template', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', example='{
      "key": "value"
}'),
            }(name='Keys'),
            properties?: {
              form?: string(name='Form', example='TEMPLATE'),
              template?: string(name='Template', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', example='{
      "key": "value"
}'),
            }(name='Properties'),
            tags?: {
              form?: string(name='Form', example='TEMPLATE'),
              template?: string(name='Template', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', example='{
      "key": "value"
}'),
            }(name='Tags'),
            topic?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='topic'),
            }(name='Topic'),
          }(name='SinkRocketMQParameters', description='Sink RocketMQ Parameters'),
          sinkSLSParameters?: {
            body?: {
              form?: string(name='Form', example='TEMPLATE'),
              template?: string(name='Template', example='The value of ${key} is ${value}!'),
              value?: string(name='Value', example='{
      "key": "value"
}'),
            }(name='Body'),
            logStore?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='test-logstore'),
            }(name='LogStore'),
            project?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='test-project'),
            }(name='Project'),
            roleName?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='test-role'),
            }(name='RoleName'),
            topic?: {
              form?: string(name='Form', example='CONSTANT'),
              template?: string(name='Template'),
              value?: string(name='Value', example='topic'),
            }(name='Topic'),
          }(name='SinkSLSParameters', description='Sink SLS Parameters'),
        }(name='Sink'),
        source?: {
          sourceDTSParameters?: {
            brokerUrl?: string(name='BrokerUrl'),
            initCheckPoint?: string(name='InitCheckPoint', example='1620962769'),
            password?: string(name='Password', example='123456'),
            sid?: string(name='Sid', example='HG9'),
            taskId?: string(name='TaskId', example='1611b337285f44e2936a2c4170bbbb7f'),
            topic?: string(name='Topic', example='TP_TEST_UNDERWRITE_ISSUE'),
            username?: string(name='Username', example='admin'),
          }(name='SourceDTSParameters'),
          sourceKafkaParameters?: {
            consumerGroup?: string(name='ConsumerGroup', example='GID_TEST'),
            instanceId?: string(name='InstanceId', example='bastionhost-cn-i7m2gwt7z1n'),
            network?: string(name='Network', example='Default'),
            offsetReset?: string(name='OffsetReset', example='latest'),
            regionId?: string(name='RegionId', example='cn-chengdu'),
            securityGroupId?: string(name='SecurityGroupId', example='sg-5ud5f3p0rqqis69tpp8eho7cp'),
            topic?: string(name='Topic', example='topic_empower_1642473600414'),
            vSwitchIds?: string(name='VSwitchIds', example='vsw-bp1rmi8rind7eo50cbied'),
            vpcId?: string(name='VpcId', example='vpc-wz9ki1qdlx3cx5cbbhowf'),
          }(name='SourceKafkaParameters', description='Source Kafka Parameters'),
          sourceMNSParameters?: {
            isBase64Decode?: boolean(name='IsBase64Decode', example='true'),
            queueName?: string(name='QueueName', example='work4'),
            regionId?: string(name='RegionId', example='cn-zhangjiakou'),
          }(name='SourceMNSParameters', description='Source MNS Parameters'),
          sourceMQTTParameters?: {
            instanceId?: string(name='InstanceId', example='bastionhost-cn-zvp27kcha1r'),
            regionId?: string(name='RegionId', example='cn-qingdao'),
            topic?: string(name='Topic', example='migration_instance'),
          }(name='SourceMQTTParameters'),
          sourceRabbitMQParameters?: {
            instanceId?: string(name='InstanceId', example='dbaudit-cn-7mz2hqolc06'),
            queueName?: string(name='QueueName', example='liuyang'),
            regionId?: string(name='RegionId', example='cn-zhangjiakou'),
            virtualHostName?: string(name='VirtualHostName', example='eb-connect'),
          }(name='SourceRabbitMQParameters', description='Source RabbitMQ Parameters'),
          sourceRocketMQParameters?: {
            authType?: string(name='AuthType'),
            groupID?: string(name='GroupID', example='GID_group1'),
            instanceEndpoint?: string(name='InstanceEndpoint'),
            instanceId?: string(name='InstanceId', example='i-f8zbher64dlm58plyfte'),
            instanceNetwork?: string(name='InstanceNetwork'),
            instancePassword?: string(name='InstancePassword'),
            instanceSecurityGroupId?: string(name='InstanceSecurityGroupId'),
            instanceType?: string(name='InstanceType'),
            instanceUsername?: string(name='InstanceUsername'),
            instanceVSwitchIds?: string(name='InstanceVSwitchIds'),
            instanceVpcId?: string(name='InstanceVpcId'),
            offset?: string(name='Offset', example='CONSUMEFROMTIMESTAMP'),
            regionId?: string(name='RegionId', example='cn-chengdu'),
            tag?: string(name='Tag', example='v1'),
            timestamp?: long(name='Timestamp', example='1670742074043'),
            topic?: string(name='Topic', example='topic_add_anima'),
          }(name='SourceRocketMQParameters', description='Source RocketMQ Parameters'),
          sourceSLSParameters?: {
            consumePosition?: string(name='ConsumePosition', example='begin'),
            consumerGroup?: string(name='ConsumerGroup', example='go-dts-shelf-group'),
            logStore?: string(name='LogStore', example='waf-logstore'),
            project?: string(name='Project', example='dmmzk'),
            roleName?: string(name='RoleName', example='testRole'),
          }(name='SourceSLSParameters'),
        }(name='Source'),
        status?: string(name='Status', example='RUNNING'),
        transforms?: [ 
          {
            arn?: string(name='Arn'),
          }
        ](name='Transforms'),
      }
    ](name='EventStreamings', description='The status of the event stream that is returned.'),
    nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists. You must specify the pagination token in the next request.', example='177'),
    total?: int32(name='Total', description='The total number of records.', example='10'),
  }(name='Data', description='The information about the event streams.'),
  message?: string(name='Message', description='The returned error message.', example='The event streaming [xxxx] not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='283FF852-C4B8-58C9-9777-F88A5A16A79F'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. The value true indicates that the request is successful.', example='true'),
}

model ListEventStreamingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventStreamingsResponseBody(name='body'),
}

/**
  * You can call this API operation to query event streams.
  *
  * @param request ListEventStreamingsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListEventStreamingsResponse
 */
async function listEventStreamingsWithOptions(request: ListEventStreamingsRequest, runtime: Util.RuntimeOptions): ListEventStreamingsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namePrefix)) {
    body['NamePrefix'] = request.namePrefix;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.sinkArn)) {
    body['SinkArn'] = request.sinkArn;
  }
  if (!Util.isUnset(request.sourceArn)) {
    body['SourceArn'] = request.sourceArn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListEventStreamings',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to query event streams.
  *
  * @param request ListEventStreamingsRequest
  * @return ListEventStreamingsResponse
 */
async function listEventStreamings(request: ListEventStreamingsRequest): ListEventStreamingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventStreamingsWithOptions(request, runtime);
}

model ListRulesRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='default'),
  limit?: int32(name='Limit', description='The maximum number of entries to be returned in a single call. You can use this parameter and the NextToken parameter to implement paging. A maximum of 100 entries can be returned in a single call.', example='50'),
  nextToken?: string(name='NextToken', description='If you set the Limit parameter and excess return values exist, this parameter is returned.', example='1000'),
  ruleNamePrefix?: string(name='RuleNamePrefix', description='The prefix of the rule name.', example='test'),
}

model ListRulesResponseBody = {
  code?: string(name='Code', description='The error code. The value Success indicates that the request is successful.', example='Success'),
  data?: {
    nextToken?: string(name='NextToken', description='If excess return values exist, this parameter is returned.', example='1000'),
    rules?: [ 
      {
        createdTimestamp?: long(name='CreatedTimestamp', description='The creation timestamp.', example='1607071602000'),
        description?: string(name='Description', description='The rule description.', example='demo'),
        detailMap?: map[string]any(name='DetailMap', description='The details of the event rule.'),
        eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='demo'),
        filterPattern?: string(name='FilterPattern', description='The event pattern, in JSON format. Valid values: stringEqual pattern stringExpression pattern Each field can have a maximum of five expressions in the map data structure.

Each field can have a maximum of five expressions in the map data structure.', example='{\\"source\\":[\\"acs.oss\\"],\\"type\\":[\\"oss:BucketQueried:GetBucketStat\\"]}'),
        ruleARN?: string(name='RuleARN', description='The Alibaba Cloud Resource Name (ARN) of the rule.', example='acs:eventbridge:cn-hangzhou:123456789098****:eventbus/default/rule/myRule3'),
        ruleName?: string(name='RuleName', description='The name of the event rule.', example='tf-testacc-rule'),
        status?: string(name='Status', description='The status of the event rule. Valid values: ENABLE: The event rule is enabled. It is the default state of the event rule. DISABLE: The event rule is disabled.', example='ENABLE'),
        targets?: [ 
          {
            endpoint?: string(name='Endpoint', description='The endpoint of the event target.', example='acs:mns:cn-hangzhou:123456789098****:queues/myqueue'),
            errorsTolerance?: string(name='ErrorsTolerance'),
            id?: string(name='Id', description='The ID of the custom event target.', example='177'),
            pushSelector?: string(name='PushSelector', description='The transformer that is used to push events.', example='MATCHED_EVENT'),
            type?: string(name='Type', description='The type of the event target. For more information, see [Event target parameters.](https://www.alibabacloud.com/help/en/eventbridge/latest/event-target-parameters)', example='acs.mns.queue'),
          }
        ](name='Targets', description='The event targets.'),
      }
    ](name='Rules', description='The rules.'),
    total?: int32(name='Total', description='The total number of entries.', example='6'),
  }(name='Data', description='The data returned.'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='Specified parameter Limit is not valid.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C7043799-F4DA-5290-9249-97C359876D97'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: true and false.', example='true'),
}

model ListRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRulesResponseBody(name='body'),
}

/**
  * You can call this API operation to query all rules of an event bus.
  *
  * @param request ListRulesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListRulesResponse
 */
async function listRulesWithOptions(request: ListRulesRequest, runtime: Util.RuntimeOptions): ListRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ruleNamePrefix)) {
    query['RuleNamePrefix'] = request.ruleNamePrefix;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRules',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to query all rules of an event bus.
  *
  * @param request ListRulesRequest
  * @return ListRulesResponse
 */
async function listRules(request: ListRulesRequest): ListRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRulesWithOptions(request, runtime);
}

model ListTargetsRequest {
  arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the event rule.', example='acs:fc:cn-hangzhou:118609547428****:services/fc-connector.a1/functions/event'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='my-event-bus'),
  limit?: int32(name='Limit', description='The maximum number of entries returned per page.', example='10'),
  nextToken?: string(name='NextToken', description='If you configure Limit and excess return values exist, this parameter is returned.', example='0'),
  ruleName?: string(name='RuleName', description='The name of the event rule.', example='tf-testacc-rule'),
}

model ListTargetsResponseBody = {
  code?: string(name='Code', description='The returned response code. Valid values:

    Success: The request is successful. 

    Other codes: The request failed. For more information about error codes, see Error codes.', example='Success'),
  data?: {
    nextToken?: string(name='NextToken', description='If excess return values exist, this parameter is returned.', example='1'),
    targets?: [ 
      {
        endpoint?: string(name='Endpoint', example='acs:fc:cn-hangzhou:123456789098****:services/guide.LATEST/functions/HelloFC'),
        errorsTolerance?: string(name='ErrorsTolerance'),
        eventBusName?: string(name='EventBusName', example='sls-beijing-one1-tf'),
        id?: string(name='Id', example='1453'),
        paramList?: [ 
          {
            form?: string(name='Form', example='TEMPLATE'),
            resourceKey?: string(name='ResourceKey', example='body'),
            template?: string(name='Template', example='The value of ${key} is ${value}!'),
            value?: string(name='Value', example='{\\"key\\"=\\"value\\"}'),
          }
        ](name='ParamList'),
        ruleName?: string(name='RuleName', example='rule-uKAK2'),
        type?: string(name='Type', example='acs.fc.function'),
      }
    ](name='Targets', description='The name of the event rule.'),
    total?: int32(name='Total', description='The total number of entries.', example='18'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='EventRuleNotExisted'),
  requestId?: string(name='RequestId', description='The request ID.', example='5DAF96FB-A4B6-548C-B999-0BFDCB2261B9'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

    true: The request is successful. 

    false: The request failed.', example='true'),
}

model ListTargetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTargetsResponseBody(name='body'),
}

async function listTargetsWithOptions(request: ListTargetsRequest, runtime: Util.RuntimeOptions): ListTargetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.arn)) {
    query['Arn'] = request.arn;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTargets',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTargets(request: ListTargetsRequest): ListTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTargetsWithOptions(request, runtime);
}

model ListUserDefinedEventSourcesRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='testBus'),
  limit?: int32(name='Limit', description='The maximum number of entries to be returned in a call. You can use this parameter and NextToken to implement paging. Note: Up to 100 entries can be returned in a call.', example='50'),
  namePrefix?: string(name='NamePrefix', description='The name of the event source.', example='testName'),
  nextToken?: string(name='NextToken', description='If you configure Limit and excess return values exist, this parameter is returned.', example='100'),
}

model ListUserDefinedEventSourcesResponseBody = {
  code?: string(name='Code', description='The returned response code. Valid values:

*   Success: The request is successful.
*   Other codes: The request failed. For more information about error codes, see Error codes.', example='Success'),
  data?: {
    eventSourceList?: [ 
      {
        arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the queried event source.', example='acs:eventbridge:cn-hangzhou:164901546557****:eventbus/my-event-bus/eventsource/myRocketMQ.source'),
        ctime?: float(name='Ctime', description='The timestamp that indicates when the event source was created.', example='1607071602000'),
        eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='test-custom-bus'),
        externalSourceType?: string(name='ExternalSourceType', description='The type of the event source.', example='RabbitMQ'),
        name?: string(name='Name', description='The name of the queried event source.', example='rocketmq.source'),
        sourceHttpEventParameters?: {
          ip?: [ string ](name='Ip', description='The CIDR block that is used for security settings. This parameter is required only if SecurityConfig is set to ip. You can enter a CIDR block or an IP address.'),
          method?: [ string ](name='Method', description='The HTTP request method that is supported by the generated webhook URL. You can select multiple values. Valid values:

*   GET
*   POST
*   PUT
*   PATCH
*   DELETE
*   HEAD
*   OPTIONS
*   TRACE
*   CONNECT'),
          publicWebHookUrl?: [ string ](name='PublicWebHookUrl', description='The Internet request URL.'),
          referer?: [ string ](name='Referer', description='The security domain name. This parameter is required only if SecurityConfig is set to referer. You can enter a domain name.'),
          securityConfig?: string(name='SecurityConfig', description='The type of security settings. Valid values:

*   none: No configuration is required.
*   ip: CIDR block.
*   referer: security domain name.', example='none'),
          type?: string(name='Type', description='The protocol type that is supported by the generated webhook URL. Valid values:

*   HTTP
*   HTTPS
*   HTTP\\&HTTPS', example='HTTPS'),
          vpcWebHookUrl?: [ string ](name='VpcWebHookUrl', description='The internal request URL.'),
        }(name='SourceHttpEventParameters', description='The parameters that are returned if HTTP events are specified as the event source.'),
        sourceKafkaParameters?: {
          consumerGroup?: string(name='ConsumerGroup', description='The ID of the consumer group that subscribes to the topic.', example='test-gid'),
          instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache Kafka instance.', example='i-2ze6kiwzkebf04s5h8ds'),
          maximumTasks?: int32(name='MaximumTasks', description='The maximum number of consumers.', example='2'),
          network?: string(name='Network', description='The network. Valid values: Default and PublicNetwork. Default value: Default. The value PublicNetwork indicates a self-managed network.', example='Default'),
          offsetReset?: string(name='OffsetReset', description='The consumer offset.', example='earliest'),
          regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
          securityGroupId?: string(name='SecurityGroupId', description='The security group ID.', example='sg-f8zatts5g97x0j***'),
          topic?: string(name='Topic', description='The topic name.', example='topic_api_1674441611897'),
          vSwitchIds?: string(name='VSwitchIds', description='The vSwitch ID.', example='vsw-bp1hcrxq3mkcik***e'),
          vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-bp1kz3ohhzgrau2***'),
        }(name='SourceKafkaParameters', description='The parameters that are returned if Message Queue for Apache Kafka is specified as the event source.'),
        sourceMNSParameters?: {
          isBase64Decode?: boolean(name='IsBase64Decode', description='Indicates whether Base64 decoding is enabled. By default, Base64 decoding is enabled.', example='true'),
          queueName?: string(name='QueueName', description='The name of the MNS queue.', example='queue.openapi-sign-callback'),
          regionId?: string(name='RegionId', description='The region where the MNS queue resides.', example='cn-hangzhou'),
        }(name='SourceMNSParameters', description='The parameters that are returned if Message Service (MNS) is specified as the event source.'),
        sourceRabbitMQParameters?: {
          instanceId?: string(name='InstanceId', description='The ID of the Message Queue for RabbitMQ instance. For more information, see [Limits](~~163289~~).', example='bastionhost-cn-0ju2x28fj07'),
          queueName?: string(name='QueueName', description='The name of the queue on the Message Queue for RabbitMQ instance. For more information, see [Limits](~~163289~~).', example='file-upload-queue'),
          regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for RabbitMQ instance resides.', example='cn-hangzhou'),
          virtualHostName?: string(name='VirtualHostName', description='The name of the vhost of the Message Queue for RabbitMQ instance. For more information, see [Limits](~~163289~~).', example='eb-connect'),
        }(name='SourceRabbitMQParameters', description='The parameters that are returned if Message Queue for RabbitMQ is specified as the event source.'),
        sourceRocketMQParameters?: {
          authType?: string(name='AuthType', description='The authentication type. This parameter can be set to ACL or left empty.', example='ACL'),
          groupId?: string(name='GroupId', description='The ID of the consumer group on the Message Queue for Apache RocketMQ instance.', example='GID-test'),
          instanceEndpoint?: string(name='InstanceEndpoint', description='The instance endpoint.', example='registry-vpc.cn-hangzhou.aliyuncs.com'),
          instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ instance. For more information, see [Limits](~~163289~~).', example='bastionhost-cn-7mz293s9d1p'),
          instanceNetwork?: string(name='InstanceNetwork', description='The network that is used by the Message Queue for Apache RocketMQ instance.', example='PublicNetwork'),
          instancePassword?: string(name='InstancePassword', description='The instance password.', example='***'),
          instanceSecurityGroupId?: string(name='InstanceSecurityGroupId', description='The security group ID.', example='eb-167adad548***'),
          instanceType?: string(name='InstanceType', description='The instance type. Valid values: CLOUD\\_4, CLOUD\\_5, and SELF_BUILT. The value CLOUD\\_4 indicates that the instance is a Message Queue for Apache RocketMQ 4.0 instance. The value CLOUD\\_5 indicates that the instance is a Message Queue for Apache RocketMQ 5.0 instance. The value SELF_BUILT indicates that the instance is a self-managed RocketMQ instance.', example='CLOUD_5'),
          instanceUsername?: string(name='InstanceUsername', description='The instance username.', example='root'),
          instanceVSwitchIds?: string(name='InstanceVSwitchIds', description='The vSwitch ID.', example='vsw-bp1iu***'),
          instanceVpcId?: string(name='InstanceVpcId', description='The virtual private cloud (VPC) ID.', example='vpc-***'),
          offset?: string(name='Offset', description='The offset from which messages are consumed. Valid values:

*   CONSUME_FROM_LAST_OFFSET: Messages are consumed from the latest offset.
*   CONSUME_FROM_FIRST_OFFSET: Messages are consumed from the earliest offset.
*   CONSUME_FROM_TIMESTAMP: Messages are consumed from the offset at the specified point in time.

Default value: CONSUME_FROM_LAST_OFFSET.', example='CONSUMEFROMLASTOFFSET'),
          regionId?: string(name='RegionId', description='The region where the Message Queue for Apache RocketMQ instance resides.', example='cn-shenzhen'),
          tag?: string(name='Tag', description='The tag that is used to filter messages.', example='dataact'),
          timestamp?: float(name='Timestamp', description='The timestamp that indicates the time from which messages are consumed. This parameter is valid only if Offset is set to CONSUME_FROM_TIMESTAMP.', example='1664591760'),
          topic?: string(name='Topic', description='The name of the topic on the Message Queue for Apache RocketMQ instance. For more information, see [Limits](~~163289~~).', example='migration_instance'),
        }(name='SourceRocketMQParameters', description='The parameters that are returned if Message Queue for Apache RocketMQ is specified as the event source.'),
        sourceSLSParameters?: {
          consumePosition?: string(name='ConsumePosition', description='The consumer offset. The value begin indicates the earliest offset, and the value end indicates the latest offset. You can also specify a time in seconds to start message consumption.', example='end'),
          logStore?: string(name='LogStore', description='The Simple Log Service Logstore.', example='cloudfirewall-logstore'),
          project?: string(name='Project', description='The Simple Log Service project.', example='VideoTestProject'),
          roleName?: string(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Simple Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the Resource Access Management (RAM) console. For information about the permission policy of this role, see Create a custom event source of the Log Service type.', example='testRole'),
        }(name='SourceSLSParameters', description='The parameters that are returned if Simple Log Service is specified as the event source.'),
        sourceScheduledEventParameters?: {
          schedule?: string(name='Schedule', description='The cron expression.', example='0 1 * * * *'),
          timeZone?: string(name='TimeZone', description='The time zone in which the cron expression is executed.', example='GMT+0:00'),
          userData?: string(name='UserData'),
        }(name='SourceScheduledEventParameters', description='The parameters that are returned if scheduled events are specified as the event source.'),
        status?: string(name='Status', description='The status of the queried event source. The returned value Activated indicates that the event source is activated.', example='Activated'),
        type?: string(name='Type', description='The type of the queried event source. The returned value UserDefined indicates that the event source is a custom event source.', example='UserDefined'),
      }
    ](name='EventSourceList', description='The event sources.'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='InvalidArgument'),
  requestId?: string(name='RequestId', description='The request ID.', example='5169654A-7059-57E3-BFD9-33C7E012EA1B'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. The value true indicates that the operation is successful.', example='true'),
}

model ListUserDefinedEventSourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserDefinedEventSourcesResponseBody(name='body'),
}

/**
  * You can call this API operation to query custom event sources.
  *
  * @param request ListUserDefinedEventSourcesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListUserDefinedEventSourcesResponse
 */
async function listUserDefinedEventSourcesWithOptions(request: ListUserDefinedEventSourcesRequest, runtime: Util.RuntimeOptions): ListUserDefinedEventSourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namePrefix)) {
    query['NamePrefix'] = request.namePrefix;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserDefinedEventSources',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to query custom event sources.
  *
  * @param request ListUserDefinedEventSourcesRequest
  * @return ListUserDefinedEventSourcesResponse
 */
async function listUserDefinedEventSources(request: ListUserDefinedEventSourcesRequest): ListUserDefinedEventSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserDefinedEventSourcesWithOptions(request, runtime);
}

model PauseEventStreamingRequest {
  eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream that you want to stop.', example='rocketmq-sync'),
}

model PauseEventStreamingResponseBody = {
  code?: boolean(name='Code', description='The response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For more information about error codes, see Error codes.', example='Success'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='The event streaming [xxxx] not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='72ce027c-546a-4231-9cf6-ec58766027f9'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model PauseEventStreamingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PauseEventStreamingResponseBody(name='body'),
}

/**
  * You can call this API operation to stop an event stream that is running.
  *
  * @param request PauseEventStreamingRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return PauseEventStreamingResponse
 */
async function pauseEventStreamingWithOptions(request: PauseEventStreamingRequest, runtime: Util.RuntimeOptions): PauseEventStreamingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PauseEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to stop an event stream that is running.
  *
  * @param request PauseEventStreamingRequest
  * @return PauseEventStreamingResponse
 */
async function pauseEventStreaming(request: PauseEventStreamingRequest): PauseEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return pauseEventStreamingWithOptions(request, runtime);
}

model PutTargetsRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='eventTest'),
  ruleName?: string(name='RuleName', description='The name of the event rule.', example='ssr-send-to-vendor-test01'),
  targets?: [ 
    {
      deadLetterQueue?: {
        arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the dead-letter queue. Events that are not processed or whose maximum retries have been exceeded are written to the dead-letter queue.', example='acs:mns:cn-hangzhou:123456789098****:/queues/deadletterqueue or acs:mq:cn-hangzhou:123456789098****:/instances/MQ_INST_123456789098****_BX8QbBPL/topic/deadlettertopic or acs:alikafka:cn-hangzhou:123456789098****:instance/alikafka_post-cn-123456/topic/deadlettertopic or acs:eventbridge:cn-hangzhou:123456789098****:eventbus/deadletterbus'),
      }(name='DeadLetterQueue', description='The dead-letter queue. Events that are not processed or whose maximum retries have been exceeded are written to the dead-letter queue. The dead-letter queue feature supports the following queue types: Message Queue for Apache RocketMQ, Message Service, Message Queue for Apache Kafka, and event bus.'),
      endpoint?: string(name='Endpoint', description='The endpoint of the event target.', example='acs:fc:cn-hangzhou:123456789098****:services/guide.LATEST/functions/HelloFC'),
      errorsTolerance?: string(name='ErrorsTolerance', description='The fault tolerance policy. Valid values:

* **ALL**: ignores the error. Fault tolerance is allowed. If an error occurs, event processing is not blocked. If the message exceeds the number of retries specified by the retry policy, the message is delivered to a dead-letter queue or discarded based on your configurations.

* **NONE**: does not ignore the error. Fault tolerance is prohibited. If an error occurs and the message exceeds the number of retries specified by the retry policy, event processing is blocked.', example='ALL'),
      id?: string(name='Id', description='The ID of the custom event target.', example='Mlm123456JHd2RsRoKw'),
      paramList?: [ 
        {
          form?: string(name='Form', description='The method that is used to deliver events to the event target. For more information,see [Event target parameters.](https://www.alibabacloud.com/help/en/eventbridge/latest/event-target-parameters)', example='TEMPLATE'),
          resourceKey?: string(name='ResourceKey', description='The resource parameter of the event target. For more information,see [Event target parameters.](https://www.alibabacloud.com/help/en/eventbridge/latest/event-target-parameters)', example='body'),
          template?: string(name='Template', description='The template based on which events are delivered to the event target.', example='The value of ${key} is ${value}!'),
          value?: string(name='Value', description='The value of the event target parameter.', example='{\\"key\\"=\\"value\\"}'),
        }
      ](name='ParamList', description='The parameters that are configured for the event target.'),
      pushRetryStrategy?: string(name='PushRetryStrategy', description='The retry policy for pushing the event. Valid values:

* **BACKOFF_RETRY**: backoff retry. A failed event can be retried up to three times. The interval between two consecutive retries is a random value from 10 to 20. Unit: seconds.

* **EXPONENTIAL_DECAY_RETRY**: exponential decay retry. The request can be retried up to 176 times. The interval between two consecutive retries exponentially increases to 512 seconds, and the total retry time is one day. The specific retry intervals are 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 512, ..., and 512 seconds. The interval of 512 seconds can be used up to one hundred and sixty-seven times in total.', example='BACKOFFRETRY'),
      type?: string(name='Type', description='The type of the event target. For more information, see [Event target parameters.](https://www.alibabacloud.com/help/en/eventbridge/latest/event-target-parameters)', example='acs.fc.function'),
    }
  ](name='Targets', description='The event targets to be created or updated. For more information, see [Limits.](https://www.alibabacloud.com/help/en/eventbridge/latest/limits)'),
}

model PutTargetsShrinkRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='eventTest'),
  ruleName?: string(name='RuleName', description='The name of the event rule.', example='ssr-send-to-vendor-test01'),
  targetsShrink?: string(name='Targets', description='The event targets to be created or updated. For more information, see [Limits.](https://www.alibabacloud.com/help/en/eventbridge/latest/limits)'),
}

model PutTargetsResponseBody = {
  code?: string(name='Code', description='The response code. Valid values:

*   Success: The call succeeded.
*   Other codes: The call failed. For more information about error codes, see Error codes.', example='Success'),
  data?: {
    errorEntries?: [ 
      {
        entryId?: string(name='EntryId', description='The ID of the failed event target.', example='Mlm123456JHd2RsRoKw'),
        errorCode?: string(name='ErrorCode', description='The error code returned.', example='EventRuleTargetIdDuplicate'),
        errorMessage?: string(name='ErrorMessage', description='The error message returned.', example='The id of event target is duplicate!'),
      }
    ](name='ErrorEntries', description='The ID of the failed event target.'),
    errorEntriesCount?: int32(name='ErrorEntriesCount', description='The number of failed event targets. Valid values:

*   0: All event targets succeeded.
*   An integer other than 0: indicates the number of failed event targets.', example='0'),
  }(name='Data', description='The returned result.'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='The event rule not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='6FB52207-7621-5292-BDF2-A17E2E984160'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request is successful.
*   **false**: The request failed.', example='true'),
}

model PutTargetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutTargetsResponseBody(name='body'),
}

/**
  * You can call this API operation to create or update event targets under a rule.
  *
  * @param tmpReq PutTargetsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return PutTargetsResponse
 */
async function putTargetsWithOptions(tmpReq: PutTargetsRequest, runtime: Util.RuntimeOptions): PutTargetsResponse {
  Util.validateModel(tmpReq);
  var request = new PutTargetsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.targets)) {
    request.targetsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.targets, 'Targets', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.targetsShrink)) {
    query['Targets'] = request.targetsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutTargets',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to create or update event targets under a rule.
  *
  * @param request PutTargetsRequest
  * @return PutTargetsResponse
 */
async function putTargets(request: PutTargetsRequest): PutTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return putTargetsWithOptions(request, runtime);
}

model QueryEventRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='demo'),
  eventId?: string(name='EventId', description='The event ID.', example='1935debf-ddac-49dc-a090-d4f2857a046d'),
  eventSource?: string(name='EventSource'),
}

model QueryEventResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code 200 indicates that the request was successful.', example='200'),
  data?: map[string]any(name='Data', description='The content of the event.'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='EventBusNotExist'),
  requestId?: string(name='RequestId', description='The request ID.', example='580A938B-6107-586C-8EC7-F22EEBEDA9E6'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model QueryEventResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryEventResponseBody(name='body'),
}

/**
  * You can call this API operation to query the content of an event.
  *
  * @param request QueryEventRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return QueryEventResponse
 */
async function queryEventWithOptions(request: QueryEventRequest, runtime: Util.RuntimeOptions): QueryEventResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.eventSource)) {
    query['EventSource'] = request.eventSource;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEvent',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to query the content of an event.
  *
  * @param request QueryEventRequest
  * @return QueryEventResponse
 */
async function queryEvent(request: QueryEventRequest): QueryEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEventWithOptions(request, runtime);
}

model QueryEventTracesRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='MyEventBus'),
  eventId?: string(name='EventId', description='The event ID.', example='1935debf-ddac-49dc-a090-d4f2857a046d'),
}

model QueryEventTracesResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code 200 indicates that the request was successful.', example='200'),
  data?: [ 
    {
      action?: string(name='Action', description='The type of the event trace. Valid values: PutEvent: a delivery event. FilterEvent: a filtering event. PushEvent: a pushing event.', example='PutEvent'),
      actionTime?: long(name='ActionTime', description='The execution time of the event trace.', example='1659495343896'),
      endpoint?: string(name='Endpoint', description='The endpoint of the event target. This parameter is returned if the value of the Action parameter is PushEvent.', example='acs:mns:cn-zhangjiakou:123456789098****:queues/testQueue'),
      eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='demo'),
      eventId?: string(name='EventId', description='The event ID.', example='a5747e4f-2af2-40b6-b262-d0140e995bf7'),
      eventSource?: string(name='EventSource', description='The name of the event source.', example='cert-api'),
      notifyLatency?: string(name='NotifyLatency', description='The delivery delay of the event target. This parameter is returned if the value of the Action parameter is PushEvent.', example='80'),
      notifyStatus?: string(name='NotifyStatus', description='The event target delivery status.', example='[200]Ok'),
      notifyTime?: long(name='NotifyTime', description='The delivery time of the event target. This parameter is returned if the value of the Action parameter is PushEvent.', example='1659495343896'),
      receivedTime?: long(name='ReceivedTime', description='The time when the event was delivered to the event bus. This parameter is returned if the value of the Action parameter is PutEvent.', example='1659495343896'),
      ruleMatchingTime?: string(name='RuleMatchingTime', description='The time when the event rule was matched. This parameter is returned if the value of the Action parameter is FilterEvent.', example='1659495343896'),
      ruleName?: string(name='RuleName', description='The name of the event rule.', example='ramrolechange-mns'),
    }
  ](name='Data', description='The name of the event source.'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='EventBusNotExist'),
  requestId?: string(name='RequestId', description='The request ID.', example='BB934571-1F5A-5E17-91DD-E2BC3E1BFBFF'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model QueryEventTracesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryEventTracesResponseBody(name='body'),
}

/**
  * You can call this API operation to query event traces.
  *
  * @param request QueryEventTracesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return QueryEventTracesResponse
 */
async function queryEventTracesWithOptions(request: QueryEventTracesRequest, runtime: Util.RuntimeOptions): QueryEventTracesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEventTraces',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to query event traces.
  *
  * @param request QueryEventTracesRequest
  * @return QueryEventTracesResponse
 */
async function queryEventTraces(request: QueryEventTracesRequest): QueryEventTracesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEventTracesWithOptions(request, runtime);
}

model QueryTracedEventByEventIdRequest {
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='demo'),
  eventId?: string(name='EventId', description='The event ID.', example='1935debf-ddac-49dc-a090-d4f2857a046d'),
  eventSource?: string(name='EventSource', description='The name of the event source.', example='mse'),
}

model QueryTracedEventByEventIdResponseBody = {
  code?: string(name='Code', description='The returned HTTP status code. The HTTP status code 200 indicates that the request is successful.', example='200'),
  data?: [ 
    {
      events?: [ 
        {
          eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='default'),
          eventId?: string(name='EventId', description='The event ID.', example='37C-1P6Yn6EM7TcH37Vod8w7rbSeimJ'),
          eventReceivedTime?: long(name='EventReceivedTime', description='The time when the event was delivered to the event bus.', example='1661773573100'),
          eventSource?: string(name='EventSource', description='The name of the event source.', example='cert-api'),
          eventType?: string(name='EventType', description='The event type.', example='eventbridge:Events:HTTPEvent'),
        }
      ](name='Events', description='The events.'),
      nextToken?: string(name='NextToken', description='If excess return values exist, this parameter is returned.', example='1000'),
      total?: int32(name='Total', description='The total number of entries returned.', example='18'),
    }
  ](name='Data', description='The total number of entries returned.'),
  message?: string(name='Message', description='The returned error message.', example='EventBusNotExist'),
  requestId?: string(name='RequestId', description='The request ID.', example='A5D7B9F4-BF96-51A9-90B1-928955FABB5B'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model QueryTracedEventByEventIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTracedEventByEventIdResponseBody(name='body'),
}

/**
  * You can call this API operation to query event traces by event ID.
  *
  * @param request QueryTracedEventByEventIdRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return QueryTracedEventByEventIdResponse
 */
async function queryTracedEventByEventIdWithOptions(request: QueryTracedEventByEventIdRequest, runtime: Util.RuntimeOptions): QueryTracedEventByEventIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.eventSource)) {
    query['EventSource'] = request.eventSource;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTracedEventByEventId',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to query event traces by event ID.
  *
  * @param request QueryTracedEventByEventIdRequest
  * @return QueryTracedEventByEventIdResponse
 */
async function queryTracedEventByEventId(request: QueryTracedEventByEventIdRequest): QueryTracedEventByEventIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTracedEventByEventIdWithOptions(request, runtime);
}

model QueryTracedEventsRequest {
  endTime?: long(name='EndTime', description='The end of the time range when event traces are queried. Unit: milliseconds.', example='1661773509000'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='MyEventBus'),
  eventSource?: string(name='EventSource', description='The name of the event source.', example='mse'),
  eventType?: string(name='EventType', description='The event type.', example='eventbridge:Events:HTTPEvent'),
  limit?: int32(name='Limit', description='The maximum number of entries to be returned in a call. You can use this parameter and NextToken to implement paging. Up to 100 entries can be returned in a call.', example='50'),
  matchedRule?: string(name='MatchedRule', description='The name of the event rule that is matched.', example='test-mnsrule'),
  nextToken?: string(name='NextToken', description='If you configure Limit and excess return values exist, this parameter is returned.', example='1000'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query event traces. Unit: milliseconds.', example='1661773509000'),
}

model QueryTracedEventsResponseBody = {
  code?: string(name='Code', description='The returned HTTP status code. The HTTP status code 200 indicates that the request is successful.', example='200'),
  data?: {
    events?: [ 
      {
        eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='test-custom-bus'),
        eventId?: string(name='EventId', description='The event ID.', example='07E-1OCckaVzNB92BIFFh4xgydOF1wd'),
        eventReceivedTime?: long(name='EventReceivedTime', description='The time when the event was delivered to the event bus.', example='1661773573100'),
        eventSource?: string(name='EventSource', description='The name of the event source.', example='acs.resourcemanager'),
        eventType?: string(name='EventType', description='The event type.', example='eventbridge:Events:HTTPEvent'),
      }
    ](name='Events', description='The event type.'),
    nextToken?: string(name='NextToken', description='If excess return values exist, this parameter is returned.', example='1000'),
    total?: int32(name='Total', description='The total number of entries.', example='6'),
  }(name='Data', description='The data returned.'),
  message?: string(name='Message', description='The returned error message.', example='EventBusNotExist'),
  requestId?: string(name='RequestId', description='The request ID.', example='d9e4628b-8b34-4f33-82be-5aac50aac0ba'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model QueryTracedEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTracedEventsResponseBody(name='body'),
}

/**
  * You can call this API operation to query event traces by time range.
  *
  * @param request QueryTracedEventsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return QueryTracedEventsResponse
 */
async function queryTracedEventsWithOptions(request: QueryTracedEventsRequest, runtime: Util.RuntimeOptions): QueryTracedEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventSource)) {
    query['EventSource'] = request.eventSource;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.matchedRule)) {
    query['MatchedRule'] = request.matchedRule;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTracedEvents',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to query event traces by time range.
  *
  * @param request QueryTracedEventsRequest
  * @return QueryTracedEventsResponse
 */
async function queryTracedEvents(request: QueryTracedEventsRequest): QueryTracedEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTracedEventsWithOptions(request, runtime);
}

model StartEventStreamingRequest {
  eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream that you want to enable.', example='rocketmq-sync'),
}

model StartEventStreamingResponseBody = {
  code?: boolean(name='Code', description='The returned response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For more information about error codes, see Error codes.', example='Success'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='The event streaming [xxxx] not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='8CEAD24D-328D-5539-9D30-FD2D33204FBB'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model StartEventStreamingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartEventStreamingResponseBody(name='body'),
}

/**
  * You can call this API operation to enable a created or deactivated event stream.
  *
  * @param request StartEventStreamingRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return StartEventStreamingResponse
 */
async function startEventStreamingWithOptions(request: StartEventStreamingRequest, runtime: Util.RuntimeOptions): StartEventStreamingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to enable a created or deactivated event stream.
  *
  * @param request StartEventStreamingRequest
  * @return StartEventStreamingResponse
 */
async function startEventStreaming(request: StartEventStreamingRequest): StartEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return startEventStreamingWithOptions(request, runtime);
}

model TestEventPatternRequest {
  event?: string(name='Event', description='The event.', example='{
    "datacontenttype": "application/json;charset=utf-8",
    "aliyunaccountid": "*****",
    "aliyunpublishtime": "2023-04-****:54:57.939Z",
    "data": {
        "resourceEventType": "****",
        "resourceCreateTime": "****",
        "resourceId": "sls-code-***-debug",
        "captureTime": "***"
    },
    "aliyunoriginalaccountid": "****",
    "specversion": "1.0",
    "aliyuneventbusname": "****",
    "id": "295e6bd2-bb72-4f70-****-204a0680ee41",
    "source": "acs.sls",
    "time": "2023-04-***:37:56Z",
    "aliyunregionid": "cn-***",
    "type": "sls:Config:****"
}'),
  eventPattern?: string(name='EventPattern', description='The event pattern.', example='{"key1": "value1"}'),
}

model TestEventPatternResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For more information about error codes, see Error codes.', example='Success'),
  data?: {
    result?: boolean(name='Result', description='The value true indicates that the event pattern matches the provided JSON format. The value false indicates that the event pattern does not match the provided JSON format.', example='true'),
  }(name='Data', description='The returned result.'),
  message?: string(name='Message', description='The error message returned if the request failed.'),
  requestId?: string(name='RequestId', description='The request ID.', example='96D7C0AB-DCE5-5E82-96B8-4725E1706BB1'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model TestEventPatternResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TestEventPatternResponseBody(name='body'),
}

/**
  * You can call this API operation to check whether the event pattern matches the provided JSON format.
  *
  * @param request TestEventPatternRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return TestEventPatternResponse
 */
async function testEventPatternWithOptions(request: TestEventPatternRequest, runtime: Util.RuntimeOptions): TestEventPatternResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.event)) {
    body['Event'] = request.event;
  }
  if (!Util.isUnset(request.eventPattern)) {
    body['EventPattern'] = request.eventPattern;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TestEventPattern',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to check whether the event pattern matches the provided JSON format.
  *
  * @param request TestEventPatternRequest
  * @return TestEventPatternResponse
 */
async function testEventPattern(request: TestEventPatternRequest): TestEventPatternResponse {
  var runtime = new Util.RuntimeOptions{};
  return testEventPatternWithOptions(request, runtime);
}

model UpdateApiDestinationRequest {
  apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination. The name must be 2 to 127 characters in length.', example='api-destination-name'),
  connectionName?: string(name='ConnectionName', description='The name of the connection. The name must be 2 to 127 characters in length.

Note: Before you configure this parameter, you must call the CreateConnection operation to create a connection. Then, set this parameter to the name of the connection that you created.', example='connection-name'),
  description?: string(name='Description', description='The description of the API destination. The description can be up to 255 characters in length.', example='demo'),
  httpApiParameters?: {
    endpoint?: string(name='Endpoint', description='The endpoint of the API destination. The endpoint can be up to 127 characters in length.', example='http://127.0.0.1:8001/api'),
    method?: string(name='Method', description='The HTTP request method. Valid values:

- GET
- POST
- HEAD
- DELETE
- PUT
- PATCH', example='POST'),
  }(name='HttpApiParameters', description='The parameters that are configured for the API destination.'),
}

model UpdateApiDestinationShrinkRequest {
  apiDestinationName?: string(name='ApiDestinationName', description='The name of the API destination. The name must be 2 to 127 characters in length.', example='api-destination-name'),
  connectionName?: string(name='ConnectionName', description='The name of the connection. The name must be 2 to 127 characters in length.

Note: Before you configure this parameter, you must call the CreateConnection operation to create a connection. Then, set this parameter to the name of the connection that you created.', example='connection-name'),
  description?: string(name='Description', description='The description of the API destination. The description can be up to 255 characters in length.', example='demo'),
  httpApiParametersShrink?: string(name='HttpApiParameters', description='The parameters that are configured for the API destination.'),
}

model UpdateApiDestinationResponseBody = {
  apiDestinationName?: string(name='ApiDestinationName', description='api-destination-name', example='api-destination-name'),
  code?: string(name='Code', description='The response code. If the request is successful, Success is returned.', example='Success'),
  message?: string(name='Message', description='The returned message. If the request is successful, success is returned.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='382E6272-8E9C-5681-AC96-A8AF0BFAC1A5'),
}

model UpdateApiDestinationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateApiDestinationResponseBody(name='body'),
}

/**
  * You can call this API operation to update an API destination.
  *
  * @param tmpReq UpdateApiDestinationRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateApiDestinationResponse
 */
async function updateApiDestinationWithOptions(tmpReq: UpdateApiDestinationRequest, runtime: Util.RuntimeOptions): UpdateApiDestinationResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateApiDestinationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.httpApiParameters)) {
    request.httpApiParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.httpApiParameters, 'HttpApiParameters', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.apiDestinationName)) {
    query['ApiDestinationName'] = request.apiDestinationName;
  }
  if (!Util.isUnset(request.connectionName)) {
    query['ConnectionName'] = request.connectionName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.httpApiParametersShrink)) {
    query['HttpApiParameters'] = request.httpApiParametersShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApiDestination',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to update an API destination.
  *
  * @param request UpdateApiDestinationRequest
  * @return UpdateApiDestinationResponse
 */
async function updateApiDestination(request: UpdateApiDestinationRequest): UpdateApiDestinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateApiDestinationWithOptions(request, runtime);
}

model UpdateConnectionRequest {
  authParameters?: {
    apiKeyAuthParameters?: {
      apiKeyName?: string(name='ApiKeyName', description='The key of the API key.', example='name'),
      apiKeyValue?: string(name='ApiKeyValue', description='The value of the API key.', example='demo'),
    }(name='ApiKeyAuthParameters', description='The parameters for API key authentication.'),
    authorizationType?: string(name='AuthorizationType', description='The authentication type. Valid values:

BASIC_AUTH: basic authentication.

Introduction: Basic authentication is a simple authentication scheme built into the HTTP protocol. When you use the HTTP protocol for communications, the authentication method that the HTTP server uses to authenticate user identities on the client is defined in the protocol. The request header is in the Authorization: Basic Base64-encoded string (Username:Password) format.

1.  Username and Password are required.

API_KEY_AUTH: API key authentication.

Introduction: The request header is in the Token : Token value format.

*   ApiKeyName and ApiKeyValue are required.

OAUTH_AUTH: OAuth authentication.

Introduction: OAuth2.0 is an authentication mechanism. In normal cases, a system that does not use OAuth2.0 can access the resources of the server from the client. To ensure access security, access tokens are used to identify users in OAuth 2.0. The client must use an access token to access protected resources. This way, OAuth 2.0 protects resources from being accessed from malicious clients and improves system security.

*   AuthorizationEndpoint, OAuthHttpParameters, and HttpMethod are required.', example='BASIC_AUTH'),
    basicAuthParameters?: {
      password?: string(name='Password', description='The password for basic authentication.', example='admin'),
      username?: string(name='Username', description='The username for basic authentication.', example='admin'),
    }(name='BasicAuthParameters', description='The parameters that are configured for basic authentication.'),
    OAuthParameters?: {
      authorizationEndpoint?: string(name='AuthorizationEndpoint', description='The endpoint that is used to obtain the OAuth token. The endpoint can be up to 127 characters in length.', example='http://localhost:8080/oauth/token'),
      clientParameters?: {
        clientID?: string(name='ClientID', description='The client ID.', example='ClientID'),
        clientSecret?: string(name='ClientSecret', description='The AccessKey secret of the client.', example='ClientSecret'),
      }(name='ClientParameters', description='The parameters that are configured for the client.'),
      httpMethod?: string(name='HttpMethod', description='The HTTP request method. Valid values:

*   GET
*   POST
*   HEAD
*   DELETE
*   PUT
*   PATCH', example='POST'),
      OAuthHttpParameters?: {
        bodyParameters?: [ 
          {
            isValueSecret?: string(name='IsValueSecret', description='Specifies whether to enable authentication.', example='false'),
            key?: string(name='Key', description='The key of the request body.', example='name'),
            value?: string(name='Value', description='The value of the request body.', example='demo'),
          }
        ](name='BodyParameters', description='The parameters that are configured for the request body.'),
        headerParameters?: [ 
          {
            isValueSecret?: string(name='IsValueSecret', description='Specifies whether to enable authentication.', example='false'),
            key?: string(name='Key', description='The key of the request header.', example='name'),
            value?: string(name='Value', description='The value of the request header.', example='demo'),
          }
        ](name='HeaderParameters', description='The value of the request header.'),
        queryStringParameters?: [ 
          {
            isValueSecret?: string(name='IsValueSecret', description='Specifies whether to enable authentication.', example='false'),
            key?: string(name='Key', description='The key of the request path.', example='name'),
            value?: string(name='Value', description='The value of the request path.', example='demo'),
          }
        ](name='QueryStringParameters', description='The parameters that are configured for the request path.'),
      }(name='OAuthHttpParameters', description='The request parameters for OAuth authentication.'),
    }(name='OAuthParameters', description='The parameters that are configured for OAuth authentication.'),
  }(name='AuthParameters', description='The parameters that are configured for authentication.'),
  connectionName?: string(name='ConnectionName', description='The name of the connection that you want to update. The name must be 2 to 127 characters in length.', example='connection-name'),
  description?: string(name='Description', description='The description of the connection. The description can be up to 255 characters in length.', example='The description of the connection.'),
  networkParameters?: {
    networkType?: string(name='NetworkType', description='PublicNetwork: the Internet.

PrivateNetwork: virtual private cloud (VPC).

Note: If you set this parameter to PrivateNetwork, you must configure VpcId, VswitcheId, and SecurityGroupId.', example='PublicNetwork'),
    securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', example='eb-167adad548759-security_grop/sg-bp1addad26peuh9qh9rtyb'),
    vpcId?: string(name='VpcId', description='The VPC ID.', example='eb-test/vpc-bp1symadadwnwgmqud'),
    vswitcheId?: string(name='VswitcheId', description='The vSwitch ID.', example='vsw-bp1iu4x7aeradadown1og8,vsw-bp193sqmadadlaszpeqbt2c'),
  }(name='NetworkParameters', description='The parameters that are configured for the network.'),
}

model UpdateConnectionShrinkRequest {
  authParametersShrink?: string(name='AuthParameters', description='The parameters that are configured for authentication.'),
  connectionName?: string(name='ConnectionName', description='The name of the connection that you want to update. The name must be 2 to 127 characters in length.', example='connection-name'),
  description?: string(name='Description', description='The description of the connection. The description can be up to 255 characters in length.', example='The description of the connection.'),
  networkParametersShrink?: string(name='NetworkParameters', description='The parameters that are configured for the network.'),
}

model UpdateConnectionResponseBody = {
  code?: string(name='Code', description='The returned response code.', example='Success'),
  message?: string(name='Message', description='The returned message.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='8346BE8F-40F3-533D-A0B8-1359C31BD5BA'),
}

model UpdateConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateConnectionResponseBody(name='body'),
}

/**
  * You can call this API operation to update a connection.
  *
  * @param tmpReq UpdateConnectionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateConnectionResponse
 */
async function updateConnectionWithOptions(tmpReq: UpdateConnectionRequest, runtime: Util.RuntimeOptions): UpdateConnectionResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateConnectionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.authParameters)) {
    request.authParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.authParameters, 'AuthParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.networkParameters)) {
    request.networkParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.networkParameters, 'NetworkParameters', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.authParametersShrink)) {
    query['AuthParameters'] = request.authParametersShrink;
  }
  if (!Util.isUnset(request.connectionName)) {
    query['ConnectionName'] = request.connectionName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.networkParametersShrink)) {
    query['NetworkParameters'] = request.networkParametersShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConnection',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to update a connection.
  *
  * @param request UpdateConnectionRequest
  * @return UpdateConnectionResponse
 */
async function updateConnection(request: UpdateConnectionRequest): UpdateConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConnectionWithOptions(request, runtime);
}

model UpdateEventBusRequest {
  description?: string(name='Description', description='The description of the event bus.', example='test'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='eventTest'),
}

model UpdateEventBusResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For more information about error codes, see Error codes.', example='Success'),
  message?: string(name='Message', description='The error message returned if the request failed.', example='The event bus [xxxx] not existed!'),
  requestId?: string(name='RequestId', description='The request ID.', example='f2099962-1628-45f1-9782-2bf6daad823f'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model UpdateEventBusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEventBusResponseBody(name='body'),
}

/**
  * You can call this API operation to modify an event bus.
  *
  * @param request UpdateEventBusRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateEventBusResponse
 */
async function updateEventBusWithOptions(request: UpdateEventBusRequest, runtime: Util.RuntimeOptions): UpdateEventBusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEventBus',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to modify an event bus.
  *
  * @param request UpdateEventBusRequest
  * @return UpdateEventBusResponse
 */
async function updateEventBus(request: UpdateEventBusRequest): UpdateEventBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEventBusWithOptions(request, runtime);
}

model UpdateEventSourceRequest {
  description?: string(name='Description', description='The description of the event source.'),
  eventBusName?: string(name='EventBusName', description='The event bus with which the event source is associated.', example='my-event-bus'),
  eventSourceName?: string(name='EventSourceName', description='The name of the event source.', example='myrabbitmq.source'),
  sourceHttpEventParameters?: {
    ip?: [ string ](name='Ip', description='The CIDR block that is used for security settings. This parameter is required only if SecurityConfig is set to ip. You can enter a CIDR block or an IP address.'),
    method?: [ string ](name='Method', description='The HTTP request method supported by the generated webhook URL. You can select multiple values. Valid values:

*   GET
*   POST
*   PUT
*   PATCH
*   DELETE
*   HEAD
*   OPTIONS
*   TRACE
*   CONNECT'),
    referer?: [ string ](name='Referer', description='The security domain name. This parameter is required only if SecurityConfig is set to referer. You can enter a domain name.'),
    securityConfig?: string(name='SecurityConfig', description='The type of security settings. Valid values:

*   none: No configuration is required.
*   ip: CIDR block.
*   referer: security domain name.', example='none'),
    type?: string(name='Type', description='The protocol type that is supported by the generated webhook URL. Valid values:

*   HTTP
*   HTTPS
*   HTTP\\&HTTPS', example='HTTPS'),
  }(name='SourceHttpEventParameters', description='The parameters that are configured if the event source is HTTP events.'),
  sourceKafkaParameters?: {
    consumerGroup?: string(name='ConsumerGroup', description='The ID of the consumer group that subscribes to the topic.', example='dsp_online_ml_request'),
    instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache Kafka instance.', example='cbwp-bp1o3m66wcjgbkssm3k5m'),
    maximumTasks?: int32(name='MaximumTasks', description='The maximum number of consumers.', example='1'),
    network?: string(name='Network', description='The network. Valid values: Default and PublicNetwork. Default value: Default. The value PublicNetwork indicates a self-managed network.', example='Default'),
    offsetReset?: string(name='OffsetReset', description='The consumer offset.', example='latest'),
    regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for Apache Kafka instance resides.', example='cn-shanghai'),
    securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the Message Queue for Apache Kafka instance belongs. This parameter is required only if you set Network to PublicNetwork.', example='sg-5wz3mjgo9wpvdnwpwnhkjdjwn'),
    topic?: string(name='Topic', description='The name of the topic on the Message Queue for Apache Kafka instance.', example='billing_notify'),
    vSwitchIds?: string(name='VSwitchIds', description='The ID of the vSwitch with which the Message Queue for Apache Kafka instance is associated. This parameter is required only if you set Network to PublicNetwork.', example='vsw-bp1xyntcxiwplhqxjybuk'),
    vpcId?: string(name='VpcId', description='The ID of the VPC in which the Message Queue for Apache Kafka instance resides. This parameter is required only if you set Network to PublicNetwork.', example='vpc-2zefu4vfmx6siogujmo0b'),
  }(name='SourceKafkaParameters', description='The parameters that are configured if the event source is Message Queue for Apache Kafka.'),
  sourceMNSParameters?: {
    isBase64Decode?: boolean(name='IsBase64Decode', description='Indicates whether Base64 decoding is enabled. By default, Base64 decoding is enabled.', example='true'),
    queueName?: string(name='QueueName', description='The name of the MNS queue.', example='queue_api_bind_1672194645178'),
    regionId?: string(name='RegionId', description='The region where the MNS queue resides.', example='cn-beijing'),
  }(name='SourceMNSParameters', description='The parameters that are configured if the event source is Message Service (MNS).'),
  sourceRabbitMQParameters?: {
    instanceId?: string(name='InstanceId', description='The ID of the Message Queue for RabbitMQ instance. For more information, see [Limits](~~163289~~).', example='bastionhost-cn-7mz2zkyff09'),
    queueName?: string(name='QueueName', description='The name of the queue on the Message Queue for RabbitMQ instance. For more information, see [Limits](~~163289~~).', example='eb-connect'),
    regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for RabbitMQ instance resides.', example='cn-hangzhou'),
    virtualHostName?: string(name='VirtualHostName', description='The name of the vhost of the Message Queue for RabbitMQ instance. For more information, see [Limits](~~163289~~).', example='amqp-cn-nif22u74****'),
  }(name='SourceRabbitMQParameters', description='The parameters that are configured if the event source is Message Queue for RabbitMQ.'),
  sourceRocketMQParameters?: {
    authType?: string(name='AuthType', description='The authentication type. You can set this parameter to ACL or leave this parameter empty.', example='ACL'),
    groupID?: string(name='GroupID', description='The ID of the consumer group on the Message Queue for Apache RocketMQ instance.', example='GID-test'),
    instanceEndpoint?: string(name='InstanceEndpoint', description='The endpoint that is used to access the Message Queue for Apache RocketMQ instance.', example='registry-vpc****.aliyuncs.com'),
    instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ instance. For more information, see [Limits](~~163289~~).', example='dbaudit-cn-i7m2nx2or01'),
    instanceNetwork?: string(name='InstanceNetwork', description='None.', example='None'),
    instancePassword?: string(name='InstancePassword', description='The password that is used to access the Message Queue for Apache RocketMQ instance.', example='******'),
    instanceSecurityGroupId?: string(name='InstanceSecurityGroupId', description='The ID of the security group to which the Message Queue for Apache RocketMQ instance belongs.', example='sg-catalog-eventlistener'),
    instanceType?: string(name='InstanceType', description='The type of the Message Queue for Apache RocketMQ instance. Valid values:

*   Cloud\\_4: Message Queue for Apache RocketMQ 4.0 instance.
*   Cloud\\_5: Message Queue for Apache RocketMQ 5.0 instance.', example='Cloud_4'),
    instanceUsername?: string(name='InstanceUsername', description='The username that is used to access the Message Queue for Apache RocketMQ instance.', example='root'),
    instanceVSwitchIds?: string(name='InstanceVSwitchIds', description='The ID of the vSwitch with which the Message Queue for Apache RocketMQ instance is associated.', example='vsw-bp10rbrt6rb6vrd89****'),
    instanceVpcId?: string(name='InstanceVpcId', description='The ID of the virtual private cloud (VPC) in which the Message Queue for Apache RocketMQ instance resides.', example='vpc-bp1a4gmlk31hyg6ptl3ss'),
    offset?: string(name='Offset', description='The offset from which message consumption starts. Valid values:

*   CONSUME_FROM_LAST_OFFSET: Start message consumption from the latest offset.
*   CONSUME_FROM_FIRST_OFFSET: Start message consumption from the earliest offset.
*   CONSUME_FROM_TIMESTAMP: Start message consumption from the offset at the specified point in time.

Default value: CONSUME_FROM_LAST_OFFSET.', example='CONSUMEFROMLASTOFFSET'),
    regionId?: string(name='RegionId', description='The region where the Message Queue for Apache RocketMQ instance resides.', example='cn-zhangjiakou'),
    tag?: string(name='Tag', description='The tag that is used to filter messages.', example='KEY2'),
    timestamp?: long(name='Timestamp', description='The timestamp that specifies the time from which messages are consumed. This parameter is valid only if you set Offset to CONSUME_FROM_TIMESTAMP.', example='1663555399032'),
    topic?: string(name='Topic', description='The name of the topic on the Message Queue for Apache RocketMQ instance. For more information, see [Limits](~~163289~~).', example='topic_default_195820716552192'),
  }(name='SourceRocketMQParameters', description='The parameters that are configured if the event source is Message Queue for Apache RocketMQ.'),
  sourceSLSParameters?: {
    consumePosition?: string(name='ConsumePosition', description='The starting consumer offset. The value begin indicates the earliest offset, and the value end indicates the latest offset. You can also specify a time in seconds to start consumption.', example='end'),
    logStore?: string(name='LogStore', description='The Log Service Logstore.', example='waf-logstore'),
    project?: string(name='Project', description='The Log Service project.', example='VideoTestProject'),
    roleName?: string(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the RAM console. For information about the permission policy of this role, see Create a custom event source of the Log Service type.', example='testRole'),
  }(name='SourceSLSParameters', description='SourceSLSParameters'),
  sourceScheduledEventParameters?: {
    schedule?: string(name='Schedule', description='The cron expression.', example='10 * * * * *'),
    timeZone?: string(name='TimeZone', description='The time zone in which the cron expression is executed.', example='GMT+0:00'),
    userData?: string(name='UserData'),
  }(name='SourceScheduledEventParameters', description='The parameters that are configured if you specify scheduled events as the event source.'),
}

model UpdateEventSourceShrinkRequest {
  description?: string(name='Description', description='The description of the event source.'),
  eventBusName?: string(name='EventBusName', description='The event bus with which the event source is associated.', example='my-event-bus'),
  eventSourceName?: string(name='EventSourceName', description='The name of the event source.', example='myrabbitmq.source'),
  sourceHttpEventParametersShrink?: string(name='SourceHttpEventParameters', description='The parameters that are configured if the event source is HTTP events.'),
  sourceKafkaParametersShrink?: string(name='SourceKafkaParameters', description='The parameters that are configured if the event source is Message Queue for Apache Kafka.'),
  sourceMNSParametersShrink?: string(name='SourceMNSParameters', description='The parameters that are configured if the event source is Message Service (MNS).'),
  sourceRabbitMQParametersShrink?: string(name='SourceRabbitMQParameters', description='The parameters that are configured if the event source is Message Queue for RabbitMQ.'),
  sourceRocketMQParametersShrink?: string(name='SourceRocketMQParameters', description='The parameters that are configured if the event source is Message Queue for Apache RocketMQ.'),
  sourceSLSParametersShrink?: string(name='SourceSLSParameters', description='SourceSLSParameters'),
  sourceScheduledEventParametersShrink?: string(name='SourceScheduledEventParameters', description='The parameters that are configured if you specify scheduled events as the event source.'),
}

model UpdateEventSourceResponseBody = {
  code?: string(name='Code', description='The returned response code. Valid values:

*   Success: The request is successful.
*   Other codes: The request failed. For more information about error codes, see Error codes.', example='200'),
  data?: boolean(name='Data', description='The result of the operation.', example='true'),
  message?: string(name='Message', description='The returned error message.', example='Remote error. requestId: [xxxx-9D10-65DFDFA3A75D], error code: [EventSourceNotExist], message: [The event source in request is not exist! ]'),
  requestId?: string(name='RequestId', description='The request ID.', example='c057d379-ea65-41ec-a8a8-90627a968204'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. The value true indicates that the operation is successful.', example='true'),
}

model UpdateEventSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEventSourceResponseBody(name='body'),
}

/**
  * You can call this API operation to update an event source.
  *
  * @param tmpReq UpdateEventSourceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateEventSourceResponse
 */
async function updateEventSourceWithOptions(tmpReq: UpdateEventSourceRequest, runtime: Util.RuntimeOptions): UpdateEventSourceResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateEventSourceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.sourceHttpEventParameters)) {
    request.sourceHttpEventParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceHttpEventParameters, 'SourceHttpEventParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceKafkaParameters)) {
    request.sourceKafkaParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceKafkaParameters, 'SourceKafkaParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceMNSParameters)) {
    request.sourceMNSParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceMNSParameters, 'SourceMNSParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceRabbitMQParameters)) {
    request.sourceRabbitMQParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceRabbitMQParameters, 'SourceRabbitMQParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceRocketMQParameters)) {
    request.sourceRocketMQParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceRocketMQParameters, 'SourceRocketMQParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceSLSParameters)) {
    request.sourceSLSParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceSLSParameters, 'SourceSLSParameters', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceScheduledEventParameters)) {
    request.sourceScheduledEventParametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceScheduledEventParameters, 'SourceScheduledEventParameters', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    body['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventSourceName)) {
    body['EventSourceName'] = request.eventSourceName;
  }
  if (!Util.isUnset(request.sourceHttpEventParametersShrink)) {
    body['SourceHttpEventParameters'] = request.sourceHttpEventParametersShrink;
  }
  if (!Util.isUnset(request.sourceKafkaParametersShrink)) {
    body['SourceKafkaParameters'] = request.sourceKafkaParametersShrink;
  }
  if (!Util.isUnset(request.sourceMNSParametersShrink)) {
    body['SourceMNSParameters'] = request.sourceMNSParametersShrink;
  }
  if (!Util.isUnset(request.sourceRabbitMQParametersShrink)) {
    body['SourceRabbitMQParameters'] = request.sourceRabbitMQParametersShrink;
  }
  if (!Util.isUnset(request.sourceRocketMQParametersShrink)) {
    body['SourceRocketMQParameters'] = request.sourceRocketMQParametersShrink;
  }
  if (!Util.isUnset(request.sourceSLSParametersShrink)) {
    body['SourceSLSParameters'] = request.sourceSLSParametersShrink;
  }
  if (!Util.isUnset(request.sourceScheduledEventParametersShrink)) {
    body['SourceScheduledEventParameters'] = request.sourceScheduledEventParametersShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEventSource',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to update an event source.
  *
  * @param request UpdateEventSourceRequest
  * @return UpdateEventSourceResponse
 */
async function updateEventSource(request: UpdateEventSourceRequest): UpdateEventSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEventSourceWithOptions(request, runtime);
}

model UpdateEventStreamingRequest {
  description?: string(name='Description', description='The description of the event stream.', example='rocketmq2mns'),
  eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream.', example='myeventstreaming'),
  filterPattern?: string(name='FilterPattern', description='The rule that is used to filter events. If you leave this parameter empty, all events are matched.'),
  runOptions?: {
    batchWindow?: {
      countBasedWindow?: int32(name='CountBasedWindow', description='The maximum number of events that is allowed in the batch window. If the value specified by this parameter is reached, the data in the batch window is pushed to the downstream application. If multiple batch windows exist, data is pushed if triggering conditions are met in one of the windows.', example='100'),
      timeBasedWindow?: int32(name='TimeBasedWindow', description='The maximum period of time during which events are allowed in the batch window. Unit: seconds. If the value specified by this parameter is reached, the data in the batch window is pushed to the downstream application. If multiple batch windows exist, data is pushed if triggering conditions are met in one of the windows.', example='10'),
    }(name='BatchWindow', description='The information about the batch window.'),
    deadLetterQueue?: {
      arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the dead-letter queue.', example='acs:ram::1317334647812936:role/rdstoecsassumekms'),
    }(name='DeadLetterQueue', description='Specifies whether to enable dead-letter queues. By default, dead-letter queues are disabled. Messages that fail to be pushed are discarded after the maximum number of retries specified by the retry policy is reached.'),
    errorsTolerance?: string(name='ErrorsTolerance', description='The fault tolerance policy. The value NONE specifies that faults are not tolerated, and the value All specifies that all faults are tolerated.', example='ALL'),
    maximumTasks?: long(name='MaximumTasks', description='The concurrency level.', example='2'),
    retryStrategy?: {
      maximumEventAgeInSeconds?: long(name='MaximumEventAgeInSeconds', description='The maximum period of time during which retries are performed.', example='512'),
      maximumRetryAttempts?: long(name='MaximumRetryAttempts', description='The maximum number of retries.', example='2'),
      pushRetryStrategy?: string(name='PushRetryStrategy', description='The retry policy that is used if an event failed to be pushed. Valid values: BACKOFF_RETRY and EXPONENTIAL_DECAY_RETRY.', example='BACKOFFRETRY'),
    }(name='RetryStrategy', description='The information about the retry policy that is used if the event fails to be pushed.'),
  }(name='RunOptions', description='The parameters that are configured for the runtime environment.'),
  sink?: {
    sinkFcParameters?: {
      body?: {
        form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before event transformation.', example='{
      "key": "value"
}'),
      }(name='Body', description='The message body that is sent to the function.'),
      concurrency?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.', example='None'),
        value?: string(name='Value', description='The delivery concurrency. Minimum value: 1.', example='1'),
      }(name='Concurrency', description='The information about the delivery concurrency.'),
      functionName?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The name of the Function Compute function.', example='mFunction'),
      }(name='FunctionName', description='The information about the Function Compute function.'),
      invocationType?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The invocation type. Valid values: Sync and Async.', example='Async'),
      }(name='InvocationType', description='The information about the invocation type.'),
      qualifier?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The alias of the service to which the function belongs.', example='LATEST'),
      }(name='Qualifier', description='The information about the service to which the function belongs.'),
      serviceName?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The name of the Function Compute service.', example='myService'),
      }(name='ServiceName', description='The information about the Function Compute service.'),
    }(name='SinkFcParameters', description='The parameters that are configured if the event target is Function Compute.'),
    sinkFnfParameters?: {
      executionName?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='ExecutionName'),
      flowName?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='FlowName'),
      input?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Input'),
      roleName?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='RoleName'),
    }(name='SinkFnfParameters'),
    sinkKafkaParameters?: {
      acks?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The ACK mode. If you set this parameter to 0, no response is returned from the broker. In this mode, the performance is high, but the risk of data loss is also high. If you set this parameter to 1, a response is returned when data is written to the leader. In this mode, the performance and the risk of data loss are moderate. Data loss may occur if a failure occurs on the leader. If you set this parameter to all, a response is returned when data is written to the leader and synchronized to the followers. In this mode, the performance is low, but the risk of data loss is also low. Data loss occurs if the leader and the followers fail at the same time.', example='1'),
      }(name='Acks', description='The information about the acknowledgment (ACK) mode. If you set this parameter to 0, no response is returned from the broker. In this mode, the performance is high, but the risk of data loss is also high. If you set this parameter to 1, a response is returned when data is written to the leader. In this mode, the performance and the risk of data loss are moderate. Data loss may occur if a failure occurs on the leader. If you set this parameter to all, a response is returned when data is written to the leader and synchronized to the followers. In this mode, the performance is low, but the risk of data loss is also low. Data loss occurs if the leader and the followers fail at the same time.'),
      instanceId?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The ID of the Message Queue for Apache Kafka instance.', example='Defaut_1283278472_sadkj'),
      }(name='InstanceId', description='The information about the Message Queue for Apache Kafka instance.'),
      key?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The message key.', example='key'),
      }(name='Key', description='The information about the message key.'),
      topic?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The name of the topic in Message Queue for Apache Kafka instance.', example='test'),
      }(name='Topic', description='The information about the topic in Message Queue for Apache Kafka instance.'),
      value?: {
        form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before event transformation.', example='{
      "key": "value"
}'),
      }(name='Value', description='The information about the message value.'),
    }(name='SinkKafkaParameters', description='The parameters that are configured if the event target is Message Queue for Apache Kafka.'),
    sinkMNSParameters?: {
      body?: {
        form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before event transformation.', example='{
      "key": "value"
}'),
      }(name='Body', description='The message content.'),
      isBase64Encode?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='Specifies that Base64 encoding is enabled.', example='true'),
      }(name='IsBase64Encode', description='Specifies whether to enable Base64 encoding.'),
      queueName?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The name of the queue in MNS.', example='MyQueue'),
      }(name='QueueName', description='The information about the MNS queue.'),
    }(name='SinkMNSParameters', description='The parameters that are configured if the event target is MNS.'),
    sinkRabbitMQParameters?: {
      body?: {
        form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before event transformation.', example='{
      "key": "value"
}'),
      }(name='Body', description='The message content.'),
      exchange?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The name of the exchange in the Message Queue for RabbitMQ instance.', example='a_exchange'),
      }(name='Exchange', description='The information about the exchange to which events are delivered. This parameter is available only if you set TargetType to Exchange.'),
      instanceId?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The ID of the Message Queue for RabbitMQ instance.', example='amqp-cn-2r42e73o****'),
      }(name='InstanceId', description='The information about the Message Queue for RabbitMQ instance.'),
      messageId?: {
        form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before event transformation.', example='{
      "key": "value"
}'),
      }(name='MessageId', description='The message ID.'),
      properties?: {
        form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before event transformation.', example='{
      "key": "value"
}'),
      }(name='Properties', description='The properties that are used to filter messages.'),
      queueName?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The name of the queue in the Message Queue for RabbitMQ instance.', example='MyQueue'),
      }(name='QueueName', description='The information about the queue to which events are delivered. This parameter is available only if you set TargetType to Queue.'),
      routingKey?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The routing rule of the message.', example='housekeeping'),
      }(name='RoutingKey', description='The information about the routing rule of the message. This parameter is available only if you set TargetType to Exchange.'),
      targetType?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The type of the resource to which events are delivered. Valid values: Exchange: exchanges. Queue: queues.', example='Exchange/Queue'),
      }(name='TargetType', description='The information about the type of the resource to which events are delivered.'),
      virtualHostName?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The vhost name of the Message Queue for RabbitMQ instance.', example='rabbit-host'),
      }(name='VirtualHostName', description='The information about the vhost of the Message Queue for RabbitMQ instance.'),
    }(name='SinkRabbitMQParameters', description='The parameters that are configured if the event target is Message Queue for RabbitMQ.'),
    sinkRocketMQParameters?: {
      body?: {
        form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before event transformation.', example='{
      "key": "value"
}'),
      }(name='Body', description='The message content.'),
      instanceId?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The ID of the Message Queue for Apache RocketMQ instance.', example='MQ_INST_164901546557****_BAAN****'),
      }(name='InstanceId', description='The parameters that are configured if the event target is Message Queue for Apache RocketMQ.'),
      keys?: {
        form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before event transformation.', example='{
      "key": "value"
}'),
      }(name='Keys', description='The properties that are used to filter messages.'),
      properties?: {
        form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before event transformation.', example='{
      "key": "value"
}'),
      }(name='Properties', description='The properties that are used to filter messages.'),
      tags?: {
        form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before event transformation.', example='{
      "key": "value"
}'),
      }(name='Tags', description='The properties that are used to filter messages.'),
      topic?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The name of the topic in the Message Queue for Apache RocketMQ instance.', example='Mytopic'),
      }(name='Topic', description='The information about the topic in the Message Queue for Apache RocketMQ instance.'),
    }(name='SinkRocketMQParameters', description='Sink RocketMQ Parameters'),
    sinkSLSParameters?: {
      body?: {
        form?: string(name='Form', description='The method that is used to transform events.', example='TEMPLATE'),
        template?: string(name='Template', description='The template based on which events are transformed.', example='The value of ${key} is ${value}!'),
        value?: string(name='Value', description='The value before event transformation.', example='{
      "key": "value"
}'),
      }(name='Body', description='The message body that is sent to Log Service.'),
      logStore?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The Log Service Logstore.', example='test-logstore'),
      }(name='LogStore', description='The information about the Log Service Logstore.'),
      project?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The Log Service project.', example='test-project'),
      }(name='Project', description='The information about the Log Service project.'),
      roleName?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The role name. If you want to authorize EventBridge to use this role to read logs in Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the RAM console.', example='testRole'),
      }(name='RoleName', description='The information about the role. If you want to authorize EventBridge to use this role to read logs in Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the RAM console.'),
      topic?: {
        form?: string(name='Form', description='The method that is used to transform events. Default value: CONSTANT.', example='CONSTANT'),
        template?: string(name='Template', description='None.'),
        value?: string(name='Value', description='The name of the topic in which logs are stored. The topic corresponds to the topic reserved field in Log Service.', example='testTopic'),
      }(name='Topic', description='The information about the topic in which logs are stored. The topic corresponds to the topic reserved field in Log Service.'),
    }(name='SinkSLSParameters', description='Sink SLS Parameters'),
  }(name='Sink', description='The event target. You must and can specify only one event target.'),
  source?: {
    sourceDTSParameters?: {
      brokerUrl?: string(name='BrokerUrl', description='The URL and port number of the data subscription channel.'),
      initCheckPoint?: long(name='InitCheckPoint', description='The consumer offset. A consumer offset is a timestamp that indicates when the SDK client consumes the first data record. The value is a UNIX timestamp.', example='1620962769'),
      password?: string(name='Password', description='The password of the consumer group.', example='admin'),
      sid?: string(name='Sid', description='The ID of the consumer group.', example='hkprdb'),
      taskId?: string(name='TaskId', description='The task ID.', example='f86e5814-b223-482c-b768-3b873297dade'),
      topic?: string(name='Topic', description='The topic to which you want to subscribe by using the data subscription channel.', example='LTC_CACHE_PRD'),
      username?: string(name='Username', description='The username of the consumer group.', example='admin'),
    }(name='SourceDTSParameters', description='The parameters that are configured if the event source is Data Transmission Service (DTS).'),
    sourceKafkaParameters?: {
      consumerGroup?: string(name='ConsumerGroup', description='The ID of the consumer group that subscribes to the topic.', example='DEFAULT_GROUP'),
      instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache Kafka instance.', example='i-8vbh4a5b9yfhgkkzm98f'),
      network?: string(name='Network', description='The network. Default value: Default. The value PublicNetwork specifies a virtual private cloud (VPC).', example='Default'),
      offsetReset?: string(name='OffsetReset', description='The offset.', example='latest'),
      regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for Apache Kafka instance resides.', example='cn-zhangjiakou'),
      securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the Message Queue for Apache Kafka instance belongs.', example='sg-uf6jcm3y5hcs7hklytxh'),
      topic?: string(name='Topic', description='The name of the topic in the Message Queue for Apache Kafka instance.', example='topic_empower_1641539400786'),
      vSwitchIds?: string(name='VSwitchIds', description='The ID of the vSwitch with which the Message Queue for Apache Kafka instance is associated.', example='vsw-wz9t1l1e8eu2omwjazmtm'),
      vpcId?: string(name='VpcId', description='The ID of the VPC to which the Message Queue for Apache Kafka instance belongs.', example='vpc-2ze6p0o345nykmekxtuop'),
    }(name='SourceKafkaParameters', description='The parameters that are configured if the event source is Message Queue for Apache Kafka.'),
    sourceMNSParameters?: {
      isBase64Decode?: boolean(name='IsBase64Decode', description='Specifies whether to enable Base64 encoding. Default value: true.', example='true'),
      queueName?: string(name='QueueName', description='The queue name.', example='queue_api_1642474203601'),
      regionId?: string(name='RegionId', description='The ID of the region where the MNS queue resides.', example='cn-hangzhou'),
    }(name='SourceMNSParameters', description='The parameters that are configured if the event source is Message Service (MNS).'),
    sourceMQTTParameters?: {
      instanceId?: string(name='InstanceId', description='The ID of the Message Queue for MQTT instance.', example='i-bp1dsudbecqwt61jqswt'),
      regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for MQTT resides.', example='cn-shanghai'),
      topic?: string(name='Topic', description='The name of the topic in the Message Queue for MQTT instance.', example='topic_empower_1642400400779'),
    }(name='SourceMQTTParameters', description='The parameters that are configured if the event source is Message Queue for MQTT.'),
    sourceRabbitMQParameters?: {
      instanceId?: string(name='InstanceId', description='The ID of the Message Queue for RabbitMQ instance.', example='i-f8z9lqkldlb4oxsxwwub'),
      queueName?: string(name='QueueName', description='The name of the queue in the Message Queue for RabbitMQ instance.', example='demo'),
      regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for RabbitMQ instance resides.', example='cn-hangzhou'),
      virtualHostName?: string(name='VirtualHostName', description='The vhost name of the Message Queue for RabbitMQ instance.', example='eb-connect'),
    }(name='SourceRabbitMQParameters', description='The parameters that are configured if the event source is Message Queue for RabbitMQ.'),
    sourceRocketMQParameters?: {
      authType?: string(name='AuthType'),
      groupID?: string(name='GroupID', description='The ID of the consumer group in the Message Queue for Apache RocketMQ instance.', example='GID_test'),
      instanceEndpoint?: string(name='InstanceEndpoint'),
      instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ instance.', example='i-f8z9a9mcgwri1c1idd0e'),
      instanceNetwork?: string(name='InstanceNetwork'),
      instancePassword?: string(name='InstancePassword'),
      instanceSecurityGroupId?: string(name='InstanceSecurityGroupId'),
      instanceType?: string(name='InstanceType'),
      instanceUsername?: string(name='InstanceUsername'),
      instanceVSwitchIds?: string(name='InstanceVSwitchIds'),
      instanceVpcId?: string(name='InstanceVpcId'),
      offset?: string(name='Offset', description='The consumer offset of the message. Valid values: CONSUME_FROM_LAST_OFFSET: consumes messages from the latest offset. CONSUME_FROM_FIRST_OFFSET: consumes messages from the earliest offset. CONSUME_FROM_TIMESTAMP: consumes messages from the offset at the specified point in time. Default value: CONSUME_FROM_LAST_OFFSET.', example='CONSUMEFROMLASTOFFSET'),
      regionId?: string(name='RegionId', description='The ID of the region where the Message Queue for Apache RocketMQ instance resides.', example='cn-shanghai'),
      tag?: string(name='Tag', description='The tags that are used to filter messages.', example='test'),
      timestamp?: long(name='Timestamp', description='The timestamp that indicates the time from which messages are consumed. This parameter is valid only if you set Offset to CONSUME_FROM_TIMESTAMP.', example='1670656652009'),
      topic?: string(name='Topic', description='The name of the topic in the Message Queue for Apache RocketMQ instance.', example='TOPIC-cainiao-pcs-order-process-inBoundConditionCheck'),
    }(name='SourceRocketMQParameters', description='The parameters that are configured if the event source is Message Queue for Apache RocketMQ.'),
    sourceSLSParameters?: {
      roleName?: string(name='RoleName', description='The role name. If you want to authorize EventBridge to use this role to read logs in Log Service, you must select Alibaba Cloud Service for Selected Trusted Entity and EventBridge for Select Trusted Service when you create the role in the Resource Access Management (RAM) console.', example='testRole'),
    }(name='SourceSLSParameters', description='The parameters that are configured if the event source is Log Service.'),
  }(name='Source', description='The event source, which is also known as the event source. You must and can specify only one event source.'),
  transforms?: [ 
    {
      arn?: string(name='Arn'),
    }
  ](name='Transforms'),
}

model UpdateEventStreamingShrinkRequest {
  description?: string(name='Description', description='The description of the event stream.', example='rocketmq2mns'),
  eventStreamingName?: string(name='EventStreamingName', description='The name of the event stream.', example='myeventstreaming'),
  filterPattern?: string(name='FilterPattern', description='The rule that is used to filter events. If you leave this parameter empty, all events are matched.'),
  runOptionsShrink?: string(name='RunOptions', description='The parameters that are configured for the runtime environment.'),
  sinkShrink?: string(name='Sink', description='The event target. You must and can specify only one event target.'),
  sourceShrink?: string(name='Source', description='The event source, which is also known as the event source. You must and can specify only one event source.'),
  transformsShrink?: string(name='Transforms'),
}

model UpdateEventStreamingResponseBody = {
  code?: string(name='Code', description='The returned response code. The value Success indicates that the request is successful. Other values indicate that the request failed. For more information about error codes, see Error codes.', example='Success'),
  message?: string(name='Message', description='The returned error message.', example='The name [xxxx] of event streaming in request is already exist!'),
  requestId?: string(name='RequestId', description='The request ID.', example='0FDD73AA-7A2D-5BD4-B4C0-88AFEBF5F0F5'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='true'),
}

model UpdateEventStreamingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEventStreamingResponseBody(name='body'),
}

/**
  * You can call this API operation to modify the information about an event stream, such as the basic information and the information about the event source, event filtering rule, and event target.
  *
  * @param tmpReq UpdateEventStreamingRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateEventStreamingResponse
 */
async function updateEventStreamingWithOptions(tmpReq: UpdateEventStreamingRequest, runtime: Util.RuntimeOptions): UpdateEventStreamingResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateEventStreamingShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.runOptions)) {
    request.runOptionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.runOptions, 'RunOptions', 'json');
  }
  if (!Util.isUnset(tmpReq.sink)) {
    request.sinkShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sink, 'Sink', 'json');
  }
  if (!Util.isUnset(tmpReq.source)) {
    request.sourceShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.source, 'Source', 'json');
  }
  if (!Util.isUnset(tmpReq.transforms)) {
    request.transformsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.transforms, 'Transforms', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  if (!Util.isUnset(request.filterPattern)) {
    body['FilterPattern'] = request.filterPattern;
  }
  if (!Util.isUnset(request.runOptionsShrink)) {
    body['RunOptions'] = request.runOptionsShrink;
  }
  if (!Util.isUnset(request.sinkShrink)) {
    body['Sink'] = request.sinkShrink;
  }
  if (!Util.isUnset(request.sourceShrink)) {
    body['Source'] = request.sourceShrink;
  }
  if (!Util.isUnset(request.transformsShrink)) {
    body['Transforms'] = request.transformsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to modify the information about an event stream, such as the basic information and the information about the event source, event filtering rule, and event target.
  *
  * @param request UpdateEventStreamingRequest
  * @return UpdateEventStreamingResponse
 */
async function updateEventStreaming(request: UpdateEventStreamingRequest): UpdateEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEventStreamingWithOptions(request, runtime);
}

model UpdateRuleRequest {
  description?: string(name='Description', description='The description of the event bus.', example='demo'),
  eventBusName?: string(name='EventBusName', description='The name of the event bus.', example='hw-test'),
  filterPattern?: string(name='FilterPattern', description='The event pattern, in JSON format. Valid values: stringEqual stringExpression Each field can have a maximum of five expressions in the map data structure.

Each field can have a maximum of five expressions in the map data structure.', example='{\\"source\\":[\\"acs.oss\\"],\\"type\\":[\\"oss:BucketQueried:GetBucketStat\\"]}'),
  ruleName?: string(name='RuleName', description='The name of the event rule.', example='tf-testacc-rule'),
  status?: string(name='Status', description='The status of the event rule. Valid values: ENABLE: The event rule is enabled. It is the default state of the event rule. DISABLE: The event rule is disabled.', example='ENABLE'),
}

model UpdateRuleResponseBody = {
  code?: string(name='Code', description='The status code returned. The status code 200 indicates that the request was successful.', example='200'),
  data?: boolean(name='Data', description='The result of the operation.', example='true'),
  message?: string(name='Message', description='The error message that is returned if the request failed.', example='EventRuleFilterPatternSchemaError'),
  requestId?: string(name='RequestId', description='The request ID.', example='7439944D-D9FC-5614-B65E-07A468988924'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='true'),
}

model UpdateRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRuleResponseBody(name='body'),
}

/**
  * You can call this API operation to update the configurations of an event rule.
  *
  * @param request UpdateRuleRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateRuleResponse
 */
async function updateRuleWithOptions(request: UpdateRuleRequest, runtime: Util.RuntimeOptions): UpdateRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.filterPattern)) {
    query['FilterPattern'] = request.filterPattern;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this API operation to update the configurations of an event rule.
  *
  * @param request UpdateRuleRequest
  * @return UpdateRuleResponse
 */
async function updateRule(request: UpdateRuleRequest): UpdateRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRuleWithOptions(request, runtime);
}

