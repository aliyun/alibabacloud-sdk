/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('eventbridge', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AttachEBEventBusRequest {
  eventBusName?: bytes(name='EventBusName', description='事件源英文Code'),
  eventSourceFullName?: bytes(name='EventSourceFullName', description='事件源ID'),
}

model AttachEBEventBusResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AttachEBEventBusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachEBEventBusResponseBody(name='body'),
}

async function attachEBEventBusWithOptions(request: AttachEBEventBusRequest, runtime: Util.RuntimeOptions): AttachEBEventBusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventBusName)) {
    body['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventSourceFullName)) {
    body['EventSourceFullName'] = request.eventSourceFullName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AttachEBEventBus',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachEBEventBus(request: AttachEBEventBusRequest): AttachEBEventBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachEBEventBusWithOptions(request, runtime);
}

model CheckRoleForProductRequest {
  productName?: string(name='ProductName'),
}

model CheckRoleForProductResponseBody = {
  code?: string(name='Code'),
  data?: {
    checkPass?: boolean(name='CheckPass'),
    stsRoleAuthURL?: string(name='StsRoleAuthURL'),
    stsRoleName?: string(name='StsRoleName'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckRoleForProductResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckRoleForProductResponseBody(name='body'),
}

async function checkRoleForProductWithOptions(request: CheckRoleForProductRequest, runtime: Util.RuntimeOptions): CheckRoleForProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.productName)) {
    query['ProductName'] = request.productName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckRoleForProduct',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkRoleForProduct(request: CheckRoleForProductRequest): CheckRoleForProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkRoleForProductWithOptions(request, runtime);
}

model CheckRoleForTargetRequest {
  targetType?: string(name='TargetType'),
}

model CheckRoleForTargetResponseBody = {
  code?: string(name='Code'),
  data?: {
    checkPass?: boolean(name='CheckPass'),
    stsRoleAuthURL?: string(name='StsRoleAuthURL'),
    stsRoleName?: string(name='StsRoleName'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckRoleForTargetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckRoleForTargetResponseBody(name='body'),
}

async function checkRoleForTargetWithOptions(request: CheckRoleForTargetRequest, runtime: Util.RuntimeOptions): CheckRoleForTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckRoleForTarget',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkRoleForTarget(request: CheckRoleForTargetRequest): CheckRoleForTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkRoleForTargetWithOptions(request, runtime);
}

model CheckServiceLinkedRoleForDeleteRequest {
  accountId?: string(name='AccountId'),
  deletionTaskId?: string(name='DeletionTaskId'),
  serviceName?: string(name='ServiceName'),
}

model CheckServiceLinkedRoleForDeleteResponseBody = {
  deletable?: boolean(name='Deletable'),
  requestId?: string(name='RequestId'),
  roleUsages?: [ 
    {
      region?: string(name='Region'),
      resources?: [ string ](name='Resources'),
    }
  ](name='RoleUsages'),
}

model CheckServiceLinkedRoleForDeleteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckServiceLinkedRoleForDeleteResponseBody(name='body'),
}

async function checkServiceLinkedRoleForDeleteWithOptions(request: CheckServiceLinkedRoleForDeleteRequest, runtime: Util.RuntimeOptions): CheckServiceLinkedRoleForDeleteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountId)) {
    query['AccountId'] = request.accountId;
  }
  if (!Util.isUnset(request.deletionTaskId)) {
    query['DeletionTaskId'] = request.deletionTaskId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckServiceLinkedRoleForDelete',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkServiceLinkedRoleForDelete(request: CheckServiceLinkedRoleForDeleteRequest): CheckServiceLinkedRoleForDeleteResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkServiceLinkedRoleForDeleteWithOptions(request, runtime);
}

model CompleteCommodityRequest {
  data?: string(name='data'),
}

model CompleteCommodityResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  synchro?: string(name='Synchro'),
}

model CompleteCommodityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CompleteCommodityResponseBody(name='body'),
}

async function completeCommodityWithOptions(request: CompleteCommodityRequest, runtime: Util.RuntimeOptions): CompleteCommodityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.data)) {
    query['data'] = request.data;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CompleteCommodity',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function completeCommodity(request: CompleteCommodityRequest): CompleteCommodityResponse {
  var runtime = new Util.RuntimeOptions{};
  return completeCommodityWithOptions(request, runtime);
}

model CompleteOrderParamRequest {
  data?: string(name='Data'),
}

model CompleteOrderParamResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  synchro?: string(name='Synchro'),
}

model CompleteOrderParamResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CompleteOrderParamResponseBody(name='body'),
}

async function completeOrderParamWithOptions(request: CompleteOrderParamRequest, runtime: Util.RuntimeOptions): CompleteOrderParamResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CompleteOrderParam',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function completeOrderParam(request: CompleteOrderParamRequest): CompleteOrderParamResponse {
  var runtime = new Util.RuntimeOptions{};
  return completeOrderParamWithOptions(request, runtime);
}

model CreateEventBusRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  eventBusName?: string(name='EventBusName'),
}

model CreateEventBusResponseBody = {
  code?: string(name='Code'),
  data?: {
    eventBusARN?: string(name='EventBusARN'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateEventBusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEventBusResponseBody(name='body'),
}

async function createEventBusWithOptions(request: CreateEventBusRequest, runtime: Util.RuntimeOptions): CreateEventBusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEventBus',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createEventBus(request: CreateEventBusRequest): CreateEventBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEventBusWithOptions(request, runtime);
}

model CreateEventSourceRequest {
  description?: bytes(name='Description', description='事件源描述详情'),
  eventBusName?: bytes(name='EventBusName'),
  eventSourceName?: bytes(name='EventSourceName', description='事件源英文Code'),
  externalSourceConfig?: map[string]any(name='ExternalSourceConfig'),
  externalSourceType?: bytes(name='ExternalSourceType'),
  linkedExternalSource?: boolean(name='LinkedExternalSource'),
}

model CreateEventSourceShrinkRequest {
  description?: bytes(name='Description', description='事件源描述详情'),
  eventBusName?: bytes(name='EventBusName'),
  eventSourceName?: bytes(name='EventSourceName', description='事件源英文Code'),
  externalSourceConfigShrink?: string(name='ExternalSourceConfig'),
  externalSourceType?: bytes(name='ExternalSourceType'),
  linkedExternalSource?: boolean(name='LinkedExternalSource'),
}

model CreateEventSourceResponseBody = {
  code?: string(name='Code'),
  data?: {
    eventSourceARN?: string(name='EventSourceARN'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateEventSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEventSourceResponseBody(name='body'),
}

async function createEventSourceWithOptions(tmpReq: CreateEventSourceRequest, runtime: Util.RuntimeOptions): CreateEventSourceResponse {
  Util.validateModel(tmpReq);
  var request = new CreateEventSourceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.externalSourceConfig)) {
    request.externalSourceConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.externalSourceConfig, 'ExternalSourceConfig', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    body['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventSourceName)) {
    body['EventSourceName'] = request.eventSourceName;
  }
  if (!Util.isUnset(request.externalSourceConfigShrink)) {
    body['ExternalSourceConfig'] = request.externalSourceConfigShrink;
  }
  if (!Util.isUnset(request.externalSourceType)) {
    body['ExternalSourceType'] = request.externalSourceType;
  }
  if (!Util.isUnset(request.linkedExternalSource)) {
    body['LinkedExternalSource'] = request.linkedExternalSource;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEventSource',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createEventSource(request: CreateEventSourceRequest): CreateEventSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEventSourceWithOptions(request, runtime);
}

model CreateEventStreamingRequest {
  description?: string(name='Description'),
  eventStreamingName?: string(name='EventStreamingName'),
  filterPattern?: string(name='FilterPattern'),
  runOptions?: {
    batchWindow?: {
      countBasedWindow?: int32(name='CountBasedWindow'),
      timeBasedWindow?: int32(name='TimeBasedWindow'),
    }(name='BatchWindow'),
    deadLetterQueue?: {
      arn?: string(name='Arn'),
    }(name='DeadLetterQueue'),
    errorsTolerance?: string(name='ErrorsTolerance'),
    maximumTasks?: long(name='MaximumTasks'),
    retryStrategy?: {
      maximumEventAgeInSeconds?: long(name='MaximumEventAgeInSeconds'),
      maximumRetryAttempts?: long(name='MaximumRetryAttempts'),
      pushRetryStrategy?: string(name='PushRetryStrategy'),
    }(name='RetryStrategy'),
  }(name='RunOptions'),
  sink?: {
    sinkFcParameters?: {
      body?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Body'),
      functionName?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='FunctionName'),
      invocationType?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='InvocationType'),
      qualifier?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Qualifier'),
      serviceName?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='ServiceName'),
    }(name='SinkFcParameters'),
    sinkKafkaParameters?: {
      acks?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Acks'),
      instanceId?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='InstanceId'),
      key?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Key'),
      saslUser?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='SaslUser'),
      topic?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Topic'),
      value?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Value'),
    }(name='SinkKafkaParameters'),
    sinkMNSParameters?: {
      body?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Body'),
      isBase64Encode?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='IsBase64Encode'),
      queueName?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='QueueName'),
    }(name='SinkMNSParameters'),
    sinkRabbitMQParameters?: {
      body?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Body'),
      exchange?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Exchange'),
      instanceId?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='InstanceId'),
      messageId?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='MessageId'),
      properties?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Properties'),
      queueName?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='QueueName'),
      routingKey?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='RoutingKey'),
      targetType?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='TargetType'),
      virtualHostName?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='VirtualHostName'),
    }(name='SinkRabbitMQParameters'),
    sinkRocketMQParameters?: {
      body?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Body'),
      instanceId?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='InstanceId'),
      keys?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Keys'),
      properties?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Properties'),
      tags?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Tags'),
      topic?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Topic'),
    }(name='SinkRocketMQParameters'),
    sinkSLSParameters?: {
      body?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Body'),
      logStore?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='LogStore'),
      project?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Project'),
      roleName?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='RoleName'),
      topic?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Topic'),
    }(name='SinkSLSParameters'),
  }(name='Sink'),
  source?: {
    sourceDTSParameters?: {
      brokerUrl?: string(name='BrokerUrl'),
      initCheckPoint?: long(name='InitCheckPoint'),
      password?: string(name='Password'),
      sid?: string(name='Sid'),
      taskId?: string(name='TaskId'),
      topic?: string(name='Topic'),
      username?: string(name='Username'),
    }(name='SourceDTSParameters'),
    sourceKafkaParameters?: {
      consumerGroup?: string(name='ConsumerGroup'),
      instanceId?: string(name='InstanceId'),
      network?: string(name='Network'),
      offsetReset?: string(name='OffsetReset'),
      regionId?: string(name='RegionId'),
      securityGroupId?: string(name='SecurityGroupId'),
      topic?: string(name='Topic'),
      vSwitchIds?: string(name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
    }(name='SourceKafkaParameters'),
    sourceMNSParameters?: {
      isBase64Decode?: boolean(name='IsBase64Decode'),
      queueName?: string(name='QueueName'),
      regionId?: string(name='RegionId'),
    }(name='SourceMNSParameters'),
    sourceMQTTParameters?: {
      instanceId?: string(name='InstanceId'),
      regionId?: string(name='RegionId'),
      topic?: string(name='Topic'),
    }(name='SourceMQTTParameters'),
    sourceRabbitMQParameters?: {
      instanceId?: string(name='InstanceId'),
      queueName?: string(name='QueueName'),
      regionId?: string(name='RegionId'),
      virtualHostName?: string(name='VirtualHostName'),
    }(name='SourceRabbitMQParameters'),
    sourceRocketMQParameters?: {
      groupID?: string(name='GroupID'),
      instanceId?: string(name='InstanceId'),
      offset?: string(name='Offset'),
      regionId?: string(name='RegionId'),
      tag?: string(name='Tag'),
      timestamp?: long(name='Timestamp'),
      topic?: string(name='Topic'),
    }(name='SourceRocketMQParameters'),
    sourceSLSParameters?: {
      consumePosition?: string(name='ConsumePosition'),
      logStore?: string(name='LogStore'),
      project?: string(name='Project'),
      roleName?: string(name='RoleName'),
    }(name='SourceSLSParameters'),
  }(name='Source'),
  tag?: string(name='Tag'),
}

model CreateEventStreamingShrinkRequest {
  description?: string(name='Description'),
  eventStreamingName?: string(name='EventStreamingName'),
  filterPattern?: string(name='FilterPattern'),
  runOptionsShrink?: string(name='RunOptions'),
  sinkShrink?: string(name='Sink'),
  sourceShrink?: string(name='Source'),
  tag?: string(name='Tag'),
}

model CreateEventStreamingResponseBody = {
  code?: string(name='Code'),
  data?: {
    eventStreamingARN?: string(name='EventStreamingARN'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateEventStreamingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEventStreamingResponseBody(name='body'),
}

async function createEventStreamingWithOptions(tmpReq: CreateEventStreamingRequest, runtime: Util.RuntimeOptions): CreateEventStreamingResponse {
  Util.validateModel(tmpReq);
  var request = new CreateEventStreamingShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.runOptions)) {
    request.runOptionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.runOptions, 'RunOptions', 'json');
  }
  if (!Util.isUnset(tmpReq.sink)) {
    request.sinkShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sink, 'Sink', 'json');
  }
  if (!Util.isUnset(tmpReq.source)) {
    request.sourceShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.source, 'Source', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  if (!Util.isUnset(request.filterPattern)) {
    body['FilterPattern'] = request.filterPattern;
  }
  if (!Util.isUnset(request.runOptionsShrink)) {
    body['RunOptions'] = request.runOptionsShrink;
  }
  if (!Util.isUnset(request.sinkShrink)) {
    body['Sink'] = request.sinkShrink;
  }
  if (!Util.isUnset(request.sourceShrink)) {
    body['Source'] = request.sourceShrink;
  }
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createEventStreaming(request: CreateEventStreamingRequest): CreateEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEventStreamingWithOptions(request, runtime);
}

model CreateRuleRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  eventBusName?: string(name='EventBusName'),
  filterPattern?: string(name='FilterPattern'),
  ruleName?: string(name='RuleName'),
  status?: string(name='Status'),
  targets?: map[string]any(name='Targets'),
}

model CreateRuleShrinkRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  eventBusName?: string(name='EventBusName'),
  filterPattern?: string(name='FilterPattern'),
  ruleName?: string(name='RuleName'),
  status?: string(name='Status'),
  targetsShrink?: string(name='Targets'),
}

model CreateRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    ruleARN?: string(name='RuleARN'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRuleResponseBody(name='body'),
}

async function createRuleWithOptions(tmpReq: CreateRuleRequest, runtime: Util.RuntimeOptions): CreateRuleResponse {
  Util.validateModel(tmpReq);
  var request = new CreateRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.targets)) {
    request.targetsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.targets, 'Targets', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.filterPattern)) {
    query['FilterPattern'] = request.filterPattern;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.targetsShrink)) {
    query['Targets'] = request.targetsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRule(request: CreateRuleRequest): CreateRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRuleWithOptions(request, runtime);
}

model CreateSchemaRequest {
  clientToken?: string(name='ClientToken'),
  compatibleType?: string(name='CompatibleType', description='Schema处理版本兼容性的策略'),
  content?: string(name='Content', description='Schema创建时间'),
  description?: string(name='Description', description='Schema描述信息'),
  groupId?: string(name='GroupId', description='Schema所属注册表'),
  schemaId?: string(name='SchemaId', description='Schema标识'),
}

model CreateSchemaResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdTimestamp?: long(name='CreatedTimestamp'),
    schemaARN?: string(name='SchemaARN'),
    version?: long(name='Version'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSchemaResponseBody(name='body'),
}

async function createSchemaWithOptions(request: CreateSchemaRequest, runtime: Util.RuntimeOptions): CreateSchemaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.compatibleType)) {
    query['CompatibleType'] = request.compatibleType;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.schemaId)) {
    query['SchemaId'] = request.schemaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSchema',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSchema(request: CreateSchemaRequest): CreateSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSchemaWithOptions(request, runtime);
}

model CreateSchemaGroupRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description', description='代表分组的类别'),
  groupId?: string(name='GroupId', description='代表资源一级ID的资源属性字段'),
  schemaFormat?: string(name='SchemaFormat'),
}

model CreateSchemaGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdTimestamp?: long(name='CreatedTimestamp'),
    groupARN?: string(name='GroupARN'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSchemaGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSchemaGroupResponseBody(name='body'),
}

async function createSchemaGroupWithOptions(request: CreateSchemaGroupRequest, runtime: Util.RuntimeOptions): CreateSchemaGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.schemaFormat)) {
    query['SchemaFormat'] = request.schemaFormat;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSchemaGroup',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSchemaGroup(request: CreateSchemaGroupRequest): CreateSchemaGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSchemaGroupWithOptions(request, runtime);
}

model CreateSchemaVersionRequest {
  clientToken?: string(name='ClientToken'),
  content?: string(name='Content', description='具体Schema内容'),
  groupId?: string(name='GroupId', description='所属注册表'),
  schemaId?: string(name='SchemaId', description='所属数据模型ID'),
}

model CreateSchemaVersionResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdTimestamp?: long(name='CreatedTimestamp'),
    schemaVersionARN?: string(name='SchemaVersionARN'),
    version?: long(name='Version'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSchemaVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSchemaVersionResponseBody(name='body'),
}

async function createSchemaVersionWithOptions(request: CreateSchemaVersionRequest, runtime: Util.RuntimeOptions): CreateSchemaVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.schemaId)) {
    query['SchemaId'] = request.schemaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSchemaVersion',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSchemaVersion(request: CreateSchemaVersionRequest): CreateSchemaVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSchemaVersionWithOptions(request, runtime);
}

model CreateServiceLinkedRoleForProductRequest {
  productName?: string(name='ProductName'),
}

model CreateServiceLinkedRoleForProductResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateServiceLinkedRoleForProductResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceLinkedRoleForProductResponseBody(name='body'),
}

async function createServiceLinkedRoleForProductWithOptions(request: CreateServiceLinkedRoleForProductRequest, runtime: Util.RuntimeOptions): CreateServiceLinkedRoleForProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.productName)) {
    query['ProductName'] = request.productName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceLinkedRoleForProduct',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createServiceLinkedRoleForProduct(request: CreateServiceLinkedRoleForProductRequest): CreateServiceLinkedRoleForProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceLinkedRoleForProductWithOptions(request, runtime);
}

model CreateServiceLinkedRoleForTargetRequest {
  targetType?: string(name='TargetType'),
}

model CreateServiceLinkedRoleForTargetResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateServiceLinkedRoleForTargetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceLinkedRoleForTargetResponseBody(name='body'),
}

async function createServiceLinkedRoleForTargetWithOptions(request: CreateServiceLinkedRoleForTargetRequest, runtime: Util.RuntimeOptions): CreateServiceLinkedRoleForTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceLinkedRoleForTarget',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createServiceLinkedRoleForTarget(request: CreateServiceLinkedRoleForTargetRequest): CreateServiceLinkedRoleForTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceLinkedRoleForTargetWithOptions(request, runtime);
}

model DeleteEventBusRequest {
  clientToken?: string(name='ClientToken'),
  eventBusName?: string(name='EventBusName'),
}

model DeleteEventBusResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteEventBusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEventBusResponseBody(name='body'),
}

async function deleteEventBusWithOptions(request: DeleteEventBusRequest, runtime: Util.RuntimeOptions): DeleteEventBusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEventBus',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEventBus(request: DeleteEventBusRequest): DeleteEventBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventBusWithOptions(request, runtime);
}

model DeleteEventSourceRequest {
  eventSourceName?: string(name='EventSourceName', description='事件源ID'),
}

model DeleteEventSourceResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteEventSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEventSourceResponseBody(name='body'),
}

async function deleteEventSourceWithOptions(request: DeleteEventSourceRequest, runtime: Util.RuntimeOptions): DeleteEventSourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventSourceName)) {
    body['EventSourceName'] = request.eventSourceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEventSource',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEventSource(request: DeleteEventSourceRequest): DeleteEventSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventSourceWithOptions(request, runtime);
}

model DeleteEventStreamingRequest {
  eventStreamingName?: string(name='EventStreamingName'),
}

model DeleteEventStreamingResponseBody = {
  code?: boolean(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteEventStreamingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEventStreamingResponseBody(name='body'),
}

async function deleteEventStreamingWithOptions(request: DeleteEventStreamingRequest, runtime: Util.RuntimeOptions): DeleteEventStreamingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEventStreaming(request: DeleteEventStreamingRequest): DeleteEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventStreamingWithOptions(request, runtime);
}

model DeleteRuleRequest {
  eventBusName?: string(name='EventBusName'),
  ruleName?: string(name='RuleName'),
}

model DeleteRuleResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRuleResponseBody(name='body'),
}

async function deleteRuleWithOptions(request: DeleteRuleRequest, runtime: Util.RuntimeOptions): DeleteRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRule(request: DeleteRuleRequest): DeleteRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRuleWithOptions(request, runtime);
}

model DeleteSchemaRequest {
  groupId?: string(name='GroupId'),
  schemaId?: string(name='SchemaId'),
}

model DeleteSchemaResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSchemaResponseBody(name='body'),
}

async function deleteSchemaWithOptions(request: DeleteSchemaRequest, runtime: Util.RuntimeOptions): DeleteSchemaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.schemaId)) {
    query['SchemaId'] = request.schemaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSchema',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSchema(request: DeleteSchemaRequest): DeleteSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSchemaWithOptions(request, runtime);
}

model DeleteSchemaGroupRequest {
  groupId?: string(name='GroupId'),
}

model DeleteSchemaGroupResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSchemaGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSchemaGroupResponseBody(name='body'),
}

async function deleteSchemaGroupWithOptions(request: DeleteSchemaGroupRequest, runtime: Util.RuntimeOptions): DeleteSchemaGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSchemaGroup',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSchemaGroup(request: DeleteSchemaGroupRequest): DeleteSchemaGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSchemaGroupWithOptions(request, runtime);
}

model DeleteSchemaVersionRequest {
  groupId?: string(name='GroupId'),
  schemaId?: string(name='SchemaId'),
  versionNumber?: string(name='VersionNumber'),
}

model DeleteSchemaVersionResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSchemaVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSchemaVersionResponseBody(name='body'),
}

async function deleteSchemaVersionWithOptions(request: DeleteSchemaVersionRequest, runtime: Util.RuntimeOptions): DeleteSchemaVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.schemaId)) {
    query['SchemaId'] = request.schemaId;
  }
  if (!Util.isUnset(request.versionNumber)) {
    query['VersionNumber'] = request.versionNumber;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSchemaVersion',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSchemaVersion(request: DeleteSchemaVersionRequest): DeleteSchemaVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSchemaVersionWithOptions(request, runtime);
}

model DeleteSourceTaskRequest {
  taskId?: string(name='TaskId'),
}

model DeleteSourceTaskResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSourceTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSourceTaskResponseBody(name='body'),
}

async function deleteSourceTaskWithOptions(request: DeleteSourceTaskRequest, runtime: Util.RuntimeOptions): DeleteSourceTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSourceTask',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSourceTask(request: DeleteSourceTaskRequest): DeleteSourceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSourceTaskWithOptions(request, runtime);
}

model DeleteTargetsRequest {
  eventBusName?: string(name='EventBusName'),
  ruleName?: string(name='RuleName'),
  targetIds?: map[string]any(name='TargetIds'),
}

model DeleteTargetsShrinkRequest {
  eventBusName?: string(name='EventBusName'),
  ruleName?: string(name='RuleName'),
  targetIdsShrink?: string(name='TargetIds'),
}

model DeleteTargetsResponseBody = {
  code?: string(name='Code'),
  data?: {
    errorEntries?: [ 
      {
        entryId?: string(name='EntryId'),
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
      }
    ](name='ErrorEntries'),
    errorEntriesCount?: int32(name='ErrorEntriesCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteTargetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTargetsResponseBody(name='body'),
}

async function deleteTargetsWithOptions(tmpReq: DeleteTargetsRequest, runtime: Util.RuntimeOptions): DeleteTargetsResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteTargetsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.targetIds)) {
    request.targetIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.targetIds, 'TargetIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.targetIdsShrink)) {
    query['TargetIds'] = request.targetIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTargets',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTargets(request: DeleteTargetsRequest): DeleteTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTargetsWithOptions(request, runtime);
}

model DescribeRegionsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      regionId?: string(name='RegionId'),
      regionName?: string(name='RegionName'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(runtime);
}

model DisableRuleRequest {
  eventBusName?: string(name='EventBusName'),
  ruleName?: string(name='RuleName'),
}

model DisableRuleResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableRuleResponseBody(name='body'),
}

async function disableRuleWithOptions(request: DisableRuleRequest, runtime: Util.RuntimeOptions): DisableRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableRule(request: DisableRuleRequest): DisableRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableRuleWithOptions(request, runtime);
}

model EnableRuleRequest {
  eventBusName?: string(name='EventBusName'),
  ruleName?: string(name='RuleName'),
}

model EnableRuleResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableRuleResponseBody(name='body'),
}

async function enableRuleWithOptions(request: EnableRuleRequest, runtime: Util.RuntimeOptions): EnableRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableRule(request: EnableRuleRequest): EnableRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableRuleWithOptions(request, runtime);
}

model FetchProductResourceValuesRequest {
  extraParams?: string(name='ExtraParams'),
  productName?: string(name='ProductName'),
  resourceKey?: string(name='ResourceKey'),
}

model FetchProductResourceValuesResponseBody = {
  code?: string(name='Code'),
  data?: [ string ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model FetchProductResourceValuesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FetchProductResourceValuesResponseBody(name='body'),
}

async function fetchProductResourceValuesWithOptions(request: FetchProductResourceValuesRequest, runtime: Util.RuntimeOptions): FetchProductResourceValuesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.extraParams)) {
    query['ExtraParams'] = request.extraParams;
  }
  if (!Util.isUnset(request.productName)) {
    query['ProductName'] = request.productName;
  }
  if (!Util.isUnset(request.resourceKey)) {
    query['ResourceKey'] = request.resourceKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FetchProductResourceValues',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function fetchProductResourceValues(request: FetchProductResourceValuesRequest): FetchProductResourceValuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return fetchProductResourceValuesWithOptions(request, runtime);
}

model FetchTargetResourceValuesRequest {
  extraParams?: string(name='ExtraParams'),
  resourceKey?: string(name='ResourceKey'),
  targetType?: string(name='TargetType'),
}

model FetchTargetResourceValuesResponseBody = {
  code?: string(name='Code'),
  data?: [ string ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model FetchTargetResourceValuesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FetchTargetResourceValuesResponseBody(name='body'),
}

async function fetchTargetResourceValuesWithOptions(request: FetchTargetResourceValuesRequest, runtime: Util.RuntimeOptions): FetchTargetResourceValuesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.extraParams)) {
    query['ExtraParams'] = request.extraParams;
  }
  if (!Util.isUnset(request.resourceKey)) {
    query['ResourceKey'] = request.resourceKey;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FetchTargetResourceValues',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function fetchTargetResourceValues(request: FetchTargetResourceValuesRequest): FetchTargetResourceValuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return fetchTargetResourceValuesWithOptions(request, runtime);
}

model GetACSEventsSchemaRequest {
  schemaId?: string(name='SchemaId'),
}

model GetACSEventsSchemaResponseBody = {
  code?: string(name='Code'),
  data?: {
    content?: string(name='Content'),
    dataSample?: string(name='DataSample'),
    description?: string(name='Description'),
    format?: string(name='Format'),
    groupId?: string(name='GroupId'),
    latestVersion?: long(name='LatestVersion'),
    schemaId?: string(name='SchemaId'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetACSEventsSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetACSEventsSchemaResponseBody(name='body'),
}

async function getACSEventsSchemaWithOptions(request: GetACSEventsSchemaRequest, runtime: Util.RuntimeOptions): GetACSEventsSchemaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.schemaId)) {
    query['SchemaId'] = request.schemaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetACSEventsSchema',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getACSEventsSchema(request: GetACSEventsSchemaRequest): GetACSEventsSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getACSEventsSchemaWithOptions(request, runtime);
}

model GetACSEventsSchemaGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    description?: string(name='Description'),
    format?: string(name='Format'),
    groupId?: string(name='GroupId'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetACSEventsSchemaGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetACSEventsSchemaGroupResponseBody(name='body'),
}

async function getACSEventsSchemaGroupWithOptions(runtime: Util.RuntimeOptions): GetACSEventsSchemaGroupResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetACSEventsSchemaGroup',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getACSEventsSchemaGroup(): GetACSEventsSchemaGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getACSEventsSchemaGroupWithOptions(runtime);
}

model GetACSEventsSchemaVersionRequest {
  schemaId?: string(name='SchemaId'),
  versionNumber?: long(name='VersionNumber'),
}

model GetACSEventsSchemaVersionResponseBody = {
  code?: string(name='Code'),
  data?: {
    content?: string(name='Content'),
    dataSample?: string(name='DataSample'),
    description?: string(name='Description'),
    format?: string(name='Format'),
    groupId?: string(name='GroupId'),
    schemaId?: string(name='SchemaId'),
    version?: long(name='Version'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetACSEventsSchemaVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetACSEventsSchemaVersionResponseBody(name='body'),
}

async function getACSEventsSchemaVersionWithOptions(request: GetACSEventsSchemaVersionRequest, runtime: Util.RuntimeOptions): GetACSEventsSchemaVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.schemaId)) {
    query['SchemaId'] = request.schemaId;
  }
  if (!Util.isUnset(request.versionNumber)) {
    query['VersionNumber'] = request.versionNumber;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetACSEventsSchemaVersion',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getACSEventsSchemaVersion(request: GetACSEventsSchemaVersionRequest): GetACSEventsSchemaVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getACSEventsSchemaVersionWithOptions(request, runtime);
}

model GetDefaultSchemaGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdTimestamp?: long(name='CreatedTimestamp'),
    description?: string(name='Description'),
    format?: string(name='Format'),
    groupARN?: string(name='GroupARN'),
    groupId?: string(name='GroupId'),
    updatedTimestamp?: long(name='UpdatedTimestamp'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDefaultSchemaGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDefaultSchemaGroupResponseBody(name='body'),
}

async function getDefaultSchemaGroupWithOptions(runtime: Util.RuntimeOptions): GetDefaultSchemaGroupResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetDefaultSchemaGroup',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDefaultSchemaGroup(): GetDefaultSchemaGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDefaultSchemaGroupWithOptions(runtime);
}

model GetEndpointsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      publicEndpoint?: string(name='PublicEndpoint'),
      vpcEndpoint?: string(name='VpcEndpoint'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetEndpointsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEndpointsResponseBody(name='body'),
}

async function getEndpointsWithOptions(runtime: Util.RuntimeOptions): GetEndpointsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetEndpoints',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEndpoints(): GetEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEndpointsWithOptions(runtime);
}

model GetEventBusRequest {
  eventBusName?: string(name='EventBusName'),
}

model GetEventBusResponseBody = {
  code?: string(name='Code'),
  data?: {
    createTimestamp?: long(name='CreateTimestamp'),
    description?: string(name='Description'),
    eventBusARN?: string(name='EventBusARN'),
    eventBusName?: string(name='EventBusName'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetEventBusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEventBusResponseBody(name='body'),
}

async function getEventBusWithOptions(request: GetEventBusRequest, runtime: Util.RuntimeOptions): GetEventBusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEventBus',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEventBus(request: GetEventBusRequest): GetEventBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEventBusWithOptions(request, runtime);
}

model GetEventStreamingRequest {
  eventStreamingName?: string(name='EventStreamingName'),
}

model GetEventStreamingResponseBody = {
  code?: string(name='Code'),
  data?: {
    description?: string(name='Description'),
    eventStreamingName?: string(name='EventStreamingName'),
    filterPattern?: string(name='FilterPattern'),
    runOptions?: {
      batchWindow?: {
        countBasedWindow?: int32(name='CountBasedWindow'),
        timeBasedWindow?: int32(name='TimeBasedWindow'),
      }(name='BatchWindow'),
      deadLetterQueue?: {
        arn?: string(name='Arn'),
      }(name='DeadLetterQueue'),
      errorsTolerance?: string(name='ErrorsTolerance'),
      maximumTasks?: int32(name='MaximumTasks'),
      retryStrategy?: {
        maximumEventAgeInSeconds?: float(name='MaximumEventAgeInSeconds'),
        maximumRetryAttempts?: float(name='MaximumRetryAttempts'),
        pushRetryStrategy?: string(name='PushRetryStrategy'),
      }(name='RetryStrategy'),
    }(name='RunOptions'),
    sink?: {
      sinkFcParameters?: {
        body?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Body'),
        functionName?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='FunctionName'),
        invocationType?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='InvocationType'),
        qualifier?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Qualifier'),
        serviceName?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='ServiceName'),
      }(name='SinkFcParameters'),
      sinkKafkaParameters?: {
        acks?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Acks'),
        instanceId?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='InstanceId'),
        key?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Key'),
        saslUser?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='SaslUser'),
        topic?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Topic'),
        value?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Value'),
      }(name='SinkKafkaParameters'),
      sinkMNSParameters?: {
        body?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Body'),
        isBase64Encode?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='IsBase64Encode'),
        queueName?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='QueueName'),
      }(name='SinkMNSParameters'),
      sinkRabbitMQParameters?: {
        body?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Body'),
        exchange?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Exchange'),
        instanceId?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='InstanceId'),
        messageId?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='MessageId'),
        properties?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Properties'),
        queueName?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='QueueName'),
        routingKey?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='RoutingKey'),
        targetType?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='TargetType'),
        virtualHostName?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='VirtualHostName'),
      }(name='SinkRabbitMQParameters'),
      sinkRocketMQParameters?: {
        body?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Body'),
        instanceId?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='InstanceId'),
        keys?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Keys'),
        properties?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Properties'),
        tags?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Tags'),
        topic?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Topic'),
      }(name='SinkRocketMQParameters'),
      sinkSLSParameters?: {
        body?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Body'),
        logStore?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='LogStore'),
        project?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Project'),
        roleName?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='RoleName'),
        topic?: {
          form?: string(name='Form'),
          template?: string(name='Template'),
          value?: string(name='Value'),
        }(name='Topic'),
      }(name='SinkSLSParameters'),
    }(name='Sink'),
    source?: {
      sourceDTSParameters?: {
        brokerUrl?: string(name='BrokerUrl'),
        initCheckPoint?: string(name='InitCheckPoint'),
        password?: string(name='Password'),
        sid?: string(name='Sid'),
        taskId?: string(name='TaskId'),
        topic?: string(name='Topic'),
        username?: string(name='Username'),
      }(name='SourceDTSParameters'),
      sourceKafkaParameters?: {
        consumerGroup?: string(name='ConsumerGroup'),
        instanceId?: string(name='InstanceId'),
        network?: string(name='Network'),
        offsetReset?: string(name='OffsetReset'),
        regionId?: string(name='RegionId'),
        securityGroupId?: string(name='SecurityGroupId'),
        topic?: string(name='Topic'),
        vSwitchIds?: string(name='VSwitchIds'),
        vpcId?: string(name='VpcId'),
      }(name='SourceKafkaParameters'),
      sourceMNSParameters?: {
        isBase64Decode?: boolean(name='IsBase64Decode'),
        queueName?: string(name='QueueName'),
        regionId?: string(name='RegionId'),
      }(name='SourceMNSParameters'),
      sourceMQTTParameters?: {
        instanceId?: string(name='InstanceId'),
        regionId?: string(name='RegionId'),
        topic?: string(name='Topic'),
      }(name='SourceMQTTParameters'),
      sourceRabbitMQParameters?: {
        instanceId?: string(name='InstanceId'),
        queueName?: string(name='QueueName'),
        regionId?: string(name='RegionId'),
        virtualHostName?: string(name='VirtualHostName'),
      }(name='SourceRabbitMQParameters'),
      sourceRocketMQParameters?: {
        groupID?: string(name='GroupID'),
        instanceId?: string(name='InstanceId'),
        offset?: string(name='Offset'),
        regionId?: string(name='RegionId'),
        tag?: string(name='Tag'),
        timestamp?: long(name='Timestamp'),
        topic?: string(name='Topic'),
      }(name='SourceRocketMQParameters'),
      sourceSLSParameters?: {
        consumePosition?: string(name='ConsumePosition'),
        consumerGroup?: string(name='ConsumerGroup'),
        logStore?: string(name='LogStore'),
        project?: string(name='Project'),
        roleName?: string(name='RoleName'),
      }(name='SourceSLSParameters'),
    }(name='Source'),
    status?: string(name='Status'),
    tag?: string(name='Tag'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetEventStreamingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEventStreamingResponseBody(name='body'),
}

async function getEventStreamingWithOptions(request: GetEventStreamingRequest, runtime: Util.RuntimeOptions): GetEventStreamingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEventStreaming(request: GetEventStreamingRequest): GetEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEventStreamingWithOptions(request, runtime);
}

model GetRuleRequest {
  eventBusName?: string(name='EventBusName'),
  ruleName?: string(name='RuleName'),
}

model GetRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdTimestamp?: long(name='CreatedTimestamp'),
    description?: string(name='Description'),
    eventBusName?: string(name='EventBusName'),
    filterPattern?: string(name='FilterPattern'),
    ruleARN?: string(name='RuleARN'),
    ruleName?: string(name='RuleName'),
    status?: string(name='Status'),
    targets?: [ 
      {
        deadLetterQueue?: {
          arn?: string(name='Arn'),
        }(name='DeadLetterQueue'),
        detailMap?: map[string]any(name='DetailMap'),
        endpoint?: string(name='Endpoint'),
        id?: string(name='Id'),
        paramList?: [ 
          {
            form?: string(name='Form'),
            resourceKey?: string(name='ResourceKey'),
            template?: string(name='Template'),
            value?: string(name='Value'),
          }
        ](name='ParamList'),
        pushRetryStrategy?: string(name='PushRetryStrategy'),
        pushSelector?: string(name='PushSelector'),
        type?: string(name='Type'),
      }
    ](name='Targets'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRuleResponseBody(name='body'),
}

async function getRuleWithOptions(request: GetRuleRequest, runtime: Util.RuntimeOptions): GetRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRule(request: GetRuleRequest): GetRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRuleWithOptions(request, runtime);
}

model GetSchemaRequest {
  groupId?: string(name='GroupId'),
  schemaId?: string(name='SchemaId'),
}

model GetSchemaResponseBody = {
  code?: string(name='Code'),
  data?: {
    compatibleType?: string(name='CompatibleType'),
    content?: string(name='Content'),
    createdTimestamp?: long(name='CreatedTimestamp'),
    description?: string(name='Description'),
    format?: string(name='Format'),
    groupId?: string(name='GroupId'),
    latestVersion?: long(name='LatestVersion'),
    schemaId?: string(name='SchemaId'),
    updatedTimestamp?: long(name='UpdatedTimestamp'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSchemaResponseBody(name='body'),
}

async function getSchemaWithOptions(request: GetSchemaRequest, runtime: Util.RuntimeOptions): GetSchemaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.schemaId)) {
    query['SchemaId'] = request.schemaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSchema',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSchema(request: GetSchemaRequest): GetSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSchemaWithOptions(request, runtime);
}

model GetSchemaGroupRequest {
  groupId?: string(name='GroupId'),
}

model GetSchemaGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdTimestamp?: long(name='CreatedTimestamp'),
    description?: string(name='Description'),
    format?: string(name='Format'),
    groupARN?: string(name='GroupARN'),
    groupId?: string(name='GroupId'),
    updatedTimestamp?: long(name='UpdatedTimestamp'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSchemaGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSchemaGroupResponseBody(name='body'),
}

async function getSchemaGroupWithOptions(request: GetSchemaGroupRequest, runtime: Util.RuntimeOptions): GetSchemaGroupResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSchemaGroup',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSchemaGroup(request: GetSchemaGroupRequest): GetSchemaGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSchemaGroupWithOptions(request, runtime);
}

model GetSchemaVersionRequest {
  groupId?: string(name='GroupId'),
  schemaId?: string(name='SchemaId'),
  versionNumber?: long(name='VersionNumber'),
}

model GetSchemaVersionResponseBody = {
  code?: string(name='Code'),
  data?: {
    content?: string(name='Content'),
    createdTimestamp?: long(name='CreatedTimestamp'),
    format?: string(name='Format'),
    groupId?: string(name='GroupId'),
    schemaId?: string(name='SchemaId'),
    schemaVersionARN?: string(name='SchemaVersionARN'),
    updatedTimestamp?: long(name='UpdatedTimestamp'),
    version?: long(name='Version'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSchemaVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSchemaVersionResponseBody(name='body'),
}

async function getSchemaVersionWithOptions(request: GetSchemaVersionRequest, runtime: Util.RuntimeOptions): GetSchemaVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.schemaId)) {
    query['SchemaId'] = request.schemaId;
  }
  if (!Util.isUnset(request.versionNumber)) {
    query['VersionNumber'] = request.versionNumber;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSchemaVersion',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSchemaVersion(request: GetSchemaVersionRequest): GetSchemaVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSchemaVersionWithOptions(request, runtime);
}

model GetSourceTaskRequest {
  taskId?: string(name='TaskId'),
}

model GetSourceTaskResponseBody = {
  code?: string(name='Code'),
  data?: {
    busName?: string(name='BusName'),
    id?: string(name='Id'),
    lastDateSyncTime?: string(name='LastDateSyncTime'),
    name?: string(name='Name'),
    sendedRecords?: long(name='SendedRecords'),
    sourceConfig?: map[string]any(name='SourceConfig'),
    sourceType?: string(name='SourceType'),
    status?: string(name='Status'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSourceTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSourceTaskResponseBody(name='body'),
}

async function getSourceTaskWithOptions(request: GetSourceTaskRequest, runtime: Util.RuntimeOptions): GetSourceTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetSourceTask',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSourceTask(request: GetSourceTaskRequest): GetSourceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSourceTaskWithOptions(request, runtime);
}

model ListACSEventsSchemaVersionsRequest {
  limit?: int32(name='Limit'),
  nextToken?: string(name='NextToken'),
  schemaId?: string(name='SchemaId'),
}

model ListACSEventsSchemaVersionsResponseBody = {
  code?: string(name='Code'),
  data?: {
    nextToken?: string(name='NextToken'),
    total?: long(name='Total'),
    versions?: [ 
      {
        content?: string(name='Content'),
        dataSample?: string(name='DataSample'),
        format?: string(name='Format'),
        groupId?: string(name='GroupId'),
        schemaId?: string(name='SchemaId'),
        version?: long(name='Version'),
      }
    ](name='Versions'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListACSEventsSchemaVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListACSEventsSchemaVersionsResponseBody(name='body'),
}

async function listACSEventsSchemaVersionsWithOptions(request: ListACSEventsSchemaVersionsRequest, runtime: Util.RuntimeOptions): ListACSEventsSchemaVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.schemaId)) {
    query['SchemaId'] = request.schemaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListACSEventsSchemaVersions',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listACSEventsSchemaVersions(request: ListACSEventsSchemaVersionsRequest): ListACSEventsSchemaVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listACSEventsSchemaVersionsWithOptions(request, runtime);
}

model ListACSEventsSchemasRequest {
  limit?: int32(name='Limit'),
  nextToken?: string(name='NextToken'),
  prefix?: string(name='Prefix'),
}

model ListACSEventsSchemasResponseBody = {
  code?: string(name='Code'),
  data?: {
    nextToken?: string(name='NextToken'),
    schemas?: [ 
      {
        description?: string(name='Description'),
        format?: string(name='Format'),
        groupId?: string(name='GroupId'),
        latestVersion?: long(name='LatestVersion'),
        schemaId?: string(name='SchemaId'),
      }
    ](name='Schemas'),
    total?: long(name='Total'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListACSEventsSchemasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListACSEventsSchemasResponseBody(name='body'),
}

async function listACSEventsSchemasWithOptions(request: ListACSEventsSchemasRequest, runtime: Util.RuntimeOptions): ListACSEventsSchemasResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['Prefix'] = request.prefix;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListACSEventsSchemas',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listACSEventsSchemas(request: ListACSEventsSchemasRequest): ListACSEventsSchemasResponse {
  var runtime = new Util.RuntimeOptions{};
  return listACSEventsSchemasWithOptions(request, runtime);
}

model ListAliyunOfficialEventSourcesRequest {
  limit?: int32(name='Limit'),
  namePrefix?: string(name='NamePrefix'),
  nextToken?: string(name='NextToken'),
  type?: bytes(name='Type'),
}

model ListAliyunOfficialEventSourcesResponseBody = {
  code?: string(name='Code'),
  data?: {
    eventSourceList?: [ 
      {
        arn?: string(name='Arn'),
        ctime?: float(name='Ctime'),
        description?: string(name='Description'),
        eventBusName?: string(name='EventBusName'),
        eventTypes?: [ 
          {
            description?: string(name='Description'),
            groupName?: string(name='GroupName'),
            name?: string(name='Name'),
            shortName?: string(name='ShortName'),
          }
        ](name='EventTypes'),
        name?: string(name='Name'),
        status?: string(name='Status'),
        type?: string(name='Type'),
      }
    ](name='EventSourceList'),
    nextToken?: string(name='NextToken'),
    total?: float(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAliyunOfficialEventSourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAliyunOfficialEventSourcesResponseBody(name='body'),
}

async function listAliyunOfficialEventSourcesWithOptions(request: ListAliyunOfficialEventSourcesRequest, runtime: Util.RuntimeOptions): ListAliyunOfficialEventSourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namePrefix)) {
    query['NamePrefix'] = request.namePrefix;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAliyunOfficialEventSources',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAliyunOfficialEventSources(request: ListAliyunOfficialEventSourcesRequest): ListAliyunOfficialEventSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAliyunOfficialEventSourcesWithOptions(request, runtime);
}

model ListEventBusesRequest {
  eventBusType?: string(name='EventBusType'),
  limit?: int32(name='Limit'),
  namePrefix?: string(name='NamePrefix'),
  nextToken?: string(name='NextToken'),
}

model ListEventBusesResponseBody = {
  code?: string(name='Code'),
  data?: {
    eventBuses?: [ 
      {
        createTimestamp?: long(name='CreateTimestamp'),
        description?: string(name='Description'),
        eventBusARN?: string(name='EventBusARN'),
        eventBusName?: string(name='EventBusName'),
      }
    ](name='EventBuses'),
    nextToken?: string(name='NextToken'),
    total?: int32(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListEventBusesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventBusesResponseBody(name='body'),
}

async function listEventBusesWithOptions(request: ListEventBusesRequest, runtime: Util.RuntimeOptions): ListEventBusesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusType)) {
    query['EventBusType'] = request.eventBusType;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namePrefix)) {
    query['NamePrefix'] = request.namePrefix;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEventBuses',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEventBuses(request: ListEventBusesRequest): ListEventBusesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventBusesWithOptions(request, runtime);
}

model ListEventSourcesRequest {
  limit?: int32(name='Limit'),
  namePrefix?: string(name='NamePrefix'),
  nextToken?: string(name='NextToken'),
  type?: bytes(name='Type'),
}

model ListEventSourcesResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      ARN?: string(name='ARN'),
      attachedBuses?: [ string ](name='AttachedBuses'),
      ctime?: float(name='Ctime'),
      description?: string(name='Description'),
      eventTypes?: [ 
        {
          description?: string(name='Description'),
          eventSourceName?: string(name='EventSourceName'),
          groupName?: string(name='GroupName'),
          name?: string(name='Name'),
          shortName?: string(name='ShortName'),
        }
      ](name='EventTypes'),
      externalSourceConfig?: map[string]any(name='ExternalSourceConfig'),
      externalSourceType?: string(name='ExternalSourceType'),
      fullName?: string(name='FullName'),
      linkedExternalSource?: boolean(name='LinkedExternalSource'),
      name?: string(name='Name'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListEventSourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventSourcesResponseBody(name='body'),
}

async function listEventSourcesWithOptions(request: ListEventSourcesRequest, runtime: Util.RuntimeOptions): ListEventSourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namePrefix)) {
    query['NamePrefix'] = request.namePrefix;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEventSources',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEventSources(request: ListEventSourcesRequest): ListEventSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventSourcesWithOptions(request, runtime);
}

model ListEventStreamingRequest {
  limit?: long(name='Limit'),
  namePrefix?: string(name='NamePrefix'),
  nextToken?: string(name='NextToken'),
  sinkType?: string(name='SinkType'),
  sourceType?: string(name='SourceType'),
  tag?: string(name='Tag'),
}

model ListEventStreamingResponseBody = {
  code?: string(name='Code'),
  data?: {
    eventStreamings?: [ 
      {
        description?: string(name='Description'),
        eventStreamingName?: string(name='EventStreamingName'),
        filterPattern?: string(name='FilterPattern'),
        runOptions?: {
          batchWindow?: {
            countBasedWindow?: int32(name='CountBasedWindow'),
            timeBasedWindow?: int32(name='TimeBasedWindow'),
          }(name='BatchWindow'),
          deadLetterQueue?: {
            arn?: string(name='Arn'),
          }(name='DeadLetterQueue'),
          errorsTolerance?: string(name='ErrorsTolerance'),
          maximumTasks?: int32(name='MaximumTasks'),
          retryStrategy?: {
            maximumEventAgeInSeconds?: float(name='MaximumEventAgeInSeconds'),
            maximumRetryAttempts?: float(name='MaximumRetryAttempts'),
            pushRetryStrategy?: string(name='PushRetryStrategy'),
          }(name='RetryStrategy'),
        }(name='RunOptions'),
        sink?: {
          sinkFcParameters?: {
            body?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Body'),
            functionName?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='FunctionName'),
            invocationType?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='InvocationType'),
            qualifier?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Qualifier'),
            serviceName?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='ServiceName'),
          }(name='SinkFcParameters'),
          sinkKafkaParameters?: {
            acks?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Acks'),
            instanceId?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='InstanceId'),
            key?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Key'),
            saslUser?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='SaslUser'),
            topic?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Topic'),
            value?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Value'),
          }(name='SinkKafkaParameters'),
          sinkMNSParameters?: {
            body?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Body'),
            isBase64Encode?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='IsBase64Encode'),
            queueName?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='QueueName'),
          }(name='SinkMNSParameters'),
          sinkRabbitMQParameters?: {
            body?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Body'),
            exchange?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Exchange'),
            instanceId?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='InstanceId'),
            messageId?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='MessageId'),
            properties?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Properties'),
            queueName?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='QueueName'),
            routingKey?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='RoutingKey'),
            targetType?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='TargetType'),
            virtualHostName?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='VirtualHostName'),
          }(name='SinkRabbitMQParameters'),
          sinkRocketMQParameters?: {
            body?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Body'),
            instanceId?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='InstanceId'),
            keys?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Keys'),
            properties?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Properties'),
            tags?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Tags'),
            topic?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Topic'),
          }(name='SinkRocketMQParameters'),
          sinkSLSParameters?: {
            body?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Body'),
            logStore?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='LogStore'),
            project?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Project'),
            roleName?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='RoleName'),
            topic?: {
              form?: string(name='Form'),
              template?: string(name='Template'),
              value?: string(name='Value'),
            }(name='Topic'),
          }(name='SinkSLSParameters'),
        }(name='Sink'),
        source?: {
          sourceDTSParameters?: {
            brokerUrl?: string(name='BrokerUrl'),
            initCheckPoint?: string(name='InitCheckPoint'),
            password?: string(name='Password'),
            sid?: string(name='Sid'),
            taskId?: string(name='TaskId'),
            topic?: string(name='Topic'),
            username?: string(name='Username'),
          }(name='SourceDTSParameters'),
          sourceKafkaParameters?: {
            consumerGroup?: string(name='ConsumerGroup'),
            instanceId?: string(name='InstanceId'),
            network?: string(name='Network'),
            offsetReset?: string(name='OffsetReset'),
            regionId?: string(name='RegionId'),
            securityGroupId?: string(name='SecurityGroupId'),
            topic?: string(name='Topic'),
            vSwitchIds?: string(name='VSwitchIds'),
            vpcId?: string(name='VpcId'),
          }(name='SourceKafkaParameters'),
          sourceMNSParameters?: {
            isBase64Decode?: boolean(name='IsBase64Decode'),
            queueName?: string(name='QueueName'),
            regionId?: string(name='RegionId'),
          }(name='SourceMNSParameters'),
          sourceMQTTParameters?: {
            instanceId?: string(name='InstanceId'),
            regionId?: string(name='RegionId'),
            topic?: string(name='Topic'),
          }(name='SourceMQTTParameters'),
          sourceRabbitMQParameters?: {
            instanceId?: string(name='InstanceId'),
            queueName?: string(name='QueueName'),
            regionId?: string(name='RegionId'),
            virtualHostName?: string(name='VirtualHostName'),
          }(name='SourceRabbitMQParameters'),
          sourceRocketMQParameters?: {
            groupID?: string(name='GroupID'),
            instanceId?: string(name='InstanceId'),
            offset?: string(name='Offset'),
            regionId?: string(name='RegionId'),
            tag?: string(name='Tag'),
            timestamp?: long(name='Timestamp'),
            topic?: string(name='Topic'),
          }(name='SourceRocketMQParameters'),
          sourceSLSParameters?: {
            consumePosition?: string(name='ConsumePosition'),
            consumerGroup?: string(name='ConsumerGroup'),
            logStore?: string(name='LogStore'),
            project?: string(name='Project'),
            roleName?: string(name='RoleName'),
          }(name='SourceSLSParameters'),
        }(name='Source'),
        status?: string(name='Status'),
        tag?: string(name='Tag'),
      }
    ](name='EventStreamings'),
    nextToken?: string(name='NextToken'),
    total?: int32(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListEventStreamingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventStreamingResponseBody(name='body'),
}

async function listEventStreamingWithOptions(request: ListEventStreamingRequest, runtime: Util.RuntimeOptions): ListEventStreamingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namePrefix)) {
    body['NamePrefix'] = request.namePrefix;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.sinkType)) {
    body['SinkType'] = request.sinkType;
  }
  if (!Util.isUnset(request.sourceType)) {
    body['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEventStreaming(request: ListEventStreamingRequest): ListEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventStreamingWithOptions(request, runtime);
}

model ListEventStreamingMetricsRequest {
  names?: [ string ](name='Names'),
}

model ListEventStreamingMetricsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      delayTime?: float(name='DelayTime'),
      diffOffset?: float(name='DiffOffset'),
      lastSyncTime?: float(name='LastSyncTime'),
      name?: string(name='Name'),
      status?: string(name='Status'),
      TPS?: float(name='TPS'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListEventStreamingMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventStreamingMetricsResponseBody(name='body'),
}

async function listEventStreamingMetricsWithOptions(request: ListEventStreamingMetricsRequest, runtime: Util.RuntimeOptions): ListEventStreamingMetricsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEventStreamingMetrics',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEventStreamingMetrics(request: ListEventStreamingMetricsRequest): ListEventStreamingMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventStreamingMetricsWithOptions(request, runtime);
}

model ListRulesRequest {
  eventBusName?: string(name='EventBusName'),
  limit?: int32(name='Limit'),
  nextToken?: string(name='NextToken'),
  ruleNamePrefix?: string(name='RuleNamePrefix'),
}

model ListRulesResponseBody = {
  code?: string(name='Code'),
  data?: {
    nextToken?: string(name='NextToken'),
    rules?: [ 
      {
        createdTimestamp?: long(name='CreatedTimestamp'),
        description?: string(name='Description'),
        detailMap?: map[string]any(name='DetailMap'),
        eventBusName?: string(name='EventBusName'),
        filterPattern?: string(name='FilterPattern'),
        ruleARN?: string(name='RuleARN'),
        ruleName?: string(name='RuleName'),
        status?: string(name='Status'),
        targets?: [ 
          {
            endpoint?: string(name='Endpoint'),
            id?: string(name='Id'),
            pushSelector?: string(name='PushSelector'),
            type?: string(name='Type'),
          }
        ](name='Targets'),
      }
    ](name='Rules'),
    total?: int32(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRulesResponseBody(name='body'),
}

async function listRulesWithOptions(request: ListRulesRequest, runtime: Util.RuntimeOptions): ListRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ruleNamePrefix)) {
    query['RuleNamePrefix'] = request.ruleNamePrefix;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRules',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRules(request: ListRulesRequest): ListRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRulesWithOptions(request, runtime);
}

model ListSchemaGroupsRequest {
  limit?: int32(name='Limit'),
  nextToken?: string(name='NextToken'),
  prefix?: string(name='Prefix'),
}

model ListSchemaGroupsResponseBody = {
  code?: string(name='Code'),
  data?: {
    groups?: [ 
      {
        createdTimestamp?: long(name='CreatedTimestamp'),
        description?: string(name='Description'),
        format?: string(name='Format'),
        groupARN?: string(name='GroupARN'),
        groupId?: string(name='GroupId'),
        updatedTimestamp?: long(name='UpdatedTimestamp'),
      }
    ](name='Groups'),
    nextToken?: string(name='NextToken'),
    total?: long(name='Total'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListSchemaGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSchemaGroupsResponseBody(name='body'),
}

async function listSchemaGroupsWithOptions(request: ListSchemaGroupsRequest, runtime: Util.RuntimeOptions): ListSchemaGroupsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSchemaGroups',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSchemaGroups(request: ListSchemaGroupsRequest): ListSchemaGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSchemaGroupsWithOptions(request, runtime);
}

model ListSchemaVersionsRequest {
  groupId?: string(name='GroupId'),
  limit?: int32(name='Limit'),
  nextToken?: string(name='NextToken'),
  schemaId?: string(name='SchemaId'),
}

model ListSchemaVersionsResponseBody = {
  code?: string(name='Code'),
  data?: {
    nextToken?: string(name='NextToken'),
    total?: long(name='Total'),
    versions?: [ 
      {
        content?: string(name='Content'),
        createdTimestamp?: long(name='CreatedTimestamp'),
        format?: string(name='Format'),
        groupId?: string(name='GroupId'),
        schemaId?: string(name='SchemaId'),
        schemaVersionARN?: string(name='SchemaVersionARN'),
        updatedTimestamp?: long(name='UpdatedTimestamp'),
        version?: long(name='Version'),
      }
    ](name='Versions'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListSchemaVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSchemaVersionsResponseBody(name='body'),
}

async function listSchemaVersionsWithOptions(request: ListSchemaVersionsRequest, runtime: Util.RuntimeOptions): ListSchemaVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.schemaId)) {
    query['SchemaId'] = request.schemaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSchemaVersions',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSchemaVersions(request: ListSchemaVersionsRequest): ListSchemaVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSchemaVersionsWithOptions(request, runtime);
}

model ListSchemasRequest {
  groupId?: string(name='GroupId'),
  limit?: int32(name='Limit'),
  nextToken?: string(name='NextToken'),
  prefix?: string(name='Prefix'),
}

model ListSchemasResponseBody = {
  code?: string(name='Code'),
  data?: {
    nextToken?: string(name='NextToken'),
    schemas?: [ 
      {
        compatibleType?: string(name='CompatibleType'),
        createdTimestamp?: long(name='CreatedTimestamp'),
        description?: string(name='Description'),
        format?: string(name='Format'),
        groupId?: string(name='GroupId'),
        latestVersion?: long(name='LatestVersion'),
        schemaId?: string(name='SchemaId'),
        updatedTimestamp?: long(name='UpdatedTimestamp'),
      }
    ](name='Schemas'),
    total?: long(name='Total'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListSchemasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSchemasResponseBody(name='body'),
}

async function listSchemasWithOptions(request: ListSchemasRequest, runtime: Util.RuntimeOptions): ListSchemasResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSchemas',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSchemas(request: ListSchemasRequest): ListSchemasResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSchemasWithOptions(request, runtime);
}

model ListSourceTaskResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      busName?: string(name='BusName'),
      id?: string(name='Id'),
      lastDateSyncTime?: string(name='LastDateSyncTime'),
      name?: string(name='Name'),
      sendedRecords?: long(name='SendedRecords'),
      source?: string(name='Source'),
      status?: string(name='Status'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListSourceTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSourceTaskResponseBody(name='body'),
}

async function listSourceTaskWithOptions(runtime: Util.RuntimeOptions): ListSourceTaskResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListSourceTask',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSourceTask(): ListSourceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSourceTaskWithOptions(runtime);
}

model ListTargetTypesRequest {
  limit?: int32(name='Limit'),
  namePrefix?: string(name='NamePrefix'),
  nextToken?: string(name='NextToken'),
}

model ListTargetTypesResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      ACSName?: string(name='ACSName'),
      arn?: string(name='Arn'),
      fullName?: string(name='FullName'),
      name?: string(name='Name'),
      resourceKeys?: [ 
        {
          advancedOption?: boolean(name='AdvancedOption'),
          defaultValues?: [ 
            {
              name?: string(name='Name'),
              value?: string(name='Value'),
            }
          ](name='DefaultValues'),
          dependentResourceKeys?: [ string ](name='DependentResourceKeys'),
          forms?: [ string ](name='Forms'),
          inputType?: string(name='InputType'),
          placeholder?: string(name='Placeholder'),
          resourceGroup?: [ 
            {
              defaultValues?: [ 
                {
                  name?: string(name='Name'),
                  value?: string(name='Value'),
                }
              ](name='DefaultValues'),
              dependentResourceKeys?: [ string ](name='DependentResourceKeys'),
              forms?: [ string ](name='Forms'),
              inputType?: string(name='InputType'),
              placeholder?: string(name='Placeholder'),
              resourceKey?: string(name='ResourceKey'),
              resourceName?: string(name='ResourceName'),
              showIf?: string(name='ShowIf'),
              tips?: string(name='Tips'),
            }
          ](name='ResourceGroup'),
          resourceKey?: string(name='ResourceKey'),
          resourceName?: string(name='ResourceName'),
          showIf?: string(name='ShowIf'),
          tips?: string(name='Tips'),
        }
      ](name='ResourceKeys'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListTargetTypesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTargetTypesResponseBody(name='body'),
}

async function listTargetTypesWithOptions(request: ListTargetTypesRequest, runtime: Util.RuntimeOptions): ListTargetTypesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namePrefix)) {
    query['NamePrefix'] = request.namePrefix;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTargetTypes',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTargetTypes(request: ListTargetTypesRequest): ListTargetTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTargetTypesWithOptions(request, runtime);
}

model ListTargetsRequest {
  eventBusName?: string(name='EventBusName'),
  limit?: int32(name='Limit'),
  ruleName?: string(name='RuleName'),
}

model ListTargetsResponseBody = {
  code?: string(name='Code'),
  data?: {
    targets?: [ 
      {
        detailMap?: map[string]any(name='DetailMap'),
        endpoint?: string(name='Endpoint'),
        id?: string(name='Id'),
        paramList?: [ 
          {
            form?: string(name='Form'),
            resourceKey?: string(name='ResourceKey'),
            template?: string(name='Template'),
            value?: string(name='Value'),
          }
        ](name='ParamList'),
        pushSelector?: string(name='PushSelector'),
        type?: string(name='Type'),
      }
    ](name='Targets'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListTargetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTargetsResponseBody(name='body'),
}

async function listTargetsWithOptions(request: ListTargetsRequest, runtime: Util.RuntimeOptions): ListTargetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTargets',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTargets(request: ListTargetsRequest): ListTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTargetsWithOptions(request, runtime);
}

model ListUserDefinedEventSourcesRequest {
  limit?: int32(name='Limit'),
  namePrefix?: string(name='NamePrefix'),
  nextToken?: string(name='NextToken'),
  type?: bytes(name='Type'),
}

model ListUserDefinedEventSourcesResponseBody = {
  code?: string(name='Code'),
  data?: {
    eventSourceList?: [ 
      {
        arn?: string(name='Arn'),
        ctime?: float(name='Ctime'),
        description?: string(name='Description'),
        eventBusName?: string(name='EventBusName'),
        externalSourceConfig?: map[string]any(name='ExternalSourceConfig'),
        externalSourceType?: string(name='ExternalSourceType'),
        linkedExternalSource?: boolean(name='LinkedExternalSource'),
        name?: string(name='Name'),
        status?: string(name='Status'),
        type?: string(name='Type'),
      }
    ](name='EventSourceList'),
    nextToken?: string(name='NextToken'),
    total?: float(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListUserDefinedEventSourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserDefinedEventSourcesResponseBody(name='body'),
}

async function listUserDefinedEventSourcesWithOptions(request: ListUserDefinedEventSourcesRequest, runtime: Util.RuntimeOptions): ListUserDefinedEventSourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.namePrefix)) {
    query['NamePrefix'] = request.namePrefix;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserDefinedEventSources',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserDefinedEventSources(request: ListUserDefinedEventSourcesRequest): ListUserDefinedEventSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserDefinedEventSourcesWithOptions(request, runtime);
}

model PauseEventStreamingRequest {
  eventStreamingName?: string(name='EventStreamingName'),
}

model PauseEventStreamingResponseBody = {
  code?: boolean(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PauseEventStreamingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PauseEventStreamingResponseBody(name='body'),
}

async function pauseEventStreamingWithOptions(request: PauseEventStreamingRequest, runtime: Util.RuntimeOptions): PauseEventStreamingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PauseEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pauseEventStreaming(request: PauseEventStreamingRequest): PauseEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return pauseEventStreamingWithOptions(request, runtime);
}

model PayOrderCallbackRequest {
  data?: string(name='Data'),
}

model PayOrderCallbackResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  synchro?: string(name='Synchro'),
}

model PayOrderCallbackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PayOrderCallbackResponseBody(name='body'),
}

async function payOrderCallbackWithOptions(request: PayOrderCallbackRequest, runtime: Util.RuntimeOptions): PayOrderCallbackResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PayOrderCallback',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function payOrderCallback(request: PayOrderCallbackRequest): PayOrderCallbackResponse {
  var runtime = new Util.RuntimeOptions{};
  return payOrderCallbackWithOptions(request, runtime);
}

model PutEventsRequest {
  eventString?: string(name='EventString'),
}

model PutEventsResponseBody = {
  code?: string(name='Code'),
  data?: {
    eventId?: string(name='EventId'),
    traceId?: string(name='TraceId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutEventsResponseBody(name='body'),
}

async function putEventsWithOptions(request: PutEventsRequest, runtime: Util.RuntimeOptions): PutEventsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventString)) {
    body['EventString'] = request.eventString;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutEvents',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putEvents(request: PutEventsRequest): PutEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return putEventsWithOptions(request, runtime);
}

model QueryEventRequest {
  eventBusName?: string(name='EventBusName'),
  eventId?: string(name='EventId'),
  eventSource?: string(name='EventSource'),
}

model QueryEventResponseBody = {
  code?: string(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryEventResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryEventResponseBody(name='body'),
}

async function queryEventWithOptions(request: QueryEventRequest, runtime: Util.RuntimeOptions): QueryEventResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.eventSource)) {
    query['EventSource'] = request.eventSource;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEvent',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryEvent(request: QueryEventRequest): QueryEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEventWithOptions(request, runtime);
}

model QueryEventTracesRequest {
  eventBusName?: string(name='EventBusName'),
  eventId?: string(name='EventId'),
}

model QueryEventTracesResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      action?: string(name='Action'),
      actionTime?: long(name='ActionTime'),
      endpoint?: string(name='Endpoint'),
      eventBusName?: string(name='EventBusName'),
      eventId?: string(name='EventId'),
      eventSource?: string(name='EventSource'),
      notifyLatency?: string(name='NotifyLatency'),
      notifyStatus?: string(name='NotifyStatus'),
      notifyTime?: long(name='NotifyTime'),
      receivedTime?: long(name='ReceivedTime'),
      ruleMatchingTime?: string(name='RuleMatchingTime'),
      ruleName?: string(name='RuleName'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryEventTracesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryEventTracesResponseBody(name='body'),
}

async function queryEventTracesWithOptions(request: QueryEventTracesRequest, runtime: Util.RuntimeOptions): QueryEventTracesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEventTraces',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryEventTraces(request: QueryEventTracesRequest): QueryEventTracesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEventTracesWithOptions(request, runtime);
}

model QueryTracedEventByEventIdRequest {
  eventBusName?: string(name='EventBusName'),
  eventId?: string(name='EventId'),
  eventSource?: string(name='EventSource'),
}

model QueryTracedEventByEventIdResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      events?: [ 
        {
          eventBusName?: string(name='EventBusName'),
          eventId?: string(name='EventId'),
          eventReceivedTime?: long(name='EventReceivedTime'),
          eventSource?: string(name='EventSource'),
          eventType?: string(name='EventType'),
        }
      ](name='Events'),
      nextToken?: string(name='NextToken'),
      total?: int32(name='Total'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryTracedEventByEventIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTracedEventByEventIdResponseBody(name='body'),
}

async function queryTracedEventByEventIdWithOptions(request: QueryTracedEventByEventIdRequest, runtime: Util.RuntimeOptions): QueryTracedEventByEventIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.eventSource)) {
    query['EventSource'] = request.eventSource;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTracedEventByEventId',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTracedEventByEventId(request: QueryTracedEventByEventIdRequest): QueryTracedEventByEventIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTracedEventByEventIdWithOptions(request, runtime);
}

model QueryTracedEventsRequest {
  endTime?: long(name='EndTime'),
  eventBusName?: string(name='EventBusName'),
  eventSource?: string(name='EventSource'),
  eventType?: string(name='EventType'),
  limit?: int32(name='Limit'),
  matchedRule?: string(name='MatchedRule'),
  nextToken?: string(name='NextToken'),
  startTime?: long(name='StartTime'),
}

model QueryTracedEventsResponseBody = {
  code?: string(name='Code'),
  data?: {
    events?: [ 
      {
        eventBusName?: string(name='EventBusName'),
        eventId?: string(name='EventId'),
        eventReceivedTime?: long(name='EventReceivedTime'),
        eventSource?: string(name='EventSource'),
        eventType?: string(name='EventType'),
      }
    ](name='Events'),
    nextToken?: string(name='NextToken'),
    total?: int32(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryTracedEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTracedEventsResponseBody(name='body'),
}

async function queryTracedEventsWithOptions(request: QueryTracedEventsRequest, runtime: Util.RuntimeOptions): QueryTracedEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventSource)) {
    query['EventSource'] = request.eventSource;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.matchedRule)) {
    query['MatchedRule'] = request.matchedRule;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTracedEvents',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTracedEvents(request: QueryTracedEventsRequest): QueryTracedEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTracedEventsWithOptions(request, runtime);
}

model RefundRequest {
  data?: string(name='Data'),
}

model RefundResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  synchro?: string(name='Synchro'),
}

model RefundResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefundResponseBody(name='body'),
}

async function refundWithOptions(request: RefundRequest, runtime: Util.RuntimeOptions): RefundResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Refund',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refund(request: RefundRequest): RefundResponse {
  var runtime = new Util.RuntimeOptions{};
  return refundWithOptions(request, runtime);
}

model SaveAndPublishSourceTaskRequest {
  busName?: string(name='BusName'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  sourceConfig?: map[string]any(name='SourceConfig'),
  sourceType?: string(name='SourceType'),
}

model SaveAndPublishSourceTaskShrinkRequest {
  busName?: string(name='BusName'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  sourceConfigShrink?: string(name='SourceConfig'),
  sourceType?: string(name='SourceType'),
}

model SaveAndPublishSourceTaskResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveAndPublishSourceTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveAndPublishSourceTaskResponseBody(name='body'),
}

async function saveAndPublishSourceTaskWithOptions(tmpReq: SaveAndPublishSourceTaskRequest, runtime: Util.RuntimeOptions): SaveAndPublishSourceTaskResponse {
  Util.validateModel(tmpReq);
  var request = new SaveAndPublishSourceTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.sourceConfig)) {
    request.sourceConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceConfig, 'SourceConfig', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.busName)) {
    body['BusName'] = request.busName;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.sourceConfigShrink)) {
    body['SourceConfig'] = request.sourceConfigShrink;
  }
  if (!Util.isUnset(request.sourceType)) {
    body['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SaveAndPublishSourceTask',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveAndPublishSourceTask(request: SaveAndPublishSourceTaskRequest): SaveAndPublishSourceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveAndPublishSourceTaskWithOptions(request, runtime);
}

model SaveAndStartEventStreamingRequest {
  description?: string(name='Description'),
  EBEventSourceEntry?: {
    description?: string(name='Description'),
    externalSourceConfig?: map[string]any(name='ExternalSourceConfig'),
    externalSourceType?: string(name='ExternalSourceType'),
    isNew?: boolean(name='IsNew'),
    name?: string(name='Name'),
  }(name='EBEventSourceEntry'),
  filterPattern?: string(name='FilterPattern'),
  name?: string(name='Name'),
  targets?: {
    endpoint?: string(name='Endpoint'),
    id?: string(name='Id'),
    paramList?: [ 
      {
        form?: string(name='Form'),
        resourceKey?: string(name='ResourceKey'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }
    ](name='ParamList'),
    pushRetryStrategy?: string(name='PushRetryStrategy'),
    type?: string(name='Type'),
  }(name='Targets'),
}

model SaveAndStartEventStreamingShrinkRequest {
  description?: string(name='Description'),
  EBEventSourceEntryShrink?: string(name='EBEventSourceEntry'),
  filterPattern?: string(name='FilterPattern'),
  name?: string(name='Name'),
  targets?: {
    endpoint?: string(name='Endpoint'),
    id?: string(name='Id'),
    paramList?: [ 
      {
        form?: string(name='Form'),
        resourceKey?: string(name='ResourceKey'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }
    ](name='ParamList'),
    pushRetryStrategy?: string(name='PushRetryStrategy'),
    type?: string(name='Type'),
  }(name='Targets'),
}

model SaveAndStartEventStreamingResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveAndStartEventStreamingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveAndStartEventStreamingResponseBody(name='body'),
}

async function saveAndStartEventStreamingWithOptions(tmpReq: SaveAndStartEventStreamingRequest, runtime: Util.RuntimeOptions): SaveAndStartEventStreamingResponse {
  Util.validateModel(tmpReq);
  var request = new SaveAndStartEventStreamingShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.EBEventSourceEntry)) {
    request.EBEventSourceEntryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.EBEventSourceEntry, 'EBEventSourceEntry', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.EBEventSourceEntryShrink)) {
    body['EBEventSourceEntry'] = request.EBEventSourceEntryShrink;
  }
  if (!Util.isUnset(request.filterPattern)) {
    body['FilterPattern'] = request.filterPattern;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.targets)) {
    bodyFlat['Targets'] = request.targets;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SaveAndStartEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveAndStartEventStreaming(request: SaveAndStartEventStreamingRequest): SaveAndStartEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveAndStartEventStreamingWithOptions(request, runtime);
}

model SaveAndStartSourceTaskRequest {
  busName?: string(name='BusName'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  sourceConfig?: map[string]any(name='SourceConfig'),
  sourceType?: string(name='SourceType'),
}

model SaveAndStartSourceTaskShrinkRequest {
  busName?: string(name='BusName'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  sourceConfigShrink?: string(name='SourceConfig'),
  sourceType?: string(name='SourceType'),
}

model SaveAndStartSourceTaskResponseBody = {
  code?: string(name='Code'),
  data?: {
    taskId?: string(name='TaskId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveAndStartSourceTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveAndStartSourceTaskResponseBody(name='body'),
}

async function saveAndStartSourceTaskWithOptions(tmpReq: SaveAndStartSourceTaskRequest, runtime: Util.RuntimeOptions): SaveAndStartSourceTaskResponse {
  Util.validateModel(tmpReq);
  var request = new SaveAndStartSourceTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.sourceConfig)) {
    request.sourceConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceConfig, 'SourceConfig', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.busName)) {
    body['BusName'] = request.busName;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.sourceConfigShrink)) {
    body['SourceConfig'] = request.sourceConfigShrink;
  }
  if (!Util.isUnset(request.sourceType)) {
    body['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SaveAndStartSourceTask',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveAndStartSourceTask(request: SaveAndStartSourceTaskRequest): SaveAndStartSourceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveAndStartSourceTaskWithOptions(request, runtime);
}

model StartEventStreamingRequest {
  eventStreamingName?: string(name='EventStreamingName'),
}

model StartEventStreamingResponseBody = {
  code?: boolean(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StartEventStreamingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartEventStreamingResponseBody(name='body'),
}

async function startEventStreamingWithOptions(request: StartEventStreamingRequest, runtime: Util.RuntimeOptions): StartEventStreamingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startEventStreaming(request: StartEventStreamingRequest): StartEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return startEventStreamingWithOptions(request, runtime);
}

model StartSourceTaskRequest {
  taskId?: string(name='TaskId'),
}

model StartSourceTaskResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StartSourceTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartSourceTaskResponseBody(name='body'),
}

async function startSourceTaskWithOptions(request: StartSourceTaskRequest, runtime: Util.RuntimeOptions): StartSourceTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartSourceTask',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startSourceTask(request: StartSourceTaskRequest): StartSourceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return startSourceTaskWithOptions(request, runtime);
}

model UpdateEventBusRequest {
  description?: string(name='Description'),
  eventBusName?: string(name='EventBusName'),
}

model UpdateEventBusResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateEventBusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEventBusResponseBody(name='body'),
}

async function updateEventBusWithOptions(request: UpdateEventBusRequest, runtime: Util.RuntimeOptions): UpdateEventBusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEventBus',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateEventBus(request: UpdateEventBusRequest): UpdateEventBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEventBusWithOptions(request, runtime);
}

model UpdateEventSourceRequest {
  description?: bytes(name='Description', description='事件源描述详情'),
  eventBusName?: bytes(name='EventBusName'),
  eventSourceName?: bytes(name='EventSourceName', description='事件源英文Code'),
  externalSourceConfig?: map[string]any(name='ExternalSourceConfig'),
  externalSourceType?: bytes(name='ExternalSourceType'),
  linkedExternalSource?: boolean(name='LinkedExternalSource'),
}

model UpdateEventSourceShrinkRequest {
  description?: bytes(name='Description', description='事件源描述详情'),
  eventBusName?: bytes(name='EventBusName'),
  eventSourceName?: bytes(name='EventSourceName', description='事件源英文Code'),
  externalSourceConfigShrink?: string(name='ExternalSourceConfig'),
  externalSourceType?: bytes(name='ExternalSourceType'),
  linkedExternalSource?: boolean(name='LinkedExternalSource'),
}

model UpdateEventSourceResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateEventSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEventSourceResponseBody(name='body'),
}

async function updateEventSourceWithOptions(tmpReq: UpdateEventSourceRequest, runtime: Util.RuntimeOptions): UpdateEventSourceResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateEventSourceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.externalSourceConfig)) {
    request.externalSourceConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.externalSourceConfig, 'ExternalSourceConfig', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    body['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.eventSourceName)) {
    body['EventSourceName'] = request.eventSourceName;
  }
  if (!Util.isUnset(request.externalSourceConfigShrink)) {
    body['ExternalSourceConfig'] = request.externalSourceConfigShrink;
  }
  if (!Util.isUnset(request.externalSourceType)) {
    body['ExternalSourceType'] = request.externalSourceType;
  }
  if (!Util.isUnset(request.linkedExternalSource)) {
    body['LinkedExternalSource'] = request.linkedExternalSource;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEventSource',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateEventSource(request: UpdateEventSourceRequest): UpdateEventSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEventSourceWithOptions(request, runtime);
}

model UpdateEventStreamingRequest {
  description?: string(name='Description'),
  eventStreamingName?: string(name='EventStreamingName'),
  filterPattern?: string(name='FilterPattern'),
  runOptions?: {
    batchWindow?: {
      countBasedWindow?: int32(name='CountBasedWindow'),
      timeBasedWindow?: int32(name='TimeBasedWindow'),
    }(name='BatchWindow'),
    deadLetterQueue?: {
      arn?: string(name='Arn'),
    }(name='DeadLetterQueue'),
    errorsTolerance?: string(name='ErrorsTolerance'),
    maximumTasks?: long(name='MaximumTasks'),
    retryStrategy?: {
      maximumEventAgeInSeconds?: long(name='MaximumEventAgeInSeconds'),
      maximumRetryAttempts?: long(name='MaximumRetryAttempts'),
      pushRetryStrategy?: string(name='PushRetryStrategy'),
    }(name='RetryStrategy'),
  }(name='RunOptions'),
  sink?: {
    sinkFcParameters?: {
      body?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Body'),
      functionName?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='FunctionName'),
      invocationType?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='InvocationType'),
      qualifier?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Qualifier'),
      serviceName?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='ServiceName'),
    }(name='SinkFcParameters'),
    sinkKafkaParameters?: {
      acks?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Acks'),
      instanceId?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='InstanceId'),
      key?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Key'),
      saslUser?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='SaslUser'),
      topic?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Topic'),
      value?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Value'),
    }(name='SinkKafkaParameters'),
    sinkMNSParameters?: {
      body?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Body'),
      isBase64Encode?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='IsBase64Encode'),
      queueName?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='QueueName'),
    }(name='SinkMNSParameters'),
    sinkRabbitMQParameters?: {
      body?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Body'),
      exchange?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Exchange'),
      instanceId?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='InstanceId'),
      messageId?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='MessageId'),
      properties?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Properties'),
      queueName?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='QueueName'),
      routingKey?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='RoutingKey'),
      targetType?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='TargetType'),
      virtualHostName?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='VirtualHostName'),
    }(name='SinkRabbitMQParameters'),
    sinkRocketMQParameters?: {
      body?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Body'),
      instanceId?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='InstanceId'),
      keys?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Keys'),
      properties?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Properties'),
      tags?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Tags'),
      topic?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Topic'),
    }(name='SinkRocketMQParameters'),
    sinkSLSParameters?: {
      body?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Body'),
      logStore?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='LogStore'),
      project?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Project'),
      roleName?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='RoleName'),
      topic?: {
        form?: string(name='Form'),
        template?: string(name='Template'),
        value?: string(name='Value'),
      }(name='Topic'),
    }(name='SinkSLSParameters'),
  }(name='Sink'),
  source?: {
    sourceDTSParameters?: {
      brokerUrl?: string(name='BrokerUrl'),
      initCheckPoint?: long(name='InitCheckPoint'),
      password?: string(name='Password'),
      sid?: string(name='Sid'),
      taskId?: string(name='TaskId'),
      topic?: string(name='Topic'),
      username?: string(name='Username'),
    }(name='SourceDTSParameters'),
    sourceKafkaParameters?: {
      consumerGroup?: string(name='ConsumerGroup'),
      instanceId?: string(name='InstanceId'),
      network?: string(name='Network'),
      offsetReset?: string(name='OffsetReset'),
      regionId?: string(name='RegionId'),
      securityGroupId?: string(name='SecurityGroupId'),
      topic?: string(name='Topic'),
      vSwitchIds?: string(name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
    }(name='SourceKafkaParameters'),
    sourceMNSParameters?: {
      isBase64Decode?: boolean(name='IsBase64Decode'),
      queueName?: string(name='QueueName'),
      regionId?: string(name='RegionId'),
    }(name='SourceMNSParameters'),
    sourceMQTTParameters?: {
      instanceId?: string(name='InstanceId'),
      regionId?: string(name='RegionId'),
      topic?: string(name='Topic'),
    }(name='SourceMQTTParameters'),
    sourceRabbitMQParameters?: {
      instanceId?: string(name='InstanceId'),
      queueName?: string(name='QueueName'),
      regionId?: string(name='RegionId'),
      virtualHostName?: string(name='VirtualHostName'),
    }(name='SourceRabbitMQParameters'),
    sourceRocketMQParameters?: {
      groupID?: string(name='GroupID'),
      instanceId?: string(name='InstanceId'),
      offset?: string(name='Offset'),
      regionId?: string(name='RegionId'),
      tag?: string(name='Tag'),
      timestamp?: long(name='Timestamp'),
      topic?: string(name='Topic'),
    }(name='SourceRocketMQParameters'),
    sourceSLSParameters?: {
      roleName?: string(name='RoleName'),
    }(name='SourceSLSParameters'),
  }(name='Source'),
  tag?: string(name='Tag'),
}

model UpdateEventStreamingShrinkRequest {
  description?: string(name='Description'),
  eventStreamingName?: string(name='EventStreamingName'),
  filterPattern?: string(name='FilterPattern'),
  runOptionsShrink?: string(name='RunOptions'),
  sinkShrink?: string(name='Sink'),
  sourceShrink?: string(name='Source'),
  tag?: string(name='Tag'),
}

model UpdateEventStreamingResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateEventStreamingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEventStreamingResponseBody(name='body'),
}

async function updateEventStreamingWithOptions(tmpReq: UpdateEventStreamingRequest, runtime: Util.RuntimeOptions): UpdateEventStreamingResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateEventStreamingShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.runOptions)) {
    request.runOptionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.runOptions, 'RunOptions', 'json');
  }
  if (!Util.isUnset(tmpReq.sink)) {
    request.sinkShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sink, 'Sink', 'json');
  }
  if (!Util.isUnset(tmpReq.source)) {
    request.sourceShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.source, 'Source', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventStreamingName)) {
    body['EventStreamingName'] = request.eventStreamingName;
  }
  if (!Util.isUnset(request.filterPattern)) {
    body['FilterPattern'] = request.filterPattern;
  }
  if (!Util.isUnset(request.runOptionsShrink)) {
    body['RunOptions'] = request.runOptionsShrink;
  }
  if (!Util.isUnset(request.sinkShrink)) {
    body['Sink'] = request.sinkShrink;
  }
  if (!Util.isUnset(request.sourceShrink)) {
    body['Source'] = request.sourceShrink;
  }
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEventStreaming',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateEventStreaming(request: UpdateEventStreamingRequest): UpdateEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEventStreamingWithOptions(request, runtime);
}

model UpdateRuleRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  eventBusName?: string(name='EventBusName'),
  filterPattern?: string(name='FilterPattern'),
  ruleName?: string(name='RuleName'),
  status?: string(name='Status'),
}

model UpdateRuleResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRuleResponseBody(name='body'),
}

async function updateRuleWithOptions(request: UpdateRuleRequest, runtime: Util.RuntimeOptions): UpdateRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.filterPattern)) {
    query['FilterPattern'] = request.filterPattern;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRule',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRule(request: UpdateRuleRequest): UpdateRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRuleWithOptions(request, runtime);
}

model UpdateSchemaRequest {
  clientToken?: string(name='ClientToken'),
  compatibleType?: string(name='CompatibleType', description='Schema处理版本兼容性的策略'),
  description?: string(name='Description', description='Schema描述信息'),
  groupId?: string(name='GroupId', description='Schema所属注册表'),
  schemaId?: string(name='SchemaId', description='Schema标识'),
}

model UpdateSchemaResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdTimestamp?: long(name='CreatedTimestamp'),
    groupARN?: string(name='GroupARN'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSchemaResponseBody(name='body'),
}

async function updateSchemaWithOptions(request: UpdateSchemaRequest, runtime: Util.RuntimeOptions): UpdateSchemaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.compatibleType)) {
    query['CompatibleType'] = request.compatibleType;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.schemaId)) {
    query['SchemaId'] = request.schemaId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSchema',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSchema(request: UpdateSchemaRequest): UpdateSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSchemaWithOptions(request, runtime);
}

model UpdateSchemaGroupRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description', description='代表分组内Schema的格式类型'),
  groupId?: string(name='GroupId', description='代表资源一级ID的资源属性字段'),
}

model UpdateSchemaGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    updatedTimestamp?: long(name='UpdatedTimestamp'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSchemaGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSchemaGroupResponseBody(name='body'),
}

async function updateSchemaGroupWithOptions(request: UpdateSchemaGroupRequest, runtime: Util.RuntimeOptions): UpdateSchemaGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSchemaGroup',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSchemaGroup(request: UpdateSchemaGroupRequest): UpdateSchemaGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSchemaGroupWithOptions(request, runtime);
}

model UpdateSchemaVersionRequest {
  clientToken?: string(name='ClientToken'),
  groupId?: string(name='GroupId'),
  schemaId?: string(name='SchemaId'),
  versionNumber?: string(name='VersionNumber'),
}

model UpdateSchemaVersionResponseBody = {
  code?: string(name='Code'),
  data?: {
    schemaVersionARN?: string(name='SchemaVersionARN'),
    updatedTimestamp?: long(name='UpdatedTimestamp'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSchemaVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSchemaVersionResponseBody(name='body'),
}

async function updateSchemaVersionWithOptions(request: UpdateSchemaVersionRequest, runtime: Util.RuntimeOptions): UpdateSchemaVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.schemaId)) {
    query['SchemaId'] = request.schemaId;
  }
  if (!Util.isUnset(request.versionNumber)) {
    query['VersionNumber'] = request.versionNumber;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSchemaVersion',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSchemaVersion(request: UpdateSchemaVersionRequest): UpdateSchemaVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSchemaVersionWithOptions(request, runtime);
}

model UpdateTargetsRequest {
  clientToken?: string(name='ClientToken'),
  eventBusName?: string(name='EventBusName'),
  ruleName?: string(name='RuleName'),
  targets?: map[string]any(name='Targets'),
}

model UpdateTargetsShrinkRequest {
  clientToken?: string(name='ClientToken'),
  eventBusName?: string(name='EventBusName'),
  ruleName?: string(name='RuleName'),
  targetsShrink?: string(name='Targets'),
}

model UpdateTargetsResponseBody = {
  code?: string(name='Code'),
  data?: {
    errorEntries?: [ 
      {
        entryId?: string(name='EntryId'),
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
      }
    ](name='ErrorEntries'),
    errorEntriesCount?: int32(name='ErrorEntriesCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateTargetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTargetsResponseBody(name='body'),
}

async function updateTargetsWithOptions(tmpReq: UpdateTargetsRequest, runtime: Util.RuntimeOptions): UpdateTargetsResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateTargetsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.targets)) {
    request.targetsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.targets, 'Targets', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.eventBusName)) {
    query['EventBusName'] = request.eventBusName;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.targetsShrink)) {
    query['Targets'] = request.targetsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTargets',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTargets(request: UpdateTargetsRequest): UpdateTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTargetsWithOptions(request, runtime);
}

model VerifyRequest {
  data?: string(name='Data'),
}

model VerifyResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  synchro?: string(name='Synchro'),
}

model VerifyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyResponseBody(name='body'),
}

async function verifyWithOptions(request: VerifyRequest, runtime: Util.RuntimeOptions): VerifyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Verify',
    version = '2020-04-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verify(request: VerifyRequest): VerifyResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyWithOptions(request, runtime);
}

