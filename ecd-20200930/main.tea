/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('ecd', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ActivateOfficeSiteRequest {
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model ActivateOfficeSiteResponseBody = {
  requestId?: string(name='RequestId'),
}

model ActivateOfficeSiteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ActivateOfficeSiteResponseBody(name='body'),
}

async function activateOfficeSiteWithOptions(request: ActivateOfficeSiteRequest, runtime: Util.RuntimeOptions): ActivateOfficeSiteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ActivateOfficeSite',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function activateOfficeSite(request: ActivateOfficeSiteRequest): ActivateOfficeSiteResponse {
  var runtime = new Util.RuntimeOptions{};
  return activateOfficeSiteWithOptions(request, runtime);
}

model AddUserToDesktopGroupRequest {
  clientToken?: string(name='ClientToken'),
  desktopGroupId?: string(name='DesktopGroupId'),
  desktopGroupIds?: [ string ](name='DesktopGroupIds'),
  endUserIds?: [ string ](name='EndUserIds'),
  regionId?: string(name='RegionId'),
}

model AddUserToDesktopGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddUserToDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddUserToDesktopGroupResponseBody(name='body'),
}

async function addUserToDesktopGroupWithOptions(request: AddUserToDesktopGroupRequest, runtime: Util.RuntimeOptions): AddUserToDesktopGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.desktopGroupId)) {
    query['DesktopGroupId'] = request.desktopGroupId;
  }
  if (!Util.isUnset(request.desktopGroupIds)) {
    query['DesktopGroupIds'] = request.desktopGroupIds;
  }
  if (!Util.isUnset(request.endUserIds)) {
    query['EndUserIds'] = request.endUserIds;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddUserToDesktopGroup',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addUserToDesktopGroup(request: AddUserToDesktopGroupRequest): AddUserToDesktopGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUserToDesktopGroupWithOptions(request, runtime);
}

model ApplyCoordinatePrivilegeRequest {
  coId?: string(name='CoId'),
  endUserId?: string(name='EndUserId'),
  regionId?: string(name='RegionId'),
  userType?: string(name='UserType'),
  uuid?: string(name='Uuid'),
}

model ApplyCoordinatePrivilegeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ApplyCoordinatePrivilegeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyCoordinatePrivilegeResponseBody(name='body'),
}

async function applyCoordinatePrivilegeWithOptions(request: ApplyCoordinatePrivilegeRequest, runtime: Util.RuntimeOptions): ApplyCoordinatePrivilegeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.coId)) {
    query['CoId'] = request.coId;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userType)) {
    query['UserType'] = request.userType;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyCoordinatePrivilege',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyCoordinatePrivilege(request: ApplyCoordinatePrivilegeRequest): ApplyCoordinatePrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyCoordinatePrivilegeWithOptions(request, runtime);
}

model ApplyCoordinationForMonitoringRequest {
  coordinatePolicyType?: string(name='CoordinatePolicyType'),
  endUserId?: string(name='EndUserId'),
  initiatorType?: string(name='InitiatorType'),
  regionId?: string(name='RegionId'),
  resourceCandidates?: [ 
    {
      ownerAliUid?: long(name='OwnerAliUid'),
      ownerEndUserId?: string(name='OwnerEndUserId'),
      resourceId?: string(name='ResourceId'),
      resourceName?: string(name='ResourceName'),
      resourceProperties?: string(name='ResourceProperties'),
      resourceRegionId?: string(name='ResourceRegionId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='ResourceCandidates'),
  uuid?: string(name='Uuid'),
}

model ApplyCoordinationForMonitoringResponseBody = {
  coordinateFlowModels?: [ 
    {
      coId?: string(name='CoId'),
      coordinateStatus?: string(name='CoordinateStatus'),
      coordinateTicket?: string(name='CoordinateTicket'),
      initiatorType?: string(name='InitiatorType'),
      ownerUserId?: string(name='OwnerUserId'),
      resourceId?: string(name='ResourceId'),
      resourceName?: string(name='ResourceName'),
    }
  ](name='CoordinateFlowModels'),
  requestId?: string(name='RequestId'),
}

model ApplyCoordinationForMonitoringResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyCoordinationForMonitoringResponseBody(name='body'),
}

async function applyCoordinationForMonitoringWithOptions(request: ApplyCoordinationForMonitoringRequest, runtime: Util.RuntimeOptions): ApplyCoordinationForMonitoringResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.coordinatePolicyType)) {
    query['CoordinatePolicyType'] = request.coordinatePolicyType;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.initiatorType)) {
    query['InitiatorType'] = request.initiatorType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceCandidates)) {
    query['ResourceCandidates'] = request.resourceCandidates;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyCoordinationForMonitoring',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyCoordinationForMonitoring(request: ApplyCoordinationForMonitoringRequest): ApplyCoordinationForMonitoringResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyCoordinationForMonitoringWithOptions(request, runtime);
}

model ApproveFotaUpdateRequest {
  appVersion?: string(name='AppVersion'),
  desktopId?: string(name='DesktopId'),
  regionId?: string(name='RegionId'),
}

model ApproveFotaUpdateResponseBody = {
  requestId?: string(name='RequestId'),
}

model ApproveFotaUpdateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApproveFotaUpdateResponseBody(name='body'),
}

async function approveFotaUpdateWithOptions(request: ApproveFotaUpdateRequest, runtime: Util.RuntimeOptions): ApproveFotaUpdateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApproveFotaUpdate',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function approveFotaUpdate(request: ApproveFotaUpdateRequest): ApproveFotaUpdateResponse {
  var runtime = new Util.RuntimeOptions{};
  return approveFotaUpdateWithOptions(request, runtime);
}

model AssociateNetworkPackageRequest {
  networkPackageId?: string(name='NetworkPackageId'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model AssociateNetworkPackageResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateNetworkPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateNetworkPackageResponseBody(name='body'),
}

async function associateNetworkPackageWithOptions(request: AssociateNetworkPackageRequest, runtime: Util.RuntimeOptions): AssociateNetworkPackageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.networkPackageId)) {
    query['NetworkPackageId'] = request.networkPackageId;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateNetworkPackage',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateNetworkPackage(request: AssociateNetworkPackageRequest): AssociateNetworkPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateNetworkPackageWithOptions(request, runtime);
}

model AttachCenRequest {
  cenId?: string(name='CenId'),
  cenOwnerId?: long(name='CenOwnerId'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
  verifyCode?: string(name='VerifyCode'),
}

model AttachCenResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachCenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachCenResponseBody(name='body'),
}

async function attachCenWithOptions(request: AttachCenRequest, runtime: Util.RuntimeOptions): AttachCenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cenId)) {
    query['CenId'] = request.cenId;
  }
  if (!Util.isUnset(request.cenOwnerId)) {
    query['CenOwnerId'] = request.cenOwnerId;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.verifyCode)) {
    query['VerifyCode'] = request.verifyCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachCen',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachCen(request: AttachCenRequest): AttachCenResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachCenWithOptions(request, runtime);
}

model CancelCoordinationForMonitoringRequest {
  coIds?: [ string ](name='CoIds'),
  endUserId?: string(name='EndUserId'),
  regionId?: string(name='RegionId'),
  userType?: string(name='UserType'),
}

model CancelCoordinationForMonitoringResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelCoordinationForMonitoringResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelCoordinationForMonitoringResponseBody(name='body'),
}

async function cancelCoordinationForMonitoringWithOptions(request: CancelCoordinationForMonitoringRequest, runtime: Util.RuntimeOptions): CancelCoordinationForMonitoringResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.coIds)) {
    query['CoIds'] = request.coIds;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userType)) {
    query['UserType'] = request.userType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelCoordinationForMonitoring',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelCoordinationForMonitoring(request: CancelCoordinationForMonitoringRequest): CancelCoordinationForMonitoringResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelCoordinationForMonitoringWithOptions(request, runtime);
}

model CancelCopyImageRequest {
  imageId?: string(name='ImageId'),
  regionId?: string(name='RegionId'),
}

model CancelCopyImageResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelCopyImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelCopyImageResponseBody(name='body'),
}

async function cancelCopyImageWithOptions(request: CancelCopyImageRequest, runtime: Util.RuntimeOptions): CancelCopyImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelCopyImage',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelCopyImage(request: CancelCopyImageRequest): CancelCopyImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelCopyImageWithOptions(request, runtime);
}

model ClonePolicyGroupRequest {
  name?: string(name='Name'),
  policyGroupId?: string(name='PolicyGroupId'),
  regionId?: string(name='RegionId'),
}

model ClonePolicyGroupResponseBody = {
  policyGroupId?: string(name='PolicyGroupId'),
  requestId?: string(name='RequestId'),
}

model ClonePolicyGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ClonePolicyGroupResponseBody(name='body'),
}

async function clonePolicyGroupWithOptions(request: ClonePolicyGroupRequest, runtime: Util.RuntimeOptions): ClonePolicyGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.policyGroupId)) {
    query['PolicyGroupId'] = request.policyGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ClonePolicyGroup',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function clonePolicyGroup(request: ClonePolicyGroupRequest): ClonePolicyGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return clonePolicyGroupWithOptions(request, runtime);
}

model ConfigADConnectorTrustRequest {
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
  trustKey?: string(name='TrustKey'),
}

model ConfigADConnectorTrustResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigADConnectorTrustResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfigADConnectorTrustResponseBody(name='body'),
}

async function configADConnectorTrustWithOptions(request: ConfigADConnectorTrustRequest, runtime: Util.RuntimeOptions): ConfigADConnectorTrustResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.trustKey)) {
    query['TrustKey'] = request.trustKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfigADConnectorTrust',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function configADConnectorTrust(request: ConfigADConnectorTrustRequest): ConfigADConnectorTrustResponse {
  var runtime = new Util.RuntimeOptions{};
  return configADConnectorTrustWithOptions(request, runtime);
}

model ConfigADConnectorUserRequest {
  domainPassword?: string(name='DomainPassword'),
  domainUserName?: string(name='DomainUserName'),
  OUName?: string(name='OUName'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model ConfigADConnectorUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigADConnectorUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfigADConnectorUserResponseBody(name='body'),
}

async function configADConnectorUserWithOptions(request: ConfigADConnectorUserRequest, runtime: Util.RuntimeOptions): ConfigADConnectorUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainPassword)) {
    query['DomainPassword'] = request.domainPassword;
  }
  if (!Util.isUnset(request.domainUserName)) {
    query['DomainUserName'] = request.domainUserName;
  }
  if (!Util.isUnset(request.OUName)) {
    query['OUName'] = request.OUName;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfigADConnectorUser',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function configADConnectorUser(request: ConfigADConnectorUserRequest): ConfigADConnectorUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return configADConnectorUserWithOptions(request, runtime);
}

model CopyImageRequest {
  destinationDescription?: string(name='DestinationDescription'),
  destinationImageName?: string(name='DestinationImageName'),
  destinationRegionId?: string(name='DestinationRegionId'),
  imageId?: string(name='ImageId'),
  regionId?: string(name='RegionId'),
}

model CopyImageResponseBody = {
  imageId?: string(name='ImageId'),
  requestId?: string(name='RequestId'),
}

model CopyImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CopyImageResponseBody(name='body'),
}

async function copyImageWithOptions(request: CopyImageRequest, runtime: Util.RuntimeOptions): CopyImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.destinationDescription)) {
    query['DestinationDescription'] = request.destinationDescription;
  }
  if (!Util.isUnset(request.destinationImageName)) {
    query['DestinationImageName'] = request.destinationImageName;
  }
  if (!Util.isUnset(request.destinationRegionId)) {
    query['DestinationRegionId'] = request.destinationRegionId;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CopyImage',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function copyImage(request: CopyImageRequest): CopyImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyImageWithOptions(request, runtime);
}

model CreateADConnectorDirectoryRequest {
  desktopAccessType?: string(name='DesktopAccessType'),
  directoryName?: string(name='DirectoryName'),
  dnsAddress?: [ string ](name='DnsAddress'),
  domainName?: string(name='DomainName'),
  domainPassword?: string(name='DomainPassword'),
  domainUserName?: string(name='DomainUserName'),
  enableAdminAccess?: boolean(name='EnableAdminAccess'),
  mfaEnabled?: boolean(name='MfaEnabled'),
  regionId?: string(name='RegionId'),
  specification?: long(name='Specification'),
  subDomainDnsAddress?: [ string ](name='SubDomainDnsAddress'),
  subDomainName?: string(name='SubDomainName'),
  vSwitchId?: [ string ](name='VSwitchId'),
}

model CreateADConnectorDirectoryResponseBody = {
  adConnectors?: [ 
    {
      address?: string(name='Address'),
    }
  ](name='AdConnectors'),
  directoryId?: string(name='DirectoryId'),
  requestId?: string(name='RequestId'),
  trustPassword?: string(name='TrustPassword'),
}

model CreateADConnectorDirectoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateADConnectorDirectoryResponseBody(name='body'),
}

async function createADConnectorDirectoryWithOptions(request: CreateADConnectorDirectoryRequest, runtime: Util.RuntimeOptions): CreateADConnectorDirectoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopAccessType)) {
    query['DesktopAccessType'] = request.desktopAccessType;
  }
  if (!Util.isUnset(request.directoryName)) {
    query['DirectoryName'] = request.directoryName;
  }
  if (!Util.isUnset(request.dnsAddress)) {
    query['DnsAddress'] = request.dnsAddress;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainPassword)) {
    query['DomainPassword'] = request.domainPassword;
  }
  if (!Util.isUnset(request.domainUserName)) {
    query['DomainUserName'] = request.domainUserName;
  }
  if (!Util.isUnset(request.enableAdminAccess)) {
    query['EnableAdminAccess'] = request.enableAdminAccess;
  }
  if (!Util.isUnset(request.mfaEnabled)) {
    query['MfaEnabled'] = request.mfaEnabled;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.specification)) {
    query['Specification'] = request.specification;
  }
  if (!Util.isUnset(request.subDomainDnsAddress)) {
    query['SubDomainDnsAddress'] = request.subDomainDnsAddress;
  }
  if (!Util.isUnset(request.subDomainName)) {
    query['SubDomainName'] = request.subDomainName;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateADConnectorDirectory',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createADConnectorDirectory(request: CreateADConnectorDirectoryRequest): CreateADConnectorDirectoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createADConnectorDirectoryWithOptions(request, runtime);
}

model CreateADConnectorOfficeSiteRequest {
  adHostname?: string(name='AdHostname'),
  bandwidth?: int32(name='Bandwidth'),
  cenId?: string(name='CenId'),
  cenOwnerId?: long(name='CenOwnerId'),
  cidrBlock?: string(name='CidrBlock'),
  desktopAccessType?: string(name='DesktopAccessType'),
  dnsAddress?: [ string ](name='DnsAddress'),
  domainName?: string(name='DomainName'),
  domainPassword?: string(name='DomainPassword'),
  domainUserName?: string(name='DomainUserName'),
  enableAdminAccess?: boolean(name='EnableAdminAccess'),
  enableInternetAccess?: boolean(name='EnableInternetAccess'),
  mfaEnabled?: boolean(name='MfaEnabled'),
  officeSiteName?: string(name='OfficeSiteName'),
  protocolType?: string(name='ProtocolType'),
  regionId?: string(name='RegionId'),
  specification?: long(name='Specification'),
  subDomainDnsAddress?: [ string ](name='SubDomainDnsAddress'),
  subDomainName?: string(name='SubDomainName'),
  verifyCode?: string(name='VerifyCode'),
}

model CreateADConnectorOfficeSiteResponseBody = {
  officeSiteId?: string(name='OfficeSiteId'),
  requestId?: string(name='RequestId'),
}

model CreateADConnectorOfficeSiteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateADConnectorOfficeSiteResponseBody(name='body'),
}

async function createADConnectorOfficeSiteWithOptions(request: CreateADConnectorOfficeSiteRequest, runtime: Util.RuntimeOptions): CreateADConnectorOfficeSiteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.adHostname)) {
    query['AdHostname'] = request.adHostname;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.cenId)) {
    query['CenId'] = request.cenId;
  }
  if (!Util.isUnset(request.cenOwnerId)) {
    query['CenOwnerId'] = request.cenOwnerId;
  }
  if (!Util.isUnset(request.cidrBlock)) {
    query['CidrBlock'] = request.cidrBlock;
  }
  if (!Util.isUnset(request.desktopAccessType)) {
    query['DesktopAccessType'] = request.desktopAccessType;
  }
  if (!Util.isUnset(request.dnsAddress)) {
    query['DnsAddress'] = request.dnsAddress;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainPassword)) {
    query['DomainPassword'] = request.domainPassword;
  }
  if (!Util.isUnset(request.domainUserName)) {
    query['DomainUserName'] = request.domainUserName;
  }
  if (!Util.isUnset(request.enableAdminAccess)) {
    query['EnableAdminAccess'] = request.enableAdminAccess;
  }
  if (!Util.isUnset(request.enableInternetAccess)) {
    query['EnableInternetAccess'] = request.enableInternetAccess;
  }
  if (!Util.isUnset(request.mfaEnabled)) {
    query['MfaEnabled'] = request.mfaEnabled;
  }
  if (!Util.isUnset(request.officeSiteName)) {
    query['OfficeSiteName'] = request.officeSiteName;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.specification)) {
    query['Specification'] = request.specification;
  }
  if (!Util.isUnset(request.subDomainDnsAddress)) {
    query['SubDomainDnsAddress'] = request.subDomainDnsAddress;
  }
  if (!Util.isUnset(request.subDomainName)) {
    query['SubDomainName'] = request.subDomainName;
  }
  if (!Util.isUnset(request.verifyCode)) {
    query['VerifyCode'] = request.verifyCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateADConnectorOfficeSite',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createADConnectorOfficeSite(request: CreateADConnectorOfficeSiteRequest): CreateADConnectorOfficeSiteResponse {
  var runtime = new Util.RuntimeOptions{};
  return createADConnectorOfficeSiteWithOptions(request, runtime);
}

model CreateAndBindNasFileSystemRequest {
  description?: string(name='Description'),
  desktopGroupId?: string(name='DesktopGroupId'),
  encryptType?: int32(name='EncryptType'),
  endUserIds?: [ string ](name='EndUserIds'),
  fileSystemName?: string(name='FileSystemName'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
  storageType?: string(name='StorageType'),
}

model CreateAndBindNasFileSystemResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateAndBindNasFileSystemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAndBindNasFileSystemResponseBody(name='body'),
}

async function createAndBindNasFileSystemWithOptions(request: CreateAndBindNasFileSystemRequest, runtime: Util.RuntimeOptions): CreateAndBindNasFileSystemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.desktopGroupId)) {
    query['DesktopGroupId'] = request.desktopGroupId;
  }
  if (!Util.isUnset(request.encryptType)) {
    query['EncryptType'] = request.encryptType;
  }
  if (!Util.isUnset(request.endUserIds)) {
    query['EndUserIds'] = request.endUserIds;
  }
  if (!Util.isUnset(request.fileSystemName)) {
    query['FileSystemName'] = request.fileSystemName;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAndBindNasFileSystem',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAndBindNasFileSystem(request: CreateAndBindNasFileSystemRequest): CreateAndBindNasFileSystemResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAndBindNasFileSystemWithOptions(request, runtime);
}

model CreateBundleRequest {
  bundleName?: string(name='BundleName'),
  description?: string(name='Description'),
  desktopType?: string(name='DesktopType'),
  imageId?: string(name='ImageId'),
  language?: string(name='Language'),
  regionId?: string(name='RegionId'),
  rootDiskPerformanceLevel?: string(name='RootDiskPerformanceLevel'),
  rootDiskSizeGib?: int32(name='RootDiskSizeGib'),
  userDiskPerformanceLevel?: string(name='UserDiskPerformanceLevel'),
  userDiskSizeGib?: [ int32 ](name='UserDiskSizeGib'),
}

model CreateBundleResponseBody = {
  bundleId?: string(name='BundleId'),
  requestId?: string(name='RequestId'),
}

model CreateBundleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBundleResponseBody(name='body'),
}

async function createBundleWithOptions(request: CreateBundleRequest, runtime: Util.RuntimeOptions): CreateBundleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bundleName)) {
    query['BundleName'] = request.bundleName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.desktopType)) {
    query['DesktopType'] = request.desktopType;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.language)) {
    query['Language'] = request.language;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.rootDiskPerformanceLevel)) {
    query['RootDiskPerformanceLevel'] = request.rootDiskPerformanceLevel;
  }
  if (!Util.isUnset(request.rootDiskSizeGib)) {
    query['RootDiskSizeGib'] = request.rootDiskSizeGib;
  }
  if (!Util.isUnset(request.userDiskPerformanceLevel)) {
    query['UserDiskPerformanceLevel'] = request.userDiskPerformanceLevel;
  }
  if (!Util.isUnset(request.userDiskSizeGib)) {
    query['UserDiskSizeGib'] = request.userDiskSizeGib;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBundle',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBundle(request: CreateBundleRequest): CreateBundleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBundleWithOptions(request, runtime);
}

model CreateDesktopGroupRequest {
  allClassifyUsers?: boolean(name='AllClassifyUsers'),
  allowAutoSetup?: int32(name='AllowAutoSetup'),
  allowBufferCount?: int32(name='AllowBufferCount'),
  autoPay?: boolean(name='AutoPay'),
  bindAmount?: long(name='BindAmount'),
  bundleId?: string(name='BundleId'),
  chargeType?: string(name='ChargeType'),
  classify?: string(name='Classify'),
  clientToken?: string(name='ClientToken'),
  comments?: string(name='Comments'),
  connectDuration?: long(name='ConnectDuration'),
  defaultInitDesktopCount?: int32(name='DefaultInitDesktopCount'),
  desktopGroupName?: string(name='DesktopGroupName'),
  directoryId?: string(name='DirectoryId'),
  endUserIds?: [ string ](name='EndUserIds'),
  fileSystemId?: string(name='FileSystemId'),
  idleDisconnectDuration?: long(name='IdleDisconnectDuration'),
  keepDuration?: long(name='KeepDuration'),
  loadPolicy?: long(name='LoadPolicy'),
  maxDesktopsCount?: int32(name='MaxDesktopsCount'),
  minDesktopsCount?: int32(name='MinDesktopsCount'),
  officeSiteId?: string(name='OfficeSiteId'),
  ownType?: int32(name='OwnType'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  policyGroupId?: string(name='PolicyGroupId'),
  profileFollowSwitch?: boolean(name='ProfileFollowSwitch'),
  ratioThreshold?: float(name='RatioThreshold'),
  regionId?: string(name='RegionId'),
  resetType?: long(name='ResetType'),
  scaleStrategyId?: string(name='ScaleStrategyId'),
  stopDuration?: long(name='StopDuration'),
  volumeEncryptionEnabled?: boolean(name='VolumeEncryptionEnabled'),
  volumeEncryptionKey?: string(name='VolumeEncryptionKey'),
  vpcId?: string(name='VpcId'),
}

model CreateDesktopGroupResponseBody = {
  desktopGroupId?: string(name='DesktopGroupId'),
  orderIds?: [ string ](name='OrderIds'),
  requestId?: string(name='RequestId'),
}

model CreateDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDesktopGroupResponseBody(name='body'),
}

async function createDesktopGroupWithOptions(request: CreateDesktopGroupRequest, runtime: Util.RuntimeOptions): CreateDesktopGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allClassifyUsers)) {
    query['AllClassifyUsers'] = request.allClassifyUsers;
  }
  if (!Util.isUnset(request.allowAutoSetup)) {
    query['AllowAutoSetup'] = request.allowAutoSetup;
  }
  if (!Util.isUnset(request.allowBufferCount)) {
    query['AllowBufferCount'] = request.allowBufferCount;
  }
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.bindAmount)) {
    query['BindAmount'] = request.bindAmount;
  }
  if (!Util.isUnset(request.bundleId)) {
    query['BundleId'] = request.bundleId;
  }
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.classify)) {
    query['Classify'] = request.classify;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.comments)) {
    query['Comments'] = request.comments;
  }
  if (!Util.isUnset(request.connectDuration)) {
    query['ConnectDuration'] = request.connectDuration;
  }
  if (!Util.isUnset(request.defaultInitDesktopCount)) {
    query['DefaultInitDesktopCount'] = request.defaultInitDesktopCount;
  }
  if (!Util.isUnset(request.desktopGroupName)) {
    query['DesktopGroupName'] = request.desktopGroupName;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.endUserIds)) {
    query['EndUserIds'] = request.endUserIds;
  }
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!Util.isUnset(request.idleDisconnectDuration)) {
    query['IdleDisconnectDuration'] = request.idleDisconnectDuration;
  }
  if (!Util.isUnset(request.keepDuration)) {
    query['KeepDuration'] = request.keepDuration;
  }
  if (!Util.isUnset(request.loadPolicy)) {
    query['LoadPolicy'] = request.loadPolicy;
  }
  if (!Util.isUnset(request.maxDesktopsCount)) {
    query['MaxDesktopsCount'] = request.maxDesktopsCount;
  }
  if (!Util.isUnset(request.minDesktopsCount)) {
    query['MinDesktopsCount'] = request.minDesktopsCount;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.ownType)) {
    query['OwnType'] = request.ownType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.policyGroupId)) {
    query['PolicyGroupId'] = request.policyGroupId;
  }
  if (!Util.isUnset(request.profileFollowSwitch)) {
    query['ProfileFollowSwitch'] = request.profileFollowSwitch;
  }
  if (!Util.isUnset(request.ratioThreshold)) {
    query['RatioThreshold'] = request.ratioThreshold;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resetType)) {
    query['ResetType'] = request.resetType;
  }
  if (!Util.isUnset(request.scaleStrategyId)) {
    query['ScaleStrategyId'] = request.scaleStrategyId;
  }
  if (!Util.isUnset(request.stopDuration)) {
    query['StopDuration'] = request.stopDuration;
  }
  if (!Util.isUnset(request.volumeEncryptionEnabled)) {
    query['VolumeEncryptionEnabled'] = request.volumeEncryptionEnabled;
  }
  if (!Util.isUnset(request.volumeEncryptionKey)) {
    query['VolumeEncryptionKey'] = request.volumeEncryptionKey;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDesktopGroup',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDesktopGroup(request: CreateDesktopGroupRequest): CreateDesktopGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDesktopGroupWithOptions(request, runtime);
}

model CreateDesktopsRequest {
  amount?: int32(name='Amount'),
  autoPay?: boolean(name='AutoPay'),
  autoRenew?: boolean(name='AutoRenew'),
  bundleId?: string(name='BundleId'),
  chargeType?: string(name='ChargeType'),
  desktopName?: string(name='DesktopName'),
  desktopNameSuffix?: boolean(name='DesktopNameSuffix'),
  directoryId?: string(name='DirectoryId'),
  endUserId?: [ string ](name='EndUserId'),
  groupId?: string(name='GroupId'),
  hostname?: string(name='Hostname'),
  officeSiteId?: string(name='OfficeSiteId'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  policyGroupId?: string(name='PolicyGroupId'),
  promotionId?: string(name='PromotionId'),
  regionId?: string(name='RegionId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  userAssignMode?: string(name='UserAssignMode'),
  userCommands?: [ 
    {
      content?: string(name='Content'),
      contentEncoding?: string(name='ContentEncoding'),
      contentType?: string(name='ContentType'),
    }
  ](name='UserCommands'),
  userName?: string(name='UserName'),
  volumeEncryptionEnabled?: boolean(name='VolumeEncryptionEnabled'),
  volumeEncryptionKey?: string(name='VolumeEncryptionKey'),
  vpcId?: string(name='VpcId'),
}

model CreateDesktopsResponseBody = {
  desktopId?: [ string ](name='DesktopId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateDesktopsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDesktopsResponseBody(name='body'),
}

async function createDesktopsWithOptions(request: CreateDesktopsRequest, runtime: Util.RuntimeOptions): CreateDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.amount)) {
    query['Amount'] = request.amount;
  }
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.bundleId)) {
    query['BundleId'] = request.bundleId;
  }
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.desktopName)) {
    query['DesktopName'] = request.desktopName;
  }
  if (!Util.isUnset(request.desktopNameSuffix)) {
    query['DesktopNameSuffix'] = request.desktopNameSuffix;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.hostname)) {
    query['Hostname'] = request.hostname;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.policyGroupId)) {
    query['PolicyGroupId'] = request.policyGroupId;
  }
  if (!Util.isUnset(request.promotionId)) {
    query['PromotionId'] = request.promotionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.userAssignMode)) {
    query['UserAssignMode'] = request.userAssignMode;
  }
  if (!Util.isUnset(request.userCommands)) {
    query['UserCommands'] = request.userCommands;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.volumeEncryptionEnabled)) {
    query['VolumeEncryptionEnabled'] = request.volumeEncryptionEnabled;
  }
  if (!Util.isUnset(request.volumeEncryptionKey)) {
    query['VolumeEncryptionKey'] = request.volumeEncryptionKey;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDesktops',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDesktops(request: CreateDesktopsRequest): CreateDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDesktopsWithOptions(request, runtime);
}

model CreateDiskEncryptionServiceRequest {
  regionId?: string(name='RegionId'),
}

model CreateDiskEncryptionServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDiskEncryptionServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDiskEncryptionServiceResponseBody(name='body'),
}

async function createDiskEncryptionServiceWithOptions(request: CreateDiskEncryptionServiceRequest, runtime: Util.RuntimeOptions): CreateDiskEncryptionServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDiskEncryptionService',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDiskEncryptionService(request: CreateDiskEncryptionServiceRequest): CreateDiskEncryptionServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDiskEncryptionServiceWithOptions(request, runtime);
}

model CreateDriveRequest {
  aliUid?: long(name='AliUid'),
  description?: string(name='Description'),
  domainId?: string(name='DomainId'),
  driveName?: string(name='DriveName'),
  externalDomainId?: string(name='ExternalDomainId'),
  profileRoaming?: boolean(name='ProfileRoaming'),
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
  totalSize?: long(name='TotalSize'),
  type?: string(name='Type'),
  usedSize?: long(name='UsedSize'),
  userId?: string(name='UserId'),
}

model CreateDriveResponseBody = {
  code?: string(name='Code'),
  drive?: {
    aliUid?: string(name='AliUid'),
    description?: string(name='Description'),
    domainId?: string(name='DomainId'),
    driveId?: string(name='DriveId'),
    externalDriveId?: string(name='ExternalDriveId'),
    externalUserId?: string(name='ExternalUserId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    profileRoaming?: boolean(name='ProfileRoaming'),
    status?: string(name='Status'),
    totalSize?: long(name='TotalSize'),
    type?: string(name='Type'),
    usedSize?: long(name='UsedSize'),
    userId?: string(name='UserId'),
  }(name='Drive'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDriveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDriveResponseBody(name='body'),
}

async function createDriveWithOptions(request: CreateDriveRequest, runtime: Util.RuntimeOptions): CreateDriveResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.domainId)) {
    query['DomainId'] = request.domainId;
  }
  if (!Util.isUnset(request.driveName)) {
    query['DriveName'] = request.driveName;
  }
  if (!Util.isUnset(request.externalDomainId)) {
    query['ExternalDomainId'] = request.externalDomainId;
  }
  if (!Util.isUnset(request.profileRoaming)) {
    query['ProfileRoaming'] = request.profileRoaming;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.totalSize)) {
    query['TotalSize'] = request.totalSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.usedSize)) {
    query['UsedSize'] = request.usedSize;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDrive',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDrive(request: CreateDriveRequest): CreateDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDriveWithOptions(request, runtime);
}

model CreateImageRequest {
  autoCleanUserdata?: boolean(name='AutoCleanUserdata'),
  description?: string(name='Description'),
  desktopId?: string(name='DesktopId'),
  diskType?: string(name='DiskType'),
  imageName?: string(name='ImageName'),
  imageResourceType?: string(name='ImageResourceType'),
  regionId?: string(name='RegionId'),
  snapshotId?: string(name='SnapshotId'),
  snapshotIds?: [ string ](name='SnapshotIds'),
}

model CreateImageResponseBody = {
  imageId?: string(name='ImageId'),
  requestId?: string(name='RequestId'),
}

model CreateImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateImageResponseBody(name='body'),
}

async function createImageWithOptions(request: CreateImageRequest, runtime: Util.RuntimeOptions): CreateImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoCleanUserdata)) {
    query['AutoCleanUserdata'] = request.autoCleanUserdata;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.diskType)) {
    query['DiskType'] = request.diskType;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.imageResourceType)) {
    query['ImageResourceType'] = request.imageResourceType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  if (!Util.isUnset(request.snapshotIds)) {
    query['SnapshotIds'] = request.snapshotIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateImage',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createImage(request: CreateImageRequest): CreateImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createImageWithOptions(request, runtime);
}

model CreateNASFileSystemRequest {
  description?: string(name='Description'),
  encryptType?: string(name='EncryptType'),
  name?: string(name='Name'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
  storageType?: string(name='StorageType'),
}

model CreateNASFileSystemResponseBody = {
  fileSystemId?: string(name='FileSystemId'),
  fileSystemName?: string(name='FileSystemName'),
  mountTargetDomain?: string(name='MountTargetDomain'),
  officeSiteId?: string(name='OfficeSiteId'),
  requestId?: string(name='RequestId'),
}

model CreateNASFileSystemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNASFileSystemResponseBody(name='body'),
}

async function createNASFileSystemWithOptions(request: CreateNASFileSystemRequest, runtime: Util.RuntimeOptions): CreateNASFileSystemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.encryptType)) {
    query['EncryptType'] = request.encryptType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNASFileSystem',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNASFileSystem(request: CreateNASFileSystemRequest): CreateNASFileSystemResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNASFileSystemWithOptions(request, runtime);
}

model CreateNetworkPackageRequest {
  autoPay?: boolean(name='AutoPay'),
  autoRenew?: boolean(name='AutoRenew'),
  bandwidth?: int32(name='Bandwidth'),
  internetChargeType?: string(name='InternetChargeType'),
  officeSiteId?: string(name='OfficeSiteId'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  promotionId?: string(name='PromotionId'),
  regionId?: string(name='RegionId'),
}

model CreateNetworkPackageResponseBody = {
  networkPackageId?: string(name='NetworkPackageId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateNetworkPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNetworkPackageResponseBody(name='body'),
}

async function createNetworkPackageWithOptions(request: CreateNetworkPackageRequest, runtime: Util.RuntimeOptions): CreateNetworkPackageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.promotionId)) {
    query['PromotionId'] = request.promotionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNetworkPackage',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNetworkPackage(request: CreateNetworkPackageRequest): CreateNetworkPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNetworkPackageWithOptions(request, runtime);
}

model CreatePolicyGroupRequest {
  appContentProtection?: string(name='AppContentProtection'),
  authorizeAccessPolicyRule?: [ 
    {
      cidrIp?: string(name='CidrIp'),
      description?: string(name='Description'),
    }
  ](name='AuthorizeAccessPolicyRule'),
  authorizeSecurityPolicyRule?: [ 
    {
      cidrIp?: string(name='CidrIp'),
      description?: string(name='Description'),
      ipProtocol?: string(name='IpProtocol'),
      policy?: string(name='Policy'),
      portRange?: string(name='PortRange'),
      priority?: string(name='Priority'),
      type?: string(name='Type'),
    }
  ](name='AuthorizeSecurityPolicyRule'),
  cameraRedirect?: string(name='CameraRedirect'),
  clientType?: [ 
    {
      clientType?: string(name='ClientType'),
      status?: string(name='Status'),
    }
  ](name='ClientType'),
  clipboard?: string(name='Clipboard'),
  domainList?: string(name='DomainList'),
  gpuAcceleration?: string(name='GpuAcceleration'),
  html5Access?: string(name='Html5Access'),
  html5FileTransfer?: string(name='Html5FileTransfer'),
  localDrive?: string(name='LocalDrive'),
  name?: string(name='Name'),
  netRedirect?: string(name='NetRedirect'),
  preemptLogin?: string(name='PreemptLogin'),
  preemptLoginUser?: [ string ](name='PreemptLoginUser'),
  printerRedirection?: string(name='PrinterRedirection'),
  recordContent?: string(name='RecordContent'),
  recordContentExpires?: long(name='RecordContentExpires'),
  recording?: string(name='Recording'),
  recordingEndTime?: string(name='RecordingEndTime'),
  recordingExpires?: long(name='RecordingExpires'),
  recordingFps?: long(name='RecordingFps'),
  recordingStartTime?: string(name='RecordingStartTime'),
  regionId?: string(name='RegionId'),
  remoteCoordinate?: string(name='RemoteCoordinate'),
  usbRedirect?: string(name='UsbRedirect'),
  usbSupplyRedirectRule?: [ 
    {
      description?: string(name='Description'),
      deviceClass?: string(name='DeviceClass'),
      deviceSubclass?: string(name='DeviceSubclass'),
      productId?: string(name='ProductId'),
      usbRedirectType?: long(name='UsbRedirectType'),
      usbRuleType?: long(name='UsbRuleType'),
      vendorId?: string(name='VendorId'),
    }
  ](name='UsbSupplyRedirectRule'),
  visualQuality?: string(name='VisualQuality'),
  watermark?: string(name='Watermark'),
  watermarkTransparency?: string(name='WatermarkTransparency'),
  watermarkType?: string(name='WatermarkType'),
}

model CreatePolicyGroupResponseBody = {
  policyGroupId?: string(name='PolicyGroupId'),
  requestId?: string(name='RequestId'),
}

model CreatePolicyGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePolicyGroupResponseBody(name='body'),
}

async function createPolicyGroupWithOptions(request: CreatePolicyGroupRequest, runtime: Util.RuntimeOptions): CreatePolicyGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appContentProtection)) {
    query['AppContentProtection'] = request.appContentProtection;
  }
  if (!Util.isUnset(request.authorizeAccessPolicyRule)) {
    query['AuthorizeAccessPolicyRule'] = request.authorizeAccessPolicyRule;
  }
  if (!Util.isUnset(request.authorizeSecurityPolicyRule)) {
    query['AuthorizeSecurityPolicyRule'] = request.authorizeSecurityPolicyRule;
  }
  if (!Util.isUnset(request.cameraRedirect)) {
    query['CameraRedirect'] = request.cameraRedirect;
  }
  if (!Util.isUnset(request.clientType)) {
    query['ClientType'] = request.clientType;
  }
  if (!Util.isUnset(request.clipboard)) {
    query['Clipboard'] = request.clipboard;
  }
  if (!Util.isUnset(request.domainList)) {
    query['DomainList'] = request.domainList;
  }
  if (!Util.isUnset(request.gpuAcceleration)) {
    query['GpuAcceleration'] = request.gpuAcceleration;
  }
  if (!Util.isUnset(request.html5Access)) {
    query['Html5Access'] = request.html5Access;
  }
  if (!Util.isUnset(request.html5FileTransfer)) {
    query['Html5FileTransfer'] = request.html5FileTransfer;
  }
  if (!Util.isUnset(request.localDrive)) {
    query['LocalDrive'] = request.localDrive;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.netRedirect)) {
    query['NetRedirect'] = request.netRedirect;
  }
  if (!Util.isUnset(request.preemptLogin)) {
    query['PreemptLogin'] = request.preemptLogin;
  }
  if (!Util.isUnset(request.preemptLoginUser)) {
    query['PreemptLoginUser'] = request.preemptLoginUser;
  }
  if (!Util.isUnset(request.printerRedirection)) {
    query['PrinterRedirection'] = request.printerRedirection;
  }
  if (!Util.isUnset(request.recordContent)) {
    query['RecordContent'] = request.recordContent;
  }
  if (!Util.isUnset(request.recordContentExpires)) {
    query['RecordContentExpires'] = request.recordContentExpires;
  }
  if (!Util.isUnset(request.recording)) {
    query['Recording'] = request.recording;
  }
  if (!Util.isUnset(request.recordingEndTime)) {
    query['RecordingEndTime'] = request.recordingEndTime;
  }
  if (!Util.isUnset(request.recordingExpires)) {
    query['RecordingExpires'] = request.recordingExpires;
  }
  if (!Util.isUnset(request.recordingFps)) {
    query['RecordingFps'] = request.recordingFps;
  }
  if (!Util.isUnset(request.recordingStartTime)) {
    query['RecordingStartTime'] = request.recordingStartTime;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.remoteCoordinate)) {
    query['RemoteCoordinate'] = request.remoteCoordinate;
  }
  if (!Util.isUnset(request.usbRedirect)) {
    query['UsbRedirect'] = request.usbRedirect;
  }
  if (!Util.isUnset(request.usbSupplyRedirectRule)) {
    query['UsbSupplyRedirectRule'] = request.usbSupplyRedirectRule;
  }
  if (!Util.isUnset(request.visualQuality)) {
    query['VisualQuality'] = request.visualQuality;
  }
  if (!Util.isUnset(request.watermark)) {
    query['Watermark'] = request.watermark;
  }
  if (!Util.isUnset(request.watermarkTransparency)) {
    query['WatermarkTransparency'] = request.watermarkTransparency;
  }
  if (!Util.isUnset(request.watermarkType)) {
    query['WatermarkType'] = request.watermarkType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePolicyGroup',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPolicyGroup(request: CreatePolicyGroupRequest): CreatePolicyGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPolicyGroupWithOptions(request, runtime);
}

model CreateRAMDirectoryRequest {
  desktopAccessType?: string(name='DesktopAccessType'),
  directoryName?: string(name='DirectoryName'),
  enableAdminAccess?: boolean(name='EnableAdminAccess'),
  enableInternetAccess?: boolean(name='EnableInternetAccess'),
  regionId?: string(name='RegionId'),
  vSwitchId?: [ string ](name='VSwitchId'),
}

model CreateRAMDirectoryResponseBody = {
  directoryId?: string(name='DirectoryId'),
  requestId?: string(name='RequestId'),
}

model CreateRAMDirectoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRAMDirectoryResponseBody(name='body'),
}

async function createRAMDirectoryWithOptions(request: CreateRAMDirectoryRequest, runtime: Util.RuntimeOptions): CreateRAMDirectoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopAccessType)) {
    query['DesktopAccessType'] = request.desktopAccessType;
  }
  if (!Util.isUnset(request.directoryName)) {
    query['DirectoryName'] = request.directoryName;
  }
  if (!Util.isUnset(request.enableAdminAccess)) {
    query['EnableAdminAccess'] = request.enableAdminAccess;
  }
  if (!Util.isUnset(request.enableInternetAccess)) {
    query['EnableInternetAccess'] = request.enableInternetAccess;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRAMDirectory',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRAMDirectory(request: CreateRAMDirectoryRequest): CreateRAMDirectoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRAMDirectoryWithOptions(request, runtime);
}

model CreateSimpleOfficeSiteRequest {
  bandwidth?: int32(name='Bandwidth'),
  cenId?: string(name='CenId'),
  cenOwnerId?: long(name='CenOwnerId'),
  cidrBlock?: string(name='CidrBlock'),
  cloudBoxOfficeSite?: boolean(name='CloudBoxOfficeSite'),
  desktopAccessType?: string(name='DesktopAccessType'),
  enableAdminAccess?: boolean(name='EnableAdminAccess'),
  enableInternetAccess?: boolean(name='EnableInternetAccess'),
  needVerifyZeroDevice?: boolean(name='NeedVerifyZeroDevice'),
  officeSiteName?: string(name='OfficeSiteName'),
  regionId?: string(name='RegionId'),
  vSwitchId?: [ string ](name='VSwitchId'),
  verifyCode?: string(name='VerifyCode'),
}

model CreateSimpleOfficeSiteResponseBody = {
  officeSiteId?: string(name='OfficeSiteId'),
  requestId?: string(name='RequestId'),
}

model CreateSimpleOfficeSiteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSimpleOfficeSiteResponseBody(name='body'),
}

async function createSimpleOfficeSiteWithOptions(request: CreateSimpleOfficeSiteRequest, runtime: Util.RuntimeOptions): CreateSimpleOfficeSiteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.cenId)) {
    query['CenId'] = request.cenId;
  }
  if (!Util.isUnset(request.cenOwnerId)) {
    query['CenOwnerId'] = request.cenOwnerId;
  }
  if (!Util.isUnset(request.cidrBlock)) {
    query['CidrBlock'] = request.cidrBlock;
  }
  if (!Util.isUnset(request.cloudBoxOfficeSite)) {
    query['CloudBoxOfficeSite'] = request.cloudBoxOfficeSite;
  }
  if (!Util.isUnset(request.desktopAccessType)) {
    query['DesktopAccessType'] = request.desktopAccessType;
  }
  if (!Util.isUnset(request.enableAdminAccess)) {
    query['EnableAdminAccess'] = request.enableAdminAccess;
  }
  if (!Util.isUnset(request.enableInternetAccess)) {
    query['EnableInternetAccess'] = request.enableInternetAccess;
  }
  if (!Util.isUnset(request.needVerifyZeroDevice)) {
    query['NeedVerifyZeroDevice'] = request.needVerifyZeroDevice;
  }
  if (!Util.isUnset(request.officeSiteName)) {
    query['OfficeSiteName'] = request.officeSiteName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.verifyCode)) {
    query['VerifyCode'] = request.verifyCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSimpleOfficeSite',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSimpleOfficeSite(request: CreateSimpleOfficeSiteRequest): CreateSimpleOfficeSiteResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSimpleOfficeSiteWithOptions(request, runtime);
}

model CreateSnapshotRequest {
  description?: string(name='Description'),
  desktopId?: string(name='DesktopId'),
  regionId?: string(name='RegionId'),
  snapshotName?: string(name='SnapshotName'),
  sourceDiskType?: string(name='SourceDiskType'),
}

model CreateSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
  snapshotId?: string(name='SnapshotId'),
}

model CreateSnapshotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSnapshotResponseBody(name='body'),
}

async function createSnapshotWithOptions(request: CreateSnapshotRequest, runtime: Util.RuntimeOptions): CreateSnapshotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.snapshotName)) {
    query['SnapshotName'] = request.snapshotName;
  }
  if (!Util.isUnset(request.sourceDiskType)) {
    query['SourceDiskType'] = request.sourceDiskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSnapshot',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSnapshot(request: CreateSnapshotRequest): CreateSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSnapshotWithOptions(request, runtime);
}

model DeleteBundlesRequest {
  bundleId?: [ string ](name='BundleId'),
  regionId?: string(name='RegionId'),
}

model DeleteBundlesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBundlesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBundlesResponseBody(name='body'),
}

async function deleteBundlesWithOptions(request: DeleteBundlesRequest, runtime: Util.RuntimeOptions): DeleteBundlesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bundleId)) {
    query['BundleId'] = request.bundleId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBundles',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBundles(request: DeleteBundlesRequest): DeleteBundlesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBundlesWithOptions(request, runtime);
}

model DeleteCloudDriveUsersRequest {
  cdsId?: string(name='CdsId'),
  endUserId?: [ string ](name='EndUserId'),
  regionId?: string(name='RegionId'),
}

model DeleteCloudDriveUsersResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCloudDriveUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCloudDriveUsersResponseBody(name='body'),
}

async function deleteCloudDriveUsersWithOptions(request: DeleteCloudDriveUsersRequest, runtime: Util.RuntimeOptions): DeleteCloudDriveUsersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cdsId)) {
    query['CdsId'] = request.cdsId;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCloudDriveUsers',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCloudDriveUsers(request: DeleteCloudDriveUsersRequest): DeleteCloudDriveUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCloudDriveUsersWithOptions(request, runtime);
}

model DeleteDesktopGroupRequest {
  desktopGroupId?: string(name='DesktopGroupId'),
  regionId?: string(name='RegionId'),
}

model DeleteDesktopGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDesktopGroupResponseBody(name='body'),
}

async function deleteDesktopGroupWithOptions(request: DeleteDesktopGroupRequest, runtime: Util.RuntimeOptions): DeleteDesktopGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopGroupId)) {
    query['DesktopGroupId'] = request.desktopGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDesktopGroup',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDesktopGroup(request: DeleteDesktopGroupRequest): DeleteDesktopGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDesktopGroupWithOptions(request, runtime);
}

model DeleteDesktopsRequest {
  desktopId?: [ string ](name='DesktopId'),
  regionId?: string(name='RegionId'),
}

model DeleteDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDesktopsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDesktopsResponseBody(name='body'),
}

async function deleteDesktopsWithOptions(request: DeleteDesktopsRequest, runtime: Util.RuntimeOptions): DeleteDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDesktops',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDesktops(request: DeleteDesktopsRequest): DeleteDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDesktopsWithOptions(request, runtime);
}

model DeleteDirectoriesRequest {
  directoryId?: [ string ](name='DirectoryId'),
  regionId?: string(name='RegionId'),
}

model DeleteDirectoriesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDirectoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDirectoriesResponseBody(name='body'),
}

async function deleteDirectoriesWithOptions(request: DeleteDirectoriesRequest, runtime: Util.RuntimeOptions): DeleteDirectoriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDirectories',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDirectories(request: DeleteDirectoriesRequest): DeleteDirectoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDirectoriesWithOptions(request, runtime);
}

model DeleteDriveRequest {
  driveId?: string(name='DriveId'),
  regionId?: string(name='RegionId'),
}

model DeleteDriveResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDriveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDriveResponseBody(name='body'),
}

async function deleteDriveWithOptions(request: DeleteDriveRequest, runtime: Util.RuntimeOptions): DeleteDriveResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.driveId)) {
    query['DriveId'] = request.driveId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDrive',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDrive(request: DeleteDriveRequest): DeleteDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDriveWithOptions(request, runtime);
}

model DeleteImagesRequest {
  imageId?: [ string ](name='ImageId'),
  regionId?: string(name='RegionId'),
}

model DeleteImagesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteImagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteImagesResponseBody(name='body'),
}

async function deleteImagesWithOptions(request: DeleteImagesRequest, runtime: Util.RuntimeOptions): DeleteImagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteImages',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteImages(request: DeleteImagesRequest): DeleteImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImagesWithOptions(request, runtime);
}

model DeleteNASFileSystemsRequest {
  fileSystemId?: [ string ](name='FileSystemId'),
  regionId?: string(name='RegionId'),
}

model DeleteNASFileSystemsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNASFileSystemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNASFileSystemsResponseBody(name='body'),
}

async function deleteNASFileSystemsWithOptions(request: DeleteNASFileSystemsRequest, runtime: Util.RuntimeOptions): DeleteNASFileSystemsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNASFileSystems',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNASFileSystems(request: DeleteNASFileSystemsRequest): DeleteNASFileSystemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNASFileSystemsWithOptions(request, runtime);
}

model DeleteNetworkPackagesRequest {
  networkPackageId?: [ string ](name='NetworkPackageId'),
  regionId?: string(name='RegionId'),
}

model DeleteNetworkPackagesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNetworkPackagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNetworkPackagesResponseBody(name='body'),
}

async function deleteNetworkPackagesWithOptions(request: DeleteNetworkPackagesRequest, runtime: Util.RuntimeOptions): DeleteNetworkPackagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.networkPackageId)) {
    query['NetworkPackageId'] = request.networkPackageId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNetworkPackages',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNetworkPackages(request: DeleteNetworkPackagesRequest): DeleteNetworkPackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNetworkPackagesWithOptions(request, runtime);
}

model DeleteOfficeSitesRequest {
  officeSiteId?: [ string ](name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model DeleteOfficeSitesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteOfficeSitesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteOfficeSitesResponseBody(name='body'),
}

async function deleteOfficeSitesWithOptions(request: DeleteOfficeSitesRequest, runtime: Util.RuntimeOptions): DeleteOfficeSitesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteOfficeSites',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteOfficeSites(request: DeleteOfficeSitesRequest): DeleteOfficeSitesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteOfficeSitesWithOptions(request, runtime);
}

model DeletePolicyGroupsRequest {
  policyGroupId?: [ string ](name='PolicyGroupId'),
  regionId?: string(name='RegionId'),
}

model DeletePolicyGroupsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePolicyGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePolicyGroupsResponseBody(name='body'),
}

async function deletePolicyGroupsWithOptions(request: DeletePolicyGroupsRequest, runtime: Util.RuntimeOptions): DeletePolicyGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyGroupId)) {
    query['PolicyGroupId'] = request.policyGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePolicyGroups',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePolicyGroups(request: DeletePolicyGroupsRequest): DeletePolicyGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePolicyGroupsWithOptions(request, runtime);
}

model DeleteSnapshotRequest {
  regionId?: string(name='RegionId'),
  snapshotId?: [ string ](name='SnapshotId'),
}

model DeleteSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSnapshotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSnapshotResponseBody(name='body'),
}

async function deleteSnapshotWithOptions(request: DeleteSnapshotRequest, runtime: Util.RuntimeOptions): DeleteSnapshotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSnapshot',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSnapshot(request: DeleteSnapshotRequest): DeleteSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSnapshotWithOptions(request, runtime);
}

model DeleteVirtualMFADeviceRequest {
  regionId?: string(name='RegionId'),
  serialNumber?: string(name='SerialNumber'),
}

model DeleteVirtualMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVirtualMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVirtualMFADeviceResponseBody(name='body'),
}

async function deleteVirtualMFADeviceWithOptions(request: DeleteVirtualMFADeviceRequest, runtime: Util.RuntimeOptions): DeleteVirtualMFADeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serialNumber)) {
    query['SerialNumber'] = request.serialNumber;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVirtualMFADevice',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVirtualMFADevice(request: DeleteVirtualMFADeviceRequest): DeleteVirtualMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVirtualMFADeviceWithOptions(request, runtime);
}

model DescribeAlarmEventStackInfoRequest {
  desktopId?: string(name='DesktopId'),
  eventName?: string(name='EventName'),
  lang?: string(name='Lang'),
  regionId?: string(name='RegionId'),
  uniqueInfo?: string(name='UniqueInfo'),
}

model DescribeAlarmEventStackInfoResponseBody = {
  requestId?: string(name='RequestId'),
  stackInfo?: string(name='StackInfo'),
}

model DescribeAlarmEventStackInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAlarmEventStackInfoResponseBody(name='body'),
}

async function describeAlarmEventStackInfoWithOptions(request: DescribeAlarmEventStackInfoRequest, runtime: Util.RuntimeOptions): DescribeAlarmEventStackInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.eventName)) {
    query['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.uniqueInfo)) {
    query['UniqueInfo'] = request.uniqueInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAlarmEventStackInfo',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAlarmEventStackInfo(request: DescribeAlarmEventStackInfoRequest): DescribeAlarmEventStackInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlarmEventStackInfoWithOptions(request, runtime);
}

model DescribeBundlesRequest {
  bundleId?: [ string ](name='BundleId'),
  bundleType?: string(name='BundleType'),
  checkStock?: boolean(name='CheckStock'),
  cpuCount?: int32(name='CpuCount'),
  desktopTypeFamily?: string(name='DesktopTypeFamily'),
  fotaChannel?: string(name='FotaChannel'),
  fromDesktopGroup?: boolean(name='FromDesktopGroup'),
  gpuCount?: float(name='GpuCount'),
  maxResults?: int32(name='MaxResults'),
  memorySize?: int32(name='MemorySize'),
  nextToken?: string(name='NextToken'),
  protocolType?: string(name='ProtocolType'),
  regionId?: string(name='RegionId'),
  supportMultiSession?: boolean(name='SupportMultiSession'),
  volumeEncryptionEnabled?: boolean(name='VolumeEncryptionEnabled'),
}

model DescribeBundlesResponseBody = {
  bundles?: [ 
    {
      bundleId?: string(name='BundleId'),
      bundleName?: string(name='BundleName'),
      bundleType?: string(name='BundleType'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      desktopType?: string(name='DesktopType'),
      desktopTypeAttribute?: {
        cpuCount?: int32(name='CpuCount'),
        gpuCount?: float(name='GpuCount'),
        gpuSpec?: string(name='GpuSpec'),
        memorySize?: int32(name='MemorySize'),
      }(name='DesktopTypeAttribute'),
      desktopTypeFamily?: string(name='DesktopTypeFamily'),
      disks?: [ 
        {
          diskPerformanceLevel?: string(name='DiskPerformanceLevel'),
          diskSize?: int32(name='DiskSize'),
          diskType?: string(name='DiskType'),
        }
      ](name='Disks'),
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      language?: string(name='Language'),
      osType?: string(name='OsType'),
      platform?: string(name='Platform'),
      protocolType?: string(name='ProtocolType'),
      sessionType?: string(name='SessionType'),
      stockState?: string(name='StockState'),
      volumeEncryptionEnabled?: boolean(name='VolumeEncryptionEnabled'),
      volumeEncryptionKey?: string(name='VolumeEncryptionKey'),
    }
  ](name='Bundles'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeBundlesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBundlesResponseBody(name='body'),
}

async function describeBundlesWithOptions(request: DescribeBundlesRequest, runtime: Util.RuntimeOptions): DescribeBundlesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bundleId)) {
    query['BundleId'] = request.bundleId;
  }
  if (!Util.isUnset(request.bundleType)) {
    query['BundleType'] = request.bundleType;
  }
  if (!Util.isUnset(request.checkStock)) {
    query['CheckStock'] = request.checkStock;
  }
  if (!Util.isUnset(request.cpuCount)) {
    query['CpuCount'] = request.cpuCount;
  }
  if (!Util.isUnset(request.desktopTypeFamily)) {
    query['DesktopTypeFamily'] = request.desktopTypeFamily;
  }
  if (!Util.isUnset(request.fotaChannel)) {
    query['FotaChannel'] = request.fotaChannel;
  }
  if (!Util.isUnset(request.fromDesktopGroup)) {
    query['FromDesktopGroup'] = request.fromDesktopGroup;
  }
  if (!Util.isUnset(request.gpuCount)) {
    query['GpuCount'] = request.gpuCount;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.memorySize)) {
    query['MemorySize'] = request.memorySize;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.supportMultiSession)) {
    query['SupportMultiSession'] = request.supportMultiSession;
  }
  if (!Util.isUnset(request.volumeEncryptionEnabled)) {
    query['VolumeEncryptionEnabled'] = request.volumeEncryptionEnabled;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBundles',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBundles(request: DescribeBundlesRequest): DescribeBundlesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBundlesWithOptions(request, runtime);
}

model DescribeCensRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model DescribeCensResponseBody = {
  cens?: [ 
    {
      cenId?: string(name='CenId'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      ipv6Level?: string(name='Ipv6Level'),
      name?: string(name='Name'),
      packageIds?: [ 
        {
          packageId?: string(name='PackageId'),
        }
      ](name='PackageIds'),
      protectionLevel?: string(name='ProtectionLevel'),
      status?: string(name='Status'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
    }
  ](name='Cens'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeCensResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCensResponseBody(name='body'),
}

async function describeCensWithOptions(request: DescribeCensRequest, runtime: Util.RuntimeOptions): DescribeCensResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCens',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCens(request: DescribeCensRequest): DescribeCensResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCensWithOptions(request, runtime);
}

model DescribeClientEventsRequest {
  desktopId?: string(name='DesktopId'),
  desktopIp?: string(name='DesktopIp'),
  desktopName?: string(name='DesktopName'),
  directoryId?: string(name='DirectoryId'),
  endTime?: string(name='EndTime'),
  endUserId?: string(name='EndUserId'),
  eventType?: string(name='EventType'),
  eventTypes?: [ string ](name='EventTypes'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  officeSiteName?: string(name='OfficeSiteName'),
  regionId?: string(name='RegionId'),
  startTime?: string(name='StartTime'),
}

model DescribeClientEventsResponseBody = {
  events?: [ 
    {
      aliUid?: string(name='AliUid'),
      bytesReceived?: string(name='BytesReceived'),
      bytesSend?: string(name='BytesSend'),
      clientIp?: string(name='ClientIp'),
      clientOS?: string(name='ClientOS'),
      clientVersion?: string(name='ClientVersion'),
      desktopGroupId?: string(name='DesktopGroupId'),
      desktopGroupName?: string(name='DesktopGroupName'),
      desktopId?: string(name='DesktopId'),
      desktopIp?: string(name='DesktopIp'),
      desktopName?: string(name='DesktopName'),
      directoryId?: string(name='DirectoryId'),
      directoryType?: string(name='DirectoryType'),
      endUserId?: string(name='EndUserId'),
      eventId?: string(name='EventId'),
      eventTime?: string(name='EventTime'),
      eventType?: string(name='EventType'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      officeSiteType?: string(name='OfficeSiteType'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
    }
  ](name='Events'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeClientEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClientEventsResponseBody(name='body'),
}

async function describeClientEventsWithOptions(request: DescribeClientEventsRequest, runtime: Util.RuntimeOptions): DescribeClientEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.desktopIp)) {
    query['DesktopIp'] = request.desktopIp;
  }
  if (!Util.isUnset(request.desktopName)) {
    query['DesktopName'] = request.desktopName;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.eventTypes)) {
    query['EventTypes'] = request.eventTypes;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.officeSiteName)) {
    query['OfficeSiteName'] = request.officeSiteName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClientEvents',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClientEvents(request: DescribeClientEventsRequest): DescribeClientEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClientEventsWithOptions(request, runtime);
}

model DescribeCloudDrivePermissionsRequest {
  cdsId?: string(name='CdsId'),
  regionId?: string(name='RegionId'),
}

model DescribeCloudDrivePermissionsResponseBody = {
  cloudDrivePermissionModels?: [ 
    {
      endUsers?: [ string ](name='EndUsers'),
      permission?: string(name='Permission'),
    }
  ](name='CloudDrivePermissionModels'),
  requestId?: string(name='RequestId'),
}

model DescribeCloudDrivePermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCloudDrivePermissionsResponseBody(name='body'),
}

async function describeCloudDrivePermissionsWithOptions(request: DescribeCloudDrivePermissionsRequest, runtime: Util.RuntimeOptions): DescribeCloudDrivePermissionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cdsId)) {
    query['CdsId'] = request.cdsId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudDrivePermissions',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCloudDrivePermissions(request: DescribeCloudDrivePermissionsRequest): DescribeCloudDrivePermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudDrivePermissionsWithOptions(request, runtime);
}

model DescribeCustomizedListHeadersRequest {
  langType?: string(name='LangType'),
  listType?: string(name='ListType'),
  regionId?: string(name='RegionId'),
}

model DescribeCustomizedListHeadersResponseBody = {
  headers?: [ 
    {
      displayType?: string(name='DisplayType'),
      headerKey?: string(name='HeaderKey'),
      headerName?: string(name='HeaderName'),
    }
  ](name='Headers'),
  requestId?: string(name='RequestId'),
}

model DescribeCustomizedListHeadersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCustomizedListHeadersResponseBody(name='body'),
}

async function describeCustomizedListHeadersWithOptions(request: DescribeCustomizedListHeadersRequest, runtime: Util.RuntimeOptions): DescribeCustomizedListHeadersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.langType)) {
    query['LangType'] = request.langType;
  }
  if (!Util.isUnset(request.listType)) {
    query['ListType'] = request.listType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomizedListHeaders',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCustomizedListHeaders(request: DescribeCustomizedListHeadersRequest): DescribeCustomizedListHeadersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomizedListHeadersWithOptions(request, runtime);
}

model DescribeDesktopGroupsRequest {
  desktopGroupId?: string(name='DesktopGroupId'),
  desktopGroupName?: string(name='DesktopGroupName'),
  endUserIds?: [ string ](name='EndUserIds'),
  excludedEndUserIds?: [ string ](name='ExcludedEndUserIds'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  ownType?: long(name='OwnType'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  policyGroupId?: string(name='PolicyGroupId'),
  regionId?: string(name='RegionId'),
  status?: int32(name='Status'),
}

model DescribeDesktopGroupsResponseBody = {
  desktopGroups?: [ 
    {
      bindAmount?: long(name='BindAmount'),
      comments?: string(name='Comments'),
      connectDuration?: long(name='ConnectDuration'),
      cpu?: int32(name='Cpu'),
      createTime?: string(name='CreateTime'),
      creator?: string(name='Creator'),
      dataDiskCategory?: string(name='DataDiskCategory'),
      dataDiskSize?: string(name='DataDiskSize'),
      desktopGroupId?: string(name='DesktopGroupId'),
      desktopGroupName?: string(name='DesktopGroupName'),
      endUserCount?: int32(name='EndUserCount'),
      expiredTime?: string(name='ExpiredTime'),
      gpuCount?: float(name='GpuCount'),
      gpuSpec?: string(name='GpuSpec'),
      idleDisconnectDuration?: long(name='IdleDisconnectDuration'),
      imageId?: string(name='ImageId'),
      keepDuration?: long(name='KeepDuration'),
      loadPolicy?: long(name='LoadPolicy'),
      maxDesktopsCount?: int32(name='MaxDesktopsCount'),
      memory?: long(name='Memory'),
      minDesktopsCount?: int32(name='MinDesktopsCount'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      officeSiteType?: string(name='OfficeSiteType'),
      ownBundleId?: string(name='OwnBundleId'),
      ownBundleName?: string(name='OwnBundleName'),
      ownType?: long(name='OwnType'),
      payType?: string(name='PayType'),
      policyGroupId?: string(name='PolicyGroupId'),
      policyGroupName?: string(name='PolicyGroupName'),
      ratioThreshold?: float(name='RatioThreshold'),
      resetType?: long(name='ResetType'),
      status?: int32(name='Status'),
      stopDuration?: long(name='StopDuration'),
      systemDiskCategory?: string(name='SystemDiskCategory'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      version?: int32(name='Version'),
      volumeEncryptionEnabled?: boolean(name='VolumeEncryptionEnabled'),
      volumeEncryptionKey?: string(name='VolumeEncryptionKey'),
    }
  ](name='DesktopGroups'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeDesktopGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDesktopGroupsResponseBody(name='body'),
}

async function describeDesktopGroupsWithOptions(request: DescribeDesktopGroupsRequest, runtime: Util.RuntimeOptions): DescribeDesktopGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopGroupId)) {
    query['DesktopGroupId'] = request.desktopGroupId;
  }
  if (!Util.isUnset(request.desktopGroupName)) {
    query['DesktopGroupName'] = request.desktopGroupName;
  }
  if (!Util.isUnset(request.endUserIds)) {
    query['EndUserIds'] = request.endUserIds;
  }
  if (!Util.isUnset(request.excludedEndUserIds)) {
    query['ExcludedEndUserIds'] = request.excludedEndUserIds;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.ownType)) {
    query['OwnType'] = request.ownType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.policyGroupId)) {
    query['PolicyGroupId'] = request.policyGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDesktopGroups',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDesktopGroups(request: DescribeDesktopGroupsRequest): DescribeDesktopGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDesktopGroupsWithOptions(request, runtime);
}

model DescribeDesktopIdsByVulNamesRequest {
  necessity?: string(name='Necessity'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
  vulName?: [ string ](name='VulName'),
}

model DescribeDesktopIdsByVulNamesResponseBody = {
  desktopItems?: [ 
    {
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
    }
  ](name='DesktopItems'),
  requestId?: string(name='RequestId'),
}

model DescribeDesktopIdsByVulNamesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDesktopIdsByVulNamesResponseBody(name='body'),
}

async function describeDesktopIdsByVulNamesWithOptions(request: DescribeDesktopIdsByVulNamesRequest, runtime: Util.RuntimeOptions): DescribeDesktopIdsByVulNamesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.necessity)) {
    query['Necessity'] = request.necessity;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.vulName)) {
    query['VulName'] = request.vulName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDesktopIdsByVulNames',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDesktopIdsByVulNames(request: DescribeDesktopIdsByVulNamesRequest): DescribeDesktopIdsByVulNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDesktopIdsByVulNamesWithOptions(request, runtime);
}

model DescribeDesktopTypesRequest {
  appliedScope?: string(name='AppliedScope'),
  cpuCount?: int32(name='CpuCount'),
  desktopIdForModify?: string(name='DesktopIdForModify'),
  desktopTypeId?: string(name='DesktopTypeId'),
  gpuCount?: float(name='GpuCount'),
  instanceTypeFamily?: string(name='InstanceTypeFamily'),
  memorySize?: int32(name='MemorySize'),
  orderType?: string(name='OrderType'),
  regionId?: string(name='RegionId'),
}

model DescribeDesktopTypesResponseBody = {
  desktopTypes?: [ 
    {
      cpuCount?: string(name='CpuCount'),
      dataDiskSize?: string(name='DataDiskSize'),
      desktopTypeId?: string(name='DesktopTypeId'),
      desktopTypeStatus?: string(name='DesktopTypeStatus'),
      gpuCount?: float(name='GpuCount'),
      gpuSpec?: string(name='GpuSpec'),
      instanceTypeFamily?: string(name='InstanceTypeFamily'),
      memorySize?: string(name='MemorySize'),
      systemDiskSize?: string(name='SystemDiskSize'),
    }
  ](name='DesktopTypes'),
  requestId?: string(name='RequestId'),
}

model DescribeDesktopTypesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDesktopTypesResponseBody(name='body'),
}

async function describeDesktopTypesWithOptions(request: DescribeDesktopTypesRequest, runtime: Util.RuntimeOptions): DescribeDesktopTypesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appliedScope)) {
    query['AppliedScope'] = request.appliedScope;
  }
  if (!Util.isUnset(request.cpuCount)) {
    query['CpuCount'] = request.cpuCount;
  }
  if (!Util.isUnset(request.desktopIdForModify)) {
    query['DesktopIdForModify'] = request.desktopIdForModify;
  }
  if (!Util.isUnset(request.desktopTypeId)) {
    query['DesktopTypeId'] = request.desktopTypeId;
  }
  if (!Util.isUnset(request.gpuCount)) {
    query['GpuCount'] = request.gpuCount;
  }
  if (!Util.isUnset(request.instanceTypeFamily)) {
    query['InstanceTypeFamily'] = request.instanceTypeFamily;
  }
  if (!Util.isUnset(request.memorySize)) {
    query['MemorySize'] = request.memorySize;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDesktopTypes',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDesktopTypes(request: DescribeDesktopTypesRequest): DescribeDesktopTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDesktopTypesWithOptions(request, runtime);
}

model DescribeDesktopsRequest {
  chargeType?: string(name='ChargeType'),
  desktopId?: [ string ](name='DesktopId'),
  desktopName?: string(name='DesktopName'),
  desktopStatus?: string(name='DesktopStatus'),
  directoryId?: string(name='DirectoryId'),
  endUserId?: [ string ](name='EndUserId'),
  excludedEndUserId?: [ string ](name='ExcludedEndUserId'),
  expiredTime?: string(name='ExpiredTime'),
  filterDesktopGroup?: boolean(name='FilterDesktopGroup'),
  groupId?: string(name='GroupId'),
  managementFlag?: string(name='ManagementFlag'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  officeSiteName?: string(name='OfficeSiteName'),
  policyGroupId?: string(name='PolicyGroupId'),
  protocolType?: string(name='ProtocolType'),
  queryFotaUpdate?: boolean(name='QueryFotaUpdate'),
  regionId?: string(name='RegionId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  userName?: string(name='UserName'),
}

model DescribeDesktopsResponseBody = {
  desktops?: [ 
    {
      bundleId?: string(name='BundleId'),
      bundleName?: string(name='BundleName'),
      chargeType?: string(name='ChargeType'),
      connectionStatus?: string(name='ConnectionStatus'),
      cpu?: int32(name='Cpu'),
      creationTime?: string(name='CreationTime'),
      dataDiskCategory?: string(name='DataDiskCategory'),
      dataDiskSize?: string(name='DataDiskSize'),
      desktopGroupId?: string(name='DesktopGroupId'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      desktopStatus?: string(name='DesktopStatus'),
      desktopType?: string(name='DesktopType'),
      directoryId?: string(name='DirectoryId'),
      directoryType?: string(name='DirectoryType'),
      disks?: [ 
        {
          diskId?: string(name='DiskId'),
          diskSize?: int32(name='DiskSize'),
          diskType?: string(name='DiskType'),
          performanceLevel?: string(name='PerformanceLevel'),
        }
      ](name='Disks'),
      downgradeQuota?: long(name='DowngradeQuota'),
      downgradedTimes?: long(name='DowngradedTimes'),
      endUserIds?: [ string ](name='EndUserIds'),
      expiredTime?: string(name='ExpiredTime'),
      fotaUpdate?: {
        currentAppVersion?: string(name='CurrentAppVersion'),
        newAppVersion?: string(name='NewAppVersion'),
        releaseNote?: string(name='ReleaseNote'),
        size?: long(name='Size'),
      }(name='FotaUpdate'),
      gpuCategory?: long(name='GpuCategory'),
      gpuCount?: float(name='GpuCount'),
      gpuDriverVersion?: string(name='GpuDriverVersion'),
      gpuSpec?: string(name='GpuSpec'),
      hostName?: string(name='HostName'),
      imageId?: string(name='ImageId'),
      managementFlag?: string(name='ManagementFlag'),
      memory?: long(name='Memory'),
      networkInterfaceId?: string(name='NetworkInterfaceId'),
      networkInterfaceIp?: string(name='NetworkInterfaceIp'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      officeSiteType?: string(name='OfficeSiteType'),
      officeSiteVpcType?: string(name='OfficeSiteVpcType'),
      osType?: string(name='OsType'),
      platform?: string(name='Platform'),
      policyGroupId?: string(name='PolicyGroupId'),
      policyGroupName?: string(name='PolicyGroupName'),
      progress?: string(name='Progress'),
      protocolType?: string(name='ProtocolType'),
      sessionType?: string(name='SessionType'),
      sessions?: [ 
        {
          endUserId?: string(name='EndUserId'),
          establishmentTime?: string(name='EstablishmentTime'),
          externalUserName?: string(name='ExternalUserName'),
        }
      ](name='Sessions'),
      startTime?: string(name='StartTime'),
      systemDiskCategory?: string(name='SystemDiskCategory'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      volumeEncryptionEnabled?: boolean(name='VolumeEncryptionEnabled'),
      volumeEncryptionKey?: string(name='VolumeEncryptionKey'),
      zoneType?: string(name='ZoneType'),
    }
  ](name='Desktops'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDesktopsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDesktopsResponseBody(name='body'),
}

async function describeDesktopsWithOptions(request: DescribeDesktopsRequest, runtime: Util.RuntimeOptions): DescribeDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.desktopName)) {
    query['DesktopName'] = request.desktopName;
  }
  if (!Util.isUnset(request.desktopStatus)) {
    query['DesktopStatus'] = request.desktopStatus;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.excludedEndUserId)) {
    query['ExcludedEndUserId'] = request.excludedEndUserId;
  }
  if (!Util.isUnset(request.expiredTime)) {
    query['ExpiredTime'] = request.expiredTime;
  }
  if (!Util.isUnset(request.filterDesktopGroup)) {
    query['FilterDesktopGroup'] = request.filterDesktopGroup;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.managementFlag)) {
    query['ManagementFlag'] = request.managementFlag;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.officeSiteName)) {
    query['OfficeSiteName'] = request.officeSiteName;
  }
  if (!Util.isUnset(request.policyGroupId)) {
    query['PolicyGroupId'] = request.policyGroupId;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.queryFotaUpdate)) {
    query['QueryFotaUpdate'] = request.queryFotaUpdate;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDesktops',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDesktops(request: DescribeDesktopsRequest): DescribeDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDesktopsWithOptions(request, runtime);
}

model DescribeDesktopsInGroupRequest {
  desktopGroupId?: string(name='DesktopGroupId'),
  ignoreDeleted?: boolean(name='IgnoreDeleted'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
}

model DescribeDesktopsInGroupResponseBody = {
  nextToken?: string(name='NextToken'),
  onlinePrePaidDesktopsCount?: int32(name='OnlinePrePaidDesktopsCount'),
  paidDesktops?: [ 
    {
      connectionStatus?: string(name='ConnectionStatus'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      desktopStatus?: string(name='DesktopStatus'),
      diskType?: string(name='DiskType'),
      endUserId?: string(name='EndUserId'),
      endUserIds?: [ string ](name='EndUserIds'),
      endUserName?: string(name='EndUserName'),
      endUserNames?: [ string ](name='EndUserNames'),
      gpuDriverVersion?: string(name='GpuDriverVersion'),
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      managementFlag?: string(name='ManagementFlag'),
      managementFlags?: [ string ](name='ManagementFlags'),
      memberEniIp?: string(name='MemberEniIp'),
      osType?: string(name='OsType'),
      primaryEniIp?: string(name='PrimaryEniIp'),
      resetTime?: string(name='ResetTime'),
      systemDiskSize?: int32(name='SystemDiskSize'),
    }
  ](name='PaidDesktops'),
  paidDesktopsCount?: int32(name='PaidDesktopsCount'),
  postPaidDesktops?: [ 
    {
      connectionStatus?: string(name='ConnectionStatus'),
      createDuration?: string(name='CreateDuration'),
      createTime?: string(name='CreateTime'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      desktopStatus?: string(name='DesktopStatus'),
      diskType?: string(name='DiskType'),
      endUserId?: string(name='EndUserId'),
      endUserIds?: [ string ](name='EndUserIds'),
      endUserName?: string(name='EndUserName'),
      endUserNames?: [ string ](name='EndUserNames'),
      gpuDriverVersion?: string(name='GpuDriverVersion'),
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      managementFlag?: string(name='ManagementFlag'),
      managementFlags?: [ string ](name='ManagementFlags'),
      memberEniIp?: string(name='MemberEniIp'),
      osType?: string(name='OsType'),
      primaryEniIp?: string(name='PrimaryEniIp'),
      releaseTime?: string(name='ReleaseTime'),
      resetTime?: string(name='ResetTime'),
      systemDiskSize?: int32(name='SystemDiskSize'),
    }
  ](name='PostPaidDesktops'),
  postPaidDesktopsCount?: int32(name='PostPaidDesktopsCount'),
  postPaidDesktopsTotalAmount?: int32(name='PostPaidDesktopsTotalAmount'),
  requestId?: string(name='RequestId'),
  runningPrePaidDesktopsCount?: int32(name='RunningPrePaidDesktopsCount'),
  stopedPrePaidDesktopsCount?: int32(name='StopedPrePaidDesktopsCount'),
}

model DescribeDesktopsInGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDesktopsInGroupResponseBody(name='body'),
}

async function describeDesktopsInGroupWithOptions(request: DescribeDesktopsInGroupRequest, runtime: Util.RuntimeOptions): DescribeDesktopsInGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopGroupId)) {
    query['DesktopGroupId'] = request.desktopGroupId;
  }
  if (!Util.isUnset(request.ignoreDeleted)) {
    query['IgnoreDeleted'] = request.ignoreDeleted;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDesktopsInGroup',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDesktopsInGroup(request: DescribeDesktopsInGroupRequest): DescribeDesktopsInGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDesktopsInGroupWithOptions(request, runtime);
}

model DescribeDirectoriesRequest {
  directoryId?: [ string ](name='DirectoryId'),
  directoryStatus?: string(name='DirectoryStatus'),
  directoryType?: string(name='DirectoryType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  status?: string(name='Status'),
}

model DescribeDirectoriesResponseBody = {
  adHostname?: string(name='AdHostname'),
  directories?: [ 
    {
      ADConnectors?: [ 
        {
          ADConnectorAddress?: string(name='ADConnectorAddress'),
          connectorStatus?: string(name='ConnectorStatus'),
          networkInterfaceId?: string(name='NetworkInterfaceId'),
          specification?: string(name='Specification'),
          trustKey?: string(name='TrustKey'),
          vSwitchId?: string(name='VSwitchId'),
        }
      ](name='ADConnectors'),
      creationTime?: string(name='CreationTime'),
      customSecurityGroupId?: string(name='CustomSecurityGroupId'),
      desktopAccessType?: string(name='DesktopAccessType'),
      desktopVpcEndpoint?: string(name='DesktopVpcEndpoint'),
      directoryId?: string(name='DirectoryId'),
      directoryType?: string(name='DirectoryType'),
      dnsAddress?: [ string ](name='DnsAddress'),
      dnsUserName?: string(name='DnsUserName'),
      domainName?: string(name='DomainName'),
      domainPassword?: string(name='DomainPassword'),
      domainUserName?: string(name='DomainUserName'),
      enableAdminAccess?: boolean(name='EnableAdminAccess'),
      enableCrossDesktopAccess?: boolean(name='EnableCrossDesktopAccess'),
      enableInternetAccess?: boolean(name='EnableInternetAccess'),
      fileSystemIds?: [ string ](name='FileSystemIds'),
      logs?: [ 
        {
          level?: string(name='Level'),
          message?: string(name='Message'),
          step?: string(name='Step'),
          timeStamp?: string(name='TimeStamp'),
        }
      ](name='Logs'),
      mfaEnabled?: boolean(name='MfaEnabled'),
      name?: string(name='Name'),
      needVerifyLoginRisk?: boolean(name='NeedVerifyLoginRisk'),
      ouName?: string(name='OuName'),
      ssoEnabled?: boolean(name='SsoEnabled'),
      status?: string(name='Status'),
      subDnsAddress?: [ string ](name='SubDnsAddress'),
      subDomainName?: string(name='SubDomainName'),
      trustPassword?: string(name='TrustPassword'),
      vSwitchIds?: [ string ](name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Directories'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeDirectoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDirectoriesResponseBody(name='body'),
}

async function describeDirectoriesWithOptions(request: DescribeDirectoriesRequest, runtime: Util.RuntimeOptions): DescribeDirectoriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.directoryStatus)) {
    query['DirectoryStatus'] = request.directoryStatus;
  }
  if (!Util.isUnset(request.directoryType)) {
    query['DirectoryType'] = request.directoryType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDirectories',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDirectories(request: DescribeDirectoriesRequest): DescribeDirectoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDirectoriesWithOptions(request, runtime);
}

model DescribeDrivesRequest {
  domainIds?: [ string ](name='DomainIds'),
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
  userId?: string(name='UserId'),
}

model DescribeDrivesResponseBody = {
  code?: string(name='Code'),
  drives?: [ 
    {
      aliUid?: long(name='AliUid'),
      description?: string(name='Description'),
      desktopGroupCount?: int32(name='DesktopGroupCount'),
      desktopGroups?: [ 
        {
          desktopGroupId?: string(name='DesktopGroupId'),
          desktopGroupName?: string(name='DesktopGroupName'),
        }
      ](name='DesktopGroups'),
      domainId?: string(name='DomainId'),
      driveId?: string(name='DriveId'),
      enableProfileManagement?: boolean(name='EnableProfileManagement'),
      externalDomainId?: string(name='ExternalDomainId'),
      externalDriveId?: string(name='ExternalDriveId'),
      externalUserId?: string(name='ExternalUserId'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      profileRoaming?: boolean(name='ProfileRoaming'),
      status?: string(name='Status'),
      totalSize?: long(name='TotalSize'),
      type?: string(name='Type'),
      usedSize?: long(name='UsedSize'),
      userId?: string(name='UserId'),
    }
  ](name='Drives'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeDrivesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDrivesResponseBody(name='body'),
}

async function describeDrivesWithOptions(request: DescribeDrivesRequest, runtime: Util.RuntimeOptions): DescribeDrivesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainIds)) {
    query['DomainIds'] = request.domainIds;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDrives',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDrives(request: DescribeDrivesRequest): DescribeDrivesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDrivesWithOptions(request, runtime);
}

model DescribeFlowMetricRequest {
  endTime?: string(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  metricType?: string(name='MetricType'),
  period?: int32(name='Period'),
  regionId?: string(name='RegionId'),
  startTime?: string(name='StartTime'),
}

model DescribeFlowMetricResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeFlowMetricResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFlowMetricResponseBody(name='body'),
}

async function describeFlowMetricWithOptions(request: DescribeFlowMetricRequest, runtime: Util.RuntimeOptions): DescribeFlowMetricResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlowMetric',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlowMetric(request: DescribeFlowMetricRequest): DescribeFlowMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowMetricWithOptions(request, runtime);
}

model DescribeFlowStatisticRequest {
  desktopId?: string(name='DesktopId'),
  officeSiteId?: string(name='OfficeSiteId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  period?: int32(name='Period'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowStatisticResponseBody = {
  desktopCount?: int32(name='DesktopCount'),
  desktopFlowStatistic?: [ 
    {
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      flowIn?: string(name='FlowIn'),
      flowRank?: int32(name='FlowRank'),
    }
  ](name='DesktopFlowStatistic'),
  requestId?: string(name='RequestId'),
}

model DescribeFlowStatisticResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFlowStatisticResponseBody(name='body'),
}

async function describeFlowStatisticWithOptions(request: DescribeFlowStatisticRequest, runtime: Util.RuntimeOptions): DescribeFlowStatisticResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlowStatistic',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlowStatistic(request: DescribeFlowStatisticRequest): DescribeFlowStatisticResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowStatisticWithOptions(request, runtime);
}

model DescribeFotaPendingDesktopsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  taskUid?: string(name='TaskUid'),
}

model DescribeFotaPendingDesktopsResponseBody = {
  fotaPendingDesktops?: [ 
    {
      currentAppVersion?: string(name='CurrentAppVersion'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      fotaProject?: string(name='FotaProject'),
      officeSiteId?: string(name='OfficeSiteId'),
    }
  ](name='FotaPendingDesktops'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeFotaPendingDesktopsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFotaPendingDesktopsResponseBody(name='body'),
}

async function describeFotaPendingDesktopsWithOptions(request: DescribeFotaPendingDesktopsRequest, runtime: Util.RuntimeOptions): DescribeFotaPendingDesktopsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFotaPendingDesktops',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFotaPendingDesktops(request: DescribeFotaPendingDesktopsRequest): DescribeFotaPendingDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFotaPendingDesktopsWithOptions(request, runtime);
}

model DescribeFotaTasksRequest {
  fotaStatus?: string(name='FotaStatus'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  taskUid?: [ string ](name='TaskUid'),
  userStatus?: string(name='UserStatus'),
}

model DescribeFotaTasksResponseBody = {
  fotaTasks?: [ 
    {
      appVersion?: string(name='AppVersion'),
      fotaProject?: string(name='FotaProject'),
      pendingDesktopCount?: int32(name='PendingDesktopCount'),
      publishTime?: string(name='PublishTime'),
      releaseNote?: string(name='ReleaseNote'),
      size?: int32(name='Size'),
      status?: string(name='Status'),
      taskUid?: string(name='TaskUid'),
    }
  ](name='FotaTasks'),
  requestId?: string(name='RequestId'),
}

model DescribeFotaTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFotaTasksResponseBody(name='body'),
}

async function describeFotaTasksWithOptions(request: DescribeFotaTasksRequest, runtime: Util.RuntimeOptions): DescribeFotaTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fotaStatus)) {
    query['FotaStatus'] = request.fotaStatus;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskUid)) {
    query['TaskUid'] = request.taskUid;
  }
  if (!Util.isUnset(request.userStatus)) {
    query['UserStatus'] = request.userStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFotaTasks',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFotaTasks(request: DescribeFotaTasksRequest): DescribeFotaTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFotaTasksWithOptions(request, runtime);
}

model DescribeFrontVulPatchListRequest {
  operateType?: string(name='OperateType'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
  vulInfo?: [ 
    {
      desktopId?: string(name='DesktopId'),
      name?: string(name='Name'),
      tag?: string(name='Tag'),
    }
  ](name='VulInfo'),
}

model DescribeFrontVulPatchListResponseBody = {
  frontPatchList?: [ 
    {
      desktopId?: string(name='DesktopId'),
      patchList?: [ 
        {
          aliasName?: string(name='AliasName'),
          name?: string(name='Name'),
        }
      ](name='PatchList'),
    }
  ](name='FrontPatchList'),
  requestId?: string(name='RequestId'),
}

model DescribeFrontVulPatchListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFrontVulPatchListResponseBody(name='body'),
}

async function describeFrontVulPatchListWithOptions(request: DescribeFrontVulPatchListRequest, runtime: Util.RuntimeOptions): DescribeFrontVulPatchListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.vulInfo)) {
    query['VulInfo'] = request.vulInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFrontVulPatchList',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFrontVulPatchList(request: DescribeFrontVulPatchListRequest): DescribeFrontVulPatchListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFrontVulPatchListWithOptions(request, runtime);
}

model DescribeGroupedVulRequest {
  currentPage?: int32(name='CurrentPage'),
  dealed?: string(name='Dealed'),
  lang?: string(name='Lang'),
  necessity?: string(name='Necessity'),
  officeSiteId?: string(name='OfficeSiteId'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
}

model DescribeGroupedVulResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  groupedVulItems?: [ 
    {
      aliasName?: string(name='AliasName'),
      asapCount?: int32(name='AsapCount'),
      gmtLast?: string(name='GmtLast'),
      handledCount?: int32(name='HandledCount'),
      laterCount?: int32(name='LaterCount'),
      name?: string(name='Name'),
      nntfCount?: int32(name='NntfCount'),
      tags?: string(name='Tags'),
      type?: string(name='Type'),
    }
  ](name='GroupedVulItems'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeGroupedVulResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGroupedVulResponseBody(name='body'),
}

async function describeGroupedVulWithOptions(request: DescribeGroupedVulRequest, runtime: Util.RuntimeOptions): DescribeGroupedVulResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.necessity)) {
    query['Necessity'] = request.necessity;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroupedVul',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGroupedVul(request: DescribeGroupedVulRequest): DescribeGroupedVulResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupedVulWithOptions(request, runtime);
}

model DescribeImageModifiedRecordsRequest {
  desktopId?: string(name='DesktopId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
}

model DescribeImageModifiedRecordsResponseBody = {
  imageModifiedRecords?: [ 
    {
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      newImageId?: string(name='NewImageId'),
      newImageName?: string(name='NewImageName'),
      status?: int32(name='Status'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='ImageModifiedRecords'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeImageModifiedRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageModifiedRecordsResponseBody(name='body'),
}

async function describeImageModifiedRecordsWithOptions(request: DescribeImageModifiedRecordsRequest, runtime: Util.RuntimeOptions): DescribeImageModifiedRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageModifiedRecords',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageModifiedRecords(request: DescribeImageModifiedRecordsRequest): DescribeImageModifiedRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageModifiedRecordsWithOptions(request, runtime);
}

model DescribeImagePermissionRequest {
  imageId?: string(name='ImageId'),
  regionId?: string(name='RegionId'),
}

model DescribeImagePermissionResponseBody = {
  aliUids?: [ string ](name='AliUids'),
  requestId?: string(name='RequestId'),
}

model DescribeImagePermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImagePermissionResponseBody(name='body'),
}

async function describeImagePermissionWithOptions(request: DescribeImagePermissionRequest, runtime: Util.RuntimeOptions): DescribeImagePermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImagePermission',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImagePermission(request: DescribeImagePermissionRequest): DescribeImagePermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImagePermissionWithOptions(request, runtime);
}

model DescribeImagesRequest {
  desktopInstanceType?: string(name='DesktopInstanceType'),
  gpuCategory?: boolean(name='GpuCategory'),
  gpuDriverVersion?: string(name='GpuDriverVersion'),
  imageId?: [ string ](name='ImageId'),
  imageStatus?: string(name='ImageStatus'),
  imageType?: string(name='ImageType'),
  languageType?: string(name='LanguageType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  osType?: string(name='OsType'),
  protocolType?: string(name='ProtocolType'),
  regionId?: string(name='RegionId'),
}

model DescribeImagesResponseBody = {
  images?: [ 
    {
      appVersion?: string(name='AppVersion'),
      creationTime?: string(name='CreationTime'),
      dataDiskSize?: int32(name='DataDiskSize'),
      description?: string(name='Description'),
      gpuCategory?: boolean(name='GpuCategory'),
      gpuDriverVersion?: string(name='GpuDriverVersion'),
      imageId?: string(name='ImageId'),
      imageType?: string(name='ImageType'),
      name?: string(name='Name'),
      osType?: string(name='OsType'),
      progress?: string(name='Progress'),
      protocolType?: string(name='ProtocolType'),
      sessionType?: string(name='SessionType'),
      sharedCount?: int32(name='SharedCount'),
      size?: int32(name='Size'),
      status?: string(name='Status'),
      supportedLanguages?: [ string ](name='SupportedLanguages'),
      volumeEncryptionEnabled?: boolean(name='VolumeEncryptionEnabled'),
      volumeEncryptionKey?: string(name='VolumeEncryptionKey'),
    }
  ](name='Images'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeImagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImagesResponseBody(name='body'),
}

async function describeImagesWithOptions(request: DescribeImagesRequest, runtime: Util.RuntimeOptions): DescribeImagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopInstanceType)) {
    query['DesktopInstanceType'] = request.desktopInstanceType;
  }
  if (!Util.isUnset(request.gpuCategory)) {
    query['GpuCategory'] = request.gpuCategory;
  }
  if (!Util.isUnset(request.gpuDriverVersion)) {
    query['GpuDriverVersion'] = request.gpuDriverVersion;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.imageStatus)) {
    query['ImageStatus'] = request.imageStatus;
  }
  if (!Util.isUnset(request.imageType)) {
    query['ImageType'] = request.imageType;
  }
  if (!Util.isUnset(request.languageType)) {
    query['LanguageType'] = request.languageType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImages',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImages(request: DescribeImagesRequest): DescribeImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImagesWithOptions(request, runtime);
}

model DescribeInvocationsRequest {
  commandType?: string(name='CommandType'),
  contentEncoding?: string(name='ContentEncoding'),
  desktopId?: string(name='DesktopId'),
  includeOutput?: boolean(name='IncludeOutput'),
  invokeId?: string(name='InvokeId'),
  invokeStatus?: string(name='InvokeStatus'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
}

model DescribeInvocationsResponseBody = {
  invocations?: [ 
    {
      commandContent?: string(name='CommandContent'),
      commandType?: string(name='CommandType'),
      creationTime?: string(name='CreationTime'),
      endUserId?: string(name='EndUserId'),
      invocationStatus?: string(name='InvocationStatus'),
      invokeDesktops?: [ 
        {
          creationTime?: string(name='CreationTime'),
          desktopId?: string(name='DesktopId'),
          dropped?: int32(name='Dropped'),
          errorCode?: string(name='ErrorCode'),
          errorInfo?: string(name='ErrorInfo'),
          exitCode?: long(name='ExitCode'),
          finishTime?: string(name='FinishTime'),
          invocationStatus?: string(name='InvocationStatus'),
          output?: string(name='Output'),
          repeats?: int32(name='Repeats'),
          startTime?: string(name='StartTime'),
          stopTime?: string(name='StopTime'),
          updateTime?: string(name='UpdateTime'),
        }
      ](name='InvokeDesktops'),
      invokeId?: string(name='InvokeId'),
    }
  ](name='Invocations'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeInvocationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInvocationsResponseBody(name='body'),
}

async function describeInvocationsWithOptions(request: DescribeInvocationsRequest, runtime: Util.RuntimeOptions): DescribeInvocationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.commandType)) {
    query['CommandType'] = request.commandType;
  }
  if (!Util.isUnset(request.contentEncoding)) {
    query['ContentEncoding'] = request.contentEncoding;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.includeOutput)) {
    query['IncludeOutput'] = request.includeOutput;
  }
  if (!Util.isUnset(request.invokeId)) {
    query['InvokeId'] = request.invokeId;
  }
  if (!Util.isUnset(request.invokeStatus)) {
    query['InvokeStatus'] = request.invokeStatus;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInvocations',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInvocations(request: DescribeInvocationsRequest): DescribeInvocationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInvocationsWithOptions(request, runtime);
}

model DescribeKmsKeysRequest {
  regionId?: string(name='RegionId'),
}

model DescribeKmsKeysResponseBody = {
  authorizeStatus?: string(name='AuthorizeStatus'),
  keys?: [ 
    {
      alias?: string(name='Alias'),
      arn?: string(name='Arn'),
      keyId?: string(name='KeyId'),
      type?: string(name='Type'),
    }
  ](name='Keys'),
  kmsServiceStatus?: string(name='KmsServiceStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeKmsKeysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeKmsKeysResponseBody(name='body'),
}

async function describeKmsKeysWithOptions(request: DescribeKmsKeysRequest, runtime: Util.RuntimeOptions): DescribeKmsKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeKmsKeys',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeKmsKeys(request: DescribeKmsKeysRequest): DescribeKmsKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeKmsKeysWithOptions(request, runtime);
}

model DescribeNASFileSystemsRequest {
  fileSystemId?: [ string ](name='FileSystemId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model DescribeNASFileSystemsResponseBody = {
  fileSystems?: [ 
    {
      capacity?: long(name='Capacity'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      encryptionEnabled?: boolean(name='EncryptionEnabled'),
      fileSystemId?: string(name='FileSystemId'),
      fileSystemName?: string(name='FileSystemName'),
      fileSystemStatus?: string(name='FileSystemStatus'),
      fileSystemType?: string(name='FileSystemType'),
      meteredSize?: long(name='MeteredSize'),
      mountTargetDomain?: string(name='MountTargetDomain'),
      mountTargetStatus?: string(name='MountTargetStatus'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      regionId?: string(name='RegionId'),
      storageType?: string(name='StorageType'),
      supportAcl?: boolean(name='SupportAcl'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='FileSystems'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeNASFileSystemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNASFileSystemsResponseBody(name='body'),
}

async function describeNASFileSystemsWithOptions(request: DescribeNASFileSystemsRequest, runtime: Util.RuntimeOptions): DescribeNASFileSystemsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNASFileSystems',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNASFileSystems(request: DescribeNASFileSystemsRequest): DescribeNASFileSystemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNASFileSystemsWithOptions(request, runtime);
}

model DescribeNetworkPackagesRequest {
  internetChargeType?: string(name='InternetChargeType'),
  maxResults?: int32(name='MaxResults'),
  networkPackageId?: [ string ](name='NetworkPackageId'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
}

model DescribeNetworkPackagesResponseBody = {
  networkPackages?: [ 
    {
      bandwidth?: int32(name='Bandwidth'),
      createTime?: string(name='CreateTime'),
      eipAddresses?: [ string ](name='EipAddresses'),
      expiredTime?: string(name='ExpiredTime'),
      internetChargeType?: string(name='InternetChargeType'),
      networkPackageId?: string(name='NetworkPackageId'),
      networkPackageStatus?: string(name='NetworkPackageStatus'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      officeSiteVpcType?: string(name='OfficeSiteVpcType'),
    }
  ](name='NetworkPackages'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeNetworkPackagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNetworkPackagesResponseBody(name='body'),
}

async function describeNetworkPackagesWithOptions(request: DescribeNetworkPackagesRequest, runtime: Util.RuntimeOptions): DescribeNetworkPackagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.networkPackageId)) {
    query['NetworkPackageId'] = request.networkPackageId;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNetworkPackages',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNetworkPackages(request: DescribeNetworkPackagesRequest): DescribeNetworkPackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNetworkPackagesWithOptions(request, runtime);
}

model DescribeOfficeSitesRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  officeSiteId?: [ string ](name='OfficeSiteId'),
  officeSiteType?: string(name='OfficeSiteType'),
  regionId?: string(name='RegionId'),
  status?: string(name='Status'),
}

model DescribeOfficeSitesResponseBody = {
  nextToken?: string(name='NextToken'),
  officeSites?: [ 
    {
      ADConnectors?: [ 
        {
          ADConnectorAddress?: string(name='ADConnectorAddress'),
          connectorStatus?: string(name='ConnectorStatus'),
          networkInterfaceId?: string(name='NetworkInterfaceId'),
          specification?: string(name='Specification'),
          trustKey?: string(name='TrustKey'),
          vSwitchId?: string(name='VSwitchId'),
        }
      ](name='ADConnectors'),
      adHostname?: string(name='AdHostname'),
      bandwidth?: int32(name='Bandwidth'),
      cenId?: string(name='CenId'),
      cidrBlock?: string(name='CidrBlock'),
      cloudBoxOfficeSite?: boolean(name='CloudBoxOfficeSite'),
      creationTime?: string(name='CreationTime'),
      customSecurityGroupId?: string(name='CustomSecurityGroupId'),
      desktopAccessType?: string(name='DesktopAccessType'),
      desktopCount?: long(name='DesktopCount'),
      desktopVpcEndpoint?: string(name='DesktopVpcEndpoint'),
      dnsAddress?: [ string ](name='DnsAddress'),
      dnsUserName?: string(name='DnsUserName'),
      domainName?: string(name='DomainName'),
      domainPassword?: string(name='DomainPassword'),
      domainUserName?: string(name='DomainUserName'),
      enableAdminAccess?: boolean(name='EnableAdminAccess'),
      enableCrossDesktopAccess?: boolean(name='EnableCrossDesktopAccess'),
      enableInternetAccess?: boolean(name='EnableInternetAccess'),
      fileSystemIds?: [ string ](name='FileSystemIds'),
      logs?: [ 
        {
          level?: string(name='Level'),
          message?: string(name='Message'),
          step?: string(name='Step'),
          timeStamp?: string(name='TimeStamp'),
        }
      ](name='Logs'),
      mfaEnabled?: boolean(name='MfaEnabled'),
      name?: string(name='Name'),
      needVerifyLoginRisk?: boolean(name='NeedVerifyLoginRisk'),
      needVerifyZeroDevice?: boolean(name='NeedVerifyZeroDevice'),
      networkPackageId?: string(name='NetworkPackageId'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteType?: string(name='OfficeSiteType'),
      ouName?: string(name='OuName'),
      protocolType?: string(name='ProtocolType'),
      ssoEnabled?: boolean(name='SsoEnabled'),
      ssoType?: string(name='SsoType'),
      status?: string(name='Status'),
      subDnsAddress?: [ string ](name='SubDnsAddress'),
      subDomainName?: string(name='SubDomainName'),
      trustPassword?: string(name='TrustPassword'),
      vSwitchIds?: [ string ](name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
      vpcType?: string(name='VpcType'),
    }
  ](name='OfficeSites'),
  requestId?: string(name='RequestId'),
}

model DescribeOfficeSitesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeOfficeSitesResponseBody(name='body'),
}

async function describeOfficeSitesWithOptions(request: DescribeOfficeSitesRequest, runtime: Util.RuntimeOptions): DescribeOfficeSitesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.officeSiteType)) {
    query['OfficeSiteType'] = request.officeSiteType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOfficeSites',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeOfficeSites(request: DescribeOfficeSitesRequest): DescribeOfficeSitesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOfficeSitesWithOptions(request, runtime);
}

model DescribePolicyGroupsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  policyGroupId?: [ string ](name='PolicyGroupId'),
  regionId?: string(name='RegionId'),
}

model DescribePolicyGroupsResponseBody = {
  describePolicyGroups?: [ 
    {
      appContentProtection?: string(name='AppContentProtection'),
      authorizeAccessPolicyRules?: [ 
        {
          cidrIp?: string(name='CidrIp'),
          description?: string(name='Description'),
        }
      ](name='AuthorizeAccessPolicyRules'),
      authorizeSecurityPolicyRules?: [ 
        {
          cidrIp?: string(name='CidrIp'),
          description?: string(name='Description'),
          ipProtocol?: string(name='IpProtocol'),
          policy?: string(name='Policy'),
          portRange?: string(name='PortRange'),
          priority?: string(name='Priority'),
          type?: string(name='Type'),
        }
      ](name='AuthorizeSecurityPolicyRules'),
      cameraRedirect?: string(name='CameraRedirect'),
      clientTypes?: [ 
        {
          clientType?: string(name='ClientType'),
          status?: string(name='Status'),
        }
      ](name='ClientTypes'),
      clipboard?: string(name='Clipboard'),
      domainList?: string(name='DomainList'),
      edsCount?: int32(name='EdsCount'),
      gpuAcceleration?: string(name='GpuAcceleration'),
      html5Access?: string(name='Html5Access'),
      html5FileTransfer?: string(name='Html5FileTransfer'),
      localDrive?: string(name='LocalDrive'),
      name?: string(name='Name'),
      netRedirect?: string(name='NetRedirect'),
      policyGroupId?: string(name='PolicyGroupId'),
      policyGroupType?: string(name='PolicyGroupType'),
      policyStatus?: string(name='PolicyStatus'),
      preemptLogin?: string(name='PreemptLogin'),
      preemptLoginUsers?: [ string ](name='PreemptLoginUsers'),
      printerRedirection?: string(name='PrinterRedirection'),
      recordContent?: string(name='RecordContent'),
      recordContentExpires?: long(name='RecordContentExpires'),
      recording?: string(name='Recording'),
      recordingEndTime?: string(name='RecordingEndTime'),
      recordingExpires?: long(name='RecordingExpires'),
      recordingFps?: long(name='RecordingFps'),
      recordingStartTime?: string(name='RecordingStartTime'),
      remoteCoordinate?: string(name='RemoteCoordinate'),
      usbRedirect?: string(name='UsbRedirect'),
      usbSupplyRedirectRule?: [ 
        {
          description?: string(name='Description'),
          deviceClass?: string(name='DeviceClass'),
          deviceSubclass?: string(name='DeviceSubclass'),
          productId?: string(name='ProductId'),
          usbRedirectType?: long(name='UsbRedirectType'),
          usbRuleType?: long(name='UsbRuleType'),
          vendorId?: string(name='VendorId'),
        }
      ](name='UsbSupplyRedirectRule'),
      visualQuality?: string(name='VisualQuality'),
      watermark?: string(name='Watermark'),
      watermarkCustomText?: string(name='WatermarkCustomText'),
      watermarkTransparency?: string(name='WatermarkTransparency'),
      watermarkType?: string(name='WatermarkType'),
    }
  ](name='DescribePolicyGroups'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribePolicyGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePolicyGroupsResponseBody(name='body'),
}

async function describePolicyGroupsWithOptions(request: DescribePolicyGroupsRequest, runtime: Util.RuntimeOptions): DescribePolicyGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.policyGroupId)) {
    query['PolicyGroupId'] = request.policyGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePolicyGroups',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePolicyGroups(request: DescribePolicyGroupsRequest): DescribePolicyGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePolicyGroupsWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  regionId?: string(name='RegionId'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeScanTaskProgressRequest {
  regionId?: string(name='RegionId'),
  taskId?: long(name='TaskId'),
}

model DescribeScanTaskProgressResponseBody = {
  createTime?: string(name='CreateTime'),
  requestId?: string(name='RequestId'),
  taskStatus?: string(name='TaskStatus'),
}

model DescribeScanTaskProgressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeScanTaskProgressResponseBody(name='body'),
}

async function describeScanTaskProgressWithOptions(request: DescribeScanTaskProgressRequest, runtime: Util.RuntimeOptions): DescribeScanTaskProgressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScanTaskProgress',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeScanTaskProgress(request: DescribeScanTaskProgressRequest): DescribeScanTaskProgressResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScanTaskProgressWithOptions(request, runtime);
}

model DescribeSecurityEventOperationStatusRequest {
  regionId?: string(name='RegionId'),
  securityEventId?: [ string ](name='SecurityEventId'),
  taskId?: long(name='TaskId'),
}

model DescribeSecurityEventOperationStatusResponseBody = {
  requestId?: string(name='RequestId'),
  securityEventOperationStatuses?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      securityEventId?: long(name='SecurityEventId'),
      status?: string(name='Status'),
    }
  ](name='SecurityEventOperationStatuses'),
  taskStatus?: string(name='TaskStatus'),
}

model DescribeSecurityEventOperationStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSecurityEventOperationStatusResponseBody(name='body'),
}

async function describeSecurityEventOperationStatusWithOptions(request: DescribeSecurityEventOperationStatusRequest, runtime: Util.RuntimeOptions): DescribeSecurityEventOperationStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityEventId)) {
    query['SecurityEventId'] = request.securityEventId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityEventOperationStatus',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSecurityEventOperationStatus(request: DescribeSecurityEventOperationStatusRequest): DescribeSecurityEventOperationStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityEventOperationStatusWithOptions(request, runtime);
}

model DescribeSecurityEventOperationsRequest {
  regionId?: string(name='RegionId'),
  securityEventId?: long(name='SecurityEventId'),
}

model DescribeSecurityEventOperationsResponseBody = {
  requestId?: string(name='RequestId'),
  securityEventOperations?: [ 
    {
      operationCode?: string(name='OperationCode'),
      operationParams?: string(name='OperationParams'),
      userCanOperate?: boolean(name='UserCanOperate'),
    }
  ](name='SecurityEventOperations'),
}

model DescribeSecurityEventOperationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSecurityEventOperationsResponseBody(name='body'),
}

async function describeSecurityEventOperationsWithOptions(request: DescribeSecurityEventOperationsRequest, runtime: Util.RuntimeOptions): DescribeSecurityEventOperationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityEventId)) {
    query['SecurityEventId'] = request.securityEventId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityEventOperations',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSecurityEventOperations(request: DescribeSecurityEventOperationsRequest): DescribeSecurityEventOperationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityEventOperationsWithOptions(request, runtime);
}

model DescribeSnapshotsRequest {
  desktopId?: string(name='DesktopId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  snapshotId?: string(name='SnapshotId'),
}

model DescribeSnapshotsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  snapshots?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      desktopId?: string(name='DesktopId'),
      progress?: string(name='Progress'),
      protocolType?: string(name='ProtocolType'),
      remainTime?: int32(name='RemainTime'),
      snapshotId?: string(name='SnapshotId'),
      snapshotName?: string(name='SnapshotName'),
      snapshotType?: string(name='SnapshotType'),
      sourceDiskSize?: string(name='SourceDiskSize'),
      sourceDiskType?: string(name='SourceDiskType'),
      status?: string(name='Status'),
      volumeEncryptionEnabled?: boolean(name='VolumeEncryptionEnabled'),
      volumeEncryptionKey?: string(name='VolumeEncryptionKey'),
    }
  ](name='Snapshots'),
}

model DescribeSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSnapshotsResponseBody(name='body'),
}

async function describeSnapshotsWithOptions(request: DescribeSnapshotsRequest, runtime: Util.RuntimeOptions): DescribeSnapshotsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSnapshots',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSnapshots(request: DescribeSnapshotsRequest): DescribeSnapshotsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSnapshotsWithOptions(request, runtime);
}

model DescribeSuspEventOverviewRequest {
  regionId?: string(name='RegionId'),
}

model DescribeSuspEventOverviewResponseBody = {
  remindCount?: int32(name='RemindCount'),
  requestId?: string(name='RequestId'),
  seriousCount?: int32(name='SeriousCount'),
  suspiciousCount?: int32(name='SuspiciousCount'),
}

model DescribeSuspEventOverviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSuspEventOverviewResponseBody(name='body'),
}

async function describeSuspEventOverviewWithOptions(request: DescribeSuspEventOverviewRequest, runtime: Util.RuntimeOptions): DescribeSuspEventOverviewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSuspEventOverview',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSuspEventOverview(request: DescribeSuspEventOverviewRequest): DescribeSuspEventOverviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSuspEventOverviewWithOptions(request, runtime);
}

model DescribeSuspEventQuaraFilesRequest {
  currentPage?: int32(name='CurrentPage'),
  officeSiteId?: string(name='OfficeSiteId'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  status?: string(name='Status'),
}

model DescribeSuspEventQuaraFilesResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  quaraFiles?: [ 
    {
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      eventName?: string(name='EventName'),
      eventType?: string(name='EventType'),
      id?: int32(name='Id'),
      md5?: string(name='Md5'),
      modifyTime?: string(name='ModifyTime'),
      path?: string(name='Path'),
      status?: string(name='Status'),
      tag?: string(name='Tag'),
    }
  ](name='QuaraFiles'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSuspEventQuaraFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSuspEventQuaraFilesResponseBody(name='body'),
}

async function describeSuspEventQuaraFilesWithOptions(request: DescribeSuspEventQuaraFilesRequest, runtime: Util.RuntimeOptions): DescribeSuspEventQuaraFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSuspEventQuaraFiles',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSuspEventQuaraFiles(request: DescribeSuspEventQuaraFilesRequest): DescribeSuspEventQuaraFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSuspEventQuaraFilesWithOptions(request, runtime);
}

model DescribeSuspEventsRequest {
  alarmUniqueInfo?: string(name='AlarmUniqueInfo'),
  currentPage?: int32(name='CurrentPage'),
  dealed?: string(name='Dealed'),
  lang?: string(name='Lang'),
  levels?: string(name='Levels'),
  officeSiteId?: string(name='OfficeSiteId'),
  pageSize?: int32(name='PageSize'),
  parentEventType?: string(name='ParentEventType'),
  regionId?: string(name='RegionId'),
}

model DescribeSuspEventsResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId'),
  suspEvents?: [ 
    {
      alarmEventName?: string(name='AlarmEventName'),
      alarmEventNameDisplay?: string(name='AlarmEventNameDisplay'),
      alarmEventType?: string(name='AlarmEventType'),
      alarmEventTypeDisplay?: string(name='AlarmEventTypeDisplay'),
      alarmUniqueInfo?: string(name='AlarmUniqueInfo'),
      canBeDealOnLine?: string(name='CanBeDealOnLine'),
      canCancelFault?: boolean(name='CanCancelFault'),
      dataSource?: string(name='DataSource'),
      desc?: string(name='Desc'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      details?: [ 
        {
          name?: string(name='Name'),
          nameDisplay?: string(name='NameDisplay'),
          type?: string(name='Type'),
          value?: string(name='Value'),
          valueDisplay?: string(name='ValueDisplay'),
        }
      ](name='Details'),
      eventStatus?: int32(name='EventStatus'),
      eventSubType?: string(name='EventSubType'),
      id?: long(name='Id'),
      lastTime?: string(name='LastTime'),
      level?: string(name='Level'),
      name?: string(name='Name'),
      occurrenceTime?: string(name='OccurrenceTime'),
      operateErrorCode?: string(name='OperateErrorCode'),
      operateMsg?: string(name='OperateMsg'),
      uniqueInfo?: string(name='UniqueInfo'),
    }
  ](name='SuspEvents'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSuspEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSuspEventsResponseBody(name='body'),
}

async function describeSuspEventsWithOptions(request: DescribeSuspEventsRequest, runtime: Util.RuntimeOptions): DescribeSuspEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alarmUniqueInfo)) {
    query['AlarmUniqueInfo'] = request.alarmUniqueInfo;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.levels)) {
    query['Levels'] = request.levels;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parentEventType)) {
    query['ParentEventType'] = request.parentEventType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSuspEvents',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSuspEvents(request: DescribeSuspEventsRequest): DescribeSuspEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSuspEventsWithOptions(request, runtime);
}

model DescribeUserConnectionRecordsRequest {
  connectDurationFrom?: long(name='ConnectDurationFrom'),
  connectDurationTo?: long(name='ConnectDurationTo'),
  connectEndTimeFrom?: long(name='ConnectEndTimeFrom'),
  connectEndTimeTo?: long(name='ConnectEndTimeTo'),
  connectStartTimeFrom?: long(name='ConnectStartTimeFrom'),
  connectStartTimeTo?: long(name='ConnectStartTimeTo'),
  desktopGroupId?: string(name='DesktopGroupId'),
  desktopId?: string(name='DesktopId'),
  endUserId?: string(name='EndUserId'),
  endUserType?: string(name='EndUserType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
}

model DescribeUserConnectionRecordsResponseBody = {
  connectionRecords?: [ 
    {
      connectDuration?: string(name='ConnectDuration'),
      connectEndTime?: string(name='ConnectEndTime'),
      connectStartTime?: string(name='ConnectStartTime'),
      connectionRecordId?: string(name='ConnectionRecordId'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
    }
  ](name='ConnectionRecords'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeUserConnectionRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUserConnectionRecordsResponseBody(name='body'),
}

async function describeUserConnectionRecordsWithOptions(request: DescribeUserConnectionRecordsRequest, runtime: Util.RuntimeOptions): DescribeUserConnectionRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectDurationFrom)) {
    query['ConnectDurationFrom'] = request.connectDurationFrom;
  }
  if (!Util.isUnset(request.connectDurationTo)) {
    query['ConnectDurationTo'] = request.connectDurationTo;
  }
  if (!Util.isUnset(request.connectEndTimeFrom)) {
    query['ConnectEndTimeFrom'] = request.connectEndTimeFrom;
  }
  if (!Util.isUnset(request.connectEndTimeTo)) {
    query['ConnectEndTimeTo'] = request.connectEndTimeTo;
  }
  if (!Util.isUnset(request.connectStartTimeFrom)) {
    query['ConnectStartTimeFrom'] = request.connectStartTimeFrom;
  }
  if (!Util.isUnset(request.connectStartTimeTo)) {
    query['ConnectStartTimeTo'] = request.connectStartTimeTo;
  }
  if (!Util.isUnset(request.desktopGroupId)) {
    query['DesktopGroupId'] = request.desktopGroupId;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.endUserType)) {
    query['EndUserType'] = request.endUserType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserConnectionRecords',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUserConnectionRecords(request: DescribeUserConnectionRecordsRequest): DescribeUserConnectionRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserConnectionRecordsWithOptions(request, runtime);
}

model DescribeUsersInGroupRequest {
  connectState?: int32(name='ConnectState'),
  desktopGroupId?: string(name='DesktopGroupId'),
  endUserId?: string(name='EndUserId'),
  filter?: string(name='Filter'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  orgId?: string(name='OrgId'),
  queryUserDetail?: boolean(name='QueryUserDetail'),
  regionId?: string(name='RegionId'),
}

model DescribeUsersInGroupResponseBody = {
  endUsers?: [ 
    {
      connectionStatus?: string(name='ConnectionStatus'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      displayName?: string(name='DisplayName'),
      endUserEmail?: string(name='EndUserEmail'),
      endUserId?: string(name='EndUserId'),
      endUserName?: string(name='EndUserName'),
      endUserPhone?: string(name='EndUserPhone'),
      endUserRemark?: string(name='EndUserRemark'),
      endUserType?: string(name='EndUserType'),
      externalInfo?: {
        externalName?: string(name='ExternalName'),
        jobNumber?: string(name='JobNumber'),
      }(name='ExternalInfo'),
      userDesktopId?: string(name='UserDesktopId'),
      userSetPropertiesModels?: [ 
        {
          propertyId?: long(name='PropertyId'),
          propertyKey?: string(name='PropertyKey'),
          propertyType?: int32(name='PropertyType'),
          propertyValues?: [ 
            {
              propertyValue?: string(name='PropertyValue'),
              propertyValueId?: long(name='PropertyValueId'),
            }
          ](name='PropertyValues'),
          userId?: long(name='UserId'),
          userName?: string(name='UserName'),
        }
      ](name='UserSetPropertiesModels'),
    }
  ](name='EndUsers'),
  nextToken?: string(name='NextToken'),
  onlineUsersCount?: int32(name='OnlineUsersCount'),
  requestId?: string(name='RequestId'),
  usersCount?: int32(name='UsersCount'),
}

model DescribeUsersInGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUsersInGroupResponseBody(name='body'),
}

async function describeUsersInGroupWithOptions(request: DescribeUsersInGroupRequest, runtime: Util.RuntimeOptions): DescribeUsersInGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectState)) {
    query['ConnectState'] = request.connectState;
  }
  if (!Util.isUnset(request.desktopGroupId)) {
    query['DesktopGroupId'] = request.desktopGroupId;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.orgId)) {
    query['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.queryUserDetail)) {
    query['QueryUserDetail'] = request.queryUserDetail;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUsersInGroup',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUsersInGroup(request: DescribeUsersInGroupRequest): DescribeUsersInGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUsersInGroupWithOptions(request, runtime);
}

model DescribeUsersPasswordRequest {
  desktopId?: string(name='DesktopId'),
  regionId?: string(name='RegionId'),
}

model DescribeUsersPasswordResponseBody = {
  desktopUsers?: [ 
    {
      displayName?: string(name='DisplayName'),
      endUserId?: string(name='EndUserId'),
      password?: string(name='Password'),
    }
  ](name='DesktopUsers'),
  requestId?: string(name='RequestId'),
}

model DescribeUsersPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUsersPasswordResponseBody(name='body'),
}

async function describeUsersPasswordWithOptions(request: DescribeUsersPasswordRequest, runtime: Util.RuntimeOptions): DescribeUsersPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUsersPassword',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUsersPassword(request: DescribeUsersPasswordRequest): DescribeUsersPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUsersPasswordWithOptions(request, runtime);
}

model DescribeVirtualMFADevicesRequest {
  endUserId?: [ string ](name='EndUserId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model DescribeVirtualMFADevicesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  virtualMFADevices?: [ 
    {
      consecutiveFails?: int32(name='ConsecutiveFails'),
      directoryId?: string(name='DirectoryId'),
      endUserId?: string(name='EndUserId'),
      gmtEnabled?: string(name='GmtEnabled'),
      gmtUnlock?: string(name='GmtUnlock'),
      officeSiteId?: string(name='OfficeSiteId'),
      serialNumber?: string(name='SerialNumber'),
      status?: string(name='status'),
    }
  ](name='VirtualMFADevices'),
}

model DescribeVirtualMFADevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVirtualMFADevicesResponseBody(name='body'),
}

async function describeVirtualMFADevicesWithOptions(request: DescribeVirtualMFADevicesRequest, runtime: Util.RuntimeOptions): DescribeVirtualMFADevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVirtualMFADevices',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVirtualMFADevices(request: DescribeVirtualMFADevicesRequest): DescribeVirtualMFADevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVirtualMFADevicesWithOptions(request, runtime);
}

model DescribeVulDetailsRequest {
  aliasName?: string(name='AliasName'),
  lang?: string(name='Lang'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
}

model DescribeVulDetailsResponseBody = {
  cves?: [ 
    {
      cveId?: string(name='CveId'),
      cvssScore?: string(name='CvssScore'),
      summary?: string(name='Summary'),
      title?: string(name='Title'),
    }
  ](name='Cves'),
  requestId?: string(name='RequestId'),
}

model DescribeVulDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVulDetailsResponseBody(name='body'),
}

async function describeVulDetailsWithOptions(request: DescribeVulDetailsRequest, runtime: Util.RuntimeOptions): DescribeVulDetailsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulDetails',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVulDetails(request: DescribeVulDetailsRequest): DescribeVulDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulDetailsWithOptions(request, runtime);
}

model DescribeVulListRequest {
  aliasName?: string(name='AliasName'),
  currentPage?: int32(name='CurrentPage'),
  dealed?: string(name='Dealed'),
  lang?: string(name='Lang'),
  name?: string(name='Name'),
  necessity?: string(name='Necessity'),
  officeSiteId?: string(name='OfficeSiteId'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
}

model DescribeVulListResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vulRecords?: [ 
    {
      aliasName?: string(name='AliasName'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      extendContentJson?: {
        rpmEntityList?: [ 
          {
            fullVersion?: string(name='FullVersion'),
            matchDetail?: string(name='MatchDetail'),
            name?: string(name='Name'),
            path?: string(name='Path'),
            updateCmd?: string(name='UpdateCmd'),
          }
        ](name='RpmEntityList'),
      }(name='ExtendContentJson'),
      firstTs?: long(name='FirstTs'),
      lastTs?: long(name='LastTs'),
      modifyTs?: long(name='ModifyTs'),
      name?: string(name='Name'),
      necessity?: string(name='Necessity'),
      online?: boolean(name='Online'),
      osVersion?: string(name='OsVersion'),
      related?: string(name='Related'),
      repairTs?: long(name='RepairTs'),
      resultCode?: string(name='ResultCode'),
      resultMessage?: string(name='ResultMessage'),
      status?: int32(name='Status'),
      tag?: string(name='Tag'),
      type?: string(name='Type'),
    }
  ](name='VulRecords'),
}

model DescribeVulListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVulListResponseBody(name='body'),
}

async function describeVulListWithOptions(request: DescribeVulListRequest, runtime: Util.RuntimeOptions): DescribeVulListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.dealed)) {
    query['Dealed'] = request.dealed;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.necessity)) {
    query['Necessity'] = request.necessity;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulList',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVulList(request: DescribeVulListRequest): DescribeVulListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulListWithOptions(request, runtime);
}

model DescribeVulOverviewRequest {
  regionId?: string(name='RegionId'),
}

model DescribeVulOverviewResponseBody = {
  asapCount?: int32(name='AsapCount'),
  laterCount?: int32(name='LaterCount'),
  nntfCount?: int32(name='NntfCount'),
  requestId?: string(name='RequestId'),
}

model DescribeVulOverviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVulOverviewResponseBody(name='body'),
}

async function describeVulOverviewWithOptions(request: DescribeVulOverviewRequest, runtime: Util.RuntimeOptions): DescribeVulOverviewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVulOverview',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVulOverview(request: DescribeVulOverviewRequest): DescribeVulOverviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVulOverviewWithOptions(request, runtime);
}

model DescribeZonesRequest {
  regionId?: string(name='RegionId'),
  zoneType?: string(name='ZoneType'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: [ 
    {
      zoneId?: string(name='ZoneId'),
    }
  ](name='Zones'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeZonesResponseBody(name='body'),
}

async function describeZonesWithOptions(request: DescribeZonesRequest, runtime: Util.RuntimeOptions): DescribeZonesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.zoneType)) {
    query['ZoneType'] = request.zoneType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeZones',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeZonesWithOptions(request, runtime);
}

model DetachCenRequest {
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model DetachCenResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachCenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachCenResponseBody(name='body'),
}

async function detachCenWithOptions(request: DetachCenRequest, runtime: Util.RuntimeOptions): DetachCenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachCen',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachCen(request: DetachCenRequest): DetachCenResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachCenWithOptions(request, runtime);
}

model DisableDesktopsInGroupRequest {
  desktopGroupId?: string(name='DesktopGroupId'),
  desktopIds?: [ string ](name='DesktopIds'),
  regionId?: string(name='RegionId'),
}

model DisableDesktopsInGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableDesktopsInGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableDesktopsInGroupResponseBody(name='body'),
}

async function disableDesktopsInGroupWithOptions(request: DisableDesktopsInGroupRequest, runtime: Util.RuntimeOptions): DisableDesktopsInGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopGroupId)) {
    query['DesktopGroupId'] = request.desktopGroupId;
  }
  if (!Util.isUnset(request.desktopIds)) {
    query['DesktopIds'] = request.desktopIds;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableDesktopsInGroup',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableDesktopsInGroup(request: DisableDesktopsInGroupRequest): DisableDesktopsInGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableDesktopsInGroupWithOptions(request, runtime);
}

model DissociateNetworkPackageRequest {
  networkPackageId?: string(name='NetworkPackageId'),
  regionId?: string(name='RegionId'),
}

model DissociateNetworkPackageResponseBody = {
  requestId?: string(name='RequestId'),
}

model DissociateNetworkPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DissociateNetworkPackageResponseBody(name='body'),
}

async function dissociateNetworkPackageWithOptions(request: DissociateNetworkPackageRequest, runtime: Util.RuntimeOptions): DissociateNetworkPackageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.networkPackageId)) {
    query['NetworkPackageId'] = request.networkPackageId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DissociateNetworkPackage',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function dissociateNetworkPackage(request: DissociateNetworkPackageRequest): DissociateNetworkPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return dissociateNetworkPackageWithOptions(request, runtime);
}

model ExportClientEventsRequest {
  desktopId?: string(name='DesktopId'),
  desktopName?: string(name='DesktopName'),
  endTime?: string(name='EndTime'),
  endUserId?: string(name='EndUserId'),
  eventType?: string(name='EventType'),
  eventTypes?: [ string ](name='EventTypes'),
  maxResults?: int32(name='MaxResults'),
  officeSiteId?: string(name='OfficeSiteId'),
  officeSiteName?: string(name='OfficeSiteName'),
  regionId?: string(name='RegionId'),
  startTime?: string(name='StartTime'),
}

model ExportClientEventsResponseBody = {
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model ExportClientEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExportClientEventsResponseBody(name='body'),
}

async function exportClientEventsWithOptions(request: ExportClientEventsRequest, runtime: Util.RuntimeOptions): ExportClientEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.desktopName)) {
    query['DesktopName'] = request.desktopName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.eventTypes)) {
    query['EventTypes'] = request.eventTypes;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.officeSiteName)) {
    query['OfficeSiteName'] = request.officeSiteName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportClientEvents',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportClientEvents(request: ExportClientEventsRequest): ExportClientEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportClientEventsWithOptions(request, runtime);
}

model ExportDesktopGroupInfoRequest {
  chargeType?: string(name='ChargeType'),
  desktopGroupId?: [ string ](name='DesktopGroupId'),
  desktopGroupName?: string(name='DesktopGroupName'),
  endUserId?: [ string ](name='EndUserId'),
  expiredTime?: string(name='ExpiredTime'),
  langType?: string(name='LangType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  policyGroupId?: string(name='PolicyGroupId'),
  regionId?: string(name='RegionId'),
}

model ExportDesktopGroupInfoResponseBody = {
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model ExportDesktopGroupInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExportDesktopGroupInfoResponseBody(name='body'),
}

async function exportDesktopGroupInfoWithOptions(request: ExportDesktopGroupInfoRequest, runtime: Util.RuntimeOptions): ExportDesktopGroupInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.desktopGroupId)) {
    query['DesktopGroupId'] = request.desktopGroupId;
  }
  if (!Util.isUnset(request.desktopGroupName)) {
    query['DesktopGroupName'] = request.desktopGroupName;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.expiredTime)) {
    query['ExpiredTime'] = request.expiredTime;
  }
  if (!Util.isUnset(request.langType)) {
    query['LangType'] = request.langType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.policyGroupId)) {
    query['PolicyGroupId'] = request.policyGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportDesktopGroupInfo',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportDesktopGroupInfo(request: ExportDesktopGroupInfoRequest): ExportDesktopGroupInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportDesktopGroupInfoWithOptions(request, runtime);
}

model ExportDesktopListInfoRequest {
  chargeType?: string(name='ChargeType'),
  desktopId?: [ string ](name='DesktopId'),
  desktopName?: string(name='DesktopName'),
  desktopStatus?: string(name='DesktopStatus'),
  endUserId?: [ string ](name='EndUserId'),
  expiredTime?: string(name='ExpiredTime'),
  groupId?: string(name='GroupId'),
  langType?: string(name='LangType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  policyGroupId?: string(name='PolicyGroupId'),
  regionId?: string(name='RegionId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  userName?: string(name='UserName'),
}

model ExportDesktopListInfoResponseBody = {
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model ExportDesktopListInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExportDesktopListInfoResponseBody(name='body'),
}

async function exportDesktopListInfoWithOptions(request: ExportDesktopListInfoRequest, runtime: Util.RuntimeOptions): ExportDesktopListInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.desktopName)) {
    query['DesktopName'] = request.desktopName;
  }
  if (!Util.isUnset(request.desktopStatus)) {
    query['DesktopStatus'] = request.desktopStatus;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.expiredTime)) {
    query['ExpiredTime'] = request.expiredTime;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.langType)) {
    query['LangType'] = request.langType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.policyGroupId)) {
    query['PolicyGroupId'] = request.policyGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportDesktopListInfo',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportDesktopListInfo(request: ExportDesktopListInfoRequest): ExportDesktopListInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportDesktopListInfoWithOptions(request, runtime);
}

model GetConnectionTicketRequest {
  commandContent?: string(name='CommandContent'),
  desktopId?: string(name='DesktopId'),
  endUserId?: string(name='EndUserId'),
  ownerId?: long(name='OwnerId'),
  password?: string(name='Password'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  taskId?: string(name='TaskId'),
  uuid?: string(name='Uuid'),
}

model GetConnectionTicketResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  taskStatus?: string(name='TaskStatus'),
  ticket?: string(name='Ticket'),
}

model GetConnectionTicketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConnectionTicketResponseBody(name='body'),
}

async function getConnectionTicketWithOptions(request: GetConnectionTicketRequest, runtime: Util.RuntimeOptions): GetConnectionTicketResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.commandContent)) {
    query['CommandContent'] = request.commandContent;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetConnectionTicket',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConnectionTicket(request: GetConnectionTicketRequest): GetConnectionTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConnectionTicketWithOptions(request, runtime);
}

model GetDesktopGroupDetailRequest {
  desktopGroupId?: string(name='DesktopGroupId'),
  regionId?: string(name='RegionId'),
}

model GetDesktopGroupDetailResponseBody = {
  desktops?: {
    allowAutoSetup?: int32(name='AllowAutoSetup'),
    allowBufferCount?: int32(name='AllowBufferCount'),
    bindAmount?: int32(name='BindAmount'),
    comments?: string(name='Comments'),
    connectDuration?: long(name='ConnectDuration'),
    cpu?: int32(name='Cpu'),
    creationTime?: string(name='CreationTime'),
    creator?: string(name='Creator'),
    dataDiskCategory?: string(name='DataDiskCategory'),
    dataDiskSize?: string(name='DataDiskSize'),
    desktopGroupId?: string(name='DesktopGroupId'),
    desktopGroupName?: string(name='DesktopGroupName'),
    directoryId?: string(name='DirectoryId'),
    directoryType?: string(name='DirectoryType'),
    expiredTime?: string(name='ExpiredTime'),
    gpuCount?: float(name='GpuCount'),
    gpuSpec?: string(name='GpuSpec'),
    idleDisconnectDuration?: long(name='IdleDisconnectDuration'),
    keepDuration?: long(name='KeepDuration'),
    loadPolicy?: int32(name='LoadPolicy'),
    maxDesktopsCount?: int32(name='MaxDesktopsCount'),
    memory?: long(name='Memory'),
    minDesktopsCount?: int32(name='MinDesktopsCount'),
    nasFileSystemID?: string(name='NasFileSystemID'),
    nasFileSystemName?: string(name='NasFileSystemName'),
    officeSiteId?: string(name='OfficeSiteId'),
    officeSiteName?: string(name='OfficeSiteName'),
    officeSiteType?: string(name='OfficeSiteType'),
    ownBundleId?: string(name='OwnBundleId'),
    ownBundleName?: string(name='OwnBundleName'),
    ownType?: int32(name='OwnType'),
    payType?: string(name='PayType'),
    policyGroupId?: string(name='PolicyGroupId'),
    policyGroupName?: string(name='PolicyGroupName'),
    profileFollowSwitch?: boolean(name='ProfileFollowSwitch'),
    ratioThreshold?: float(name='RatioThreshold'),
    resType?: int32(name='ResType'),
    resetType?: int32(name='ResetType'),
    status?: int32(name='Status'),
    stopDuration?: long(name='StopDuration'),
    systemDiskCategory?: string(name='SystemDiskCategory'),
    systemDiskSize?: int32(name='SystemDiskSize'),
    timerInfos?: [ 
      {
        cronExpression?: string(name='CronExpression'),
        forced?: boolean(name='Forced'),
        status?: int32(name='Status'),
        timerType?: int32(name='TimerType'),
      }
    ](name='TimerInfos'),
    version?: long(name='Version'),
  }(name='Desktops'),
  requestId?: string(name='RequestId'),
}

model GetDesktopGroupDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDesktopGroupDetailResponseBody(name='body'),
}

async function getDesktopGroupDetailWithOptions(request: GetDesktopGroupDetailRequest, runtime: Util.RuntimeOptions): GetDesktopGroupDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopGroupId)) {
    query['DesktopGroupId'] = request.desktopGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDesktopGroupDetail',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDesktopGroupDetail(request: GetDesktopGroupDetailRequest): GetDesktopGroupDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDesktopGroupDetailWithOptions(request, runtime);
}

model GetOfficeSiteSsoStatusRequest {
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model GetOfficeSiteSsoStatusResponseBody = {
  requestId?: string(name='RequestId'),
  ssoStatus?: boolean(name='SsoStatus'),
}

model GetOfficeSiteSsoStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOfficeSiteSsoStatusResponseBody(name='body'),
}

async function getOfficeSiteSsoStatusWithOptions(request: GetOfficeSiteSsoStatusRequest, runtime: Util.RuntimeOptions): GetOfficeSiteSsoStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOfficeSiteSsoStatus',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOfficeSiteSsoStatus(request: GetOfficeSiteSsoStatusRequest): GetOfficeSiteSsoStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOfficeSiteSsoStatusWithOptions(request, runtime);
}

model GetSpMetadataRequest {
  directoryId?: string(name='DirectoryId'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model GetSpMetadataResponseBody = {
  requestId?: string(name='RequestId'),
  spMetadata?: string(name='SpMetadata'),
}

model GetSpMetadataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSpMetadataResponseBody(name='body'),
}

async function getSpMetadataWithOptions(request: GetSpMetadataRequest, runtime: Util.RuntimeOptions): GetSpMetadataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSpMetadata',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSpMetadata(request: GetSpMetadataRequest): GetSpMetadataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSpMetadataWithOptions(request, runtime);
}

model HandleSecurityEventsRequest {
  operationCode?: string(name='OperationCode'),
  operationParams?: string(name='OperationParams'),
  regionId?: string(name='RegionId'),
  securityEvent?: [ 
    {
      desktopId?: string(name='DesktopId'),
      securityEventId?: string(name='SecurityEventId'),
    }
  ](name='SecurityEvent'),
}

model HandleSecurityEventsResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: long(name='TaskId'),
}

model HandleSecurityEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: HandleSecurityEventsResponseBody(name='body'),
}

async function handleSecurityEventsWithOptions(request: HandleSecurityEventsRequest, runtime: Util.RuntimeOptions): HandleSecurityEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.operationCode)) {
    query['OperationCode'] = request.operationCode;
  }
  if (!Util.isUnset(request.operationParams)) {
    query['OperationParams'] = request.operationParams;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityEvent)) {
    query['SecurityEvent'] = request.securityEvent;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'HandleSecurityEvents',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function handleSecurityEvents(request: HandleSecurityEventsRequest): HandleSecurityEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return handleSecurityEventsWithOptions(request, runtime);
}

model ListDirectoryUsersRequest {
  directoryId?: string(name='DirectoryId'),
  filter?: string(name='Filter'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  OUPath?: string(name='OUPath'),
  regionId?: string(name='RegionId'),
}

model ListDirectoryUsersResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  users?: [ 
    {
      displayName?: string(name='DisplayName'),
      endUser?: string(name='EndUser'),
    }
  ](name='Users'),
}

model ListDirectoryUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDirectoryUsersResponseBody(name='body'),
}

async function listDirectoryUsersWithOptions(request: ListDirectoryUsersRequest, runtime: Util.RuntimeOptions): ListDirectoryUsersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.OUPath)) {
    query['OUPath'] = request.OUPath;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDirectoryUsers',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDirectoryUsers(request: ListDirectoryUsersRequest): ListDirectoryUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDirectoryUsersWithOptions(request, runtime);
}

model ListOfficeSiteOverviewRequest {
  forceRefresh?: boolean(name='ForceRefresh'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  officeSiteId?: [ string ](name='OfficeSiteId'),
  queryRange?: int32(name='QueryRange'),
  regionId?: string(name='RegionId'),
}

model ListOfficeSiteOverviewResponseBody = {
  nextToken?: string(name='NextToken'),
  officeSiteOverviewResults?: [ 
    {
      hasExpiredEdsCount?: int32(name='HasExpiredEdsCount'),
      hasExpiredEdsCountForGroup?: int32(name='HasExpiredEdsCountForGroup'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      officeSiteStatus?: string(name='OfficeSiteStatus'),
      regionId?: string(name='RegionId'),
      runningEdsCount?: int32(name='RunningEdsCount'),
      runningEdsCountForGroup?: int32(name='RunningEdsCountForGroup'),
      totalEdsCount?: int32(name='TotalEdsCount'),
      totalEdsCountForGroup?: int32(name='TotalEdsCountForGroup'),
      vpcType?: string(name='VpcType'),
      willExpiredEdsCount?: int32(name='WillExpiredEdsCount'),
      willExpiredEdsCountForGroup?: int32(name='WillExpiredEdsCountForGroup'),
    }
  ](name='OfficeSiteOverviewResults'),
  requestId?: string(name='RequestId'),
}

model ListOfficeSiteOverviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOfficeSiteOverviewResponseBody(name='body'),
}

async function listOfficeSiteOverviewWithOptions(request: ListOfficeSiteOverviewRequest, runtime: Util.RuntimeOptions): ListOfficeSiteOverviewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.forceRefresh)) {
    query['ForceRefresh'] = request.forceRefresh;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.queryRange)) {
    query['QueryRange'] = request.queryRange;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOfficeSiteOverview',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOfficeSiteOverview(request: ListOfficeSiteOverviewRequest): ListOfficeSiteOverviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOfficeSiteOverviewWithOptions(request, runtime);
}

model ListOfficeSiteUsersRequest {
  filter?: string(name='Filter'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  OUPath?: string(name='OUPath'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model ListOfficeSiteUsersResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  users?: [ 
    {
      displayName?: string(name='DisplayName'),
      endUser?: string(name='EndUser'),
    }
  ](name='Users'),
}

model ListOfficeSiteUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOfficeSiteUsersResponseBody(name='body'),
}

async function listOfficeSiteUsersWithOptions(request: ListOfficeSiteUsersRequest, runtime: Util.RuntimeOptions): ListOfficeSiteUsersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.OUPath)) {
    query['OUPath'] = request.OUPath;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOfficeSiteUsers',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOfficeSiteUsers(request: ListOfficeSiteUsersRequest): ListOfficeSiteUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOfficeSiteUsersWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListUserAdOrganizationUnitsRequest {
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model ListUserAdOrganizationUnitsResponseBody = {
  OUNames?: [ 
    {
      OUName?: string(name='OUName'),
      officeSiteId?: string(name='OfficeSiteId'),
    }
  ](name='OUNames'),
  requestId?: string(name='RequestId'),
}

model ListUserAdOrganizationUnitsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserAdOrganizationUnitsResponseBody(name='body'),
}

async function listUserAdOrganizationUnitsWithOptions(request: ListUserAdOrganizationUnitsRequest, runtime: Util.RuntimeOptions): ListUserAdOrganizationUnitsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserAdOrganizationUnits',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserAdOrganizationUnits(request: ListUserAdOrganizationUnitsRequest): ListUserAdOrganizationUnitsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserAdOrganizationUnitsWithOptions(request, runtime);
}

model LockVirtualMFADeviceRequest {
  regionId?: string(name='RegionId'),
  serialNumber?: string(name='SerialNumber'),
}

model LockVirtualMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model LockVirtualMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LockVirtualMFADeviceResponseBody(name='body'),
}

async function lockVirtualMFADeviceWithOptions(request: LockVirtualMFADeviceRequest, runtime: Util.RuntimeOptions): LockVirtualMFADeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serialNumber)) {
    query['SerialNumber'] = request.serialNumber;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'LockVirtualMFADevice',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function lockVirtualMFADevice(request: LockVirtualMFADeviceRequest): LockVirtualMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return lockVirtualMFADeviceWithOptions(request, runtime);
}

model ModifyADConnectorDirectoryRequest {
  adHostname?: string(name='AdHostname'),
  directoryId?: string(name='DirectoryId'),
  directoryName?: string(name='DirectoryName'),
  dnsAddress?: [ string ](name='DnsAddress'),
  domainName?: string(name='DomainName'),
  domainPassword?: string(name='DomainPassword'),
  domainUserName?: string(name='DomainUserName'),
  mfaEnabled?: boolean(name='MfaEnabled'),
  OUName?: string(name='OUName'),
  regionId?: string(name='RegionId'),
  subDomainDnsAddress?: [ string ](name='SubDomainDnsAddress'),
  subDomainName?: string(name='SubDomainName'),
}

model ModifyADConnectorDirectoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyADConnectorDirectoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyADConnectorDirectoryResponseBody(name='body'),
}

async function modifyADConnectorDirectoryWithOptions(request: ModifyADConnectorDirectoryRequest, runtime: Util.RuntimeOptions): ModifyADConnectorDirectoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.adHostname)) {
    query['AdHostname'] = request.adHostname;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.directoryName)) {
    query['DirectoryName'] = request.directoryName;
  }
  if (!Util.isUnset(request.dnsAddress)) {
    query['DnsAddress'] = request.dnsAddress;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainPassword)) {
    query['DomainPassword'] = request.domainPassword;
  }
  if (!Util.isUnset(request.domainUserName)) {
    query['DomainUserName'] = request.domainUserName;
  }
  if (!Util.isUnset(request.mfaEnabled)) {
    query['MfaEnabled'] = request.mfaEnabled;
  }
  if (!Util.isUnset(request.OUName)) {
    query['OUName'] = request.OUName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.subDomainDnsAddress)) {
    query['SubDomainDnsAddress'] = request.subDomainDnsAddress;
  }
  if (!Util.isUnset(request.subDomainName)) {
    query['SubDomainName'] = request.subDomainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyADConnectorDirectory',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyADConnectorDirectory(request: ModifyADConnectorDirectoryRequest): ModifyADConnectorDirectoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyADConnectorDirectoryWithOptions(request, runtime);
}

model ModifyADConnectorOfficeSiteRequest {
  adHostname?: string(name='AdHostname'),
  dnsAddress?: [ string ](name='DnsAddress'),
  domainName?: string(name='DomainName'),
  domainPassword?: string(name='DomainPassword'),
  domainUserName?: string(name='DomainUserName'),
  mfaEnabled?: boolean(name='MfaEnabled'),
  OUName?: string(name='OUName'),
  officeSiteId?: string(name='OfficeSiteId'),
  officeSiteName?: string(name='OfficeSiteName'),
  regionId?: string(name='RegionId'),
  subDomainDnsAddress?: [ string ](name='SubDomainDnsAddress'),
  subDomainName?: string(name='SubDomainName'),
}

model ModifyADConnectorOfficeSiteResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyADConnectorOfficeSiteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyADConnectorOfficeSiteResponseBody(name='body'),
}

async function modifyADConnectorOfficeSiteWithOptions(request: ModifyADConnectorOfficeSiteRequest, runtime: Util.RuntimeOptions): ModifyADConnectorOfficeSiteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.adHostname)) {
    query['AdHostname'] = request.adHostname;
  }
  if (!Util.isUnset(request.dnsAddress)) {
    query['DnsAddress'] = request.dnsAddress;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainPassword)) {
    query['DomainPassword'] = request.domainPassword;
  }
  if (!Util.isUnset(request.domainUserName)) {
    query['DomainUserName'] = request.domainUserName;
  }
  if (!Util.isUnset(request.mfaEnabled)) {
    query['MfaEnabled'] = request.mfaEnabled;
  }
  if (!Util.isUnset(request.OUName)) {
    query['OUName'] = request.OUName;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.officeSiteName)) {
    query['OfficeSiteName'] = request.officeSiteName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.subDomainDnsAddress)) {
    query['SubDomainDnsAddress'] = request.subDomainDnsAddress;
  }
  if (!Util.isUnset(request.subDomainName)) {
    query['SubDomainName'] = request.subDomainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyADConnectorOfficeSite',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyADConnectorOfficeSite(request: ModifyADConnectorOfficeSiteRequest): ModifyADConnectorOfficeSiteResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyADConnectorOfficeSiteWithOptions(request, runtime);
}

model ModifyBundleRequest {
  bundleId?: string(name='BundleId'),
  bundleName?: string(name='BundleName'),
  description?: string(name='Description'),
  imageId?: string(name='ImageId'),
  language?: string(name='Language'),
  regionId?: string(name='RegionId'),
}

model ModifyBundleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBundleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyBundleResponseBody(name='body'),
}

async function modifyBundleWithOptions(request: ModifyBundleRequest, runtime: Util.RuntimeOptions): ModifyBundleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bundleId)) {
    query['BundleId'] = request.bundleId;
  }
  if (!Util.isUnset(request.bundleName)) {
    query['BundleName'] = request.bundleName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.language)) {
    query['Language'] = request.language;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBundle',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyBundle(request: ModifyBundleRequest): ModifyBundleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBundleWithOptions(request, runtime);
}

model ModifyCloudDrivePermissionRequest {
  cdsId?: string(name='CdsId'),
  downloadEndUserIds?: [ string ](name='DownloadEndUserIds'),
  downloadUploadEndUserIds?: [ string ](name='DownloadUploadEndUserIds'),
  regionId?: string(name='RegionId'),
}

model ModifyCloudDrivePermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCloudDrivePermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyCloudDrivePermissionResponseBody(name='body'),
}

async function modifyCloudDrivePermissionWithOptions(request: ModifyCloudDrivePermissionRequest, runtime: Util.RuntimeOptions): ModifyCloudDrivePermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cdsId)) {
    query['CdsId'] = request.cdsId;
  }
  if (!Util.isUnset(request.downloadEndUserIds)) {
    query['DownloadEndUserIds'] = request.downloadEndUserIds;
  }
  if (!Util.isUnset(request.downloadUploadEndUserIds)) {
    query['DownloadUploadEndUserIds'] = request.downloadUploadEndUserIds;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCloudDrivePermission',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyCloudDrivePermission(request: ModifyCloudDrivePermissionRequest): ModifyCloudDrivePermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCloudDrivePermissionWithOptions(request, runtime);
}

model ModifyCustomizedListHeadersRequest {
  headers?: [ 
    {
      displayType?: string(name='DisplayType'),
      headerKey?: string(name='HeaderKey'),
    }
  ](name='Headers'),
  listType?: string(name='ListType'),
  regionId?: string(name='RegionId'),
}

model ModifyCustomizedListHeadersResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCustomizedListHeadersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyCustomizedListHeadersResponseBody(name='body'),
}

async function modifyCustomizedListHeadersWithOptions(request: ModifyCustomizedListHeadersRequest, runtime: Util.RuntimeOptions): ModifyCustomizedListHeadersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.headers)) {
    query['Headers'] = request.headers;
  }
  if (!Util.isUnset(request.listType)) {
    query['ListType'] = request.listType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCustomizedListHeaders',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyCustomizedListHeaders(request: ModifyCustomizedListHeadersRequest): ModifyCustomizedListHeadersResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCustomizedListHeadersWithOptions(request, runtime);
}

model ModifyDesktopChargeTypeRequest {
  autoPay?: boolean(name='AutoPay'),
  chargeType?: string(name='ChargeType'),
  desktopId?: [ string ](name='DesktopId'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  promotionId?: string(name='PromotionId'),
  regionId?: string(name='RegionId'),
}

model ModifyDesktopChargeTypeResponseBody = {
  desktopId?: [ string ](name='DesktopId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyDesktopChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDesktopChargeTypeResponseBody(name='body'),
}

async function modifyDesktopChargeTypeWithOptions(request: ModifyDesktopChargeTypeRequest, runtime: Util.RuntimeOptions): ModifyDesktopChargeTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.promotionId)) {
    query['PromotionId'] = request.promotionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDesktopChargeType',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDesktopChargeType(request: ModifyDesktopChargeTypeRequest): ModifyDesktopChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDesktopChargeTypeWithOptions(request, runtime);
}

model ModifyDesktopGroupRequest {
  allowAutoSetup?: int32(name='AllowAutoSetup'),
  allowBufferCount?: int32(name='AllowBufferCount'),
  bindAmount?: long(name='BindAmount'),
  classify?: string(name='Classify'),
  comments?: string(name='Comments'),
  connectDuration?: long(name='ConnectDuration'),
  desktopGroupId?: string(name='DesktopGroupId'),
  desktopGroupName?: string(name='DesktopGroupName'),
  disableSessionConfig?: boolean(name='DisableSessionConfig'),
  fileSystemId?: string(name='FileSystemId'),
  idleDisconnectDuration?: long(name='IdleDisconnectDuration'),
  imageId?: string(name='ImageId'),
  keepDuration?: long(name='KeepDuration'),
  loadPolicy?: long(name='LoadPolicy'),
  maxDesktopsCount?: int32(name='MaxDesktopsCount'),
  minDesktopsCount?: int32(name='MinDesktopsCount'),
  ownBundleId?: string(name='OwnBundleId'),
  policyGroupId?: string(name='PolicyGroupId'),
  profileFollowSwitch?: boolean(name='ProfileFollowSwitch'),
  ratioThreshold?: float(name='RatioThreshold'),
  regionId?: string(name='RegionId'),
  resetType?: long(name='ResetType'),
  scaleStrategyId?: string(name='ScaleStrategyId'),
  stopDuration?: long(name='StopDuration'),
}

model ModifyDesktopGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDesktopGroupResponseBody(name='body'),
}

async function modifyDesktopGroupWithOptions(request: ModifyDesktopGroupRequest, runtime: Util.RuntimeOptions): ModifyDesktopGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allowAutoSetup)) {
    query['AllowAutoSetup'] = request.allowAutoSetup;
  }
  if (!Util.isUnset(request.allowBufferCount)) {
    query['AllowBufferCount'] = request.allowBufferCount;
  }
  if (!Util.isUnset(request.bindAmount)) {
    query['BindAmount'] = request.bindAmount;
  }
  if (!Util.isUnset(request.classify)) {
    query['Classify'] = request.classify;
  }
  if (!Util.isUnset(request.comments)) {
    query['Comments'] = request.comments;
  }
  if (!Util.isUnset(request.connectDuration)) {
    query['ConnectDuration'] = request.connectDuration;
  }
  if (!Util.isUnset(request.desktopGroupId)) {
    query['DesktopGroupId'] = request.desktopGroupId;
  }
  if (!Util.isUnset(request.desktopGroupName)) {
    query['DesktopGroupName'] = request.desktopGroupName;
  }
  if (!Util.isUnset(request.disableSessionConfig)) {
    query['DisableSessionConfig'] = request.disableSessionConfig;
  }
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!Util.isUnset(request.idleDisconnectDuration)) {
    query['IdleDisconnectDuration'] = request.idleDisconnectDuration;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.keepDuration)) {
    query['KeepDuration'] = request.keepDuration;
  }
  if (!Util.isUnset(request.loadPolicy)) {
    query['LoadPolicy'] = request.loadPolicy;
  }
  if (!Util.isUnset(request.maxDesktopsCount)) {
    query['MaxDesktopsCount'] = request.maxDesktopsCount;
  }
  if (!Util.isUnset(request.minDesktopsCount)) {
    query['MinDesktopsCount'] = request.minDesktopsCount;
  }
  if (!Util.isUnset(request.ownBundleId)) {
    query['OwnBundleId'] = request.ownBundleId;
  }
  if (!Util.isUnset(request.policyGroupId)) {
    query['PolicyGroupId'] = request.policyGroupId;
  }
  if (!Util.isUnset(request.profileFollowSwitch)) {
    query['ProfileFollowSwitch'] = request.profileFollowSwitch;
  }
  if (!Util.isUnset(request.ratioThreshold)) {
    query['RatioThreshold'] = request.ratioThreshold;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resetType)) {
    query['ResetType'] = request.resetType;
  }
  if (!Util.isUnset(request.scaleStrategyId)) {
    query['ScaleStrategyId'] = request.scaleStrategyId;
  }
  if (!Util.isUnset(request.stopDuration)) {
    query['StopDuration'] = request.stopDuration;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDesktopGroup',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDesktopGroup(request: ModifyDesktopGroupRequest): ModifyDesktopGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDesktopGroupWithOptions(request, runtime);
}

model ModifyDesktopHostNameRequest {
  desktopId?: string(name='DesktopId'),
  newHostName?: string(name='NewHostName'),
  regionId?: string(name='RegionId'),
}

model ModifyDesktopHostNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDesktopHostNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDesktopHostNameResponseBody(name='body'),
}

async function modifyDesktopHostNameWithOptions(request: ModifyDesktopHostNameRequest, runtime: Util.RuntimeOptions): ModifyDesktopHostNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.newHostName)) {
    query['NewHostName'] = request.newHostName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDesktopHostName',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDesktopHostName(request: ModifyDesktopHostNameRequest): ModifyDesktopHostNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDesktopHostNameWithOptions(request, runtime);
}

model ModifyDesktopNameRequest {
  desktopId?: string(name='DesktopId'),
  newDesktopName?: string(name='NewDesktopName'),
  regionId?: string(name='RegionId'),
}

model ModifyDesktopNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDesktopNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDesktopNameResponseBody(name='body'),
}

async function modifyDesktopNameWithOptions(request: ModifyDesktopNameRequest, runtime: Util.RuntimeOptions): ModifyDesktopNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.newDesktopName)) {
    query['NewDesktopName'] = request.newDesktopName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDesktopName',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDesktopName(request: ModifyDesktopNameRequest): ModifyDesktopNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDesktopNameWithOptions(request, runtime);
}

model ModifyDesktopSpecRequest {
  autoPay?: boolean(name='AutoPay'),
  desktopId?: string(name='DesktopId'),
  desktopType?: string(name='DesktopType'),
  promotionId?: string(name='PromotionId'),
  regionId?: string(name='RegionId'),
  rootDiskSizeGib?: int32(name='RootDiskSizeGib'),
  userDiskPerformanceLevel?: string(name='UserDiskPerformanceLevel'),
  userDiskSizeGib?: int32(name='UserDiskSizeGib'),
}

model ModifyDesktopSpecResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyDesktopSpecResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDesktopSpecResponseBody(name='body'),
}

async function modifyDesktopSpecWithOptions(request: ModifyDesktopSpecRequest, runtime: Util.RuntimeOptions): ModifyDesktopSpecResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.desktopType)) {
    query['DesktopType'] = request.desktopType;
  }
  if (!Util.isUnset(request.promotionId)) {
    query['PromotionId'] = request.promotionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.rootDiskSizeGib)) {
    query['RootDiskSizeGib'] = request.rootDiskSizeGib;
  }
  if (!Util.isUnset(request.userDiskPerformanceLevel)) {
    query['UserDiskPerformanceLevel'] = request.userDiskPerformanceLevel;
  }
  if (!Util.isUnset(request.userDiskSizeGib)) {
    query['UserDiskSizeGib'] = request.userDiskSizeGib;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDesktopSpec',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDesktopSpec(request: ModifyDesktopSpecRequest): ModifyDesktopSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDesktopSpecWithOptions(request, runtime);
}

model ModifyDesktopsPolicyGroupRequest {
  desktopId?: [ string ](name='DesktopId'),
  policyGroupId?: string(name='PolicyGroupId'),
  regionId?: string(name='RegionId'),
}

model ModifyDesktopsPolicyGroupResponseBody = {
  modifyResults?: [ 
    {
      code?: string(name='Code'),
      desktopId?: string(name='DesktopId'),
      message?: string(name='Message'),
    }
  ](name='ModifyResults'),
  requestId?: string(name='RequestId'),
}

model ModifyDesktopsPolicyGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDesktopsPolicyGroupResponseBody(name='body'),
}

async function modifyDesktopsPolicyGroupWithOptions(request: ModifyDesktopsPolicyGroupRequest, runtime: Util.RuntimeOptions): ModifyDesktopsPolicyGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.policyGroupId)) {
    query['PolicyGroupId'] = request.policyGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDesktopsPolicyGroup',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDesktopsPolicyGroup(request: ModifyDesktopsPolicyGroupRequest): ModifyDesktopsPolicyGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDesktopsPolicyGroupWithOptions(request, runtime);
}

model ModifyDiskSpecRequest {
  autoPay?: boolean(name='AutoPay'),
  desktopId?: string(name='DesktopId'),
  promotionId?: string(name='PromotionId'),
  regionId?: string(name='RegionId'),
  rootDiskPerformanceLevel?: string(name='RootDiskPerformanceLevel'),
  userDiskPerformanceLevel?: string(name='UserDiskPerformanceLevel'),
}

model ModifyDiskSpecResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyDiskSpecResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDiskSpecResponseBody(name='body'),
}

async function modifyDiskSpecWithOptions(request: ModifyDiskSpecRequest, runtime: Util.RuntimeOptions): ModifyDiskSpecResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.promotionId)) {
    query['PromotionId'] = request.promotionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.rootDiskPerformanceLevel)) {
    query['RootDiskPerformanceLevel'] = request.rootDiskPerformanceLevel;
  }
  if (!Util.isUnset(request.userDiskPerformanceLevel)) {
    query['UserDiskPerformanceLevel'] = request.userDiskPerformanceLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDiskSpec',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDiskSpec(request: ModifyDiskSpecRequest): ModifyDiskSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDiskSpecWithOptions(request, runtime);
}

model ModifyEntitlementRequest {
  desktopId?: string(name='DesktopId'),
  endUserId?: [ string ](name='EndUserId'),
  regionId?: string(name='RegionId'),
}

model ModifyEntitlementResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyEntitlementResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyEntitlementResponseBody(name='body'),
}

async function modifyEntitlementWithOptions(request: ModifyEntitlementRequest, runtime: Util.RuntimeOptions): ModifyEntitlementResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyEntitlement',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyEntitlement(request: ModifyEntitlementRequest): ModifyEntitlementResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyEntitlementWithOptions(request, runtime);
}

model ModifyImageAttributeRequest {
  description?: string(name='Description'),
  imageId?: string(name='ImageId'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model ModifyImageAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyImageAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyImageAttributeResponseBody(name='body'),
}

async function modifyImageAttributeWithOptions(request: ModifyImageAttributeRequest, runtime: Util.RuntimeOptions): ModifyImageAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyImageAttribute',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyImageAttribute(request: ModifyImageAttributeRequest): ModifyImageAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyImageAttributeWithOptions(request, runtime);
}

model ModifyImagePermissionRequest {
  addAccount?: [ long ](name='AddAccount'),
  imageId?: string(name='ImageId'),
  regionId?: string(name='RegionId'),
  removeAccount?: [ long ](name='RemoveAccount'),
}

model ModifyImagePermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyImagePermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyImagePermissionResponseBody(name='body'),
}

async function modifyImagePermissionWithOptions(request: ModifyImagePermissionRequest, runtime: Util.RuntimeOptions): ModifyImagePermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addAccount)) {
    query['AddAccount'] = request.addAccount;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.removeAccount)) {
    query['RemoveAccount'] = request.removeAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyImagePermission',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyImagePermission(request: ModifyImagePermissionRequest): ModifyImagePermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyImagePermissionWithOptions(request, runtime);
}

model ModifyNASDefaultMountTargetRequest {
  fileSystemId?: string(name='FileSystemId'),
  mountTargetDomain?: string(name='MountTargetDomain'),
  regionId?: string(name='RegionId'),
}

model ModifyNASDefaultMountTargetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNASDefaultMountTargetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyNASDefaultMountTargetResponseBody(name='body'),
}

async function modifyNASDefaultMountTargetWithOptions(request: ModifyNASDefaultMountTargetRequest, runtime: Util.RuntimeOptions): ModifyNASDefaultMountTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!Util.isUnset(request.mountTargetDomain)) {
    query['MountTargetDomain'] = request.mountTargetDomain;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNASDefaultMountTarget',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyNASDefaultMountTarget(request: ModifyNASDefaultMountTargetRequest): ModifyNASDefaultMountTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNASDefaultMountTargetWithOptions(request, runtime);
}

model ModifyNetworkPackageBandwidthRequest {
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: int32(name='Bandwidth'),
  networkPackageId?: string(name='NetworkPackageId'),
  promotionId?: string(name='PromotionId'),
  regionId?: string(name='RegionId'),
}

model ModifyNetworkPackageBandwidthResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyNetworkPackageBandwidthResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyNetworkPackageBandwidthResponseBody(name='body'),
}

async function modifyNetworkPackageBandwidthWithOptions(request: ModifyNetworkPackageBandwidthRequest, runtime: Util.RuntimeOptions): ModifyNetworkPackageBandwidthResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.networkPackageId)) {
    query['NetworkPackageId'] = request.networkPackageId;
  }
  if (!Util.isUnset(request.promotionId)) {
    query['PromotionId'] = request.promotionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNetworkPackageBandwidth',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyNetworkPackageBandwidth(request: ModifyNetworkPackageBandwidthRequest): ModifyNetworkPackageBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNetworkPackageBandwidthWithOptions(request, runtime);
}

model ModifyNetworkPackageEnabledRequest {
  enabled?: boolean(name='Enabled'),
  networkPackageId?: string(name='NetworkPackageId'),
  regionId?: string(name='RegionId'),
}

model ModifyNetworkPackageEnabledResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNetworkPackageEnabledResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyNetworkPackageEnabledResponseBody(name='body'),
}

async function modifyNetworkPackageEnabledWithOptions(request: ModifyNetworkPackageEnabledRequest, runtime: Util.RuntimeOptions): ModifyNetworkPackageEnabledResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.networkPackageId)) {
    query['NetworkPackageId'] = request.networkPackageId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNetworkPackageEnabled',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyNetworkPackageEnabled(request: ModifyNetworkPackageEnabledRequest): ModifyNetworkPackageEnabledResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNetworkPackageEnabledWithOptions(request, runtime);
}

model ModifyOfficeSiteAttributeRequest {
  desktopAccessType?: string(name='DesktopAccessType'),
  needVerifyLoginRisk?: boolean(name='NeedVerifyLoginRisk'),
  needVerifyZeroDevice?: boolean(name='NeedVerifyZeroDevice'),
  officeSiteId?: string(name='OfficeSiteId'),
  officeSiteName?: string(name='OfficeSiteName'),
  regionId?: string(name='RegionId'),
}

model ModifyOfficeSiteAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyOfficeSiteAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyOfficeSiteAttributeResponseBody(name='body'),
}

async function modifyOfficeSiteAttributeWithOptions(request: ModifyOfficeSiteAttributeRequest, runtime: Util.RuntimeOptions): ModifyOfficeSiteAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopAccessType)) {
    query['DesktopAccessType'] = request.desktopAccessType;
  }
  if (!Util.isUnset(request.needVerifyLoginRisk)) {
    query['NeedVerifyLoginRisk'] = request.needVerifyLoginRisk;
  }
  if (!Util.isUnset(request.needVerifyZeroDevice)) {
    query['NeedVerifyZeroDevice'] = request.needVerifyZeroDevice;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.officeSiteName)) {
    query['OfficeSiteName'] = request.officeSiteName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyOfficeSiteAttribute',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyOfficeSiteAttribute(request: ModifyOfficeSiteAttributeRequest): ModifyOfficeSiteAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyOfficeSiteAttributeWithOptions(request, runtime);
}

model ModifyOfficeSiteCrossDesktopAccessRequest {
  enableCrossDesktopAccess?: boolean(name='EnableCrossDesktopAccess'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model ModifyOfficeSiteCrossDesktopAccessResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyOfficeSiteCrossDesktopAccessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyOfficeSiteCrossDesktopAccessResponseBody(name='body'),
}

async function modifyOfficeSiteCrossDesktopAccessWithOptions(request: ModifyOfficeSiteCrossDesktopAccessRequest, runtime: Util.RuntimeOptions): ModifyOfficeSiteCrossDesktopAccessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.enableCrossDesktopAccess)) {
    query['EnableCrossDesktopAccess'] = request.enableCrossDesktopAccess;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyOfficeSiteCrossDesktopAccess',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyOfficeSiteCrossDesktopAccess(request: ModifyOfficeSiteCrossDesktopAccessRequest): ModifyOfficeSiteCrossDesktopAccessResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyOfficeSiteCrossDesktopAccessWithOptions(request, runtime);
}

model ModifyOfficeSiteMfaEnabledRequest {
  mfaEnabled?: boolean(name='MfaEnabled'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model ModifyOfficeSiteMfaEnabledResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyOfficeSiteMfaEnabledResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyOfficeSiteMfaEnabledResponseBody(name='body'),
}

async function modifyOfficeSiteMfaEnabledWithOptions(request: ModifyOfficeSiteMfaEnabledRequest, runtime: Util.RuntimeOptions): ModifyOfficeSiteMfaEnabledResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mfaEnabled)) {
    query['MfaEnabled'] = request.mfaEnabled;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyOfficeSiteMfaEnabled',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyOfficeSiteMfaEnabled(request: ModifyOfficeSiteMfaEnabledRequest): ModifyOfficeSiteMfaEnabledResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyOfficeSiteMfaEnabledWithOptions(request, runtime);
}

model ModifyOperateVulRequest {
  operateType?: string(name='OperateType'),
  reason?: string(name='Reason'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
  vulInfo?: [ 
    {
      desktopId?: string(name='DesktopId'),
      name?: string(name='Name'),
      tag?: string(name='Tag'),
    }
  ](name='VulInfo'),
}

model ModifyOperateVulResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyOperateVulResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyOperateVulResponseBody(name='body'),
}

async function modifyOperateVulWithOptions(request: ModifyOperateVulRequest, runtime: Util.RuntimeOptions): ModifyOperateVulResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.vulInfo)) {
    query['VulInfo'] = request.vulInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyOperateVul',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyOperateVul(request: ModifyOperateVulRequest): ModifyOperateVulResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyOperateVulWithOptions(request, runtime);
}

model ModifyPolicyGroupRequest {
  appContentProtection?: string(name='AppContentProtection'),
  authorizeAccessPolicyRule?: [ 
    {
      cidrIp?: string(name='CidrIp'),
      description?: string(name='Description'),
    }
  ](name='AuthorizeAccessPolicyRule'),
  authorizeSecurityPolicyRule?: [ 
    {
      cidrIp?: string(name='CidrIp'),
      description?: string(name='Description'),
      ipProtocol?: string(name='IpProtocol'),
      policy?: string(name='Policy'),
      portRange?: string(name='PortRange'),
      priority?: string(name='Priority'),
      type?: string(name='Type'),
    }
  ](name='AuthorizeSecurityPolicyRule'),
  cameraRedirect?: string(name='CameraRedirect'),
  clientType?: [ 
    {
      clientType?: string(name='ClientType'),
      status?: string(name='Status'),
    }
  ](name='ClientType'),
  clipboard?: string(name='Clipboard'),
  domainList?: string(name='DomainList'),
  gpuAcceleration?: string(name='GpuAcceleration'),
  html5Access?: string(name='Html5Access'),
  html5FileTransfer?: string(name='Html5FileTransfer'),
  localDrive?: string(name='LocalDrive'),
  name?: string(name='Name'),
  netRedirect?: string(name='NetRedirect'),
  policyGroupId?: string(name='PolicyGroupId'),
  preemptLogin?: string(name='PreemptLogin'),
  preemptLoginUser?: [ string ](name='PreemptLoginUser'),
  printerRedirection?: string(name='PrinterRedirection'),
  recordContent?: string(name='RecordContent'),
  recordContentExpires?: long(name='RecordContentExpires'),
  recording?: string(name='Recording'),
  recordingEndTime?: string(name='RecordingEndTime'),
  recordingExpires?: long(name='RecordingExpires'),
  recordingFps?: long(name='RecordingFps'),
  recordingStartTime?: string(name='RecordingStartTime'),
  regionId?: string(name='RegionId'),
  remoteCoordinate?: string(name='RemoteCoordinate'),
  revokeAccessPolicyRule?: [ 
    {
      cidrIp?: string(name='CidrIp'),
      description?: string(name='Description'),
    }
  ](name='RevokeAccessPolicyRule'),
  revokeSecurityPolicyRule?: [ 
    {
      cidrIp?: string(name='CidrIp'),
      description?: string(name='Description'),
      ipProtocol?: string(name='IpProtocol'),
      policy?: string(name='Policy'),
      portRange?: string(name='PortRange'),
      priority?: string(name='Priority'),
      type?: string(name='Type'),
    }
  ](name='RevokeSecurityPolicyRule'),
  usbRedirect?: string(name='UsbRedirect'),
  usbSupplyRedirectRule?: [ 
    {
      description?: string(name='Description'),
      deviceClass?: string(name='DeviceClass'),
      deviceSubclass?: string(name='DeviceSubclass'),
      productId?: string(name='ProductId'),
      usbRedirectType?: long(name='UsbRedirectType'),
      usbRuleType?: long(name='UsbRuleType'),
      vendorId?: string(name='VendorId'),
    }
  ](name='UsbSupplyRedirectRule'),
  visualQuality?: string(name='VisualQuality'),
  watermark?: string(name='Watermark'),
  watermarkTransparency?: string(name='WatermarkTransparency'),
  watermarkType?: string(name='WatermarkType'),
}

model ModifyPolicyGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyPolicyGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyPolicyGroupResponseBody(name='body'),
}

async function modifyPolicyGroupWithOptions(request: ModifyPolicyGroupRequest, runtime: Util.RuntimeOptions): ModifyPolicyGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appContentProtection)) {
    query['AppContentProtection'] = request.appContentProtection;
  }
  if (!Util.isUnset(request.authorizeAccessPolicyRule)) {
    query['AuthorizeAccessPolicyRule'] = request.authorizeAccessPolicyRule;
  }
  if (!Util.isUnset(request.authorizeSecurityPolicyRule)) {
    query['AuthorizeSecurityPolicyRule'] = request.authorizeSecurityPolicyRule;
  }
  if (!Util.isUnset(request.cameraRedirect)) {
    query['CameraRedirect'] = request.cameraRedirect;
  }
  if (!Util.isUnset(request.clientType)) {
    query['ClientType'] = request.clientType;
  }
  if (!Util.isUnset(request.clipboard)) {
    query['Clipboard'] = request.clipboard;
  }
  if (!Util.isUnset(request.domainList)) {
    query['DomainList'] = request.domainList;
  }
  if (!Util.isUnset(request.gpuAcceleration)) {
    query['GpuAcceleration'] = request.gpuAcceleration;
  }
  if (!Util.isUnset(request.html5Access)) {
    query['Html5Access'] = request.html5Access;
  }
  if (!Util.isUnset(request.html5FileTransfer)) {
    query['Html5FileTransfer'] = request.html5FileTransfer;
  }
  if (!Util.isUnset(request.localDrive)) {
    query['LocalDrive'] = request.localDrive;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.netRedirect)) {
    query['NetRedirect'] = request.netRedirect;
  }
  if (!Util.isUnset(request.policyGroupId)) {
    query['PolicyGroupId'] = request.policyGroupId;
  }
  if (!Util.isUnset(request.preemptLogin)) {
    query['PreemptLogin'] = request.preemptLogin;
  }
  if (!Util.isUnset(request.preemptLoginUser)) {
    query['PreemptLoginUser'] = request.preemptLoginUser;
  }
  if (!Util.isUnset(request.printerRedirection)) {
    query['PrinterRedirection'] = request.printerRedirection;
  }
  if (!Util.isUnset(request.recordContent)) {
    query['RecordContent'] = request.recordContent;
  }
  if (!Util.isUnset(request.recordContentExpires)) {
    query['RecordContentExpires'] = request.recordContentExpires;
  }
  if (!Util.isUnset(request.recording)) {
    query['Recording'] = request.recording;
  }
  if (!Util.isUnset(request.recordingEndTime)) {
    query['RecordingEndTime'] = request.recordingEndTime;
  }
  if (!Util.isUnset(request.recordingExpires)) {
    query['RecordingExpires'] = request.recordingExpires;
  }
  if (!Util.isUnset(request.recordingFps)) {
    query['RecordingFps'] = request.recordingFps;
  }
  if (!Util.isUnset(request.recordingStartTime)) {
    query['RecordingStartTime'] = request.recordingStartTime;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.remoteCoordinate)) {
    query['RemoteCoordinate'] = request.remoteCoordinate;
  }
  if (!Util.isUnset(request.revokeAccessPolicyRule)) {
    query['RevokeAccessPolicyRule'] = request.revokeAccessPolicyRule;
  }
  if (!Util.isUnset(request.revokeSecurityPolicyRule)) {
    query['RevokeSecurityPolicyRule'] = request.revokeSecurityPolicyRule;
  }
  if (!Util.isUnset(request.usbRedirect)) {
    query['UsbRedirect'] = request.usbRedirect;
  }
  if (!Util.isUnset(request.usbSupplyRedirectRule)) {
    query['UsbSupplyRedirectRule'] = request.usbSupplyRedirectRule;
  }
  if (!Util.isUnset(request.visualQuality)) {
    query['VisualQuality'] = request.visualQuality;
  }
  if (!Util.isUnset(request.watermark)) {
    query['Watermark'] = request.watermark;
  }
  if (!Util.isUnset(request.watermarkTransparency)) {
    query['WatermarkTransparency'] = request.watermarkTransparency;
  }
  if (!Util.isUnset(request.watermarkType)) {
    query['WatermarkType'] = request.watermarkType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPolicyGroup',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyPolicyGroup(request: ModifyPolicyGroupRequest): ModifyPolicyGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPolicyGroupWithOptions(request, runtime);
}

model ModifyUserEntitlementRequest {
  authorizeDesktopId?: [ string ](name='AuthorizeDesktopId'),
  endUserId?: [ string ](name='EndUserId'),
  regionId?: string(name='RegionId'),
  revokeDesktopId?: [ string ](name='RevokeDesktopId'),
}

model ModifyUserEntitlementResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUserEntitlementResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyUserEntitlementResponseBody(name='body'),
}

async function modifyUserEntitlementWithOptions(request: ModifyUserEntitlementRequest, runtime: Util.RuntimeOptions): ModifyUserEntitlementResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authorizeDesktopId)) {
    query['AuthorizeDesktopId'] = request.authorizeDesktopId;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.revokeDesktopId)) {
    query['RevokeDesktopId'] = request.revokeDesktopId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyUserEntitlement',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyUserEntitlement(request: ModifyUserEntitlementRequest): ModifyUserEntitlementResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyUserEntitlementWithOptions(request, runtime);
}

model ModifyUserToDesktopGroupRequest {
  desktopGroupId?: string(name='DesktopGroupId'),
  newEndUserIds?: [ string ](name='NewEndUserIds'),
  oldEndUserIds?: [ string ](name='OldEndUserIds'),
  regionId?: string(name='RegionId'),
}

model ModifyUserToDesktopGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUserToDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyUserToDesktopGroupResponseBody(name='body'),
}

async function modifyUserToDesktopGroupWithOptions(request: ModifyUserToDesktopGroupRequest, runtime: Util.RuntimeOptions): ModifyUserToDesktopGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopGroupId)) {
    query['DesktopGroupId'] = request.desktopGroupId;
  }
  if (!Util.isUnset(request.newEndUserIds)) {
    query['NewEndUserIds'] = request.newEndUserIds;
  }
  if (!Util.isUnset(request.oldEndUserIds)) {
    query['OldEndUserIds'] = request.oldEndUserIds;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyUserToDesktopGroup',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyUserToDesktopGroup(request: ModifyUserToDesktopGroupRequest): ModifyUserToDesktopGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyUserToDesktopGroupWithOptions(request, runtime);
}

model OperateVulsRequest {
  desktopId?: [ string ](name='DesktopId'),
  operateType?: string(name='OperateType'),
  precondition?: int32(name='Precondition'),
  reason?: string(name='Reason'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
  vulName?: [ string ](name='VulName'),
}

model OperateVulsResponseBody = {
  requestId?: string(name='RequestId'),
}

model OperateVulsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OperateVulsResponseBody(name='body'),
}

async function operateVulsWithOptions(request: OperateVulsRequest, runtime: Util.RuntimeOptions): OperateVulsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.precondition)) {
    query['Precondition'] = request.precondition;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.vulName)) {
    query['VulName'] = request.vulName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateVuls',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function operateVuls(request: OperateVulsRequest): OperateVulsResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateVulsWithOptions(request, runtime);
}

model RebootDesktopsRequest {
  desktopId?: [ string ](name='DesktopId'),
  regionId?: string(name='RegionId'),
}

model RebootDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RebootDesktopsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RebootDesktopsResponseBody(name='body'),
}

async function rebootDesktopsWithOptions(request: RebootDesktopsRequest, runtime: Util.RuntimeOptions): RebootDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RebootDesktops',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rebootDesktops(request: RebootDesktopsRequest): RebootDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return rebootDesktopsWithOptions(request, runtime);
}

model RebuildDesktopsRequest {
  desktopId?: [ string ](name='DesktopId'),
  imageId?: string(name='ImageId'),
  regionId?: string(name='RegionId'),
}

model RebuildDesktopsResponseBody = {
  rebuildResults?: [ 
    {
      code?: string(name='Code'),
      desktopId?: string(name='DesktopId'),
      message?: string(name='Message'),
    }
  ](name='RebuildResults'),
  requestId?: string(name='RequestId'),
}

model RebuildDesktopsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RebuildDesktopsResponseBody(name='body'),
}

async function rebuildDesktopsWithOptions(request: RebuildDesktopsRequest, runtime: Util.RuntimeOptions): RebuildDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RebuildDesktops',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rebuildDesktops(request: RebuildDesktopsRequest): RebuildDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return rebuildDesktopsWithOptions(request, runtime);
}

model RemoveUserFromDesktopGroupRequest {
  desktopGroupId?: string(name='DesktopGroupId'),
  desktopGroupIds?: [ string ](name='DesktopGroupIds'),
  endUserIds?: [ string ](name='EndUserIds'),
  regionId?: string(name='RegionId'),
}

model RemoveUserFromDesktopGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveUserFromDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveUserFromDesktopGroupResponseBody(name='body'),
}

async function removeUserFromDesktopGroupWithOptions(request: RemoveUserFromDesktopGroupRequest, runtime: Util.RuntimeOptions): RemoveUserFromDesktopGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopGroupId)) {
    query['DesktopGroupId'] = request.desktopGroupId;
  }
  if (!Util.isUnset(request.desktopGroupIds)) {
    query['DesktopGroupIds'] = request.desktopGroupIds;
  }
  if (!Util.isUnset(request.endUserIds)) {
    query['EndUserIds'] = request.endUserIds;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveUserFromDesktopGroup',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeUserFromDesktopGroup(request: RemoveUserFromDesktopGroupRequest): RemoveUserFromDesktopGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeUserFromDesktopGroupWithOptions(request, runtime);
}

model RenewDesktopsRequest {
  autoPay?: boolean(name='AutoPay'),
  desktopId?: [ string ](name='DesktopId'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  promotionId?: string(name='PromotionId'),
  regionId?: string(name='RegionId'),
}

model RenewDesktopsResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewDesktopsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenewDesktopsResponseBody(name='body'),
}

async function renewDesktopsWithOptions(request: RenewDesktopsRequest, runtime: Util.RuntimeOptions): RenewDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.promotionId)) {
    query['PromotionId'] = request.promotionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenewDesktops',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function renewDesktops(request: RenewDesktopsRequest): RenewDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewDesktopsWithOptions(request, runtime);
}

model RenewNetworkPackagesRequest {
  autoPay?: boolean(name='AutoPay'),
  networkPackageId?: [ string ](name='NetworkPackageId'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  promotionId?: string(name='PromotionId'),
  regionId?: string(name='RegionId'),
}

model RenewNetworkPackagesResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewNetworkPackagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenewNetworkPackagesResponseBody(name='body'),
}

async function renewNetworkPackagesWithOptions(request: RenewNetworkPackagesRequest, runtime: Util.RuntimeOptions): RenewNetworkPackagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.networkPackageId)) {
    query['NetworkPackageId'] = request.networkPackageId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.promotionId)) {
    query['PromotionId'] = request.promotionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenewNetworkPackages',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function renewNetworkPackages(request: RenewNetworkPackagesRequest): RenewNetworkPackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewNetworkPackagesWithOptions(request, runtime);
}

model ResetDesktopsRequest {
  desktopGroupId?: string(name='DesktopGroupId'),
  desktopId?: [ string ](name='DesktopId'),
  imageId?: string(name='ImageId'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  resetType?: string(name='ResetType'),
}

model ResetDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetDesktopsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetDesktopsResponseBody(name='body'),
}

async function resetDesktopsWithOptions(request: ResetDesktopsRequest, runtime: Util.RuntimeOptions): ResetDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopGroupId)) {
    query['DesktopGroupId'] = request.desktopGroupId;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resetType)) {
    query['ResetType'] = request.resetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetDesktops',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetDesktops(request: ResetDesktopsRequest): ResetDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetDesktopsWithOptions(request, runtime);
}

model ResetNASDefaultMountTargetRequest {
  fileSystemId?: string(name='FileSystemId'),
  regionId?: string(name='RegionId'),
}

model ResetNASDefaultMountTargetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetNASDefaultMountTargetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetNASDefaultMountTargetResponseBody(name='body'),
}

async function resetNASDefaultMountTargetWithOptions(request: ResetNASDefaultMountTargetRequest, runtime: Util.RuntimeOptions): ResetNASDefaultMountTargetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetNASDefaultMountTarget',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetNASDefaultMountTarget(request: ResetNASDefaultMountTargetRequest): ResetNASDefaultMountTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetNASDefaultMountTargetWithOptions(request, runtime);
}

model ResetSnapshotRequest {
  regionId?: string(name='RegionId'),
  snapshotId?: string(name='SnapshotId'),
}

model ResetSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetSnapshotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetSnapshotResponseBody(name='body'),
}

async function resetSnapshotWithOptions(request: ResetSnapshotRequest, runtime: Util.RuntimeOptions): ResetSnapshotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetSnapshot',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetSnapshot(request: ResetSnapshotRequest): ResetSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetSnapshotWithOptions(request, runtime);
}

model RevokeCoordinatePrivilegeRequest {
  coId?: string(name='CoId'),
  endUserId?: string(name='EndUserId'),
  regionId?: string(name='RegionId'),
  userType?: string(name='UserType'),
  uuid?: string(name='Uuid'),
}

model RevokeCoordinatePrivilegeResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeCoordinatePrivilegeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokeCoordinatePrivilegeResponseBody(name='body'),
}

async function revokeCoordinatePrivilegeWithOptions(request: RevokeCoordinatePrivilegeRequest, runtime: Util.RuntimeOptions): RevokeCoordinatePrivilegeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.coId)) {
    query['CoId'] = request.coId;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userType)) {
    query['UserType'] = request.userType;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RevokeCoordinatePrivilege',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokeCoordinatePrivilege(request: RevokeCoordinatePrivilegeRequest): RevokeCoordinatePrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeCoordinatePrivilegeWithOptions(request, runtime);
}

model RollbackSuspEventQuaraFileRequest {
  desktopId?: string(name='DesktopId'),
  quaraFieldId?: int32(name='QuaraFieldId'),
  regionId?: string(name='RegionId'),
}

model RollbackSuspEventQuaraFileResponseBody = {
  requestId?: string(name='RequestId'),
}

model RollbackSuspEventQuaraFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RollbackSuspEventQuaraFileResponseBody(name='body'),
}

async function rollbackSuspEventQuaraFileWithOptions(request: RollbackSuspEventQuaraFileRequest, runtime: Util.RuntimeOptions): RollbackSuspEventQuaraFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.quaraFieldId)) {
    query['QuaraFieldId'] = request.quaraFieldId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RollbackSuspEventQuaraFile',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rollbackSuspEventQuaraFile(request: RollbackSuspEventQuaraFileRequest): RollbackSuspEventQuaraFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return rollbackSuspEventQuaraFileWithOptions(request, runtime);
}

model RunCommandRequest {
  commandContent?: string(name='CommandContent'),
  contentEncoding?: string(name='ContentEncoding'),
  desktopId?: [ string ](name='DesktopId'),
  regionId?: string(name='RegionId'),
  timeout?: long(name='Timeout'),
  type?: string(name='Type'),
}

model RunCommandResponseBody = {
  invokeId?: string(name='InvokeId'),
  requestId?: string(name='RequestId'),
}

model RunCommandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RunCommandResponseBody(name='body'),
}

async function runCommandWithOptions(request: RunCommandRequest, runtime: Util.RuntimeOptions): RunCommandResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.commandContent)) {
    query['CommandContent'] = request.commandContent;
  }
  if (!Util.isUnset(request.contentEncoding)) {
    query['ContentEncoding'] = request.contentEncoding;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RunCommand',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runCommand(request: RunCommandRequest): RunCommandResponse {
  var runtime = new Util.RuntimeOptions{};
  return runCommandWithOptions(request, runtime);
}

model SendVerifyCodeRequest {
  extraInfo?: string(name='ExtraInfo'),
  regionId?: string(name='RegionId'),
  verifyCodeAction?: string(name='VerifyCodeAction'),
}

model SendVerifyCodeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SendVerifyCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SendVerifyCodeResponseBody(name='body'),
}

async function sendVerifyCodeWithOptions(request: SendVerifyCodeRequest, runtime: Util.RuntimeOptions): SendVerifyCodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.extraInfo)) {
    query['ExtraInfo'] = request.extraInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.verifyCodeAction)) {
    query['VerifyCodeAction'] = request.verifyCodeAction;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SendVerifyCode',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendVerifyCode(request: SendVerifyCodeRequest): SendVerifyCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendVerifyCodeWithOptions(request, runtime);
}

model SetDesktopGroupTimerRequest {
  cronExpression?: string(name='CronExpression'),
  desktopGroupId?: string(name='DesktopGroupId'),
  force?: boolean(name='Force'),
  regionId?: string(name='RegionId'),
  resetType?: int32(name='ResetType'),
  timerType?: int32(name='TimerType'),
}

model SetDesktopGroupTimerResponseBody = {
  desktopGroupId?: string(name='DesktopGroupId'),
  orderIds?: [ string ](name='OrderIds'),
  requestId?: string(name='RequestId'),
}

model SetDesktopGroupTimerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDesktopGroupTimerResponseBody(name='body'),
}

async function setDesktopGroupTimerWithOptions(request: SetDesktopGroupTimerRequest, runtime: Util.RuntimeOptions): SetDesktopGroupTimerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cronExpression)) {
    query['CronExpression'] = request.cronExpression;
  }
  if (!Util.isUnset(request.desktopGroupId)) {
    query['DesktopGroupId'] = request.desktopGroupId;
  }
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resetType)) {
    query['ResetType'] = request.resetType;
  }
  if (!Util.isUnset(request.timerType)) {
    query['TimerType'] = request.timerType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDesktopGroupTimer',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDesktopGroupTimer(request: SetDesktopGroupTimerRequest): SetDesktopGroupTimerResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDesktopGroupTimerWithOptions(request, runtime);
}

model SetDesktopGroupTimerStatusRequest {
  desktopGroupId?: string(name='DesktopGroupId'),
  regionId?: string(name='RegionId'),
  status?: int32(name='Status'),
  timerType?: int32(name='TimerType'),
}

model SetDesktopGroupTimerStatusResponseBody = {
  desktopGroupId?: string(name='DesktopGroupId'),
  orderIds?: [ string ](name='OrderIds'),
  requestId?: string(name='RequestId'),
}

model SetDesktopGroupTimerStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDesktopGroupTimerStatusResponseBody(name='body'),
}

async function setDesktopGroupTimerStatusWithOptions(request: SetDesktopGroupTimerStatusRequest, runtime: Util.RuntimeOptions): SetDesktopGroupTimerStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopGroupId)) {
    query['DesktopGroupId'] = request.desktopGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.timerType)) {
    query['TimerType'] = request.timerType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDesktopGroupTimerStatus',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDesktopGroupTimerStatus(request: SetDesktopGroupTimerStatusRequest): SetDesktopGroupTimerStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDesktopGroupTimerStatusWithOptions(request, runtime);
}

model SetIdpMetadataRequest {
  directoryId?: string(name='DirectoryId'),
  idpMetadata?: string(name='IdpMetadata'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model SetIdpMetadataResponseBody = {
  idpEntityId?: string(name='IdpEntityId'),
  requestId?: string(name='RequestId'),
}

model SetIdpMetadataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetIdpMetadataResponseBody(name='body'),
}

async function setIdpMetadataWithOptions(request: SetIdpMetadataRequest, runtime: Util.RuntimeOptions): SetIdpMetadataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.idpMetadata)) {
    query['IdpMetadata'] = request.idpMetadata;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetIdpMetadata',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setIdpMetadata(request: SetIdpMetadataRequest): SetIdpMetadataResponse {
  var runtime = new Util.RuntimeOptions{};
  return setIdpMetadataWithOptions(request, runtime);
}

model SetOfficeSiteSsoStatusRequest {
  enableSso?: boolean(name='EnableSso'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model SetOfficeSiteSsoStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetOfficeSiteSsoStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetOfficeSiteSsoStatusResponseBody(name='body'),
}

async function setOfficeSiteSsoStatusWithOptions(request: SetOfficeSiteSsoStatusRequest, runtime: Util.RuntimeOptions): SetOfficeSiteSsoStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.enableSso)) {
    query['EnableSso'] = request.enableSso;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetOfficeSiteSsoStatus',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setOfficeSiteSsoStatus(request: SetOfficeSiteSsoStatusRequest): SetOfficeSiteSsoStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setOfficeSiteSsoStatusWithOptions(request, runtime);
}

model StartDesktopsRequest {
  desktopId?: [ string ](name='DesktopId'),
  regionId?: string(name='RegionId'),
}

model StartDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartDesktopsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartDesktopsResponseBody(name='body'),
}

async function startDesktopsWithOptions(request: StartDesktopsRequest, runtime: Util.RuntimeOptions): StartDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartDesktops',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startDesktops(request: StartDesktopsRequest): StartDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return startDesktopsWithOptions(request, runtime);
}

model StartVirusScanTaskRequest {
  desktopId?: [ string ](name='DesktopId'),
  officeSiteId?: [ string ](name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model StartVirusScanTaskResponseBody = {
  requestId?: string(name='RequestId'),
  scanTaskId?: long(name='ScanTaskId'),
}

model StartVirusScanTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartVirusScanTaskResponseBody(name='body'),
}

async function startVirusScanTaskWithOptions(request: StartVirusScanTaskRequest, runtime: Util.RuntimeOptions): StartVirusScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartVirusScanTask',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startVirusScanTask(request: StartVirusScanTaskRequest): StartVirusScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return startVirusScanTaskWithOptions(request, runtime);
}

model StopDesktopsRequest {
  desktopId?: [ string ](name='DesktopId'),
  regionId?: string(name='RegionId'),
  stoppedMode?: string(name='StoppedMode'),
}

model StopDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopDesktopsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopDesktopsResponseBody(name='body'),
}

async function stopDesktopsWithOptions(request: StopDesktopsRequest, runtime: Util.RuntimeOptions): StopDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.stoppedMode)) {
    query['StoppedMode'] = request.stoppedMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopDesktops',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopDesktops(request: StopDesktopsRequest): StopDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopDesktopsWithOptions(request, runtime);
}

model StopInvocationRequest {
  desktopId?: [ string ](name='DesktopId'),
  invokeId?: string(name='InvokeId'),
  regionId?: string(name='RegionId'),
}

model StopInvocationResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopInvocationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopInvocationResponseBody(name='body'),
}

async function stopInvocationWithOptions(request: StopInvocationRequest, runtime: Util.RuntimeOptions): StopInvocationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.invokeId)) {
    query['InvokeId'] = request.invokeId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopInvocation',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopInvocation(request: StopInvocationRequest): StopInvocationResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopInvocationWithOptions(request, runtime);
}

model TagResourcesRequest {
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UnlockVirtualMFADeviceRequest {
  regionId?: string(name='RegionId'),
  serialNumber?: string(name='SerialNumber'),
}

model UnlockVirtualMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnlockVirtualMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnlockVirtualMFADeviceResponseBody(name='body'),
}

async function unlockVirtualMFADeviceWithOptions(request: UnlockVirtualMFADeviceRequest, runtime: Util.RuntimeOptions): UnlockVirtualMFADeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serialNumber)) {
    query['SerialNumber'] = request.serialNumber;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnlockVirtualMFADevice',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unlockVirtualMFADevice(request: UnlockVirtualMFADeviceRequest): UnlockVirtualMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unlockVirtualMFADeviceWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateFotaTaskRequest {
  regionId?: string(name='RegionId'),
  taskUid?: string(name='TaskUid'),
  userStatus?: string(name='UserStatus'),
}

model UpdateFotaTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateFotaTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFotaTaskResponseBody(name='body'),
}

async function updateFotaTaskWithOptions(request: UpdateFotaTaskRequest, runtime: Util.RuntimeOptions): UpdateFotaTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskUid)) {
    query['TaskUid'] = request.taskUid;
  }
  if (!Util.isUnset(request.userStatus)) {
    query['UserStatus'] = request.userStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFotaTask',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateFotaTask(request: UpdateFotaTaskRequest): UpdateFotaTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFotaTaskWithOptions(request, runtime);
}

model UploadImageRequest {
  dataDiskSize?: int32(name='DataDiskSize'),
  description?: string(name='Description'),
  enableSecurityCheck?: boolean(name='EnableSecurityCheck'),
  gpuCategory?: boolean(name='GpuCategory'),
  gpuDriverType?: string(name='GpuDriverType'),
  imageName?: string(name='ImageName'),
  licenseType?: string(name='LicenseType'),
  osType?: string(name='OsType'),
  ossObjectPath?: string(name='OssObjectPath'),
  protocolType?: string(name='ProtocolType'),
  regionId?: string(name='RegionId'),
}

model UploadImageResponseBody = {
  imageId?: string(name='ImageId'),
  requestId?: string(name='RequestId'),
}

model UploadImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadImageResponseBody(name='body'),
}

async function uploadImageWithOptions(request: UploadImageRequest, runtime: Util.RuntimeOptions): UploadImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataDiskSize)) {
    query['DataDiskSize'] = request.dataDiskSize;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.enableSecurityCheck)) {
    query['EnableSecurityCheck'] = request.enableSecurityCheck;
  }
  if (!Util.isUnset(request.gpuCategory)) {
    query['GpuCategory'] = request.gpuCategory;
  }
  if (!Util.isUnset(request.gpuDriverType)) {
    query['GpuDriverType'] = request.gpuDriverType;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.licenseType)) {
    query['LicenseType'] = request.licenseType;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.ossObjectPath)) {
    query['OssObjectPath'] = request.ossObjectPath;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadImage',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadImage(request: UploadImageRequest): UploadImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadImageWithOptions(request, runtime);
}

model VerifyCenRequest {
  cenId?: string(name='CenId'),
  cenOwnerId?: long(name='CenOwnerId'),
  cidrBlock?: string(name='CidrBlock'),
  regionId?: string(name='RegionId'),
  verifyCode?: string(name='VerifyCode'),
}

model VerifyCenResponseBody = {
  cidrBlocks?: [ string ](name='CidrBlocks'),
  requestId?: string(name='RequestId'),
  routeEntries?: [ 
    {
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      nextHopInstanceId?: string(name='NextHopInstanceId'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
    }
  ](name='RouteEntries'),
  status?: string(name='Status'),
}

model VerifyCenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyCenResponseBody(name='body'),
}

async function verifyCenWithOptions(request: VerifyCenRequest, runtime: Util.RuntimeOptions): VerifyCenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cenId)) {
    query['CenId'] = request.cenId;
  }
  if (!Util.isUnset(request.cenOwnerId)) {
    query['CenOwnerId'] = request.cenOwnerId;
  }
  if (!Util.isUnset(request.cidrBlock)) {
    query['CidrBlock'] = request.cidrBlock;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.verifyCode)) {
    query['VerifyCode'] = request.verifyCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyCen',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyCen(request: VerifyCenRequest): VerifyCenResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyCenWithOptions(request, runtime);
}

