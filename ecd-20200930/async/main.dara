/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'ecd';
  @version = '2020-09-30';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model ActivateOfficeSiteRequest {
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ActivateOfficeSiteResponseBody = {
  requestId?: string(name='RequestId'),
}

model ActivateOfficeSiteResponse = {
  headers: map[string]string(name='headers'),
  body: ActivateOfficeSiteResponseBody(name='body'),
}

async function activateOfficeSite(request: ActivateOfficeSiteRequest): ActivateOfficeSiteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ActivateOfficeSite', 'POST', '/', 'json', false, 'json', request);
}

model AddUserToDesktopGroupRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  desktopGroupId?: string(name='DesktopGroupId', position='Query'),
  desktopGroupIds?: [ string ](name='DesktopGroupIds', position='Query'),
  endUserIds: [ string ](name='EndUserIds', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model AddUserToDesktopGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddUserToDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserToDesktopGroupResponseBody(name='body'),
}

async function addUserToDesktopGroup(request: AddUserToDesktopGroupRequest): AddUserToDesktopGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddUserToDesktopGroup', 'POST', '/', 'json', false, 'json', request);
}

model ApplyCoordinationForMonitoringRequest {
  coordinatePolicyType: string(name='CoordinatePolicyType', position='Query'),
  endUserId?: string(name='EndUserId', position='Query'),
  initiatorType?: string(name='InitiatorType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceCandidates: [ 
    {
      ownerAliUid: long(name='OwnerAliUid'),
      ownerEndUserId?: string(name='OwnerEndUserId'),
      resourceId: string(name='ResourceId'),
      resourceName: string(name='ResourceName'),
      resourceProperties?: string(name='ResourceProperties'),
      resourceRegionId: string(name='ResourceRegionId'),
      resourceType: string(name='ResourceType'),
    }
  ](name='ResourceCandidates', position='Query'),
  uuid: string(name='Uuid', position='Query'),
}

model ApplyCoordinationForMonitoringResponseBody = {
  coordinateFlowModels?: [ 
    {
      coId?: string(name='CoId'),
      coordinateStatus?: string(name='CoordinateStatus'),
      coordinateTicket?: string(name='CoordinateTicket'),
      initiatorType?: string(name='InitiatorType'),
      ownerUserId?: string(name='OwnerUserId'),
      resourceId?: string(name='ResourceId'),
      resourceName?: string(name='ResourceName'),
    }
  ](name='CoordinateFlowModels'),
  requestId?: string(name='RequestId'),
}

model ApplyCoordinationForMonitoringResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyCoordinationForMonitoringResponseBody(name='body'),
}

async function applyCoordinationForMonitoring(request: ApplyCoordinationForMonitoringRequest): ApplyCoordinationForMonitoringResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ApplyCoordinationForMonitoring', 'POST', '/', 'json', false, 'json', request);
}

model ApproveFotaUpdateRequest {
  appVersion: string(name='AppVersion', position='Query'),
  desktopId: string(name='DesktopId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ApproveFotaUpdateResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ApproveFotaUpdateResponse = {
  headers: map[string]string(name='headers'),
  body: ApproveFotaUpdateResponseBody(name='body'),
}

async function approveFotaUpdate(request: ApproveFotaUpdateRequest): ApproveFotaUpdateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ApproveFotaUpdate', 'POST', '/', 'json', false, 'json', request);
}

model AssociateNetworkPackageRequest {
  networkPackageId: string(name='NetworkPackageId', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model AssociateNetworkPackageResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateNetworkPackageResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateNetworkPackageResponseBody(name='body'),
}

async function associateNetworkPackage(request: AssociateNetworkPackageRequest): AssociateNetworkPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateNetworkPackage', 'POST', '/', 'json', false, 'json', request);
}

model AttachCenRequest {
  cenId: string(name='CenId', position='Query'),
  cenOwnerId?: long(name='CenOwnerId', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  verifyCode?: string(name='VerifyCode', position='Query'),
}

model AttachCenResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachCenResponse = {
  headers: map[string]string(name='headers'),
  body: AttachCenResponseBody(name='body'),
}

async function attachCen(request: AttachCenRequest): AttachCenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachCen', 'POST', '/', 'json', false, 'json', request);
}

model CancelCoordinationForMonitoringRequest {
  coIds: [ string ](name='CoIds', position='Query'),
  endUserId?: string(name='EndUserId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  userType?: string(name='UserType', position='Query'),
}

model CancelCoordinationForMonitoringResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelCoordinationForMonitoringResponse = {
  headers: map[string]string(name='headers'),
  body: CancelCoordinationForMonitoringResponseBody(name='body'),
}

async function cancelCoordinationForMonitoring(request: CancelCoordinationForMonitoringRequest): CancelCoordinationForMonitoringResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelCoordinationForMonitoring', 'POST', '/', 'json', false, 'json', request);
}

model CancelCopyImageRequest {
  imageId: string(name='ImageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CancelCopyImageResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelCopyImageResponse = {
  headers: map[string]string(name='headers'),
  body: CancelCopyImageResponseBody(name='body'),
}

async function cancelCopyImage(request: CancelCopyImageRequest): CancelCopyImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelCopyImage', 'POST', '/', 'json', false, 'json', request);
}

model ClonePolicyGroupRequest {
  name: string(name='Name', position='Query'),
  policyGroupId: string(name='PolicyGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ClonePolicyGroupResponseBody = {
  policyGroupId?: string(name='PolicyGroupId'),
  requestId?: string(name='RequestId'),
}

model ClonePolicyGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ClonePolicyGroupResponseBody(name='body'),
}

async function clonePolicyGroup(request: ClonePolicyGroupRequest): ClonePolicyGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ClonePolicyGroup', 'POST', '/', 'json', false, 'json', request);
}

model ConfigADConnectorTrustRequest {
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  trustKey: string(name='TrustKey', position='Query'),
}

model ConfigADConnectorTrustResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigADConnectorTrustResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigADConnectorTrustResponseBody(name='body'),
}

async function configADConnectorTrust(request: ConfigADConnectorTrustRequest): ConfigADConnectorTrustResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfigADConnectorTrust', 'POST', '/', 'json', false, 'json', request);
}

model ConfigADConnectorUserRequest {
  domainPassword: string(name='DomainPassword', position='Query'),
  domainUserName: string(name='DomainUserName', position='Query'),
  OUName?: string(name='OUName', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ConfigADConnectorUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigADConnectorUserResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigADConnectorUserResponseBody(name='body'),
}

async function configADConnectorUser(request: ConfigADConnectorUserRequest): ConfigADConnectorUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfigADConnectorUser', 'POST', '/', 'json', false, 'json', request);
}

model CopyImageRequest {
  destinationDescription?: string(name='DestinationDescription', position='Query'),
  destinationImageName: string(name='DestinationImageName', position='Query'),
  destinationRegionId: string(name='DestinationRegionId', position='Query'),
  imageId: string(name='ImageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CopyImageResponseBody = {
  imageId?: string(name='ImageId'),
  requestId?: string(name='RequestId'),
}

model CopyImageResponse = {
  headers: map[string]string(name='headers'),
  body: CopyImageResponseBody(name='body'),
}

async function copyImage(request: CopyImageRequest): CopyImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CopyImage', 'POST', '/', 'json', false, 'json', request);
}

model CreateADConnectorDirectoryRequest {
  desktopAccessType?: string(name='DesktopAccessType', position='Query'),
  directoryName?: string(name='DirectoryName', position='Query'),
  dnsAddress: [ string ](name='DnsAddress', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  domainPassword: string(name='DomainPassword', position='Query'),
  domainUserName: string(name='DomainUserName', position='Query'),
  enableAdminAccess?: boolean(name='EnableAdminAccess', position='Query'),
  mfaEnabled?: boolean(name='MfaEnabled', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  specification?: long(name='Specification', position='Query'),
  subDomainDnsAddress?: [ string ](name='SubDomainDnsAddress', position='Query'),
  subDomainName?: string(name='SubDomainName', position='Query'),
  vSwitchId: [ string ](name='VSwitchId', position='Query'),
}

model CreateADConnectorDirectoryResponseBody = {
  adConnectors?: [ 
    {
      address?: string(name='Address'),
    }
  ](name='AdConnectors'),
  directoryId?: string(name='DirectoryId'),
  requestId?: string(name='RequestId'),
  trustPassword?: string(name='TrustPassword'),
}

model CreateADConnectorDirectoryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateADConnectorDirectoryResponseBody(name='body'),
}

async function createADConnectorDirectory(request: CreateADConnectorDirectoryRequest): CreateADConnectorDirectoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateADConnectorDirectory', 'POST', '/', 'json', false, 'json', request);
}

model CreateADConnectorOfficeSiteRequest {
  adHostname?: string(name='AdHostname', position='Query'),
  bandwidth?: int32(name='Bandwidth', position='Query'),
  cenId: string(name='CenId', position='Query'),
  cenOwnerId?: long(name='CenOwnerId', position='Query'),
  cidrBlock: string(name='CidrBlock', position='Query'),
  desktopAccessType?: string(name='DesktopAccessType', position='Query'),
  dnsAddress: [ string ](name='DnsAddress', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  domainPassword?: string(name='DomainPassword', position='Query'),
  domainUserName?: string(name='DomainUserName', position='Query'),
  enableAdminAccess?: boolean(name='EnableAdminAccess', position='Query'),
  enableInternetAccess?: boolean(name='EnableInternetAccess', position='Query'),
  mfaEnabled?: boolean(name='MfaEnabled', position='Query'),
  officeSiteName?: string(name='OfficeSiteName', position='Query'),
  protocolType?: string(name='ProtocolType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  specification?: long(name='Specification', position='Query'),
  subDomainDnsAddress?: [ string ](name='SubDomainDnsAddress', position='Query'),
  subDomainName?: string(name='SubDomainName', position='Query'),
  verifyCode?: string(name='VerifyCode', position='Query'),
}

model CreateADConnectorOfficeSiteResponseBody = {
  officeSiteId?: string(name='OfficeSiteId'),
  requestId?: string(name='RequestId'),
}

model CreateADConnectorOfficeSiteResponse = {
  headers: map[string]string(name='headers'),
  body: CreateADConnectorOfficeSiteResponseBody(name='body'),
}

async function createADConnectorOfficeSite(request: CreateADConnectorOfficeSiteRequest): CreateADConnectorOfficeSiteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateADConnectorOfficeSite', 'POST', '/', 'json', false, 'json', request);
}

model CreateBundleRequest {
  bundleName?: string(name='BundleName', position='Query'),
  description?: string(name='Description', position='Query'),
  desktopType: string(name='DesktopType', position='Query'),
  imageId: string(name='ImageId', position='Query'),
  language?: string(name='Language', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  rootDiskPerformanceLevel?: string(name='RootDiskPerformanceLevel', position='Query'),
  rootDiskSizeGib: int32(name='RootDiskSizeGib', position='Query'),
  userDiskPerformanceLevel?: string(name='UserDiskPerformanceLevel', position='Query'),
  userDiskSizeGib: [ int32 ](name='UserDiskSizeGib', position='Query'),
}

model CreateBundleResponseBody = {
  bundleId?: string(name='BundleId'),
  requestId?: string(name='RequestId'),
}

model CreateBundleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBundleResponseBody(name='body'),
}

async function createBundle(request: CreateBundleRequest): CreateBundleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBundle', 'POST', '/', 'json', false, 'json', request);
}

model CreateDesktopGroupRequest {
  allClassifyUsers?: boolean(name='AllClassifyUsers', position='Query'),
  allowAutoSetup?: int32(name='AllowAutoSetup', minimum=0, maximum=1, position='Query'),
  allowBufferCount?: int32(name='AllowBufferCount', minimum=0, maximum=1000, position='Query'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  bindAmount?: long(name='BindAmount', position='Query'),
  bundleId: string(name='BundleId', position='Query'),
  chargeType: string(name='ChargeType', position='Query'),
  classify?: string(name='Classify', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  comments?: string(name='Comments', position='Query'),
  connectDuration?: long(name='ConnectDuration', position='Query'),
  defaultInitDesktopCount?: int32(name='DefaultInitDesktopCount', minimum=1, maximum=1000, position='Query'),
  desktopGroupName?: string(name='DesktopGroupName', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  endUserIds?: [ string ](name='EndUserIds', position='Query'),
  idleDisconnectDuration?: long(name='IdleDisconnectDuration', position='Query'),
  keepDuration?: long(name='KeepDuration', position='Query'),
  loadPolicy?: long(name='LoadPolicy', position='Query'),
  maxDesktopsCount?: int32(name='MaxDesktopsCount', minimum=0, maximum=1000, position='Query'),
  minDesktopsCount?: int32(name='MinDesktopsCount', minimum=0, maximum=500, position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  ownType?: int32(name='OwnType', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  policyGroupId?: string(name='PolicyGroupId', position='Query'),
  ratioThreshold?: float(name='RatioThreshold', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resetType?: long(name='ResetType', position='Query'),
  scaleStrategyId?: string(name='ScaleStrategyId', position='Query'),
  stopDuration?: long(name='StopDuration', position='Query'),
  volumeEncryptionEnabled?: boolean(name='VolumeEncryptionEnabled', position='Query'),
  volumeEncryptionKey?: string(name='VolumeEncryptionKey', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model CreateDesktopGroupResponseBody = {
  desktopGroupId?: string(name='DesktopGroupId'),
  orderIds?: [ string ](name='OrderIds'),
  requestId?: string(name='RequestId'),
}

model CreateDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDesktopGroupResponseBody(name='body'),
}

async function createDesktopGroup(request: CreateDesktopGroupRequest): CreateDesktopGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDesktopGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateDesktopsRequest {
  amount?: int32(name='Amount', minimum=0, maximum=500, position='Query'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  autoRenew?: boolean(name='AutoRenew', position='Query'),
  bundleId?: string(name='BundleId', position='Query'),
  chargeType?: string(name='ChargeType', position='Query'),
  desktopName?: string(name='DesktopName', position='Query'),
  desktopNameSuffix?: boolean(name='DesktopNameSuffix', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  endUserId?: [ string ](name='EndUserId', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  hostname?: string(name='Hostname', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  policyGroupId: string(name='PolicyGroupId', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  userAssignMode?: string(name='UserAssignMode', position='Query'),
  userCommands?: [ 
    {
      content?: string(name='Content', maxLength=15000),
      contentEncoding?: string(name='ContentEncoding', description='自定义脚本命令编码，默认Base64编码'),
      contentType?: string(name='ContentType'),
    }
  ](name='UserCommands', position='Query'),
  userName?: string(name='UserName', position='Query'),
  volumeEncryptionEnabled?: boolean(name='VolumeEncryptionEnabled', position='Query'),
  volumeEncryptionKey?: string(name='VolumeEncryptionKey', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model CreateDesktopsResponseBody = {
  desktopId?: [ string ](name='DesktopId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDesktopsResponseBody(name='body'),
}

async function createDesktops(request: CreateDesktopsRequest): CreateDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDesktops', 'POST', '/', 'json', false, 'json', request);
}

model CreateDiskEncryptionServiceRequest {
  regionId: string(name='RegionId', position='Query'),
}

model CreateDiskEncryptionServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDiskEncryptionServiceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDiskEncryptionServiceResponseBody(name='body'),
}

async function createDiskEncryptionService(request: CreateDiskEncryptionServiceRequest): CreateDiskEncryptionServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDiskEncryptionService', 'POST', '/', 'json', false, 'json', request);
}

model CreateDriveRequest {
  aliUid?: long(name='AliUid', position='Query'),
  description?: string(name='Description', position='Query'),
  domainId?: string(name='DomainId', position='Query'),
  driveName?: string(name='DriveName', position='Query'),
  externalDomainId?: string(name='ExternalDomainId', position='Query'),
  profileRoaming?: boolean(name='ProfileRoaming', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  totalSize?: long(name='TotalSize', position='Query'),
  type?: string(name='Type', position='Query'),
  usedSize?: long(name='UsedSize', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model CreateDriveResponseBody = {
  code?: string(name='Code'),
  drive?: {
    aliUid?: string(name='AliUid'),
    description?: string(name='Description'),
    domainId?: string(name='DomainId'),
    driveId?: string(name='DriveId'),
    externalDriveId?: string(name='ExternalDriveId'),
    externalUserId?: string(name='ExternalUserId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    profileRoaming?: boolean(name='ProfileRoaming'),
    status?: string(name='Status'),
    totalSize?: long(name='TotalSize'),
    type?: string(name='Type'),
    usedSize?: long(name='UsedSize'),
    userId?: string(name='UserId'),
  }(name='Drive'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model CreateDriveResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDriveResponseBody(name='body'),
}

async function createDrive(request: CreateDriveRequest): CreateDriveResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDrive', 'POST', '/', 'json', false, 'json', request);
}

model CreateImageRequest {
  autoCleanUserdata?: boolean(name='AutoCleanUserdata', position='Query'),
  description?: string(name='Description', position='Query'),
  desktopId: string(name='DesktopId', position='Query'),
  diskType?: string(name='DiskType', position='Query'),
  imageName?: string(name='ImageName', position='Query'),
  imageResourceType?: string(name='ImageResourceType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  snapshotId?: string(name='SnapshotId', position='Query'),
  snapshotIds?: [ string ](name='SnapshotIds', position='Query'),
}

model CreateImageResponseBody = {
  imageId?: string(name='ImageId'),
  requestId?: string(name='RequestId'),
}

model CreateImageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateImageResponseBody(name='body'),
}

async function createImage(request: CreateImageRequest): CreateImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateImage', 'POST', '/', 'json', false, 'json', request);
}

model CreateNASFileSystemRequest {
  description?: string(name='Description', position='Query'),
  encryptType?: string(name='EncryptType', position='Query'),
  name?: string(name='Name', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  storageType?: string(name='StorageType', position='Query'),
}

model CreateNASFileSystemResponseBody = {
  fileSystemId?: string(name='FileSystemId'),
  fileSystemName?: string(name='FileSystemName'),
  mountTargetDomain?: string(name='MountTargetDomain'),
  officeSiteId?: string(name='OfficeSiteId'),
  requestId?: string(name='RequestId'),
}

model CreateNASFileSystemResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNASFileSystemResponseBody(name='body'),
}

async function createNASFileSystem(request: CreateNASFileSystemRequest): CreateNASFileSystemResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNASFileSystem', 'POST', '/', 'json', false, 'json', request);
}

model CreateNetworkPackageRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  autoRenew?: boolean(name='AutoRenew', position='Query'),
  bandwidth: int32(name='Bandwidth', minimum=2, maximum=1000, position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CreateNetworkPackageResponseBody = {
  networkPackageId?: string(name='NetworkPackageId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateNetworkPackageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNetworkPackageResponseBody(name='body'),
}

async function createNetworkPackage(request: CreateNetworkPackageRequest): CreateNetworkPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNetworkPackage', 'POST', '/', 'json', false, 'json', request);
}

model CreatePolicyGroupRequest {
  appContentProtection?: string(name='AppContentProtection', position='Query'),
  authorizeAccessPolicyRule?: [ 
    {
      cidrIp?: string(name='CidrIp'),
      description?: string(name='Description'),
    }
  ](name='AuthorizeAccessPolicyRule', position='Query'),
  authorizeSecurityPolicyRule?: [ 
    {
      cidrIp?: string(name='CidrIp'),
      description?: string(name='Description'),
      ipProtocol?: string(name='IpProtocol'),
      policy?: string(name='Policy'),
      portRange?: string(name='PortRange'),
      priority?: string(name='Priority'),
      type?: string(name='Type'),
    }
  ](name='AuthorizeSecurityPolicyRule', position='Query'),
  cameraRedirect?: string(name='CameraRedirect', position='Query'),
  clientType?: [ 
    {
      clientType?: string(name='ClientType'),
      status?: string(name='Status'),
    }
  ](name='ClientType', position='Query'),
  clipboard?: string(name='Clipboard', position='Query'),
  domainList?: string(name='DomainList', position='Query'),
  gpuAcceleration?: string(name='GpuAcceleration', position='Query'),
  html5Access?: string(name='Html5Access', position='Query'),
  html5FileTransfer?: string(name='Html5FileTransfer', position='Query'),
  localDrive?: string(name='LocalDrive', position='Query'),
  name?: string(name='Name', position='Query'),
  netRedirect?: string(name='NetRedirect', position='Query'),
  preemptLogin?: string(name='PreemptLogin', position='Query'),
  preemptLoginUser?: [ string ](name='PreemptLoginUser', position='Query'),
  printerRedirection?: string(name='PrinterRedirection', position='Query'),
  recordContent?: string(name='RecordContent', position='Query'),
  recordContentExpires?: long(name='RecordContentExpires', position='Query'),
  recording?: string(name='Recording', position='Query'),
  recordingEndTime?: string(name='RecordingEndTime', position='Query'),
  recordingExpires?: long(name='RecordingExpires', position='Query'),
  recordingFps?: long(name='RecordingFps', position='Query'),
  recordingStartTime?: string(name='RecordingStartTime', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  usbRedirect?: string(name='UsbRedirect', position='Query'),
  usbSupplyRedirectRule?: [ 
    {
      description?: string(name='Description'),
      deviceClass?: string(name='DeviceClass'),
      deviceSubclass?: string(name='DeviceSubclass'),
      productId?: string(name='ProductId'),
      usbRedirectType?: long(name='UsbRedirectType'),
      usbRuleType?: long(name='UsbRuleType'),
      vendorId?: string(name='VendorId'),
    }
  ](name='UsbSupplyRedirectRule', position='Query'),
  visualQuality?: string(name='VisualQuality', position='Query'),
  watermark?: string(name='Watermark', position='Query'),
  watermarkTransparency?: string(name='WatermarkTransparency', position='Query'),
  watermarkType?: string(name='WatermarkType', position='Query'),
}

model CreatePolicyGroupResponseBody = {
  policyGroupId?: string(name='PolicyGroupId'),
  requestId?: string(name='RequestId'),
}

model CreatePolicyGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePolicyGroupResponseBody(name='body'),
}

async function createPolicyGroup(request: CreatePolicyGroupRequest): CreatePolicyGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePolicyGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateRAMDirectoryRequest {
  desktopAccessType?: string(name='DesktopAccessType', position='Query'),
  directoryName?: string(name='DirectoryName', position='Query'),
  enableAdminAccess?: boolean(name='EnableAdminAccess', position='Query'),
  enableInternetAccess?: boolean(name='EnableInternetAccess', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  vSwitchId: [ string ](name='VSwitchId', position='Query'),
}

model CreateRAMDirectoryResponseBody = {
  directoryId?: string(name='DirectoryId'),
  requestId?: string(name='RequestId'),
}

model CreateRAMDirectoryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRAMDirectoryResponseBody(name='body'),
}

async function createRAMDirectory(request: CreateRAMDirectoryRequest): CreateRAMDirectoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRAMDirectory', 'POST', '/', 'json', false, 'json', request);
}

model CreateSimpleOfficeSiteRequest {
  bandwidth?: int32(name='Bandwidth', position='Query'),
  cenId?: string(name='CenId', position='Query'),
  cenOwnerId?: long(name='CenOwnerId', position='Query'),
  cidrBlock?: string(name='CidrBlock', position='Query'),
  cloudBoxOfficeSite?: boolean(name='CloudBoxOfficeSite', position='Query'),
  desktopAccessType?: string(name='DesktopAccessType', position='Query'),
  enableAdminAccess?: boolean(name='EnableAdminAccess', position='Query'),
  enableInternetAccess?: boolean(name='EnableInternetAccess', position='Query'),
  needVerifyZeroDevice?: boolean(name='NeedVerifyZeroDevice', position='Query'),
  officeSiteName?: string(name='OfficeSiteName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  vSwitchId?: [ string ](name='VSwitchId', position='Query'),
  verifyCode?: string(name='VerifyCode', position='Query'),
}

model CreateSimpleOfficeSiteResponseBody = {
  officeSiteId?: string(name='OfficeSiteId'),
  requestId?: string(name='RequestId'),
}

model CreateSimpleOfficeSiteResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSimpleOfficeSiteResponseBody(name='body'),
}

async function createSimpleOfficeSite(request: CreateSimpleOfficeSiteRequest): CreateSimpleOfficeSiteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSimpleOfficeSite', 'POST', '/', 'json', false, 'json', request);
}

model CreateSnapshotRequest {
  description?: string(name='Description', position='Query'),
  desktopId: string(name='DesktopId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  snapshotName: string(name='SnapshotName', position='Query'),
  sourceDiskType: string(name='SourceDiskType', position='Query'),
}

model CreateSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
  snapshotId?: string(name='SnapshotId'),
}

model CreateSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSnapshotResponseBody(name='body'),
}

async function createSnapshot(request: CreateSnapshotRequest): CreateSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSnapshot', 'POST', '/', 'json', false, 'json', request);
}

model DeleteBundlesRequest {
  bundleId: [ string ](name='BundleId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteBundlesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBundlesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBundlesResponseBody(name='body'),
}

async function deleteBundles(request: DeleteBundlesRequest): DeleteBundlesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBundles', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCloudDriveUsersRequest {
  cdsId: string(name='CdsId', position='Query'),
  endUserId?: [ string ](name='EndUserId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteCloudDriveUsersResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCloudDriveUsersResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCloudDriveUsersResponseBody(name='body'),
}

async function deleteCloudDriveUsers(request: DeleteCloudDriveUsersRequest): DeleteCloudDriveUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCloudDriveUsers', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDesktopGroupRequest {
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteDesktopGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDesktopGroupResponseBody(name='body'),
}

async function deleteDesktopGroup(request: DeleteDesktopGroupRequest): DeleteDesktopGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDesktopGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDesktopsRequest {
  desktopId: [ string ](name='DesktopId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDesktopsResponseBody(name='body'),
}

async function deleteDesktops(request: DeleteDesktopsRequest): DeleteDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDesktops', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDirectoriesRequest {
  directoryId: [ string ](name='DirectoryId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteDirectoriesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDirectoriesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDirectoriesResponseBody(name='body'),
}

async function deleteDirectories(request: DeleteDirectoriesRequest): DeleteDirectoriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDirectories', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDriveRequest {
  driveId?: string(name='DriveId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteDriveResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteDriveResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDriveResponseBody(name='body'),
}

async function deleteDrive(request: DeleteDriveRequest): DeleteDriveResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDrive', 'POST', '/', 'json', false, 'json', request);
}

model DeleteImagesRequest {
  imageId: [ string ](name='ImageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteImagesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteImagesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImagesResponseBody(name='body'),
}

async function deleteImages(request: DeleteImagesRequest): DeleteImagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteImages', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNASFileSystemsRequest {
  fileSystemId: [ string ](name='FileSystemId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteNASFileSystemsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNASFileSystemsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNASFileSystemsResponseBody(name='body'),
}

async function deleteNASFileSystems(request: DeleteNASFileSystemsRequest): DeleteNASFileSystemsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNASFileSystems', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNetworkPackagesRequest {
  networkPackageId: [ string ](name='NetworkPackageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteNetworkPackagesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNetworkPackagesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNetworkPackagesResponseBody(name='body'),
}

async function deleteNetworkPackages(request: DeleteNetworkPackagesRequest): DeleteNetworkPackagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNetworkPackages', 'POST', '/', 'json', false, 'json', request);
}

model DeleteOfficeSitesRequest {
  officeSiteId: [ string ](name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteOfficeSitesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteOfficeSitesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteOfficeSitesResponseBody(name='body'),
}

async function deleteOfficeSites(request: DeleteOfficeSitesRequest): DeleteOfficeSitesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteOfficeSites', 'POST', '/', 'json', false, 'json', request);
}

model DeletePolicyGroupsRequest {
  policyGroupId: [ string ](name='PolicyGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeletePolicyGroupsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePolicyGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePolicyGroupsResponseBody(name='body'),
}

async function deletePolicyGroups(request: DeletePolicyGroupsRequest): DeletePolicyGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePolicyGroups', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSnapshotRequest {
  regionId: string(name='RegionId', position='Query'),
  snapshotId: [ string ](name='SnapshotId', position='Query'),
}

model DeleteSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSnapshotResponseBody(name='body'),
}

async function deleteSnapshot(request: DeleteSnapshotRequest): DeleteSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSnapshot', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVirtualMFADeviceRequest {
  regionId: string(name='RegionId', position='Query'),
  serialNumber: string(name='SerialNumber', position='Query'),
}

model DeleteVirtualMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVirtualMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVirtualMFADeviceResponseBody(name='body'),
}

async function deleteVirtualMFADevice(request: DeleteVirtualMFADeviceRequest): DeleteVirtualMFADeviceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVirtualMFADevice', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAlarmEventStackInfoRequest {
  desktopId: string(name='DesktopId', position='Query'),
  eventName: string(name='EventName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  uniqueInfo: string(name='UniqueInfo', position='Query'),
}

model DescribeAlarmEventStackInfoResponseBody = {
  requestId?: string(name='RequestId'),
  stackInfo?: string(name='StackInfo'),
}

model DescribeAlarmEventStackInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAlarmEventStackInfoResponseBody(name='body'),
}

async function describeAlarmEventStackInfo(request: DescribeAlarmEventStackInfoRequest): DescribeAlarmEventStackInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAlarmEventStackInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBundlesRequest {
  bundleId?: [ string ](name='BundleId', position='Query'),
  bundleType?: string(name='BundleType', position='Query'),
  checkStock?: boolean(name='CheckStock', position='Query'),
  cpuCount?: int32(name='CpuCount', position='Query'),
  desktopTypeFamily?: string(name='DesktopTypeFamily', position='Query'),
  fotaChannel?: string(name='FotaChannel', position='Query'),
  fromDesktopGroup?: boolean(name='FromDesktopGroup', position='Query'),
  gpuCount?: float(name='GpuCount', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=0, maximum=500, position='Query'),
  memorySize?: int32(name='MemorySize', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  protocolType?: string(name='ProtocolType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  supportMultiSession?: boolean(name='SupportMultiSession', position='Query'),
  volumeEncryptionEnabled?: boolean(name='VolumeEncryptionEnabled', position='Query'),
}

model DescribeBundlesResponseBody = {
  bundles?: [ 
    {
      bundleId?: string(name='BundleId'),
      bundleName?: string(name='BundleName'),
      bundleType?: string(name='BundleType'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      desktopType?: string(name='DesktopType'),
      desktopTypeAttribute?: {
        cpuCount?: int32(name='CpuCount'),
        gpuCount?: float(name='GpuCount'),
        gpuSpec?: string(name='GpuSpec'),
        memorySize?: int32(name='MemorySize'),
      }(name='DesktopTypeAttribute'),
      desktopTypeFamily?: string(name='DesktopTypeFamily'),
      disks?: [ 
        {
          diskPerformanceLevel?: string(name='DiskPerformanceLevel'),
          diskSize?: int32(name='DiskSize'),
          diskType?: string(name='DiskType'),
        }
      ](name='Disks'),
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      language?: string(name='Language'),
      osType?: string(name='OsType'),
      protocolType?: string(name='ProtocolType'),
      sessionType?: string(name='SessionType'),
      stockState?: string(name='StockState'),
      volumeEncryptionEnabled?: boolean(name='VolumeEncryptionEnabled'),
      volumeEncryptionKey?: string(name='VolumeEncryptionKey'),
    }
  ](name='Bundles'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeBundlesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBundlesResponseBody(name='body'),
}

async function describeBundles(request: DescribeBundlesRequest): DescribeBundlesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBundles', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCensRequest {
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeCensResponseBody = {
  cens?: [ 
    {
      cenId?: string(name='CenId'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      ipv6Level?: string(name='Ipv6Level'),
      name?: string(name='Name'),
      packageIds?: [ 
        {
          packageId?: string(name='PackageId'),
        }
      ](name='PackageIds'),
      protectionLevel?: string(name='ProtectionLevel'),
      status?: string(name='Status'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
    }
  ](name='Cens'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeCensResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCensResponseBody(name='body'),
}

async function describeCens(request: DescribeCensRequest): DescribeCensResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCens', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClientEventsRequest {
  desktopId?: string(name='DesktopId', position='Query'),
  desktopIp?: string(name='DesktopIp', position='Query'),
  desktopName?: string(name='DesktopName', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  endUserId?: string(name='EndUserId', position='Query'),
  eventType?: string(name='EventType', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  officeSiteName?: string(name='OfficeSiteName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeClientEventsResponseBody = {
  events?: [ 
    {
      aliUid?: string(name='AliUid'),
      bytesReceived?: string(name='BytesReceived'),
      bytesSend?: string(name='BytesSend'),
      clientIp?: string(name='ClientIp'),
      clientOS?: string(name='ClientOS'),
      clientVersion?: string(name='ClientVersion'),
      desktopGroupId?: string(name='DesktopGroupId'),
      desktopGroupName?: string(name='DesktopGroupName'),
      desktopId?: string(name='DesktopId'),
      desktopIp?: string(name='DesktopIp'),
      desktopName?: string(name='DesktopName'),
      directoryId?: string(name='DirectoryId'),
      directoryType?: string(name='DirectoryType'),
      endUserId?: string(name='EndUserId'),
      eventId?: string(name='EventId'),
      eventTime?: string(name='EventTime'),
      eventType?: string(name='EventType'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      officeSiteType?: string(name='OfficeSiteType'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
    }
  ](name='Events'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeClientEventsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClientEventsResponseBody(name='body'),
}

async function describeClientEvents(request: DescribeClientEventsRequest): DescribeClientEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClientEvents', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudDrivePermissionsRequest {
  cdsId: string(name='CdsId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeCloudDrivePermissionsResponseBody = {
  cloudDrivePermissionModels?: [ 
    {
      endUsers?: [ string ](name='EndUsers'),
      permission?: string(name='Permission'),
    }
  ](name='CloudDrivePermissionModels'),
  requestId?: string(name='RequestId'),
}

model DescribeCloudDrivePermissionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCloudDrivePermissionsResponseBody(name='body'),
}

async function describeCloudDrivePermissions(request: DescribeCloudDrivePermissionsRequest): DescribeCloudDrivePermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudDrivePermissions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDesktopGroupsRequest {
  desktopGroupId?: string(name='DesktopGroupId', position='Query'),
  desktopGroupName?: string(name='DesktopGroupName', position='Query'),
  endUserIds?: [ string ](name='EndUserIds', position='Query'),
  excludedEndUserIds?: [ string ](name='ExcludedEndUserIds', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  ownType?: long(name='OwnType', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  policyGroupId?: string(name='PolicyGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  status?: int32(name='Status', position='Query'),
}

model DescribeDesktopGroupsResponseBody = {
  desktopGroups?: [ 
    {
      bindAmount?: long(name='BindAmount'),
      comments?: string(name='Comments'),
      connectDuration?: long(name='ConnectDuration'),
      cpu?: int32(name='Cpu'),
      createTime?: string(name='CreateTime'),
      creator?: string(name='Creator'),
      dataDiskCategory?: string(name='DataDiskCategory'),
      dataDiskSize?: string(name='DataDiskSize'),
      desktopGroupId?: string(name='DesktopGroupId'),
      desktopGroupName?: string(name='DesktopGroupName'),
      endUserCount?: int32(name='EndUserCount'),
      expiredTime?: string(name='ExpiredTime'),
      gpuCount?: float(name='GpuCount'),
      gpuSpec?: string(name='GpuSpec'),
      idleDisconnectDuration?: long(name='IdleDisconnectDuration'),
      imageId?: string(name='ImageId'),
      keepDuration?: long(name='KeepDuration'),
      loadPolicy?: long(name='LoadPolicy'),
      maxDesktopsCount?: int32(name='MaxDesktopsCount'),
      memory?: long(name='Memory'),
      minDesktopsCount?: int32(name='MinDesktopsCount'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      officeSiteType?: string(name='OfficeSiteType'),
      ownBundleId?: string(name='OwnBundleId'),
      ownBundleName?: string(name='OwnBundleName'),
      ownType?: long(name='OwnType'),
      payType?: string(name='PayType'),
      policyGroupId?: string(name='PolicyGroupId'),
      policyGroupName?: string(name='PolicyGroupName'),
      ratioThreshold?: float(name='RatioThreshold'),
      resetType?: long(name='ResetType'),
      status?: int32(name='Status'),
      stopDuration?: long(name='StopDuration'),
      systemDiskCategory?: string(name='SystemDiskCategory'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      version?: int32(name='Version'),
      volumeEncryptionEnabled?: boolean(name='VolumeEncryptionEnabled'),
      volumeEncryptionKey?: string(name='VolumeEncryptionKey'),
    }
  ](name='DesktopGroups'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeDesktopGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDesktopGroupsResponseBody(name='body'),
}

async function describeDesktopGroups(request: DescribeDesktopGroupsRequest): DescribeDesktopGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDesktopGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDesktopIdsByVulNamesRequest {
  necessity?: string(name='Necessity', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
  vulName: [ string ](name='VulName', position='Query'),
}

model DescribeDesktopIdsByVulNamesResponseBody = {
  desktopItems?: [ 
    {
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
    }
  ](name='DesktopItems'),
  requestId?: string(name='RequestId'),
}

model DescribeDesktopIdsByVulNamesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDesktopIdsByVulNamesResponseBody(name='body'),
}

async function describeDesktopIdsByVulNames(request: DescribeDesktopIdsByVulNamesRequest): DescribeDesktopIdsByVulNamesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDesktopIdsByVulNames', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDesktopTypesRequest {
  appliedScope?: string(name='AppliedScope', position='Query'),
  cpuCount?: int32(name='CpuCount', position='Query'),
  desktopIdForModify?: string(name='DesktopIdForModify', position='Query'),
  desktopTypeId?: string(name='DesktopTypeId', position='Query'),
  gpuCount?: float(name='GpuCount', position='Query'),
  instanceTypeFamily?: string(name='InstanceTypeFamily', position='Query'),
  memorySize?: int32(name='MemorySize', position='Query'),
  orderType?: string(name='OrderType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeDesktopTypesResponseBody = {
  desktopTypes?: [ 
    {
      cpuCount?: string(name='CpuCount'),
      dataDiskSize?: string(name='DataDiskSize'),
      desktopTypeId?: string(name='DesktopTypeId'),
      desktopTypeStatus?: string(name='DesktopTypeStatus'),
      gpuCount?: float(name='GpuCount'),
      gpuSpec?: string(name='GpuSpec'),
      instanceTypeFamily?: string(name='InstanceTypeFamily'),
      memorySize?: string(name='MemorySize'),
      systemDiskSize?: string(name='SystemDiskSize'),
    }
  ](name='DesktopTypes'),
  requestId?: string(name='RequestId'),
}

model DescribeDesktopTypesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDesktopTypesResponseBody(name='body'),
}

async function describeDesktopTypes(request: DescribeDesktopTypesRequest): DescribeDesktopTypesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDesktopTypes', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDesktopsRequest {
  chargeType?: string(name='ChargeType', position='Query'),
  desktopId?: [ string ](name='DesktopId', position='Query'),
  desktopName?: string(name='DesktopName', position='Query'),
  desktopStatus?: string(name='DesktopStatus', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  endUserId?: [ string ](name='EndUserId', position='Query'),
  excludedEndUserId?: [ string ](name='ExcludedEndUserId', position='Query'),
  expiredTime?: string(name='ExpiredTime', position='Query'),
  filterDesktopGroup?: boolean(name='FilterDesktopGroup', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  managementFlag?: string(name='ManagementFlag', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  officeSiteName?: string(name='OfficeSiteName', position='Query'),
  policyGroupId?: string(name='PolicyGroupId', position='Query'),
  protocolType?: string(name='ProtocolType', position='Query'),
  queryFotaUpdate?: boolean(name='QueryFotaUpdate', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  userName?: string(name='UserName', position='Query'),
}

model DescribeDesktopsResponseBody = {
  desktops?: [ 
    {
      bundleId?: string(name='BundleId'),
      bundleName?: string(name='BundleName'),
      chargeType?: string(name='ChargeType'),
      connectionStatus?: string(name='ConnectionStatus'),
      cpu?: int32(name='Cpu'),
      creationTime?: string(name='CreationTime'),
      dataDiskCategory?: string(name='DataDiskCategory'),
      dataDiskSize?: string(name='DataDiskSize'),
      desktopGroupId?: string(name='DesktopGroupId'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      desktopStatus?: string(name='DesktopStatus'),
      desktopType?: string(name='DesktopType'),
      directoryId?: string(name='DirectoryId'),
      directoryType?: string(name='DirectoryType'),
      disks?: [ 
        {
          diskId?: string(name='DiskId'),
          diskSize?: int32(name='DiskSize'),
          diskType?: string(name='DiskType'),
          performanceLevel?: string(name='PerformanceLevel'),
        }
      ](name='Disks'),
      downgradeQuota?: long(name='DowngradeQuota'),
      downgradedTimes?: long(name='DowngradedTimes'),
      endUserIds?: [ string ](name='EndUserIds'),
      expiredTime?: string(name='ExpiredTime'),
      fotaUpdate?: {
        currentAppVersion?: string(name='CurrentAppVersion'),
        newAppVersion?: string(name='NewAppVersion'),
        releaseNote?: string(name='ReleaseNote'),
        size?: long(name='Size'),
      }(name='FotaUpdate'),
      gpuCategory?: long(name='GpuCategory'),
      gpuCount?: float(name='GpuCount'),
      gpuDriverVersion?: string(name='GpuDriverVersion'),
      gpuSpec?: string(name='GpuSpec'),
      hostName?: string(name='HostName'),
      imageId?: string(name='ImageId'),
      managementFlag?: string(name='ManagementFlag'),
      memory?: long(name='Memory'),
      networkInterfaceId?: string(name='NetworkInterfaceId'),
      networkInterfaceIp?: string(name='NetworkInterfaceIp'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      officeSiteType?: string(name='OfficeSiteType'),
      officeSiteVpcType?: string(name='OfficeSiteVpcType'),
      osType?: string(name='OsType'),
      platform?: string(name='Platform'),
      policyGroupId?: string(name='PolicyGroupId'),
      policyGroupName?: string(name='PolicyGroupName'),
      progress?: string(name='Progress'),
      protocolType?: string(name='ProtocolType'),
      sessionType?: string(name='SessionType'),
      sessions?: [ 
        {
          endUserId?: string(name='EndUserId'),
          establishmentTime?: string(name='EstablishmentTime'),
          externalUserName?: string(name='ExternalUserName'),
        }
      ](name='Sessions'),
      startTime?: string(name='StartTime'),
      systemDiskCategory?: string(name='SystemDiskCategory'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      volumeEncryptionEnabled?: boolean(name='VolumeEncryptionEnabled'),
      volumeEncryptionKey?: string(name='VolumeEncryptionKey'),
      zoneType?: string(name='ZoneType'),
    }
  ](name='Desktops'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDesktopsResponseBody(name='body'),
}

async function describeDesktops(request: DescribeDesktopsRequest): DescribeDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDesktops', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDesktopsInGroupRequest {
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  ignoreDeleted?: boolean(name='IgnoreDeleted', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  payType: string(name='PayType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeDesktopsInGroupResponseBody = {
  nextToken?: string(name='NextToken'),
  onlinePrePaidDesktopsCount?: int32(name='OnlinePrePaidDesktopsCount'),
  paidDesktops?: [ 
    {
      connectionStatus?: string(name='ConnectionStatus'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      desktopStatus?: string(name='DesktopStatus'),
      diskType?: string(name='DiskType'),
      endUserId?: string(name='EndUserId'),
      endUserIds?: [ string ](name='EndUserIds'),
      endUserName?: string(name='EndUserName'),
      endUserNames?: [ string ](name='EndUserNames'),
      gpuDriverVersion?: string(name='GpuDriverVersion'),
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      managementFlag?: string(name='ManagementFlag'),
      managementFlags?: [ string ](name='ManagementFlags'),
      memberEniIp?: string(name='MemberEniIp'),
      osType?: string(name='OsType'),
      primaryEniIp?: string(name='PrimaryEniIp'),
      resetTime?: string(name='ResetTime'),
      systemDiskSize?: int32(name='SystemDiskSize'),
    }
  ](name='PaidDesktops'),
  paidDesktopsCount?: int32(name='PaidDesktopsCount'),
  postPaidDesktops?: [ 
    {
      connectionStatus?: string(name='ConnectionStatus'),
      createDuration?: string(name='CreateDuration'),
      createTime?: string(name='CreateTime'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      desktopStatus?: string(name='DesktopStatus'),
      diskType?: string(name='DiskType'),
      endUserId?: string(name='EndUserId'),
      endUserIds?: [ string ](name='EndUserIds'),
      endUserName?: string(name='EndUserName'),
      endUserNames?: [ string ](name='EndUserNames'),
      gpuDriverVersion?: string(name='GpuDriverVersion'),
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      managementFlag?: string(name='ManagementFlag'),
      managementFlags?: [ string ](name='ManagementFlags'),
      memberEniIp?: string(name='MemberEniIp'),
      osType?: string(name='OsType'),
      primaryEniIp?: string(name='PrimaryEniIp'),
      releaseTime?: string(name='ReleaseTime'),
      resetTime?: string(name='ResetTime'),
      systemDiskSize?: int32(name='SystemDiskSize'),
    }
  ](name='PostPaidDesktops'),
  postPaidDesktopsCount?: int32(name='PostPaidDesktopsCount'),
  postPaidDesktopsTotalAmount?: int32(name='PostPaidDesktopsTotalAmount'),
  requestId?: string(name='RequestId'),
  runningPrePaidDesktopsCount?: int32(name='RunningPrePaidDesktopsCount'),
  stopedPrePaidDesktopsCount?: int32(name='StopedPrePaidDesktopsCount'),
}

model DescribeDesktopsInGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDesktopsInGroupResponseBody(name='body'),
}

async function describeDesktopsInGroup(request: DescribeDesktopsInGroupRequest): DescribeDesktopsInGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDesktopsInGroup', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDirectoriesRequest {
  directoryId?: [ string ](name='DirectoryId', position='Query'),
  directoryStatus?: string(name='DirectoryStatus', position='Query'),
  directoryType?: string(name='DirectoryType', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=0, maximum=500, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  status?: string(name='Status', position='Query'),
}

model DescribeDirectoriesResponseBody = {
  adHostname?: string(name='AdHostname'),
  directories?: [ 
    {
      ADConnectors?: [ 
        {
          ADConnectorAddress?: string(name='ADConnectorAddress'),
          connectorStatus?: string(name='ConnectorStatus'),
          networkInterfaceId?: string(name='NetworkInterfaceId'),
          specification?: string(name='Specification'),
          trustKey?: string(name='TrustKey'),
          vSwitchId?: string(name='VSwitchId'),
        }
      ](name='ADConnectors'),
      creationTime?: string(name='CreationTime'),
      customSecurityGroupId?: string(name='CustomSecurityGroupId'),
      desktopAccessType?: string(name='DesktopAccessType'),
      desktopVpcEndpoint?: string(name='DesktopVpcEndpoint'),
      directoryId?: string(name='DirectoryId'),
      directoryType?: string(name='DirectoryType'),
      dnsAddress?: [ string ](name='DnsAddress'),
      dnsUserName?: string(name='DnsUserName'),
      domainName?: string(name='DomainName'),
      domainPassword?: string(name='DomainPassword'),
      domainUserName?: string(name='DomainUserName'),
      enableAdminAccess?: boolean(name='EnableAdminAccess'),
      enableCrossDesktopAccess?: boolean(name='EnableCrossDesktopAccess'),
      enableInternetAccess?: boolean(name='EnableInternetAccess'),
      fileSystemIds?: [ string ](name='FileSystemIds'),
      logs?: [ 
        {
          level?: string(name='Level'),
          message?: string(name='Message'),
          step?: string(name='Step'),
          timeStamp?: string(name='TimeStamp'),
        }
      ](name='Logs'),
      mfaEnabled?: boolean(name='MfaEnabled'),
      name?: string(name='Name'),
      needVerifyLoginRisk?: boolean(name='NeedVerifyLoginRisk'),
      ouName?: string(name='OuName'),
      ssoEnabled?: boolean(name='SsoEnabled'),
      status?: string(name='Status'),
      subDnsAddress?: [ string ](name='SubDnsAddress'),
      subDomainName?: string(name='SubDomainName'),
      trustPassword?: string(name='TrustPassword'),
      vSwitchIds?: [ string ](name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Directories'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeDirectoriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDirectoriesResponseBody(name='body'),
}

async function describeDirectories(request: DescribeDirectoriesRequest): DescribeDirectoriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDirectories', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDrivesRequest {
  domainIds?: [ string ](name='DomainIds', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model DescribeDrivesResponseBody = {
  code?: string(name='Code'),
  drives?: [ 
    {
      aliUid?: long(name='AliUid'),
      description?: string(name='Description'),
      desktopGroupCount?: int32(name='DesktopGroupCount'),
      desktopGroups?: [ 
        {
          desktopGroupId?: string(name='DesktopGroupId'),
          desktopGroupName?: string(name='DesktopGroupName'),
        }
      ](name='DesktopGroups'),
      domainId?: string(name='DomainId'),
      driveId?: string(name='DriveId'),
      enableProfileManagement?: boolean(name='EnableProfileManagement'),
      externalDomainId?: string(name='ExternalDomainId'),
      externalDriveId?: string(name='ExternalDriveId'),
      externalUserId?: string(name='ExternalUserId'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      profileRoaming?: boolean(name='ProfileRoaming'),
      status?: string(name='Status'),
      totalSize?: long(name='TotalSize'),
      type?: string(name='Type'),
      usedSize?: long(name='UsedSize'),
      userId?: string(name='UserId'),
    }
  ](name='Drives'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DescribeDrivesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDrivesResponseBody(name='body'),
}

async function describeDrives(request: DescribeDrivesRequest): DescribeDrivesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDrives', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFlowMetricRequest {
  endTime: string(name='EndTime', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceType: string(name='InstanceType', position='Query'),
  metricType: string(name='MetricType', position='Query'),
  period: int32(name='Period', minimum=60, maximum=900, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeFlowMetricResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeFlowMetricResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowMetricResponseBody(name='body'),
}

async function describeFlowMetric(request: DescribeFlowMetricRequest): DescribeFlowMetricResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFlowMetric', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFlowStatisticRequest {
  desktopId?: string(name='DesktopId', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=0, maximum=500, position='Query'),
  pageSize?: int32(name='PageSize', minimum=0, maximum=500, position='Query'),
  period: int32(name='Period', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeFlowStatisticResponseBody = {
  desktopCount?: int32(name='DesktopCount'),
  desktopFlowStatistic?: [ 
    {
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      flowIn?: string(name='FlowIn'),
      flowRank?: int32(name='FlowRank'),
    }
  ](name='DesktopFlowStatistic'),
  requestId?: string(name='RequestId'),
}

model DescribeFlowStatisticResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowStatisticResponseBody(name='body'),
}

async function describeFlowStatistic(request: DescribeFlowStatisticRequest): DescribeFlowStatisticResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFlowStatistic', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFotaPendingDesktopsRequest {
  maxResults?: int32(name='MaxResults', minimum=0, maximum=500, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  taskUid?: string(name='TaskUid', position='Query'),
}

model DescribeFotaPendingDesktopsResponseBody = {
  fotaPendingDesktops?: [ 
    {
      currentAppVersion?: string(name='CurrentAppVersion'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      fotaProject?: string(name='FotaProject'),
      officeSiteId?: string(name='OfficeSiteId'),
    }
  ](name='FotaPendingDesktops'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DescribeFotaPendingDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFotaPendingDesktopsResponseBody(name='body'),
}

async function describeFotaPendingDesktops(request: DescribeFotaPendingDesktopsRequest): DescribeFotaPendingDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFotaPendingDesktops', 'GET', '/', 'json', false, 'json', request);
}

model DescribeFotaTasksRequest {
  fotaStatus?: string(name='FotaStatus', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=0, maximum=500, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  taskUid?: [ string ](name='TaskUid', position='Query'),
  userStatus?: string(name='UserStatus', position='Query'),
}

model DescribeFotaTasksResponseBody = {
  fotaTasks?: [ 
    {
      appVersion?: string(name='AppVersion'),
      fotaProject?: string(name='FotaProject'),
      pendingDesktopCount?: int32(name='PendingDesktopCount'),
      publishTime?: string(name='PublishTime'),
      releaseNote?: string(name='ReleaseNote'),
      size?: int32(name='Size'),
      status?: string(name='Status'),
      taskUid?: string(name='TaskUid'),
    }
  ](name='FotaTasks'),
  requestId?: string(name='RequestId'),
}

model DescribeFotaTasksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFotaTasksResponseBody(name='body'),
}

async function describeFotaTasks(request: DescribeFotaTasksRequest): DescribeFotaTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFotaTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFrontVulPatchListRequest {
  operateType?: string(name='OperateType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
  vulInfo: [ 
    {
      desktopId?: string(name='DesktopId'),
      name?: string(name='Name'),
      tag?: string(name='Tag'),
    }
  ](name='VulInfo', position='Query'),
}

model DescribeFrontVulPatchListResponseBody = {
  frontPatchList?: [ 
    {
      desktopId?: string(name='DesktopId'),
      patchList?: [ 
        {
          aliasName?: string(name='AliasName'),
          name?: string(name='Name'),
        }
      ](name='PatchList'),
    }
  ](name='FrontPatchList'),
  requestId?: string(name='RequestId'),
}

model DescribeFrontVulPatchListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFrontVulPatchListResponseBody(name='body'),
}

async function describeFrontVulPatchList(request: DescribeFrontVulPatchListRequest): DescribeFrontVulPatchListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFrontVulPatchList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGroupedVulRequest {
  currentPage?: int32(name='CurrentPage', position='Query'),
  dealed?: string(name='Dealed', position='Query'),
  lang?: string(name='Lang', position='Query'),
  necessity?: string(name='Necessity', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
}

model DescribeGroupedVulResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  groupedVulItems?: [ 
    {
      aliasName?: string(name='AliasName'),
      asapCount?: int32(name='AsapCount'),
      gmtLast?: string(name='GmtLast'),
      handledCount?: int32(name='HandledCount'),
      laterCount?: int32(name='LaterCount'),
      name?: string(name='Name'),
      nntfCount?: int32(name='NntfCount'),
      tags?: string(name='Tags'),
      type?: string(name='Type'),
    }
  ](name='GroupedVulItems'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeGroupedVulResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGroupedVulResponseBody(name='body'),
}

async function describeGroupedVul(request: DescribeGroupedVulRequest): DescribeGroupedVulResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGroupedVul', 'POST', '/', 'json', false, 'json', request);
}

model DescribeImageModifiedRecordsRequest {
  desktopId: string(name='DesktopId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeImageModifiedRecordsResponseBody = {
  imageModifiedRecords?: [ 
    {
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      newImageId?: string(name='NewImageId'),
      newImageName?: string(name='NewImageName'),
      status?: int32(name='Status'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='ImageModifiedRecords'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeImageModifiedRecordsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageModifiedRecordsResponseBody(name='body'),
}

async function describeImageModifiedRecords(request: DescribeImageModifiedRecordsRequest): DescribeImageModifiedRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImageModifiedRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeImagePermissionRequest {
  imageId: string(name='ImageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeImagePermissionResponseBody = {
  aliUids?: [ string ](name='AliUids'),
  requestId?: string(name='RequestId'),
}

model DescribeImagePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImagePermissionResponseBody(name='body'),
}

async function describeImagePermission(request: DescribeImagePermissionRequest): DescribeImagePermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImagePermission', 'POST', '/', 'json', false, 'json', request);
}

model DescribeImagesRequest {
  desktopInstanceType?: string(name='DesktopInstanceType', position='Query'),
  fotaChannel?: string(name='FotaChannel', position='Query'),
  gpuCategory?: boolean(name='GpuCategory', position='Query'),
  gpuDriverVersion?: string(name='GpuDriverVersion', position='Query'),
  imageId?: [ string ](name='ImageId', position='Query'),
  imageStatus?: string(name='ImageStatus', position='Query'),
  imageType?: string(name='ImageType', position='Query'),
  languageType?: string(name='LanguageType', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=0, maximum=500, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  osType?: string(name='OsType', position='Query'),
  protocolType?: string(name='ProtocolType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeImagesResponseBody = {
  images?: [ 
    {
      appVersion?: string(name='AppVersion'),
      creationTime?: string(name='CreationTime'),
      dataDiskSize?: int32(name='DataDiskSize'),
      description?: string(name='Description'),
      gpuCategory?: boolean(name='GpuCategory'),
      gpuDriverVersion?: string(name='GpuDriverVersion'),
      imageId?: string(name='ImageId'),
      imageType?: string(name='ImageType'),
      name?: string(name='Name'),
      osType?: string(name='OsType'),
      progress?: string(name='Progress'),
      protocolType?: string(name='ProtocolType'),
      sessionType?: string(name='SessionType'),
      sharedCount?: int32(name='SharedCount'),
      size?: int32(name='Size'),
      status?: string(name='Status'),
      supportedLanguages?: [ string ](name='SupportedLanguages'),
      volumeEncryptionEnabled?: boolean(name='VolumeEncryptionEnabled'),
      volumeEncryptionKey?: string(name='VolumeEncryptionKey'),
    }
  ](name='Images'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeImagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImagesResponseBody(name='body'),
}

async function describeImages(request: DescribeImagesRequest): DescribeImagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImages', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInvocationsRequest {
  commandType?: string(name='CommandType', position='Query'),
  contentEncoding?: string(name='ContentEncoding', position='Query'),
  desktopId?: string(name='DesktopId', position='Query'),
  includeOutput?: boolean(name='IncludeOutput', position='Query'),
  invokeId?: string(name='InvokeId', position='Query'),
  invokeStatus?: string(name='InvokeStatus', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=0, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeInvocationsResponseBody = {
  invocations?: [ 
    {
      commandContent?: string(name='CommandContent'),
      commandType?: string(name='CommandType'),
      creationTime?: string(name='CreationTime'),
      endUserId?: string(name='EndUserId'),
      invocationStatus?: string(name='InvocationStatus'),
      invokeDesktops?: [ 
        {
          creationTime?: string(name='CreationTime'),
          desktopId?: string(name='DesktopId'),
          dropped?: int32(name='Dropped'),
          errorCode?: string(name='ErrorCode'),
          errorInfo?: string(name='ErrorInfo'),
          exitCode?: long(name='ExitCode'),
          finishTime?: string(name='FinishTime'),
          invocationStatus?: string(name='InvocationStatus'),
          output?: string(name='Output'),
          repeats?: int32(name='Repeats'),
          startTime?: string(name='StartTime'),
          stopTime?: string(name='StopTime'),
          updateTime?: string(name='UpdateTime'),
        }
      ](name='InvokeDesktops'),
      invokeId?: string(name='InvokeId'),
    }
  ](name='Invocations'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeInvocationsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInvocationsResponseBody(name='body'),
}

async function describeInvocations(request: DescribeInvocationsRequest): DescribeInvocationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInvocations', 'POST', '/', 'json', false, 'json', request);
}

model DescribeKmsKeysRequest {
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeKmsKeysResponseBody = {
  authorizeStatus?: string(name='AuthorizeStatus'),
  keys?: [ 
    {
      alias?: string(name='Alias'),
      arn?: string(name='Arn'),
      keyId?: string(name='KeyId'),
      type?: string(name='Type'),
    }
  ](name='Keys'),
  kmsServiceStatus?: string(name='KmsServiceStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeKmsKeysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeKmsKeysResponseBody(name='body'),
}

async function describeKmsKeys(request: DescribeKmsKeysRequest): DescribeKmsKeysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeKmsKeys', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNASFileSystemsRequest {
  fileSystemId?: [ string ](name='FileSystemId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=0, maximum=500, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeNASFileSystemsResponseBody = {
  fileSystems?: [ 
    {
      capacity?: long(name='Capacity'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      encryptionEnabled?: boolean(name='EncryptionEnabled'),
      fileSystemId?: string(name='FileSystemId'),
      fileSystemName?: string(name='FileSystemName'),
      fileSystemStatus?: string(name='FileSystemStatus'),
      fileSystemType?: string(name='FileSystemType'),
      meteredSize?: long(name='MeteredSize'),
      mountTargetDomain?: string(name='MountTargetDomain'),
      mountTargetStatus?: string(name='MountTargetStatus'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      regionId?: string(name='RegionId'),
      storageType?: string(name='StorageType'),
      supportAcl?: boolean(name='SupportAcl'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='FileSystems'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeNASFileSystemsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNASFileSystemsResponseBody(name='body'),
}

async function describeNASFileSystems(request: DescribeNASFileSystemsRequest): DescribeNASFileSystemsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNASFileSystems', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNetworkPackagesRequest {
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  networkPackageId?: [ string ](name='NetworkPackageId', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeNetworkPackagesResponseBody = {
  networkPackages?: [ 
    {
      bandwidth?: int32(name='Bandwidth'),
      createTime?: string(name='CreateTime'),
      eipAddresses?: [ string ](name='EipAddresses'),
      expiredTime?: string(name='ExpiredTime'),
      internetChargeType?: string(name='InternetChargeType'),
      networkPackageId?: string(name='NetworkPackageId'),
      networkPackageStatus?: string(name='NetworkPackageStatus'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      officeSiteVpcType?: string(name='OfficeSiteVpcType'),
    }
  ](name='NetworkPackages'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeNetworkPackagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkPackagesResponseBody(name='body'),
}

async function describeNetworkPackages(request: DescribeNetworkPackagesRequest): DescribeNetworkPackagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNetworkPackages', 'POST', '/', 'json', false, 'json', request);
}

model DescribeOfficeSitesRequest {
  maxResults?: int32(name='MaxResults', minimum=0, maximum=500, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: [ string ](name='OfficeSiteId', position='Query'),
  officeSiteType?: string(name='OfficeSiteType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  status?: string(name='Status', position='Query'),
}

model DescribeOfficeSitesResponseBody = {
  nextToken?: string(name='NextToken'),
  officeSites?: [ 
    {
      ADConnectors?: [ 
        {
          ADConnectorAddress?: string(name='ADConnectorAddress'),
          connectorStatus?: string(name='ConnectorStatus'),
          networkInterfaceId?: string(name='NetworkInterfaceId'),
          specification?: string(name='Specification'),
          trustKey?: string(name='TrustKey'),
          vSwitchId?: string(name='VSwitchId'),
        }
      ](name='ADConnectors'),
      adHostname?: string(name='AdHostname'),
      bandwidth?: int32(name='Bandwidth'),
      cenId?: string(name='CenId'),
      cidrBlock?: string(name='CidrBlock'),
      cloudBoxOfficeSite?: boolean(name='CloudBoxOfficeSite'),
      creationTime?: string(name='CreationTime'),
      customSecurityGroupId?: string(name='CustomSecurityGroupId'),
      desktopAccessType?: string(name='DesktopAccessType'),
      desktopCount?: long(name='DesktopCount'),
      desktopVpcEndpoint?: string(name='DesktopVpcEndpoint'),
      dnsAddress?: [ string ](name='DnsAddress'),
      dnsUserName?: string(name='DnsUserName'),
      domainName?: string(name='DomainName'),
      domainPassword?: string(name='DomainPassword'),
      domainUserName?: string(name='DomainUserName'),
      enableAdminAccess?: boolean(name='EnableAdminAccess'),
      enableCrossDesktopAccess?: boolean(name='EnableCrossDesktopAccess'),
      enableInternetAccess?: boolean(name='EnableInternetAccess'),
      fileSystemIds?: [ string ](name='FileSystemIds'),
      logs?: [ 
        {
          level?: string(name='Level'),
          message?: string(name='Message'),
          step?: string(name='Step'),
          timeStamp?: string(name='TimeStamp'),
        }
      ](name='Logs'),
      mfaEnabled?: boolean(name='MfaEnabled'),
      name?: string(name='Name'),
      needVerifyLoginRisk?: boolean(name='NeedVerifyLoginRisk'),
      needVerifyZeroDevice?: boolean(name='NeedVerifyZeroDevice'),
      networkPackageId?: string(name='NetworkPackageId'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteType?: string(name='OfficeSiteType'),
      ouName?: string(name='OuName'),
      protocolType?: string(name='ProtocolType'),
      ssoEnabled?: boolean(name='SsoEnabled'),
      ssoType?: string(name='SsoType'),
      status?: string(name='Status'),
      subDnsAddress?: [ string ](name='SubDnsAddress'),
      subDomainName?: string(name='SubDomainName'),
      trustPassword?: string(name='TrustPassword'),
      vSwitchIds?: [ string ](name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
      vpcType?: string(name='VpcType'),
    }
  ](name='OfficeSites'),
  requestId?: string(name='RequestId'),
}

model DescribeOfficeSitesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeOfficeSitesResponseBody(name='body'),
}

async function describeOfficeSites(request: DescribeOfficeSitesRequest): DescribeOfficeSitesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeOfficeSites', 'POST', '/', 'json', false, 'json', request);
}

model DescribePolicyGroupsRequest {
  maxResults?: int32(name='MaxResults', minimum=1, maximum=200, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  policyGroupId?: [ string ](name='PolicyGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribePolicyGroupsResponseBody = {
  describePolicyGroups?: [ 
    {
      appContentProtection?: string(name='AppContentProtection'),
      authorizeAccessPolicyRules?: [ 
        {
          cidrIp?: string(name='CidrIp'),
          description?: string(name='Description'),
        }
      ](name='AuthorizeAccessPolicyRules'),
      authorizeSecurityPolicyRules?: [ 
        {
          cidrIp?: string(name='CidrIp'),
          description?: string(name='Description'),
          ipProtocol?: string(name='IpProtocol'),
          policy?: string(name='Policy'),
          portRange?: string(name='PortRange'),
          priority?: string(name='Priority'),
          type?: string(name='Type'),
        }
      ](name='AuthorizeSecurityPolicyRules'),
      cameraRedirect?: string(name='CameraRedirect'),
      clientTypes?: [ 
        {
          clientType?: string(name='ClientType'),
          status?: string(name='Status'),
        }
      ](name='ClientTypes'),
      clipboard?: string(name='Clipboard'),
      domainList?: string(name='DomainList'),
      edsCount?: int32(name='EdsCount'),
      gpuAcceleration?: string(name='GpuAcceleration'),
      html5Access?: string(name='Html5Access'),
      html5FileTransfer?: string(name='Html5FileTransfer'),
      localDrive?: string(name='LocalDrive'),
      name?: string(name='Name'),
      netRedirect?: string(name='NetRedirect'),
      policyGroupId?: string(name='PolicyGroupId'),
      policyGroupType?: string(name='PolicyGroupType'),
      policyStatus?: string(name='PolicyStatus'),
      preemptLogin?: string(name='PreemptLogin'),
      preemptLoginUsers?: [ string ](name='PreemptLoginUsers'),
      printerRedirection?: string(name='PrinterRedirection'),
      recordContent?: string(name='RecordContent'),
      recordContentExpires?: long(name='RecordContentExpires'),
      recording?: string(name='Recording'),
      recordingEndTime?: string(name='RecordingEndTime'),
      recordingExpires?: long(name='RecordingExpires'),
      recordingFps?: long(name='RecordingFps'),
      recordingStartTime?: string(name='RecordingStartTime'),
      usbRedirect?: string(name='UsbRedirect'),
      usbSupplyRedirectRule?: [ 
        {
          description?: string(name='Description'),
          deviceClass?: string(name='DeviceClass'),
          deviceSubclass?: string(name='DeviceSubclass'),
          productId?: string(name='ProductId'),
          usbRedirectType?: long(name='UsbRedirectType'),
          usbRuleType?: long(name='UsbRuleType'),
          vendorId?: string(name='VendorId'),
        }
      ](name='UsbSupplyRedirectRule'),
      visualQuality?: string(name='VisualQuality'),
      watermark?: string(name='Watermark'),
      watermarkCustomText?: string(name='WatermarkCustomText'),
      watermarkTransparency?: string(name='WatermarkTransparency'),
      watermarkType?: string(name='WatermarkType'),
    }
  ](name='DescribePolicyGroups'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribePolicyGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePolicyGroupsResponseBody(name='body'),
}

async function describePolicyGroups(request: DescribePolicyGroupsRequest): DescribePolicyGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePolicyGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeScanTaskProgressRequest {
  regionId: string(name='RegionId', position='Query'),
  taskId?: long(name='TaskId', position='Query'),
}

model DescribeScanTaskProgressResponseBody = {
  createTime?: string(name='CreateTime'),
  requestId?: string(name='RequestId'),
  taskStatus?: string(name='TaskStatus'),
}

model DescribeScanTaskProgressResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeScanTaskProgressResponseBody(name='body'),
}

async function describeScanTaskProgress(request: DescribeScanTaskProgressRequest): DescribeScanTaskProgressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeScanTaskProgress', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSecurityEventOperationStatusRequest {
  regionId: string(name='RegionId', position='Query'),
  securityEventId: [ string ](name='SecurityEventId', position='Query'),
  taskId: long(name='TaskId', position='Query'),
}

model DescribeSecurityEventOperationStatusResponseBody = {
  requestId?: string(name='RequestId'),
  securityEventOperationStatuses?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      securityEventId?: long(name='SecurityEventId'),
      status?: string(name='Status'),
    }
  ](name='SecurityEventOperationStatuses'),
  taskStatus?: string(name='TaskStatus'),
}

model DescribeSecurityEventOperationStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityEventOperationStatusResponseBody(name='body'),
}

async function describeSecurityEventOperationStatus(request: DescribeSecurityEventOperationStatusRequest): DescribeSecurityEventOperationStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecurityEventOperationStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSecurityEventOperationsRequest {
  regionId: string(name='RegionId', position='Query'),
  securityEventId: long(name='SecurityEventId', position='Query'),
}

model DescribeSecurityEventOperationsResponseBody = {
  requestId?: string(name='RequestId'),
  securityEventOperations?: [ 
    {
      operationCode?: string(name='OperationCode'),
      operationParams?: string(name='OperationParams'),
      userCanOperate?: boolean(name='UserCanOperate'),
    }
  ](name='SecurityEventOperations'),
}

model DescribeSecurityEventOperationsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityEventOperationsResponseBody(name='body'),
}

async function describeSecurityEventOperations(request: DescribeSecurityEventOperationsRequest): DescribeSecurityEventOperationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecurityEventOperations', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSnapshotsRequest {
  desktopId?: string(name='DesktopId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  snapshotId?: string(name='SnapshotId', position='Query'),
}

model DescribeSnapshotsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  snapshots?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      desktopId?: string(name='DesktopId'),
      progress?: string(name='Progress'),
      protocolType?: string(name='ProtocolType'),
      remainTime?: int32(name='RemainTime'),
      snapshotId?: string(name='SnapshotId'),
      snapshotName?: string(name='SnapshotName'),
      snapshotType?: string(name='SnapshotType'),
      sourceDiskSize?: string(name='SourceDiskSize'),
      sourceDiskType?: string(name='SourceDiskType'),
      status?: string(name='Status'),
      volumeEncryptionEnabled?: boolean(name='VolumeEncryptionEnabled'),
      volumeEncryptionKey?: string(name='VolumeEncryptionKey'),
    }
  ](name='Snapshots'),
}

model DescribeSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotsResponseBody(name='body'),
}

async function describeSnapshots(request: DescribeSnapshotsRequest): DescribeSnapshotsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSnapshots', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSuspEventOverviewRequest {
  regionId: string(name='RegionId', position='Query'),
}

model DescribeSuspEventOverviewResponseBody = {
  remindCount?: int32(name='RemindCount'),
  requestId?: string(name='RequestId'),
  seriousCount?: int32(name='SeriousCount'),
  suspiciousCount?: int32(name='SuspiciousCount'),
}

model DescribeSuspEventOverviewResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSuspEventOverviewResponseBody(name='body'),
}

async function describeSuspEventOverview(request: DescribeSuspEventOverviewRequest): DescribeSuspEventOverviewResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSuspEventOverview', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSuspEventQuaraFilesRequest {
  currentPage?: int32(name='CurrentPage', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  status?: string(name='Status', position='Query'),
}

model DescribeSuspEventQuaraFilesResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  quaraFiles?: [ 
    {
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      eventName?: string(name='EventName'),
      eventType?: string(name='EventType'),
      id?: int32(name='Id'),
      md5?: string(name='Md5'),
      modifyTime?: string(name='ModifyTime'),
      path?: string(name='Path'),
      status?: string(name='Status'),
      tag?: string(name='Tag'),
    }
  ](name='QuaraFiles'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSuspEventQuaraFilesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSuspEventQuaraFilesResponseBody(name='body'),
}

async function describeSuspEventQuaraFiles(request: DescribeSuspEventQuaraFilesRequest): DescribeSuspEventQuaraFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSuspEventQuaraFiles', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSuspEventsRequest {
  alarmUniqueInfo?: string(name='AlarmUniqueInfo', position='Query'),
  currentPage?: int32(name='CurrentPage', position='Query'),
  dealed?: string(name='Dealed', position='Query'),
  lang?: string(name='Lang', position='Query'),
  levels?: string(name='Levels', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  parentEventType?: string(name='ParentEventType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeSuspEventsResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId'),
  suspEvents?: [ 
    {
      alarmEventName?: string(name='AlarmEventName'),
      alarmEventNameDisplay?: string(name='AlarmEventNameDisplay'),
      alarmEventType?: string(name='AlarmEventType'),
      alarmEventTypeDisplay?: string(name='AlarmEventTypeDisplay'),
      alarmUniqueInfo?: string(name='AlarmUniqueInfo'),
      canBeDealOnLine?: string(name='CanBeDealOnLine'),
      canCancelFault?: boolean(name='CanCancelFault'),
      dataSource?: string(name='DataSource'),
      desc?: string(name='Desc'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      details?: [ 
        {
          name?: string(name='Name'),
          nameDisplay?: string(name='NameDisplay'),
          type?: string(name='Type'),
          value?: string(name='Value'),
          valueDisplay?: string(name='ValueDisplay'),
        }
      ](name='Details'),
      eventStatus?: int32(name='EventStatus'),
      eventSubType?: string(name='EventSubType'),
      id?: long(name='Id'),
      lastTime?: string(name='LastTime'),
      level?: string(name='Level'),
      name?: string(name='Name'),
      occurrenceTime?: string(name='OccurrenceTime'),
      operateErrorCode?: string(name='OperateErrorCode'),
      operateMsg?: string(name='OperateMsg'),
      uniqueInfo?: string(name='UniqueInfo'),
    }
  ](name='SuspEvents'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSuspEventsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSuspEventsResponseBody(name='body'),
}

async function describeSuspEvents(request: DescribeSuspEventsRequest): DescribeSuspEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSuspEvents', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUserConnectionRecordsRequest {
  connectDurationFrom?: long(name='ConnectDurationFrom', position='Query'),
  connectDurationTo?: long(name='ConnectDurationTo', position='Query'),
  connectEndTimeFrom?: long(name='ConnectEndTimeFrom', position='Query'),
  connectEndTimeTo?: long(name='ConnectEndTimeTo', position='Query'),
  connectStartTimeFrom?: long(name='ConnectStartTimeFrom', position='Query'),
  connectStartTimeTo?: long(name='ConnectStartTimeTo', position='Query'),
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  desktopId?: string(name='DesktopId', position='Query'),
  endUserId: string(name='EndUserId', position='Query'),
  endUserType?: string(name='EndUserType', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeUserConnectionRecordsResponseBody = {
  connectionRecords?: [ 
    {
      connectDuration?: string(name='ConnectDuration'),
      connectEndTime?: string(name='ConnectEndTime'),
      connectStartTime?: string(name='ConnectStartTime'),
      connectionRecordId?: string(name='ConnectionRecordId'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
    }
  ](name='ConnectionRecords'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeUserConnectionRecordsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUserConnectionRecordsResponseBody(name='body'),
}

async function describeUserConnectionRecords(request: DescribeUserConnectionRecordsRequest): DescribeUserConnectionRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUserConnectionRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUsersInGroupRequest {
  connectState?: int32(name='ConnectState', position='Query'),
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  endUserId?: string(name='EndUserId', position='Query'),
  filter?: string(name='Filter', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  queryUserDetail?: boolean(name='QueryUserDetail', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeUsersInGroupResponseBody = {
  endUsers?: [ 
    {
      connectionStatus?: string(name='ConnectionStatus'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      endUserEmail?: string(name='EndUserEmail'),
      endUserId?: string(name='EndUserId'),
      endUserName?: string(name='EndUserName'),
      endUserPhone?: string(name='EndUserPhone'),
      endUserType?: string(name='EndUserType'),
      externalInfo?: {
        externalName?: string(name='ExternalName'),
        jobNumber?: string(name='JobNumber'),
      }(name='ExternalInfo'),
      userDesktopId?: string(name='UserDesktopId'),
      userSetPropertiesModels?: [ 
        {
          propertyId?: long(name='PropertyId'),
          propertyKey?: string(name='PropertyKey'),
          propertyType?: int32(name='PropertyType'),
          propertyValues?: [ 
            {
              propertyValue?: string(name='PropertyValue'),
              propertyValueId?: long(name='PropertyValueId'),
            }
          ](name='PropertyValues'),
          userId?: long(name='UserId'),
          userName?: string(name='UserName'),
        }
      ](name='UserSetPropertiesModels'),
    }
  ](name='EndUsers'),
  nextToken?: string(name='NextToken'),
  onlineUsersCount?: int32(name='OnlineUsersCount'),
  requestId?: string(name='RequestId'),
  usersCount?: int32(name='UsersCount'),
}

model DescribeUsersInGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUsersInGroupResponseBody(name='body'),
}

async function describeUsersInGroup(request: DescribeUsersInGroupRequest): DescribeUsersInGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUsersInGroup', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUsersPasswordRequest {
  desktopId: string(name='DesktopId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeUsersPasswordResponseBody = {
  desktopUsers?: [ 
    {
      displayName?: string(name='DisplayName'),
      endUserId?: string(name='EndUserId'),
      password?: string(name='Password'),
    }
  ](name='DesktopUsers'),
  requestId?: string(name='RequestId'),
}

model DescribeUsersPasswordResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUsersPasswordResponseBody(name='body'),
}

async function describeUsersPassword(request: DescribeUsersPasswordRequest): DescribeUsersPasswordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUsersPassword', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVirtualMFADevicesRequest {
  endUserId?: [ string ](name='EndUserId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=0, maximum=500, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeVirtualMFADevicesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  virtualMFADevices?: [ 
    {
      consecutiveFails?: int32(name='ConsecutiveFails'),
      directoryId?: string(name='DirectoryId'),
      endUserId?: string(name='EndUserId'),
      gmtEnabled?: string(name='GmtEnabled'),
      gmtUnlock?: string(name='GmtUnlock'),
      officeSiteId?: string(name='OfficeSiteId'),
      serialNumber?: string(name='SerialNumber'),
      status?: string(name='status'),
    }
  ](name='VirtualMFADevices'),
}

model DescribeVirtualMFADevicesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVirtualMFADevicesResponseBody(name='body'),
}

async function describeVirtualMFADevices(request: DescribeVirtualMFADevicesRequest): DescribeVirtualMFADevicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVirtualMFADevices', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVulDetailsRequest {
  aliasName?: string(name='AliasName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  name: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
}

model DescribeVulDetailsResponseBody = {
  cves?: [ 
    {
      cveId?: string(name='CveId'),
      cvssScore?: string(name='CvssScore'),
      summary?: string(name='Summary'),
      title?: string(name='Title'),
    }
  ](name='Cves'),
  requestId?: string(name='RequestId'),
}

model DescribeVulDetailsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVulDetailsResponseBody(name='body'),
}

async function describeVulDetails(request: DescribeVulDetailsRequest): DescribeVulDetailsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVulDetails', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVulListRequest {
  aliasName?: string(name='AliasName', position='Query'),
  currentPage?: int32(name='CurrentPage', position='Query'),
  dealed?: string(name='Dealed', position='Query'),
  lang?: string(name='Lang', position='Query'),
  name?: string(name='Name', position='Query'),
  necessity?: string(name='Necessity', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
}

model DescribeVulListResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vulRecords?: [ 
    {
      aliasName?: string(name='AliasName'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      extendContentJson?: {
        rpmEntityList?: [ 
          {
            fullVersion?: string(name='FullVersion'),
            matchDetail?: string(name='MatchDetail'),
            name?: string(name='Name'),
            path?: string(name='Path'),
            updateCmd?: string(name='UpdateCmd'),
          }
        ](name='RpmEntityList'),
      }(name='ExtendContentJson'),
      firstTs?: long(name='FirstTs'),
      lastTs?: long(name='LastTs'),
      modifyTs?: long(name='ModifyTs'),
      name?: string(name='Name'),
      necessity?: string(name='Necessity'),
      online?: boolean(name='Online'),
      osVersion?: string(name='OsVersion'),
      related?: string(name='Related'),
      repairTs?: long(name='RepairTs'),
      resultCode?: string(name='ResultCode'),
      resultMessage?: string(name='ResultMessage'),
      status?: int32(name='Status'),
      tag?: string(name='Tag'),
      type?: string(name='Type'),
    }
  ](name='VulRecords'),
}

model DescribeVulListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVulListResponseBody(name='body'),
}

async function describeVulList(request: DescribeVulListRequest): DescribeVulListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVulList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVulOverviewRequest {
  regionId: string(name='RegionId', position='Query'),
}

model DescribeVulOverviewResponseBody = {
  asapCount?: int32(name='AsapCount'),
  laterCount?: int32(name='LaterCount'),
  nntfCount?: int32(name='NntfCount'),
  requestId?: string(name='RequestId'),
}

model DescribeVulOverviewResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVulOverviewResponseBody(name='body'),
}

async function describeVulOverview(request: DescribeVulOverviewRequest): DescribeVulOverviewResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVulOverview', 'POST', '/', 'json', false, 'json', request);
}

model DescribeZonesRequest {
  regionId: string(name='RegionId', position='Query'),
  zoneType?: string(name='ZoneType', position='Query'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: [ 
    {
      zoneId?: string(name='ZoneId'),
    }
  ](name='Zones'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeZonesResponseBody(name='body'),
}

async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeZones', 'POST', '/', 'json', false, 'json', request);
}

model DetachCenRequest {
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DetachCenResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachCenResponse = {
  headers: map[string]string(name='headers'),
  body: DetachCenResponseBody(name='body'),
}

async function detachCen(request: DetachCenRequest): DetachCenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachCen', 'POST', '/', 'json', false, 'json', request);
}

model DisableDesktopsInGroupRequest {
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  desktopIds: [ string ](name='DesktopIds', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DisableDesktopsInGroupResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DisableDesktopsInGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DisableDesktopsInGroupResponseBody(name='body'),
}

async function disableDesktopsInGroup(request: DisableDesktopsInGroupRequest): DisableDesktopsInGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableDesktopsInGroup', 'POST', '/', 'json', false, 'json', request);
}

model DissociateNetworkPackageRequest {
  networkPackageId: string(name='NetworkPackageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DissociateNetworkPackageResponseBody = {
  requestId?: string(name='RequestId'),
}

model DissociateNetworkPackageResponse = {
  headers: map[string]string(name='headers'),
  body: DissociateNetworkPackageResponseBody(name='body'),
}

async function dissociateNetworkPackage(request: DissociateNetworkPackageRequest): DissociateNetworkPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DissociateNetworkPackage', 'POST', '/', 'json', false, 'json', request);
}

model ExportClientEventsRequest {
  desktopId?: string(name='DesktopId', position='Query'),
  desktopName?: string(name='DesktopName', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  endUserId?: string(name='EndUserId', position='Query'),
  eventType?: string(name='EventType', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  officeSiteName?: string(name='OfficeSiteName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model ExportClientEventsResponseBody = {
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model ExportClientEventsResponse = {
  headers: map[string]string(name='headers'),
  body: ExportClientEventsResponseBody(name='body'),
}

async function exportClientEvents(request: ExportClientEventsRequest): ExportClientEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportClientEvents', 'POST', '/', 'json', false, 'json', request);
}

model ExportDesktopGroupInfoRequest {
  chargeType?: string(name='ChargeType', position='Query'),
  desktopGroupId?: [ string ](name='DesktopGroupId', position='Query'),
  desktopGroupName?: string(name='DesktopGroupName', position='Query'),
  endUserId?: [ string ](name='EndUserId', position='Query'),
  expiredTime?: string(name='ExpiredTime', position='Query'),
  langType?: string(name='LangType', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  policyGroupId?: string(name='PolicyGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ExportDesktopGroupInfoResponseBody = {
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model ExportDesktopGroupInfoResponse = {
  headers: map[string]string(name='headers'),
  body: ExportDesktopGroupInfoResponseBody(name='body'),
}

async function exportDesktopGroupInfo(request: ExportDesktopGroupInfoRequest): ExportDesktopGroupInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportDesktopGroupInfo', 'POST', '/', 'json', false, 'json', request);
}

model ExportDesktopListInfoRequest {
  chargeType?: string(name='ChargeType', position='Query'),
  desktopId?: [ string ](name='DesktopId', position='Query'),
  desktopName?: string(name='DesktopName', position='Query'),
  desktopStatus?: string(name='DesktopStatus', position='Query'),
  endUserId?: [ string ](name='EndUserId', position='Query'),
  expiredTime?: string(name='ExpiredTime', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  langType?: string(name='LangType', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  policyGroupId?: string(name='PolicyGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  userName?: string(name='UserName', position='Query'),
}

model ExportDesktopListInfoResponseBody = {
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model ExportDesktopListInfoResponse = {
  headers: map[string]string(name='headers'),
  body: ExportDesktopListInfoResponseBody(name='body'),
}

async function exportDesktopListInfo(request: ExportDesktopListInfoRequest): ExportDesktopListInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportDesktopListInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetConnectionTicketRequest {
  desktopId?: string(name='DesktopId', position='Query'),
  endUserId?: string(name='EndUserId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  password?: string(name='Password', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  taskId?: string(name='TaskId', position='Query'),
  uuid?: string(name='Uuid', position='Query'),
}

model GetConnectionTicketResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  taskStatus?: string(name='TaskStatus'),
  ticket?: string(name='Ticket'),
}

model GetConnectionTicketResponse = {
  headers: map[string]string(name='headers'),
  body: GetConnectionTicketResponseBody(name='body'),
}

async function getConnectionTicket(request: GetConnectionTicketRequest): GetConnectionTicketResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetConnectionTicket', 'POST', '/', 'json', false, 'json', request);
}

model GetDesktopGroupDetailRequest {
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetDesktopGroupDetailResponseBody = {
  desktops?: {
    allowAutoSetup?: int32(name='AllowAutoSetup'),
    allowBufferCount?: int32(name='AllowBufferCount'),
    bindAmount?: int32(name='BindAmount'),
    comments?: string(name='Comments'),
    connectDuration?: long(name='ConnectDuration'),
    cpu?: int32(name='Cpu'),
    creationTime?: string(name='CreationTime'),
    creator?: string(name='Creator'),
    dataDiskCategory?: string(name='DataDiskCategory'),
    dataDiskSize?: string(name='DataDiskSize'),
    desktopGroupId?: string(name='DesktopGroupId'),
    desktopGroupName?: string(name='DesktopGroupName'),
    directoryId?: string(name='DirectoryId'),
    directoryType?: string(name='DirectoryType'),
    expiredTime?: string(name='ExpiredTime'),
    gpuCount?: float(name='GpuCount'),
    gpuSpec?: string(name='GpuSpec'),
    idleDisconnectDuration?: long(name='IdleDisconnectDuration'),
    keepDuration?: long(name='KeepDuration'),
    loadPolicy?: int32(name='LoadPolicy'),
    maxDesktopsCount?: int32(name='MaxDesktopsCount'),
    memory?: long(name='Memory'),
    minDesktopsCount?: int32(name='MinDesktopsCount'),
    officeSiteId?: string(name='OfficeSiteId'),
    officeSiteName?: string(name='OfficeSiteName'),
    officeSiteType?: string(name='OfficeSiteType'),
    ownBundleId?: string(name='OwnBundleId'),
    ownBundleName?: string(name='OwnBundleName'),
    ownType?: int32(name='OwnType'),
    payType?: string(name='PayType'),
    policyGroupId?: string(name='PolicyGroupId'),
    policyGroupName?: string(name='PolicyGroupName'),
    ratioThreshold?: float(name='RatioThreshold'),
    resType?: int32(name='ResType'),
    resetType?: int32(name='ResetType'),
    status?: int32(name='Status'),
    stopDuration?: long(name='StopDuration'),
    systemDiskCategory?: string(name='SystemDiskCategory'),
    systemDiskSize?: int32(name='SystemDiskSize'),
    timerInfos?: [ 
      {
        cronExpression?: string(name='CronExpression'),
        forced?: boolean(name='Forced'),
        status?: int32(name='Status'),
        timerType?: int32(name='TimerType'),
      }
    ](name='TimerInfos'),
    version?: long(name='Version'),
  }(name='Desktops'),
  requestId?: string(name='RequestId'),
}

model GetDesktopGroupDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetDesktopGroupDetailResponseBody(name='body'),
}

async function getDesktopGroupDetail(request: GetDesktopGroupDetailRequest): GetDesktopGroupDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDesktopGroupDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetOfficeSiteSsoStatusRequest {
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetOfficeSiteSsoStatusResponseBody = {
  requestId?: string(name='RequestId'),
  ssoStatus?: boolean(name='SsoStatus'),
}

model GetOfficeSiteSsoStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetOfficeSiteSsoStatusResponseBody(name='body'),
}

async function getOfficeSiteSsoStatus(request: GetOfficeSiteSsoStatusRequest): GetOfficeSiteSsoStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetOfficeSiteSsoStatus', 'POST', '/', 'json', false, 'json', request);
}

model GetSpMetadataRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetSpMetadataResponseBody = {
  requestId?: string(name='RequestId'),
  spMetadata?: string(name='SpMetadata'),
}

model GetSpMetadataResponse = {
  headers: map[string]string(name='headers'),
  body: GetSpMetadataResponseBody(name='body'),
}

async function getSpMetadata(request: GetSpMetadataRequest): GetSpMetadataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSpMetadata', 'POST', '/', 'json', false, 'json', request);
}

model HandleSecurityEventsRequest {
  operationCode: string(name='OperationCode', position='Query'),
  operationParams?: string(name='OperationParams', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  securityEvent: [ 
    {
      desktopId?: string(name='DesktopId'),
      securityEventId?: string(name='SecurityEventId'),
    }
  ](name='SecurityEvent', position='Query'),
}

model HandleSecurityEventsResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: long(name='TaskId'),
}

model HandleSecurityEventsResponse = {
  headers: map[string]string(name='headers'),
  body: HandleSecurityEventsResponseBody(name='body'),
}

async function handleSecurityEvents(request: HandleSecurityEventsRequest): HandleSecurityEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'HandleSecurityEvents', 'POST', '/', 'json', false, 'json', request);
}

model ListDirectoryUsersRequest {
  directoryId: string(name='DirectoryId', position='Query'),
  filter?: string(name='Filter', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  OUPath?: string(name='OUPath', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListDirectoryUsersResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  users?: [ 
    {
      displayName?: string(name='DisplayName'),
      endUser?: string(name='EndUser'),
    }
  ](name='Users'),
}

model ListDirectoryUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListDirectoryUsersResponseBody(name='body'),
}

async function listDirectoryUsers(request: ListDirectoryUsersRequest): ListDirectoryUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDirectoryUsers', 'POST', '/', 'json', false, 'json', request);
}

model ListOfficeSiteOverviewRequest {
  forceRefresh?: boolean(name='ForceRefresh', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: [ string ](name='OfficeSiteId', position='Query'),
  queryRange?: int32(name='QueryRange', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListOfficeSiteOverviewResponseBody = {
  nextToken?: string(name='NextToken'),
  officeSiteOverviewResults?: [ 
    {
      hasExpiredEdsCount?: int32(name='HasExpiredEdsCount'),
      hasExpiredEdsCountForGroup?: int32(name='HasExpiredEdsCountForGroup'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      officeSiteStatus?: string(name='OfficeSiteStatus'),
      regionId?: string(name='RegionId'),
      runningEdsCount?: int32(name='RunningEdsCount'),
      runningEdsCountForGroup?: int32(name='RunningEdsCountForGroup'),
      totalEdsCount?: int32(name='TotalEdsCount'),
      totalEdsCountForGroup?: int32(name='TotalEdsCountForGroup'),
      vpcType?: string(name='VpcType'),
      willExpiredEdsCount?: int32(name='WillExpiredEdsCount'),
      willExpiredEdsCountForGroup?: int32(name='WillExpiredEdsCountForGroup'),
    }
  ](name='OfficeSiteOverviewResults'),
  requestId?: string(name='RequestId'),
}

model ListOfficeSiteOverviewResponse = {
  headers: map[string]string(name='headers'),
  body: ListOfficeSiteOverviewResponseBody(name='body'),
}

async function listOfficeSiteOverview(request: ListOfficeSiteOverviewRequest): ListOfficeSiteOverviewResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListOfficeSiteOverview', 'POST', '/', 'json', false, 'json', request);
}

model ListOfficeSiteUsersRequest {
  filter?: string(name='Filter', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  OUPath?: string(name='OUPath', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListOfficeSiteUsersResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  users?: [ 
    {
      displayName?: string(name='DisplayName'),
      endUser?: string(name='EndUser'),
    }
  ](name='Users'),
}

model ListOfficeSiteUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListOfficeSiteUsersResponseBody(name='body'),
}

async function listOfficeSiteUsers(request: ListOfficeSiteUsersRequest): ListOfficeSiteUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListOfficeSiteUsers', 'POST', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ListUserAdOrganizationUnitsRequest {
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListUserAdOrganizationUnitsResponseBody = {
  OUNames?: [ 
    {
      OUName?: string(name='OUName'),
      officeSiteId?: string(name='OfficeSiteId'),
    }
  ](name='OUNames'),
  requestId?: string(name='RequestId'),
}

model ListUserAdOrganizationUnitsResponse = {
  headers: map[string]string(name='headers'),
  body: ListUserAdOrganizationUnitsResponseBody(name='body'),
}

async function listUserAdOrganizationUnits(request: ListUserAdOrganizationUnitsRequest): ListUserAdOrganizationUnitsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserAdOrganizationUnits', 'POST', '/', 'json', false, 'json', request);
}

model LockVirtualMFADeviceRequest {
  regionId: string(name='RegionId', position='Query'),
  serialNumber: string(name='SerialNumber', position='Query'),
}

model LockVirtualMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model LockVirtualMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  body: LockVirtualMFADeviceResponseBody(name='body'),
}

async function lockVirtualMFADevice(request: LockVirtualMFADeviceRequest): LockVirtualMFADeviceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'LockVirtualMFADevice', 'POST', '/', 'json', false, 'json', request);
}

model ModifyADConnectorDirectoryRequest {
  adHostname?: string(name='AdHostname', position='Query'),
  directoryId: string(name='DirectoryId', position='Query'),
  directoryName?: string(name='DirectoryName', position='Query'),
  dnsAddress?: [ string ](name='DnsAddress', position='Query'),
  domainName?: string(name='DomainName', position='Query'),
  domainPassword?: string(name='DomainPassword', position='Query'),
  domainUserName?: string(name='DomainUserName', position='Query'),
  mfaEnabled?: boolean(name='MfaEnabled', position='Query'),
  OUName?: string(name='OUName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  subDomainDnsAddress?: [ string ](name='SubDomainDnsAddress', position='Query'),
  subDomainName?: string(name='SubDomainName', position='Query'),
}

model ModifyADConnectorDirectoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyADConnectorDirectoryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyADConnectorDirectoryResponseBody(name='body'),
}

async function modifyADConnectorDirectory(request: ModifyADConnectorDirectoryRequest): ModifyADConnectorDirectoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyADConnectorDirectory', 'POST', '/', 'json', false, 'json', request);
}

model ModifyADConnectorOfficeSiteRequest {
  adHostname?: string(name='AdHostname', position='Query'),
  dnsAddress?: [ string ](name='DnsAddress', position='Query'),
  domainName?: string(name='DomainName', position='Query'),
  domainPassword?: string(name='DomainPassword', position='Query'),
  domainUserName?: string(name='DomainUserName', position='Query'),
  mfaEnabled?: boolean(name='MfaEnabled', position='Query'),
  OUName?: string(name='OUName', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  officeSiteName?: string(name='OfficeSiteName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  subDomainDnsAddress?: [ string ](name='SubDomainDnsAddress', position='Query'),
  subDomainName?: string(name='SubDomainName', position='Query'),
}

model ModifyADConnectorOfficeSiteResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyADConnectorOfficeSiteResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyADConnectorOfficeSiteResponseBody(name='body'),
}

async function modifyADConnectorOfficeSite(request: ModifyADConnectorOfficeSiteRequest): ModifyADConnectorOfficeSiteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyADConnectorOfficeSite', 'POST', '/', 'json', false, 'json', request);
}

model ModifyBundleRequest {
  bundleId: string(name='BundleId', position='Query'),
  bundleName?: string(name='BundleName', position='Query'),
  description?: string(name='Description', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  language?: string(name='Language', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyBundleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBundleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBundleResponseBody(name='body'),
}

async function modifyBundle(request: ModifyBundleRequest): ModifyBundleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyBundle', 'POST', '/', 'json', false, 'json', request);
}

model ModifyCloudDrivePermissionRequest {
  cdsId: string(name='CdsId', position='Query'),
  downloadEndUserIds?: [ string ](name='DownloadEndUserIds', position='Query'),
  downloadUploadEndUserIds?: [ string ](name='DownloadUploadEndUserIds', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyCloudDrivePermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCloudDrivePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCloudDrivePermissionResponseBody(name='body'),
}

async function modifyCloudDrivePermission(request: ModifyCloudDrivePermissionRequest): ModifyCloudDrivePermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCloudDrivePermission', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDesktopChargeTypeRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  chargeType?: string(name='ChargeType', position='Query'),
  desktopId: [ string ](name='DesktopId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyDesktopChargeTypeResponseBody = {
  desktopId?: [ string ](name='DesktopId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyDesktopChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDesktopChargeTypeResponseBody(name='body'),
}

async function modifyDesktopChargeType(request: ModifyDesktopChargeTypeRequest): ModifyDesktopChargeTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDesktopChargeType', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDesktopGroupRequest {
  allowAutoSetup?: int32(name='AllowAutoSetup', minimum=0, maximum=1, position='Query'),
  allowBufferCount?: int32(name='AllowBufferCount', minimum=0, maximum=1000, position='Query'),
  bindAmount?: long(name='BindAmount', position='Query'),
  classify?: string(name='Classify', position='Query'),
  comments?: string(name='Comments', position='Query'),
  connectDuration?: long(name='ConnectDuration', position='Query'),
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  desktopGroupName?: string(name='DesktopGroupName', position='Query'),
  disableSessionConfig?: boolean(name='DisableSessionConfig', position='Query'),
  idleDisconnectDuration?: long(name='IdleDisconnectDuration', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  keepDuration?: long(name='KeepDuration', position='Query'),
  loadPolicy?: long(name='LoadPolicy', position='Query'),
  maxDesktopsCount?: int32(name='MaxDesktopsCount', minimum=0, maximum=1000, position='Query'),
  minDesktopsCount?: int32(name='MinDesktopsCount', minimum=0, maximum=500, position='Query'),
  ownBundleId?: string(name='OwnBundleId', position='Query'),
  policyGroupId?: string(name='PolicyGroupId', position='Query'),
  ratioThreshold?: float(name='RatioThreshold', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resetType?: long(name='ResetType', position='Query'),
  scaleStrategyId?: string(name='ScaleStrategyId', position='Query'),
  stopDuration?: long(name='StopDuration', position='Query'),
}

model ModifyDesktopGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDesktopGroupResponseBody(name='body'),
}

async function modifyDesktopGroup(request: ModifyDesktopGroupRequest): ModifyDesktopGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDesktopGroup', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDesktopHostNameRequest {
  desktopId: string(name='DesktopId', position='Query'),
  newHostName: string(name='NewHostName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyDesktopHostNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDesktopHostNameResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDesktopHostNameResponseBody(name='body'),
}

async function modifyDesktopHostName(request: ModifyDesktopHostNameRequest): ModifyDesktopHostNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDesktopHostName', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDesktopNameRequest {
  desktopId: string(name='DesktopId', position='Query'),
  newDesktopName: string(name='NewDesktopName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyDesktopNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDesktopNameResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDesktopNameResponseBody(name='body'),
}

async function modifyDesktopName(request: ModifyDesktopNameRequest): ModifyDesktopNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDesktopName', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDesktopSpecRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  desktopId: string(name='DesktopId', position='Query'),
  desktopType?: string(name='DesktopType', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  rootDiskSizeGib?: int32(name='RootDiskSizeGib', minimum=0, maximum=32768, position='Query'),
  userDiskPerformanceLevel?: string(name='UserDiskPerformanceLevel', position='Query'),
  userDiskSizeGib?: int32(name='UserDiskSizeGib', minimum=0, maximum=32768, position='Query'),
}

model ModifyDesktopSpecResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyDesktopSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDesktopSpecResponseBody(name='body'),
}

async function modifyDesktopSpec(request: ModifyDesktopSpecRequest): ModifyDesktopSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDesktopSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDesktopsPolicyGroupRequest {
  desktopId: [ string ](name='DesktopId', position='Query'),
  policyGroupId: string(name='PolicyGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyDesktopsPolicyGroupResponseBody = {
  modifyResults?: [ 
    {
      code?: string(name='Code'),
      desktopId?: string(name='DesktopId'),
      message?: string(name='Message'),
    }
  ](name='ModifyResults'),
  requestId?: string(name='RequestId'),
}

model ModifyDesktopsPolicyGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDesktopsPolicyGroupResponseBody(name='body'),
}

async function modifyDesktopsPolicyGroup(request: ModifyDesktopsPolicyGroupRequest): ModifyDesktopsPolicyGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDesktopsPolicyGroup', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDiskSpecRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  desktopId: string(name='DesktopId', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  rootDiskPerformanceLevel?: string(name='RootDiskPerformanceLevel', position='Query'),
  userDiskPerformanceLevel?: string(name='UserDiskPerformanceLevel', position='Query'),
}

model ModifyDiskSpecResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyDiskSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDiskSpecResponseBody(name='body'),
}

async function modifyDiskSpec(request: ModifyDiskSpecRequest): ModifyDiskSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDiskSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifyEntitlementRequest {
  desktopId: string(name='DesktopId', position='Query'),
  endUserId?: [ string ](name='EndUserId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyEntitlementResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyEntitlementResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyEntitlementResponseBody(name='body'),
}

async function modifyEntitlement(request: ModifyEntitlementRequest): ModifyEntitlementResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyEntitlement', 'POST', '/', 'json', false, 'json', request);
}

model ModifyImageAttributeRequest {
  description?: string(name='Description', position='Query'),
  imageId: string(name='ImageId', position='Query'),
  name?: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyImageAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyImageAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyImageAttributeResponseBody(name='body'),
}

async function modifyImageAttribute(request: ModifyImageAttributeRequest): ModifyImageAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyImageAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyImagePermissionRequest {
  addAccount?: [ long ](name='AddAccount', position='Query'),
  imageId: string(name='ImageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  removeAccount?: [ long ](name='RemoveAccount', position='Query'),
}

model ModifyImagePermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyImagePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyImagePermissionResponseBody(name='body'),
}

async function modifyImagePermission(request: ModifyImagePermissionRequest): ModifyImagePermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyImagePermission', 'POST', '/', 'json', false, 'json', request);
}

model ModifyNASDefaultMountTargetRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  mountTargetDomain: string(name='MountTargetDomain', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyNASDefaultMountTargetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNASDefaultMountTargetResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNASDefaultMountTargetResponseBody(name='body'),
}

async function modifyNASDefaultMountTarget(request: ModifyNASDefaultMountTargetRequest): ModifyNASDefaultMountTargetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNASDefaultMountTarget', 'POST', '/', 'json', false, 'json', request);
}

model ModifyNetworkPackageBandwidthRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  bandwidth: int32(name='Bandwidth', minimum=2, maximum=1000, position='Query'),
  networkPackageId: string(name='NetworkPackageId', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyNetworkPackageBandwidthResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyNetworkPackageBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNetworkPackageBandwidthResponseBody(name='body'),
}

async function modifyNetworkPackageBandwidth(request: ModifyNetworkPackageBandwidthRequest): ModifyNetworkPackageBandwidthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNetworkPackageBandwidth', 'POST', '/', 'json', false, 'json', request);
}

model ModifyNetworkPackageEnabledRequest {
  enabled?: boolean(name='Enabled', position='Query'),
  networkPackageId: string(name='NetworkPackageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyNetworkPackageEnabledResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNetworkPackageEnabledResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNetworkPackageEnabledResponseBody(name='body'),
}

async function modifyNetworkPackageEnabled(request: ModifyNetworkPackageEnabledRequest): ModifyNetworkPackageEnabledResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNetworkPackageEnabled', 'POST', '/', 'json', false, 'json', request);
}

model ModifyOfficeSiteAttributeRequest {
  desktopAccessType?: string(name='DesktopAccessType', position='Query'),
  needVerifyLoginRisk?: boolean(name='NeedVerifyLoginRisk', position='Query'),
  needVerifyZeroDevice?: boolean(name='NeedVerifyZeroDevice', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  officeSiteName?: string(name='OfficeSiteName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyOfficeSiteAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyOfficeSiteAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyOfficeSiteAttributeResponseBody(name='body'),
}

async function modifyOfficeSiteAttribute(request: ModifyOfficeSiteAttributeRequest): ModifyOfficeSiteAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyOfficeSiteAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyOfficeSiteCrossDesktopAccessRequest {
  enableCrossDesktopAccess: boolean(name='EnableCrossDesktopAccess', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyOfficeSiteCrossDesktopAccessResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyOfficeSiteCrossDesktopAccessResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyOfficeSiteCrossDesktopAccessResponseBody(name='body'),
}

async function modifyOfficeSiteCrossDesktopAccess(request: ModifyOfficeSiteCrossDesktopAccessRequest): ModifyOfficeSiteCrossDesktopAccessResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyOfficeSiteCrossDesktopAccess', 'POST', '/', 'json', false, 'json', request);
}

model ModifyOfficeSiteMfaEnabledRequest {
  mfaEnabled: boolean(name='MfaEnabled', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyOfficeSiteMfaEnabledResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyOfficeSiteMfaEnabledResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyOfficeSiteMfaEnabledResponseBody(name='body'),
}

async function modifyOfficeSiteMfaEnabled(request: ModifyOfficeSiteMfaEnabledRequest): ModifyOfficeSiteMfaEnabledResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyOfficeSiteMfaEnabled', 'POST', '/', 'json', false, 'json', request);
}

model ModifyOperateVulRequest {
  operateType: string(name='OperateType', position='Query'),
  reason?: string(name='Reason', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
  vulInfo: [ 
    {
      desktopId?: string(name='DesktopId'),
      name?: string(name='Name'),
      tag?: string(name='Tag'),
    }
  ](name='VulInfo', position='Query'),
}

model ModifyOperateVulResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyOperateVulResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyOperateVulResponseBody(name='body'),
}

async function modifyOperateVul(request: ModifyOperateVulRequest): ModifyOperateVulResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyOperateVul', 'POST', '/', 'json', false, 'json', request);
}

model ModifyPolicyGroupRequest {
  appContentProtection?: string(name='AppContentProtection', position='Query'),
  authorizeAccessPolicyRule?: [ 
    {
      cidrIp: string(name='CidrIp'),
      description?: string(name='Description'),
    }
  ](name='AuthorizeAccessPolicyRule', position='Query'),
  authorizeSecurityPolicyRule?: [ 
    {
      cidrIp?: string(name='CidrIp'),
      description?: string(name='Description'),
      ipProtocol?: string(name='IpProtocol'),
      policy?: string(name='Policy'),
      portRange?: string(name='PortRange'),
      priority?: string(name='Priority'),
      type?: string(name='Type'),
    }
  ](name='AuthorizeSecurityPolicyRule', position='Query'),
  cameraRedirect?: string(name='CameraRedirect', position='Query'),
  clientType?: [ 
    {
      clientType?: string(name='ClientType'),
      status?: string(name='Status'),
    }
  ](name='ClientType', position='Query'),
  clipboard?: string(name='Clipboard', position='Query'),
  domainList?: string(name='DomainList', position='Query'),
  gpuAcceleration?: string(name='GpuAcceleration', position='Query'),
  html5Access?: string(name='Html5Access', position='Query'),
  html5FileTransfer?: string(name='Html5FileTransfer', position='Query'),
  localDrive?: string(name='LocalDrive', position='Query'),
  name?: string(name='Name', position='Query'),
  netRedirect?: string(name='NetRedirect', position='Query'),
  policyGroupId: string(name='PolicyGroupId', position='Query'),
  preemptLogin?: string(name='PreemptLogin', position='Query'),
  preemptLoginUser?: [ string ](name='PreemptLoginUser', position='Query'),
  printerRedirection?: string(name='PrinterRedirection', position='Query'),
  recordContent?: string(name='RecordContent', position='Query'),
  recordContentExpires?: long(name='RecordContentExpires', position='Query'),
  recording?: string(name='Recording', position='Query'),
  recordingEndTime?: string(name='RecordingEndTime', position='Query'),
  recordingExpires?: long(name='RecordingExpires', position='Query'),
  recordingFps?: long(name='RecordingFps', position='Query'),
  recordingStartTime?: string(name='RecordingStartTime', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  revokeAccessPolicyRule?: [ 
    {
      cidrIp?: string(name='CidrIp'),
      description?: string(name='Description'),
    }
  ](name='RevokeAccessPolicyRule', position='Query'),
  revokeSecurityPolicyRule?: [ 
    {
      cidrIp?: string(name='CidrIp'),
      description?: string(name='Description'),
      ipProtocol?: string(name='IpProtocol'),
      policy?: string(name='Policy'),
      portRange?: string(name='PortRange'),
      priority?: string(name='Priority'),
      type?: string(name='Type'),
    }
  ](name='RevokeSecurityPolicyRule', position='Query'),
  usbRedirect?: string(name='UsbRedirect', position='Query'),
  usbSupplyRedirectRule?: [ 
    {
      description?: string(name='Description'),
      deviceClass?: string(name='DeviceClass'),
      deviceSubclass?: string(name='DeviceSubclass'),
      productId?: string(name='ProductId'),
      usbRedirectType?: long(name='UsbRedirectType'),
      usbRuleType?: long(name='UsbRuleType'),
      vendorId?: string(name='VendorId'),
    }
  ](name='UsbSupplyRedirectRule', position='Query'),
  visualQuality?: string(name='VisualQuality', position='Query'),
  watermark?: string(name='Watermark', position='Query'),
  watermarkTransparency?: string(name='WatermarkTransparency', position='Query'),
  watermarkType?: string(name='WatermarkType', position='Query'),
}

model ModifyPolicyGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyPolicyGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPolicyGroupResponseBody(name='body'),
}

async function modifyPolicyGroup(request: ModifyPolicyGroupRequest): ModifyPolicyGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyPolicyGroup', 'POST', '/', 'json', false, 'json', request);
}

model ModifyUserEntitlementRequest {
  authorizeDesktopId?: [ string ](name='AuthorizeDesktopId', position='Query'),
  endUserId?: [ string ](name='EndUserId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  revokeDesktopId?: [ string ](name='RevokeDesktopId', position='Query'),
}

model ModifyUserEntitlementResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUserEntitlementResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyUserEntitlementResponseBody(name='body'),
}

async function modifyUserEntitlement(request: ModifyUserEntitlementRequest): ModifyUserEntitlementResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyUserEntitlement', 'POST', '/', 'json', false, 'json', request);
}

model ModifyUserToDesktopGroupRequest {
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  newEndUserIds: [ string ](name='NewEndUserIds', position='Query'),
  oldEndUserIds: [ string ](name='OldEndUserIds', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyUserToDesktopGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUserToDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyUserToDesktopGroupResponseBody(name='body'),
}

async function modifyUserToDesktopGroup(request: ModifyUserToDesktopGroupRequest): ModifyUserToDesktopGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyUserToDesktopGroup', 'POST', '/', 'json', false, 'json', request);
}

model OperateVulsRequest {
  desktopId: [ string ](name='DesktopId', position='Query'),
  operateType: string(name='OperateType', position='Query'),
  precondition: int32(name='Precondition', position='Query'),
  reason?: string(name='Reason', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
  vulName: [ string ](name='VulName', position='Query'),
}

model OperateVulsResponseBody = {
  requestId?: string(name='RequestId'),
}

model OperateVulsResponse = {
  headers: map[string]string(name='headers'),
  body: OperateVulsResponseBody(name='body'),
}

async function operateVuls(request: OperateVulsRequest): OperateVulsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OperateVuls', 'POST', '/', 'json', false, 'json', request);
}

model RebootDesktopsRequest {
  desktopId: [ string ](name='DesktopId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RebootDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RebootDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: RebootDesktopsResponseBody(name='body'),
}

async function rebootDesktops(request: RebootDesktopsRequest): RebootDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RebootDesktops', 'POST', '/', 'json', false, 'json', request);
}

model RebuildDesktopsRequest {
  desktopId: [ string ](name='DesktopId', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RebuildDesktopsResponseBody = {
  rebuildResults?: [ 
    {
      code?: string(name='Code'),
      desktopId?: string(name='DesktopId'),
      message?: string(name='Message'),
    }
  ](name='RebuildResults'),
  requestId?: string(name='RequestId'),
}

model RebuildDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: RebuildDesktopsResponseBody(name='body'),
}

async function rebuildDesktops(request: RebuildDesktopsRequest): RebuildDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RebuildDesktops', 'POST', '/', 'json', false, 'json', request);
}

model RemoveUserFromDesktopGroupRequest {
  desktopGroupId?: string(name='DesktopGroupId', position='Query'),
  desktopGroupIds?: [ string ](name='DesktopGroupIds', position='Query'),
  endUserIds: [ string ](name='EndUserIds', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RemoveUserFromDesktopGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveUserFromDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveUserFromDesktopGroupResponseBody(name='body'),
}

async function removeUserFromDesktopGroup(request: RemoveUserFromDesktopGroupRequest): RemoveUserFromDesktopGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveUserFromDesktopGroup', 'POST', '/', 'json', false, 'json', request);
}

model RenewDesktopsRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  desktopId: [ string ](name='DesktopId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RenewDesktopsResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: RenewDesktopsResponseBody(name='body'),
}

async function renewDesktops(request: RenewDesktopsRequest): RenewDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RenewDesktops', 'POST', '/', 'json', false, 'json', request);
}

model RenewNetworkPackagesRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  networkPackageId: [ string ](name='NetworkPackageId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RenewNetworkPackagesResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewNetworkPackagesResponse = {
  headers: map[string]string(name='headers'),
  body: RenewNetworkPackagesResponseBody(name='body'),
}

async function renewNetworkPackages(request: RenewNetworkPackagesRequest): RenewNetworkPackagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RenewNetworkPackages', 'POST', '/', 'json', false, 'json', request);
}

model ResetDesktopsRequest {
  desktopGroupId?: string(name='DesktopGroupId', position='Query'),
  desktopId?: [ string ](name='DesktopId', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  payType?: string(name='PayType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resetType: string(name='ResetType', position='Query'),
}

model ResetDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: ResetDesktopsResponseBody(name='body'),
}

async function resetDesktops(request: ResetDesktopsRequest): ResetDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetDesktops', 'POST', '/', 'json', false, 'json', request);
}

model ResetNASDefaultMountTargetRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ResetNASDefaultMountTargetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetNASDefaultMountTargetResponse = {
  headers: map[string]string(name='headers'),
  body: ResetNASDefaultMountTargetResponseBody(name='body'),
}

async function resetNASDefaultMountTarget(request: ResetNASDefaultMountTargetRequest): ResetNASDefaultMountTargetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetNASDefaultMountTarget', 'POST', '/', 'json', false, 'json', request);
}

model ResetSnapshotRequest {
  regionId: string(name='RegionId', position='Query'),
  snapshotId: string(name='SnapshotId', position='Query'),
}

model ResetSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: ResetSnapshotResponseBody(name='body'),
}

async function resetSnapshot(request: ResetSnapshotRequest): ResetSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetSnapshot', 'POST', '/', 'json', false, 'json', request);
}

model RollbackSuspEventQuaraFileRequest {
  desktopId?: string(name='DesktopId', position='Query'),
  quaraFieldId: int32(name='QuaraFieldId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RollbackSuspEventQuaraFileResponseBody = {
  requestId?: string(name='RequestId'),
}

model RollbackSuspEventQuaraFileResponse = {
  headers: map[string]string(name='headers'),
  body: RollbackSuspEventQuaraFileResponseBody(name='body'),
}

async function rollbackSuspEventQuaraFile(request: RollbackSuspEventQuaraFileRequest): RollbackSuspEventQuaraFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RollbackSuspEventQuaraFile', 'POST', '/', 'json', false, 'json', request);
}

model RunCommandRequest {
  commandContent: string(name='CommandContent', position='Query'),
  contentEncoding?: string(name='ContentEncoding', position='Query'),
  desktopId: [ string ](name='DesktopId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  timeout?: long(name='Timeout', position='Query'),
  type: string(name='Type', position='Query'),
}

model RunCommandResponseBody = {
  invokeId?: string(name='InvokeId'),
  requestId?: string(name='RequestId'),
}

model RunCommandResponse = {
  headers: map[string]string(name='headers'),
  body: RunCommandResponseBody(name='body'),
}

async function runCommand(request: RunCommandRequest): RunCommandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunCommand', 'POST', '/', 'json', false, 'json', request);
}

model SendVerifyCodeRequest {
  extraInfo?: string(name='ExtraInfo', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  verifyCodeAction: string(name='VerifyCodeAction', position='Query'),
}

model SendVerifyCodeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SendVerifyCodeResponse = {
  headers: map[string]string(name='headers'),
  body: SendVerifyCodeResponseBody(name='body'),
}

async function sendVerifyCode(request: SendVerifyCodeRequest): SendVerifyCodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SendVerifyCode', 'POST', '/', 'json', false, 'json', request);
}

model SetDesktopGroupTimerRequest {
  cronExpression?: string(name='CronExpression', position='Query'),
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  force?: boolean(name='Force', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resetType?: int32(name='ResetType', position='Query'),
  timerType: int32(name='TimerType', position='Query'),
}

model SetDesktopGroupTimerResponseBody = {
  desktopGroupId?: string(name='DesktopGroupId'),
  orderIds?: [ string ](name='OrderIds'),
  requestId?: string(name='RequestId'),
}

model SetDesktopGroupTimerResponse = {
  headers: map[string]string(name='headers'),
  body: SetDesktopGroupTimerResponseBody(name='body'),
}

async function setDesktopGroupTimer(request: SetDesktopGroupTimerRequest): SetDesktopGroupTimerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDesktopGroupTimer', 'POST', '/', 'json', false, 'json', request);
}

model SetDesktopGroupTimerStatusRequest {
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  status?: int32(name='Status', position='Query'),
  timerType: int32(name='TimerType', position='Query'),
}

model SetDesktopGroupTimerStatusResponseBody = {
  desktopGroupId?: string(name='DesktopGroupId'),
  orderIds?: [ string ](name='OrderIds'),
  requestId?: string(name='RequestId'),
}

model SetDesktopGroupTimerStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetDesktopGroupTimerStatusResponseBody(name='body'),
}

async function setDesktopGroupTimerStatus(request: SetDesktopGroupTimerStatusRequest): SetDesktopGroupTimerStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDesktopGroupTimerStatus', 'POST', '/', 'json', false, 'json', request);
}

model SetIdpMetadataRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  idpMetadata: string(name='IdpMetadata', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model SetIdpMetadataResponseBody = {
  idpEntityId?: string(name='IdpEntityId'),
  requestId?: string(name='RequestId'),
}

model SetIdpMetadataResponse = {
  headers: map[string]string(name='headers'),
  body: SetIdpMetadataResponseBody(name='body'),
}

async function setIdpMetadata(request: SetIdpMetadataRequest): SetIdpMetadataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetIdpMetadata', 'POST', '/', 'json', false, 'json', request);
}

model SetOfficeSiteSsoStatusRequest {
  enableSso: boolean(name='EnableSso', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model SetOfficeSiteSsoStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetOfficeSiteSsoStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetOfficeSiteSsoStatusResponseBody(name='body'),
}

async function setOfficeSiteSsoStatus(request: SetOfficeSiteSsoStatusRequest): SetOfficeSiteSsoStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetOfficeSiteSsoStatus', 'POST', '/', 'json', false, 'json', request);
}

model StartDesktopsRequest {
  desktopId: [ string ](name='DesktopId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model StartDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: StartDesktopsResponseBody(name='body'),
}

async function startDesktops(request: StartDesktopsRequest): StartDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartDesktops', 'POST', '/', 'json', false, 'json', request);
}

model StartVirusScanTaskRequest {
  desktopId?: [ string ](name='DesktopId', position='Query'),
  officeSiteId?: [ string ](name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model StartVirusScanTaskResponseBody = {
  requestId?: string(name='RequestId'),
  scanTaskId?: long(name='ScanTaskId'),
}

model StartVirusScanTaskResponse = {
  headers: map[string]string(name='headers'),
  body: StartVirusScanTaskResponseBody(name='body'),
}

async function startVirusScanTask(request: StartVirusScanTaskRequest): StartVirusScanTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartVirusScanTask', 'POST', '/', 'json', false, 'json', request);
}

model StopDesktopsRequest {
  desktopId: [ string ](name='DesktopId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  stoppedMode?: string(name='StoppedMode', position='Query'),
}

model StopDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: StopDesktopsResponseBody(name='body'),
}

async function stopDesktops(request: StopDesktopsRequest): StopDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopDesktops', 'POST', '/', 'json', false, 'json', request);
}

model StopInvocationRequest {
  desktopId?: [ string ](name='DesktopId', position='Query'),
  invokeId: string(name='InvokeId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model StopInvocationResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopInvocationResponse = {
  headers: map[string]string(name='headers'),
  body: StopInvocationResponseBody(name='body'),
}

async function stopInvocation(request: StopInvocationRequest): StopInvocationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopInvocation', 'POST', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model UnlockVirtualMFADeviceRequest {
  regionId: string(name='RegionId', position='Query'),
  serialNumber: string(name='SerialNumber', position='Query'),
}

model UnlockVirtualMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnlockVirtualMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  body: UnlockVirtualMFADeviceResponseBody(name='body'),
}

async function unlockVirtualMFADevice(request: UnlockVirtualMFADeviceRequest): UnlockVirtualMFADeviceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnlockVirtualMFADevice', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tagKey?: [ string ](name='TagKey', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

model UpdateFotaTaskRequest {
  regionId: string(name='RegionId', position='Query'),
  taskUid: string(name='TaskUid', position='Query'),
  userStatus?: string(name='UserStatus', position='Query'),
}

model UpdateFotaTaskResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateFotaTaskResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFotaTaskResponseBody(name='body'),
}

async function updateFotaTask(request: UpdateFotaTaskRequest): UpdateFotaTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateFotaTask', 'POST', '/', 'json', false, 'json', request);
}

model UploadImageRequest {
  dataDiskSize?: int32(name='DataDiskSize', minimum=5, maximum=500, position='Query'),
  description?: string(name='Description', position='Query'),
  enableSecurityCheck?: boolean(name='EnableSecurityCheck', position='Query'),
  gpuCategory?: boolean(name='GpuCategory', position='Query'),
  gpuDriverType?: string(name='GpuDriverType', position='Query'),
  imageName: string(name='ImageName', position='Query'),
  licenseType?: string(name='LicenseType', position='Query'),
  osType?: string(name='OsType', position='Query'),
  ossObjectPath: string(name='OssObjectPath', position='Query'),
  protocolType?: string(name='ProtocolType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UploadImageResponseBody = {
  imageId?: string(name='ImageId'),
  requestId?: string(name='RequestId'),
}

model UploadImageResponse = {
  headers: map[string]string(name='headers'),
  body: UploadImageResponseBody(name='body'),
}

async function uploadImage(request: UploadImageRequest): UploadImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UploadImage', 'POST', '/', 'json', false, 'json', request);
}

model VerifyCenRequest {
  cenId: string(name='CenId', position='Query'),
  cenOwnerId?: long(name='CenOwnerId', position='Query'),
  cidrBlock: string(name='CidrBlock', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  verifyCode?: string(name='VerifyCode', position='Query'),
}

model VerifyCenResponseBody = {
  cidrBlocks?: [ string ](name='CidrBlocks'),
  requestId?: string(name='RequestId'),
  routeEntries?: [ 
    {
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      nextHopInstanceId?: string(name='NextHopInstanceId'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
    }
  ](name='RouteEntries'),
  status?: string(name='Status'),
}

model VerifyCenResponse = {
  headers: map[string]string(name='headers'),
  body: VerifyCenResponseBody(name='body'),
}

async function verifyCen(request: VerifyCenRequest): VerifyCenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'VerifyCen', 'POST', '/', 'json', false, 'json', request);
}

