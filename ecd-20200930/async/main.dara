/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'ecd';
  @version = '2020-09-30';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model ActivateOfficeSiteRequest {
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ActivateOfficeSiteResponseBody = {
  requestId?: string(name='RequestId'),
}

model ActivateOfficeSiteResponse = {
  headers: map[string]string(name='headers'),
  body: ActivateOfficeSiteResponseBody(name='body'),
}

async function activateOfficeSite(request: ActivateOfficeSiteRequest): ActivateOfficeSiteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ActivateOfficeSite', 'POST', '/', 'json', false, 'json', request);
}

model AddUserToDesktopGroupRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  endUserIds: [ string ](name='EndUserIds', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model AddUserToDesktopGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddUserToDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserToDesktopGroupResponseBody(name='body'),
}

async function addUserToDesktopGroup(request: AddUserToDesktopGroupRequest): AddUserToDesktopGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddUserToDesktopGroup', 'POST', '/', 'json', false, 'json', request);
}

model AddUserToSecurityCenterWhiteListRequest {
  regionId: string(name='RegionId', position='Query'),
}

model AddUserToSecurityCenterWhiteListResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddUserToSecurityCenterWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserToSecurityCenterWhiteListResponseBody(name='body'),
}

async function addUserToSecurityCenterWhiteList(request: AddUserToSecurityCenterWhiteListRequest): AddUserToSecurityCenterWhiteListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddUserToSecurityCenterWhiteList', 'POST', '/', 'json', false, 'json', request);
}

model AttachCenRequest {
  cenId: string(name='CenId', position='Query'),
  cenOwnerId?: long(name='CenOwnerId', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  verifyCode?: string(name='VerifyCode', position='Query'),
}

model AttachCenResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachCenResponse = {
  headers: map[string]string(name='headers'),
  body: AttachCenResponseBody(name='body'),
}

async function attachCen(request: AttachCenRequest): AttachCenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachCen', 'POST', '/', 'json', false, 'json', request);
}

model CheckUserInSecurityCenterWhiteListRequest {
  regionId: string(name='RegionId', position='Query'),
}

model CheckUserInSecurityCenterWhiteListResponseBody = {
  inWhiteList?: boolean(name='InWhiteList'),
  requestId?: string(name='RequestId'),
}

model CheckUserInSecurityCenterWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: CheckUserInSecurityCenterWhiteListResponseBody(name='body'),
}

async function checkUserInSecurityCenterWhiteList(request: CheckUserInSecurityCenterWhiteListRequest): CheckUserInSecurityCenterWhiteListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckUserInSecurityCenterWhiteList', 'POST', '/', 'json', false, 'json', request);
}

model CheckUserTagsRequest {
  regionId: string(name='RegionId', position='Query'),
  tags: [ string ](name='Tags', position='Query'),
}

model CheckUserTagsResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model CheckUserTagsResponse = {
  headers: map[string]string(name='headers'),
  body: CheckUserTagsResponseBody(name='body'),
}

async function checkUserTags(request: CheckUserTagsRequest): CheckUserTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckUserTags', 'POST', '/', 'json', false, 'json', request);
}

model ClonePolicyGroupRequest {
  name: string(name='Name', position='Query'),
  policyGroupId: string(name='PolicyGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ClonePolicyGroupResponseBody = {
  policyGroupId?: string(name='PolicyGroupId'),
  requestId?: string(name='RequestId'),
}

model ClonePolicyGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ClonePolicyGroupResponseBody(name='body'),
}

async function clonePolicyGroup(request: ClonePolicyGroupRequest): ClonePolicyGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ClonePolicyGroup', 'POST', '/', 'json', false, 'json', request);
}

model ConfigADConnectorTrustRequest {
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  trustKey: string(name='TrustKey', position='Query'),
}

model ConfigADConnectorTrustResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigADConnectorTrustResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigADConnectorTrustResponseBody(name='body'),
}

async function configADConnectorTrust(request: ConfigADConnectorTrustRequest): ConfigADConnectorTrustResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfigADConnectorTrust', 'POST', '/', 'json', false, 'json', request);
}

model ConfigADConnectorUserRequest {
  domainPassword: string(name='DomainPassword', position='Query'),
  domainUserName: string(name='DomainUserName', position='Query'),
  OUName: string(name='OUName', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ConfigADConnectorUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigADConnectorUserResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigADConnectorUserResponseBody(name='body'),
}

async function configADConnectorUser(request: ConfigADConnectorUserRequest): ConfigADConnectorUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfigADConnectorUser', 'POST', '/', 'json', false, 'json', request);
}

model CreateADConnectorDirectoryRequest {
  desktopAccessType?: string(name='DesktopAccessType', position='Query'),
  directoryName?: string(name='DirectoryName', position='Query'),
  dnsAddress: [ string ](name='DnsAddress', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  domainPassword: string(name='DomainPassword', position='Query'),
  domainUserName: string(name='DomainUserName', position='Query'),
  enableAdminAccess?: boolean(name='EnableAdminAccess', position='Query'),
  mfaEnabled?: boolean(name='MfaEnabled', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  subDomainDnsAddress?: [ string ](name='SubDomainDnsAddress', position='Query'),
  subDomainName?: string(name='SubDomainName', position='Query'),
  vSwitchId: [ string ](name='VSwitchId', position='Query'),
}

model CreateADConnectorDirectoryResponseBody = {
  adConnectors?: [ 
    {
      address?: string(name='Address'),
    }
  ](name='AdConnectors'),
  directoryId?: string(name='DirectoryId'),
  requestId?: string(name='RequestId'),
  trustPassword?: string(name='TrustPassword'),
}

model CreateADConnectorDirectoryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateADConnectorDirectoryResponseBody(name='body'),
}

async function createADConnectorDirectory(request: CreateADConnectorDirectoryRequest): CreateADConnectorDirectoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateADConnectorDirectory', 'POST', '/', 'json', false, 'json', request);
}

model CreateADConnectorOfficeSiteRequest {
  bandwidth?: int32(name='Bandwidth', position='Query'),
  cenId: string(name='CenId', position='Query'),
  cenOwnerId?: long(name='CenOwnerId', position='Query'),
  cidrBlock: string(name='CidrBlock', position='Query'),
  desktopAccessType?: string(name='DesktopAccessType', position='Query'),
  dnsAddress: [ string ](name='DnsAddress', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  domainPassword?: string(name='DomainPassword', position='Query'),
  domainUserName?: string(name='DomainUserName', position='Query'),
  enableAdminAccess?: boolean(name='EnableAdminAccess', position='Query'),
  enableInternetAccess?: boolean(name='EnableInternetAccess', position='Query'),
  mfaEnabled?: boolean(name='MfaEnabled', position='Query'),
  officeSiteName?: string(name='OfficeSiteName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  subDomainDnsAddress?: [ string ](name='SubDomainDnsAddress', position='Query'),
  subDomainName?: string(name='SubDomainName', position='Query'),
  verifyCode?: string(name='VerifyCode', position='Query'),
}

model CreateADConnectorOfficeSiteResponseBody = {
  officeSiteId?: string(name='OfficeSiteId'),
  requestId?: string(name='RequestId'),
}

model CreateADConnectorOfficeSiteResponse = {
  headers: map[string]string(name='headers'),
  body: CreateADConnectorOfficeSiteResponseBody(name='body'),
}

async function createADConnectorOfficeSite(request: CreateADConnectorOfficeSiteRequest): CreateADConnectorOfficeSiteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateADConnectorOfficeSite', 'POST', '/', 'json', false, 'json', request);
}

model CreateBandwidthResourcePackagesRequest {
  amount?: int32(name='Amount', minimum=1, maximum=20, position='Query'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  packageSize: int32(name='PackageSize', minimum=10, maximum=12000, position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CreateBandwidthResourcePackagesResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateBandwidthResourcePackagesResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBandwidthResourcePackagesResponseBody(name='body'),
}

async function createBandwidthResourcePackages(request: CreateBandwidthResourcePackagesRequest): CreateBandwidthResourcePackagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBandwidthResourcePackages', 'POST', '/', 'json', false, 'json', request);
}

model CreateBundleRequest {
  bundleName?: string(name='BundleName', position='Query'),
  description?: string(name='Description', position='Query'),
  desktopType: string(name='DesktopType', position='Query'),
  imageId: string(name='ImageId', position='Query'),
  language?: string(name='Language', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  rootDiskPerformanceLevel?: string(name='RootDiskPerformanceLevel', position='Query'),
  rootDiskSizeGib: int32(name='RootDiskSizeGib', position='Query'),
  userDiskPerformanceLevel?: string(name='UserDiskPerformanceLevel', position='Query'),
  userDiskSizeGib: [ int32 ](name='UserDiskSizeGib', position='Query'),
}

model CreateBundleResponseBody = {
  bundleId?: string(name='BundleId'),
  requestId?: string(name='RequestId'),
}

model CreateBundleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBundleResponseBody(name='body'),
}

async function createBundle(request: CreateBundleRequest): CreateBundleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBundle', 'POST', '/', 'json', false, 'json', request);
}

model CreateCloudDriveServiceRequest {
  maxSize: long(name='MaxSize', position='Query'),
  name: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CreateCloudDriveServiceResponseBody = {
  cdsId?: string(name='CdsId'),
  cdsName?: string(name='CdsName'),
  maxSize?: string(name='MaxSize'),
  requestId?: string(name='RequestId'),
}

model CreateCloudDriveServiceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCloudDriveServiceResponseBody(name='body'),
}

async function createCloudDriveService(request: CreateCloudDriveServiceRequest): CreateCloudDriveServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCloudDriveService', 'POST', '/', 'json', false, 'json', request);
}

model CreateDesktopGroupRequest {
  allowAutoSetup?: int32(name='AllowAutoSetup', minimum=0, maximum=1, position='Query'),
  allowBufferCount?: int32(name='AllowBufferCount', minimum=0, maximum=1000, position='Query'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  bundleId: string(name='BundleId', position='Query'),
  chargeType?: string(name='ChargeType', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  comments?: string(name='Comments', position='Query'),
  defaultInitDesktopCount?: int32(name='DefaultInitDesktopCount', minimum=1, maximum=1000, position='Query'),
  desktopGroupName?: string(name='DesktopGroupName', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  endUserIds: [ string ](name='EndUserIds', position='Query'),
  keepDuration?: long(name='KeepDuration', position='Query'),
  maxDesktopsCount?: int32(name='MaxDesktopsCount', minimum=1, maximum=1000, position='Query'),
  minDesktopsCount?: int32(name='MinDesktopsCount', minimum=0, maximum=500, position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  ownType?: int32(name='OwnType', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  policyGroupId?: string(name='PolicyGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resetType?: long(name='ResetType', position='Query'),
  scaleStrategyId?: string(name='ScaleStrategyId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model CreateDesktopGroupResponseBody = {
  desktopGroupId?: string(name='DesktopGroupId'),
  orderIds?: [ string ](name='OrderIds'),
  requestId?: string(name='RequestId'),
}

model CreateDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDesktopGroupResponseBody(name='body'),
}

async function createDesktopGroup(request: CreateDesktopGroupRequest): CreateDesktopGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDesktopGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateDesktopsRequest {
  amount?: int32(name='Amount', minimum=0, maximum=500, position='Query'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  autoRenew?: boolean(name='AutoRenew', position='Query'),
  bundleId: string(name='BundleId', position='Query'),
  chargeType?: string(name='ChargeType', position='Query'),
  desktopName?: string(name='DesktopName', position='Query'),
  desktopNameSuffix?: boolean(name='DesktopNameSuffix', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  endUserId?: [ string ](name='EndUserId', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  hostname?: string(name='Hostname', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  policyGroupId: string(name='PolicyGroupId', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  userAssignMode?: string(name='UserAssignMode', position='Query'),
  userName?: string(name='UserName', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model CreateDesktopsResponseBody = {
  desktopId?: [ string ](name='DesktopId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDesktopsResponseBody(name='body'),
}

async function createDesktops(request: CreateDesktopsRequest): CreateDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDesktops', 'POST', '/', 'json', false, 'json', request);
}

model CreateDesktopsLiteRequest {
  amount?: int32(name='Amount', minimum=0, maximum=20, position='Query'),
  bandwidth?: int32(name='Bandwidth', minimum=10, maximum=1000, position='Query'),
  bundleId?: string(name='BundleId', position='Query'),
  enableInternetAccess?: boolean(name='EnableInternetAccess', position='Query'),
  endUserId: [ string ](name='EndUserId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  userAssignMode?: string(name='UserAssignMode', position='Query'),
}

model CreateDesktopsLiteResponseBody = {
  desktopId?: [ string ](name='DesktopId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateDesktopsLiteResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDesktopsLiteResponseBody(name='body'),
}

async function createDesktopsLite(request: CreateDesktopsLiteRequest): CreateDesktopsLiteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDesktopsLite', 'POST', '/', 'json', false, 'json', request);
}

model CreateImageRequest {
  description?: string(name='Description', position='Query'),
  desktopId: string(name='DesktopId', position='Query'),
  imageName?: string(name='ImageName', position='Query'),
  imageResourceType?: string(name='ImageResourceType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  snapshotId?: string(name='SnapshotId', position='Query'),
  snapshotIds?: [ string ](name='SnapshotIds', position='Query'),
}

model CreateImageResponseBody = {
  imageId?: string(name='ImageId'),
  requestId?: string(name='RequestId'),
}

model CreateImageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateImageResponseBody(name='body'),
}

async function createImage(request: CreateImageRequest): CreateImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateImage', 'POST', '/', 'json', false, 'json', request);
}

model CreateNASFileSystemRequest {
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  storageType?: string(name='StorageType', position='Query'),
}

model CreateNASFileSystemResponseBody = {
  fileSystemId?: string(name='FileSystemId'),
  fileSystemName?: string(name='FileSystemName'),
  mountTargetDomain?: string(name='MountTargetDomain'),
  officeSiteId?: string(name='OfficeSiteId'),
  requestId?: string(name='RequestId'),
}

model CreateNASFileSystemResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNASFileSystemResponseBody(name='body'),
}

async function createNASFileSystem(request: CreateNASFileSystemRequest): CreateNASFileSystemResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNASFileSystem', 'POST', '/', 'json', false, 'json', request);
}

model CreateNetworkPackageRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  autoRenew?: boolean(name='AutoRenew', position='Query'),
  bandwidth: int32(name='Bandwidth', minimum=10, maximum=1000, position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CreateNetworkPackageResponseBody = {
  networkPackageId?: string(name='NetworkPackageId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateNetworkPackageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNetworkPackageResponseBody(name='body'),
}

async function createNetworkPackage(request: CreateNetworkPackageRequest): CreateNetworkPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNetworkPackage', 'POST', '/', 'json', false, 'json', request);
}

model CreateOrderForHardwareRequest {
  amount?: int32(name='Amount', minimum=0, maximum=500, position='Query'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  cityCode?: string(name='CityCode', position='Query'),
  cityName?: string(name='CityName', position='Query'),
  contactName?: string(name='ContactName', position='Query'),
  countryCode?: string(name='CountryCode', position='Query'),
  countryName?: string(name='CountryName', position='Query'),
  detailAddress?: string(name='DetailAddress', position='Query'),
  districtCode?: string(name='DistrictCode', position='Query'),
  districtName?: string(name='DistrictName', position='Query'),
  email?: string(name='Email', position='Query'),
  hardwareType: string(name='HardwareType', position='Query'),
  hardwareVersion: string(name='HardwareVersion', position='Query'),
  mobilePhone?: string(name='MobilePhone', position='Query'),
  phone?: string(name='Phone', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  provCode?: string(name='ProvCode', position='Query'),
  provName?: string(name='ProvName', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streetCode?: string(name='StreetCode', position='Query'),
  streetName?: string(name='StreetName', position='Query'),
  zipCode?: string(name='ZipCode', position='Query'),
}

model CreateOrderForHardwareResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateOrderForHardwareResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOrderForHardwareResponseBody(name='body'),
}

async function createOrderForHardware(request: CreateOrderForHardwareRequest): CreateOrderForHardwareResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOrderForHardware', 'POST', '/', 'json', false, 'json', request);
}

model CreatePolicyGroupRequest {
  authorizeAccessPolicyRule?: [ 
    {
      cidrIp?: string(name='CidrIp'),
      description?: string(name='Description'),
    }
  ](name='AuthorizeAccessPolicyRule', position='Query'),
  authorizeSecurityPolicyRule?: [ 
    {
      cidrIp?: string(name='CidrIp'),
      description?: string(name='Description'),
      ipProtocol?: string(name='IpProtocol'),
      policy?: string(name='Policy'),
      portRange?: string(name='PortRange'),
      priority?: string(name='Priority'),
      type?: string(name='Type'),
    }
  ](name='AuthorizeSecurityPolicyRule', position='Query'),
  clientType?: [ 
    {
      clientType?: string(name='ClientType'),
      status?: string(name='Status'),
    }
  ](name='ClientType', position='Query'),
  clipboard?: string(name='Clipboard', position='Query'),
  domainList?: string(name='DomainList', position='Query'),
  gpuAcceleration?: string(name='GpuAcceleration', position='Query'),
  html5Access?: string(name='Html5Access', position='Query'),
  html5FileTransfer?: string(name='Html5FileTransfer', position='Query'),
  localDrive?: string(name='LocalDrive', position='Query'),
  name?: string(name='Name', position='Query'),
  preemptLogin?: string(name='PreemptLogin', position='Query'),
  preemptLoginUser?: [ string ](name='PreemptLoginUser', position='Query'),
  printerRedirection?: string(name='PrinterRedirection', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  usbRedirect?: string(name='UsbRedirect', position='Query'),
  usbSupplyRedirectRule?: [ 
    {
      description?: string(name='Description'),
      deviceClass?: string(name='DeviceClass'),
      deviceSubclass?: string(name='DeviceSubclass'),
      productId?: string(name='ProductId'),
      usbRedirectType?: long(name='UsbRedirectType'),
      usbRuleType?: long(name='UsbRuleType'),
      vendorId?: string(name='VendorId'),
    }
  ](name='UsbSupplyRedirectRule', position='Query'),
  visualQuality?: string(name='VisualQuality', position='Query'),
  watermark?: string(name='Watermark', position='Query'),
  watermarkCustomText?: string(name='WatermarkCustomText', position='Query'),
  watermarkTransparency?: string(name='WatermarkTransparency', position='Query'),
  watermarkType?: string(name='WatermarkType', position='Query'),
}

model CreatePolicyGroupResponseBody = {
  policyGroupId?: string(name='PolicyGroupId'),
  requestId?: string(name='RequestId'),
}

model CreatePolicyGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePolicyGroupResponseBody(name='body'),
}

async function createPolicyGroup(request: CreatePolicyGroupRequest): CreatePolicyGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePolicyGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateRAMDirectoryRequest {
  desktopAccessType?: string(name='DesktopAccessType', position='Query'),
  directoryName?: string(name='DirectoryName', position='Query'),
  enableAdminAccess?: boolean(name='EnableAdminAccess', position='Query'),
  enableInternetAccess?: boolean(name='EnableInternetAccess', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  vSwitchId: [ string ](name='VSwitchId', position='Query'),
}

model CreateRAMDirectoryResponseBody = {
  directoryId?: string(name='DirectoryId'),
  requestId?: string(name='RequestId'),
}

model CreateRAMDirectoryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRAMDirectoryResponseBody(name='body'),
}

async function createRAMDirectory(request: CreateRAMDirectoryRequest): CreateRAMDirectoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRAMDirectory', 'POST', '/', 'json', false, 'json', request);
}

model CreateScaleStrategyRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  maxAvailableDesktopsCount?: int32(name='MaxAvailableDesktopsCount', minimum=0, maximum=100, position='Query'),
  maxDesktopsCount?: int32(name='MaxDesktopsCount', minimum=1, maximum=1000, position='Query'),
  minAvailableDesktopsCount?: int32(name='MinAvailableDesktopsCount', minimum=0, maximum=100, position='Query'),
  minDesktopsCount?: int32(name='MinDesktopsCount', minimum=0, maximum=500, position='Query'),
  payType?: string(name='PayType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  scaleStep?: int32(name='ScaleStep', minimum=1, maximum=100, position='Query'),
  scaleStrategyName?: string(name='ScaleStrategyName', position='Query'),
  scaleStrategyType?: string(name='ScaleStrategyType', position='Query'),
}

model CreateScaleStrategyResponseBody = {
  requestId?: string(name='RequestId'),
  scaleStrategyId?: string(name='ScaleStrategyId'),
}

model CreateScaleStrategyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateScaleStrategyResponseBody(name='body'),
}

async function createScaleStrategy(request: CreateScaleStrategyRequest): CreateScaleStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateScaleStrategy', 'POST', '/', 'json', false, 'json', request);
}

model CreateServiceLinkedRoleRequest {
  regionId: string(name='RegionId', position='Query'),
}

model CreateServiceLinkedRoleResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateServiceLinkedRoleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServiceLinkedRoleResponseBody(name='body'),
}

async function createServiceLinkedRole(request: CreateServiceLinkedRoleRequest): CreateServiceLinkedRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateServiceLinkedRole', 'POST', '/', 'json', false, 'json', request);
}

model CreateSimpleOfficeSiteRequest {
  bandwidth?: int32(name='Bandwidth', position='Query'),
  cenId?: string(name='CenId', position='Query'),
  cenOwnerId?: long(name='CenOwnerId', position='Query'),
  cidrBlock: string(name='CidrBlock', position='Query'),
  desktopAccessType?: string(name='DesktopAccessType', position='Query'),
  enableAdminAccess?: boolean(name='EnableAdminAccess', position='Query'),
  enableInternetAccess?: boolean(name='EnableInternetAccess', position='Query'),
  needVerifyZeroDevice?: boolean(name='NeedVerifyZeroDevice', position='Query'),
  officeSiteName?: string(name='OfficeSiteName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  verifyCode?: string(name='VerifyCode', position='Query'),
}

model CreateSimpleOfficeSiteResponseBody = {
  officeSiteId?: string(name='OfficeSiteId'),
  requestId?: string(name='RequestId'),
}

model CreateSimpleOfficeSiteResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSimpleOfficeSiteResponseBody(name='body'),
}

async function createSimpleOfficeSite(request: CreateSimpleOfficeSiteRequest): CreateSimpleOfficeSiteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSimpleOfficeSite', 'POST', '/', 'json', false, 'json', request);
}

model CreateSnapshotRequest {
  description?: string(name='Description', position='Query'),
  desktopId: string(name='DesktopId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  snapshotName: string(name='SnapshotName', position='Query'),
  sourceDiskType: string(name='SourceDiskType', position='Query'),
}

model CreateSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
  snapshotId?: string(name='SnapshotId'),
}

model CreateSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSnapshotResponseBody(name='body'),
}

async function createSnapshot(request: CreateSnapshotRequest): CreateSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSnapshot', 'POST', '/', 'json', false, 'json', request);
}

model DeleteBundlesRequest {
  bundleId: [ string ](name='BundleId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteBundlesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBundlesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBundlesResponseBody(name='body'),
}

async function deleteBundles(request: DeleteBundlesRequest): DeleteBundlesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBundles', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCloudDriveServicesRequest {
  cdsId: [ string ](name='CdsId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteCloudDriveServicesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCloudDriveServicesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCloudDriveServicesResponseBody(name='body'),
}

async function deleteCloudDriveServices(request: DeleteCloudDriveServicesRequest): DeleteCloudDriveServicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCloudDriveServices', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDesktopGroupRequest {
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteDesktopGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDesktopGroupResponseBody(name='body'),
}

async function deleteDesktopGroup(request: DeleteDesktopGroupRequest): DeleteDesktopGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDesktopGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDesktopsRequest {
  desktopId: [ string ](name='DesktopId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDesktopsResponseBody(name='body'),
}

async function deleteDesktops(request: DeleteDesktopsRequest): DeleteDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDesktops', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDirectoriesRequest {
  directoryId: [ string ](name='DirectoryId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteDirectoriesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDirectoriesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDirectoriesResponseBody(name='body'),
}

async function deleteDirectories(request: DeleteDirectoriesRequest): DeleteDirectoriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDirectories', 'POST', '/', 'json', false, 'json', request);
}

model DeleteImagesRequest {
  imageId: [ string ](name='ImageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteImagesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteImagesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImagesResponseBody(name='body'),
}

async function deleteImages(request: DeleteImagesRequest): DeleteImagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteImages', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNASFileSystemsRequest {
  fileSystemId: [ string ](name='FileSystemId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteNASFileSystemsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNASFileSystemsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNASFileSystemsResponseBody(name='body'),
}

async function deleteNASFileSystems(request: DeleteNASFileSystemsRequest): DeleteNASFileSystemsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNASFileSystems', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNetworkPackagesRequest {
  networkPackageId: [ string ](name='NetworkPackageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteNetworkPackagesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNetworkPackagesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNetworkPackagesResponseBody(name='body'),
}

async function deleteNetworkPackages(request: DeleteNetworkPackagesRequest): DeleteNetworkPackagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNetworkPackages', 'POST', '/', 'json', false, 'json', request);
}

model DeleteOfficeSitesRequest {
  officeSiteId: [ string ](name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteOfficeSitesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteOfficeSitesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteOfficeSitesResponseBody(name='body'),
}

async function deleteOfficeSites(request: DeleteOfficeSitesRequest): DeleteOfficeSitesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteOfficeSites', 'POST', '/', 'json', false, 'json', request);
}

model DeletePolicyGroupsRequest {
  policyGroupId: [ string ](name='PolicyGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeletePolicyGroupsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePolicyGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePolicyGroupsResponseBody(name='body'),
}

async function deletePolicyGroups(request: DeletePolicyGroupsRequest): DeletePolicyGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePolicyGroups', 'POST', '/', 'json', false, 'json', request);
}

model DeleteScaleStrategyRequest {
  regionId: string(name='RegionId', position='Query'),
  scaleStrategyId: string(name='ScaleStrategyId', position='Query'),
}

model DeleteScaleStrategyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteScaleStrategyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteScaleStrategyResponseBody(name='body'),
}

async function deleteScaleStrategy(request: DeleteScaleStrategyRequest): DeleteScaleStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteScaleStrategy', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSnapshotRequest {
  regionId: string(name='RegionId', position='Query'),
  snapshotId: [ string ](name='SnapshotId', position='Query'),
}

model DeleteSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSnapshotResponseBody(name='body'),
}

async function deleteSnapshot(request: DeleteSnapshotRequest): DeleteSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSnapshot', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVirtualMFADeviceRequest {
  regionId: string(name='RegionId', position='Query'),
  serialNumber: string(name='SerialNumber', position='Query'),
}

model DeleteVirtualMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVirtualMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVirtualMFADeviceResponseBody(name='body'),
}

async function deleteVirtualMFADevice(request: DeleteVirtualMFADeviceRequest): DeleteVirtualMFADeviceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVirtualMFADevice', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAlarmEventStackInfoRequest {
  desktopId: string(name='DesktopId', position='Query'),
  eventName: string(name='EventName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  uniqueInfo: string(name='UniqueInfo', position='Query'),
}

model DescribeAlarmEventStackInfoResponseBody = {
  requestId?: string(name='RequestId'),
  stackInfo?: string(name='StackInfo'),
}

model DescribeAlarmEventStackInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAlarmEventStackInfoResponseBody(name='body'),
}

async function describeAlarmEventStackInfo(request: DescribeAlarmEventStackInfoRequest): DescribeAlarmEventStackInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAlarmEventStackInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBundlesRequest {
  bundleId?: [ string ](name='BundleId', position='Query'),
  bundleType?: string(name='BundleType', position='Query'),
  checkStock?: boolean(name='CheckStock', position='Query'),
  cpuCount?: int32(name='CpuCount', position='Query'),
  desktopTypeFamily?: string(name='DesktopTypeFamily', position='Query'),
  fromDesktopGroup?: boolean(name='FromDesktopGroup', position='Query'),
  gpuCount?: float(name='GpuCount', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=0, maximum=500, position='Query'),
  memorySize?: int32(name='MemorySize', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  protocolType?: string(name='ProtocolType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeBundlesResponseBody = {
  bundles?: [ 
    {
      bundleId?: string(name='BundleId'),
      bundleName?: string(name='BundleName'),
      bundleType?: string(name='BundleType'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      desktopType?: string(name='DesktopType'),
      desktopTypeAttribute?: {
        cpuCount?: int32(name='CpuCount'),
        gpuCount?: float(name='GpuCount'),
        gpuSpec?: string(name='GpuSpec'),
        memorySize?: int32(name='MemorySize'),
      }(name='DesktopTypeAttribute'),
      desktopTypeFamily?: string(name='DesktopTypeFamily'),
      disks?: [ 
        {
          diskPerformanceLevel?: string(name='DiskPerformanceLevel'),
          diskSize?: int32(name='DiskSize'),
          diskType?: string(name='DiskType'),
        }
      ](name='Disks'),
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      language?: string(name='Language'),
      osType?: string(name='OsType'),
      protocolType?: string(name='ProtocolType'),
      stockState?: string(name='StockState'),
    }
  ](name='Bundles'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeBundlesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBundlesResponseBody(name='body'),
}

async function describeBundles(request: DescribeBundlesRequest): DescribeBundlesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBundles', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCensRequest {
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeCensResponseBody = {
  cens?: [ 
    {
      cenId?: string(name='CenId'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      ipv6Level?: string(name='Ipv6Level'),
      name?: string(name='Name'),
      packageIds?: [ 
        {
          packageId?: string(name='PackageId'),
        }
      ](name='PackageIds'),
      protectionLevel?: string(name='ProtectionLevel'),
      status?: string(name='Status'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
    }
  ](name='Cens'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeCensResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCensResponseBody(name='body'),
}

async function describeCens(request: DescribeCensRequest): DescribeCensResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCens', 'POST', '/', 'json', false, 'json', request);
}

model DescribeClientEventsRequest {
  desktopId?: string(name='DesktopId', position='Query'),
  desktopIp?: string(name='DesktopIp', position='Query'),
  desktopName?: string(name='DesktopName', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  endUserId?: string(name='EndUserId', position='Query'),
  eventType?: string(name='EventType', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  officeSiteName?: string(name='OfficeSiteName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeClientEventsResponseBody = {
  events?: [ 
    {
      aliUid?: string(name='AliUid'),
      bytesReceived?: string(name='BytesReceived'),
      bytesSend?: string(name='BytesSend'),
      clientIp?: string(name='ClientIp'),
      clientOS?: string(name='ClientOS'),
      clientVersion?: string(name='ClientVersion'),
      desktopId?: string(name='DesktopId'),
      desktopIp?: string(name='DesktopIp'),
      desktopName?: string(name='DesktopName'),
      directoryId?: string(name='DirectoryId'),
      directoryType?: string(name='DirectoryType'),
      endUserId?: string(name='EndUserId'),
      eventId?: string(name='EventId'),
      eventTime?: string(name='EventTime'),
      eventType?: string(name='EventType'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      officeSiteType?: string(name='OfficeSiteType'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
    }
  ](name='Events'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeClientEventsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClientEventsResponseBody(name='body'),
}

async function describeClientEvents(request: DescribeClientEventsRequest): DescribeClientEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeClientEvents', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudDriveServiceRequest {
  cdsIds?: [ string ](name='CdsIds', position='Query'),
  isTokenNeeded?: boolean(name='IsTokenNeeded', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=0, maximum=500, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeCloudDriveServiceResponseBody = {
  cloudDriveServices?: [ 
    {
      aliUid?: long(name='AliUid'),
      cdsChargeStatus?: string(name='CdsChargeStatus'),
      cdsChargeType?: string(name='CdsChargeType'),
      cdsId?: string(name='CdsId'),
      cdsName?: string(name='CdsName'),
      cdsReleaseDeadline?: string(name='CdsReleaseDeadline'),
      cdsStatus?: string(name='CdsStatus'),
      createTime?: string(name='CreateTime'),
      maxSize?: long(name='MaxSize'),
      meteredSize?: long(name='MeteredSize'),
      pdsAdministrator?: string(name='PdsAdministrator'),
      pdsDomainId?: string(name='PdsDomainId'),
      pdsEndpoint?: string(name='PdsEndpoint'),
      pdsInitToken?: string(name='PdsInitToken'),
      pdsProductName?: string(name='PdsProductName'),
      pdsSubdomainId?: string(name='PdsSubdomainId'),
      pdsUrl?: string(name='PdsUrl'),
      regionId?: string(name='RegionId'),
    }
  ](name='CloudDriveServices'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeCloudDriveServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCloudDriveServiceResponseBody(name='body'),
}

async function describeCloudDriveService(request: DescribeCloudDriveServiceRequest): DescribeCloudDriveServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudDriveService', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDesktopGroupsRequest {
  desktopGroupId?: string(name='DesktopGroupId', position='Query'),
  desktopGroupName?: string(name='DesktopGroupName', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  policyGroupId?: string(name='PolicyGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  status?: int32(name='Status', position='Query'),
}

model DescribeDesktopGroupsResponseBody = {
  desktopGroups?: [ 
    {
      comments?: string(name='Comments'),
      cpu?: int32(name='Cpu'),
      createTime?: string(name='CreateTime'),
      creator?: string(name='Creator'),
      dataDiskCategory?: string(name='DataDiskCategory'),
      dataDiskSize?: string(name='DataDiskSize'),
      desktopGroupId?: string(name='DesktopGroupId'),
      desktopGroupName?: string(name='DesktopGroupName'),
      directoryId?: string(name='DirectoryId'),
      directoryType?: string(name='DirectoryType'),
      endUserCount?: int32(name='EndUserCount'),
      expiredTime?: string(name='ExpiredTime'),
      gpuCount?: float(name='GpuCount'),
      gpuSpec?: string(name='GpuSpec'),
      keepDuration?: long(name='KeepDuration'),
      maxDesktopsCount?: int32(name='MaxDesktopsCount'),
      memory?: long(name='Memory'),
      minDesktopsCount?: int32(name='MinDesktopsCount'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      officeSiteType?: string(name='OfficeSiteType'),
      ownBundleId?: string(name='OwnBundleId'),
      ownBundleName?: string(name='OwnBundleName'),
      payType?: string(name='PayType'),
      policyGroupId?: string(name='PolicyGroupId'),
      policyGroupName?: string(name='PolicyGroupName'),
      resetType?: long(name='ResetType'),
      status?: int32(name='Status'),
      systemDiskCategory?: string(name='SystemDiskCategory'),
      systemDiskSize?: int32(name='SystemDiskSize'),
    }
  ](name='DesktopGroups'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeDesktopGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDesktopGroupsResponseBody(name='body'),
}

async function describeDesktopGroups(request: DescribeDesktopGroupsRequest): DescribeDesktopGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDesktopGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDesktopIdsByVulNamesRequest {
  necessity?: string(name='Necessity', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
  vulName: [ string ](name='VulName', position='Query'),
}

model DescribeDesktopIdsByVulNamesResponseBody = {
  desktopItems?: [ 
    {
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
    }
  ](name='DesktopItems'),
  requestId?: string(name='RequestId'),
}

model DescribeDesktopIdsByVulNamesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDesktopIdsByVulNamesResponseBody(name='body'),
}

async function describeDesktopIdsByVulNames(request: DescribeDesktopIdsByVulNamesRequest): DescribeDesktopIdsByVulNamesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDesktopIdsByVulNames', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDesktopPolicysRequest {
  desktopId?: [ string ](name='DesktopId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeDesktopPolicysResponseBody = {
  describeDesktopPolicys?: [ 
    {
      clipboard?: string(name='Clipboard'),
      desktopId?: string(name='DesktopId'),
      localDrive?: string(name='LocalDrive'),
      usbRedirect?: string(name='UsbRedirect'),
      watermark?: string(name='Watermark'),
    }
  ](name='DescribeDesktopPolicys'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeDesktopPolicysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDesktopPolicysResponseBody(name='body'),
}

async function describeDesktopPolicys(request: DescribeDesktopPolicysRequest): DescribeDesktopPolicysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDesktopPolicys', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDesktopTypesRequest {
  cpuCount?: int32(name='CpuCount', position='Query'),
  desktopIdForModify?: string(name='DesktopIdForModify', position='Query'),
  desktopTypeId?: string(name='DesktopTypeId', position='Query'),
  gpuCount?: float(name='GpuCount', position='Query'),
  instanceTypeFamily?: string(name='InstanceTypeFamily', position='Query'),
  memorySize?: int32(name='MemorySize', position='Query'),
  orderType?: string(name='OrderType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeDesktopTypesResponseBody = {
  desktopTypes?: [ 
    {
      allowDiskSize?: [ 
        {
          dataDiskSize?: int32(name='DataDiskSize'),
          defaultDataDiskSize?: int32(name='DefaultDataDiskSize'),
          systemDiskSize?: int32(name='SystemDiskSize'),
        }
      ](name='AllowDiskSize'),
      cpuCount?: string(name='CpuCount'),
      dataDiskSize?: string(name='DataDiskSize'),
      desktopTypeId?: string(name='DesktopTypeId'),
      desktopTypeStatus?: string(name='DesktopTypeStatus'),
      gpuCount?: float(name='GpuCount'),
      gpuSpec?: string(name='GpuSpec'),
      instanceTypeFamily?: string(name='InstanceTypeFamily'),
      memorySize?: string(name='MemorySize'),
      systemDiskSize?: string(name='SystemDiskSize'),
    }
  ](name='DesktopTypes'),
  requestId?: string(name='RequestId'),
}

model DescribeDesktopTypesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDesktopTypesResponseBody(name='body'),
}

async function describeDesktopTypes(request: DescribeDesktopTypesRequest): DescribeDesktopTypesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDesktopTypes', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDesktopsRequest {
  chargeType?: string(name='ChargeType', position='Query'),
  desktopId?: [ string ](name='DesktopId', position='Query'),
  desktopName?: string(name='DesktopName', position='Query'),
  desktopStatus?: string(name='DesktopStatus', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  endUserId?: [ string ](name='EndUserId', position='Query'),
  excludedEndUserId?: [ string ](name='ExcludedEndUserId', position='Query'),
  expiredTime?: string(name='ExpiredTime', position='Query'),
  filterDesktopGroup?: boolean(name='FilterDesktopGroup', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  officeSiteName?: string(name='OfficeSiteName', position='Query'),
  policyGroupId?: string(name='PolicyGroupId', position='Query'),
  protocolType?: string(name='ProtocolType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  userName?: string(name='UserName', position='Query'),
}

model DescribeDesktopsResponseBody = {
  desktops?: [ 
    {
      bundleId?: string(name='BundleId'),
      bundleName?: string(name='BundleName'),
      chargeType?: string(name='ChargeType'),
      connectionStatus?: string(name='ConnectionStatus'),
      cpu?: int32(name='Cpu'),
      creationTime?: string(name='CreationTime'),
      dataDiskCategory?: string(name='DataDiskCategory'),
      dataDiskSize?: string(name='DataDiskSize'),
      desktopGroupId?: string(name='DesktopGroupId'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      desktopStatus?: string(name='DesktopStatus'),
      desktopType?: string(name='DesktopType'),
      directoryId?: string(name='DirectoryId'),
      directoryType?: string(name='DirectoryType'),
      disks?: [ 
        {
          diskId?: string(name='DiskId'),
          diskSize?: int32(name='DiskSize'),
          diskType?: string(name='DiskType'),
        }
      ](name='Disks'),
      downgradeQuota?: long(name='DowngradeQuota'),
      downgradedTimes?: long(name='DowngradedTimes'),
      endUserIds?: [ string ](name='EndUserIds'),
      expiredTime?: string(name='ExpiredTime'),
      gpuCategory?: long(name='GpuCategory'),
      gpuCount?: float(name='GpuCount'),
      gpuDriverVersion?: string(name='GpuDriverVersion'),
      gpuSpec?: string(name='GpuSpec'),
      hostName?: string(name='HostName'),
      imageId?: string(name='ImageId'),
      managementFlag?: string(name='ManagementFlag'),
      memory?: long(name='Memory'),
      networkInterfaceId?: string(name='NetworkInterfaceId'),
      networkInterfaceIp?: string(name='NetworkInterfaceIp'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      officeSiteType?: string(name='OfficeSiteType'),
      osType?: string(name='OsType'),
      policyGroupId?: string(name='PolicyGroupId'),
      policyGroupName?: string(name='PolicyGroupName'),
      progress?: string(name='Progress'),
      protocolType?: string(name='ProtocolType'),
      sessions?: [ 
        {
          endUserId?: string(name='EndUserId'),
          establishmentTime?: string(name='EstablishmentTime'),
        }
      ](name='Sessions'),
      startTime?: string(name='StartTime'),
      systemDiskCategory?: string(name='SystemDiskCategory'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
    }
  ](name='Desktops'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDesktopsResponseBody(name='body'),
}

async function describeDesktops(request: DescribeDesktopsRequest): DescribeDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDesktops', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDesktopsInGroupRequest {
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  payType: string(name='PayType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeDesktopsInGroupResponseBody = {
  nextToken?: string(name='NextToken'),
  paidDesktops?: [ 
    {
      connectionStatus?: string(name='ConnectionStatus'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      desktopStatus?: string(name='DesktopStatus'),
      endUserId?: string(name='EndUserId'),
      endUserName?: string(name='EndUserName'),
      managementFlag?: string(name='ManagementFlag'),
    }
  ](name='PaidDesktops'),
  paidDesktopsCount?: int32(name='PaidDesktopsCount'),
  postPaidDesktops?: [ 
    {
      connectionStatus?: string(name='ConnectionStatus'),
      createDuration?: string(name='CreateDuration'),
      createTime?: string(name='CreateTime'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      desktopStatus?: string(name='DesktopStatus'),
      endUserId?: string(name='EndUserId'),
      endUserName?: string(name='EndUserName'),
      managementFlag?: string(name='ManagementFlag'),
      releaseTime?: string(name='ReleaseTime'),
    }
  ](name='PostPaidDesktops'),
  postPaidDesktopsCount?: int32(name='PostPaidDesktopsCount'),
  postPaidDesktopsTotalAmount?: int32(name='PostPaidDesktopsTotalAmount'),
  requestId?: string(name='RequestId'),
}

model DescribeDesktopsInGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDesktopsInGroupResponseBody(name='body'),
}

async function describeDesktopsInGroup(request: DescribeDesktopsInGroupRequest): DescribeDesktopsInGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDesktopsInGroup', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDirectoriesRequest {
  directoryId?: [ string ](name='DirectoryId', position='Query'),
  directoryStatus?: string(name='DirectoryStatus', position='Query'),
  directoryType?: string(name='DirectoryType', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=0, maximum=500, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  status?: string(name='Status', position='Query'),
}

model DescribeDirectoriesResponseBody = {
  directories?: [ 
    {
      ADConnectors?: [ 
        {
          ADConnectorAddress?: string(name='ADConnectorAddress'),
          connectorStatus?: string(name='ConnectorStatus'),
          networkInterfaceId?: string(name='NetworkInterfaceId'),
          trustKey?: string(name='TrustKey'),
          vSwitchId?: string(name='VSwitchId'),
        }
      ](name='ADConnectors'),
      creationTime?: string(name='CreationTime'),
      customSecurityGroupId?: string(name='CustomSecurityGroupId'),
      desktopAccessType?: string(name='DesktopAccessType'),
      desktopVpcEndpoint?: string(name='DesktopVpcEndpoint'),
      directoryId?: string(name='DirectoryId'),
      directoryType?: string(name='DirectoryType'),
      dnsAddress?: [ string ](name='DnsAddress'),
      dnsUserName?: string(name='DnsUserName'),
      domainName?: string(name='DomainName'),
      domainPassword?: string(name='DomainPassword'),
      domainUserName?: string(name='DomainUserName'),
      enableAdminAccess?: boolean(name='EnableAdminAccess'),
      enableCrossDesktopAccess?: boolean(name='EnableCrossDesktopAccess'),
      enableInternetAccess?: boolean(name='EnableInternetAccess'),
      fileSystemIds?: [ string ](name='FileSystemIds'),
      logs?: [ 
        {
          level?: string(name='Level'),
          message?: string(name='Message'),
          step?: string(name='Step'),
          timeStamp?: string(name='TimeStamp'),
        }
      ](name='Logs'),
      mfaEnabled?: boolean(name='MfaEnabled'),
      name?: string(name='Name'),
      needVerifyLoginRisk?: boolean(name='NeedVerifyLoginRisk'),
      ouName?: string(name='OuName'),
      ssoEnabled?: boolean(name='SsoEnabled'),
      status?: string(name='Status'),
      subDnsAddress?: [ string ](name='SubDnsAddress'),
      subDomainName?: string(name='SubDomainName'),
      trustPassword?: string(name='TrustPassword'),
      vSwitchIds?: [ string ](name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Directories'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeDirectoriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDirectoriesResponseBody(name='body'),
}

async function describeDirectories(request: DescribeDirectoriesRequest): DescribeDirectoriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDirectories', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFlowMetricRequest {
  endTime: string(name='EndTime', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceType: string(name='InstanceType', position='Query'),
  metricType: string(name='MetricType', position='Query'),
  period: int32(name='Period', minimum=60, maximum=900, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeFlowMetricResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeFlowMetricResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowMetricResponseBody(name='body'),
}

async function describeFlowMetric(request: DescribeFlowMetricRequest): DescribeFlowMetricResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFlowMetric', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFrontVulPatchListRequest {
  operateType?: string(name='OperateType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
  vulInfo?: [ 
    {
      desktopId?: string(name='DesktopId'),
      name?: string(name='Name'),
      tag?: string(name='Tag'),
    }
  ](name='VulInfo', position='Query'),
}

model DescribeFrontVulPatchListResponseBody = {
  frontPatchList?: [ 
    {
      desktopId?: string(name='DesktopId'),
      patchList?: [ 
        {
          aliasName?: string(name='AliasName'),
          name?: string(name='Name'),
        }
      ](name='PatchList'),
    }
  ](name='FrontPatchList'),
  requestId?: string(name='RequestId'),
}

model DescribeFrontVulPatchListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFrontVulPatchListResponseBody(name='body'),
}

async function describeFrontVulPatchList(request: DescribeFrontVulPatchListRequest): DescribeFrontVulPatchListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFrontVulPatchList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGroupedVulRequest {
  currentPage?: int32(name='CurrentPage', position='Query'),
  dealed?: string(name='Dealed', position='Query'),
  lang?: string(name='Lang', position='Query'),
  necessity?: string(name='Necessity', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
}

model DescribeGroupedVulResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  groupedVulItems?: [ 
    {
      aliasName?: string(name='AliasName'),
      asapCount?: int32(name='AsapCount'),
      gmtLast?: string(name='GmtLast'),
      handledCount?: int32(name='HandledCount'),
      laterCount?: int32(name='LaterCount'),
      name?: string(name='Name'),
      nntfCount?: int32(name='NntfCount'),
      tags?: string(name='Tags'),
      type?: string(name='Type'),
    }
  ](name='GroupedVulItems'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeGroupedVulResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGroupedVulResponseBody(name='body'),
}

async function describeGroupedVul(request: DescribeGroupedVulRequest): DescribeGroupedVulResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGroupedVul', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHardwareTerminalsRequest {
  hardwareType?: string(name='HardwareType', position='Query'),
  hardwareVersion?: string(name='HardwareVersion', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeHardwareTerminalsResponseBody = {
  hardwareTerminals?: [ 
    {
      hardwareType?: string(name='HardwareType'),
      hardwareTypeDetails?: [ 
        {
          description?: string(name='Description'),
          hardwareVersion?: int32(name='HardwareVersion'),
          stockState?: string(name='StockState'),
        }
      ](name='HardwareTypeDetails'),
    }
  ](name='HardwareTerminals'),
  requestId?: string(name='RequestId'),
}

model DescribeHardwareTerminalsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHardwareTerminalsResponseBody(name='body'),
}

async function describeHardwareTerminals(request: DescribeHardwareTerminalsRequest): DescribeHardwareTerminalsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHardwareTerminals', 'POST', '/', 'json', false, 'json', request);
}

model DescribeImagesRequest {
  desktopInstanceType?: string(name='DesktopInstanceType', position='Query'),
  gpuCategory?: boolean(name='GpuCategory', position='Query'),
  gpuDriverVersion?: string(name='GpuDriverVersion', position='Query'),
  imageId?: [ string ](name='ImageId', position='Query'),
  imageStatus?: string(name='ImageStatus', position='Query'),
  imageType?: string(name='ImageType', position='Query'),
  languageType?: string(name='LanguageType', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=0, maximum=500, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  osType?: string(name='OsType', position='Query'),
  protocolType?: string(name='ProtocolType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeImagesResponseBody = {
  images?: [ 
    {
      creationTime?: string(name='CreationTime'),
      dataDiskSize?: int32(name='DataDiskSize'),
      description?: string(name='Description'),
      gpuCategory?: boolean(name='GpuCategory'),
      gpuDriverVersion?: string(name='GpuDriverVersion'),
      imageId?: string(name='ImageId'),
      imageType?: string(name='ImageType'),
      name?: string(name='Name'),
      osType?: string(name='OsType'),
      progress?: string(name='Progress'),
      protocolType?: string(name='ProtocolType'),
      size?: int32(name='Size'),
      status?: string(name='Status'),
      supportedLanguages?: [ string ](name='SupportedLanguages'),
    }
  ](name='Images'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeImagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImagesResponseBody(name='body'),
}

async function describeImages(request: DescribeImagesRequest): DescribeImagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImages', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInvocationsRequest {
  commandType?: string(name='CommandType', position='Query'),
  contentEncoding?: string(name='ContentEncoding', position='Query'),
  desktopId?: string(name='DesktopId', position='Query'),
  includeOutput?: boolean(name='IncludeOutput', position='Query'),
  invokeId?: string(name='InvokeId', position='Query'),
  invokeStatus?: string(name='InvokeStatus', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=0, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeInvocationsResponseBody = {
  invocations?: [ 
    {
      commandContent?: string(name='CommandContent'),
      commandType?: string(name='CommandType'),
      creationTime?: string(name='CreationTime'),
      invocationStatus?: string(name='InvocationStatus'),
      invokeDesktops?: [ 
        {
          creationTime?: string(name='CreationTime'),
          desktopId?: string(name='DesktopId'),
          dropped?: int32(name='Dropped'),
          errorCode?: string(name='ErrorCode'),
          errorInfo?: string(name='ErrorInfo'),
          exitCode?: long(name='ExitCode'),
          finishTime?: string(name='FinishTime'),
          invocationStatus?: string(name='InvocationStatus'),
          output?: string(name='Output'),
          repeats?: int32(name='Repeats'),
          startTime?: string(name='StartTime'),
          stopTime?: string(name='StopTime'),
          updateTime?: string(name='UpdateTime'),
        }
      ](name='InvokeDesktops'),
      invokeId?: string(name='InvokeId'),
    }
  ](name='Invocations'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeInvocationsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInvocationsResponseBody(name='body'),
}

async function describeInvocations(request: DescribeInvocationsRequest): DescribeInvocationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInvocations', 'POST', '/', 'json', false, 'json', request);
}

model DescribeModificationPriceRequest {
  bandwidth?: int32(name='Bandwidth', minimum=10, maximum=1000, position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  rootDiskPerformanceLevel?: string(name='RootDiskPerformanceLevel', position='Query'),
  rootDiskSizeGib?: int32(name='RootDiskSizeGib', minimum=0, maximum=32768, position='Query'),
  userDiskPerformanceLevel?: string(name='UserDiskPerformanceLevel', position='Query'),
  userDiskSizeGib?: int32(name='UserDiskSizeGib', minimum=0, maximum=32768, position='Query'),
}

model DescribeModificationPriceResponseBody = {
  priceInfo?: {
    price?: {
      currency?: string(name='Currency'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      promotions?: [ 
        {
          optionCode?: string(name='OptionCode'),
          promotionDesc?: string(name='PromotionDesc'),
          promotionId?: string(name='PromotionId'),
          promotionName?: string(name='PromotionName'),
          selected?: boolean(name='Selected'),
        }
      ](name='Promotions'),
      tradePrice?: float(name='TradePrice'),
    }(name='Price'),
    rules?: [ 
      {
        description?: string(name='Description'),
        ruleId?: long(name='RuleId'),
      }
    ](name='Rules'),
  }(name='PriceInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeModificationPriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeModificationPriceResponseBody(name='body'),
}

async function describeModificationPrice(request: DescribeModificationPriceRequest): DescribeModificationPriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeModificationPrice', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNASFileSystemsRequest {
  fileSystemId?: [ string ](name='FileSystemId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=0, maximum=500, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeNASFileSystemsResponseBody = {
  fileSystems?: [ 
    {
      capacity?: long(name='Capacity'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      fileSystemId?: string(name='FileSystemId'),
      fileSystemName?: string(name='FileSystemName'),
      fileSystemStatus?: string(name='FileSystemStatus'),
      fileSystemType?: string(name='FileSystemType'),
      meteredSize?: long(name='MeteredSize'),
      mountTargetDomain?: string(name='MountTargetDomain'),
      mountTargetStatus?: string(name='MountTargetStatus'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      regionId?: string(name='RegionId'),
      storageType?: string(name='StorageType'),
      supportAcl?: boolean(name='SupportAcl'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='FileSystems'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeNASFileSystemsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNASFileSystemsResponseBody(name='body'),
}

async function describeNASFileSystems(request: DescribeNASFileSystemsRequest): DescribeNASFileSystemsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNASFileSystems', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNetworkPackagesRequest {
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  networkPackageId?: [ string ](name='NetworkPackageId', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeNetworkPackagesResponseBody = {
  networkPackages?: [ 
    {
      bandwidth?: int32(name='Bandwidth'),
      createTime?: string(name='CreateTime'),
      eipAddresses?: [ string ](name='EipAddresses'),
      expiredTime?: string(name='ExpiredTime'),
      internetChargeType?: string(name='InternetChargeType'),
      networkPackageId?: string(name='NetworkPackageId'),
      networkPackageStatus?: string(name='NetworkPackageStatus'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
    }
  ](name='NetworkPackages'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeNetworkPackagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkPackagesResponseBody(name='body'),
}

async function describeNetworkPackages(request: DescribeNetworkPackagesRequest): DescribeNetworkPackagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNetworkPackages', 'POST', '/', 'json', false, 'json', request);
}

model DescribeOfficeSitesRequest {
  maxResults?: int32(name='MaxResults', minimum=0, maximum=500, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: [ string ](name='OfficeSiteId', position='Query'),
  officeSiteType?: string(name='OfficeSiteType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  status?: string(name='Status', position='Query'),
}

model DescribeOfficeSitesResponseBody = {
  nextToken?: string(name='NextToken'),
  officeSites?: [ 
    {
      ADConnectors?: [ 
        {
          ADConnectorAddress?: string(name='ADConnectorAddress'),
          connectorStatus?: string(name='ConnectorStatus'),
          networkInterfaceId?: string(name='NetworkInterfaceId'),
          trustKey?: string(name='TrustKey'),
          vSwitchId?: string(name='VSwitchId'),
        }
      ](name='ADConnectors'),
      bandwidth?: int32(name='Bandwidth'),
      cenId?: string(name='CenId'),
      cidrBlock?: string(name='CidrBlock'),
      cloudBoxOfficeSite?: boolean(name='CloudBoxOfficeSite'),
      creationTime?: string(name='CreationTime'),
      customSecurityGroupId?: string(name='CustomSecurityGroupId'),
      desktopAccessType?: string(name='DesktopAccessType'),
      desktopCount?: long(name='DesktopCount'),
      desktopVpcEndpoint?: string(name='DesktopVpcEndpoint'),
      dnsAddress?: [ string ](name='DnsAddress'),
      dnsUserName?: string(name='DnsUserName'),
      domainName?: string(name='DomainName'),
      domainPassword?: string(name='DomainPassword'),
      domainUserName?: string(name='DomainUserName'),
      enableAdminAccess?: boolean(name='EnableAdminAccess'),
      enableCrossDesktopAccess?: boolean(name='EnableCrossDesktopAccess'),
      enableInternetAccess?: boolean(name='EnableInternetAccess'),
      fileSystemIds?: [ string ](name='FileSystemIds'),
      logs?: [ 
        {
          level?: string(name='Level'),
          message?: string(name='Message'),
          step?: string(name='Step'),
          timeStamp?: string(name='TimeStamp'),
        }
      ](name='Logs'),
      mfaEnabled?: boolean(name='MfaEnabled'),
      name?: string(name='Name'),
      needVerifyLoginRisk?: boolean(name='NeedVerifyLoginRisk'),
      needVerifyZeroDevice?: boolean(name='NeedVerifyZeroDevice'),
      networkPackageId?: string(name='NetworkPackageId'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteType?: string(name='OfficeSiteType'),
      ouName?: string(name='OuName'),
      ssoEnabled?: boolean(name='SsoEnabled'),
      ssoType?: string(name='SsoType'),
      status?: string(name='Status'),
      subDnsAddress?: [ string ](name='SubDnsAddress'),
      subDomainName?: string(name='SubDomainName'),
      trustPassword?: string(name='TrustPassword'),
      vSwitchIds?: [ string ](name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
    }
  ](name='OfficeSites'),
  requestId?: string(name='RequestId'),
}

model DescribeOfficeSitesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeOfficeSitesResponseBody(name='body'),
}

async function describeOfficeSites(request: DescribeOfficeSitesRequest): DescribeOfficeSitesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeOfficeSites', 'POST', '/', 'json', false, 'json', request);
}

model DescribePolicyGroupsRequest {
  maxResults?: int32(name='MaxResults', minimum=1, maximum=200, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  policyGroupId?: [ string ](name='PolicyGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribePolicyGroupsResponseBody = {
  describePolicyGroups?: [ 
    {
      authorizeAccessPolicyRules?: [ 
        {
          cidrIp?: string(name='CidrIp'),
          description?: string(name='Description'),
        }
      ](name='AuthorizeAccessPolicyRules'),
      authorizeSecurityPolicyRules?: [ 
        {
          cidrIp?: string(name='CidrIp'),
          description?: string(name='Description'),
          ipProtocol?: string(name='IpProtocol'),
          policy?: string(name='Policy'),
          portRange?: string(name='PortRange'),
          priority?: string(name='Priority'),
          type?: string(name='Type'),
        }
      ](name='AuthorizeSecurityPolicyRules'),
      clientTypes?: [ 
        {
          clientType?: string(name='ClientType'),
          status?: string(name='Status'),
        }
      ](name='ClientTypes'),
      clipboard?: string(name='Clipboard'),
      domainList?: string(name='DomainList'),
      edsCount?: int32(name='EdsCount'),
      gpuAcceleration?: string(name='GpuAcceleration'),
      html5Access?: string(name='Html5Access'),
      html5FileTransfer?: string(name='Html5FileTransfer'),
      localDrive?: string(name='LocalDrive'),
      name?: string(name='Name'),
      policyGroupId?: string(name='PolicyGroupId'),
      policyGroupType?: string(name='PolicyGroupType'),
      policyStatus?: string(name='PolicyStatus'),
      preemptLogin?: string(name='PreemptLogin'),
      preemptLoginUsers?: [ string ](name='PreemptLoginUsers'),
      printerRedirection?: string(name='PrinterRedirection'),
      usbRedirect?: string(name='UsbRedirect'),
      usbSupplyRedirectRule?: [ 
        {
          description?: string(name='Description'),
          deviceClass?: string(name='DeviceClass'),
          deviceSubclass?: string(name='DeviceSubclass'),
          productId?: string(name='ProductId'),
          usbRedirectType?: long(name='UsbRedirectType'),
          usbRuleType?: long(name='UsbRuleType'),
          vendorId?: string(name='VendorId'),
        }
      ](name='UsbSupplyRedirectRule'),
      visualQuality?: string(name='VisualQuality'),
      watermark?: string(name='Watermark'),
      watermarkCustomText?: string(name='WatermarkCustomText'),
      watermarkTransparency?: string(name='WatermarkTransparency'),
      watermarkType?: string(name='WatermarkType'),
    }
  ](name='DescribePolicyGroups'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribePolicyGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePolicyGroupsResponseBody(name='body'),
}

async function describePolicyGroups(request: DescribePolicyGroupsRequest): DescribePolicyGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePolicyGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribePostPaidDesktopBillsRequest {
  billEndTime: string(name='BillEndTime', position='Query'),
  billStartTime: string(name='BillStartTime', position='Query'),
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribePostPaidDesktopBillsResponseBody = {
  bills?: [ 
    {
      billEndTime?: string(name='BillEndTime'),
      billId?: string(name='BillId'),
      billStartTime?: string(name='BillStartTime'),
      billType?: string(name='BillType'),
      cashPayment?: string(name='CashPayment'),
      chargeItem?: string(name='ChargeItem'),
      consumeTime?: string(name='ConsumeTime'),
      consumeType?: string(name='ConsumeType'),
      discountPrice?: string(name='DiscountPrice'),
      goldNote?: string(name='GoldNote'),
      instanceId?: string(name='InstanceId'),
      originalPrice?: string(name='OriginalPrice'),
      payment?: string(name='Payment'),
      price?: string(name='Price'),
      priceUnit?: string(name='PriceUnit'),
      product?: string(name='Product'),
      productDetail?: string(name='ProductDetail'),
      resourceGroupId?: string(name='ResourceGroupId'),
      resourceGroupName?: string(name='ResourceGroupName'),
      usage?: string(name='Usage'),
      usageUnit?: string(name='UsageUnit'),
    }
  ](name='Bills'),
  nextToken?: string(name='NextToken'),
  postPaidDesktopsBillsUrl?: string(name='PostPaidDesktopsBillsUrl'),
  postPaidDesktopsCount?: int32(name='PostPaidDesktopsCount'),
  postPaidDesktopsTotalAmount?: float(name='PostPaidDesktopsTotalAmount'),
  requestId?: string(name='RequestId'),
}

model DescribePostPaidDesktopBillsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePostPaidDesktopBillsResponseBody(name='body'),
}

async function describePostPaidDesktopBills(request: DescribePostPaidDesktopBillsRequest): DescribePostPaidDesktopBillsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePostPaidDesktopBills', 'POST', '/', 'json', false, 'json', request);
}

model DescribePriceRequest {
  amount?: int32(name='Amount', minimum=1, maximum=500, position='Query'),
  bandwidth?: int32(name='Bandwidth', minimum=1, maximum=2048, position='Query'),
  hardwareVersion?: string(name='HardwareVersion', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  osType?: string(name='OsType', position='Query'),
  packageSize?: int32(name='PackageSize', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  rootDiskPerformanceLevel?: string(name='RootDiskPerformanceLevel', position='Query'),
  rootDiskSizeGib?: int32(name='RootDiskSizeGib', minimum=0, maximum=32768, position='Query'),
  userDiskPerformanceLevel?: string(name='UserDiskPerformanceLevel', position='Query'),
  userDiskSizeGib?: int32(name='UserDiskSizeGib', minimum=0, maximum=32768, position='Query'),
}

model DescribePriceResponseBody = {
  priceInfo?: {
    freeCdsQuota?: boolean(name='FreeCdsQuota'),
    freeCdsSize?: long(name='FreeCdsSize'),
    price?: {
      currency?: string(name='Currency'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      promotions?: [ 
        {
          optionCode?: string(name='OptionCode'),
          promotionDesc?: string(name='PromotionDesc'),
          promotionId?: string(name='PromotionId'),
          promotionName?: string(name='PromotionName'),
          selected?: boolean(name='Selected'),
        }
      ](name='Promotions'),
      tradePrice?: float(name='TradePrice'),
    }(name='Price'),
    rules?: [ 
      {
        description?: string(name='Description'),
        ruleId?: long(name='RuleId'),
      }
    ](name='Rules'),
  }(name='PriceInfo'),
  requestId?: string(name='RequestId'),
}

model DescribePriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePriceResponseBody(name='body'),
}

async function describePrice(request: DescribePriceRequest): DescribePriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePrice', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  regionId: string(name='RegionId', position='Query'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRenewalPriceRequest {
  instanceId?: string(name='InstanceId', position='Query'),
  instanceIds?: [ string ](name='InstanceIds', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
}

model DescribeRenewalPriceResponseBody = {
  priceInfo?: {
    price?: {
      currency?: string(name='Currency'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      promotions?: [ 
        {
          optionCode?: string(name='OptionCode'),
          promotionDesc?: string(name='PromotionDesc'),
          promotionId?: string(name='PromotionId'),
          promotionName?: string(name='PromotionName'),
          selected?: boolean(name='Selected'),
        }
      ](name='Promotions'),
      tradePrice?: float(name='TradePrice'),
    }(name='Price'),
    rules?: [ 
      {
        description?: string(name='Description'),
        ruleId?: long(name='RuleId'),
      }
    ](name='Rules'),
  }(name='PriceInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeRenewalPriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRenewalPriceResponseBody(name='body'),
}

async function describeRenewalPrice(request: DescribeRenewalPriceRequest): DescribeRenewalPriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRenewalPrice', 'POST', '/', 'json', false, 'json', request);
}

model DescribeResourcePackageQuotaRequest {
  regionId: string(name='RegionId', position='Query'),
}

model DescribeResourcePackageQuotaResponseBody = {
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  usedCount?: int32(name='UsedCount'),
}

model DescribeResourcePackageQuotaResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeResourcePackageQuotaResponseBody(name='body'),
}

async function describeResourcePackageQuota(request: DescribeResourcePackageQuotaRequest): DescribeResourcePackageQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeResourcePackageQuota', 'POST', '/', 'json', false, 'json', request);
}

model DescribeScaleStrategysRequest {
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  scaleStrategyName?: string(name='ScaleStrategyName', position='Query'),
}

model DescribeScaleStrategysResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  scaleStrategys?: [ 
    {
      maxAvailableDesktopsCount?: int32(name='MaxAvailableDesktopsCount'),
      maxDesktopsCount?: int32(name='MaxDesktopsCount'),
      minAvailableDesktopsCount?: int32(name='MinAvailableDesktopsCount'),
      minDesktopsCount?: int32(name='MinDesktopsCount'),
      scaleStep?: int32(name='ScaleStep'),
      scaleStrategyId?: string(name='ScaleStrategyId'),
      scaleStrategyName?: string(name='ScaleStrategyName'),
      scaleStrategyType?: string(name='ScaleStrategyType'),
    }
  ](name='ScaleStrategys'),
}

model DescribeScaleStrategysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeScaleStrategysResponseBody(name='body'),
}

async function describeScaleStrategys(request: DescribeScaleStrategysRequest): DescribeScaleStrategysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeScaleStrategys', 'POST', '/', 'json', false, 'json', request);
}

model DescribeScanTaskProgressRequest {
  regionId: string(name='RegionId', position='Query'),
  taskId?: long(name='TaskId', position='Query'),
}

model DescribeScanTaskProgressResponseBody = {
  createTime?: string(name='CreateTime'),
  requestId?: string(name='RequestId'),
  taskStatus?: string(name='TaskStatus'),
}

model DescribeScanTaskProgressResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeScanTaskProgressResponseBody(name='body'),
}

async function describeScanTaskProgress(request: DescribeScanTaskProgressRequest): DescribeScanTaskProgressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeScanTaskProgress', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSecurityEventOperationStatusRequest {
  regionId: string(name='RegionId', position='Query'),
  securityEventId: [ string ](name='SecurityEventId', position='Query'),
  taskId: long(name='TaskId', position='Query'),
}

model DescribeSecurityEventOperationStatusResponseBody = {
  requestId?: string(name='RequestId'),
  securityEventOperationStatuses?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      securityEventId?: long(name='SecurityEventId'),
      status?: string(name='Status'),
    }
  ](name='SecurityEventOperationStatuses'),
  taskStatus?: string(name='TaskStatus'),
}

model DescribeSecurityEventOperationStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityEventOperationStatusResponseBody(name='body'),
}

async function describeSecurityEventOperationStatus(request: DescribeSecurityEventOperationStatusRequest): DescribeSecurityEventOperationStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecurityEventOperationStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSecurityEventOperationsRequest {
  regionId: string(name='RegionId', position='Query'),
  securityEventId: long(name='SecurityEventId', position='Query'),
}

model DescribeSecurityEventOperationsResponseBody = {
  requestId?: string(name='RequestId'),
  securityEventOperations?: [ 
    {
      operationCode?: string(name='OperationCode'),
      operationParams?: string(name='OperationParams'),
      userCanOperate?: boolean(name='UserCanOperate'),
    }
  ](name='SecurityEventOperations'),
}

model DescribeSecurityEventOperationsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityEventOperationsResponseBody(name='body'),
}

async function describeSecurityEventOperations(request: DescribeSecurityEventOperationsRequest): DescribeSecurityEventOperationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecurityEventOperations', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSnapshotsRequest {
  desktopId?: string(name='DesktopId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  snapshotId?: string(name='SnapshotId', position='Query'),
}

model DescribeSnapshotsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  snapshots?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      desktopId?: string(name='DesktopId'),
      progress?: string(name='Progress'),
      remainTime?: int32(name='RemainTime'),
      snapshotId?: string(name='SnapshotId'),
      snapshotName?: string(name='SnapshotName'),
      snapshotType?: string(name='SnapshotType'),
      sourceDiskSize?: string(name='SourceDiskSize'),
      sourceDiskType?: string(name='SourceDiskType'),
      status?: string(name='Status'),
    }
  ](name='Snapshots'),
}

model DescribeSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotsResponseBody(name='body'),
}

async function describeSnapshots(request: DescribeSnapshotsRequest): DescribeSnapshotsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSnapshots', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSuspEventOverviewRequest {
  regionId: string(name='RegionId', position='Query'),
}

model DescribeSuspEventOverviewResponseBody = {
  remindCount?: int32(name='RemindCount'),
  requestId?: string(name='RequestId'),
  seriousCount?: int32(name='SeriousCount'),
  suspiciousCount?: int32(name='SuspiciousCount'),
}

model DescribeSuspEventOverviewResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSuspEventOverviewResponseBody(name='body'),
}

async function describeSuspEventOverview(request: DescribeSuspEventOverviewRequest): DescribeSuspEventOverviewResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSuspEventOverview', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSuspEventQuaraFilesRequest {
  currentPage?: int32(name='CurrentPage', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  status?: string(name='Status', position='Query'),
}

model DescribeSuspEventQuaraFilesResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  quaraFiles?: [ 
    {
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      eventName?: string(name='EventName'),
      eventType?: string(name='EventType'),
      id?: int32(name='Id'),
      md5?: string(name='Md5'),
      modifyTime?: string(name='ModifyTime'),
      path?: string(name='Path'),
      status?: string(name='Status'),
      tag?: string(name='Tag'),
    }
  ](name='QuaraFiles'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSuspEventQuaraFilesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSuspEventQuaraFilesResponseBody(name='body'),
}

async function describeSuspEventQuaraFiles(request: DescribeSuspEventQuaraFilesRequest): DescribeSuspEventQuaraFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSuspEventQuaraFiles', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSuspEventsRequest {
  alarmUniqueInfo?: string(name='AlarmUniqueInfo', position='Query'),
  currentPage?: int32(name='CurrentPage', position='Query'),
  dealed?: string(name='Dealed', position='Query'),
  lang?: string(name='Lang', position='Query'),
  levels?: string(name='Levels', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  parentEventType?: string(name='ParentEventType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeSuspEventsResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId'),
  suspEvents?: [ 
    {
      alarmEventName?: string(name='AlarmEventName'),
      alarmEventNameDisplay?: string(name='AlarmEventNameDisplay'),
      alarmEventType?: string(name='AlarmEventType'),
      alarmEventTypeDisplay?: string(name='AlarmEventTypeDisplay'),
      alarmUniqueInfo?: string(name='AlarmUniqueInfo'),
      canBeDealOnLine?: string(name='CanBeDealOnLine'),
      canCancelFault?: boolean(name='CanCancelFault'),
      dataSource?: string(name='DataSource'),
      desc?: string(name='Desc'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      details?: [ 
        {
          name?: string(name='Name'),
          nameDisplay?: string(name='NameDisplay'),
          type?: string(name='Type'),
          value?: string(name='Value'),
          valueDisplay?: string(name='ValueDisplay'),
        }
      ](name='Details'),
      eventStatus?: int32(name='EventStatus'),
      eventSubType?: string(name='EventSubType'),
      id?: long(name='Id'),
      lastTime?: string(name='LastTime'),
      level?: string(name='Level'),
      name?: string(name='Name'),
      occurrenceTime?: string(name='OccurrenceTime'),
      operateErrorCode?: string(name='OperateErrorCode'),
      operateMsg?: string(name='OperateMsg'),
      uniqueInfo?: string(name='UniqueInfo'),
    }
  ](name='SuspEvents'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSuspEventsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSuspEventsResponseBody(name='body'),
}

async function describeSuspEvents(request: DescribeSuspEventsRequest): DescribeSuspEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSuspEvents', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUserConnectionRecordsRequest {
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  endUserId: string(name='EndUserId', position='Query'),
  endUserType?: string(name='EndUserType', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeUserConnectionRecordsResponseBody = {
  connectionRecords?: [ 
    {
      connectDuration?: string(name='ConnectDuration'),
      connectEndTime?: string(name='ConnectEndTime'),
      connectStartTime?: string(name='ConnectStartTime'),
      connectionRecordId?: string(name='ConnectionRecordId'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
    }
  ](name='ConnectionRecords'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeUserConnectionRecordsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUserConnectionRecordsResponseBody(name='body'),
}

async function describeUserConnectionRecords(request: DescribeUserConnectionRecordsRequest): DescribeUserConnectionRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUserConnectionRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUsersInGroupRequest {
  connectState?: int32(name='ConnectState', position='Query'),
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  endUserId?: string(name='EndUserId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeUsersInGroupResponseBody = {
  endUsers?: [ 
    {
      connectionStatus?: string(name='ConnectionStatus'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      endUserEmail?: string(name='EndUserEmail'),
      endUserId?: string(name='EndUserId'),
      endUserName?: string(name='EndUserName'),
      endUserPhone?: string(name='EndUserPhone'),
      endUserType?: string(name='EndUserType'),
    }
  ](name='EndUsers'),
  nextToken?: string(name='NextToken'),
  onlineUsersCount?: int32(name='OnlineUsersCount'),
  requestId?: string(name='RequestId'),
  usersCount?: int32(name='UsersCount'),
}

model DescribeUsersInGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUsersInGroupResponseBody(name='body'),
}

async function describeUsersInGroup(request: DescribeUsersInGroupRequest): DescribeUsersInGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUsersInGroup', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVirtualMFADevicesRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  endUserId?: [ string ](name='EndUserId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=0, maximum=500, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeVirtualMFADevicesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  virtualMFADevices?: [ 
    {
      consecutiveFails?: int32(name='ConsecutiveFails'),
      directoryId?: string(name='DirectoryId'),
      endUserId?: string(name='EndUserId'),
      gmtEnabled?: string(name='GmtEnabled'),
      gmtUnlock?: string(name='GmtUnlock'),
      officeSiteId?: string(name='OfficeSiteId'),
      serialNumber?: string(name='SerialNumber'),
      status?: string(name='status'),
    }
  ](name='VirtualMFADevices'),
}

model DescribeVirtualMFADevicesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVirtualMFADevicesResponseBody(name='body'),
}

async function describeVirtualMFADevices(request: DescribeVirtualMFADevicesRequest): DescribeVirtualMFADevicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVirtualMFADevices', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVulDetailsRequest {
  aliasName?: string(name='AliasName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  name: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
}

model DescribeVulDetailsResponseBody = {
  cves?: [ 
    {
      cveId?: string(name='CveId'),
      cvssScore?: string(name='CvssScore'),
      summary?: string(name='Summary'),
      title?: string(name='Title'),
    }
  ](name='Cves'),
  requestId?: string(name='RequestId'),
}

model DescribeVulDetailsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVulDetailsResponseBody(name='body'),
}

async function describeVulDetails(request: DescribeVulDetailsRequest): DescribeVulDetailsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVulDetails', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVulListRequest {
  aliasName?: string(name='AliasName', position='Query'),
  currentPage?: int32(name='CurrentPage', position='Query'),
  dealed?: string(name='Dealed', position='Query'),
  lang?: string(name='Lang', position='Query'),
  necessity?: string(name='Necessity', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
}

model DescribeVulListResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vulRecords?: [ 
    {
      aliasName?: string(name='AliasName'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      extendContentJson?: {
        rpmEntityList?: [ 
          {
            fullVersion?: string(name='FullVersion'),
            matchDetail?: string(name='MatchDetail'),
            name?: string(name='Name'),
            path?: string(name='Path'),
            updateCmd?: string(name='UpdateCmd'),
          }
        ](name='RpmEntityList'),
      }(name='ExtendContentJson'),
      firstTs?: long(name='FirstTs'),
      lastTs?: long(name='LastTs'),
      modifyTs?: long(name='ModifyTs'),
      name?: string(name='Name'),
      necessity?: string(name='Necessity'),
      online?: boolean(name='Online'),
      osVersion?: string(name='OsVersion'),
      related?: string(name='Related'),
      repairTs?: long(name='RepairTs'),
      resultCode?: string(name='ResultCode'),
      resultMessage?: string(name='ResultMessage'),
      status?: int32(name='Status'),
      tag?: string(name='Tag'),
      type?: string(name='Type'),
    }
  ](name='VulRecords'),
}

model DescribeVulListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVulListResponseBody(name='body'),
}

async function describeVulList(request: DescribeVulListRequest): DescribeVulListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVulList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVulOverviewRequest {
  regionId: string(name='RegionId', position='Query'),
}

model DescribeVulOverviewResponseBody = {
  asapCount?: int32(name='AsapCount'),
  laterCount?: int32(name='LaterCount'),
  nntfCount?: int32(name='NntfCount'),
  requestId?: string(name='RequestId'),
}

model DescribeVulOverviewResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVulOverviewResponseBody(name='body'),
}

async function describeVulOverview(request: DescribeVulOverviewRequest): DescribeVulOverviewResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVulOverview', 'POST', '/', 'json', false, 'json', request);
}

model DescribeZonesRequest {
  regionId: string(name='RegionId', position='Query'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: [ 
    {
      zoneId?: string(name='ZoneId'),
    }
  ](name='Zones'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeZonesResponseBody(name='body'),
}

async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeZones', 'POST', '/', 'json', false, 'json', request);
}

model DetachCenRequest {
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DetachCenResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachCenResponse = {
  headers: map[string]string(name='headers'),
  body: DetachCenResponseBody(name='body'),
}

async function detachCen(request: DetachCenRequest): DetachCenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachCen', 'POST', '/', 'json', false, 'json', request);
}

model DoCheckResourceRequest {
  bid?: string(name='Bid', position='Query'),
  country?: string(name='Country', position='Query'),
  gmtWakeup?: string(name='GmtWakeup', position='Query'),
  hid?: long(name='Hid', position='Query'),
  invoker?: string(name='Invoker', position='Query'),
  pk?: string(name='Pk', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  taskExtraData?: string(name='TaskExtraData', position='Query'),
  taskIdentifier?: string(name='TaskIdentifier', position='Query'),
}

model DoCheckResourceResponseBody = {
  bid?: string(name='Bid'),
  country?: string(name='Country'),
  gmtWakeup?: string(name='GmtWakeup'),
  hid?: long(name='Hid'),
  interrupt?: boolean(name='Interrupt'),
  invoker?: string(name='Invoker'),
  level?: long(name='Level'),
  message?: string(name='Message'),
  pk?: string(name='Pk'),
  prompt?: string(name='Prompt'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskExtraData?: string(name='TaskExtraData'),
  taskIdentifier?: string(name='TaskIdentifier'),
  url?: string(name='Url'),
}

model DoCheckResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DoCheckResourceResponseBody(name='body'),
}

async function doCheckResource(request: DoCheckResourceRequest): DoCheckResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DoCheckResource', 'POST', '/', 'json', false, 'json', request);
}

model DoLogicalDeleteResourceRequest {
  bid?: string(name='Bid', position='Query'),
  country?: string(name='Country', position='Query'),
  gmtWakeup?: string(name='GmtWakeup', position='Query'),
  hid?: long(name='Hid', position='Query'),
  invoker?: string(name='Invoker', position='Query'),
  pk?: string(name='Pk', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  taskExtraData?: string(name='TaskExtraData', position='Query'),
  taskIdentifier?: string(name='TaskIdentifier', position='Query'),
}

model DoLogicalDeleteResourceResponseBody = {
  bid?: string(name='Bid'),
  country?: string(name='Country'),
  gmtWakeup?: string(name='GmtWakeup'),
  hid?: long(name='Hid'),
  interrupt?: boolean(name='Interrupt'),
  invoker?: string(name='Invoker'),
  message?: string(name='Message'),
  pk?: string(name='Pk'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskExtraData?: string(name='TaskExtraData'),
  taskIdentifier?: string(name='TaskIdentifier'),
}

model DoLogicalDeleteResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DoLogicalDeleteResourceResponseBody(name='body'),
}

async function doLogicalDeleteResource(request: DoLogicalDeleteResourceRequest): DoLogicalDeleteResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DoLogicalDeleteResource', 'POST', '/', 'json', false, 'json', request);
}

model DoPhysicalDeleteResourceRequest {
  bid?: string(name='Bid', position='Query'),
  country?: string(name='Country', position='Query'),
  gmtWakeup?: string(name='GmtWakeup', position='Query'),
  hid?: long(name='Hid', position='Query'),
  invoker?: string(name='Invoker', position='Query'),
  pk?: string(name='Pk', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  taskExtraData?: string(name='TaskExtraData', position='Query'),
  taskIdentifier?: string(name='TaskIdentifier', position='Query'),
}

model DoPhysicalDeleteResourceResponseBody = {
  bid?: string(name='Bid'),
  country?: string(name='Country'),
  gmtWakeup?: string(name='GmtWakeup'),
  hid?: long(name='Hid'),
  interrupt?: boolean(name='Interrupt'),
  invoker?: string(name='Invoker'),
  message?: string(name='Message'),
  pk?: string(name='Pk'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskExtraData?: string(name='TaskExtraData'),
  taskIdentifier?: string(name='TaskIdentifier'),
}

model DoPhysicalDeleteResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DoPhysicalDeleteResourceResponseBody(name='body'),
}

async function doPhysicalDeleteResource(request: DoPhysicalDeleteResourceRequest): DoPhysicalDeleteResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DoPhysicalDeleteResource', 'POST', '/', 'json', false, 'json', request);
}

model ExportClientEventsRequest {
  desktopId?: string(name='DesktopId', position='Query'),
  desktopName?: string(name='DesktopName', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  endUserId?: string(name='EndUserId', position='Query'),
  eventType?: string(name='EventType', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  officeSiteName?: string(name='OfficeSiteName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model ExportClientEventsResponseBody = {
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model ExportClientEventsResponse = {
  headers: map[string]string(name='headers'),
  body: ExportClientEventsResponseBody(name='body'),
}

async function exportClientEvents(request: ExportClientEventsRequest): ExportClientEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportClientEvents', 'POST', '/', 'json', false, 'json', request);
}

model ExportDesktopGroupInfoRequest {
  chargeType?: string(name='ChargeType', position='Query'),
  desktopGroupId?: [ string ](name='DesktopGroupId', position='Query'),
  desktopGroupName?: string(name='DesktopGroupName', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  endUserId?: [ string ](name='EndUserId', position='Query'),
  expiredTime?: string(name='ExpiredTime', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  policyGroupId?: string(name='PolicyGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ExportDesktopGroupInfoResponseBody = {
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model ExportDesktopGroupInfoResponse = {
  headers: map[string]string(name='headers'),
  body: ExportDesktopGroupInfoResponseBody(name='body'),
}

async function exportDesktopGroupInfo(request: ExportDesktopGroupInfoRequest): ExportDesktopGroupInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportDesktopGroupInfo', 'POST', '/', 'json', false, 'json', request);
}

model ExportDesktopListInfoRequest {
  chargeType?: string(name='ChargeType', position='Query'),
  desktopId?: [ string ](name='DesktopId', position='Query'),
  desktopName?: string(name='DesktopName', position='Query'),
  desktopStatus?: string(name='DesktopStatus', position='Query'),
  directoryId?: string(name='DirectoryId', position='Query'),
  endUserId?: [ string ](name='EndUserId', position='Query'),
  expiredTime?: string(name='ExpiredTime', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  policyGroupId?: string(name='PolicyGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  userName?: string(name='UserName', position='Query'),
}

model ExportDesktopListInfoResponseBody = {
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model ExportDesktopListInfoResponse = {
  headers: map[string]string(name='headers'),
  body: ExportDesktopListInfoResponseBody(name='body'),
}

async function exportDesktopListInfo(request: ExportDesktopListInfoRequest): ExportDesktopListInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportDesktopListInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetConnectionTicketRequest {
  desktopId?: string(name='DesktopId', position='Query'),
  endUserId?: string(name='EndUserId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  password?: string(name='Password', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  taskId?: string(name='TaskId', position='Query'),
}

model GetConnectionTicketResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  taskStatus?: string(name='TaskStatus'),
  ticket?: string(name='Ticket'),
}

model GetConnectionTicketResponse = {
  headers: map[string]string(name='headers'),
  body: GetConnectionTicketResponseBody(name='body'),
}

async function getConnectionTicket(request: GetConnectionTicketRequest): GetConnectionTicketResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetConnectionTicket', 'POST', '/', 'json', false, 'json', request);
}

model GetDesktopGroupDetailRequest {
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetDesktopGroupDetailResponseBody = {
  desktops?: [ 
    {
      allowAutoSetup?: int32(name='AllowAutoSetup'),
      allowBufferCount?: int32(name='AllowBufferCount'),
      comments?: string(name='Comments'),
      cpu?: int32(name='Cpu'),
      creationTime?: string(name='CreationTime'),
      creator?: string(name='Creator'),
      dataDiskCategory?: string(name='DataDiskCategory'),
      dataDiskSize?: string(name='DataDiskSize'),
      desktopGroupId?: string(name='DesktopGroupId'),
      desktopGroupName?: string(name='DesktopGroupName'),
      directoryId?: string(name='DirectoryId'),
      directoryType?: string(name='DirectoryType'),
      expiredTime?: string(name='ExpiredTime'),
      gpuCount?: float(name='GpuCount'),
      gpuSpec?: string(name='GpuSpec'),
      keepDuration?: long(name='KeepDuration'),
      maxDesktopsCount?: int32(name='MaxDesktopsCount'),
      memory?: long(name='Memory'),
      minDesktopsCount?: int32(name='MinDesktopsCount'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      officeSiteType?: string(name='OfficeSiteType'),
      ownBundleId?: string(name='OwnBundleId'),
      ownBundleName?: string(name='OwnBundleName'),
      payType?: string(name='PayType'),
      policyGroupId?: string(name='PolicyGroupId'),
      policyGroupName?: string(name='PolicyGroupName'),
      resType?: int32(name='ResType'),
      resetType?: long(name='ResetType'),
      status?: int32(name='Status'),
      systemDiskCategory?: string(name='SystemDiskCategory'),
      systemDiskSize?: int32(name='SystemDiskSize'),
    }
  ](name='Desktops'),
  requestId?: string(name='RequestId'),
}

model GetDesktopGroupDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetDesktopGroupDetailResponseBody(name='body'),
}

async function getDesktopGroupDetail(request: GetDesktopGroupDetailRequest): GetDesktopGroupDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDesktopGroupDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetDirectorySsoStatusRequest {
  directoryId: string(name='DirectoryId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetDirectorySsoStatusResponseBody = {
  requestId?: string(name='RequestId'),
  ssoStatus?: boolean(name='SsoStatus'),
}

model GetDirectorySsoStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetDirectorySsoStatusResponseBody(name='body'),
}

async function getDirectorySsoStatus(request: GetDirectorySsoStatusRequest): GetDirectorySsoStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDirectorySsoStatus', 'POST', '/', 'json', false, 'json', request);
}

model GetOfficeSiteSsoStatusRequest {
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetOfficeSiteSsoStatusResponseBody = {
  requestId?: string(name='RequestId'),
  ssoStatus?: boolean(name='SsoStatus'),
}

model GetOfficeSiteSsoStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetOfficeSiteSsoStatusResponseBody(name='body'),
}

async function getOfficeSiteSsoStatus(request: GetOfficeSiteSsoStatusRequest): GetOfficeSiteSsoStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetOfficeSiteSsoStatus', 'POST', '/', 'json', false, 'json', request);
}

model GetSpMetadataRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetSpMetadataResponseBody = {
  requestId?: string(name='RequestId'),
  spMetadata?: string(name='SpMetadata'),
}

model GetSpMetadataResponse = {
  headers: map[string]string(name='headers'),
  body: GetSpMetadataResponseBody(name='body'),
}

async function getSpMetadata(request: GetSpMetadataRequest): GetSpMetadataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSpMetadata', 'POST', '/', 'json', false, 'json', request);
}

model HandleSecurityEventsRequest {
  operationCode: string(name='OperationCode', position='Query'),
  operationParams?: string(name='OperationParams', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  securityEvent?: [ 
    {
      desktopId?: string(name='DesktopId'),
      securityEventId?: string(name='SecurityEventId'),
    }
  ](name='SecurityEvent', position='Query'),
}

model HandleSecurityEventsResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: long(name='TaskId'),
}

model HandleSecurityEventsResponse = {
  headers: map[string]string(name='headers'),
  body: HandleSecurityEventsResponseBody(name='body'),
}

async function handleSecurityEvents(request: HandleSecurityEventsRequest): HandleSecurityEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'HandleSecurityEvents', 'POST', '/', 'json', false, 'json', request);
}

model ListDirectoryUsersRequest {
  directoryId: string(name='DirectoryId', position='Query'),
  filter?: string(name='Filter', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  OUPath?: string(name='OUPath', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListDirectoryUsersResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  users?: [ 
    {
      endUser?: string(name='EndUser'),
    }
  ](name='Users'),
}

model ListDirectoryUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListDirectoryUsersResponseBody(name='body'),
}

async function listDirectoryUsers(request: ListDirectoryUsersRequest): ListDirectoryUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDirectoryUsers', 'POST', '/', 'json', false, 'json', request);
}

model ListOfficeSiteOverviewRequest {
  forceRefresh?: boolean(name='ForceRefresh', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  officeSiteId?: [ string ](name='OfficeSiteId', position='Query'),
  queryRange?: int32(name='QueryRange', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListOfficeSiteOverviewResponseBody = {
  nextToken?: string(name='NextToken'),
  officeSiteOverviewResults?: [ 
    {
      hasExpiredEdsCount?: int32(name='HasExpiredEdsCount'),
      hasExpiredEdsCountForGroup?: int32(name='HasExpiredEdsCountForGroup'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteName?: string(name='OfficeSiteName'),
      officeSiteStatus?: string(name='OfficeSiteStatus'),
      regionId?: string(name='RegionId'),
      runningEdsCount?: int32(name='RunningEdsCount'),
      runningEdsCountForGroup?: int32(name='RunningEdsCountForGroup'),
      totalEdsCount?: int32(name='TotalEdsCount'),
      totalEdsCountForGroup?: int32(name='TotalEdsCountForGroup'),
      willExpiredEdsCount?: int32(name='WillExpiredEdsCount'),
      willExpiredEdsCountForGroup?: int32(name='WillExpiredEdsCountForGroup'),
    }
  ](name='OfficeSiteOverviewResults'),
  requestId?: string(name='RequestId'),
}

model ListOfficeSiteOverviewResponse = {
  headers: map[string]string(name='headers'),
  body: ListOfficeSiteOverviewResponseBody(name='body'),
}

async function listOfficeSiteOverview(request: ListOfficeSiteOverviewRequest): ListOfficeSiteOverviewResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListOfficeSiteOverview', 'POST', '/', 'json', false, 'json', request);
}

model ListOfficeSiteUsersRequest {
  filter?: string(name='Filter', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  OUPath?: string(name='OUPath', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListOfficeSiteUsersResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  users?: [ 
    {
      endUser?: string(name='EndUser'),
    }
  ](name='Users'),
}

model ListOfficeSiteUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListOfficeSiteUsersResponseBody(name='body'),
}

async function listOfficeSiteUsers(request: ListOfficeSiteUsersRequest): ListOfficeSiteUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListOfficeSiteUsers', 'POST', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ListUserAdOrganizationUnitsRequest {
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListUserAdOrganizationUnitsResponseBody = {
  OUNames?: [ 
    {
      OUName?: string(name='OUName'),
      officeSiteId?: string(name='OfficeSiteId'),
    }
  ](name='OUNames'),
  requestId?: string(name='RequestId'),
}

model ListUserAdOrganizationUnitsResponse = {
  headers: map[string]string(name='headers'),
  body: ListUserAdOrganizationUnitsResponseBody(name='body'),
}

async function listUserAdOrganizationUnits(request: ListUserAdOrganizationUnitsRequest): ListUserAdOrganizationUnitsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserAdOrganizationUnits', 'POST', '/', 'json', false, 'json', request);
}

model LockVirtualMFADeviceRequest {
  regionId: string(name='RegionId', position='Query'),
  serialNumber: string(name='SerialNumber', position='Query'),
}

model LockVirtualMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model LockVirtualMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  body: LockVirtualMFADeviceResponseBody(name='body'),
}

async function lockVirtualMFADevice(request: LockVirtualMFADeviceRequest): LockVirtualMFADeviceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'LockVirtualMFADevice', 'POST', '/', 'json', false, 'json', request);
}

model ModifyADConnectorDirectoryRequest {
  directoryId: string(name='DirectoryId', position='Query'),
  directoryName?: string(name='DirectoryName', position='Query'),
  dnsAddress?: [ string ](name='DnsAddress', position='Query'),
  domainName?: string(name='DomainName', position='Query'),
  domainPassword?: string(name='DomainPassword', position='Query'),
  domainUserName?: string(name='DomainUserName', position='Query'),
  mfaEnabled?: boolean(name='MfaEnabled', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  subDomainDnsAddress?: [ string ](name='SubDomainDnsAddress', position='Query'),
  subDomainName?: string(name='SubDomainName', position='Query'),
}

model ModifyADConnectorDirectoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyADConnectorDirectoryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyADConnectorDirectoryResponseBody(name='body'),
}

async function modifyADConnectorDirectory(request: ModifyADConnectorDirectoryRequest): ModifyADConnectorDirectoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyADConnectorDirectory', 'POST', '/', 'json', false, 'json', request);
}

model ModifyADConnectorOfficeSiteRequest {
  dnsAddress?: [ string ](name='DnsAddress', position='Query'),
  domainName?: string(name='DomainName', position='Query'),
  domainPassword?: string(name='DomainPassword', position='Query'),
  domainUserName?: string(name='DomainUserName', position='Query'),
  mfaEnabled?: boolean(name='MfaEnabled', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  officeSiteName?: string(name='OfficeSiteName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  subDomainDnsAddress?: [ string ](name='SubDomainDnsAddress', position='Query'),
  subDomainName?: string(name='SubDomainName', position='Query'),
}

model ModifyADConnectorOfficeSiteResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyADConnectorOfficeSiteResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyADConnectorOfficeSiteResponseBody(name='body'),
}

async function modifyADConnectorOfficeSite(request: ModifyADConnectorOfficeSiteRequest): ModifyADConnectorOfficeSiteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyADConnectorOfficeSite', 'POST', '/', 'json', false, 'json', request);
}

model ModifyBundleRequest {
  bundleId: string(name='BundleId', position='Query'),
  bundleName?: string(name='BundleName', position='Query'),
  description?: string(name='Description', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  language?: string(name='Language', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyBundleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBundleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBundleResponseBody(name='body'),
}

async function modifyBundle(request: ModifyBundleRequest): ModifyBundleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyBundle', 'POST', '/', 'json', false, 'json', request);
}

model ModifyCloudDriveServiceRequest {
  cdsId: string(name='CdsId', position='Query'),
  cdsName: string(name='CdsName', position='Query'),
  maxSize: long(name='MaxSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyCloudDriveServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCloudDriveServiceResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCloudDriveServiceResponseBody(name='body'),
}

async function modifyCloudDriveService(request: ModifyCloudDriveServiceRequest): ModifyCloudDriveServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCloudDriveService', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDesktopChargeTypeRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  chargeType?: string(name='ChargeType', position='Query'),
  desktopId: [ string ](name='DesktopId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyDesktopChargeTypeResponseBody = {
  desktopId?: [ string ](name='DesktopId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyDesktopChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDesktopChargeTypeResponseBody(name='body'),
}

async function modifyDesktopChargeType(request: ModifyDesktopChargeTypeRequest): ModifyDesktopChargeTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDesktopChargeType', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDesktopGroupRequest {
  allowAutoSetup?: int32(name='AllowAutoSetup', minimum=0, maximum=1, position='Query'),
  allowBufferCount?: int32(name='AllowBufferCount', minimum=0, maximum=1000, position='Query'),
  comments?: string(name='Comments', position='Query'),
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  desktopGroupName?: string(name='DesktopGroupName', position='Query'),
  keepDuration?: long(name='KeepDuration', position='Query'),
  maxDesktopsCount?: int32(name='MaxDesktopsCount', minimum=1, maximum=1000, position='Query'),
  minDesktopsCount?: int32(name='MinDesktopsCount', minimum=0, maximum=500, position='Query'),
  ownBundleId?: string(name='OwnBundleId', position='Query'),
  policyGroupId?: string(name='PolicyGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resetType?: long(name='ResetType', position='Query'),
  scaleStrategyId?: string(name='ScaleStrategyId', position='Query'),
}

model ModifyDesktopGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDesktopGroupResponseBody(name='body'),
}

async function modifyDesktopGroup(request: ModifyDesktopGroupRequest): ModifyDesktopGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDesktopGroup', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDesktopHostNameRequest {
  desktopId: string(name='DesktopId', position='Query'),
  newHostName: string(name='NewHostName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyDesktopHostNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDesktopHostNameResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDesktopHostNameResponseBody(name='body'),
}

async function modifyDesktopHostName(request: ModifyDesktopHostNameRequest): ModifyDesktopHostNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDesktopHostName', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDesktopNameRequest {
  desktopId: string(name='DesktopId', position='Query'),
  newDesktopName: string(name='NewDesktopName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyDesktopNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDesktopNameResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDesktopNameResponseBody(name='body'),
}

async function modifyDesktopName(request: ModifyDesktopNameRequest): ModifyDesktopNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDesktopName', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDesktopPolicysRequest {
  clipboard?: string(name='Clipboard', position='Query'),
  desktopId: [ string ](name='DesktopId', position='Query'),
  localDrive?: string(name='LocalDrive', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  usbRedirect?: string(name='UsbRedirect', position='Query'),
  watermark?: string(name='Watermark', position='Query'),
}

model ModifyDesktopPolicysResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      code?: string(name='Code'),
      desktopId?: string(name='DesktopId'),
      message?: string(name='Message'),
      success?: string(name='Success'),
    }
  ](name='Results'),
}

model ModifyDesktopPolicysResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDesktopPolicysResponseBody(name='body'),
}

async function modifyDesktopPolicys(request: ModifyDesktopPolicysRequest): ModifyDesktopPolicysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDesktopPolicys', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDesktopSpecRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  desktopId: string(name='DesktopId', position='Query'),
  desktopType?: string(name='DesktopType', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  rootDiskSizeGib?: int32(name='RootDiskSizeGib', minimum=0, maximum=32768, position='Query'),
  userDiskPerformanceLevel?: string(name='UserDiskPerformanceLevel', position='Query'),
  userDiskSizeGib?: int32(name='UserDiskSizeGib', minimum=0, maximum=32768, position='Query'),
}

model ModifyDesktopSpecResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyDesktopSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDesktopSpecResponseBody(name='body'),
}

async function modifyDesktopSpec(request: ModifyDesktopSpecRequest): ModifyDesktopSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDesktopSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDesktopsPolicyGroupRequest {
  desktopId: [ string ](name='DesktopId', position='Query'),
  policyGroupId: string(name='PolicyGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyDesktopsPolicyGroupResponseBody = {
  modifyResults?: [ 
    {
      code?: string(name='Code'),
      desktopId?: string(name='DesktopId'),
      message?: string(name='Message'),
    }
  ](name='ModifyResults'),
  requestId?: string(name='RequestId'),
}

model ModifyDesktopsPolicyGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDesktopsPolicyGroupResponseBody(name='body'),
}

async function modifyDesktopsPolicyGroup(request: ModifyDesktopsPolicyGroupRequest): ModifyDesktopsPolicyGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDesktopsPolicyGroup', 'POST', '/', 'json', false, 'json', request);
}

model ModifyEntitlementRequest {
  desktopId: string(name='DesktopId', position='Query'),
  endUserId?: [ string ](name='EndUserId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyEntitlementResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyEntitlementResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyEntitlementResponseBody(name='body'),
}

async function modifyEntitlement(request: ModifyEntitlementRequest): ModifyEntitlementResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyEntitlement', 'POST', '/', 'json', false, 'json', request);
}

model ModifyImageAttributeRequest {
  description?: string(name='Description', position='Query'),
  imageId: string(name='ImageId', position='Query'),
  name?: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyImageAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyImageAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyImageAttributeResponseBody(name='body'),
}

async function modifyImageAttribute(request: ModifyImageAttributeRequest): ModifyImageAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyImageAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyNASDefaultMountTargetRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  mountTargetDomain: string(name='MountTargetDomain', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyNASDefaultMountTargetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNASDefaultMountTargetResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNASDefaultMountTargetResponseBody(name='body'),
}

async function modifyNASDefaultMountTarget(request: ModifyNASDefaultMountTargetRequest): ModifyNASDefaultMountTargetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNASDefaultMountTarget', 'POST', '/', 'json', false, 'json', request);
}

model ModifyNetworkPackageRequest {
  bandwidth?: int32(name='Bandwidth', minimum=1, maximum=200, position='Query'),
  networkPackageId: string(name='NetworkPackageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyNetworkPackageResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNetworkPackageResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNetworkPackageResponseBody(name='body'),
}

async function modifyNetworkPackage(request: ModifyNetworkPackageRequest): ModifyNetworkPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNetworkPackage', 'POST', '/', 'json', false, 'json', request);
}

model ModifyNetworkPackageBandwidthRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  bandwidth: int32(name='Bandwidth', minimum=10, maximum=1000, position='Query'),
  networkPackageId: string(name='NetworkPackageId', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyNetworkPackageBandwidthResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyNetworkPackageBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNetworkPackageBandwidthResponseBody(name='body'),
}

async function modifyNetworkPackageBandwidth(request: ModifyNetworkPackageBandwidthRequest): ModifyNetworkPackageBandwidthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNetworkPackageBandwidth', 'POST', '/', 'json', false, 'json', request);
}

model ModifyNetworkPackageEnabledRequest {
  enabled?: boolean(name='Enabled', position='Query'),
  networkPackageId: string(name='NetworkPackageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyNetworkPackageEnabledResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNetworkPackageEnabledResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNetworkPackageEnabledResponseBody(name='body'),
}

async function modifyNetworkPackageEnabled(request: ModifyNetworkPackageEnabledRequest): ModifyNetworkPackageEnabledResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNetworkPackageEnabled', 'POST', '/', 'json', false, 'json', request);
}

model ModifyOfficeSiteAttributeRequest {
  desktopAccessType?: string(name='DesktopAccessType', position='Query'),
  needVerifyLoginRisk?: boolean(name='NeedVerifyLoginRisk', position='Query'),
  needVerifyZeroDevice?: boolean(name='NeedVerifyZeroDevice', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  officeSiteName?: string(name='OfficeSiteName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyOfficeSiteAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyOfficeSiteAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyOfficeSiteAttributeResponseBody(name='body'),
}

async function modifyOfficeSiteAttribute(request: ModifyOfficeSiteAttributeRequest): ModifyOfficeSiteAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyOfficeSiteAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyOfficeSiteCrossDesktopAccessRequest {
  enableCrossDesktopAccess: boolean(name='EnableCrossDesktopAccess', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyOfficeSiteCrossDesktopAccessResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyOfficeSiteCrossDesktopAccessResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyOfficeSiteCrossDesktopAccessResponseBody(name='body'),
}

async function modifyOfficeSiteCrossDesktopAccess(request: ModifyOfficeSiteCrossDesktopAccessRequest): ModifyOfficeSiteCrossDesktopAccessResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyOfficeSiteCrossDesktopAccess', 'POST', '/', 'json', false, 'json', request);
}

model ModifyOfficeSiteMfaEnabledRequest {
  mfaEnabled: boolean(name='MfaEnabled', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyOfficeSiteMfaEnabledResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyOfficeSiteMfaEnabledResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyOfficeSiteMfaEnabledResponseBody(name='body'),
}

async function modifyOfficeSiteMfaEnabled(request: ModifyOfficeSiteMfaEnabledRequest): ModifyOfficeSiteMfaEnabledResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyOfficeSiteMfaEnabled', 'POST', '/', 'json', false, 'json', request);
}

model ModifyOperateVulRequest {
  operateType: string(name='OperateType', position='Query'),
  reason?: string(name='Reason', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
  vulInfo?: [ 
    {
      desktopId?: string(name='DesktopId'),
      name?: string(name='Name'),
      tag?: string(name='Tag'),
    }
  ](name='VulInfo', position='Query'),
}

model ModifyOperateVulResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyOperateVulResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyOperateVulResponseBody(name='body'),
}

async function modifyOperateVul(request: ModifyOperateVulRequest): ModifyOperateVulResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyOperateVul', 'POST', '/', 'json', false, 'json', request);
}

model ModifyPolicyGroupRequest {
  authorizeAccessPolicyRule?: [ 
    {
      cidrIp: string(name='CidrIp'),
      description?: string(name='Description'),
    }
  ](name='AuthorizeAccessPolicyRule', position='Query'),
  authorizeSecurityPolicyRule?: [ 
    {
      cidrIp?: string(name='CidrIp'),
      description?: string(name='Description'),
      ipProtocol?: string(name='IpProtocol'),
      policy?: string(name='Policy'),
      portRange?: string(name='PortRange'),
      priority?: string(name='Priority'),
      type?: string(name='Type'),
    }
  ](name='AuthorizeSecurityPolicyRule', position='Query'),
  clientType?: [ 
    {
      clientType?: string(name='ClientType'),
      status?: string(name='Status'),
    }
  ](name='ClientType', position='Query'),
  clipboard?: string(name='Clipboard', position='Query'),
  domainList?: string(name='DomainList', position='Query'),
  gpuAcceleration?: string(name='GpuAcceleration', position='Query'),
  html5Access?: string(name='Html5Access', position='Query'),
  html5FileTransfer?: string(name='Html5FileTransfer', position='Query'),
  localDrive?: string(name='LocalDrive', position='Query'),
  name?: string(name='Name', position='Query'),
  policyGroupId: string(name='PolicyGroupId', position='Query'),
  preemptLogin?: string(name='PreemptLogin', position='Query'),
  preemptLoginUser?: [ string ](name='PreemptLoginUser', position='Query'),
  printerRedirection?: string(name='PrinterRedirection', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  revokeAccessPolicyRule?: [ 
    {
      cidrIp?: string(name='CidrIp'),
      description?: string(name='Description'),
    }
  ](name='RevokeAccessPolicyRule', position='Query'),
  revokeSecurityPolicyRule?: [ 
    {
      cidrIp?: string(name='CidrIp'),
      description?: string(name='Description'),
      ipProtocol?: string(name='IpProtocol'),
      policy?: string(name='Policy'),
      portRange?: string(name='PortRange'),
      priority?: string(name='Priority'),
      type?: string(name='Type'),
    }
  ](name='RevokeSecurityPolicyRule', position='Query'),
  usbRedirect?: string(name='UsbRedirect', position='Query'),
  usbSupplyRedirectRule?: [ 
    {
      description?: string(name='Description'),
      deviceClass?: string(name='DeviceClass'),
      deviceSubclass?: string(name='DeviceSubclass'),
      productId?: string(name='ProductId'),
      usbRedirectType?: long(name='UsbRedirectType'),
      usbRuleType?: long(name='UsbRuleType'),
      vendorId?: string(name='VendorId'),
    }
  ](name='UsbSupplyRedirectRule', position='Query'),
  visualQuality?: string(name='VisualQuality', position='Query'),
  watermark?: string(name='Watermark', position='Query'),
  watermarkCustomText?: string(name='WatermarkCustomText', position='Query'),
  watermarkTransparency?: string(name='WatermarkTransparency', position='Query'),
  watermarkType?: string(name='WatermarkType', position='Query'),
}

model ModifyPolicyGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyPolicyGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPolicyGroupResponseBody(name='body'),
}

async function modifyPolicyGroup(request: ModifyPolicyGroupRequest): ModifyPolicyGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyPolicyGroup', 'POST', '/', 'json', false, 'json', request);
}

model ModifyScaleStrategyRequest {
  maxAvailableDesktopsCount?: int32(name='MaxAvailableDesktopsCount', minimum=0, maximum=100, position='Query'),
  maxDesktopsCount?: int32(name='MaxDesktopsCount', minimum=1, maximum=1000, position='Query'),
  minAvailableDesktopsCount?: int32(name='MinAvailableDesktopsCount', minimum=0, maximum=100, position='Query'),
  minDesktopsCount?: int32(name='MinDesktopsCount', minimum=0, maximum=500, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  scaleStep?: int32(name='ScaleStep', minimum=1, maximum=100, position='Query'),
  scaleStrategyId: string(name='ScaleStrategyId', position='Query'),
  scaleStrategyName?: string(name='ScaleStrategyName', position='Query'),
  scaleStrategyType?: string(name='ScaleStrategyType', position='Query'),
}

model ModifyScaleStrategyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyScaleStrategyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyScaleStrategyResponseBody(name='body'),
}

async function modifyScaleStrategy(request: ModifyScaleStrategyRequest): ModifyScaleStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyScaleStrategy', 'POST', '/', 'json', false, 'json', request);
}

model ModifyUserEntitlementRequest {
  authorizeDesktopId?: [ string ](name='AuthorizeDesktopId', position='Query'),
  endUserId?: [ string ](name='EndUserId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  revokeDesktopId?: [ string ](name='RevokeDesktopId', position='Query'),
}

model ModifyUserEntitlementResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUserEntitlementResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyUserEntitlementResponseBody(name='body'),
}

async function modifyUserEntitlement(request: ModifyUserEntitlementRequest): ModifyUserEntitlementResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyUserEntitlement', 'POST', '/', 'json', false, 'json', request);
}

model ModifyUserToDesktopGroupRequest {
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  newEndUserIds: [ string ](name='NewEndUserIds', position='Query'),
  oldEndUserIds: [ string ](name='OldEndUserIds', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyUserToDesktopGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUserToDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyUserToDesktopGroupResponseBody(name='body'),
}

async function modifyUserToDesktopGroup(request: ModifyUserToDesktopGroupRequest): ModifyUserToDesktopGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyUserToDesktopGroup', 'POST', '/', 'json', false, 'json', request);
}

model OperateVulsRequest {
  desktopId: [ string ](name='DesktopId', position='Query'),
  operateType: string(name='OperateType', position='Query'),
  precondition: int32(name='Precondition', position='Query'),
  reason?: string(name='Reason', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
  vulName: [ string ](name='VulName', position='Query'),
}

model OperateVulsResponseBody = {
  requestId?: string(name='RequestId'),
}

model OperateVulsResponse = {
  headers: map[string]string(name='headers'),
  body: OperateVulsResponseBody(name='body'),
}

async function operateVuls(request: OperateVulsRequest): OperateVulsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OperateVuls', 'POST', '/', 'json', false, 'json', request);
}

model PayOrderCallbackRequest {
  data: string(name='data', position='Query'),
}

model PayOrderCallbackResponseBody = {
  requestId?: string(name='RequestId'),
}

model PayOrderCallbackResponse = {
  headers: map[string]string(name='headers'),
  body: PayOrderCallbackResponseBody(name='body'),
}

async function payOrderCallback(request: PayOrderCallbackRequest): PayOrderCallbackResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PayOrderCallback', 'POST', '/', 'json', false, 'json', request);
}

model RebootDesktopsRequest {
  desktopId: [ string ](name='DesktopId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RebootDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RebootDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: RebootDesktopsResponseBody(name='body'),
}

async function rebootDesktops(request: RebootDesktopsRequest): RebootDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RebootDesktops', 'POST', '/', 'json', false, 'json', request);
}

model RebuildDesktopsRequest {
  desktopId: [ string ](name='DesktopId', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RebuildDesktopsResponseBody = {
  rebuildResults?: [ 
    {
      code?: string(name='Code'),
      desktopId?: string(name='DesktopId'),
      message?: string(name='Message'),
    }
  ](name='RebuildResults'),
  requestId?: string(name='RequestId'),
}

model RebuildDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: RebuildDesktopsResponseBody(name='body'),
}

async function rebuildDesktops(request: RebuildDesktopsRequest): RebuildDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RebuildDesktops', 'POST', '/', 'json', false, 'json', request);
}

model RecreateDesktopGroupRequest {
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  ownBundleId?: string(name='OwnBundleId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RecreateDesktopGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model RecreateDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  body: RecreateDesktopGroupResponseBody(name='body'),
}

async function recreateDesktopGroup(request: RecreateDesktopGroupRequest): RecreateDesktopGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RecreateDesktopGroup', 'POST', '/', 'json', false, 'json', request);
}

model RemoveUserFromDesktopGroupRequest {
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  endUserIds: [ string ](name='EndUserIds', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RemoveUserFromDesktopGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveUserFromDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveUserFromDesktopGroupResponseBody(name='body'),
}

async function removeUserFromDesktopGroup(request: RemoveUserFromDesktopGroupRequest): RemoveUserFromDesktopGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveUserFromDesktopGroup', 'POST', '/', 'json', false, 'json', request);
}

model RenewDesktopGroupRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  desktopGroupId: string(name='DesktopGroupId', position='Query'),
  keepSamePeriod?: int32(name='KeepSamePeriod', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RenewDesktopGroupResponseBody = {
  orderId?: [ string ](name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewDesktopGroupResponse = {
  headers: map[string]string(name='headers'),
  body: RenewDesktopGroupResponseBody(name='body'),
}

async function renewDesktopGroup(request: RenewDesktopGroupRequest): RenewDesktopGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RenewDesktopGroup', 'POST', '/', 'json', false, 'json', request);
}

model RenewDesktopsRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  desktopId: [ string ](name='DesktopId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RenewDesktopsResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: RenewDesktopsResponseBody(name='body'),
}

async function renewDesktops(request: RenewDesktopsRequest): RenewDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RenewDesktops', 'POST', '/', 'json', false, 'json', request);
}

model RenewNetworkPackagesRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  networkPackageId: [ string ](name='NetworkPackageId', position='Query'),
  period?: int32(name='Period', position='Query'),
  periodUnit?: string(name='PeriodUnit', position='Query'),
  promotionId?: string(name='PromotionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RenewNetworkPackagesResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewNetworkPackagesResponse = {
  headers: map[string]string(name='headers'),
  body: RenewNetworkPackagesResponseBody(name='body'),
}

async function renewNetworkPackages(request: RenewNetworkPackagesRequest): RenewNetworkPackagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RenewNetworkPackages', 'POST', '/', 'json', false, 'json', request);
}

model ResetNASDefaultMountTargetRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ResetNASDefaultMountTargetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetNASDefaultMountTargetResponse = {
  headers: map[string]string(name='headers'),
  body: ResetNASDefaultMountTargetResponseBody(name='body'),
}

async function resetNASDefaultMountTarget(request: ResetNASDefaultMountTargetRequest): ResetNASDefaultMountTargetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetNASDefaultMountTarget', 'POST', '/', 'json', false, 'json', request);
}

model ResetSnapshotRequest {
  regionId: string(name='RegionId', position='Query'),
  snapshotId: string(name='SnapshotId', position='Query'),
}

model ResetSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: ResetSnapshotResponseBody(name='body'),
}

async function resetSnapshot(request: ResetSnapshotRequest): ResetSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetSnapshot', 'POST', '/', 'json', false, 'json', request);
}

model RollbackSuspEventQuaraFileRequest {
  desktopId?: string(name='DesktopId', position='Query'),
  quaraFieldId: int32(name='QuaraFieldId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RollbackSuspEventQuaraFileResponseBody = {
  requestId?: string(name='RequestId'),
}

model RollbackSuspEventQuaraFileResponse = {
  headers: map[string]string(name='headers'),
  body: RollbackSuspEventQuaraFileResponseBody(name='body'),
}

async function rollbackSuspEventQuaraFile(request: RollbackSuspEventQuaraFileRequest): RollbackSuspEventQuaraFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RollbackSuspEventQuaraFile', 'POST', '/', 'json', false, 'json', request);
}

model RunCommandRequest {
  commandContent: string(name='CommandContent', position='Query'),
  contentEncoding?: string(name='ContentEncoding', position='Query'),
  desktopId: [ string ](name='DesktopId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  timeout?: long(name='Timeout', position='Query'),
  type: string(name='Type', position='Query'),
}

model RunCommandResponseBody = {
  invokeId?: string(name='InvokeId'),
  requestId?: string(name='RequestId'),
}

model RunCommandResponse = {
  headers: map[string]string(name='headers'),
  body: RunCommandResponseBody(name='body'),
}

async function runCommand(request: RunCommandRequest): RunCommandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunCommand', 'POST', '/', 'json', false, 'json', request);
}

model SendVerifyCodeRequest {
  extraInfo?: string(name='ExtraInfo', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  verifyCodeAction: string(name='VerifyCodeAction', position='Query'),
}

model SendVerifyCodeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SendVerifyCodeResponse = {
  headers: map[string]string(name='headers'),
  body: SendVerifyCodeResponseBody(name='body'),
}

async function sendVerifyCode(request: SendVerifyCodeRequest): SendVerifyCodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SendVerifyCode', 'POST', '/', 'json', false, 'json', request);
}

model SetDirectorySsoStatusRequest {
  directoryId: string(name='DirectoryId', position='Query'),
  enableSso: boolean(name='EnableSso', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model SetDirectorySsoStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetDirectorySsoStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetDirectorySsoStatusResponseBody(name='body'),
}

async function setDirectorySsoStatus(request: SetDirectorySsoStatusRequest): SetDirectorySsoStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDirectorySsoStatus', 'POST', '/', 'json', false, 'json', request);
}

model SetIdpMetadataRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  idpMetadata: string(name='IdpMetadata', position='Query'),
  officeSiteId?: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model SetIdpMetadataResponseBody = {
  idpEntityId?: string(name='IdpEntityId'),
  requestId?: string(name='RequestId'),
}

model SetIdpMetadataResponse = {
  headers: map[string]string(name='headers'),
  body: SetIdpMetadataResponseBody(name='body'),
}

async function setIdpMetadata(request: SetIdpMetadataRequest): SetIdpMetadataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetIdpMetadata', 'POST', '/', 'json', false, 'json', request);
}

model SetOfficeSiteSsoStatusRequest {
  enableSso: boolean(name='EnableSso', position='Query'),
  officeSiteId: string(name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  ssoType?: string(name='SsoType', position='Query'),
}

model SetOfficeSiteSsoStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetOfficeSiteSsoStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetOfficeSiteSsoStatusResponseBody(name='body'),
}

async function setOfficeSiteSsoStatus(request: SetOfficeSiteSsoStatusRequest): SetOfficeSiteSsoStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetOfficeSiteSsoStatus', 'POST', '/', 'json', false, 'json', request);
}

model StartDesktopsRequest {
  desktopId: [ string ](name='DesktopId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model StartDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: StartDesktopsResponseBody(name='body'),
}

async function startDesktops(request: StartDesktopsRequest): StartDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartDesktops', 'POST', '/', 'json', false, 'json', request);
}

model StartVirusScanTaskRequest {
  desktopId?: [ string ](name='DesktopId', position='Query'),
  officeSiteId?: [ string ](name='OfficeSiteId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model StartVirusScanTaskResponseBody = {
  requestId?: string(name='RequestId'),
  scanTaskId?: long(name='ScanTaskId'),
}

model StartVirusScanTaskResponse = {
  headers: map[string]string(name='headers'),
  body: StartVirusScanTaskResponseBody(name='body'),
}

async function startVirusScanTask(request: StartVirusScanTaskRequest): StartVirusScanTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartVirusScanTask', 'POST', '/', 'json', false, 'json', request);
}

model StopDesktopsRequest {
  desktopId: [ string ](name='DesktopId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  stoppedMode?: string(name='StoppedMode', position='Query'),
}

model StopDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: StopDesktopsResponseBody(name='body'),
}

async function stopDesktops(request: StopDesktopsRequest): StopDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopDesktops', 'POST', '/', 'json', false, 'json', request);
}

model StopInvocationRequest {
  desktopId?: [ string ](name='DesktopId', position='Query'),
  invokeId: string(name='InvokeId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model StopInvocationResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopInvocationResponse = {
  headers: map[string]string(name='headers'),
  body: StopInvocationResponseBody(name='body'),
}

async function stopInvocation(request: StopInvocationRequest): StopInvocationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopInvocation', 'POST', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model UnlockVirtualMFADeviceRequest {
  regionId: string(name='RegionId', position='Query'),
  serialNumber: string(name='SerialNumber', position='Query'),
}

model UnlockVirtualMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnlockVirtualMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  body: UnlockVirtualMFADeviceResponseBody(name='body'),
}

async function unlockVirtualMFADevice(request: UnlockVirtualMFADeviceRequest): UnlockVirtualMFADeviceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnlockVirtualMFADevice', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tagKey?: [ string ](name='TagKey', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

model VerifyCenRequest {
  cenId: string(name='CenId', position='Query'),
  cenOwnerId?: long(name='CenOwnerId', position='Query'),
  cidrBlock: string(name='CidrBlock', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  verifyCode?: string(name='VerifyCode', position='Query'),
}

model VerifyCenResponseBody = {
  cidrBlocks?: [ string ](name='CidrBlocks'),
  requestId?: string(name='RequestId'),
  routeEntries?: [ 
    {
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      nextHopInstanceId?: string(name='NextHopInstanceId'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
    }
  ](name='RouteEntries'),
  status?: string(name='Status'),
}

model VerifyCenResponse = {
  headers: map[string]string(name='headers'),
  body: VerifyCenResponseBody(name='body'),
}

async function verifyCen(request: VerifyCenRequest): VerifyCenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'VerifyCen', 'POST', '/', 'json', false, 'json', request);
}

