/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Kms';
  @version = '2016-01-20';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AsymmetricDecryptRequest {
  algorithm: string(name='Algorithm', position='Query'),
  ciphertextBlob: string(name='CiphertextBlob', position='Query'),
  keyId: string(name='KeyId', position='Query'),
  keyVersionId: string(name='KeyVersionId', position='Query'),
}

model AsymmetricDecryptResponseBody = {
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  plaintext?: string(name='Plaintext'),
  requestId?: string(name='RequestId'),
}

model AsymmetricDecryptResponse = {
  headers: map[string]string(name='headers'),
  body: AsymmetricDecryptResponseBody(name='body'),
}

async function asymmetricDecrypt(request: AsymmetricDecryptRequest): AsymmetricDecryptResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AsymmetricDecrypt', 'POST', '/', 'json', false, 'json', request);
}

model AsymmetricEncryptRequest {
  algorithm: string(name='Algorithm', position='Query'),
  keyId: string(name='KeyId', position='Query'),
  keyVersionId: string(name='KeyVersionId', position='Query'),
  plaintext: string(name='Plaintext', position='Query'),
}

model AsymmetricEncryptResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  requestId?: string(name='RequestId'),
}

model AsymmetricEncryptResponse = {
  headers: map[string]string(name='headers'),
  body: AsymmetricEncryptResponseBody(name='body'),
}

async function asymmetricEncrypt(request: AsymmetricEncryptRequest): AsymmetricEncryptResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AsymmetricEncrypt', 'POST', '/', 'json', false, 'json', request);
}

model AsymmetricSignRequest {
  algorithm: string(name='Algorithm', position='Query'),
  digest: string(name='Digest', position='Query'),
  keyId: string(name='KeyId', position='Query'),
  keyVersionId: string(name='KeyVersionId', position='Query'),
}

model AsymmetricSignResponseBody = {
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  requestId?: string(name='RequestId'),
  value?: string(name='Value'),
}

model AsymmetricSignResponse = {
  headers: map[string]string(name='headers'),
  body: AsymmetricSignResponseBody(name='body'),
}

async function asymmetricSign(request: AsymmetricSignRequest): AsymmetricSignResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AsymmetricSign', 'POST', '/', 'json', false, 'json', request);
}

model AsymmetricVerifyRequest {
  algorithm: string(name='Algorithm', position='Query'),
  digest: string(name='Digest', position='Query'),
  keyId: string(name='KeyId', position='Query'),
  keyVersionId: string(name='KeyVersionId', position='Query'),
  value: string(name='Value', position='Query'),
}

model AsymmetricVerifyResponseBody = {
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  requestId?: string(name='RequestId'),
  value?: boolean(name='Value'),
}

model AsymmetricVerifyResponse = {
  headers: map[string]string(name='headers'),
  body: AsymmetricVerifyResponseBody(name='body'),
}

async function asymmetricVerify(request: AsymmetricVerifyRequest): AsymmetricVerifyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AsymmetricVerify', 'POST', '/', 'json', false, 'json', request);
}

model CancelKeyDeletionRequest {
  keyId: string(name='KeyId', position='Query'),
}

model CancelKeyDeletionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelKeyDeletionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelKeyDeletionResponseBody(name='body'),
}

async function cancelKeyDeletion(request: CancelKeyDeletionRequest): CancelKeyDeletionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelKeyDeletion', 'POST', '/', 'json', false, 'json', request);
}

model CertificatePrivateKeyDecryptRequest {
  algorithm: string(name='Algorithm', position='Query'),
  certificateId: string(name='CertificateId', position='Query'),
  ciphertextBlob: string(name='CiphertextBlob', position='Query'),
}

model CertificatePrivateKeyDecryptResponseBody = {
  certificateId?: string(name='CertificateId'),
  plaintext?: string(name='Plaintext'),
  requestId?: string(name='RequestId'),
}

model CertificatePrivateKeyDecryptResponse = {
  headers: map[string]string(name='headers'),
  body: CertificatePrivateKeyDecryptResponseBody(name='body'),
}

async function certificatePrivateKeyDecrypt(request: CertificatePrivateKeyDecryptRequest): CertificatePrivateKeyDecryptResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CertificatePrivateKeyDecrypt', 'POST', '/', 'json', false, 'json', request);
}

model CertificatePrivateKeySignRequest {
  algorithm: string(name='Algorithm', position='Query'),
  certificateId: string(name='CertificateId', position='Query'),
  message: string(name='Message', position='Query'),
  messageType: string(name='MessageType', position='Query'),
}

model CertificatePrivateKeySignResponseBody = {
  certificateId?: string(name='CertificateId'),
  requestId?: string(name='RequestId'),
  signatureValue?: string(name='SignatureValue'),
}

model CertificatePrivateKeySignResponse = {
  headers: map[string]string(name='headers'),
  body: CertificatePrivateKeySignResponseBody(name='body'),
}

async function certificatePrivateKeySign(request: CertificatePrivateKeySignRequest): CertificatePrivateKeySignResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CertificatePrivateKeySign', 'POST', '/', 'json', false, 'json', request);
}

model CertificatePublicKeyEncryptRequest {
  algorithm: string(name='Algorithm', position='Query'),
  certificateId: string(name='CertificateId', position='Query'),
  plaintext: string(name='Plaintext', position='Query'),
}

model CertificatePublicKeyEncryptResponseBody = {
  certificateId?: string(name='CertificateId'),
  ciphertextBlob?: string(name='CiphertextBlob'),
  requestId?: string(name='RequestId'),
}

model CertificatePublicKeyEncryptResponse = {
  headers: map[string]string(name='headers'),
  body: CertificatePublicKeyEncryptResponseBody(name='body'),
}

async function certificatePublicKeyEncrypt(request: CertificatePublicKeyEncryptRequest): CertificatePublicKeyEncryptResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CertificatePublicKeyEncrypt', 'POST', '/', 'json', false, 'json', request);
}

model CertificatePublicKeyVerifyRequest {
  algorithm: string(name='Algorithm', position='Query'),
  certificateId: string(name='CertificateId', position='Query'),
  message: string(name='Message', position='Query'),
  messageType: string(name='MessageType', position='Query'),
  signatureValue: string(name='SignatureValue', position='Query'),
}

model CertificatePublicKeyVerifyResponseBody = {
  certificateId?: string(name='CertificateId'),
  requestId?: string(name='RequestId'),
  signatureValid?: boolean(name='SignatureValid'),
}

model CertificatePublicKeyVerifyResponse = {
  headers: map[string]string(name='headers'),
  body: CertificatePublicKeyVerifyResponseBody(name='body'),
}

async function certificatePublicKeyVerify(request: CertificatePublicKeyVerifyRequest): CertificatePublicKeyVerifyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CertificatePublicKeyVerify', 'POST', '/', 'json', false, 'json', request);
}

model CreateAliasRequest {
  aliasName: string(name='AliasName', position='Query'),
  keyId: string(name='KeyId', position='Query'),
}

model CreateAliasResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateAliasResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAliasResponseBody(name='body'),
}

async function createAlias(request: CreateAliasRequest): CreateAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAlias', 'POST', '/', 'json', false, 'json', request);
}

model CreateCertificateRequest {
  exportablePrivateKey?: boolean(name='ExportablePrivateKey', position='Query'),
  keySpec: string(name='KeySpec', position='Query'),
  subject: string(name='Subject', position='Query'),
  subjectAlternativeNames?: map[string]any(name='SubjectAlternativeNames', position='Query'),
}

model CreateCertificateResponseBody = {
  arn?: string(name='Arn'),
  certificateId?: string(name='CertificateId'),
  csr?: string(name='Csr'),
  requestId?: string(name='RequestId'),
}

model CreateCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCertificateResponseBody(name='body'),
}

async function createCertificate(request: CreateCertificateRequest): CreateCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCertificate', 'POST', '/', 'json', false, 'json', request);
}

model CreateKeyRequest {
  description?: string(name='Description', position='Query'),
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation', position='Query'),
  keySpec?: string(name='KeySpec', position='Query'),
  keyUsage?: string(name='KeyUsage', position='Query'),
  origin?: string(name='Origin', position='Query'),
  protectionLevel?: string(name='ProtectionLevel', position='Query'),
  rotationInterval?: string(name='RotationInterval', position='Query'),
}

model CreateKeyResponseBody = {
  keyMetadata?: {
    arn?: string(name='Arn'),
    automaticRotation?: string(name='AutomaticRotation'),
    creationDate?: string(name='CreationDate'),
    creator?: string(name='Creator'),
    deleteDate?: string(name='DeleteDate'),
    description?: string(name='Description'),
    keyId?: string(name='KeyId'),
    keySpec?: string(name='KeySpec'),
    keyState?: string(name='KeyState'),
    keyUsage?: string(name='KeyUsage'),
    lastRotationDate?: string(name='LastRotationDate'),
    materialExpireTime?: string(name='MaterialExpireTime'),
    nextRotationDate?: string(name='NextRotationDate'),
    origin?: string(name='Origin'),
    primaryKeyVersion?: string(name='PrimaryKeyVersion'),
    protectionLevel?: string(name='ProtectionLevel'),
    rotationInterval?: string(name='RotationInterval'),
  }(name='KeyMetadata'),
  requestId?: string(name='RequestId'),
}

model CreateKeyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateKeyResponseBody(name='body'),
}

async function createKey(request: CreateKeyRequest): CreateKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateKey', 'POST', '/', 'json', false, 'json', request);
}

model CreateKeyVersionRequest {
  keyId: string(name='KeyId', position='Query'),
}

model CreateKeyVersionResponseBody = {
  keyVersion?: {
    creationDate?: string(name='CreationDate'),
    keyId?: string(name='KeyId'),
    keyVersionId?: string(name='KeyVersionId'),
  }(name='KeyVersion'),
  requestId?: string(name='RequestId'),
}

model CreateKeyVersionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateKeyVersionResponseBody(name='body'),
}

async function createKeyVersion(request: CreateKeyVersionRequest): CreateKeyVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateKeyVersion', 'POST', '/', 'json', false, 'json', request);
}

model CreateSecretRequest {
  description?: string(name='Description', position='Query'),
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation', position='Query'),
  encryptionKeyId?: string(name='EncryptionKeyId', position='Query'),
  extendedConfig?: map[string]any(name='ExtendedConfig', position='Query'),
  rotationInterval?: string(name='RotationInterval', position='Query'),
  secretData: string(name='SecretData', position='Query'),
  secretDataType?: string(name='SecretDataType', position='Query'),
  secretName: string(name='SecretName', position='Query'),
  secretType?: string(name='SecretType', position='Query'),
  tags?: string(name='Tags', position='Query'),
  versionId: string(name='VersionId', position='Query'),
}

model CreateSecretResponseBody = {
  arn?: string(name='Arn'),
  automaticRotation?: string(name='AutomaticRotation'),
  extendedConfig?: string(name='ExtendedConfig'),
  nextRotationDate?: string(name='NextRotationDate'),
  requestId?: string(name='RequestId'),
  rotationInterval?: string(name='RotationInterval'),
  secretName?: string(name='SecretName'),
  secretType?: string(name='SecretType'),
  versionId?: string(name='VersionId'),
}

model CreateSecretResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSecretResponseBody(name='body'),
}

async function createSecret(request: CreateSecretRequest): CreateSecretResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSecret', 'POST', '/', 'json', false, 'json', request);
}

model DecryptRequest {
  ciphertextBlob: string(name='CiphertextBlob', position='Query'),
  encryptionContext?: map[string]any(name='EncryptionContext', position='Query'),
}

model DecryptResponseBody = {
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  plaintext?: string(name='Plaintext'),
  requestId?: string(name='RequestId'),
}

model DecryptResponse = {
  headers: map[string]string(name='headers'),
  body: DecryptResponseBody(name='body'),
}

async function decrypt(request: DecryptRequest): DecryptResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'Decrypt', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAliasRequest {
  aliasName: string(name='AliasName', position='Query'),
}

model DeleteAliasResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAliasResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAliasResponseBody(name='body'),
}

async function deleteAlias(request: DeleteAliasRequest): DeleteAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAlias', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCertificateRequest {
  certificateId: string(name='CertificateId', position='Query'),
}

model DeleteCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCertificateResponseBody(name='body'),
}

async function deleteCertificate(request: DeleteCertificateRequest): DeleteCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCertificate', 'POST', '/', 'json', false, 'json', request);
}

model DeleteKeyMaterialRequest {
  keyId: string(name='KeyId', position='Query'),
}

model DeleteKeyMaterialResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteKeyMaterialResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteKeyMaterialResponseBody(name='body'),
}

async function deleteKeyMaterial(request: DeleteKeyMaterialRequest): DeleteKeyMaterialResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteKeyMaterial', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSecretRequest {
  forceDeleteWithoutRecovery?: string(name='ForceDeleteWithoutRecovery', position='Query'),
  recoveryWindowInDays?: string(name='RecoveryWindowInDays', position='Query'),
  secretName: string(name='SecretName', position='Query'),
}

model DeleteSecretResponseBody = {
  plannedDeleteTime?: string(name='PlannedDeleteTime'),
  requestId?: string(name='RequestId'),
  secretName?: string(name='SecretName'),
}

model DeleteSecretResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSecretResponseBody(name='body'),
}

async function deleteSecret(request: DeleteSecretRequest): DeleteSecretResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSecret', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAccountKmsStatusRequest {
}

model DescribeAccountKmsStatusResponseBody = {
  accountStatus?: string(name='AccountStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeAccountKmsStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccountKmsStatusResponseBody(name='body'),
}

async function describeAccountKmsStatus(request: DescribeAccountKmsStatusRequest): DescribeAccountKmsStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAccountKmsStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCertificateRequest {
  certificateId: string(name='CertificateId', position='Query'),
}

model DescribeCertificateResponseBody = {
  arn?: string(name='Arn'),
  certificateId?: string(name='CertificateId'),
  createdAt?: string(name='CreatedAt'),
  exportablePrivateKey?: boolean(name='ExportablePrivateKey'),
  issuer?: string(name='Issuer'),
  keySpec?: string(name='KeySpec'),
  notAfter?: string(name='NotAfter'),
  notBefore?: string(name='NotBefore'),
  requestId?: string(name='RequestId'),
  serial?: string(name='Serial'),
  signatureAlgorithm?: string(name='SignatureAlgorithm'),
  status?: string(name='Status'),
  subject?: string(name='Subject'),
  subjectAlternativeNames?: [ string ](name='SubjectAlternativeNames'),
  subjectKeyIdentifier?: string(name='SubjectKeyIdentifier'),
  subjectPublicKey?: string(name='SubjectPublicKey'),
  tags?: map[string]any(name='Tags'),
  updatedAt?: string(name='UpdatedAt'),
}

model DescribeCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCertificateResponseBody(name='body'),
}

async function describeCertificate(request: DescribeCertificateRequest): DescribeCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCertificate', 'POST', '/', 'json', false, 'json', request);
}

model DescribeKeyRequest {
  keyId: string(name='KeyId', position='Query'),
}

model DescribeKeyResponseBody = {
  keyMetadata?: {
    arn?: string(name='Arn'),
    automaticRotation?: string(name='AutomaticRotation'),
    creationDate?: string(name='CreationDate'),
    creator?: string(name='Creator'),
    deleteDate?: string(name='DeleteDate'),
    deletionProtection?: string(name='DeletionProtection'),
    deletionProtectionDescription?: string(name='DeletionProtectionDescription'),
    description?: string(name='Description'),
    keyId?: string(name='KeyId'),
    keySpec?: string(name='KeySpec'),
    keyState?: string(name='KeyState'),
    keyUsage?: string(name='KeyUsage'),
    lastRotationDate?: string(name='LastRotationDate'),
    materialExpireTime?: string(name='MaterialExpireTime'),
    nextRotationDate?: string(name='NextRotationDate'),
    origin?: string(name='Origin'),
    primaryKeyVersion?: string(name='PrimaryKeyVersion'),
    protectionLevel?: string(name='ProtectionLevel'),
    rotationInterval?: string(name='RotationInterval'),
  }(name='KeyMetadata'),
  requestId?: string(name='RequestId'),
}

model DescribeKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeKeyResponseBody(name='body'),
}

async function describeKey(request: DescribeKeyRequest): DescribeKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeKey', 'POST', '/', 'json', false, 'json', request);
}

model DescribeKeyVersionRequest {
  keyId: string(name='KeyId', position='Query'),
  keyVersionId: string(name='KeyVersionId', position='Query'),
}

model DescribeKeyVersionResponseBody = {
  keyVersion?: {
    creationDate?: string(name='CreationDate'),
    keyId?: string(name='KeyId'),
    keyVersionId?: string(name='KeyVersionId'),
  }(name='KeyVersion'),
  requestId?: string(name='RequestId'),
}

model DescribeKeyVersionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeKeyVersionResponseBody(name='body'),
}

async function describeKeyVersion(request: DescribeKeyVersionRequest): DescribeKeyVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeKeyVersion', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      regionId?: string(name='RegionId'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSecretRequest {
  fetchTags?: string(name='FetchTags', position='Query'),
  secretName: string(name='SecretName', position='Query'),
}

model DescribeSecretResponseBody = {
  arn?: string(name='Arn'),
  automaticRotation?: string(name='AutomaticRotation'),
  createTime?: string(name='CreateTime'),
  description?: string(name='Description'),
  encryptionKeyId?: string(name='EncryptionKeyId'),
  extendedConfig?: string(name='ExtendedConfig'),
  lastRotationDate?: string(name='LastRotationDate'),
  nextRotationDate?: string(name='NextRotationDate'),
  plannedDeleteTime?: string(name='PlannedDeleteTime'),
  requestId?: string(name='RequestId'),
  rotationInterval?: string(name='RotationInterval'),
  secretName?: string(name='SecretName'),
  secretType?: string(name='SecretType'),
  tags?: {
    tag?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Tag')
  }(name='Tags'),
  updateTime?: string(name='UpdateTime'),
}

model DescribeSecretResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecretResponseBody(name='body'),
}

async function describeSecret(request: DescribeSecretRequest): DescribeSecretResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecret', 'POST', '/', 'json', false, 'json', request);
}

model DescribeServiceRequest {
}

model DescribeServiceResponseBody = {
  keySpecs?: {
    keySpec?: [ 
    {
      name?: string(name='Name'),
      supportedProtectionLevels?: {
        supportedProtectionLevel?: [ string ](name='SupportedProtectionLevel')
      }(name='SupportedProtectionLevels'),
      usages?: {
        usage?: [ string ](name='Usage')
      }(name='Usages'),
    }
  ](name='KeySpec')
  }(name='KeySpecs'),
  protectionLevels?: {
    protectionLevel?: [ 
    {
      type?: string(name='Type'),
    }
  ](name='ProtectionLevel')
  }(name='ProtectionLevels'),
  requestId?: string(name='RequestId'),
}

model DescribeServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServiceResponseBody(name='body'),
}

async function describeService(request: DescribeServiceRequest): DescribeServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeService', 'POST', '/', 'json', false, 'json', request);
}

model DisableKeyRequest {
  keyId: string(name='KeyId', position='Query'),
}

model DisableKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DisableKeyResponseBody(name='body'),
}

async function disableKey(request: DisableKeyRequest): DisableKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableKey', 'POST', '/', 'json', false, 'json', request);
}

model EnableKeyRequest {
  keyId: string(name='KeyId', position='Query'),
}

model EnableKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableKeyResponse = {
  headers: map[string]string(name='headers'),
  body: EnableKeyResponseBody(name='body'),
}

async function enableKey(request: EnableKeyRequest): EnableKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableKey', 'POST', '/', 'json', false, 'json', request);
}

model EncryptRequest {
  encryptionContext?: map[string]any(name='EncryptionContext', position='Query'),
  keyId: string(name='KeyId', position='Query'),
  plaintext: string(name='Plaintext', position='Query'),
}

model EncryptResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  requestId?: string(name='RequestId'),
}

model EncryptResponse = {
  headers: map[string]string(name='headers'),
  body: EncryptResponseBody(name='body'),
}

async function encrypt(request: EncryptRequest): EncryptResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'Encrypt', 'POST', '/', 'json', false, 'json', request);
}

model ExportCertificateRequest {
  certificateId: string(name='CertificateId', position='Query'),
  exportFormat?: string(name='ExportFormat', position='Query'),
  passphrase: string(name='Passphrase', position='Query'),
}

model ExportCertificateResponseBody = {
  certificate?: string(name='Certificate'),
  certificateChain?: string(name='CertificateChain'),
  certificateId?: string(name='CertificateId'),
  PKCS12Blob?: string(name='PKCS12Blob'),
  privateKey?: string(name='PrivateKey'),
  requestId?: string(name='RequestId'),
}

model ExportCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: ExportCertificateResponseBody(name='body'),
}

async function exportCertificate(request: ExportCertificateRequest): ExportCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportCertificate', 'POST', '/', 'json', false, 'json', request);
}

model ExportDataKeyRequest {
  ciphertextBlob: string(name='CiphertextBlob', position='Query'),
  encryptionContext?: map[string]any(name='EncryptionContext', position='Query'),
  publicKeyBlob: string(name='PublicKeyBlob', position='Query'),
  wrappingAlgorithm: string(name='WrappingAlgorithm', position='Query'),
  wrappingKeySpec: string(name='WrappingKeySpec', position='Query'),
}

model ExportDataKeyResponseBody = {
  exportedDataKey?: string(name='ExportedDataKey'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  requestId?: string(name='RequestId'),
}

model ExportDataKeyResponse = {
  headers: map[string]string(name='headers'),
  body: ExportDataKeyResponseBody(name='body'),
}

async function exportDataKey(request: ExportDataKeyRequest): ExportDataKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportDataKey', 'POST', '/', 'json', false, 'json', request);
}

model GenerateAndExportDataKeyRequest {
  encryptionContext?: map[string]any(name='EncryptionContext', position='Query'),
  keyId: string(name='KeyId', position='Query'),
  keySpec?: string(name='KeySpec', position='Query'),
  numberOfBytes?: int32(name='NumberOfBytes', minimum=0, maximum=1024, position='Query'),
  publicKeyBlob: string(name='PublicKeyBlob', position='Query'),
  wrappingAlgorithm: string(name='WrappingAlgorithm', position='Query'),
  wrappingKeySpec: string(name='WrappingKeySpec', position='Query'),
}

model GenerateAndExportDataKeyResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob'),
  exportedDataKey?: string(name='ExportedDataKey'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  requestId?: string(name='RequestId'),
}

model GenerateAndExportDataKeyResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateAndExportDataKeyResponseBody(name='body'),
}

async function generateAndExportDataKey(request: GenerateAndExportDataKeyRequest): GenerateAndExportDataKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GenerateAndExportDataKey', 'POST', '/', 'json', false, 'json', request);
}

model GenerateDataKeyRequest {
  encryptionContext?: map[string]any(name='EncryptionContext', position='Query'),
  keyId: string(name='KeyId', position='Query'),
  keySpec?: string(name='KeySpec', position='Query'),
  numberOfBytes?: int32(name='NumberOfBytes', minimum=0, maximum=1024, position='Query'),
}

model GenerateDataKeyResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  plaintext?: string(name='Plaintext'),
  requestId?: string(name='RequestId'),
}

model GenerateDataKeyResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateDataKeyResponseBody(name='body'),
}

async function generateDataKey(request: GenerateDataKeyRequest): GenerateDataKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GenerateDataKey', 'POST', '/', 'json', false, 'json', request);
}

model GenerateDataKeyWithoutPlaintextRequest {
  encryptionContext?: map[string]any(name='EncryptionContext', position='Query'),
  keyId: string(name='KeyId', position='Query'),
  keySpec?: string(name='KeySpec', position='Query'),
  numberOfBytes?: int32(name='NumberOfBytes', minimum=0, maximum=1024, position='Query'),
}

model GenerateDataKeyWithoutPlaintextResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  requestId?: string(name='RequestId'),
}

model GenerateDataKeyWithoutPlaintextResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateDataKeyWithoutPlaintextResponseBody(name='body'),
}

async function generateDataKeyWithoutPlaintext(request: GenerateDataKeyWithoutPlaintextRequest): GenerateDataKeyWithoutPlaintextResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GenerateDataKeyWithoutPlaintext', 'POST', '/', 'json', false, 'json', request);
}

model GetCertificateRequest {
  certificateId: string(name='CertificateId', position='Query'),
}

model GetCertificateResponseBody = {
  certificate?: string(name='Certificate'),
  certificateChain?: string(name='CertificateChain'),
  certificateId?: string(name='CertificateId'),
  csr?: string(name='Csr'),
  requestId?: string(name='RequestId'),
}

model GetCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: GetCertificateResponseBody(name='body'),
}

async function getCertificate(request: GetCertificateRequest): GetCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetCertificate', 'POST', '/', 'json', false, 'json', request);
}

model GetParametersForImportRequest {
  keyId: string(name='KeyId', position='Query'),
  wrappingAlgorithm: string(name='WrappingAlgorithm', position='Query'),
  wrappingKeySpec: string(name='WrappingKeySpec', position='Query'),
}

model GetParametersForImportResponseBody = {
  importToken?: string(name='ImportToken'),
  keyId?: string(name='KeyId'),
  publicKey?: string(name='PublicKey'),
  requestId?: string(name='RequestId'),
  tokenExpireTime?: string(name='TokenExpireTime'),
}

model GetParametersForImportResponse = {
  headers: map[string]string(name='headers'),
  body: GetParametersForImportResponseBody(name='body'),
}

async function getParametersForImport(request: GetParametersForImportRequest): GetParametersForImportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetParametersForImport', 'POST', '/', 'json', false, 'json', request);
}

model GetPublicKeyRequest {
  keyId: string(name='KeyId', position='Query'),
  keyVersionId: string(name='KeyVersionId', position='Query'),
}

model GetPublicKeyResponseBody = {
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  publicKey?: string(name='PublicKey'),
  requestId?: string(name='RequestId'),
}

model GetPublicKeyResponse = {
  headers: map[string]string(name='headers'),
  body: GetPublicKeyResponseBody(name='body'),
}

async function getPublicKey(request: GetPublicKeyRequest): GetPublicKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPublicKey', 'POST', '/', 'json', false, 'json', request);
}

model GetRandomPasswordRequest {
  excludeCharacters?: string(name='ExcludeCharacters', position='Query'),
  excludeLowercase?: string(name='ExcludeLowercase', position='Query'),
  excludeNumbers?: string(name='ExcludeNumbers', position='Query'),
  excludePunctuation?: string(name='ExcludePunctuation', position='Query'),
  excludeUppercase?: string(name='ExcludeUppercase', position='Query'),
  passwordLength?: string(name='PasswordLength', position='Query'),
  requireEachIncludedType?: string(name='RequireEachIncludedType', position='Query'),
}

model GetRandomPasswordResponseBody = {
  randomPassword?: string(name='RandomPassword'),
  requestId?: string(name='RequestId'),
}

model GetRandomPasswordResponse = {
  headers: map[string]string(name='headers'),
  body: GetRandomPasswordResponseBody(name='body'),
}

async function getRandomPassword(request: GetRandomPasswordRequest): GetRandomPasswordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetRandomPassword', 'POST', '/', 'json', false, 'json', request);
}

model GetSecretValueRequest {
  fetchExtendedConfig?: boolean(name='FetchExtendedConfig', position='Query'),
  secretName: string(name='SecretName', position='Query'),
  versionId?: string(name='VersionId', position='Query'),
  versionStage?: string(name='VersionStage', position='Query'),
}

model GetSecretValueResponseBody = {
  automaticRotation?: string(name='AutomaticRotation'),
  createTime?: string(name='CreateTime'),
  extendedConfig?: string(name='ExtendedConfig'),
  lastRotationDate?: string(name='LastRotationDate'),
  nextRotationDate?: string(name='NextRotationDate'),
  requestId?: string(name='RequestId'),
  rotationInterval?: string(name='RotationInterval'),
  secretData?: string(name='SecretData'),
  secretDataType?: string(name='SecretDataType'),
  secretName?: string(name='SecretName'),
  secretType?: string(name='SecretType'),
  versionId?: string(name='VersionId'),
  versionStages?: {
    versionStage?: [ string ](name='VersionStage')
  }(name='VersionStages'),
}

model GetSecretValueResponse = {
  headers: map[string]string(name='headers'),
  body: GetSecretValueResponseBody(name='body'),
}

async function getSecretValue(request: GetSecretValueRequest): GetSecretValueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSecretValue', 'POST', '/', 'json', false, 'json', request);
}

model ImportCertificateRequest {
  PKCS12Blob: string(name='PKCS12Blob', position='Query'),
  passphrase: string(name='Passphrase', position='Query'),
}

model ImportCertificateResponseBody = {
  arn?: string(name='Arn'),
  certificateId?: string(name='CertificateId'),
  requestId?: string(name='RequestId'),
}

model ImportCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: ImportCertificateResponseBody(name='body'),
}

async function importCertificate(request: ImportCertificateRequest): ImportCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportCertificate', 'POST', '/', 'json', false, 'json', request);
}

model ImportEncryptionCertificateRequest {
  asymmetricAlgorithm: string(name='AsymmetricAlgorithm', position='Query'),
  certificate: string(name='Certificate', position='Query'),
  certificateChain?: string(name='CertificateChain', position='Query'),
  certificateId: string(name='CertificateId', position='Query'),
  encryptedPrivateKey: string(name='EncryptedPrivateKey', position='Query'),
  encryptedSymmetricKey: string(name='EncryptedSymmetricKey', position='Query'),
  symmetricAlgorithm: string(name='SymmetricAlgorithm', position='Query'),
}

model ImportEncryptionCertificateResponseBody = {
  arn?: string(name='Arn'),
  certificateId?: string(name='CertificateId'),
  requestId?: string(name='RequestId'),
}

model ImportEncryptionCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: ImportEncryptionCertificateResponseBody(name='body'),
}

async function importEncryptionCertificate(request: ImportEncryptionCertificateRequest): ImportEncryptionCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportEncryptionCertificate', 'POST', '/', 'json', false, 'json', request);
}

model ImportKeyMaterialRequest {
  encryptedKeyMaterial: string(name='EncryptedKeyMaterial', position='Query'),
  importToken: string(name='ImportToken', position='Query'),
  keyId: string(name='KeyId', position='Query'),
  keyMaterialExpireUnix: long(name='KeyMaterialExpireUnix', position='Query'),
}

model ImportKeyMaterialResponseBody = {
  requestId?: string(name='RequestId'),
}

model ImportKeyMaterialResponse = {
  headers: map[string]string(name='headers'),
  body: ImportKeyMaterialResponseBody(name='body'),
}

async function importKeyMaterial(request: ImportKeyMaterialRequest): ImportKeyMaterialResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportKeyMaterial', 'POST', '/', 'json', false, 'json', request);
}

model ListAliasesRequest {
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListAliasesResponseBody = {
  aliases?: {
    alias?: [ 
    {
      aliasArn?: string(name='AliasArn'),
      aliasName?: string(name='AliasName'),
      keyId?: string(name='KeyId'),
    }
  ](name='Alias')
  }(name='Aliases'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAliasesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAliasesResponseBody(name='body'),
}

async function listAliases(request: ListAliasesRequest): ListAliasesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAliases', 'POST', '/', 'json', false, 'json', request);
}

model ListAliasesByKeyIdRequest {
  keyId: string(name='KeyId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListAliasesByKeyIdResponseBody = {
  aliases?: {
    alias?: [ 
    {
      aliasArn?: string(name='AliasArn'),
      aliasName?: string(name='AliasName'),
      keyId?: string(name='KeyId'),
    }
  ](name='Alias')
  }(name='Aliases'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAliasesByKeyIdResponse = {
  headers: map[string]string(name='headers'),
  body: ListAliasesByKeyIdResponseBody(name='body'),
}

async function listAliasesByKeyId(request: ListAliasesByKeyIdRequest): ListAliasesByKeyIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAliasesByKeyId', 'POST', '/', 'json', false, 'json', request);
}

model ListCertificatesRequest {
  issuer?: string(name='Issuer', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=0, maximum=200, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  status?: string(name='Status', position='Query'),
  subject?: string(name='Subject', position='Query'),
}

model ListCertificatesResponseBody = {
  certificates?: {
    certificate?: [ 
    {
      certificateId?: string(name='CertificateId'),
    }
  ](name='Certificate')
  }(name='Certificates'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalSize?: int32(name='TotalSize'),
}

model ListCertificatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListCertificatesResponseBody(name='body'),
}

async function listCertificates(request: ListCertificatesRequest): ListCertificatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCertificates', 'POST', '/', 'json', false, 'json', request);
}

model ListKeyVersionsRequest {
  keyId: string(name='KeyId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListKeyVersionsResponseBody = {
  keyVersions?: {
    keyVersion?: [ 
    {
      creationDate?: string(name='CreationDate'),
      keyId?: string(name='KeyId'),
      keyVersionId?: string(name='KeyVersionId'),
    }
  ](name='KeyVersion')
  }(name='KeyVersions'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListKeyVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListKeyVersionsResponseBody(name='body'),
}

async function listKeyVersions(request: ListKeyVersionsRequest): ListKeyVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListKeyVersions', 'POST', '/', 'json', false, 'json', request);
}

model ListKeysRequest {
  filters?: string(name='Filters', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListKeysResponseBody = {
  keys?: {
    key?: [ 
    {
      keyArn?: string(name='KeyArn'),
      keyId?: string(name='KeyId'),
    }
  ](name='Key')
  }(name='Keys'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListKeysResponse = {
  headers: map[string]string(name='headers'),
  body: ListKeysResponseBody(name='body'),
}

async function listKeys(request: ListKeysRequest): ListKeysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListKeys', 'POST', '/', 'json', false, 'json', request);
}

model ListResourceTagsRequest {
  keyId: string(name='KeyId', position='Query'),
}

model ListResourceTagsResponseBody = {
  requestId?: string(name='RequestId'),
  tags?: {
    tag?: [ 
    {
      keyId?: string(name='KeyId'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Tag')
  }(name='Tags'),
}

model ListResourceTagsResponse = {
  headers: map[string]string(name='headers'),
  body: ListResourceTagsResponseBody(name='body'),
}

async function listResourceTags(request: ListResourceTagsRequest): ListResourceTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListResourceTags', 'POST', '/', 'json', false, 'json', request);
}

model ListSecretVersionIdsRequest {
  includeDeprecated?: string(name='IncludeDeprecated', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  secretName: string(name='SecretName', position='Query'),
}

model ListSecretVersionIdsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  secretName?: string(name='SecretName'),
  totalCount?: int32(name='TotalCount'),
  versionIds?: {
    versionId?: [ 
    {
      createTime?: string(name='CreateTime'),
      versionId?: string(name='VersionId'),
      versionStages?: {
        versionStage?: [ string ](name='VersionStage')
      }(name='VersionStages'),
    }
  ](name='VersionId')
  }(name='VersionIds'),
}

model ListSecretVersionIdsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecretVersionIdsResponseBody(name='body'),
}

async function listSecretVersionIds(request: ListSecretVersionIdsRequest): ListSecretVersionIdsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSecretVersionIds', 'POST', '/', 'json', false, 'json', request);
}

model ListSecretsRequest {
  fetchTags?: string(name='FetchTags', position='Query'),
  filters?: string(name='Filters', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
}

model ListSecretsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  secretList?: {
    secret?: [ 
    {
      createTime?: string(name='CreateTime'),
      plannedDeleteTime?: string(name='PlannedDeleteTime'),
      secretName?: string(name='SecretName'),
      secretType?: string(name='SecretType'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Secret')
  }(name='SecretList'),
  totalCount?: int32(name='TotalCount'),
}

model ListSecretsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecretsResponseBody(name='body'),
}

async function listSecrets(request: ListSecretsRequest): ListSecretsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSecrets', 'POST', '/', 'json', false, 'json', request);
}

model OpenKmsServiceRequest {
}

model OpenKmsServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model OpenKmsServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenKmsServiceResponseBody(name='body'),
}

async function openKmsService(request: OpenKmsServiceRequest): OpenKmsServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenKmsService', 'POST', '/', 'json', false, 'json', request);
}

model PutSecretValueRequest {
  secretData: string(name='SecretData', position='Query'),
  secretDataType?: string(name='SecretDataType', position='Query'),
  secretName: string(name='SecretName', position='Query'),
  versionId: string(name='VersionId', position='Query'),
  versionStages?: string(name='VersionStages', position='Query'),
}

model PutSecretValueResponseBody = {
  requestId?: string(name='RequestId'),
  secretName?: string(name='SecretName'),
  versionId?: string(name='VersionId'),
  versionStages?: {
    versionStage?: [ string ](name='VersionStage')
  }(name='VersionStages'),
}

model PutSecretValueResponse = {
  headers: map[string]string(name='headers'),
  body: PutSecretValueResponseBody(name='body'),
}

async function putSecretValue(request: PutSecretValueRequest): PutSecretValueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PutSecretValue', 'POST', '/', 'json', false, 'json', request);
}

model ReEncryptRequest {
  ciphertextBlob: string(name='CiphertextBlob', position='Query'),
  destinationEncryptionContext?: map[string]any(name='DestinationEncryptionContext', position='Query'),
  destinationKeyId: string(name='DestinationKeyId', position='Query'),
  sourceEncryptionAlgorithm?: string(name='SourceEncryptionAlgorithm', position='Query'),
  sourceEncryptionContext?: map[string]any(name='SourceEncryptionContext', position='Query'),
  sourceKeyId?: string(name='SourceKeyId', position='Query'),
  sourceKeyVersionId?: string(name='SourceKeyVersionId', position='Query'),
}

model ReEncryptResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  requestId?: string(name='RequestId'),
}

model ReEncryptResponse = {
  headers: map[string]string(name='headers'),
  body: ReEncryptResponseBody(name='body'),
}

async function reEncrypt(request: ReEncryptRequest): ReEncryptResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReEncrypt', 'POST', '/', 'json', false, 'json', request);
}

model RestoreSecretRequest {
  secretName: string(name='SecretName', position='Query'),
}

model RestoreSecretResponseBody = {
  requestId?: string(name='RequestId'),
  secretName?: string(name='SecretName'),
}

model RestoreSecretResponse = {
  headers: map[string]string(name='headers'),
  body: RestoreSecretResponseBody(name='body'),
}

async function restoreSecret(request: RestoreSecretRequest): RestoreSecretResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestoreSecret', 'POST', '/', 'json', false, 'json', request);
}

model RotateSecretRequest {
  secretName: string(name='SecretName', position='Query'),
  versionId: string(name='VersionId', position='Query'),
}

model RotateSecretResponseBody = {
  arn?: string(name='Arn'),
  requestId?: string(name='RequestId'),
  secretName?: string(name='SecretName'),
  versionId?: string(name='VersionId'),
}

model RotateSecretResponse = {
  headers: map[string]string(name='headers'),
  body: RotateSecretResponseBody(name='body'),
}

async function rotateSecret(request: RotateSecretRequest): RotateSecretResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RotateSecret', 'POST', '/', 'json', false, 'json', request);
}

model ScheduleKeyDeletionRequest {
  keyId: string(name='KeyId', position='Query'),
  pendingWindowInDays?: int32(name='PendingWindowInDays', position='Query'),
}

model ScheduleKeyDeletionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ScheduleKeyDeletionResponse = {
  headers: map[string]string(name='headers'),
  body: ScheduleKeyDeletionResponseBody(name='body'),
}

async function scheduleKeyDeletion(request: ScheduleKeyDeletionRequest): ScheduleKeyDeletionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ScheduleKeyDeletion', 'POST', '/', 'json', false, 'json', request);
}

model SetDeletionProtectionRequest {
  deletionProtectionDescription?: string(name='DeletionProtectionDescription', position='Query'),
  enableDeletionProtection: boolean(name='EnableDeletionProtection', position='Query'),
  protectedResourceArn: string(name='ProtectedResourceArn', position='Query'),
}

model SetDeletionProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetDeletionProtectionResponse = {
  headers: map[string]string(name='headers'),
  body: SetDeletionProtectionResponseBody(name='body'),
}

async function setDeletionProtection(request: SetDeletionProtectionRequest): SetDeletionProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDeletionProtection', 'POST', '/', 'json', false, 'json', request);
}

model TagResourceRequest {
  certificateId?: string(name='CertificateId', position='Query'),
  keyId?: string(name='KeyId', position='Query'),
  secretName?: string(name='SecretName', position='Query'),
  tags: string(name='Tags', position='Query'),
}

model TagResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourceResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourceResponseBody(name='body'),
}

async function tagResource(request: TagResourceRequest): TagResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResource', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourceRequest {
  certificateId?: string(name='CertificateId', position='Query'),
  keyId?: string(name='KeyId', position='Query'),
  secretName?: string(name='SecretName', position='Query'),
  tagKeys: string(name='TagKeys', position='Query'),
}

model UntagResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourceResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourceResponseBody(name='body'),
}

async function untagResource(request: UntagResourceRequest): UntagResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResource', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAliasRequest {
  aliasName: string(name='AliasName', position='Query'),
  keyId: string(name='KeyId', position='Query'),
}

model UpdateAliasResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAliasResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAliasResponseBody(name='body'),
}

async function updateAlias(request: UpdateAliasRequest): UpdateAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAlias', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCertificateStatusRequest {
  certificateId: string(name='CertificateId', position='Query'),
  status: string(name='Status', position='Query'),
}

model UpdateCertificateStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateCertificateStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCertificateStatusResponseBody(name='body'),
}

async function updateCertificateStatus(request: UpdateCertificateStatusRequest): UpdateCertificateStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCertificateStatus', 'POST', '/', 'json', false, 'json', request);
}

model UpdateKeyDescriptionRequest {
  description: string(name='Description', position='Query'),
  keyId: string(name='KeyId', position='Query'),
}

model UpdateKeyDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateKeyDescriptionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateKeyDescriptionResponseBody(name='body'),
}

async function updateKeyDescription(request: UpdateKeyDescriptionRequest): UpdateKeyDescriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateKeyDescription', 'POST', '/', 'json', false, 'json', request);
}

model UpdateRotationPolicyRequest {
  enableAutomaticRotation: boolean(name='EnableAutomaticRotation', position='Query'),
  keyId: string(name='KeyId', position='Query'),
  rotationInterval?: string(name='RotationInterval', position='Query'),
}

model UpdateRotationPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateRotationPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRotationPolicyResponseBody(name='body'),
}

async function updateRotationPolicy(request: UpdateRotationPolicyRequest): UpdateRotationPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateRotationPolicy', 'POST', '/', 'json', false, 'json', request);
}

model UpdateSecretRequest {
  extendedConfig?: {
    customData?: map[string]any(name='CustomData', position=''),
  }(name='ExtendedConfig'),
  description?: string(name='Description', position='Query'),
  secretName: string(name='SecretName', position='Query'),
}

model UpdateSecretResponseBody = {
  requestId?: string(name='RequestId'),
  secretName?: string(name='SecretName'),
}

model UpdateSecretResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSecretResponseBody(name='body'),
}

async function updateSecret(request: UpdateSecretRequest): UpdateSecretResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSecret', 'POST', '/', 'json', false, 'json', request);
}

model UpdateSecretRotationPolicyRequest {
  enableAutomaticRotation: boolean(name='EnableAutomaticRotation', position='Query'),
  rotationInterval?: string(name='RotationInterval', position='Query'),
  secretName: string(name='SecretName', position='Query'),
}

model UpdateSecretRotationPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  secretName?: string(name='SecretName'),
}

model UpdateSecretRotationPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSecretRotationPolicyResponseBody(name='body'),
}

async function updateSecretRotationPolicy(request: UpdateSecretRotationPolicyRequest): UpdateSecretRotationPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSecretRotationPolicy', 'POST', '/', 'json', false, 'json', request);
}

model UpdateSecretVersionStageRequest {
  moveToVersion?: string(name='MoveToVersion', position='Query'),
  removeFromVersion?: string(name='RemoveFromVersion', position='Query'),
  secretName: string(name='SecretName', position='Query'),
  versionStage: string(name='VersionStage', position='Query'),
}

model UpdateSecretVersionStageResponseBody = {
  requestId?: string(name='RequestId'),
  secretName?: string(name='SecretName'),
}

model UpdateSecretVersionStageResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSecretVersionStageResponseBody(name='body'),
}

async function updateSecretVersionStage(request: UpdateSecretVersionStageRequest): UpdateSecretVersionStageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSecretVersionStage', 'POST', '/', 'json', false, 'json', request);
}

model UploadCertificateRequest {
  certificate: string(name='Certificate', position='Query'),
  certificateChain?: string(name='CertificateChain', position='Query'),
  certificateId: string(name='CertificateId', position='Query'),
}

model UploadCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UploadCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: UploadCertificateResponseBody(name='body'),
}

async function uploadCertificate(request: UploadCertificateRequest): UploadCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UploadCertificate', 'POST', '/', 'json', false, 'json', request);
}

