/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('kms', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AsymmetricDecryptRequest {
  ciphertextBlob?: string(name='CiphertextBlob'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  algorithm?: string(name='Algorithm'),
}

model AsymmetricDecryptResponseBody = {
  requestId?: string(name='RequestId'),
  plaintext?: string(name='Plaintext'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model AsymmetricDecryptResponse = {
  headers: map[string]string(name='headers'),
  body: AsymmetricDecryptResponseBody(name='body'),
}

async function asymmetricDecryptWithOptions(request: AsymmetricDecryptRequest, runtime: Util.RuntimeOptions): AsymmetricDecryptResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AsymmetricDecrypt', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function asymmetricDecrypt(request: AsymmetricDecryptRequest): AsymmetricDecryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return asymmetricDecryptWithOptions(request, runtime);
}

model AsymmetricEncryptRequest {
  plaintext?: string(name='Plaintext'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  algorithm?: string(name='Algorithm'),
}

model AsymmetricEncryptResponseBody = {
  requestId?: string(name='RequestId'),
  ciphertextBlob?: string(name='CiphertextBlob'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model AsymmetricEncryptResponse = {
  headers: map[string]string(name='headers'),
  body: AsymmetricEncryptResponseBody(name='body'),
}

async function asymmetricEncryptWithOptions(request: AsymmetricEncryptRequest, runtime: Util.RuntimeOptions): AsymmetricEncryptResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AsymmetricEncrypt', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function asymmetricEncrypt(request: AsymmetricEncryptRequest): AsymmetricEncryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return asymmetricEncryptWithOptions(request, runtime);
}

model AsymmetricSignRequest {
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  algorithm?: string(name='Algorithm'),
  digest?: string(name='Digest'),
}

model AsymmetricSignResponseBody = {
  requestId?: string(name='RequestId'),
  value?: string(name='Value'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model AsymmetricSignResponse = {
  headers: map[string]string(name='headers'),
  body: AsymmetricSignResponseBody(name='body'),
}

async function asymmetricSignWithOptions(request: AsymmetricSignRequest, runtime: Util.RuntimeOptions): AsymmetricSignResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AsymmetricSign', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function asymmetricSign(request: AsymmetricSignRequest): AsymmetricSignResponse {
  var runtime = new Util.RuntimeOptions{};
  return asymmetricSignWithOptions(request, runtime);
}

model AsymmetricVerifyRequest {
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  algorithm?: string(name='Algorithm'),
  digest?: string(name='Digest'),
  value?: string(name='Value'),
}

model AsymmetricVerifyResponseBody = {
  requestId?: string(name='RequestId'),
  value?: boolean(name='Value'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model AsymmetricVerifyResponse = {
  headers: map[string]string(name='headers'),
  body: AsymmetricVerifyResponseBody(name='body'),
}

async function asymmetricVerifyWithOptions(request: AsymmetricVerifyRequest, runtime: Util.RuntimeOptions): AsymmetricVerifyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AsymmetricVerify', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function asymmetricVerify(request: AsymmetricVerifyRequest): AsymmetricVerifyResponse {
  var runtime = new Util.RuntimeOptions{};
  return asymmetricVerifyWithOptions(request, runtime);
}

model CancelKeyDeletionRequest {
  keyId?: string(name='KeyId'),
}

model CancelKeyDeletionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelKeyDeletionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelKeyDeletionResponseBody(name='body'),
}

async function cancelKeyDeletionWithOptions(request: CancelKeyDeletionRequest, runtime: Util.RuntimeOptions): CancelKeyDeletionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelKeyDeletion', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelKeyDeletion(request: CancelKeyDeletionRequest): CancelKeyDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelKeyDeletionWithOptions(request, runtime);
}

model CertificatePrivateKeyDecryptRequest {
  certificateId?: string(name='CertificateId'),
  algorithm?: string(name='Algorithm'),
  ciphertextBlob?: string(name='CiphertextBlob'),
}

model CertificatePrivateKeyDecryptResponseBody = {
  requestId?: string(name='RequestId'),
  certificateId?: string(name='CertificateId'),
  plaintext?: string(name='Plaintext'),
}

model CertificatePrivateKeyDecryptResponse = {
  headers: map[string]string(name='headers'),
  body: CertificatePrivateKeyDecryptResponseBody(name='body'),
}

async function certificatePrivateKeyDecryptWithOptions(request: CertificatePrivateKeyDecryptRequest, runtime: Util.RuntimeOptions): CertificatePrivateKeyDecryptResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CertificatePrivateKeyDecrypt', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function certificatePrivateKeyDecrypt(request: CertificatePrivateKeyDecryptRequest): CertificatePrivateKeyDecryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return certificatePrivateKeyDecryptWithOptions(request, runtime);
}

model CertificatePrivateKeySignRequest {
  certificateId?: string(name='CertificateId'),
  algorithm?: string(name='Algorithm'),
  messageType?: string(name='MessageType'),
  message?: string(name='Message'),
}

model CertificatePrivateKeySignResponseBody = {
  signatureValue?: string(name='SignatureValue'),
  requestId?: string(name='RequestId'),
  certificateId?: string(name='CertificateId'),
}

model CertificatePrivateKeySignResponse = {
  headers: map[string]string(name='headers'),
  body: CertificatePrivateKeySignResponseBody(name='body'),
}

async function certificatePrivateKeySignWithOptions(request: CertificatePrivateKeySignRequest, runtime: Util.RuntimeOptions): CertificatePrivateKeySignResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CertificatePrivateKeySign', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function certificatePrivateKeySign(request: CertificatePrivateKeySignRequest): CertificatePrivateKeySignResponse {
  var runtime = new Util.RuntimeOptions{};
  return certificatePrivateKeySignWithOptions(request, runtime);
}

model CertificatePublicKeyEncryptRequest {
  certificateId?: string(name='CertificateId'),
  algorithm?: string(name='Algorithm'),
  plaintext?: string(name='Plaintext'),
}

model CertificatePublicKeyEncryptResponseBody = {
  requestId?: string(name='RequestId'),
  ciphertextBlob?: string(name='CiphertextBlob'),
  certificateId?: string(name='CertificateId'),
}

model CertificatePublicKeyEncryptResponse = {
  headers: map[string]string(name='headers'),
  body: CertificatePublicKeyEncryptResponseBody(name='body'),
}

async function certificatePublicKeyEncryptWithOptions(request: CertificatePublicKeyEncryptRequest, runtime: Util.RuntimeOptions): CertificatePublicKeyEncryptResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CertificatePublicKeyEncrypt', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function certificatePublicKeyEncrypt(request: CertificatePublicKeyEncryptRequest): CertificatePublicKeyEncryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return certificatePublicKeyEncryptWithOptions(request, runtime);
}

model CertificatePublicKeyVerifyRequest {
  certificateId?: string(name='CertificateId'),
  algorithm?: string(name='Algorithm'),
  message?: string(name='Message'),
  messageType?: string(name='MessageType'),
  signatureValue?: string(name='SignatureValue'),
}

model CertificatePublicKeyVerifyResponseBody = {
  requestId?: string(name='RequestId'),
  certificateId?: string(name='CertificateId'),
  signatureValid?: boolean(name='SignatureValid'),
}

model CertificatePublicKeyVerifyResponse = {
  headers: map[string]string(name='headers'),
  body: CertificatePublicKeyVerifyResponseBody(name='body'),
}

async function certificatePublicKeyVerifyWithOptions(request: CertificatePublicKeyVerifyRequest, runtime: Util.RuntimeOptions): CertificatePublicKeyVerifyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CertificatePublicKeyVerify', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function certificatePublicKeyVerify(request: CertificatePublicKeyVerifyRequest): CertificatePublicKeyVerifyResponse {
  var runtime = new Util.RuntimeOptions{};
  return certificatePublicKeyVerifyWithOptions(request, runtime);
}

model CreateAliasRequest {
  keyId?: string(name='KeyId'),
  aliasName?: string(name='AliasName'),
}

model CreateAliasResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateAliasResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAliasResponseBody(name='body'),
}

async function createAliasWithOptions(request: CreateAliasRequest, runtime: Util.RuntimeOptions): CreateAliasResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateAlias', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createAlias(request: CreateAliasRequest): CreateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAliasWithOptions(request, runtime);
}

model CreateCertificateRequest {
  subject?: string(name='Subject'),
  subjectAlternativeNames?: map[string]any(name='SubjectAlternativeNames'),
  keySpec?: string(name='KeySpec'),
  protectionLevel?: string(name='ProtectionLevel'),
}

model CreateCertificateShrinkRequest {
  subject?: string(name='Subject'),
  subjectAlternativeNamesShrink?: string(name='SubjectAlternativeNames'),
  keySpec?: string(name='KeySpec'),
  protectionLevel?: string(name='ProtectionLevel'),
}

model CreateCertificateResponseBody = {
  csr?: string(name='Csr'),
  requestId?: string(name='RequestId'),
  certificateId?: string(name='CertificateId'),
  arn?: string(name='Arn'),
}

model CreateCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCertificateResponseBody(name='body'),
}

async function createCertificateWithOptions(tmpReq: CreateCertificateRequest, runtime: Util.RuntimeOptions): CreateCertificateResponse {
  Util.validateModel(tmpReq);
  var request = new CreateCertificateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.subjectAlternativeNames)) {
    request.subjectAlternativeNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.subjectAlternativeNames, 'SubjectAlternativeNames', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateCertificate', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createCertificate(request: CreateCertificateRequest): CreateCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCertificateWithOptions(request, runtime);
}

model CreateKeyRequest {
  description?: string(name='Description'),
  keyUsage?: string(name='KeyUsage'),
  origin?: string(name='Origin'),
  protectionLevel?: string(name='ProtectionLevel'),
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation'),
  rotationInterval?: string(name='RotationInterval'),
  keySpec?: string(name='KeySpec'),
}

model CreateKeyResponseBody = {
  requestId?: string(name='RequestId'),
  keyMetadata?: {
    keyId?: string(name='KeyId'),
    nextRotationDate?: string(name='NextRotationDate'),
    keyState?: string(name='KeyState'),
    rotationInterval?: string(name='RotationInterval'),
    arn?: string(name='Arn'),
    creator?: string(name='Creator'),
    deleteDate?: string(name='DeleteDate'),
    lastRotationDate?: string(name='LastRotationDate'),
    description?: string(name='Description'),
    primaryKeyVersion?: string(name='PrimaryKeyVersion'),
    origin?: string(name='Origin'),
    keySpec?: string(name='KeySpec'),
    materialExpireTime?: string(name='MaterialExpireTime'),
    automaticRotation?: string(name='AutomaticRotation'),
    protectionLevel?: string(name='ProtectionLevel'),
    keyUsage?: string(name='KeyUsage'),
    creationDate?: string(name='CreationDate'),
  }(name='KeyMetadata'),
}

model CreateKeyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateKeyResponseBody(name='body'),
}

async function createKeyWithOptions(request: CreateKeyRequest, runtime: Util.RuntimeOptions): CreateKeyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateKey', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createKey(request: CreateKeyRequest): CreateKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createKeyWithOptions(request, runtime);
}

model CreateKeyVersionRequest {
  keyId?: string(name='KeyId'),
}

model CreateKeyVersionResponseBody = {
  requestId?: string(name='RequestId'),
  keyVersion?: {
    keyVersionId?: string(name='KeyVersionId'),
    keyId?: string(name='KeyId'),
    creationDate?: string(name='CreationDate'),
  }(name='KeyVersion'),
}

model CreateKeyVersionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateKeyVersionResponseBody(name='body'),
}

async function createKeyVersionWithOptions(request: CreateKeyVersionRequest, runtime: Util.RuntimeOptions): CreateKeyVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateKeyVersion', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createKeyVersion(request: CreateKeyVersionRequest): CreateKeyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createKeyVersionWithOptions(request, runtime);
}

model CreateSecretRequest {
  secretName?: string(name='SecretName'),
  versionId?: string(name='VersionId'),
  encryptionKeyId?: string(name='EncryptionKeyId'),
  secretData?: string(name='SecretData'),
  secretDataType?: string(name='SecretDataType'),
  description?: string(name='Description'),
  tags?: string(name='Tags'),
  secretType?: string(name='SecretType'),
  extendedConfig?: map[string]any(name='ExtendedConfig'),
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation'),
  rotationInterval?: string(name='RotationInterval'),
}

model CreateSecretShrinkRequest {
  secretName?: string(name='SecretName'),
  versionId?: string(name='VersionId'),
  encryptionKeyId?: string(name='EncryptionKeyId'),
  secretData?: string(name='SecretData'),
  secretDataType?: string(name='SecretDataType'),
  description?: string(name='Description'),
  tags?: string(name='Tags'),
  secretType?: string(name='SecretType'),
  extendedConfigShrink?: string(name='ExtendedConfig'),
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation'),
  rotationInterval?: string(name='RotationInterval'),
}

model CreateSecretResponseBody = {
  secretName?: string(name='SecretName'),
  versionId?: string(name='VersionId'),
  nextRotationDate?: string(name='NextRotationDate'),
  requestId?: string(name='RequestId'),
  secretType?: string(name='SecretType'),
  rotationInterval?: string(name='RotationInterval'),
  extendedConfig?: string(name='ExtendedConfig'),
  arn?: string(name='Arn'),
  automaticRotation?: string(name='AutomaticRotation'),
}

model CreateSecretResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSecretResponseBody(name='body'),
}

async function createSecretWithOptions(tmpReq: CreateSecretRequest, runtime: Util.RuntimeOptions): CreateSecretResponse {
  Util.validateModel(tmpReq);
  var request = new CreateSecretShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.extendedConfig)) {
    request.extendedConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extendedConfig, 'ExtendedConfig', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateSecret', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createSecret(request: CreateSecretRequest): CreateSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSecretWithOptions(request, runtime);
}

model DecryptRequest {
  ciphertextBlob?: string(name='CiphertextBlob'),
  encryptionContext?: map[string]any(name='EncryptionContext'),
}

model DecryptShrinkRequest {
  ciphertextBlob?: string(name='CiphertextBlob'),
  encryptionContextShrink?: string(name='EncryptionContext'),
}

model DecryptResponseBody = {
  requestId?: string(name='RequestId'),
  plaintext?: string(name='Plaintext'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model DecryptResponse = {
  headers: map[string]string(name='headers'),
  body: DecryptResponseBody(name='body'),
}

async function decryptWithOptions(tmpReq: DecryptRequest, runtime: Util.RuntimeOptions): DecryptResponse {
  Util.validateModel(tmpReq);
  var request = new DecryptShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('Decrypt', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function decrypt(request: DecryptRequest): DecryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return decryptWithOptions(request, runtime);
}

model DeleteAliasRequest {
  aliasName?: string(name='AliasName'),
}

model DeleteAliasResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAliasResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAliasResponseBody(name='body'),
}

async function deleteAliasWithOptions(request: DeleteAliasRequest, runtime: Util.RuntimeOptions): DeleteAliasResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteAlias', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteAlias(request: DeleteAliasRequest): DeleteAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAliasWithOptions(request, runtime);
}

model DeleteCertificateRequest {
  certificateId?: string(name='CertificateId'),
}

model DeleteCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCertificateResponseBody(name='body'),
}

async function deleteCertificateWithOptions(request: DeleteCertificateRequest, runtime: Util.RuntimeOptions): DeleteCertificateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteCertificate', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteCertificate(request: DeleteCertificateRequest): DeleteCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCertificateWithOptions(request, runtime);
}

model DeleteKeyMaterialRequest {
  keyId?: string(name='KeyId'),
}

model DeleteKeyMaterialResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteKeyMaterialResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteKeyMaterialResponseBody(name='body'),
}

async function deleteKeyMaterialWithOptions(request: DeleteKeyMaterialRequest, runtime: Util.RuntimeOptions): DeleteKeyMaterialResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteKeyMaterial', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteKeyMaterial(request: DeleteKeyMaterialRequest): DeleteKeyMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteKeyMaterialWithOptions(request, runtime);
}

model DeleteSecretRequest {
  secretName?: string(name='SecretName'),
  forceDeleteWithoutRecovery?: string(name='ForceDeleteWithoutRecovery'),
  recoveryWindowInDays?: string(name='RecoveryWindowInDays'),
}

model DeleteSecretResponseBody = {
  secretName?: string(name='SecretName'),
  requestId?: string(name='RequestId'),
  plannedDeleteTime?: string(name='PlannedDeleteTime'),
}

model DeleteSecretResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSecretResponseBody(name='body'),
}

async function deleteSecretWithOptions(request: DeleteSecretRequest, runtime: Util.RuntimeOptions): DeleteSecretResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSecret', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSecret(request: DeleteSecretRequest): DeleteSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecretWithOptions(request, runtime);
}

model DescribeAccountKmsStatusResponseBody = {
  accountStatus?: string(name='AccountStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeAccountKmsStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccountKmsStatusResponseBody(name='body'),
}

async function describeAccountKmsStatusWithOptions(runtime: Util.RuntimeOptions): DescribeAccountKmsStatusResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('DescribeAccountKmsStatus', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeAccountKmsStatus(): DescribeAccountKmsStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccountKmsStatusWithOptions(runtime);
}

model DescribeCertificateRequest {
  certificateId?: string(name='CertificateId'),
}

model DescribeCertificateResponseBody = {
  status?: string(name='Status'),
  protectionLevel?: string(name='ProtectionLevel'),
  requestId?: string(name='RequestId'),
  issuer?: string(name='Issuer'),
  certificateId?: string(name='CertificateId'),
  createdAt?: string(name='CreatedAt'),
  keySpec?: string(name='KeySpec'),
  subjectAlternativeNames?: [ string ](name='SubjectAlternativeNames'),
  signatureAlgorithm?: string(name='SignatureAlgorithm'),
  subjectKeyIdentifier?: string(name='SubjectKeyIdentifier'),
  notAfter?: string(name='NotAfter'),
  updatedAt?: string(name='UpdatedAt'),
  subject?: string(name='Subject'),
  serial?: string(name='Serial'),
  subjectPublicKey?: string(name='SubjectPublicKey'),
  arn?: string(name='Arn'),
  notBefore?: string(name='NotBefore'),
  tags?: map[string]any(name='Tags'),
}

model DescribeCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCertificateResponseBody(name='body'),
}

async function describeCertificateWithOptions(request: DescribeCertificateRequest, runtime: Util.RuntimeOptions): DescribeCertificateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeCertificate', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeCertificate(request: DescribeCertificateRequest): DescribeCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCertificateWithOptions(request, runtime);
}

model DescribeKeyRequest {
  keyId?: string(name='KeyId'),
}

model DescribeKeyResponseBody = {
  requestId?: string(name='RequestId'),
  keyMetadata?: {
    keyId?: string(name='KeyId'),
    nextRotationDate?: string(name='NextRotationDate'),
    keyState?: string(name='KeyState'),
    rotationInterval?: string(name='RotationInterval'),
    arn?: string(name='Arn'),
    creator?: string(name='Creator'),
    deleteDate?: string(name='DeleteDate'),
    lastRotationDate?: string(name='LastRotationDate'),
    description?: string(name='Description'),
    primaryKeyVersion?: string(name='PrimaryKeyVersion'),
    origin?: string(name='Origin'),
    keySpec?: string(name='KeySpec'),
    materialExpireTime?: string(name='MaterialExpireTime'),
    automaticRotation?: string(name='AutomaticRotation'),
    protectionLevel?: string(name='ProtectionLevel'),
    keyUsage?: string(name='KeyUsage'),
    creationDate?: string(name='CreationDate'),
  }(name='KeyMetadata'),
}

model DescribeKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeKeyResponseBody(name='body'),
}

async function describeKeyWithOptions(request: DescribeKeyRequest, runtime: Util.RuntimeOptions): DescribeKeyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeKey', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeKey(request: DescribeKeyRequest): DescribeKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeKeyWithOptions(request, runtime);
}

model DescribeKeyVersionRequest {
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model DescribeKeyVersionResponseBody = {
  requestId?: string(name='RequestId'),
  keyVersion?: {
    keyVersionId?: string(name='KeyVersionId'),
    keyId?: string(name='KeyId'),
    creationDate?: string(name='CreationDate'),
  }(name='KeyVersion'),
}

model DescribeKeyVersionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeKeyVersionResponseBody(name='body'),
}

async function describeKeyVersionWithOptions(request: DescribeKeyVersionRequest, runtime: Util.RuntimeOptions): DescribeKeyVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeKeyVersion', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeKeyVersion(request: DescribeKeyVersionRequest): DescribeKeyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeKeyVersionWithOptions(request, runtime);
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  regions?: {
    region?: [ 
    {
      regionId?: string(name='RegionId'),
    }
  ](name='Region')
  }(name='Regions'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('DescribeRegions', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(runtime);
}

model DescribeSecretRequest {
  secretName?: string(name='SecretName'),
  fetchTags?: string(name='FetchTags'),
}

model DescribeSecretResponseBody = {
  description?: string(name='Description'),
  rotationInterval?: string(name='RotationInterval'),
  lastRotationDate?: string(name='LastRotationDate'),
  requestId?: string(name='RequestId'),
  secretType?: string(name='SecretType'),
  createTime?: string(name='CreateTime'),
  automaticRotation?: string(name='AutomaticRotation'),
  secretName?: string(name='SecretName'),
  nextRotationDate?: string(name='NextRotationDate'),
  updateTime?: string(name='UpdateTime'),
  extendedConfig?: string(name='ExtendedConfig'),
  plannedDeleteTime?: string(name='PlannedDeleteTime'),
  arn?: string(name='Arn'),
  tags?: {
    tag?: [ 
    {
      tagValue?: string(name='TagValue'),
      tagKey?: string(name='TagKey'),
    }
  ](name='Tag')
  }(name='Tags'),
  encryptionKeyId?: string(name='EncryptionKeyId'),
}

model DescribeSecretResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecretResponseBody(name='body'),
}

async function describeSecretWithOptions(request: DescribeSecretRequest, runtime: Util.RuntimeOptions): DescribeSecretResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSecret', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSecret(request: DescribeSecretRequest): DescribeSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecretWithOptions(request, runtime);
}

model DescribeServiceResponseBody = {
  protectionLevels?: {
    protectionLevel?: [ 
    {
      type?: string(name='Type'),
    }
  ](name='ProtectionLevel')
  }(name='ProtectionLevels'),
  requestId?: string(name='RequestId'),
  keySpecs?: {
    keySpec?: [ 
    {
      supportedProtectionLevels?: {
        supportedProtectionLevel?: [ string ](name='SupportedProtectionLevel')
      }(name='SupportedProtectionLevels'),
      name?: string(name='Name'),
      usages?: {
        usage?: [ string ](name='Usage')
      }(name='Usages'),
    }
  ](name='KeySpec')
  }(name='KeySpecs'),
}

model DescribeServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServiceResponseBody(name='body'),
}

async function describeServiceWithOptions(runtime: Util.RuntimeOptions): DescribeServiceResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('DescribeService', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeService(): DescribeServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServiceWithOptions(runtime);
}

model DisableKeyRequest {
  keyId?: string(name='KeyId'),
}

model DisableKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DisableKeyResponseBody(name='body'),
}

async function disableKeyWithOptions(request: DisableKeyRequest, runtime: Util.RuntimeOptions): DisableKeyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableKey', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableKey(request: DisableKeyRequest): DisableKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableKeyWithOptions(request, runtime);
}

model EnableKeyRequest {
  keyId?: string(name='KeyId'),
}

model EnableKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableKeyResponse = {
  headers: map[string]string(name='headers'),
  body: EnableKeyResponseBody(name='body'),
}

async function enableKeyWithOptions(request: EnableKeyRequest, runtime: Util.RuntimeOptions): EnableKeyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableKey', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableKey(request: EnableKeyRequest): EnableKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableKeyWithOptions(request, runtime);
}

model EncryptRequest {
  keyId?: string(name='KeyId'),
  plaintext?: string(name='Plaintext'),
  encryptionContext?: map[string]any(name='EncryptionContext'),
}

model EncryptShrinkRequest {
  keyId?: string(name='KeyId'),
  plaintext?: string(name='Plaintext'),
  encryptionContextShrink?: string(name='EncryptionContext'),
}

model EncryptResponseBody = {
  requestId?: string(name='RequestId'),
  ciphertextBlob?: string(name='CiphertextBlob'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model EncryptResponse = {
  headers: map[string]string(name='headers'),
  body: EncryptResponseBody(name='body'),
}

async function encryptWithOptions(tmpReq: EncryptRequest, runtime: Util.RuntimeOptions): EncryptResponse {
  Util.validateModel(tmpReq);
  var request = new EncryptShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('Encrypt', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function encrypt(request: EncryptRequest): EncryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return encryptWithOptions(request, runtime);
}

model ExportCertificateRequest {
  certificateId?: string(name='CertificateId'),
  passphrase?: string(name='Passphrase'),
  exportFormat?: string(name='ExportFormat'),
}

model ExportCertificateResponseBody = {
  privateKey?: string(name='PrivateKey'),
  requestId?: string(name='RequestId'),
  certificateId?: string(name='CertificateId'),
  certificateChain?: string(name='CertificateChain'),
  PKCS12Blob?: string(name='PKCS12Blob'),
  certificate?: string(name='Certificate'),
}

model ExportCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: ExportCertificateResponseBody(name='body'),
}

async function exportCertificateWithOptions(request: ExportCertificateRequest, runtime: Util.RuntimeOptions): ExportCertificateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ExportCertificate', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function exportCertificate(request: ExportCertificateRequest): ExportCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportCertificateWithOptions(request, runtime);
}

model ExportDataKeyRequest {
  ciphertextBlob?: string(name='CiphertextBlob'),
  encryptionContext?: map[string]any(name='EncryptionContext'),
  publicKeyBlob?: string(name='PublicKeyBlob'),
  wrappingKeySpec?: string(name='WrappingKeySpec'),
  wrappingAlgorithm?: string(name='WrappingAlgorithm'),
}

model ExportDataKeyShrinkRequest {
  ciphertextBlob?: string(name='CiphertextBlob'),
  encryptionContextShrink?: string(name='EncryptionContext'),
  publicKeyBlob?: string(name='PublicKeyBlob'),
  wrappingKeySpec?: string(name='WrappingKeySpec'),
  wrappingAlgorithm?: string(name='WrappingAlgorithm'),
}

model ExportDataKeyResponseBody = {
  requestId?: string(name='RequestId'),
  exportedDataKey?: string(name='ExportedDataKey'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model ExportDataKeyResponse = {
  headers: map[string]string(name='headers'),
  body: ExportDataKeyResponseBody(name='body'),
}

async function exportDataKeyWithOptions(tmpReq: ExportDataKeyRequest, runtime: Util.RuntimeOptions): ExportDataKeyResponse {
  Util.validateModel(tmpReq);
  var request = new ExportDataKeyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ExportDataKey', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function exportDataKey(request: ExportDataKeyRequest): ExportDataKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportDataKeyWithOptions(request, runtime);
}

model GenerateAndExportDataKeyRequest {
  keyId?: string(name='KeyId'),
  keySpec?: string(name='KeySpec'),
  numberOfBytes?: int32(name='NumberOfBytes'),
  encryptionContext?: map[string]any(name='EncryptionContext'),
  publicKeyBlob?: string(name='PublicKeyBlob'),
  wrappingKeySpec?: string(name='WrappingKeySpec'),
  wrappingAlgorithm?: string(name='WrappingAlgorithm'),
}

model GenerateAndExportDataKeyShrinkRequest {
  keyId?: string(name='KeyId'),
  keySpec?: string(name='KeySpec'),
  numberOfBytes?: int32(name='NumberOfBytes'),
  encryptionContextShrink?: string(name='EncryptionContext'),
  publicKeyBlob?: string(name='PublicKeyBlob'),
  wrappingKeySpec?: string(name='WrappingKeySpec'),
  wrappingAlgorithm?: string(name='WrappingAlgorithm'),
}

model GenerateAndExportDataKeyResponseBody = {
  requestId?: string(name='RequestId'),
  ciphertextBlob?: string(name='CiphertextBlob'),
  exportedDataKey?: string(name='ExportedDataKey'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model GenerateAndExportDataKeyResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateAndExportDataKeyResponseBody(name='body'),
}

async function generateAndExportDataKeyWithOptions(tmpReq: GenerateAndExportDataKeyRequest, runtime: Util.RuntimeOptions): GenerateAndExportDataKeyResponse {
  Util.validateModel(tmpReq);
  var request = new GenerateAndExportDataKeyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GenerateAndExportDataKey', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function generateAndExportDataKey(request: GenerateAndExportDataKeyRequest): GenerateAndExportDataKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateAndExportDataKeyWithOptions(request, runtime);
}

model GenerateDataKeyRequest {
  keyId?: string(name='KeyId'),
  keySpec?: string(name='KeySpec'),
  numberOfBytes?: int32(name='NumberOfBytes'),
  encryptionContext?: map[string]any(name='EncryptionContext'),
}

model GenerateDataKeyShrinkRequest {
  keyId?: string(name='KeyId'),
  keySpec?: string(name='KeySpec'),
  numberOfBytes?: int32(name='NumberOfBytes'),
  encryptionContextShrink?: string(name='EncryptionContext'),
}

model GenerateDataKeyResponseBody = {
  requestId?: string(name='RequestId'),
  ciphertextBlob?: string(name='CiphertextBlob'),
  plaintext?: string(name='Plaintext'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model GenerateDataKeyResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateDataKeyResponseBody(name='body'),
}

async function generateDataKeyWithOptions(tmpReq: GenerateDataKeyRequest, runtime: Util.RuntimeOptions): GenerateDataKeyResponse {
  Util.validateModel(tmpReq);
  var request = new GenerateDataKeyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GenerateDataKey', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function generateDataKey(request: GenerateDataKeyRequest): GenerateDataKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateDataKeyWithOptions(request, runtime);
}

model GenerateDataKeyWithoutPlaintextRequest {
  keyId?: string(name='KeyId'),
  keySpec?: string(name='KeySpec'),
  numberOfBytes?: int32(name='NumberOfBytes'),
  encryptionContext?: map[string]any(name='EncryptionContext'),
}

model GenerateDataKeyWithoutPlaintextShrinkRequest {
  keyId?: string(name='KeyId'),
  keySpec?: string(name='KeySpec'),
  numberOfBytes?: int32(name='NumberOfBytes'),
  encryptionContextShrink?: string(name='EncryptionContext'),
}

model GenerateDataKeyWithoutPlaintextResponseBody = {
  requestId?: string(name='RequestId'),
  ciphertextBlob?: string(name='CiphertextBlob'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model GenerateDataKeyWithoutPlaintextResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateDataKeyWithoutPlaintextResponseBody(name='body'),
}

async function generateDataKeyWithoutPlaintextWithOptions(tmpReq: GenerateDataKeyWithoutPlaintextRequest, runtime: Util.RuntimeOptions): GenerateDataKeyWithoutPlaintextResponse {
  Util.validateModel(tmpReq);
  var request = new GenerateDataKeyWithoutPlaintextShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GenerateDataKeyWithoutPlaintext', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function generateDataKeyWithoutPlaintext(request: GenerateDataKeyWithoutPlaintextRequest): GenerateDataKeyWithoutPlaintextResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateDataKeyWithoutPlaintextWithOptions(request, runtime);
}

model GetCertificateRequest {
  certificateId?: string(name='CertificateId'),
}

model GetCertificateResponseBody = {
  csr?: string(name='Csr'),
  requestId?: string(name='RequestId'),
  certificateId?: string(name='CertificateId'),
  certificateChain?: string(name='CertificateChain'),
  certificate?: string(name='Certificate'),
}

model GetCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: GetCertificateResponseBody(name='body'),
}

async function getCertificateWithOptions(request: GetCertificateRequest, runtime: Util.RuntimeOptions): GetCertificateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetCertificate', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getCertificate(request: GetCertificateRequest): GetCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCertificateWithOptions(request, runtime);
}

model GetParametersForImportRequest {
  keyId?: string(name='KeyId'),
  wrappingAlgorithm?: string(name='WrappingAlgorithm'),
  wrappingKeySpec?: string(name='WrappingKeySpec'),
}

model GetParametersForImportResponseBody = {
  requestId?: string(name='RequestId'),
  publicKey?: string(name='PublicKey'),
  keyId?: string(name='KeyId'),
  tokenExpireTime?: string(name='TokenExpireTime'),
  importToken?: string(name='ImportToken'),
}

model GetParametersForImportResponse = {
  headers: map[string]string(name='headers'),
  body: GetParametersForImportResponseBody(name='body'),
}

async function getParametersForImportWithOptions(request: GetParametersForImportRequest, runtime: Util.RuntimeOptions): GetParametersForImportResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetParametersForImport', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getParametersForImport(request: GetParametersForImportRequest): GetParametersForImportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getParametersForImportWithOptions(request, runtime);
}

model GetPublicKeyRequest {
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model GetPublicKeyResponseBody = {
  requestId?: string(name='RequestId'),
  publicKey?: string(name='PublicKey'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model GetPublicKeyResponse = {
  headers: map[string]string(name='headers'),
  body: GetPublicKeyResponseBody(name='body'),
}

async function getPublicKeyWithOptions(request: GetPublicKeyRequest, runtime: Util.RuntimeOptions): GetPublicKeyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetPublicKey', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getPublicKey(request: GetPublicKeyRequest): GetPublicKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPublicKeyWithOptions(request, runtime);
}

model GetRandomPasswordRequest {
  passwordLength?: string(name='PasswordLength'),
  excludeCharacters?: string(name='ExcludeCharacters'),
  excludeLowercase?: string(name='ExcludeLowercase'),
  excludeUppercase?: string(name='ExcludeUppercase'),
  excludeNumbers?: string(name='ExcludeNumbers'),
  excludePunctuation?: string(name='ExcludePunctuation'),
  requireEachIncludedType?: string(name='RequireEachIncludedType'),
}

model GetRandomPasswordResponseBody = {
  randomPassword?: string(name='RandomPassword'),
  requestId?: string(name='RequestId'),
}

model GetRandomPasswordResponse = {
  headers: map[string]string(name='headers'),
  body: GetRandomPasswordResponseBody(name='body'),
}

async function getRandomPasswordWithOptions(request: GetRandomPasswordRequest, runtime: Util.RuntimeOptions): GetRandomPasswordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetRandomPassword', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getRandomPassword(request: GetRandomPasswordRequest): GetRandomPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRandomPasswordWithOptions(request, runtime);
}

model GetSecretValueRequest {
  secretName?: string(name='SecretName'),
  versionStage?: string(name='VersionStage'),
  versionId?: string(name='VersionId'),
  fetchExtendedConfig?: boolean(name='FetchExtendedConfig'),
}

model GetSecretValueResponseBody = {
  versionId?: string(name='VersionId'),
  rotationInterval?: string(name='RotationInterval'),
  lastRotationDate?: string(name='LastRotationDate'),
  requestId?: string(name='RequestId'),
  secretType?: string(name='SecretType'),
  createTime?: string(name='CreateTime'),
  secretDataType?: string(name='SecretDataType'),
  versionStages?: {
    versionStage?: [ string ](name='VersionStage')
  }(name='VersionStages'),
  automaticRotation?: string(name='AutomaticRotation'),
  secretName?: string(name='SecretName'),
  nextRotationDate?: string(name='NextRotationDate'),
  extendedConfig?: string(name='ExtendedConfig'),
  secretData?: string(name='SecretData'),
}

model GetSecretValueResponse = {
  headers: map[string]string(name='headers'),
  body: GetSecretValueResponseBody(name='body'),
}

async function getSecretValueWithOptions(request: GetSecretValueRequest, runtime: Util.RuntimeOptions): GetSecretValueResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetSecretValue', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getSecretValue(request: GetSecretValueRequest): GetSecretValueResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecretValueWithOptions(request, runtime);
}

model ImportCertificateRequest {
  PKCS12Blob?: string(name='PKCS12Blob'),
  passphrase?: string(name='Passphrase'),
}

model ImportCertificateResponseBody = {
  requestId?: string(name='RequestId'),
  certificateId?: string(name='CertificateId'),
  arn?: string(name='Arn'),
}

model ImportCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: ImportCertificateResponseBody(name='body'),
}

async function importCertificateWithOptions(request: ImportCertificateRequest, runtime: Util.RuntimeOptions): ImportCertificateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ImportCertificate', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function importCertificate(request: ImportCertificateRequest): ImportCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return importCertificateWithOptions(request, runtime);
}

model ImportEncryptionCertificateRequest {
  certificateId?: string(name='CertificateId'),
  encryptedSymmetricKey?: string(name='EncryptedSymmetricKey'),
  encryptedPrivateKey?: string(name='EncryptedPrivateKey'),
  symmetricAlgorithm?: string(name='SymmetricAlgorithm'),
  asymmetricAlgorithm?: string(name='AsymmetricAlgorithm'),
  certificate?: string(name='Certificate'),
  certificateChain?: string(name='CertificateChain'),
}

model ImportEncryptionCertificateResponseBody = {
  requestId?: string(name='RequestId'),
  certificateId?: string(name='CertificateId'),
  arn?: string(name='Arn'),
}

model ImportEncryptionCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: ImportEncryptionCertificateResponseBody(name='body'),
}

async function importEncryptionCertificateWithOptions(request: ImportEncryptionCertificateRequest, runtime: Util.RuntimeOptions): ImportEncryptionCertificateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ImportEncryptionCertificate', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function importEncryptionCertificate(request: ImportEncryptionCertificateRequest): ImportEncryptionCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return importEncryptionCertificateWithOptions(request, runtime);
}

model ImportKeyMaterialRequest {
  keyId?: string(name='KeyId'),
  encryptedKeyMaterial?: string(name='EncryptedKeyMaterial'),
  importToken?: string(name='ImportToken'),
  keyMaterialExpireUnix?: long(name='KeyMaterialExpireUnix'),
}

model ImportKeyMaterialResponseBody = {
  requestId?: string(name='RequestId'),
}

model ImportKeyMaterialResponse = {
  headers: map[string]string(name='headers'),
  body: ImportKeyMaterialResponseBody(name='body'),
}

async function importKeyMaterialWithOptions(request: ImportKeyMaterialRequest, runtime: Util.RuntimeOptions): ImportKeyMaterialResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ImportKeyMaterial', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function importKeyMaterial(request: ImportKeyMaterialRequest): ImportKeyMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return importKeyMaterialWithOptions(request, runtime);
}

model ListAliasesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListAliasesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  aliases?: {
    alias?: [ 
    {
      aliasArn?: string(name='AliasArn'),
      keyId?: string(name='KeyId'),
      aliasName?: string(name='AliasName'),
    }
  ](name='Alias')
  }(name='Aliases'),
}

model ListAliasesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAliasesResponseBody(name='body'),
}

async function listAliasesWithOptions(request: ListAliasesRequest, runtime: Util.RuntimeOptions): ListAliasesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListAliases', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listAliases(request: ListAliasesRequest): ListAliasesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAliasesWithOptions(request, runtime);
}

model ListAliasesByKeyIdRequest {
  keyId?: string(name='KeyId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListAliasesByKeyIdResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  aliases?: {
    alias?: [ 
    {
      aliasArn?: string(name='AliasArn'),
      keyId?: string(name='KeyId'),
      aliasName?: string(name='AliasName'),
    }
  ](name='Alias')
  }(name='Aliases'),
}

model ListAliasesByKeyIdResponse = {
  headers: map[string]string(name='headers'),
  body: ListAliasesByKeyIdResponseBody(name='body'),
}

async function listAliasesByKeyIdWithOptions(request: ListAliasesByKeyIdRequest, runtime: Util.RuntimeOptions): ListAliasesByKeyIdResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListAliasesByKeyId', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listAliasesByKeyId(request: ListAliasesByKeyIdRequest): ListAliasesByKeyIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAliasesByKeyIdWithOptions(request, runtime);
}

model ListCertificatesRequest {
  subject?: string(name='Subject'),
  issuer?: string(name='Issuer'),
  status?: string(name='Status'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListCertificatesResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  certificateSummaryList?: {
    certificateSummary?: [ 
    {
      status?: string(name='Status'),
      keySpec?: string(name='KeySpec'),
      subject?: string(name='Subject'),
      protectionLevel?: string(name='ProtectionLevel'),
      issuer?: string(name='Issuer'),
      notBefore?: string(name='NotBefore'),
      notAfter?: string(name='NotAfter'),
      certificateId?: string(name='CertificateId'),
    }
  ](name='CertificateSummary')
  }(name='CertificateSummaryList'),
  totalSize?: int32(name='TotalSize'),
}

model ListCertificatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListCertificatesResponseBody(name='body'),
}

async function listCertificatesWithOptions(request: ListCertificatesRequest, runtime: Util.RuntimeOptions): ListCertificatesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListCertificates', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listCertificates(request: ListCertificatesRequest): ListCertificatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCertificatesWithOptions(request, runtime);
}

model ListKeysRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  filters?: string(name='Filters'),
}

model ListKeysResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  keys?: {
    key?: [ 
    {
      keyArn?: string(name='KeyArn'),
      keyId?: string(name='KeyId'),
    }
  ](name='Key')
  }(name='Keys'),
}

model ListKeysResponse = {
  headers: map[string]string(name='headers'),
  body: ListKeysResponseBody(name='body'),
}

async function listKeysWithOptions(request: ListKeysRequest, runtime: Util.RuntimeOptions): ListKeysResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListKeys', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listKeys(request: ListKeysRequest): ListKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listKeysWithOptions(request, runtime);
}

model ListKeyVersionsRequest {
  keyId?: string(name='KeyId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListKeyVersionsResponseBody = {
  keyVersions?: {
    keyVersion?: [ 
    {
      keyVersionId?: string(name='KeyVersionId'),
      keyId?: string(name='KeyId'),
      creationDate?: string(name='CreationDate'),
    }
  ](name='KeyVersion')
  }(name='KeyVersions'),
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model ListKeyVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListKeyVersionsResponseBody(name='body'),
}

async function listKeyVersionsWithOptions(request: ListKeyVersionsRequest, runtime: Util.RuntimeOptions): ListKeyVersionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListKeyVersions', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listKeyVersions(request: ListKeyVersionsRequest): ListKeyVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listKeyVersionsWithOptions(request, runtime);
}

model ListResourceTagsRequest {
  keyId?: string(name='KeyId'),
}

model ListResourceTagsResponseBody = {
  requestId?: string(name='RequestId'),
  tags?: {
    tag?: [ 
    {
      keyId?: string(name='KeyId'),
      tagValue?: string(name='TagValue'),
      tagKey?: string(name='TagKey'),
    }
  ](name='Tag')
  }(name='Tags'),
}

model ListResourceTagsResponse = {
  headers: map[string]string(name='headers'),
  body: ListResourceTagsResponseBody(name='body'),
}

async function listResourceTagsWithOptions(request: ListResourceTagsRequest, runtime: Util.RuntimeOptions): ListResourceTagsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListResourceTags', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listResourceTags(request: ListResourceTagsRequest): ListResourceTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceTagsWithOptions(request, runtime);
}

model ListSecretsRequest {
  fetchTags?: string(name='FetchTags'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  filters?: string(name='Filters'),
}

model ListSecretsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  secretList?: {
    secret?: [ 
    {
      updateTime?: string(name='UpdateTime'),
      createTime?: string(name='CreateTime'),
      secretName?: string(name='SecretName'),
      tags?: {
        tag?: [ 
        {
          tagValue?: string(name='TagValue'),
          tagKey?: string(name='TagKey'),
        }
      ](name='Tag')
      }(name='Tags'),
      secretType?: string(name='SecretType'),
      plannedDeleteTime?: string(name='PlannedDeleteTime'),
    }
  ](name='Secret')
  }(name='SecretList'),
  pageNumber?: int32(name='PageNumber'),
}

model ListSecretsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecretsResponseBody(name='body'),
}

async function listSecretsWithOptions(request: ListSecretsRequest, runtime: Util.RuntimeOptions): ListSecretsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListSecrets', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listSecrets(request: ListSecretsRequest): ListSecretsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecretsWithOptions(request, runtime);
}

model ListSecretVersionIdsRequest {
  secretName?: string(name='SecretName'),
  includeDeprecated?: string(name='IncludeDeprecated'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListSecretVersionIdsResponseBody = {
  secretName?: string(name='SecretName'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  versionIds?: {
    versionId?: [ 
    {
      createTime?: string(name='CreateTime'),
      versionId?: string(name='VersionId'),
      versionStages?: {
        versionStage?: [ string ](name='VersionStage')
      }(name='VersionStages'),
    }
  ](name='VersionId')
  }(name='VersionIds'),
}

model ListSecretVersionIdsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecretVersionIdsResponseBody(name='body'),
}

async function listSecretVersionIdsWithOptions(request: ListSecretVersionIdsRequest, runtime: Util.RuntimeOptions): ListSecretVersionIdsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListSecretVersionIds', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listSecretVersionIds(request: ListSecretVersionIdsRequest): ListSecretVersionIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecretVersionIdsWithOptions(request, runtime);
}

model OpenKmsServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model OpenKmsServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenKmsServiceResponseBody(name='body'),
}

async function openKmsServiceWithOptions(runtime: Util.RuntimeOptions): OpenKmsServiceResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('OpenKmsService', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function openKmsService(): OpenKmsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openKmsServiceWithOptions(runtime);
}

model PutSecretValueRequest {
  versionId?: string(name='VersionId'),
  secretName?: string(name='SecretName'),
  secretData?: string(name='SecretData'),
  secretDataType?: string(name='SecretDataType'),
  versionStages?: string(name='VersionStages'),
}

model PutSecretValueResponseBody = {
  secretName?: string(name='SecretName'),
  versionId?: string(name='VersionId'),
  requestId?: string(name='RequestId'),
  versionStages?: {
    versionStage?: [ string ](name='VersionStage')
  }(name='VersionStages'),
}

model PutSecretValueResponse = {
  headers: map[string]string(name='headers'),
  body: PutSecretValueResponseBody(name='body'),
}

async function putSecretValueWithOptions(request: PutSecretValueRequest, runtime: Util.RuntimeOptions): PutSecretValueResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutSecretValue', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putSecretValue(request: PutSecretValueRequest): PutSecretValueResponse {
  var runtime = new Util.RuntimeOptions{};
  return putSecretValueWithOptions(request, runtime);
}

model ReEncryptRequest {
  ciphertextBlob?: string(name='CiphertextBlob'),
  sourceKeyId?: string(name='SourceKeyId'),
  sourceKeyVersionId?: string(name='SourceKeyVersionId'),
  sourceEncryptionAlgorithm?: string(name='SourceEncryptionAlgorithm'),
  sourceEncryptionContext?: map[string]any(name='SourceEncryptionContext'),
  destinationKeyId?: string(name='DestinationKeyId'),
  destinationEncryptionContext?: map[string]any(name='DestinationEncryptionContext'),
}

model ReEncryptShrinkRequest {
  ciphertextBlob?: string(name='CiphertextBlob'),
  sourceKeyId?: string(name='SourceKeyId'),
  sourceKeyVersionId?: string(name='SourceKeyVersionId'),
  sourceEncryptionAlgorithm?: string(name='SourceEncryptionAlgorithm'),
  sourceEncryptionContextShrink?: string(name='SourceEncryptionContext'),
  destinationKeyId?: string(name='DestinationKeyId'),
  destinationEncryptionContextShrink?: string(name='DestinationEncryptionContext'),
}

model ReEncryptResponseBody = {
  requestId?: string(name='RequestId'),
  ciphertextBlob?: string(name='CiphertextBlob'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model ReEncryptResponse = {
  headers: map[string]string(name='headers'),
  body: ReEncryptResponseBody(name='body'),
}

async function reEncryptWithOptions(tmpReq: ReEncryptRequest, runtime: Util.RuntimeOptions): ReEncryptResponse {
  Util.validateModel(tmpReq);
  var request = new ReEncryptShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.sourceEncryptionContext)) {
    request.sourceEncryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceEncryptionContext, 'SourceEncryptionContext', 'json');
  }
  if (!Util.isUnset(tmpReq.destinationEncryptionContext)) {
    request.destinationEncryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.destinationEncryptionContext, 'DestinationEncryptionContext', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReEncrypt', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function reEncrypt(request: ReEncryptRequest): ReEncryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return reEncryptWithOptions(request, runtime);
}

model RestoreSecretRequest {
  secretName?: string(name='SecretName'),
}

model RestoreSecretResponseBody = {
  secretName?: string(name='SecretName'),
  requestId?: string(name='RequestId'),
}

model RestoreSecretResponse = {
  headers: map[string]string(name='headers'),
  body: RestoreSecretResponseBody(name='body'),
}

async function restoreSecretWithOptions(request: RestoreSecretRequest, runtime: Util.RuntimeOptions): RestoreSecretResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RestoreSecret', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function restoreSecret(request: RestoreSecretRequest): RestoreSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return restoreSecretWithOptions(request, runtime);
}

model RotateSecretRequest {
  secretName?: string(name='SecretName'),
  versionId?: string(name='VersionId'),
}

model RotateSecretResponseBody = {
  versionId?: string(name='VersionId'),
  secretName?: string(name='SecretName'),
  requestId?: string(name='RequestId'),
  arn?: string(name='Arn'),
}

model RotateSecretResponse = {
  headers: map[string]string(name='headers'),
  body: RotateSecretResponseBody(name='body'),
}

async function rotateSecretWithOptions(request: RotateSecretRequest, runtime: Util.RuntimeOptions): RotateSecretResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RotateSecret', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function rotateSecret(request: RotateSecretRequest): RotateSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return rotateSecretWithOptions(request, runtime);
}

model ScheduleKeyDeletionRequest {
  keyId?: string(name='KeyId'),
  pendingWindowInDays?: int32(name='PendingWindowInDays'),
}

model ScheduleKeyDeletionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ScheduleKeyDeletionResponse = {
  headers: map[string]string(name='headers'),
  body: ScheduleKeyDeletionResponseBody(name='body'),
}

async function scheduleKeyDeletionWithOptions(request: ScheduleKeyDeletionRequest, runtime: Util.RuntimeOptions): ScheduleKeyDeletionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ScheduleKeyDeletion', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function scheduleKeyDeletion(request: ScheduleKeyDeletionRequest): ScheduleKeyDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  return scheduleKeyDeletionWithOptions(request, runtime);
}

model TagResourceRequest {
  keyId?: string(name='KeyId'),
  tags?: string(name='Tags'),
  secretName?: string(name='SecretName'),
  certificateId?: string(name='CertificateId'),
}

model TagResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourceResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourceResponseBody(name='body'),
}

async function tagResourceWithOptions(request: TagResourceRequest, runtime: Util.RuntimeOptions): TagResourceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TagResource', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function tagResource(request: TagResourceRequest): TagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourceWithOptions(request, runtime);
}

model UntagResourceRequest {
  keyId?: string(name='KeyId'),
  tagKeys?: string(name='TagKeys'),
  secretName?: string(name='SecretName'),
  certificateId?: string(name='CertificateId'),
}

model UntagResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourceResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourceResponseBody(name='body'),
}

async function untagResourceWithOptions(request: UntagResourceRequest, runtime: Util.RuntimeOptions): UntagResourceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UntagResource', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function untagResource(request: UntagResourceRequest): UntagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourceWithOptions(request, runtime);
}

model UpdateAliasRequest {
  keyId?: string(name='KeyId'),
  aliasName?: string(name='AliasName'),
}

model UpdateAliasResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAliasResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAliasResponseBody(name='body'),
}

async function updateAliasWithOptions(request: UpdateAliasRequest, runtime: Util.RuntimeOptions): UpdateAliasResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateAlias', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateAlias(request: UpdateAliasRequest): UpdateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAliasWithOptions(request, runtime);
}

model UpdateCertificateStatusRequest {
  certificateId?: string(name='CertificateId'),
  status?: string(name='Status'),
}

model UpdateCertificateStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateCertificateStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCertificateStatusResponseBody(name='body'),
}

async function updateCertificateStatusWithOptions(request: UpdateCertificateStatusRequest, runtime: Util.RuntimeOptions): UpdateCertificateStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateCertificateStatus', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateCertificateStatus(request: UpdateCertificateStatusRequest): UpdateCertificateStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCertificateStatusWithOptions(request, runtime);
}

model UpdateKeyDescriptionRequest {
  keyId?: string(name='KeyId'),
  description?: string(name='Description'),
}

model UpdateKeyDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateKeyDescriptionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateKeyDescriptionResponseBody(name='body'),
}

async function updateKeyDescriptionWithOptions(request: UpdateKeyDescriptionRequest, runtime: Util.RuntimeOptions): UpdateKeyDescriptionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateKeyDescription', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateKeyDescription(request: UpdateKeyDescriptionRequest): UpdateKeyDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateKeyDescriptionWithOptions(request, runtime);
}

model UpdateRotationPolicyRequest {
  keyId?: string(name='KeyId'),
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation'),
  rotationInterval?: string(name='RotationInterval'),
}

model UpdateRotationPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateRotationPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRotationPolicyResponseBody(name='body'),
}

async function updateRotationPolicyWithOptions(request: UpdateRotationPolicyRequest, runtime: Util.RuntimeOptions): UpdateRotationPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateRotationPolicy', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateRotationPolicy(request: UpdateRotationPolicyRequest): UpdateRotationPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRotationPolicyWithOptions(request, runtime);
}

model UpdateSecretRotationPolicyRequest {
  secretName?: string(name='SecretName'),
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation'),
  rotationInterval?: string(name='RotationInterval'),
}

model UpdateSecretRotationPolicyResponseBody = {
  secretName?: string(name='SecretName'),
  requestId?: string(name='RequestId'),
}

model UpdateSecretRotationPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSecretRotationPolicyResponseBody(name='body'),
}

async function updateSecretRotationPolicyWithOptions(request: UpdateSecretRotationPolicyRequest, runtime: Util.RuntimeOptions): UpdateSecretRotationPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateSecretRotationPolicy', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateSecretRotationPolicy(request: UpdateSecretRotationPolicyRequest): UpdateSecretRotationPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSecretRotationPolicyWithOptions(request, runtime);
}

model UpdateSecretVersionStageRequest {
  secretName?: string(name='SecretName'),
  versionStage?: string(name='VersionStage'),
  removeFromVersion?: string(name='RemoveFromVersion'),
  moveToVersion?: string(name='MoveToVersion'),
}

model UpdateSecretVersionStageResponseBody = {
  secretName?: string(name='SecretName'),
  requestId?: string(name='RequestId'),
}

model UpdateSecretVersionStageResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSecretVersionStageResponseBody(name='body'),
}

async function updateSecretVersionStageWithOptions(request: UpdateSecretVersionStageRequest, runtime: Util.RuntimeOptions): UpdateSecretVersionStageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateSecretVersionStage', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateSecretVersionStage(request: UpdateSecretVersionStageRequest): UpdateSecretVersionStageResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSecretVersionStageWithOptions(request, runtime);
}

model UploadCertificateRequest {
  certificateId?: string(name='CertificateId'),
  certificate?: string(name='Certificate'),
  certificateChain?: string(name='CertificateChain'),
}

model UploadCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UploadCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: UploadCertificateResponseBody(name='body'),
}

async function uploadCertificateWithOptions(request: UploadCertificateRequest, runtime: Util.RuntimeOptions): UploadCertificateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UploadCertificate', '2016-01-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function uploadCertificate(request: UploadCertificateRequest): UploadCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadCertificateWithOptions(request, runtime);
}

