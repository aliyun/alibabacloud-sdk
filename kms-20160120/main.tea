/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('kms', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AsymmetricDecryptRequest {
  algorithm?: string(name='Algorithm'),
  ciphertextBlob?: string(name='CiphertextBlob'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model AsymmetricDecryptResponseBody = {
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  plaintext?: string(name='Plaintext'),
  requestId?: string(name='RequestId'),
}

model AsymmetricDecryptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AsymmetricDecryptResponseBody(name='body'),
}

async function asymmetricDecryptWithOptions(request: AsymmetricDecryptRequest, runtime: Util.RuntimeOptions): AsymmetricDecryptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.ciphertextBlob)) {
    query['CiphertextBlob'] = request.ciphertextBlob;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keyVersionId)) {
    query['KeyVersionId'] = request.keyVersionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AsymmetricDecrypt',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function asymmetricDecrypt(request: AsymmetricDecryptRequest): AsymmetricDecryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return asymmetricDecryptWithOptions(request, runtime);
}

model AsymmetricEncryptRequest {
  algorithm?: string(name='Algorithm'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  plaintext?: string(name='Plaintext'),
}

model AsymmetricEncryptResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  requestId?: string(name='RequestId'),
}

model AsymmetricEncryptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AsymmetricEncryptResponseBody(name='body'),
}

async function asymmetricEncryptWithOptions(request: AsymmetricEncryptRequest, runtime: Util.RuntimeOptions): AsymmetricEncryptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keyVersionId)) {
    query['KeyVersionId'] = request.keyVersionId;
  }
  if (!Util.isUnset(request.plaintext)) {
    query['Plaintext'] = request.plaintext;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AsymmetricEncrypt',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function asymmetricEncrypt(request: AsymmetricEncryptRequest): AsymmetricEncryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return asymmetricEncryptWithOptions(request, runtime);
}

model AsymmetricSignRequest {
  algorithm?: string(name='Algorithm'),
  digest?: string(name='Digest'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model AsymmetricSignResponseBody = {
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  requestId?: string(name='RequestId'),
  value?: string(name='Value'),
}

model AsymmetricSignResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AsymmetricSignResponseBody(name='body'),
}

async function asymmetricSignWithOptions(request: AsymmetricSignRequest, runtime: Util.RuntimeOptions): AsymmetricSignResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keyVersionId)) {
    query['KeyVersionId'] = request.keyVersionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AsymmetricSign',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function asymmetricSign(request: AsymmetricSignRequest): AsymmetricSignResponse {
  var runtime = new Util.RuntimeOptions{};
  return asymmetricSignWithOptions(request, runtime);
}

model AsymmetricVerifyRequest {
  algorithm?: string(name='Algorithm'),
  digest?: string(name='Digest'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  value?: string(name='Value'),
}

model AsymmetricVerifyResponseBody = {
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  requestId?: string(name='RequestId'),
  value?: boolean(name='Value'),
}

model AsymmetricVerifyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AsymmetricVerifyResponseBody(name='body'),
}

async function asymmetricVerifyWithOptions(request: AsymmetricVerifyRequest, runtime: Util.RuntimeOptions): AsymmetricVerifyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keyVersionId)) {
    query['KeyVersionId'] = request.keyVersionId;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AsymmetricVerify',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function asymmetricVerify(request: AsymmetricVerifyRequest): AsymmetricVerifyResponse {
  var runtime = new Util.RuntimeOptions{};
  return asymmetricVerifyWithOptions(request, runtime);
}

model CancelKeyDeletionRequest {
  keyId?: string(name='KeyId'),
}

model CancelKeyDeletionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelKeyDeletionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelKeyDeletionResponseBody(name='body'),
}

async function cancelKeyDeletionWithOptions(request: CancelKeyDeletionRequest, runtime: Util.RuntimeOptions): CancelKeyDeletionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelKeyDeletion',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelKeyDeletion(request: CancelKeyDeletionRequest): CancelKeyDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelKeyDeletionWithOptions(request, runtime);
}

model CertificatePrivateKeyDecryptRequest {
  algorithm?: string(name='Algorithm'),
  certificateId?: string(name='CertificateId'),
  ciphertextBlob?: string(name='CiphertextBlob'),
}

model CertificatePrivateKeyDecryptResponseBody = {
  certificateId?: string(name='CertificateId'),
  plaintext?: string(name='Plaintext'),
  requestId?: string(name='RequestId'),
}

model CertificatePrivateKeyDecryptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CertificatePrivateKeyDecryptResponseBody(name='body'),
}

async function certificatePrivateKeyDecryptWithOptions(request: CertificatePrivateKeyDecryptRequest, runtime: Util.RuntimeOptions): CertificatePrivateKeyDecryptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.ciphertextBlob)) {
    query['CiphertextBlob'] = request.ciphertextBlob;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CertificatePrivateKeyDecrypt',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function certificatePrivateKeyDecrypt(request: CertificatePrivateKeyDecryptRequest): CertificatePrivateKeyDecryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return certificatePrivateKeyDecryptWithOptions(request, runtime);
}

model CertificatePrivateKeySignRequest {
  algorithm?: string(name='Algorithm'),
  certificateId?: string(name='CertificateId'),
  message?: string(name='Message'),
  messageType?: string(name='MessageType'),
}

model CertificatePrivateKeySignResponseBody = {
  certificateId?: string(name='CertificateId'),
  requestId?: string(name='RequestId'),
  signatureValue?: string(name='SignatureValue'),
}

model CertificatePrivateKeySignResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CertificatePrivateKeySignResponseBody(name='body'),
}

async function certificatePrivateKeySignWithOptions(request: CertificatePrivateKeySignRequest, runtime: Util.RuntimeOptions): CertificatePrivateKeySignResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  if (!Util.isUnset(request.messageType)) {
    query['MessageType'] = request.messageType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CertificatePrivateKeySign',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function certificatePrivateKeySign(request: CertificatePrivateKeySignRequest): CertificatePrivateKeySignResponse {
  var runtime = new Util.RuntimeOptions{};
  return certificatePrivateKeySignWithOptions(request, runtime);
}

model CertificatePublicKeyEncryptRequest {
  algorithm?: string(name='Algorithm'),
  certificateId?: string(name='CertificateId'),
  plaintext?: string(name='Plaintext'),
}

model CertificatePublicKeyEncryptResponseBody = {
  certificateId?: string(name='CertificateId'),
  ciphertextBlob?: string(name='CiphertextBlob'),
  requestId?: string(name='RequestId'),
}

model CertificatePublicKeyEncryptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CertificatePublicKeyEncryptResponseBody(name='body'),
}

async function certificatePublicKeyEncryptWithOptions(request: CertificatePublicKeyEncryptRequest, runtime: Util.RuntimeOptions): CertificatePublicKeyEncryptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.plaintext)) {
    query['Plaintext'] = request.plaintext;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CertificatePublicKeyEncrypt',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function certificatePublicKeyEncrypt(request: CertificatePublicKeyEncryptRequest): CertificatePublicKeyEncryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return certificatePublicKeyEncryptWithOptions(request, runtime);
}

model CertificatePublicKeyVerifyRequest {
  algorithm?: string(name='Algorithm'),
  certificateId?: string(name='CertificateId'),
  message?: string(name='Message'),
  messageType?: string(name='MessageType'),
  signatureValue?: string(name='SignatureValue'),
}

model CertificatePublicKeyVerifyResponseBody = {
  certificateId?: string(name='CertificateId'),
  requestId?: string(name='RequestId'),
  signatureValid?: boolean(name='SignatureValid'),
}

model CertificatePublicKeyVerifyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CertificatePublicKeyVerifyResponseBody(name='body'),
}

async function certificatePublicKeyVerifyWithOptions(request: CertificatePublicKeyVerifyRequest, runtime: Util.RuntimeOptions): CertificatePublicKeyVerifyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  if (!Util.isUnset(request.messageType)) {
    query['MessageType'] = request.messageType;
  }
  if (!Util.isUnset(request.signatureValue)) {
    query['SignatureValue'] = request.signatureValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CertificatePublicKeyVerify',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function certificatePublicKeyVerify(request: CertificatePublicKeyVerifyRequest): CertificatePublicKeyVerifyResponse {
  var runtime = new Util.RuntimeOptions{};
  return certificatePublicKeyVerifyWithOptions(request, runtime);
}

model CreateAliasRequest {
  aliasName?: string(name='AliasName'),
  keyId?: string(name='KeyId'),
}

model CreateAliasResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAliasResponseBody(name='body'),
}

async function createAliasWithOptions(request: CreateAliasRequest, runtime: Util.RuntimeOptions): CreateAliasResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlias',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAlias(request: CreateAliasRequest): CreateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAliasWithOptions(request, runtime);
}

model CreateCertificateRequest {
  exportablePrivateKey?: boolean(name='ExportablePrivateKey'),
  keySpec?: string(name='KeySpec'),
  subject?: string(name='Subject'),
  subjectAlternativeNames?: map[string]any(name='SubjectAlternativeNames'),
}

model CreateCertificateShrinkRequest {
  exportablePrivateKey?: boolean(name='ExportablePrivateKey'),
  keySpec?: string(name='KeySpec'),
  subject?: string(name='Subject'),
  subjectAlternativeNamesShrink?: string(name='SubjectAlternativeNames'),
}

model CreateCertificateResponseBody = {
  arn?: string(name='Arn'),
  certificateId?: string(name='CertificateId'),
  csr?: string(name='Csr'),
  requestId?: string(name='RequestId'),
}

model CreateCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCertificateResponseBody(name='body'),
}

async function createCertificateWithOptions(tmpReq: CreateCertificateRequest, runtime: Util.RuntimeOptions): CreateCertificateResponse {
  Util.validateModel(tmpReq);
  var request = new CreateCertificateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.subjectAlternativeNames)) {
    request.subjectAlternativeNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.subjectAlternativeNames, 'SubjectAlternativeNames', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.exportablePrivateKey)) {
    query['ExportablePrivateKey'] = request.exportablePrivateKey;
  }
  if (!Util.isUnset(request.keySpec)) {
    query['KeySpec'] = request.keySpec;
  }
  if (!Util.isUnset(request.subject)) {
    query['Subject'] = request.subject;
  }
  if (!Util.isUnset(request.subjectAlternativeNamesShrink)) {
    query['SubjectAlternativeNames'] = request.subjectAlternativeNamesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCertificate',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCertificate(request: CreateCertificateRequest): CreateCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCertificateWithOptions(request, runtime);
}

model CreateKeyRequest {
  DKMSInstanceId?: string(name='DKMSInstanceId'),
  description?: string(name='Description'),
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation'),
  keySpec?: string(name='KeySpec'),
  keyUsage?: string(name='KeyUsage'),
  origin?: string(name='Origin'),
  protectionLevel?: string(name='ProtectionLevel'),
  rotationInterval?: string(name='RotationInterval'),
}

model CreateKeyResponseBody = {
  keyMetadata?: {
    arn?: string(name='Arn'),
    automaticRotation?: string(name='AutomaticRotation'),
    creationDate?: string(name='CreationDate'),
    creator?: string(name='Creator'),
    DKMSInstanceId?: string(name='DKMSInstanceId'),
    deleteDate?: string(name='DeleteDate'),
    description?: string(name='Description'),
    keyId?: string(name='KeyId'),
    keySpec?: string(name='KeySpec'),
    keyState?: string(name='KeyState'),
    keyUsage?: string(name='KeyUsage'),
    lastRotationDate?: string(name='LastRotationDate'),
    materialExpireTime?: string(name='MaterialExpireTime'),
    nextRotationDate?: string(name='NextRotationDate'),
    origin?: string(name='Origin'),
    primaryKeyVersion?: string(name='PrimaryKeyVersion'),
    protectionLevel?: string(name='ProtectionLevel'),
    rotationInterval?: string(name='RotationInterval'),
  }(name='KeyMetadata'),
  requestId?: string(name='RequestId'),
}

model CreateKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateKeyResponseBody(name='body'),
}

async function createKeyWithOptions(request: CreateKeyRequest, runtime: Util.RuntimeOptions): CreateKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DKMSInstanceId)) {
    query['DKMSInstanceId'] = request.DKMSInstanceId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.enableAutomaticRotation)) {
    query['EnableAutomaticRotation'] = request.enableAutomaticRotation;
  }
  if (!Util.isUnset(request.keySpec)) {
    query['KeySpec'] = request.keySpec;
  }
  if (!Util.isUnset(request.keyUsage)) {
    query['KeyUsage'] = request.keyUsage;
  }
  if (!Util.isUnset(request.origin)) {
    query['Origin'] = request.origin;
  }
  if (!Util.isUnset(request.protectionLevel)) {
    query['ProtectionLevel'] = request.protectionLevel;
  }
  if (!Util.isUnset(request.rotationInterval)) {
    query['RotationInterval'] = request.rotationInterval;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateKey',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createKey(request: CreateKeyRequest): CreateKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createKeyWithOptions(request, runtime);
}

model CreateKeyVersionRequest {
  keyId?: string(name='KeyId'),
}

model CreateKeyVersionResponseBody = {
  keyVersion?: {
    creationDate?: string(name='CreationDate'),
    keyId?: string(name='KeyId'),
    keyVersionId?: string(name='KeyVersionId'),
  }(name='KeyVersion'),
  requestId?: string(name='RequestId'),
}

model CreateKeyVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateKeyVersionResponseBody(name='body'),
}

async function createKeyVersionWithOptions(request: CreateKeyVersionRequest, runtime: Util.RuntimeOptions): CreateKeyVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateKeyVersion',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createKeyVersion(request: CreateKeyVersionRequest): CreateKeyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createKeyVersionWithOptions(request, runtime);
}

model CreateSecretRequest {
  DKMSInstanceId?: string(name='DKMSInstanceId'),
  description?: string(name='Description'),
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation'),
  encryptionKeyId?: string(name='EncryptionKeyId'),
  extendedConfig?: map[string]any(name='ExtendedConfig'),
  rotationInterval?: string(name='RotationInterval'),
  secretData?: string(name='SecretData'),
  secretDataType?: string(name='SecretDataType'),
  secretName?: string(name='SecretName'),
  secretType?: string(name='SecretType'),
  tags?: string(name='Tags'),
  versionId?: string(name='VersionId'),
}

model CreateSecretShrinkRequest {
  DKMSInstanceId?: string(name='DKMSInstanceId'),
  description?: string(name='Description'),
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation'),
  encryptionKeyId?: string(name='EncryptionKeyId'),
  extendedConfigShrink?: string(name='ExtendedConfig'),
  rotationInterval?: string(name='RotationInterval'),
  secretData?: string(name='SecretData'),
  secretDataType?: string(name='SecretDataType'),
  secretName?: string(name='SecretName'),
  secretType?: string(name='SecretType'),
  tags?: string(name='Tags'),
  versionId?: string(name='VersionId'),
}

model CreateSecretResponseBody = {
  arn?: string(name='Arn'),
  automaticRotation?: string(name='AutomaticRotation'),
  DKMSInstanceId?: string(name='DKMSInstanceId'),
  extendedConfig?: string(name='ExtendedConfig'),
  nextRotationDate?: string(name='NextRotationDate'),
  requestId?: string(name='RequestId'),
  rotationInterval?: string(name='RotationInterval'),
  secretName?: string(name='SecretName'),
  secretType?: string(name='SecretType'),
  versionId?: string(name='VersionId'),
}

model CreateSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSecretResponseBody(name='body'),
}

async function createSecretWithOptions(tmpReq: CreateSecretRequest, runtime: Util.RuntimeOptions): CreateSecretResponse {
  Util.validateModel(tmpReq);
  var request = new CreateSecretShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.extendedConfig)) {
    request.extendedConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extendedConfig, 'ExtendedConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.DKMSInstanceId)) {
    query['DKMSInstanceId'] = request.DKMSInstanceId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.enableAutomaticRotation)) {
    query['EnableAutomaticRotation'] = request.enableAutomaticRotation;
  }
  if (!Util.isUnset(request.encryptionKeyId)) {
    query['EncryptionKeyId'] = request.encryptionKeyId;
  }
  if (!Util.isUnset(request.extendedConfigShrink)) {
    query['ExtendedConfig'] = request.extendedConfigShrink;
  }
  if (!Util.isUnset(request.rotationInterval)) {
    query['RotationInterval'] = request.rotationInterval;
  }
  if (!Util.isUnset(request.secretData)) {
    query['SecretData'] = request.secretData;
  }
  if (!Util.isUnset(request.secretDataType)) {
    query['SecretDataType'] = request.secretDataType;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.secretType)) {
    query['SecretType'] = request.secretType;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSecret',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSecret(request: CreateSecretRequest): CreateSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSecretWithOptions(request, runtime);
}

model DecryptRequest {
  ciphertextBlob?: string(name='CiphertextBlob'),
  encryptionContext?: map[string]any(name='EncryptionContext'),
}

model DecryptShrinkRequest {
  ciphertextBlob?: string(name='CiphertextBlob'),
  encryptionContextShrink?: string(name='EncryptionContext'),
}

model DecryptResponseBody = {
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  plaintext?: string(name='Plaintext'),
  requestId?: string(name='RequestId'),
}

model DecryptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DecryptResponseBody(name='body'),
}

async function decryptWithOptions(tmpReq: DecryptRequest, runtime: Util.RuntimeOptions): DecryptResponse {
  Util.validateModel(tmpReq);
  var request = new DecryptShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.ciphertextBlob)) {
    query['CiphertextBlob'] = request.ciphertextBlob;
  }
  if (!Util.isUnset(request.encryptionContextShrink)) {
    query['EncryptionContext'] = request.encryptionContextShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Decrypt',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function decrypt(request: DecryptRequest): DecryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return decryptWithOptions(request, runtime);
}

model DeleteAliasRequest {
  aliasName?: string(name='AliasName'),
}

model DeleteAliasResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAliasResponseBody(name='body'),
}

async function deleteAliasWithOptions(request: DeleteAliasRequest, runtime: Util.RuntimeOptions): DeleteAliasResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlias',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAlias(request: DeleteAliasRequest): DeleteAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAliasWithOptions(request, runtime);
}

model DeleteCertificateRequest {
  certificateId?: string(name='CertificateId'),
}

model DeleteCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCertificateResponseBody(name='body'),
}

async function deleteCertificateWithOptions(request: DeleteCertificateRequest, runtime: Util.RuntimeOptions): DeleteCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCertificate',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCertificate(request: DeleteCertificateRequest): DeleteCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCertificateWithOptions(request, runtime);
}

model DeleteKeyMaterialRequest {
  keyId?: string(name='KeyId'),
}

model DeleteKeyMaterialResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteKeyMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteKeyMaterialResponseBody(name='body'),
}

async function deleteKeyMaterialWithOptions(request: DeleteKeyMaterialRequest, runtime: Util.RuntimeOptions): DeleteKeyMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteKeyMaterial',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteKeyMaterial(request: DeleteKeyMaterialRequest): DeleteKeyMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteKeyMaterialWithOptions(request, runtime);
}

model DeleteSecretRequest {
  forceDeleteWithoutRecovery?: string(name='ForceDeleteWithoutRecovery'),
  recoveryWindowInDays?: string(name='RecoveryWindowInDays'),
  secretName?: string(name='SecretName'),
}

model DeleteSecretResponseBody = {
  plannedDeleteTime?: string(name='PlannedDeleteTime'),
  requestId?: string(name='RequestId'),
  secretName?: string(name='SecretName'),
}

model DeleteSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSecretResponseBody(name='body'),
}

async function deleteSecretWithOptions(request: DeleteSecretRequest, runtime: Util.RuntimeOptions): DeleteSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.forceDeleteWithoutRecovery)) {
    query['ForceDeleteWithoutRecovery'] = request.forceDeleteWithoutRecovery;
  }
  if (!Util.isUnset(request.recoveryWindowInDays)) {
    query['RecoveryWindowInDays'] = request.recoveryWindowInDays;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSecret',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSecret(request: DeleteSecretRequest): DeleteSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecretWithOptions(request, runtime);
}

model DescribeAccountKmsStatusResponseBody = {
  accountStatus?: string(name='AccountStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeAccountKmsStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAccountKmsStatusResponseBody(name='body'),
}

async function describeAccountKmsStatusWithOptions(runtime: Util.RuntimeOptions): DescribeAccountKmsStatusResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeAccountKmsStatus',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAccountKmsStatus(): DescribeAccountKmsStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccountKmsStatusWithOptions(runtime);
}

model DescribeCertificateRequest {
  certificateId?: string(name='CertificateId'),
}

model DescribeCertificateResponseBody = {
  arn?: string(name='Arn'),
  certificateId?: string(name='CertificateId'),
  createdAt?: string(name='CreatedAt'),
  exportablePrivateKey?: boolean(name='ExportablePrivateKey'),
  issuer?: string(name='Issuer'),
  keySpec?: string(name='KeySpec'),
  notAfter?: string(name='NotAfter'),
  notBefore?: string(name='NotBefore'),
  requestId?: string(name='RequestId'),
  serial?: string(name='Serial'),
  signatureAlgorithm?: string(name='SignatureAlgorithm'),
  status?: string(name='Status'),
  subject?: string(name='Subject'),
  subjectAlternativeNames?: [ string ](name='SubjectAlternativeNames'),
  subjectKeyIdentifier?: string(name='SubjectKeyIdentifier'),
  subjectPublicKey?: string(name='SubjectPublicKey'),
  tags?: map[string]any(name='Tags'),
  updatedAt?: string(name='UpdatedAt'),
}

model DescribeCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCertificateResponseBody(name='body'),
}

async function describeCertificateWithOptions(request: DescribeCertificateRequest, runtime: Util.RuntimeOptions): DescribeCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCertificate',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCertificate(request: DescribeCertificateRequest): DescribeCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCertificateWithOptions(request, runtime);
}

model DescribeKeyRequest {
  keyId?: string(name='KeyId'),
}

model DescribeKeyResponseBody = {
  keyMetadata?: {
    arn?: string(name='Arn'),
    automaticRotation?: string(name='AutomaticRotation'),
    creationDate?: string(name='CreationDate'),
    creator?: string(name='Creator'),
    DKMSInstanceId?: string(name='DKMSInstanceId'),
    deleteDate?: string(name='DeleteDate'),
    deletionProtection?: string(name='DeletionProtection'),
    deletionProtectionDescription?: string(name='DeletionProtectionDescription'),
    description?: string(name='Description'),
    keyId?: string(name='KeyId'),
    keySpec?: string(name='KeySpec'),
    keyState?: string(name='KeyState'),
    keyUsage?: string(name='KeyUsage'),
    lastRotationDate?: string(name='LastRotationDate'),
    materialExpireTime?: string(name='MaterialExpireTime'),
    nextRotationDate?: string(name='NextRotationDate'),
    origin?: string(name='Origin'),
    primaryKeyVersion?: string(name='PrimaryKeyVersion'),
    protectionLevel?: string(name='ProtectionLevel'),
    rotationInterval?: string(name='RotationInterval'),
  }(name='KeyMetadata'),
  requestId?: string(name='RequestId'),
}

model DescribeKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeKeyResponseBody(name='body'),
}

async function describeKeyWithOptions(request: DescribeKeyRequest, runtime: Util.RuntimeOptions): DescribeKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeKey',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeKey(request: DescribeKeyRequest): DescribeKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeKeyWithOptions(request, runtime);
}

model DescribeKeyVersionRequest {
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model DescribeKeyVersionResponseBody = {
  keyVersion?: {
    creationDate?: string(name='CreationDate'),
    keyId?: string(name='KeyId'),
    keyVersionId?: string(name='KeyVersionId'),
  }(name='KeyVersion'),
  requestId?: string(name='RequestId'),
}

model DescribeKeyVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeKeyVersionResponseBody(name='body'),
}

async function describeKeyVersionWithOptions(request: DescribeKeyVersionRequest, runtime: Util.RuntimeOptions): DescribeKeyVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keyVersionId)) {
    query['KeyVersionId'] = request.keyVersionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeKeyVersion',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeKeyVersion(request: DescribeKeyVersionRequest): DescribeKeyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeKeyVersionWithOptions(request, runtime);
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      regionId?: string(name='RegionId'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(runtime);
}

model DescribeSecretRequest {
  fetchTags?: string(name='FetchTags'),
  secretName?: string(name='SecretName'),
}

model DescribeSecretResponseBody = {
  arn?: string(name='Arn'),
  automaticRotation?: string(name='AutomaticRotation'),
  createTime?: string(name='CreateTime'),
  DKMSInstanceId?: string(name='DKMSInstanceId'),
  description?: string(name='Description'),
  encryptionKeyId?: string(name='EncryptionKeyId'),
  extendedConfig?: string(name='ExtendedConfig'),
  lastRotationDate?: string(name='LastRotationDate'),
  nextRotationDate?: string(name='NextRotationDate'),
  plannedDeleteTime?: string(name='PlannedDeleteTime'),
  requestId?: string(name='RequestId'),
  rotationInterval?: string(name='RotationInterval'),
  secretName?: string(name='SecretName'),
  secretType?: string(name='SecretType'),
  tags?: {
    tag?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Tag')
  }(name='Tags'),
  updateTime?: string(name='UpdateTime'),
}

model DescribeSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSecretResponseBody(name='body'),
}

async function describeSecretWithOptions(request: DescribeSecretRequest, runtime: Util.RuntimeOptions): DescribeSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fetchTags)) {
    query['FetchTags'] = request.fetchTags;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecret',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSecret(request: DescribeSecretRequest): DescribeSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecretWithOptions(request, runtime);
}

model DisableKeyRequest {
  keyId?: string(name='KeyId'),
}

model DisableKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableKeyResponseBody(name='body'),
}

async function disableKeyWithOptions(request: DisableKeyRequest, runtime: Util.RuntimeOptions): DisableKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableKey',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableKey(request: DisableKeyRequest): DisableKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableKeyWithOptions(request, runtime);
}

model EnableKeyRequest {
  keyId?: string(name='KeyId'),
}

model EnableKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableKeyResponseBody(name='body'),
}

async function enableKeyWithOptions(request: EnableKeyRequest, runtime: Util.RuntimeOptions): EnableKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableKey',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableKey(request: EnableKeyRequest): EnableKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableKeyWithOptions(request, runtime);
}

model EncryptRequest {
  encryptionContext?: map[string]any(name='EncryptionContext'),
  keyId?: string(name='KeyId'),
  plaintext?: string(name='Plaintext'),
}

model EncryptShrinkRequest {
  encryptionContextShrink?: string(name='EncryptionContext'),
  keyId?: string(name='KeyId'),
  plaintext?: string(name='Plaintext'),
}

model EncryptResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  requestId?: string(name='RequestId'),
}

model EncryptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EncryptResponseBody(name='body'),
}

async function encryptWithOptions(tmpReq: EncryptRequest, runtime: Util.RuntimeOptions): EncryptResponse {
  Util.validateModel(tmpReq);
  var request = new EncryptShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.encryptionContextShrink)) {
    query['EncryptionContext'] = request.encryptionContextShrink;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.plaintext)) {
    query['Plaintext'] = request.plaintext;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Encrypt',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function encrypt(request: EncryptRequest): EncryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return encryptWithOptions(request, runtime);
}

model ExportDataKeyRequest {
  ciphertextBlob?: string(name='CiphertextBlob'),
  encryptionContext?: map[string]any(name='EncryptionContext'),
  publicKeyBlob?: string(name='PublicKeyBlob'),
  wrappingAlgorithm?: string(name='WrappingAlgorithm'),
  wrappingKeySpec?: string(name='WrappingKeySpec'),
}

model ExportDataKeyShrinkRequest {
  ciphertextBlob?: string(name='CiphertextBlob'),
  encryptionContextShrink?: string(name='EncryptionContext'),
  publicKeyBlob?: string(name='PublicKeyBlob'),
  wrappingAlgorithm?: string(name='WrappingAlgorithm'),
  wrappingKeySpec?: string(name='WrappingKeySpec'),
}

model ExportDataKeyResponseBody = {
  exportedDataKey?: string(name='ExportedDataKey'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  requestId?: string(name='RequestId'),
}

model ExportDataKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExportDataKeyResponseBody(name='body'),
}

async function exportDataKeyWithOptions(tmpReq: ExportDataKeyRequest, runtime: Util.RuntimeOptions): ExportDataKeyResponse {
  Util.validateModel(tmpReq);
  var request = new ExportDataKeyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.ciphertextBlob)) {
    query['CiphertextBlob'] = request.ciphertextBlob;
  }
  if (!Util.isUnset(request.encryptionContextShrink)) {
    query['EncryptionContext'] = request.encryptionContextShrink;
  }
  if (!Util.isUnset(request.publicKeyBlob)) {
    query['PublicKeyBlob'] = request.publicKeyBlob;
  }
  if (!Util.isUnset(request.wrappingAlgorithm)) {
    query['WrappingAlgorithm'] = request.wrappingAlgorithm;
  }
  if (!Util.isUnset(request.wrappingKeySpec)) {
    query['WrappingKeySpec'] = request.wrappingKeySpec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportDataKey',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportDataKey(request: ExportDataKeyRequest): ExportDataKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportDataKeyWithOptions(request, runtime);
}

model GenerateAndExportDataKeyRequest {
  encryptionContext?: map[string]any(name='EncryptionContext'),
  keyId?: string(name='KeyId'),
  keySpec?: string(name='KeySpec'),
  numberOfBytes?: int32(name='NumberOfBytes'),
  publicKeyBlob?: string(name='PublicKeyBlob'),
  wrappingAlgorithm?: string(name='WrappingAlgorithm'),
  wrappingKeySpec?: string(name='WrappingKeySpec'),
}

model GenerateAndExportDataKeyShrinkRequest {
  encryptionContextShrink?: string(name='EncryptionContext'),
  keyId?: string(name='KeyId'),
  keySpec?: string(name='KeySpec'),
  numberOfBytes?: int32(name='NumberOfBytes'),
  publicKeyBlob?: string(name='PublicKeyBlob'),
  wrappingAlgorithm?: string(name='WrappingAlgorithm'),
  wrappingKeySpec?: string(name='WrappingKeySpec'),
}

model GenerateAndExportDataKeyResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob'),
  exportedDataKey?: string(name='ExportedDataKey'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  requestId?: string(name='RequestId'),
}

model GenerateAndExportDataKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateAndExportDataKeyResponseBody(name='body'),
}

async function generateAndExportDataKeyWithOptions(tmpReq: GenerateAndExportDataKeyRequest, runtime: Util.RuntimeOptions): GenerateAndExportDataKeyResponse {
  Util.validateModel(tmpReq);
  var request = new GenerateAndExportDataKeyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.encryptionContextShrink)) {
    query['EncryptionContext'] = request.encryptionContextShrink;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keySpec)) {
    query['KeySpec'] = request.keySpec;
  }
  if (!Util.isUnset(request.numberOfBytes)) {
    query['NumberOfBytes'] = request.numberOfBytes;
  }
  if (!Util.isUnset(request.publicKeyBlob)) {
    query['PublicKeyBlob'] = request.publicKeyBlob;
  }
  if (!Util.isUnset(request.wrappingAlgorithm)) {
    query['WrappingAlgorithm'] = request.wrappingAlgorithm;
  }
  if (!Util.isUnset(request.wrappingKeySpec)) {
    query['WrappingKeySpec'] = request.wrappingKeySpec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateAndExportDataKey',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateAndExportDataKey(request: GenerateAndExportDataKeyRequest): GenerateAndExportDataKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateAndExportDataKeyWithOptions(request, runtime);
}

model GenerateDataKeyRequest {
  encryptionContext?: map[string]any(name='EncryptionContext'),
  keyId?: string(name='KeyId'),
  keySpec?: string(name='KeySpec'),
  numberOfBytes?: int32(name='NumberOfBytes'),
}

model GenerateDataKeyShrinkRequest {
  encryptionContextShrink?: string(name='EncryptionContext'),
  keyId?: string(name='KeyId'),
  keySpec?: string(name='KeySpec'),
  numberOfBytes?: int32(name='NumberOfBytes'),
}

model GenerateDataKeyResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  plaintext?: string(name='Plaintext'),
  requestId?: string(name='RequestId'),
}

model GenerateDataKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateDataKeyResponseBody(name='body'),
}

async function generateDataKeyWithOptions(tmpReq: GenerateDataKeyRequest, runtime: Util.RuntimeOptions): GenerateDataKeyResponse {
  Util.validateModel(tmpReq);
  var request = new GenerateDataKeyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.encryptionContextShrink)) {
    query['EncryptionContext'] = request.encryptionContextShrink;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keySpec)) {
    query['KeySpec'] = request.keySpec;
  }
  if (!Util.isUnset(request.numberOfBytes)) {
    query['NumberOfBytes'] = request.numberOfBytes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateDataKey',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateDataKey(request: GenerateDataKeyRequest): GenerateDataKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateDataKeyWithOptions(request, runtime);
}

model GenerateDataKeyWithoutPlaintextRequest {
  encryptionContext?: map[string]any(name='EncryptionContext'),
  keyId?: string(name='KeyId'),
  keySpec?: string(name='KeySpec'),
  numberOfBytes?: int32(name='NumberOfBytes'),
}

model GenerateDataKeyWithoutPlaintextShrinkRequest {
  encryptionContextShrink?: string(name='EncryptionContext'),
  keyId?: string(name='KeyId'),
  keySpec?: string(name='KeySpec'),
  numberOfBytes?: int32(name='NumberOfBytes'),
}

model GenerateDataKeyWithoutPlaintextResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  requestId?: string(name='RequestId'),
}

model GenerateDataKeyWithoutPlaintextResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateDataKeyWithoutPlaintextResponseBody(name='body'),
}

async function generateDataKeyWithoutPlaintextWithOptions(tmpReq: GenerateDataKeyWithoutPlaintextRequest, runtime: Util.RuntimeOptions): GenerateDataKeyWithoutPlaintextResponse {
  Util.validateModel(tmpReq);
  var request = new GenerateDataKeyWithoutPlaintextShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.encryptionContextShrink)) {
    query['EncryptionContext'] = request.encryptionContextShrink;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keySpec)) {
    query['KeySpec'] = request.keySpec;
  }
  if (!Util.isUnset(request.numberOfBytes)) {
    query['NumberOfBytes'] = request.numberOfBytes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateDataKeyWithoutPlaintext',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateDataKeyWithoutPlaintext(request: GenerateDataKeyWithoutPlaintextRequest): GenerateDataKeyWithoutPlaintextResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateDataKeyWithoutPlaintextWithOptions(request, runtime);
}

model GetCertificateRequest {
  certificateId?: string(name='CertificateId'),
}

model GetCertificateResponseBody = {
  certificate?: string(name='Certificate'),
  certificateChain?: string(name='CertificateChain'),
  certificateId?: string(name='CertificateId'),
  csr?: string(name='Csr'),
  requestId?: string(name='RequestId'),
}

model GetCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCertificateResponseBody(name='body'),
}

async function getCertificateWithOptions(request: GetCertificateRequest, runtime: Util.RuntimeOptions): GetCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCertificate',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCertificate(request: GetCertificateRequest): GetCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCertificateWithOptions(request, runtime);
}

model GetParametersForImportRequest {
  keyId?: string(name='KeyId'),
  wrappingAlgorithm?: string(name='WrappingAlgorithm'),
  wrappingKeySpec?: string(name='WrappingKeySpec'),
}

model GetParametersForImportResponseBody = {
  importToken?: string(name='ImportToken'),
  keyId?: string(name='KeyId'),
  publicKey?: string(name='PublicKey'),
  requestId?: string(name='RequestId'),
  tokenExpireTime?: string(name='TokenExpireTime'),
}

model GetParametersForImportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetParametersForImportResponseBody(name='body'),
}

async function getParametersForImportWithOptions(request: GetParametersForImportRequest, runtime: Util.RuntimeOptions): GetParametersForImportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.wrappingAlgorithm)) {
    query['WrappingAlgorithm'] = request.wrappingAlgorithm;
  }
  if (!Util.isUnset(request.wrappingKeySpec)) {
    query['WrappingKeySpec'] = request.wrappingKeySpec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetParametersForImport',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getParametersForImport(request: GetParametersForImportRequest): GetParametersForImportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getParametersForImportWithOptions(request, runtime);
}

model GetPublicKeyRequest {
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
}

model GetPublicKeyResponseBody = {
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  publicKey?: string(name='PublicKey'),
  requestId?: string(name='RequestId'),
}

model GetPublicKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPublicKeyResponseBody(name='body'),
}

async function getPublicKeyWithOptions(request: GetPublicKeyRequest, runtime: Util.RuntimeOptions): GetPublicKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keyVersionId)) {
    query['KeyVersionId'] = request.keyVersionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPublicKey',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPublicKey(request: GetPublicKeyRequest): GetPublicKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPublicKeyWithOptions(request, runtime);
}

model GetRandomPasswordRequest {
  excludeCharacters?: string(name='ExcludeCharacters'),
  excludeLowercase?: string(name='ExcludeLowercase'),
  excludeNumbers?: string(name='ExcludeNumbers'),
  excludePunctuation?: string(name='ExcludePunctuation'),
  excludeUppercase?: string(name='ExcludeUppercase'),
  passwordLength?: string(name='PasswordLength'),
  requireEachIncludedType?: string(name='RequireEachIncludedType'),
}

model GetRandomPasswordResponseBody = {
  randomPassword?: string(name='RandomPassword'),
  requestId?: string(name='RequestId'),
}

model GetRandomPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRandomPasswordResponseBody(name='body'),
}

async function getRandomPasswordWithOptions(request: GetRandomPasswordRequest, runtime: Util.RuntimeOptions): GetRandomPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.excludeCharacters)) {
    query['ExcludeCharacters'] = request.excludeCharacters;
  }
  if (!Util.isUnset(request.excludeLowercase)) {
    query['ExcludeLowercase'] = request.excludeLowercase;
  }
  if (!Util.isUnset(request.excludeNumbers)) {
    query['ExcludeNumbers'] = request.excludeNumbers;
  }
  if (!Util.isUnset(request.excludePunctuation)) {
    query['ExcludePunctuation'] = request.excludePunctuation;
  }
  if (!Util.isUnset(request.excludeUppercase)) {
    query['ExcludeUppercase'] = request.excludeUppercase;
  }
  if (!Util.isUnset(request.passwordLength)) {
    query['PasswordLength'] = request.passwordLength;
  }
  if (!Util.isUnset(request.requireEachIncludedType)) {
    query['RequireEachIncludedType'] = request.requireEachIncludedType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRandomPassword',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRandomPassword(request: GetRandomPasswordRequest): GetRandomPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRandomPasswordWithOptions(request, runtime);
}

model GetSecretValueRequest {
  fetchExtendedConfig?: boolean(name='FetchExtendedConfig'),
  secretName?: string(name='SecretName'),
  versionId?: string(name='VersionId'),
  versionStage?: string(name='VersionStage'),
}

model GetSecretValueResponseBody = {
  automaticRotation?: string(name='AutomaticRotation'),
  createTime?: string(name='CreateTime'),
  extendedConfig?: string(name='ExtendedConfig'),
  lastRotationDate?: string(name='LastRotationDate'),
  nextRotationDate?: string(name='NextRotationDate'),
  requestId?: string(name='RequestId'),
  rotationInterval?: string(name='RotationInterval'),
  secretData?: string(name='SecretData'),
  secretDataType?: string(name='SecretDataType'),
  secretName?: string(name='SecretName'),
  secretType?: string(name='SecretType'),
  versionId?: string(name='VersionId'),
  versionStages?: {
    versionStage?: [ string ](name='VersionStage')
  }(name='VersionStages'),
}

model GetSecretValueResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSecretValueResponseBody(name='body'),
}

async function getSecretValueWithOptions(request: GetSecretValueRequest, runtime: Util.RuntimeOptions): GetSecretValueResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fetchExtendedConfig)) {
    query['FetchExtendedConfig'] = request.fetchExtendedConfig;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionStage)) {
    query['VersionStage'] = request.versionStage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSecretValue',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSecretValue(request: GetSecretValueRequest): GetSecretValueResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecretValueWithOptions(request, runtime);
}

model ImportKeyMaterialRequest {
  encryptedKeyMaterial?: string(name='EncryptedKeyMaterial'),
  importToken?: string(name='ImportToken'),
  keyId?: string(name='KeyId'),
  keyMaterialExpireUnix?: long(name='KeyMaterialExpireUnix'),
}

model ImportKeyMaterialResponseBody = {
  requestId?: string(name='RequestId'),
}

model ImportKeyMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ImportKeyMaterialResponseBody(name='body'),
}

async function importKeyMaterialWithOptions(request: ImportKeyMaterialRequest, runtime: Util.RuntimeOptions): ImportKeyMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.encryptedKeyMaterial)) {
    query['EncryptedKeyMaterial'] = request.encryptedKeyMaterial;
  }
  if (!Util.isUnset(request.importToken)) {
    query['ImportToken'] = request.importToken;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keyMaterialExpireUnix)) {
    query['KeyMaterialExpireUnix'] = request.keyMaterialExpireUnix;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportKeyMaterial',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importKeyMaterial(request: ImportKeyMaterialRequest): ImportKeyMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return importKeyMaterialWithOptions(request, runtime);
}

model ListAliasesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListAliasesResponseBody = {
  aliases?: {
    alias?: [ 
    {
      aliasArn?: string(name='AliasArn'),
      aliasName?: string(name='AliasName'),
      keyId?: string(name='KeyId'),
    }
  ](name='Alias')
  }(name='Aliases'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAliasesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAliasesResponseBody(name='body'),
}

async function listAliasesWithOptions(request: ListAliasesRequest, runtime: Util.RuntimeOptions): ListAliasesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAliases',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAliases(request: ListAliasesRequest): ListAliasesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAliasesWithOptions(request, runtime);
}

model ListAliasesByKeyIdRequest {
  keyId?: string(name='KeyId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListAliasesByKeyIdResponseBody = {
  aliases?: {
    alias?: [ 
    {
      aliasArn?: string(name='AliasArn'),
      aliasName?: string(name='AliasName'),
      keyId?: string(name='KeyId'),
    }
  ](name='Alias')
  }(name='Aliases'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAliasesByKeyIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAliasesByKeyIdResponseBody(name='body'),
}

async function listAliasesByKeyIdWithOptions(request: ListAliasesByKeyIdRequest, runtime: Util.RuntimeOptions): ListAliasesByKeyIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAliasesByKeyId',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAliasesByKeyId(request: ListAliasesByKeyIdRequest): ListAliasesByKeyIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAliasesByKeyIdWithOptions(request, runtime);
}

model ListKeyVersionsRequest {
  keyId?: string(name='KeyId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListKeyVersionsResponseBody = {
  keyVersions?: {
    keyVersion?: [ 
    {
      creationDate?: string(name='CreationDate'),
      keyId?: string(name='KeyId'),
      keyVersionId?: string(name='KeyVersionId'),
    }
  ](name='KeyVersion')
  }(name='KeyVersions'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListKeyVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListKeyVersionsResponseBody(name='body'),
}

async function listKeyVersionsWithOptions(request: ListKeyVersionsRequest, runtime: Util.RuntimeOptions): ListKeyVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListKeyVersions',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listKeyVersions(request: ListKeyVersionsRequest): ListKeyVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listKeyVersionsWithOptions(request, runtime);
}

model ListKeysRequest {
  filters?: string(name='Filters'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListKeysResponseBody = {
  keys?: {
    key?: [ 
    {
      keyArn?: string(name='KeyArn'),
      keyId?: string(name='KeyId'),
    }
  ](name='Key')
  }(name='Keys'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListKeysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListKeysResponseBody(name='body'),
}

async function listKeysWithOptions(request: ListKeysRequest, runtime: Util.RuntimeOptions): ListKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListKeys',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listKeys(request: ListKeysRequest): ListKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listKeysWithOptions(request, runtime);
}

model ListResourceTagsRequest {
  keyId?: string(name='KeyId'),
}

model ListResourceTagsResponseBody = {
  requestId?: string(name='RequestId'),
  tags?: {
    tag?: [ 
    {
      keyId?: string(name='KeyId'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Tag')
  }(name='Tags'),
}

model ListResourceTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceTagsResponseBody(name='body'),
}

async function listResourceTagsWithOptions(request: ListResourceTagsRequest, runtime: Util.RuntimeOptions): ListResourceTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceTags',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceTags(request: ListResourceTagsRequest): ListResourceTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceTagsWithOptions(request, runtime);
}

model ListSecretVersionIdsRequest {
  includeDeprecated?: string(name='IncludeDeprecated'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  secretName?: string(name='SecretName'),
}

model ListSecretVersionIdsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  secretName?: string(name='SecretName'),
  totalCount?: int32(name='TotalCount'),
  versionIds?: {
    versionId?: [ 
    {
      createTime?: string(name='CreateTime'),
      versionId?: string(name='VersionId'),
      versionStages?: {
        versionStage?: [ string ](name='VersionStage')
      }(name='VersionStages'),
    }
  ](name='VersionId')
  }(name='VersionIds'),
}

model ListSecretVersionIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSecretVersionIdsResponseBody(name='body'),
}

async function listSecretVersionIdsWithOptions(request: ListSecretVersionIdsRequest, runtime: Util.RuntimeOptions): ListSecretVersionIdsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.includeDeprecated)) {
    query['IncludeDeprecated'] = request.includeDeprecated;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSecretVersionIds',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSecretVersionIds(request: ListSecretVersionIdsRequest): ListSecretVersionIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecretVersionIdsWithOptions(request, runtime);
}

model ListSecretsRequest {
  fetchTags?: string(name='FetchTags'),
  filters?: string(name='Filters'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListSecretsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  secretList?: {
    secret?: [ 
    {
      createTime?: string(name='CreateTime'),
      plannedDeleteTime?: string(name='PlannedDeleteTime'),
      secretName?: string(name='SecretName'),
      secretType?: string(name='SecretType'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Secret')
  }(name='SecretList'),
  totalCount?: int32(name='TotalCount'),
}

model ListSecretsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSecretsResponseBody(name='body'),
}

async function listSecretsWithOptions(request: ListSecretsRequest, runtime: Util.RuntimeOptions): ListSecretsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fetchTags)) {
    query['FetchTags'] = request.fetchTags;
  }
  if (!Util.isUnset(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSecrets',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSecrets(request: ListSecretsRequest): ListSecretsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecretsWithOptions(request, runtime);
}

model OpenKmsServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model OpenKmsServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenKmsServiceResponseBody(name='body'),
}

async function openKmsServiceWithOptions(runtime: Util.RuntimeOptions): OpenKmsServiceResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'OpenKmsService',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openKmsService(): OpenKmsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openKmsServiceWithOptions(runtime);
}

model PutSecretValueRequest {
  secretData?: string(name='SecretData'),
  secretDataType?: string(name='SecretDataType'),
  secretName?: string(name='SecretName'),
  versionId?: string(name='VersionId'),
  versionStages?: string(name='VersionStages'),
}

model PutSecretValueResponseBody = {
  requestId?: string(name='RequestId'),
  secretName?: string(name='SecretName'),
  versionId?: string(name='VersionId'),
  versionStages?: {
    versionStage?: [ string ](name='VersionStage')
  }(name='VersionStages'),
}

model PutSecretValueResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutSecretValueResponseBody(name='body'),
}

async function putSecretValueWithOptions(request: PutSecretValueRequest, runtime: Util.RuntimeOptions): PutSecretValueResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.secretData)) {
    query['SecretData'] = request.secretData;
  }
  if (!Util.isUnset(request.secretDataType)) {
    query['SecretDataType'] = request.secretDataType;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionStages)) {
    query['VersionStages'] = request.versionStages;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutSecretValue',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putSecretValue(request: PutSecretValueRequest): PutSecretValueResponse {
  var runtime = new Util.RuntimeOptions{};
  return putSecretValueWithOptions(request, runtime);
}

model ReEncryptRequest {
  ciphertextBlob?: string(name='CiphertextBlob'),
  destinationEncryptionContext?: map[string]any(name='DestinationEncryptionContext'),
  destinationKeyId?: string(name='DestinationKeyId'),
  sourceEncryptionAlgorithm?: string(name='SourceEncryptionAlgorithm'),
  sourceEncryptionContext?: map[string]any(name='SourceEncryptionContext'),
  sourceKeyId?: string(name='SourceKeyId'),
  sourceKeyVersionId?: string(name='SourceKeyVersionId'),
}

model ReEncryptShrinkRequest {
  ciphertextBlob?: string(name='CiphertextBlob'),
  destinationEncryptionContextShrink?: string(name='DestinationEncryptionContext'),
  destinationKeyId?: string(name='DestinationKeyId'),
  sourceEncryptionAlgorithm?: string(name='SourceEncryptionAlgorithm'),
  sourceEncryptionContextShrink?: string(name='SourceEncryptionContext'),
  sourceKeyId?: string(name='SourceKeyId'),
  sourceKeyVersionId?: string(name='SourceKeyVersionId'),
}

model ReEncryptResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob'),
  keyId?: string(name='KeyId'),
  keyVersionId?: string(name='KeyVersionId'),
  requestId?: string(name='RequestId'),
}

model ReEncryptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReEncryptResponseBody(name='body'),
}

async function reEncryptWithOptions(tmpReq: ReEncryptRequest, runtime: Util.RuntimeOptions): ReEncryptResponse {
  Util.validateModel(tmpReq);
  var request = new ReEncryptShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.destinationEncryptionContext)) {
    request.destinationEncryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.destinationEncryptionContext, 'DestinationEncryptionContext', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceEncryptionContext)) {
    request.sourceEncryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceEncryptionContext, 'SourceEncryptionContext', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.ciphertextBlob)) {
    query['CiphertextBlob'] = request.ciphertextBlob;
  }
  if (!Util.isUnset(request.destinationEncryptionContextShrink)) {
    query['DestinationEncryptionContext'] = request.destinationEncryptionContextShrink;
  }
  if (!Util.isUnset(request.destinationKeyId)) {
    query['DestinationKeyId'] = request.destinationKeyId;
  }
  if (!Util.isUnset(request.sourceEncryptionAlgorithm)) {
    query['SourceEncryptionAlgorithm'] = request.sourceEncryptionAlgorithm;
  }
  if (!Util.isUnset(request.sourceEncryptionContextShrink)) {
    query['SourceEncryptionContext'] = request.sourceEncryptionContextShrink;
  }
  if (!Util.isUnset(request.sourceKeyId)) {
    query['SourceKeyId'] = request.sourceKeyId;
  }
  if (!Util.isUnset(request.sourceKeyVersionId)) {
    query['SourceKeyVersionId'] = request.sourceKeyVersionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReEncrypt',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reEncrypt(request: ReEncryptRequest): ReEncryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return reEncryptWithOptions(request, runtime);
}

model RestoreSecretRequest {
  secretName?: string(name='SecretName'),
}

model RestoreSecretResponseBody = {
  requestId?: string(name='RequestId'),
  secretName?: string(name='SecretName'),
}

model RestoreSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestoreSecretResponseBody(name='body'),
}

async function restoreSecretWithOptions(request: RestoreSecretRequest, runtime: Util.RuntimeOptions): RestoreSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestoreSecret',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restoreSecret(request: RestoreSecretRequest): RestoreSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return restoreSecretWithOptions(request, runtime);
}

model RotateSecretRequest {
  secretName?: string(name='SecretName'),
  versionId?: string(name='VersionId'),
}

model RotateSecretResponseBody = {
  arn?: string(name='Arn'),
  requestId?: string(name='RequestId'),
  secretName?: string(name='SecretName'),
  versionId?: string(name='VersionId'),
}

model RotateSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RotateSecretResponseBody(name='body'),
}

async function rotateSecretWithOptions(request: RotateSecretRequest, runtime: Util.RuntimeOptions): RotateSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RotateSecret',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rotateSecret(request: RotateSecretRequest): RotateSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return rotateSecretWithOptions(request, runtime);
}

model ScheduleKeyDeletionRequest {
  keyId?: string(name='KeyId'),
  pendingWindowInDays?: int32(name='PendingWindowInDays'),
}

model ScheduleKeyDeletionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ScheduleKeyDeletionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ScheduleKeyDeletionResponseBody(name='body'),
}

async function scheduleKeyDeletionWithOptions(request: ScheduleKeyDeletionRequest, runtime: Util.RuntimeOptions): ScheduleKeyDeletionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.pendingWindowInDays)) {
    query['PendingWindowInDays'] = request.pendingWindowInDays;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ScheduleKeyDeletion',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function scheduleKeyDeletion(request: ScheduleKeyDeletionRequest): ScheduleKeyDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  return scheduleKeyDeletionWithOptions(request, runtime);
}

model SetDeletionProtectionRequest {
  deletionProtectionDescription?: string(name='DeletionProtectionDescription'),
  enableDeletionProtection?: boolean(name='EnableDeletionProtection'),
  protectedResourceArn?: string(name='ProtectedResourceArn'),
}

model SetDeletionProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetDeletionProtectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDeletionProtectionResponseBody(name='body'),
}

async function setDeletionProtectionWithOptions(request: SetDeletionProtectionRequest, runtime: Util.RuntimeOptions): SetDeletionProtectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deletionProtectionDescription)) {
    query['DeletionProtectionDescription'] = request.deletionProtectionDescription;
  }
  if (!Util.isUnset(request.enableDeletionProtection)) {
    query['EnableDeletionProtection'] = request.enableDeletionProtection;
  }
  if (!Util.isUnset(request.protectedResourceArn)) {
    query['ProtectedResourceArn'] = request.protectedResourceArn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDeletionProtection',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDeletionProtection(request: SetDeletionProtectionRequest): SetDeletionProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDeletionProtectionWithOptions(request, runtime);
}

model TagResourceRequest {
  certificateId?: string(name='CertificateId'),
  keyId?: string(name='KeyId'),
  secretName?: string(name='SecretName'),
  tags?: string(name='Tags'),
}

model TagResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourceResponseBody(name='body'),
}

async function tagResourceWithOptions(request: TagResourceRequest, runtime: Util.RuntimeOptions): TagResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResource',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResource(request: TagResourceRequest): TagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourceWithOptions(request, runtime);
}

model UntagResourceRequest {
  certificateId?: string(name='CertificateId'),
  keyId?: string(name='KeyId'),
  secretName?: string(name='SecretName'),
  tagKeys?: string(name='TagKeys'),
}

model UntagResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourceResponseBody(name='body'),
}

async function untagResourceWithOptions(request: UntagResourceRequest, runtime: Util.RuntimeOptions): UntagResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.tagKeys)) {
    query['TagKeys'] = request.tagKeys;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResource',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResource(request: UntagResourceRequest): UntagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourceWithOptions(request, runtime);
}

model UpdateAliasRequest {
  aliasName?: string(name='AliasName'),
  keyId?: string(name='KeyId'),
}

model UpdateAliasResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAliasResponseBody(name='body'),
}

async function updateAliasWithOptions(request: UpdateAliasRequest, runtime: Util.RuntimeOptions): UpdateAliasResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlias',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAlias(request: UpdateAliasRequest): UpdateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAliasWithOptions(request, runtime);
}

model UpdateCertificateStatusRequest {
  certificateId?: string(name='CertificateId'),
  status?: string(name='Status'),
}

model UpdateCertificateStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateCertificateStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCertificateStatusResponseBody(name='body'),
}

async function updateCertificateStatusWithOptions(request: UpdateCertificateStatusRequest, runtime: Util.RuntimeOptions): UpdateCertificateStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCertificateStatus',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCertificateStatus(request: UpdateCertificateStatusRequest): UpdateCertificateStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCertificateStatusWithOptions(request, runtime);
}

model UpdateKeyDescriptionRequest {
  description?: string(name='Description'),
  keyId?: string(name='KeyId'),
}

model UpdateKeyDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateKeyDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateKeyDescriptionResponseBody(name='body'),
}

async function updateKeyDescriptionWithOptions(request: UpdateKeyDescriptionRequest, runtime: Util.RuntimeOptions): UpdateKeyDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateKeyDescription',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateKeyDescription(request: UpdateKeyDescriptionRequest): UpdateKeyDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateKeyDescriptionWithOptions(request, runtime);
}

model UpdateRotationPolicyRequest {
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation'),
  keyId?: string(name='KeyId'),
  rotationInterval?: string(name='RotationInterval'),
}

model UpdateRotationPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateRotationPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRotationPolicyResponseBody(name='body'),
}

async function updateRotationPolicyWithOptions(request: UpdateRotationPolicyRequest, runtime: Util.RuntimeOptions): UpdateRotationPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.enableAutomaticRotation)) {
    query['EnableAutomaticRotation'] = request.enableAutomaticRotation;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.rotationInterval)) {
    query['RotationInterval'] = request.rotationInterval;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRotationPolicy',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRotationPolicy(request: UpdateRotationPolicyRequest): UpdateRotationPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRotationPolicyWithOptions(request, runtime);
}

model UpdateSecretRequest {
  extendedConfig?: {
    customData?: map[string]any(name='CustomData'),
  }(name='ExtendedConfig'),
  description?: string(name='Description'),
  secretName?: string(name='SecretName'),
}

model UpdateSecretShrinkRequest {
  extendedConfig?: {
    customData?: string(name='CustomData'),
  }(name='ExtendedConfig'),
  description?: string(name='Description'),
  secretName?: string(name='SecretName'),
}

model UpdateSecretResponseBody = {
  requestId?: string(name='RequestId'),
  secretName?: string(name='SecretName'),
}

model UpdateSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSecretResponseBody(name='body'),
}

async function updateSecretWithOptions(request: UpdateSecretRequest, runtime: Util.RuntimeOptions): UpdateSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.extendedConfig)) {
    query['ExtendedConfig'] = request.extendedConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSecret',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSecret(request: UpdateSecretRequest): UpdateSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSecretWithOptions(request, runtime);
}

model UpdateSecretRotationPolicyRequest {
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation'),
  rotationInterval?: string(name='RotationInterval'),
  secretName?: string(name='SecretName'),
}

model UpdateSecretRotationPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  secretName?: string(name='SecretName'),
}

model UpdateSecretRotationPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSecretRotationPolicyResponseBody(name='body'),
}

async function updateSecretRotationPolicyWithOptions(request: UpdateSecretRotationPolicyRequest, runtime: Util.RuntimeOptions): UpdateSecretRotationPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.enableAutomaticRotation)) {
    query['EnableAutomaticRotation'] = request.enableAutomaticRotation;
  }
  if (!Util.isUnset(request.rotationInterval)) {
    query['RotationInterval'] = request.rotationInterval;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSecretRotationPolicy',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSecretRotationPolicy(request: UpdateSecretRotationPolicyRequest): UpdateSecretRotationPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSecretRotationPolicyWithOptions(request, runtime);
}

model UpdateSecretVersionStageRequest {
  moveToVersion?: string(name='MoveToVersion'),
  removeFromVersion?: string(name='RemoveFromVersion'),
  secretName?: string(name='SecretName'),
  versionStage?: string(name='VersionStage'),
}

model UpdateSecretVersionStageResponseBody = {
  requestId?: string(name='RequestId'),
  secretName?: string(name='SecretName'),
}

model UpdateSecretVersionStageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSecretVersionStageResponseBody(name='body'),
}

async function updateSecretVersionStageWithOptions(request: UpdateSecretVersionStageRequest, runtime: Util.RuntimeOptions): UpdateSecretVersionStageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.moveToVersion)) {
    query['MoveToVersion'] = request.moveToVersion;
  }
  if (!Util.isUnset(request.removeFromVersion)) {
    query['RemoveFromVersion'] = request.removeFromVersion;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.versionStage)) {
    query['VersionStage'] = request.versionStage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSecretVersionStage',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSecretVersionStage(request: UpdateSecretVersionStageRequest): UpdateSecretVersionStageResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSecretVersionStageWithOptions(request, runtime);
}

model UploadCertificateRequest {
  certificate?: string(name='Certificate'),
  certificateChain?: string(name='CertificateChain'),
  certificateId?: string(name='CertificateId'),
}

model UploadCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UploadCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadCertificateResponseBody(name='body'),
}

async function uploadCertificateWithOptions(request: UploadCertificateRequest, runtime: Util.RuntimeOptions): UploadCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificate)) {
    query['Certificate'] = request.certificate;
  }
  if (!Util.isUnset(request.certificateChain)) {
    query['CertificateChain'] = request.certificateChain;
  }
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadCertificate',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadCertificate(request: UploadCertificateRequest): UploadCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadCertificateWithOptions(request, runtime);
}

