/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('kms', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AsymmetricDecryptRequest {
  algorithm?: string(name='Algorithm', description='The decryption algorithm.', example='RSAES_OAEP_SHA_1'),
  ciphertextBlob?: string(name='CiphertextBlob', description='The ciphertext that you want to decrypt.

> * The value is encoded in Base64.
> * You can call the [AsymmetricEncrypt](~~148131~~) operation to generate the ciphertext.', example='BQKP+1zK6+ZEMxTP5qaVzcsgXtWplYBKm0NXdSnB5FzliFxE1bSiu4dnEIlca2JpeH7yz1/S6fed630H+hIH6DoM25fTLNcKj+mFB0Xnh9m2+HN59Mn4qyTfcUeadnfCXSWcGBouhXFwcdd2rJ3n337bzTf4jm659gZu3L0i6PLuxM9p7mqdwO0cKJPfGVfhnfMz+f4alMg79WB/NNyE2lyX7/qxvV49ObNrrJbKSFiz8Djocaf0IESNLMbfYI5bXjWkJlX92DQbKhibtQW8ZOJ//ZC6t0AWcUoKL6QDm/dg5koQalcleRinpB+QadFm894sLbVZ9+N4GVsv1W****=='),
  keyId?: string(name='KeyId', description='The ID of the customer master key (CMK). The ID must be globally unique.

>  You can also set this parameter to an alias that is bound to the CMK. For more information, see [Alias overview](~~68522~~).', example='5c438b18-05be-40ad-b6c2-3be6752c****'),
  keyVersionId?: string(name='KeyVersionId', description='The version ID of the CMK. The ID must be globally unique.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
}

model AsymmetricDecryptResponseBody = {
  keyId?: string(name='KeyId', description='The ID of the CMK. The ID must be globally unique.

>  If you set the KeyId parameter in the request to an alias, the ID of the CMK to which the alias is bound is returned.', example='5c438b18-05be-40ad-b6c2-3be6752c****'),
  keyVersionId?: string(name='KeyVersionId', description='The version ID of the CMK that is used to encrypt the plaintext.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
  plaintext?: string(name='Plaintext', description='The Base64-encoded plaintext that is generated after decryption.', example='SGVsbG8gd29ybGQ='),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='475f1620-b9d3-4d35-b5c6-3fbdd941423d'),
}

model AsymmetricDecryptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AsymmetricDecryptResponseBody(name='body'),
}

/**
  * This operation supports only asymmetric keys for which the **Usage** parameter is set to **ENCRYPT/DECRYPT**. The following table lists supported encryption algorithms. 
  * | KeySpec | Algorithm | Description | Maximum length in bytes |
  * | ------- | --------- | ----------- | ----------------------- |
  * | RSA_2048 | RSAES_OAEP_SHA_256 | RSAES-OAEP using SHA-256 and MGF1 with SHA-256 | 256 |
  * | RSA_2048 | RSAES_OAEP_SHA_1 | RSAES-OAEP using SHA1 and MGF1 with SHA1 | 256 |
  * | RSA_3072 | RSAES_OAEP_SHA_256 | RSAES-OAEP using SHA-256 and MGF1 with SHA-256 | 384 |
  * | RSA_3072 | RSAES_OAEP_SHA_1 | RSAES-OAEP using SHA1 and MGF1 with SHA1 | 384 |
  * | EC_SM2 | SM2PKE | SM2 public key encryption algorithm based on elliptic curves | 6144 |
  * In this example, the asymmetric key whose ID is `5c438b18-05be-40ad-b6c2-3be6752c****` and version ID is `2ab1a983-7072-4bbc-a582-584b5bd8****` and the decryption algorithm `RSAES_OAEP_SHA_1` are used to decrypt the ciphertext `BQKP+1zK6+ZEMxTP5qaVzcsgXtWplYBKm0NXdSnB5FzliFxE1bSiu4dnEIlca2JpeH7yz1/S6fed630H+hIH6DoM25fTLNcKj+mFB0Xnh9m2+HN59Mn4qyTfcUeadnfCXSWcGBouhXFwcdd2rJ3n337bzTf4jm659gZu3L0i6PLuxM9p7mqdwO0cKJPfGVfhnfMz+f4alMg79WB/NNyE2lyX7/qxvV49ObNrrJbKSFiz8Djocaf0IESNLMbfYI5bXjWkJlX92DQbKhibtQW8ZOJ//ZC6t0AWcUoKL6QDm/dg5koQalcleRinpB+QadFm894sLbVZ9+N4GVsv1W****==`.
  *
  * @param request AsymmetricDecryptRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AsymmetricDecryptResponse
 */
async function asymmetricDecryptWithOptions(request: AsymmetricDecryptRequest, runtime: Util.RuntimeOptions): AsymmetricDecryptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.ciphertextBlob)) {
    query['CiphertextBlob'] = request.ciphertextBlob;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keyVersionId)) {
    query['KeyVersionId'] = request.keyVersionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AsymmetricDecrypt',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation supports only asymmetric keys for which the **Usage** parameter is set to **ENCRYPT/DECRYPT**. The following table lists supported encryption algorithms. 
  * | KeySpec | Algorithm | Description | Maximum length in bytes |
  * | ------- | --------- | ----------- | ----------------------- |
  * | RSA_2048 | RSAES_OAEP_SHA_256 | RSAES-OAEP using SHA-256 and MGF1 with SHA-256 | 256 |
  * | RSA_2048 | RSAES_OAEP_SHA_1 | RSAES-OAEP using SHA1 and MGF1 with SHA1 | 256 |
  * | RSA_3072 | RSAES_OAEP_SHA_256 | RSAES-OAEP using SHA-256 and MGF1 with SHA-256 | 384 |
  * | RSA_3072 | RSAES_OAEP_SHA_1 | RSAES-OAEP using SHA1 and MGF1 with SHA1 | 384 |
  * | EC_SM2 | SM2PKE | SM2 public key encryption algorithm based on elliptic curves | 6144 |
  * In this example, the asymmetric key whose ID is `5c438b18-05be-40ad-b6c2-3be6752c****` and version ID is `2ab1a983-7072-4bbc-a582-584b5bd8****` and the decryption algorithm `RSAES_OAEP_SHA_1` are used to decrypt the ciphertext `BQKP+1zK6+ZEMxTP5qaVzcsgXtWplYBKm0NXdSnB5FzliFxE1bSiu4dnEIlca2JpeH7yz1/S6fed630H+hIH6DoM25fTLNcKj+mFB0Xnh9m2+HN59Mn4qyTfcUeadnfCXSWcGBouhXFwcdd2rJ3n337bzTf4jm659gZu3L0i6PLuxM9p7mqdwO0cKJPfGVfhnfMz+f4alMg79WB/NNyE2lyX7/qxvV49ObNrrJbKSFiz8Djocaf0IESNLMbfYI5bXjWkJlX92DQbKhibtQW8ZOJ//ZC6t0AWcUoKL6QDm/dg5koQalcleRinpB+QadFm894sLbVZ9+N4GVsv1W****==`.
  *
  * @param request AsymmetricDecryptRequest
  * @return AsymmetricDecryptResponse
 */
async function asymmetricDecrypt(request: AsymmetricDecryptRequest): AsymmetricDecryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return asymmetricDecryptWithOptions(request, runtime);
}

model AsymmetricEncryptRequest {
  algorithm?: string(name='Algorithm', description='The encryption algorithm.', example='RSAES_OAEP_SHA_1'),
  keyId?: string(name='KeyId', description='The ID of the CMK. The ID must be globally unique.

>  You can also set this parameter to an alias that is bound to the CMK. For more information, see [Overview of aliases](~~68522~~).', example='5c438b18-05be-40ad-b6c2-3be6752c****'),
  keyVersionId?: string(name='KeyVersionId', description='The version ID of the CMK. The ID must be globally unique.

>  You can call the [ListKeyVersions](~~133966~~) operation to query the versions of a CMK. The ID of a version is specified by the KeyVersionId parameter.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
  plaintext?: string(name='Plaintext', description='The plaintext that you want to encrypt. The plaintext must be Base64-encoded.', example='SGVsbG8gd29ybGQ='),
}

model AsymmetricEncryptResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob', description='The Base64-encoded ciphertext that was generated after encryption.', example='BQKP+1zK6+ZEMxTP5qaVzcsgXtWplYBKm0NXdSnB5FzliFxE1bSiu4dnEIlca2JpeH7yz1/S6fed630H+hIH6DoM25fTLNcKj+mFB0Xnh9m2+HN59Mn4qyTfcUeadnfCXSWcGBouhXFwcdd2rJ3n337bzTf4jm659gZu3L0i6PLuxM9p7mqdwO0cKJPfGVfhnfMz+f4alMg79WB/NNyE2lyX7/qxvV49ObNrrJbKSFiz8Djocaf0IESNLMbfYI5bXjWkJlX92DQbKhibtQW8ZOJ//ZC6t0AWcUoKL6QDm/dg5koQalcleRinpB+QadFm894sLbVZ9+N4GVsv1Wbjwg=='),
  keyId?: string(name='KeyId', description='The ID of the CMK. The ID must be globally unique.

>  If you set the KeyId parameter in the request to an alias, the ID of the CMK to which the alias is bound is returned.', example='5c438b18-05be-40ad-b6c2-3be6752c****'),
  keyVersionId?: string(name='KeyVersionId', description='The version ID of the CMK that is used to encrypt the plaintext.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='475f1620-b9d3-4d35-b5c6-3fbdd941423d'),
}

model AsymmetricEncryptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AsymmetricEncryptResponseBody(name='body'),
}

/**
  * This operation is supported only for asymmetric keys for which the **Usage** parameter is set to **ENCRYPT/DECRYPT**. The following table lists the supported encryption algorithms: 
  * | KeySpec | Algorithm | Description | Maximum number of bytes that can be encrypted |
  * | ------- | --------- | ----------- | --------------------------------------------- |
  * | RSA_2048 | RSAES_OAEP_SHA_256 | RSAES-OAEP using SHA-256 and MGF1 with SHA-256 | 190 |
  * | RSA_2048 | RSAES_OAEP_SHA_1 | RSAES-OAEP using SHA1 and MGF1 with SHA1 | 214 |
  * | RSA_3072 | RSAES_OAEP_SHA_256 | RSAES-OAEP using SHA-256 and MGF1 with SHA-256 | 318 |
  * | RSA_3072 | RSAES_OAEP_SHA_1 | RSAES-OAEP using SHA1 and MGF1 with SHA1 | 342 |
  * | EC_SM2 | SM2PKE | SM2 public key encryption algorithm based on elliptic curves | 6047 |
  * You can use the asymmetric CMK whose ID is `5c438b18-05be-40ad-b6c2-3be6752c****` and version ID is `2ab1a983-7072-4bbc-a582-584b5bd8****` and the algorithm `RSAES_OAEP_SHA_1` to encrypt the plaintext `SGVsbG8gd29ybGQ=` based on the parameter settings provided in this topic.
  *
  * @param request AsymmetricEncryptRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AsymmetricEncryptResponse
 */
async function asymmetricEncryptWithOptions(request: AsymmetricEncryptRequest, runtime: Util.RuntimeOptions): AsymmetricEncryptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keyVersionId)) {
    query['KeyVersionId'] = request.keyVersionId;
  }
  if (!Util.isUnset(request.plaintext)) {
    query['Plaintext'] = request.plaintext;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AsymmetricEncrypt',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation is supported only for asymmetric keys for which the **Usage** parameter is set to **ENCRYPT/DECRYPT**. The following table lists the supported encryption algorithms: 
  * | KeySpec | Algorithm | Description | Maximum number of bytes that can be encrypted |
  * | ------- | --------- | ----------- | --------------------------------------------- |
  * | RSA_2048 | RSAES_OAEP_SHA_256 | RSAES-OAEP using SHA-256 and MGF1 with SHA-256 | 190 |
  * | RSA_2048 | RSAES_OAEP_SHA_1 | RSAES-OAEP using SHA1 and MGF1 with SHA1 | 214 |
  * | RSA_3072 | RSAES_OAEP_SHA_256 | RSAES-OAEP using SHA-256 and MGF1 with SHA-256 | 318 |
  * | RSA_3072 | RSAES_OAEP_SHA_1 | RSAES-OAEP using SHA1 and MGF1 with SHA1 | 342 |
  * | EC_SM2 | SM2PKE | SM2 public key encryption algorithm based on elliptic curves | 6047 |
  * You can use the asymmetric CMK whose ID is `5c438b18-05be-40ad-b6c2-3be6752c****` and version ID is `2ab1a983-7072-4bbc-a582-584b5bd8****` and the algorithm `RSAES_OAEP_SHA_1` to encrypt the plaintext `SGVsbG8gd29ybGQ=` based on the parameter settings provided in this topic.
  *
  * @param request AsymmetricEncryptRequest
  * @return AsymmetricEncryptResponse
 */
async function asymmetricEncrypt(request: AsymmetricEncryptRequest): AsymmetricEncryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return asymmetricEncryptWithOptions(request, runtime);
}

model AsymmetricSignRequest {
  algorithm?: string(name='Algorithm', description='The version ID of the CMK. The ID must be globally unique.', example='RSA_PSS_SHA_256'),
  digest?: string(name='Digest', description='The signature algorithm.', example='ZOyIygCyaOW6GjVnihtTFtIS9PNmskdyMlNKiu****='),
  keyId?: string(name='KeyId', description='The operation that you want to perform. Set the value to **AsymmetricSign**.', example='5c438b18-05be-40ad-b6c2-3be6752c****'),
  keyVersionId?: string(name='KeyVersionId', description='The ID of the customer master key (CMK). The ID must be globally unique.

>  You can also set this parameter to an alias that is bound to the CMK. For more information, see [Alias overview](~~68522~~).', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
}

model AsymmetricSignResponseBody = {
  keyId?: string(name='KeyId', description='The version ID of the CMK. The ID must be globally unique.', example='5c438b18-05be-40ad-b6c2-3be6752c****'),
  keyVersionId?: string(name='KeyVersionId', description='The digest that is generated for the original message by using a hash algorithm. The hash algorithm is specified by the Algorithm parameter.

> * The value is encoded in Base64.
> * For more information about how to calculate message digests, see the **Preprocess signature: compute a message digest** section of the [Generate and verify a signature by using an asymmetric CMK](~~148146~~) topic.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
  requestId?: string(name='RequestId', description='The calculated signature.

>  The value is encoded in Base64.', example='475f1620-b9d3-4d35-b5c6-3fbdd941423d'),
  value?: string(name='Value', description='The ID of the CMK. The ID must be globally unique.

>  If you set the KeyId parameter in the request to an alias, the ID of the CMK to which the alias is bound is returned.', example='M2CceNZH00ZgL9ED/ZHFp21YRAvYeZHknJUc207OCZ0N9wNn9As4z2bON3FF3je+1Nu+2+/8Zj50HpMTpzYpMp2R93cYmACCmhaYoKydxylbyGzJR8y9likZRCrkD38lRoS40aBBvv/6iRKzQuo9EGYVcel36cMNg00VmYNBy3pa1rwg3gA4l3cy6kjayZja1WGPkVhrVKsrJMdbpl0ApLjXKuD8rw1n1XLCwCUEL5eLPljTZaAveqdOFQOiZnZEGI27qIiZe7I1fN8tcz6anS/gTM7xRKE++5egEvRWlTQQTJeApnPSiUPA+8ZykNdelQsOQh5SrGoyI4A5pq****=='),
}

model AsymmetricSignResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AsymmetricSignResponseBody(name='body'),
}

/**
  * Generates a signature by using an asymmetric key.
  *
  * @param request AsymmetricSignRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AsymmetricSignResponse
 */
async function asymmetricSignWithOptions(request: AsymmetricSignRequest, runtime: Util.RuntimeOptions): AsymmetricSignResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keyVersionId)) {
    query['KeyVersionId'] = request.keyVersionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AsymmetricSign',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Generates a signature by using an asymmetric key.
  *
  * @param request AsymmetricSignRequest
  * @return AsymmetricSignResponse
 */
async function asymmetricSign(request: AsymmetricSignRequest): AsymmetricSignResponse {
  var runtime = new Util.RuntimeOptions{};
  return asymmetricSignWithOptions(request, runtime);
}

model AsymmetricVerifyRequest {
  algorithm?: string(name='Algorithm', description='The signature algorithm.', example='RSA_PSS_SHA_256'),
  digest?: string(name='Digest', description='The digest that is generated for the original message by using a hash algorithm. The hash algorithm is specified by the **Algorithm** parameter.

>  The value is encoded in Base64.', example='ZOyIygCyaOW6GjVnihtTFtIS9PNmskdyMlNKiuy****='),
  keyId?: string(name='KeyId', description='The ID of the CMK. The ID must be globally unique.

>  You can also set this parameter to an alias that is bound to the CMK. For more information, see [Overview of aliases](~~68522~~).', example='5c438b18-05be-40ad-b6c2-3be6752c****'),
  keyVersionId?: string(name='KeyVersionId', description='The version ID of the CMK. The ID must be globally unique.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
  value?: string(name='Value', description='The signature value to be verified.

>  The value is encoded in Base64.', example='M2CceNZH00ZgL9ED/ZHFp21YRAvYeZHknJUc207OCZ0N9wNn9As4z2bON3FF3je+1Nu+2+/8Zj50HpMTpzYpMp2R93cYmACCmhaYoKydxylbyGzJR8y9likZRCrkD38lRoS40aBBvv/6iRKzQuo9EGYVcel36cMNg00VmYNBy3pa1rwg3gA4l3cy6kjayZja1WGPkVhrVKsrJMdbpl0ApLjXKuD8rw1n1XLCwCUEL5eLPljTZaAveqdOFQOiZnZEGI27qIiZe7I1fN8tcz6anS/gTM7xRKE++5egEvRWlTQQTJeApnPSiUPA+8ZykNdelQsOQh5SrGoyI4A5pq****=='),
}

model AsymmetricVerifyResponseBody = {
  keyId?: string(name='KeyId', description='The ID of the CMK. The ID must be globally unique.

>  If you set the KeyId parameter in the request to an alias, the ID of the CMK to which the alias is bound is returned.', example='5c438b18-05be-40ad-b6c2-3be6752c****'),
  keyVersionId?: string(name='KeyVersionId', description='The version ID of the CMK that is used to encrypt the plaintext.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='475f1620-b9d3-4d35-b5c6-3fbdd941423d'),
  value?: boolean(name='Value', description='Indicates whether the signature passed the verification.', example='true'),
}

model AsymmetricVerifyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AsymmetricVerifyResponseBody(name='body'),
}

/**
  * This operation supports only asymmetric keys for which the **Usage** parameter is set to **SIGN/VERIFY**. The following table describes the supported signature algorithms. 
  * | KeySpec | Algorithm | Description |
  * | ------- | --------- | ----------- |
  * | RSA_2048 | RSA_PSS_SHA_256 | RSASSA-PSS using SHA-256 and MGF1 with SHA-256 |
  * | RSA_2048 | RSA_PKCS1_SHA_256 | RSASSA-PKCS1-v1_5 using SHA-256 |
  * | RSA_3072 | RSA_PSS_SHA_256 | RSASSA-PSS using SHA-256 and MGF1 with SHA-256 |
  * | RSA_3072 | RSA_PKCS1_SHA_256 | RSASSA-PKCS1-v1_5 using SHA-256 |
  * | EC_P256 | ECDSA_SHA_256 | ECDSA on the P-256 Curve(secp256r1) with a SHA-256 digest |
  * | EC_P256K | ECDSA_SHA_256 | ECDSA on the P-256K Curve(secp256k1) with a SHA-256 digest |
  * | EC_SM2 | SM2DSA | SM2 elliptic curve public key encryption algorithm |
  * >  When you calculate the SM2 signature based on GB/T 32918, the **Digest** parameter is used to calculate the digest value of the combination of Z(A) and M, rather than the SM3 digest value. M indicates the original message to be signed. Z(A) indicates the hash value for User A. The hash value is defined in GB/T 32918.  In this example, the asymmetric key whose ID is `5c438b18-05be-40ad-b6c2-3be6752c****` and version ID is `2ab1a983-7072-4bbc-a582-584b5bd8****` and the signature algorithm RSA_PSS_SHA_256 are used to verify the signature `M2CceNZH00ZgL9ED/ZHFp21YRAvYeZHknJUc207OCZ0N9wNn9As4z2bON3FF3je+1Nu+2+/8Zj50HpMTpzYpMp2R93cYmACCmhaYoKydxylbyGzJR8y9likZRCrkD38lRoS40aBBvv/6iRKzQuo9EGYVcel36cMNg00VmYNBy3pa1rwg3gA4l3cy6kjayZja1WGPkVhrVKsrJMdbpl0ApLjXKuD8rw1n1XLCwCUEL5eLPljTZaAveqdOFQOiZnZEGI27qIiZe7I1fN8tcz6anS/gTM7xRKE++5egEvRWlTQQTJeApnPSiUPA+8ZykNdelQsOQh5SrGoyI4A5pq****==` of the digest `ZOyIygCyaOW6GjVnihtTFtIS9PNmskdyMlNKiuyjfzw=`.
  *
  * @param request AsymmetricVerifyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AsymmetricVerifyResponse
 */
async function asymmetricVerifyWithOptions(request: AsymmetricVerifyRequest, runtime: Util.RuntimeOptions): AsymmetricVerifyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keyVersionId)) {
    query['KeyVersionId'] = request.keyVersionId;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AsymmetricVerify',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation supports only asymmetric keys for which the **Usage** parameter is set to **SIGN/VERIFY**. The following table describes the supported signature algorithms. 
  * | KeySpec | Algorithm | Description |
  * | ------- | --------- | ----------- |
  * | RSA_2048 | RSA_PSS_SHA_256 | RSASSA-PSS using SHA-256 and MGF1 with SHA-256 |
  * | RSA_2048 | RSA_PKCS1_SHA_256 | RSASSA-PKCS1-v1_5 using SHA-256 |
  * | RSA_3072 | RSA_PSS_SHA_256 | RSASSA-PSS using SHA-256 and MGF1 with SHA-256 |
  * | RSA_3072 | RSA_PKCS1_SHA_256 | RSASSA-PKCS1-v1_5 using SHA-256 |
  * | EC_P256 | ECDSA_SHA_256 | ECDSA on the P-256 Curve(secp256r1) with a SHA-256 digest |
  * | EC_P256K | ECDSA_SHA_256 | ECDSA on the P-256K Curve(secp256k1) with a SHA-256 digest |
  * | EC_SM2 | SM2DSA | SM2 elliptic curve public key encryption algorithm |
  * >  When you calculate the SM2 signature based on GB/T 32918, the **Digest** parameter is used to calculate the digest value of the combination of Z(A) and M, rather than the SM3 digest value. M indicates the original message to be signed. Z(A) indicates the hash value for User A. The hash value is defined in GB/T 32918.  In this example, the asymmetric key whose ID is `5c438b18-05be-40ad-b6c2-3be6752c****` and version ID is `2ab1a983-7072-4bbc-a582-584b5bd8****` and the signature algorithm RSA_PSS_SHA_256 are used to verify the signature `M2CceNZH00ZgL9ED/ZHFp21YRAvYeZHknJUc207OCZ0N9wNn9As4z2bON3FF3je+1Nu+2+/8Zj50HpMTpzYpMp2R93cYmACCmhaYoKydxylbyGzJR8y9likZRCrkD38lRoS40aBBvv/6iRKzQuo9EGYVcel36cMNg00VmYNBy3pa1rwg3gA4l3cy6kjayZja1WGPkVhrVKsrJMdbpl0ApLjXKuD8rw1n1XLCwCUEL5eLPljTZaAveqdOFQOiZnZEGI27qIiZe7I1fN8tcz6anS/gTM7xRKE++5egEvRWlTQQTJeApnPSiUPA+8ZykNdelQsOQh5SrGoyI4A5pq****==` of the digest `ZOyIygCyaOW6GjVnihtTFtIS9PNmskdyMlNKiuyjfzw=`.
  *
  * @param request AsymmetricVerifyRequest
  * @return AsymmetricVerifyResponse
 */
async function asymmetricVerify(request: AsymmetricVerifyRequest): AsymmetricVerifyResponse {
  var runtime = new Util.RuntimeOptions{};
  return asymmetricVerifyWithOptions(request, runtime);
}

model CancelKeyDeletionRequest {
  keyId?: string(name='KeyId', description='The ID of the CMK. The ID must be globally unique.', example='1234abcd-12ab-34cd-56ef-12345678****'),
}

model CancelKeyDeletionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3da5b8cc-8107-40ac-a170-793cd181d7b7'),
}

model CancelKeyDeletionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelKeyDeletionResponseBody(name='body'),
}

/**
  * If the deletion task of a CMK is canceled, the CMK returns to the Enabled state.
  *
  * @param request CancelKeyDeletionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CancelKeyDeletionResponse
 */
async function cancelKeyDeletionWithOptions(request: CancelKeyDeletionRequest, runtime: Util.RuntimeOptions): CancelKeyDeletionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelKeyDeletion',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If the deletion task of a CMK is canceled, the CMK returns to the Enabled state.
  *
  * @param request CancelKeyDeletionRequest
  * @return CancelKeyDeletionResponse
 */
async function cancelKeyDeletion(request: CancelKeyDeletionRequest): CancelKeyDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelKeyDeletionWithOptions(request, runtime);
}

model CertificatePrivateKeyDecryptRequest {
  algorithm?: string(name='Algorithm', description='The encryption algorithm. Valid values:

*   RSAES_OAEP_SHA\\_1

*   RSAES_OAEP_SHA\\_256

*   SM2PKE

> The SM2PKE encryption algorithm is supported only in regions in mainland China. In these regions, managed hardware security modules (HSMs) are used. For more information, see [Managed HSM overview](~~125803~~).', example='RSAES_OAEP_SHA_256'),
  certificateId?: string(name='CertificateId', description='The ID of the certificate. The ID must be globally unique in Certificates Manager.', example='12345678-1234-1234-1234-12345678****'),
  ciphertextBlob?: string(name='CiphertextBlob', description='The data that you want to decrypt.

The value is encoded in Base64.', example='ZOyIygCyaOW6Gj****MlNKiuyjfzw='),
}

model CertificatePrivateKeyDecryptResponseBody = {
  certificateId?: string(name='CertificateId', description='The ID of the certificate.', example='12345678-1234-1234-1234-12345678****'),
  plaintext?: string(name='Plaintext', description='The plaintext after data is decrypted.

The value is encoded in Base64.', example='VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='5979d897-d69f-4fc9-87dd-f3bb73c40b80'),
}

model CertificatePrivateKeyDecryptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CertificatePrivateKeyDecryptResponseBody(name='body'),
}

/**
  * Limit: The encryption algorithm in the request parameters must match the key type. 
  * The following table describes the mapping between encryption algorithms and key types.
  * | Algorithm | Key Spec |
  * | --------- | -------- |
  * | RSAES_OAEP_SHA_1 | RSA_2048 |
  * | RSAES_OAEP_SHA_256 | RSA_2048 |
  * | SM2PKE | EC_SM2 |
  * In this example, the certificate whose ID is `12345678-1234-1234-1234-12345678****` and the encryption algorithm `RSAES_OAEP_SHA_256` are used to decrypt the data `ZOyIygCyaOW6Gj****MlNKiuyjfzw=`.
  *
  * @param request CertificatePrivateKeyDecryptRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CertificatePrivateKeyDecryptResponse
 */
async function certificatePrivateKeyDecryptWithOptions(request: CertificatePrivateKeyDecryptRequest, runtime: Util.RuntimeOptions): CertificatePrivateKeyDecryptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.ciphertextBlob)) {
    query['CiphertextBlob'] = request.ciphertextBlob;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CertificatePrivateKeyDecrypt',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Limit: The encryption algorithm in the request parameters must match the key type. 
  * The following table describes the mapping between encryption algorithms and key types.
  * | Algorithm | Key Spec |
  * | --------- | -------- |
  * | RSAES_OAEP_SHA_1 | RSA_2048 |
  * | RSAES_OAEP_SHA_256 | RSA_2048 |
  * | SM2PKE | EC_SM2 |
  * In this example, the certificate whose ID is `12345678-1234-1234-1234-12345678****` and the encryption algorithm `RSAES_OAEP_SHA_256` are used to decrypt the data `ZOyIygCyaOW6Gj****MlNKiuyjfzw=`.
  *
  * @param request CertificatePrivateKeyDecryptRequest
  * @return CertificatePrivateKeyDecryptResponse
 */
async function certificatePrivateKeyDecrypt(request: CertificatePrivateKeyDecryptRequest): CertificatePrivateKeyDecryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return certificatePrivateKeyDecryptWithOptions(request, runtime);
}

model CertificatePrivateKeySignRequest {
  algorithm?: string(name='Algorithm', description='The signature algorithm. Valid values:

*   RSA_PKCS1\\_SHA\\_256

*   RSA_PSS_SHA\\_256

*   ECDSA_SHA\\_256

*   SM2DSA

>* The SM2DSA signature algorithm is supported only in regions where managed hardware security modules (HSMs) are used in mainland China. For more information, see [Managed HSM overview](~~125803~~).', example='ECDSA_SHA_256'),
  certificateId?: string(name='CertificateId', description='The ID of the certificate. The ID must be globally unique in Certificates Manager.', example='12345678-1234-1234-1234-12345678****'),
  message?: string(name='Message', description='The data to be signed.

The value is encoded in Base64. For example, if the hexadecimal data that you want to sign is `[0x31, 0x32, 0x33, 0x34]`, the Base64-encoded data is `MTIzNA==`.

If the MessageType parameter is set to RAW, the size of the data must be less than or equal to 4 KB.

If the size of the data is greater than 4 KB, you can set the MessageType parameter to DIGEST and set the Message parameter to the digest of the data. The digest is also called hash value. You can compute the digest of the data on an on-premises machine. Certificates Manager uses the digest that you compute in your own certificate application system. The message digest algorithm that you use must match the specified signature algorithm. Comply with the following mapping between signature algorithms and message digest algorithms:

*   If the signature algorithm is RSA_PKCS1\\_SHA\\_256, RSA_PSS_SHA\\_256, or ECDSA_SHA\\_256, the message digest algorithm must be SHA-256.
*   If the signature algorithm is SM2DSA, the message digest algorithm must be SM3.

>  If the key type of the certificate is EC_SM2 and the MessageType parameter is set to DIGEST, the value of the Message parameter is `e` that is described in GB/T 32918.2-2016 6.1.', example='VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4='),
  messageType?: string(name='MessageType', description='The type of the message. Valid values:

*   RAW: the raw data. This is the default value.
*   DIGEST: the message digest (hash value) of the raw data.', example='RAW'),
}

model CertificatePrivateKeySignResponseBody = {
  certificateId?: string(name='CertificateId', description='The ID of the certificate.', example='12345678-1234-1234-1234-12345678****'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='5979d897-d69f-4fc9-87dd-f3bb73c40b80'),
  signatureValue?: string(name='SignatureValue', description='The signature value.

The value is encoded in Base64.', example='ZOyIygCyaOW6Gj****MlNKiuyjfzw='),
}

model CertificatePrivateKeySignResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CertificatePrivateKeySignResponseBody(name='body'),
}

/**
  * The signature algorithm in the request parameters must match the key type. The following table describes the mapping between signature algorithms and key types.  
  * | Algorithm | Key Spec |
  * | --------- | -------- |
  * | RSA_PKCS1_SHA_256 | RSA_2048 |
  * | RSA_PSS_SHA_256 | RSA_2048 |
  * | ECDSA_SHA_256 | EC_P256 |
  * | SM2DSA | EC_SM2 |
  * In this example, the certificate whose ID is `12345678-1234-1234-1234-12345678****` and the signature algorithm `ECDSA_SHA_256` are used to generate a signature for the raw data `VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=`.
  *
  * @param request CertificatePrivateKeySignRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CertificatePrivateKeySignResponse
 */
async function certificatePrivateKeySignWithOptions(request: CertificatePrivateKeySignRequest, runtime: Util.RuntimeOptions): CertificatePrivateKeySignResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  if (!Util.isUnset(request.messageType)) {
    query['MessageType'] = request.messageType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CertificatePrivateKeySign',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The signature algorithm in the request parameters must match the key type. The following table describes the mapping between signature algorithms and key types.  
  * | Algorithm | Key Spec |
  * | --------- | -------- |
  * | RSA_PKCS1_SHA_256 | RSA_2048 |
  * | RSA_PSS_SHA_256 | RSA_2048 |
  * | ECDSA_SHA_256 | EC_P256 |
  * | SM2DSA | EC_SM2 |
  * In this example, the certificate whose ID is `12345678-1234-1234-1234-12345678****` and the signature algorithm `ECDSA_SHA_256` are used to generate a signature for the raw data `VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=`.
  *
  * @param request CertificatePrivateKeySignRequest
  * @return CertificatePrivateKeySignResponse
 */
async function certificatePrivateKeySign(request: CertificatePrivateKeySignRequest): CertificatePrivateKeySignResponse {
  var runtime = new Util.RuntimeOptions{};
  return certificatePrivateKeySignWithOptions(request, runtime);
}

model CertificatePublicKeyEncryptRequest {
  algorithm?: string(name='Algorithm', description='The encryption algorithm. Valid values:

*   RSAES_OAEP_SHA\\_1

*   RSAES_OAEP_SHA\\_256

*   SM2PKE

>The SM2PKE encryption algorithm is supported only in regions in mainland China. In these regions, managed hardware security modules (HSMs) are used. For more information, see [Managed HSM overview](~~125803~~).', example='RSAES_OAEP_SHA_256'),
  certificateId?: string(name='CertificateId', description='The ID of the certificate. The ID must be globally unique in Certificates Manager.', example='12345678-1234-1234-1234-12345678****'),
  plaintext?: string(name='Plaintext', description='The data that you want to encrypt.

The value is encoded in Base64. For example, if the hexadecimal data that you want to encrypt is `[0x31, 0x32, 0x33, 0x34]`, the Base64-encoded data is `MTIzNA==`.

The size of data that can be encrypted varies based on the encryption algorithm that you use:

*   RSAES_OAEP_SHA\\_1: 214 bytes
*   RSAES_OAEP_SHA\\_256: 190 bytes
*   SM2PKE: 6,047 bytes

If the size of data that you want to encrypt exceeds the preceding limits, you can call the [GenerateDataKey](~~28948~~) operation to generate a data key to encrypt the data. Then, call the CertificatePublicKeyEncrypt operation to encrypt the data key.', example='VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4='),
}

model CertificatePublicKeyEncryptResponseBody = {
  certificateId?: string(name='CertificateId', description='The ID of the certificate.', example='12345678-1234-1234-1234-12345678****'),
  ciphertextBlob?: string(name='CiphertextBlob', description='The ciphertext.

The value is encoded in Base64.', example='ZOyIygCyaOW6Gj****MlNKiuyjfzw='),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='5979d897-d69f-4fc9-87dd-f3bb73c40b80'),
}

model CertificatePublicKeyEncryptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CertificatePublicKeyEncryptResponseBody(name='body'),
}

/**
  * Limit: The encryption algorithm in the request parameters must match the key type. 
  * The following table describes the mapping between encryption algorithms and key types.
  * | Algorithm | Key Spec |
  * | --------- | -------- |
  * | RSAES_OAEP_SHA_1 | RSA_2048 |
  * | RSAES_OAEP_SHA_256 | RSA_2048 |
  * | SM2PKE | EC_SM2 |
  * In this example, the certificate whose ID is `12345678-1234-1234-1234-12345678****` and the encryption algorithm `RSAES_OAEP_SHA_256` are used to encrypt the data `VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=`.
  *
  * @param request CertificatePublicKeyEncryptRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CertificatePublicKeyEncryptResponse
 */
async function certificatePublicKeyEncryptWithOptions(request: CertificatePublicKeyEncryptRequest, runtime: Util.RuntimeOptions): CertificatePublicKeyEncryptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.plaintext)) {
    query['Plaintext'] = request.plaintext;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CertificatePublicKeyEncrypt',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Limit: The encryption algorithm in the request parameters must match the key type. 
  * The following table describes the mapping between encryption algorithms and key types.
  * | Algorithm | Key Spec |
  * | --------- | -------- |
  * | RSAES_OAEP_SHA_1 | RSA_2048 |
  * | RSAES_OAEP_SHA_256 | RSA_2048 |
  * | SM2PKE | EC_SM2 |
  * In this example, the certificate whose ID is `12345678-1234-1234-1234-12345678****` and the encryption algorithm `RSAES_OAEP_SHA_256` are used to encrypt the data `VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=`.
  *
  * @param request CertificatePublicKeyEncryptRequest
  * @return CertificatePublicKeyEncryptResponse
 */
async function certificatePublicKeyEncrypt(request: CertificatePublicKeyEncryptRequest): CertificatePublicKeyEncryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return certificatePublicKeyEncryptWithOptions(request, runtime);
}

model CertificatePublicKeyVerifyRequest {
  algorithm?: string(name='Algorithm', description='The signature algorithm. Valid values:

*   RSA_PKCS1\\_SHA\\_256

*   RSA_PSS_SHA\\_256

*   ECDSA_SHA\\_256

*   SM2DSA

> The SM2DSA signature algorithm is supported only in regions where managed hardware security modules (HSMs) are used in the Chinese mainland. For more information, see [Managed HSM overview](~~125803~~).', example='ECDSA_SHA_256'),
  certificateId?: string(name='CertificateId', description='The ID of the certificate. The ID must be globally unique in Certificates Manager.', example='12345678-1234-1234-1234-12345678****'),
  message?: string(name='Message', description='The raw data that is signed.

The value is encoded in Base64. For example, if the raw data in the hexadecimal format is `[0x31, 0x32, 0x33, 0x34]`, set this parameter to the Base64-encoded value `MTIzNA==`.

If the MessageType parameter is set to RAW, the size of the data must be less than or equal to 4 KB.

If the size of the data is greater than 4 KB, you can set the MessageType parameter to DIGEST and set the Message parameter to the digest of the data. The digest is also called hash value. You can compute the digest of the data on an on-premises device. Certificates Manager uses the digest that you compute in your own certificate application system. The message digest algorithm that you use must match the specified signature algorithm. Comply with the following mapping between signature algorithms and message digest algorithms:

*   If the signature algorithm is RSA_PKCS1\\_SHA\\_256, RSA_PSS_SHA\\_256, or ECDSA_SHA\\_256, the message digest algorithm must be SHA-256.
*   If the signature algorithm is SM2DSA, the message digest algorithm must be SM3.

>  If the key type of the certificate is EC_SM2 and the MessageType parameter is set to DIGEST, the value of the Message parameter is `e` that is described in GB/T 32918.2-2016 6.1.', example='VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4='),
  messageType?: string(name='MessageType', description='The type of the message. Valid values:

*   RAW: the raw data. This is the default value.
*   DIGEST: the message digest (hash value) of the raw data.', example='RAW'),
  signatureValue?: string(name='SignatureValue', description='The signature value.

The value is encoded in Base64.', example='ZOyIygCyaOW6Gj****MlNKiuyjfzw='),
}

model CertificatePublicKeyVerifyResponseBody = {
  certificateId?: string(name='CertificateId', description='The ID of the certificate.', example='12345678-1234-1234-1234-12345678****'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='5979d897-d69f-4fc9-87dd-f3bb73c40b80'),
  signatureValid?: boolean(name='SignatureValid', description='The verification result. Valid values:

*   true: The signature is valid.
*   false: The signature is invalid.', example='true'),
}

model CertificatePublicKeyVerifyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CertificatePublicKeyVerifyResponseBody(name='body'),
}

/**
  * The signature algorithm in the request parameters must match the key type. The following table describes the mapping between signature algorithms and key types.  
  * | Algorithm | Key Spec |
  * | --------- | -------- |
  * | RSA_PKCS1_SHA_256 | RSA_2048 |
  * | RSA_PSS_SHA_256 | RSA_2048 |
  * | ECDSA_SHA_256 | EC_P256 |
  * | SM2DSA | EC_SM2 |
  * In this example, the certificate whose ID is `12345678-1234-1234-1234-12345678****` and the signature algorithm `ECDSA_SHA_256` are used to verify the digital signature `ZOyIygCyaOW6Gj****MlNKiuyjfzw=` of the raw data `VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=`.
  *
  * @param request CertificatePublicKeyVerifyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CertificatePublicKeyVerifyResponse
 */
async function certificatePublicKeyVerifyWithOptions(request: CertificatePublicKeyVerifyRequest, runtime: Util.RuntimeOptions): CertificatePublicKeyVerifyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  if (!Util.isUnset(request.messageType)) {
    query['MessageType'] = request.messageType;
  }
  if (!Util.isUnset(request.signatureValue)) {
    query['SignatureValue'] = request.signatureValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CertificatePublicKeyVerify',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The signature algorithm in the request parameters must match the key type. The following table describes the mapping between signature algorithms and key types.  
  * | Algorithm | Key Spec |
  * | --------- | -------- |
  * | RSA_PKCS1_SHA_256 | RSA_2048 |
  * | RSA_PSS_SHA_256 | RSA_2048 |
  * | ECDSA_SHA_256 | EC_P256 |
  * | SM2DSA | EC_SM2 |
  * In this example, the certificate whose ID is `12345678-1234-1234-1234-12345678****` and the signature algorithm `ECDSA_SHA_256` are used to verify the digital signature `ZOyIygCyaOW6Gj****MlNKiuyjfzw=` of the raw data `VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=`.
  *
  * @param request CertificatePublicKeyVerifyRequest
  * @return CertificatePublicKeyVerifyResponse
 */
async function certificatePublicKeyVerify(request: CertificatePublicKeyVerifyRequest): CertificatePublicKeyVerifyResponse {
  var runtime = new Util.RuntimeOptions{};
  return certificatePublicKeyVerifyWithOptions(request, runtime);
}

model CreateAliasRequest {
  aliasName?: string(name='AliasName', description='The alias of the CMK.

The alias must be 1 to 255 characters in length and must contain the prefix `alias/`. The alias cannot be prefixed with the reserved word `alias/acs`.', example='alias/example'),
  keyId?: string(name='KeyId', description='The ID of the CMK. The ID must be globally unique.', example='7906979c-8e06-46a2-be2d-68e3ccbc****'),
}

model CreateAliasResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='1d2baaf3-d357-46c2-832e-13560c2bd9cd'),
}

model CreateAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAliasResponseBody(name='body'),
}

/**
  * *   Each alias can be bound to only one CMK at a time.
  * *   The aliases of CMKs in the same region must be unique.
  * In this topic, an alias named `alias/example` is created for a CMK named `7906979c-8e06-46a2-be2d-68e3ccbc****`.
  *
  * @param request CreateAliasRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateAliasResponse
 */
async function createAliasWithOptions(request: CreateAliasRequest, runtime: Util.RuntimeOptions): CreateAliasResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlias',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   Each alias can be bound to only one CMK at a time.
  * *   The aliases of CMKs in the same region must be unique.
  * In this topic, an alias named `alias/example` is created for a CMK named `7906979c-8e06-46a2-be2d-68e3ccbc****`.
  *
  * @param request CreateAliasRequest
  * @return CreateAliasResponse
 */
async function createAlias(request: CreateAliasRequest): CreateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAliasWithOptions(request, runtime);
}

model CreateCertificateRequest {
  exportablePrivateKey?: boolean(name='ExportablePrivateKey', description='Specifies whether the private key of the certificate can be exported for use. Valid values:

*   true: The private key of the certificate can be exported for use. This is the default value.
*   false: The private key of the certificate cannot be exported for use. We recommend that you set this parameter to false to protect keys with a higher security level.', example='true'),
  keySpec?: string(name='KeySpec', description='The type of the key. Valid values:

*   RSA\\_2048
*   EC_P256
*   EC_SM2', example='RSA_2048'),
  subject?: string(name='Subject', description='The certificate subject, which is the owner of the certificate.

Specify the value in the distinguished name (DN) format, as defined in [RFC 2253](https://tools.ietf.org/html/rfc2253?spm=a2c4g.11186623.2.13.265f1a1cGFCn3Q). A DN is a sequence of relative distinguished names (RDNs).

RDNs are key-value pairs in the format of `attribute1=value1,attribute2=value2`. Separate multiple RDNs with commas (,).

The Subject parameter consists of the following fields:

*   CN: required. The name of the certificate subject.
*   C: required. The two-character country or region code in the [ISO 3166-1](https://www.iso.org/obp/ui/#search/code/) standard. For example, CN indicates China.
*   O: required. The legal name of the enterprise, company, organization, or institution.
*   OU: required. The name of the department.
*   ST: optional. The name of the province, municipality, autonomous region, or special administrative region.
*   L: optional. The name of the city.', example='CN=userName,OU=kms,O=aliyun,C=CN'),
  subjectAlternativeNames?: map[string]any(name='SubjectAlternativeNames', description='The subject alternative names.

A domain name list is supported. A maximum of 10 domain names are supported.', example='["test1.example.com","test2.example.com"]'),
}

model CreateCertificateShrinkRequest {
  exportablePrivateKey?: boolean(name='ExportablePrivateKey', description='Specifies whether the private key of the certificate can be exported for use. Valid values:

*   true: The private key of the certificate can be exported for use. This is the default value.
*   false: The private key of the certificate cannot be exported for use. We recommend that you set this parameter to false to protect keys with a higher security level.', example='true'),
  keySpec?: string(name='KeySpec', description='The type of the key. Valid values:

*   RSA\\_2048
*   EC_P256
*   EC_SM2', example='RSA_2048'),
  subject?: string(name='Subject', description='The certificate subject, which is the owner of the certificate.

Specify the value in the distinguished name (DN) format, as defined in [RFC 2253](https://tools.ietf.org/html/rfc2253?spm=a2c4g.11186623.2.13.265f1a1cGFCn3Q). A DN is a sequence of relative distinguished names (RDNs).

RDNs are key-value pairs in the format of `attribute1=value1,attribute2=value2`. Separate multiple RDNs with commas (,).

The Subject parameter consists of the following fields:

*   CN: required. The name of the certificate subject.
*   C: required. The two-character country or region code in the [ISO 3166-1](https://www.iso.org/obp/ui/#search/code/) standard. For example, CN indicates China.
*   O: required. The legal name of the enterprise, company, organization, or institution.
*   OU: required. The name of the department.
*   ST: optional. The name of the province, municipality, autonomous region, or special administrative region.
*   L: optional. The name of the city.', example='CN=userName,OU=kms,O=aliyun,C=CN'),
  subjectAlternativeNamesShrink?: string(name='SubjectAlternativeNames', description='The subject alternative names.

A domain name list is supported. A maximum of 10 domain names are supported.', example='["test1.example.com","test2.example.com"]'),
}

model CreateCertificateResponseBody = {
  arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the certificate.', example='acs:kms:cn-hangzhou:154035569884****:certificate/98e85c94-52d0-40c9-b3b2-afda52f4****'),
  certificateId?: string(name='CertificateId', description='The ID of the certificate. It is the globally unique identifier (GUID) of the certificate in Certificates Manager.', example='9a28de48-8d8b-484d-a766-dec4****'),
  csr?: string(name='Csr', description='The CSR in the PEM format.', example='-----BEGIN CERTIFICATE REQUEST-----\\nMIIDADCCAegCAQAwgboxCzAJBgNVBAYTAkNOMREwDwYDVQQIEwhaaGVqaWFuZzER\\n****\\nmkj4rg==\\n-----END CERTIFICATE REQUEST-----\\n'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='15a735a1-8fe6-45cc-a64c-3c4ff839334e'),
}

model CreateCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCertificateResponseBody(name='body'),
}

/**
  * To create a certificate, you must specify the type of the asymmetric key. Certificates Manager generates a private key and returns a certificate signing request (CSR). Submit the CSR in the Privacy Enhanced Mail (PEM) format to a certificate authority (CA) to obtain the formal certificate and certificate chain. Then, call the [UploadCertificate](~~212136~~) operation to import the certificate into Certificates Manager.
  * In this example, a certificate is created and the CSR is obtained.
  *
  * @param tmpReq CreateCertificateRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateCertificateResponse
 */
async function createCertificateWithOptions(tmpReq: CreateCertificateRequest, runtime: Util.RuntimeOptions): CreateCertificateResponse {
  Util.validateModel(tmpReq);
  var request = new CreateCertificateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.subjectAlternativeNames)) {
    request.subjectAlternativeNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.subjectAlternativeNames, 'SubjectAlternativeNames', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.exportablePrivateKey)) {
    query['ExportablePrivateKey'] = request.exportablePrivateKey;
  }
  if (!Util.isUnset(request.keySpec)) {
    query['KeySpec'] = request.keySpec;
  }
  if (!Util.isUnset(request.subject)) {
    query['Subject'] = request.subject;
  }
  if (!Util.isUnset(request.subjectAlternativeNamesShrink)) {
    query['SubjectAlternativeNames'] = request.subjectAlternativeNamesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCertificate',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * To create a certificate, you must specify the type of the asymmetric key. Certificates Manager generates a private key and returns a certificate signing request (CSR). Submit the CSR in the Privacy Enhanced Mail (PEM) format to a certificate authority (CA) to obtain the formal certificate and certificate chain. Then, call the [UploadCertificate](~~212136~~) operation to import the certificate into Certificates Manager.
  * In this example, a certificate is created and the CSR is obtained.
  *
  * @param request CreateCertificateRequest
  * @return CreateCertificateResponse
 */
async function createCertificate(request: CreateCertificateRequest): CreateCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCertificateWithOptions(request, runtime);
}

model CreateKeyRequest {
  DKMSInstanceId?: string(name='DKMSInstanceId', description='The type of the CMK. Valid values:

*   Aliyun_AES\\_256
*   Aliyun_AES\\_128
*   Aliyun_AES\\_192
*   Aliyun_SM4
*   RSA\\_2048
*   RSA\\_3072
*   EC_P256
*   EC_P256K
*   EC_SM2

> * The default type of the CMK is Aliyun\\_AES\\_256.
> * Only Dedicated KMS supports Aliyun\\_AES\\_128 and Aliyun\\_AES\\_192.', example='kst-bjj62d8f5e0sgtx8h****'),
  description?: string(name='Description', description='The operation that you want to perform. Set the value to **CreateKey**.', example='key description example'),
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation', description='The protection level of the CMK. Valid values:

*   SOFTWARE
*   HSM

Default value: SOFTWARE.

> * The value of this parameter is case-sensitive.
> * Assume that you set this parameter to HSM. If you set the Origin parameter to Aliyun_KMS, the CMK is created in a managed HSM. If you set the Origin parameter to EXTERNAL, you can import an external key into the managed HSM.', example='false'),
  keySpec?: string(name='KeySpec', description='The period of automatic key rotation. Specify the value in the integer\\[unit] format. Unit: d (day), h (hour), m (minute), or s (second). For example, you can use either 7d or 604800s to specify a seven-day period. The period can range from 7 days to 730 days.

>  If you set the EnableAutomaticRotation parameter to true, you must also specify this parameter. If you set the EnableAutomaticRotation parameter to false, you can leave this parameter unspecified.', example='Aliyun_AES_256'),
  keyUsage?: string(name='KeyUsage', description='The description of the CMK.

The description can be 0 to 8,192 characters in length.', example='ENCRYPT/DECRYPT'),
  origin?: string(name='Origin', description='The usage of the CMK. Valid values:

*   ENCRYPT/DECRYPT: encrypts or decrypts data.
*   SIGN/VERIFY: generates or verifies a digital signature.

If the CMK supports signature verification, the default value is SIGN/VERIFY. If the CMK does not support signature verification, the default value is ENCRYPT/DECRYPT.', example='Aliyun_KMS'),
  protectionLevel?: string(name='ProtectionLevel', description='The source of key material. Valid values:

*   Aliyun_KMS (default value)
*   EXTERNAL

> * The value of this parameter is case-sensitive.
> * If you set the KeySpec parameter to an asymmetric CMK type, you are not allowed to set the Origin parameter to EXTERNAL.
> * If you set the Origin parameter to EXTERNAL, you must import key material. For more information, see [Import key material](~~68523~~).', example='SOFTWARE'),
  rotationInterval?: string(name='RotationInterval', description='Specifies whether to enable automatic key rotation. Valid values:

*   true
*   false

Default value: false.

>  If the Origin parameter is set to EXTERNAL or the KeySpec parameter is set to an asymmetric CMK type, automatic key rotation is not supported.', example='365d'),
  tags?: string(name='Tags'),
}

model CreateKeyResponseBody = {
  keyMetadata?: {
    arn?: string(name='Arn', description='The period of automatic key rotation. Unit: seconds. The value is in the format of an integer followed by the letter s. For example, if the rotation period is seven days, this parameter is set to 604800s. This value is returned only when the value of the AutomaticRotation parameter is Enabled or Suspended.', example='acs:kms:cn-qingdao:154035569884****:key/d6bee1cb-2e14-4277-ba6b-73786b21****'),
    automaticRotation?: string(name='AutomaticRotation', description='The time when the key material expires. The time is displayed in UTC.

If this parameter value is empty, the key material does not expire.', example='Disabled'),
    creationDate?: string(name='CreationDate', description='The usage of the CMK.', example='2022-03-25T10:42:40Z'),
    creator?: string(name='Creator', description='The Alibaba Cloud Resource Name (ARN) of the CMK.', example='154035569884****'),
    DKMSInstanceId?: string(name='DKMSInstanceId', description='The date and time when the CMK was created. The time is displayed in UTC.', example='kst-bjj62d8f5e0sgtx8h****'),
    deleteDate?: string(name='DeleteDate', description='The time when the last rotation was performed. The time is displayed in UTC.

For a new CMK, this parameter value is the time when the initial version of the CMK was generated.', example='2022-07-06T18:22:03Z'),
    description?: string(name='Description', description='The ID of the current primary key version of the symmetric CMK.

> * The primary key version of a symmetric CMK is an active encryption key. KMS uses the primary key version of a specified CMK to encrypt data.
> * This parameter is unavailable for asymmetric CMKs.', example='key description example'),
    keyId?: string(name='KeyId', description='The metadata of the CMK.', example='d6bee1cb-2e14-4277-ba6b-73786b21****'),
    keySpec?: string(name='KeySpec', description='The description of the CMK.', example='Aliyun_AES_256'),
    keyState?: string(name='KeyState', description='The time when the next rotation will be performed.

>  This value is returned only when the value of the AutomaticRotation parameter is Enabled or Suspended.', example='Enabled'),
    keyUsage?: string(name='KeyUsage', description='The protection level of the CMK.', example='ENCRYPT/DECRYPT'),
    lastRotationDate?: string(name='LastRotationDate', description='The creator of the CMK.', example='2022-06-06T18:22:03Z'),
    materialExpireTime?: string(name='MaterialExpireTime', description='The source of the key material for the CMK.', example='2022-07-06T18:22:03Z'),
    nextRotationDate?: string(name='NextRotationDate', description='The ID of the CMK. The ID must be globally unique.', example='2022-07-06T18:22:03Z'),
    origin?: string(name='Origin', description='The type of the CMK.', example='Aliyun_KMS'),
    primaryKeyVersion?: string(name='PrimaryKeyVersion', description='The time when the CMK is scheduled for deletion.

For more information, see [ScheduleKeyDeletion](~~44196~~).

>  This value is returned only when the value of the KeyState parameter is PendingDeletion.', example='7ce1d081-06cb-42e6-aab6-5c5de030****'),
    protectionLevel?: string(name='ProtectionLevel', description='Indicates whether automatic key rotation is enabled. Valid values:

*   Enabled: Automatic key rotation is enabled.
*   Disabled: Automatic key rotation is disabled.
*   Suspended: Automatic key rotation is suspended. For more information, see [Automatic key rotation](~~134270~~).

>  Automatic key rotation is available only for symmetric CMKs.', example='SOFTWARE'),
    rotationInterval?: string(name='RotationInterval', description='The status of the CMK.

For more information, see [Impact of CMK status on API operations](~~44211~~).', example='31536000s'),
  }(name='KeyMetadata', description='The ID of the request, which is used to locate and troubleshoot issues.'),
  requestId?: string(name='RequestId', description='The ID of the dedicated KMS instance.', example='36c7e41a-3f2c-45f7-9bdd-d1dc1e7e7e06'),
}

model CreateKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateKeyResponseBody(name='body'),
}

/**
  * Creates a customer master key (CMK).
  *
  * @param request CreateKeyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateKeyResponse
 */
async function createKeyWithOptions(request: CreateKeyRequest, runtime: Util.RuntimeOptions): CreateKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DKMSInstanceId)) {
    query['DKMSInstanceId'] = request.DKMSInstanceId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.enableAutomaticRotation)) {
    query['EnableAutomaticRotation'] = request.enableAutomaticRotation;
  }
  if (!Util.isUnset(request.keySpec)) {
    query['KeySpec'] = request.keySpec;
  }
  if (!Util.isUnset(request.keyUsage)) {
    query['KeyUsage'] = request.keyUsage;
  }
  if (!Util.isUnset(request.origin)) {
    query['Origin'] = request.origin;
  }
  if (!Util.isUnset(request.protectionLevel)) {
    query['ProtectionLevel'] = request.protectionLevel;
  }
  if (!Util.isUnset(request.rotationInterval)) {
    query['RotationInterval'] = request.rotationInterval;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateKey',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Creates a customer master key (CMK).
  *
  * @param request CreateKeyRequest
  * @return CreateKeyResponse
 */
async function createKey(request: CreateKeyRequest): CreateKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createKeyWithOptions(request, runtime);
}

model CreateKeyVersionRequest {
  keyId?: string(name='KeyId', description='The ID of the CMK. The ID must be globally unique.

>  You can also set the value to an alias that is bound to the CMK. For more information, see [Overview of aliases](~~68522~~).', example='0b30658a-ed1a-4922-b8f7-a673ca9c****'),
}

model CreateKeyVersionResponseBody = {
  keyVersion?: {
    creationDate?: string(name='CreationDate', description='The date and time when the version was created. The time is displayed in UTC.', example='2019-08-02T10:38:27Z'),
    keyId?: string(name='KeyId', description='The ID of the CMK. The ID must be globally unique.', example='0b30658a-ed1a-4922-b8f7-a673ca9c****'),
    keyVersionId?: string(name='KeyVersionId', description='The ID of the version.', example='c0a3d5dc-0b47-4199-a050-b289349a****'),
  }(name='KeyVersion', description='The metadata of the version.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='b96f250a-4b75-498c-91be-22c6928f85be'),
}

model CreateKeyVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateKeyVersionResponseBody(name='body'),
}

/**
  * *   You can create a version only for an asymmetric CMK that is in the Enabled state. You can call the [CreateKey](~~28947~~) operation to create an asymmetric CMK and the [DescribeKey](~~28952~~) operation to query the status of the CMK. The status is specified by the KeyState parameter.
  * *   The minimum interval for creating a version of the same CMK is seven days. You can call the [DescribeKey](~~28952~~) operation to query the time when the last version of a CMK was created. The time is specified by the LastRotationDate parameter.
  * *   If a CMK is in a private key store, you cannot create a version for the CMK.
  * *   You can create a maximum of 50 versions for a CMK in the same region.
  * You can create a version for the CMK whose ID is `0b30658a-ed1a-4922-b8f7-a673ca9c****` by using the parameter settings provided in this topic.
  *
  * @param request CreateKeyVersionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateKeyVersionResponse
 */
async function createKeyVersionWithOptions(request: CreateKeyVersionRequest, runtime: Util.RuntimeOptions): CreateKeyVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateKeyVersion',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   You can create a version only for an asymmetric CMK that is in the Enabled state. You can call the [CreateKey](~~28947~~) operation to create an asymmetric CMK and the [DescribeKey](~~28952~~) operation to query the status of the CMK. The status is specified by the KeyState parameter.
  * *   The minimum interval for creating a version of the same CMK is seven days. You can call the [DescribeKey](~~28952~~) operation to query the time when the last version of a CMK was created. The time is specified by the LastRotationDate parameter.
  * *   If a CMK is in a private key store, you cannot create a version for the CMK.
  * *   You can create a maximum of 50 versions for a CMK in the same region.
  * You can create a version for the CMK whose ID is `0b30658a-ed1a-4922-b8f7-a673ca9c****` by using the parameter settings provided in this topic.
  *
  * @param request CreateKeyVersionRequest
  * @return CreateKeyVersionResponse
 */
async function createKeyVersion(request: CreateKeyVersionRequest): CreateKeyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createKeyVersionWithOptions(request, runtime);
}

model CreateSecretRequest {
  DKMSInstanceId?: string(name='DKMSInstanceId', description='The version number of the secret.', example='kst-bjj62d8f5e0sgtx8h****'),
  description?: string(name='Description', description='Specifies whether to enable automatic rotation. Valid values:

*   true: specifies to enable automatic rotation.
*   false: specifies to disable automatic rotation. This is the default value.

>  This parameter is valid if you set the SecretType parameter to Rds, RAMCredentials, or ECS.', example='mydbinfo'),
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation', description='Indicates whether automatic rotation is enabled. Valid values:

*   Enabled: indicates that automatic rotation is enabled.
*   Disabled: indicates that automatic rotation is disabled.
*   Invalid: indicates that the status of automatic rotation is abnormal. In this case, Secrets Manager cannot automatically rotate the secret.

>  This parameter is returned if you set the SecretType parameter to Rds, RAMCredentials, or ECS.', example='true'),
  encryptionKeyId?: string(name='EncryptionKeyId', description='The description of the secret.', example='00aa68af-2c02-4f68-95fe-3435d330****'),
  extendedConfig?: map[string]any(name='ExtendedConfig', description='The ID of the request, which is used to locate and troubleshoot issues.', example='{"SecretSubType":"SingleUser", "DBInstanceId":"rm-bp1b3dd3a506e****" ,"CustomData":{}}'),
  rotationInterval?: string(name='RotationInterval', description='The name of the secret.', example='30d'),
  secretData?: string(name='SecretData', description='The tags of the secret.', example='The type of the secret. Valid values:

*   Generic: specifies a generic secret.
*   Rds: specifies a managed ApsaraDB RDS secret.
*   RAMCredentials: specifies a managed RAM secret.
*   ECS: specifies a managed ECS secret.'),
  secretDataType?: string(name='SecretDataType', description='The extended configuration of the secret. This parameter specifies the properties of the secret of the specific type. The description can be up to 1,024 characters in length.

*   If you set the SecretType parameter to Generic, you do not need to configure this parameter.

*   If you set the SecretType parameter to Rds, configure the following fields for the ExtendedConfig parameter:

    *   SecretSubType: required. The subtype of the secret. Valid values:

        *   SingleUser: Secrets Manager manages the ApsaraDB RDS secret in single-account mode. When the secret is rotated, the password of the specified account is reset to a new random password.
        *   DoubleUsers: Secrets Manager manages the ApsaraDB RDS secret in dual-account mode. One account is referenced by the ACSCurrent version, and the other account is referenced by the ACSPrevious version. When the secret is rotated, the password of the account referenced by the ACSPrevious version is reset to a new random password. Then, Secrets Manager switches the referenced accounts between the ACSCurrent and ACSPrevious versions.

    *   DBInstanceId: required. The ApsaraDB RDS instance to which the ApsaraDB RDS account belongs.

    *   CustomData: optional. The custom data. The value is a collection of key-value pairs in the JSON format. Up to 10 key-value pairs can be specified. Separate multiple key-value pairs with commas (,). Example: `{"Key1": "v1", "fds":"fdsf"}`. The default value is a pair of empty braces (`{}`).

*   If you set the SecretType parameter to RAMCredentials, configure the following fields for the ExtendedConfig parameter:

    *   SecretSubType: required. The subtype of the secret. Set the value to RamUserAccessKey.
    *   UserName: required. The name of the RAM user.
    *   CustomData: optional. The custom data. The value is a collection of key-value pairs in the JSON format. Up to 10 key-value pairs can be specified. Separate multiple key-value pairs with commas (,). The default value is a pair of empty braces (`{}`).

*   If you set the SecretType parameter to ECS, configure the following fields for the ExtendedConfig parameter:

    *   SecretSubType: required. The subtype of the secret. Valid values:

        *   Password: the password that is used to log on to the ECS instance.
        *   SSHKey: the SSH public key and private key that are used to log on to the ECS instance.

    *   RegionId: required. The ID of the region in which the ECS instance resides.

    *   InstanceId: required. The ID of the ECS instance.

    *   CustomData: optional. The custom data. The value is a collection of key-value pairs in the JSON format. Up to 10 key-value pairs can be specified. Separate multiple key-value pairs with commas (,). The default value is a pair of empty braces (`{}`).

>  This parameter is required if you set the SecretType parameter to Rds, RAMCredentials, or ECS.', example='text'),
  secretName?: string(name='SecretName', description='The value of the secret that you want to create. Secrets Manager encrypts the secret value and stores the encrypted value in the initial version.

*   If you set the SecretType parameter to Generic that indicates a generic secret, you can customize the secret value.

*   If you set the SecretType parameter to Rds that indicates a managed ApsaraDB RDS secret, the secret value must be in the format of `{"Accounts":[{"AccountName":"","AccountPassword":""}]}`. In the preceding format, `AccountName` indicates the username of the account that is used to connect to your ApsaraDB RDS instance, and `AccountPassword` specifies the password of the account.

*   If you set the SecretType parameter to RAMCredentials that indicates a managed RAM secret, the secret value must be in the format of `{"AccessKeys":[{"AccessKeyId":"","AccessKeySecret":"",}]}`. In the preceding format, `AccessKeyId` indicates the AccessKey ID of the RAM user and `AccessKeySecret` specifies the AccessKey secret of the RAM user. You must specify all the AccessKey pairs of the RAM user.

*   If you set the SecretType parameter to ECS that indicates a managed ECS secret, the secret value must be in one of the following formats:

    *   `{"UserName":"","Password": ""}`: In the format, `UserName` specifies the username that is used to log on to the ECS instance, and `Password` specifies the password that is used to log on to the ECS instance.
    *   `{"UserName":"","PublicKey": "", "PrivateKey": ""}`: In the format, `PublicKey` indicates the SSH public key that is used to log on to the ECS instance, and `PrivateKey` specifies the SSH private key that is used to log on to the ECS instance.', example='mydbconninfo'),
  secretType?: string(name='SecretType', description='The ID of the dedicated KMS instance.', example='Rds'),
  tags?: string(name='Tags', description='The interval for automatic rotation. Valid values: 6 hours to 8,760 hours (365 days).

The value is in the `integer[unit]` format.

The unit can be d (day), h (hour), m (minute), or s (second). For example, both 7d and 604800s indicate a seven-day interval.

>  This parameter is required if you set the EnableAutomaticRotation parameter to true. This parameter is ignored if you set the EnableAutomaticRotation parameter to false or if the EnableAutomaticRotation parameter is not configured.', example='[{\\"TagKey\\":\\"key1\\",\\"TagValue\\":\\"val1\\"},{\\"TagKey\\":\\"key2\\",\\"TagValue\\":\\"val2\\"}]'),
  versionId?: string(name='VersionId', description='The type of the secret value. Valid values:

*   text
*   binary

>  If you set the SecretType parameter to Rds, RAMCredentials, or ECS, the SecretDataType parameter must be set to text.', example='v1'),
}

model CreateSecretShrinkRequest {
  DKMSInstanceId?: string(name='DKMSInstanceId', description='The version number of the secret.', example='kst-bjj62d8f5e0sgtx8h****'),
  description?: string(name='Description', description='Specifies whether to enable automatic rotation. Valid values:

*   true: specifies to enable automatic rotation.
*   false: specifies to disable automatic rotation. This is the default value.

>  This parameter is valid if you set the SecretType parameter to Rds, RAMCredentials, or ECS.', example='mydbinfo'),
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation', description='Indicates whether automatic rotation is enabled. Valid values:

*   Enabled: indicates that automatic rotation is enabled.
*   Disabled: indicates that automatic rotation is disabled.
*   Invalid: indicates that the status of automatic rotation is abnormal. In this case, Secrets Manager cannot automatically rotate the secret.

>  This parameter is returned if you set the SecretType parameter to Rds, RAMCredentials, or ECS.', example='true'),
  encryptionKeyId?: string(name='EncryptionKeyId', description='The description of the secret.', example='00aa68af-2c02-4f68-95fe-3435d330****'),
  extendedConfigShrink?: string(name='ExtendedConfig', description='The ID of the request, which is used to locate and troubleshoot issues.', example='{"SecretSubType":"SingleUser", "DBInstanceId":"rm-bp1b3dd3a506e****" ,"CustomData":{}}'),
  rotationInterval?: string(name='RotationInterval', description='The name of the secret.', example='30d'),
  secretData?: string(name='SecretData', description='The tags of the secret.', example='The type of the secret. Valid values:

*   Generic: specifies a generic secret.
*   Rds: specifies a managed ApsaraDB RDS secret.
*   RAMCredentials: specifies a managed RAM secret.
*   ECS: specifies a managed ECS secret.'),
  secretDataType?: string(name='SecretDataType', description='The extended configuration of the secret. This parameter specifies the properties of the secret of the specific type. The description can be up to 1,024 characters in length.

*   If you set the SecretType parameter to Generic, you do not need to configure this parameter.

*   If you set the SecretType parameter to Rds, configure the following fields for the ExtendedConfig parameter:

    *   SecretSubType: required. The subtype of the secret. Valid values:

        *   SingleUser: Secrets Manager manages the ApsaraDB RDS secret in single-account mode. When the secret is rotated, the password of the specified account is reset to a new random password.
        *   DoubleUsers: Secrets Manager manages the ApsaraDB RDS secret in dual-account mode. One account is referenced by the ACSCurrent version, and the other account is referenced by the ACSPrevious version. When the secret is rotated, the password of the account referenced by the ACSPrevious version is reset to a new random password. Then, Secrets Manager switches the referenced accounts between the ACSCurrent and ACSPrevious versions.

    *   DBInstanceId: required. The ApsaraDB RDS instance to which the ApsaraDB RDS account belongs.

    *   CustomData: optional. The custom data. The value is a collection of key-value pairs in the JSON format. Up to 10 key-value pairs can be specified. Separate multiple key-value pairs with commas (,). Example: `{"Key1": "v1", "fds":"fdsf"}`. The default value is a pair of empty braces (`{}`).

*   If you set the SecretType parameter to RAMCredentials, configure the following fields for the ExtendedConfig parameter:

    *   SecretSubType: required. The subtype of the secret. Set the value to RamUserAccessKey.
    *   UserName: required. The name of the RAM user.
    *   CustomData: optional. The custom data. The value is a collection of key-value pairs in the JSON format. Up to 10 key-value pairs can be specified. Separate multiple key-value pairs with commas (,). The default value is a pair of empty braces (`{}`).

*   If you set the SecretType parameter to ECS, configure the following fields for the ExtendedConfig parameter:

    *   SecretSubType: required. The subtype of the secret. Valid values:

        *   Password: the password that is used to log on to the ECS instance.
        *   SSHKey: the SSH public key and private key that are used to log on to the ECS instance.

    *   RegionId: required. The ID of the region in which the ECS instance resides.

    *   InstanceId: required. The ID of the ECS instance.

    *   CustomData: optional. The custom data. The value is a collection of key-value pairs in the JSON format. Up to 10 key-value pairs can be specified. Separate multiple key-value pairs with commas (,). The default value is a pair of empty braces (`{}`).

>  This parameter is required if you set the SecretType parameter to Rds, RAMCredentials, or ECS.', example='text'),
  secretName?: string(name='SecretName', description='The value of the secret that you want to create. Secrets Manager encrypts the secret value and stores the encrypted value in the initial version.

*   If you set the SecretType parameter to Generic that indicates a generic secret, you can customize the secret value.

*   If you set the SecretType parameter to Rds that indicates a managed ApsaraDB RDS secret, the secret value must be in the format of `{"Accounts":[{"AccountName":"","AccountPassword":""}]}`. In the preceding format, `AccountName` indicates the username of the account that is used to connect to your ApsaraDB RDS instance, and `AccountPassword` specifies the password of the account.

*   If you set the SecretType parameter to RAMCredentials that indicates a managed RAM secret, the secret value must be in the format of `{"AccessKeys":[{"AccessKeyId":"","AccessKeySecret":"",}]}`. In the preceding format, `AccessKeyId` indicates the AccessKey ID of the RAM user and `AccessKeySecret` specifies the AccessKey secret of the RAM user. You must specify all the AccessKey pairs of the RAM user.

*   If you set the SecretType parameter to ECS that indicates a managed ECS secret, the secret value must be in one of the following formats:

    *   `{"UserName":"","Password": ""}`: In the format, `UserName` specifies the username that is used to log on to the ECS instance, and `Password` specifies the password that is used to log on to the ECS instance.
    *   `{"UserName":"","PublicKey": "", "PrivateKey": ""}`: In the format, `PublicKey` indicates the SSH public key that is used to log on to the ECS instance, and `PrivateKey` specifies the SSH private key that is used to log on to the ECS instance.', example='mydbconninfo'),
  secretType?: string(name='SecretType', description='The ID of the dedicated KMS instance.', example='Rds'),
  tags?: string(name='Tags', description='The interval for automatic rotation. Valid values: 6 hours to 8,760 hours (365 days).

The value is in the `integer[unit]` format.

The unit can be d (day), h (hour), m (minute), or s (second). For example, both 7d and 604800s indicate a seven-day interval.

>  This parameter is required if you set the EnableAutomaticRotation parameter to true. This parameter is ignored if you set the EnableAutomaticRotation parameter to false or if the EnableAutomaticRotation parameter is not configured.', example='[{\\"TagKey\\":\\"key1\\",\\"TagValue\\":\\"val1\\"},{\\"TagKey\\":\\"key2\\",\\"TagValue\\":\\"val2\\"}]'),
  versionId?: string(name='VersionId', description='The type of the secret value. Valid values:

*   text
*   binary

>  If you set the SecretType parameter to Rds, RAMCredentials, or ECS, the SecretDataType parameter must be set to text.', example='v1'),
}

model CreateSecretResponseBody = {
  arn?: string(name='Arn', example='acs:kms:cn-hangzhou:154035569884****:secret/mydbconninfo'),
  automaticRotation?: string(name='AutomaticRotation', description='The type of the secret. Valid values:

*   Generic: indicates a generic secret.
*   Rds: indicates a managed ApsaraDB RDS secret.
*   RAMCredentials: indicates a managed RAM secret.
*   ECS: indicates a managed ECS secret.', example='Enabled'),
  DKMSInstanceId?: string(name='DKMSInstanceId', example='kst-bjj62d8f5e0sgtx8h****'),
  extendedConfig?: string(name='ExtendedConfig', example='{\\"SecretSubType\\":\\"SingleUser\\", \\"DBInstanceId\\":\\"rm-uf667446pc955****\\",  \\"CustomData\\":{} }'),
  nextRotationDate?: string(name='NextRotationDate', description='The extended configuration of the secret.

>  This parameter is returned if you set the SecretType parameter to Rds, RAMCredentials, or ECS.', example='2022-07-06T18:22:03Z'),
  requestId?: string(name='RequestId', description='The time when the next rotation will be performed.

>  This parameter is returned if automatic rotation is enabled.', example='3bf02f7a-015b-4f93-be0f-cc043fda2dd3'),
  rotationInterval?: string(name='RotationInterval', example='604800s'),
  secretName?: string(name='SecretName', description='The interval for automatic rotation.

The value is in the `integer[unit]` format. The value of the `unit` field is fixed as s. For example, if the value is 604800s, automatic rotation is performed at a 7-day interval.

>  This parameter is returned if automatic rotation is enabled.', example='mydbconninfo'),
  secretType?: string(name='SecretType', description='The ID of the dedicated KMS instance.', example='Rds'),
  versionId?: string(name='VersionId', description='The Alibaba Cloud Resource Name (ARN) of the secret.', example='v1'),
}

model CreateSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSecretResponseBody(name='body'),
}

/**
  * The name of the secret.
  * The value must be 1 to 64 characters in length and can contain letters, digits, underscores (\\_), forward slashes (/), plus signs (+), equal signs (=), periods (.), hyphens (-), and at signs (@). The following list describes the name requirements for different types of secrets:
  * *   If the SecretType parameter is set to Generic or Rds, the name cannot start with `acs/`.
  * *   If the SecretType parameter is set to RAMCredentials, set the SecretName parameter to `$Auto`. In this case, KMS automatically generates a secret name that starts with `acs/ram/user/`. The name includes the display name of RAM user.
  * *   If the SecretType parameter is set to ECS, the name must start with `acs/ecs/`.
  *
  * @param tmpReq CreateSecretRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateSecretResponse
 */
async function createSecretWithOptions(tmpReq: CreateSecretRequest, runtime: Util.RuntimeOptions): CreateSecretResponse {
  Util.validateModel(tmpReq);
  var request = new CreateSecretShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.extendedConfig)) {
    request.extendedConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extendedConfig, 'ExtendedConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.DKMSInstanceId)) {
    query['DKMSInstanceId'] = request.DKMSInstanceId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.enableAutomaticRotation)) {
    query['EnableAutomaticRotation'] = request.enableAutomaticRotation;
  }
  if (!Util.isUnset(request.encryptionKeyId)) {
    query['EncryptionKeyId'] = request.encryptionKeyId;
  }
  if (!Util.isUnset(request.extendedConfigShrink)) {
    query['ExtendedConfig'] = request.extendedConfigShrink;
  }
  if (!Util.isUnset(request.rotationInterval)) {
    query['RotationInterval'] = request.rotationInterval;
  }
  if (!Util.isUnset(request.secretData)) {
    query['SecretData'] = request.secretData;
  }
  if (!Util.isUnset(request.secretDataType)) {
    query['SecretDataType'] = request.secretDataType;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.secretType)) {
    query['SecretType'] = request.secretType;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSecret',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The name of the secret.
  * The value must be 1 to 64 characters in length and can contain letters, digits, underscores (\\_), forward slashes (/), plus signs (+), equal signs (=), periods (.), hyphens (-), and at signs (@). The following list describes the name requirements for different types of secrets:
  * *   If the SecretType parameter is set to Generic or Rds, the name cannot start with `acs/`.
  * *   If the SecretType parameter is set to RAMCredentials, set the SecretName parameter to `$Auto`. In this case, KMS automatically generates a secret name that starts with `acs/ram/user/`. The name includes the display name of RAM user.
  * *   If the SecretType parameter is set to ECS, the name must start with `acs/ecs/`.
  *
  * @param request CreateSecretRequest
  * @return CreateSecretResponse
 */
async function createSecret(request: CreateSecretRequest): CreateSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSecretWithOptions(request, runtime);
}

model DecryptRequest {
  ciphertextBlob?: string(name='CiphertextBlob', description='The ciphertext that you want to decrypt.

You can generate the ciphertext by calling the following operations:

*   [GenerateDataKey](~~28948~~)
*   [Encrypt](~~28949~~)
*   [GenerateDataKeyWithoutPlaintext](~~134043~~)', example='DZhOWVmZDktM2QxNi00ODk0LWJkNGYtMWZjNDNmM2YyYWJmaaSl+TztSIMe43nbTH/Z1Wr4XfLftKhAciUmDQXuMRl4WTvKhxjMThjK****'),
  encryptionContext?: map[string]any(name='EncryptionContext', description='The JSON string that consists of key-value pairs.

>  If you specify the EncryptionContext parameter when you call the [GenerateDataKey](~~28948~~), [Encrypt](~~28949~~), or [GenerateDataKeyWithoutPlaintext](~~134043~~) operation, you must specify the same context when you call the Decrypt operation. For more information, see [EncryptionContext](~~42975~~).', example='{"Example":"Example"}'),
}

model DecryptShrinkRequest {
  ciphertextBlob?: string(name='CiphertextBlob', description='The ciphertext that you want to decrypt.

You can generate the ciphertext by calling the following operations:

*   [GenerateDataKey](~~28948~~)
*   [Encrypt](~~28949~~)
*   [GenerateDataKeyWithoutPlaintext](~~134043~~)', example='DZhOWVmZDktM2QxNi00ODk0LWJkNGYtMWZjNDNmM2YyYWJmaaSl+TztSIMe43nbTH/Z1Wr4XfLftKhAciUmDQXuMRl4WTvKhxjMThjK****'),
  encryptionContextShrink?: string(name='EncryptionContext', description='The JSON string that consists of key-value pairs.

>  If you specify the EncryptionContext parameter when you call the [GenerateDataKey](~~28948~~), [Encrypt](~~28949~~), or [GenerateDataKeyWithoutPlaintext](~~134043~~) operation, you must specify the same context when you call the Decrypt operation. For more information, see [EncryptionContext](~~42975~~).', example='{"Example":"Example"}'),
}

model DecryptResponseBody = {
  keyId?: string(name='KeyId', description='The ID of the customer master key (CMK) that is used to decrypt the ciphertext.

It is the GUID of the CMK.', example='202b9877-5a25-46e3-a763-e20791b5****'),
  keyVersionId?: string(name='KeyVersionId', description='The ID of the CMK version that is used to decrypt the ciphertext.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
  plaintext?: string(name='Plaintext', description='The plaintext that is generated after decryption.', example='tRYXuCwgja12xxO1N/gZERDDCLw9doZEQiPDk/Bv****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='207596a2-36d3-4840-b1bd-f87044699bd7'),
}

model DecryptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DecryptResponseBody(name='body'),
}

async function decryptWithOptions(tmpReq: DecryptRequest, runtime: Util.RuntimeOptions): DecryptResponse {
  Util.validateModel(tmpReq);
  var request = new DecryptShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.ciphertextBlob)) {
    query['CiphertextBlob'] = request.ciphertextBlob;
  }
  if (!Util.isUnset(request.encryptionContextShrink)) {
    query['EncryptionContext'] = request.encryptionContextShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Decrypt',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function decrypt(request: DecryptRequest): DecryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return decryptWithOptions(request, runtime);
}

model DeleteAliasRequest {
  aliasName?: string(name='AliasName', description='The alias that you want to delete.

The value must be 1 to 255 characters in length and must include the alias/ prefix.', example='alias/example'),
}

model DeleteAliasResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='4c8ae23f-3a42-6791-a4ba-1faa77831c28'),
}

model DeleteAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAliasResponseBody(name='body'),
}

async function deleteAliasWithOptions(request: DeleteAliasRequest, runtime: Util.RuntimeOptions): DeleteAliasResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlias',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAlias(request: DeleteAliasRequest): DeleteAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAliasWithOptions(request, runtime);
}

model DeleteCertificateRequest {
  certificateId?: string(name='CertificateId', description='The ID of the certificate. It is the globally unique identifier (GUID) of the certificate in Alibaba Cloud Certificate Manager.', example='9a28de48-8d8b-484d-a766-dec4****'),
}

model DeleteCertificateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='d97f6c33-ca26-4de2-a580-0e2fd1c5bfb0'),
}

model DeleteCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCertificateResponseBody(name='body'),
}

/**
  * After the certificate and its private key and certificate chain are deleted, they cannot be restored. Proceed with caution.
  * In this example, the certificate whose ID is `9a28de48-8d8b-484d-a766-dec4****` and its private key and certificate chain are deleted.
  *
  * @param request DeleteCertificateRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteCertificateResponse
 */
async function deleteCertificateWithOptions(request: DeleteCertificateRequest, runtime: Util.RuntimeOptions): DeleteCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCertificate',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * After the certificate and its private key and certificate chain are deleted, they cannot be restored. Proceed with caution.
  * In this example, the certificate whose ID is `9a28de48-8d8b-484d-a766-dec4****` and its private key and certificate chain are deleted.
  *
  * @param request DeleteCertificateRequest
  * @return DeleteCertificateResponse
 */
async function deleteCertificate(request: DeleteCertificateRequest): DeleteCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCertificateWithOptions(request, runtime);
}

model DeleteKeyMaterialRequest {
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK.', example='1234abcd-12ab-34cd-56ef-12345678****'),
}

model DeleteKeyMaterialResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='4162a6af-bc99-40b3-a552-89dcc8aaf7c8'),
}

model DeleteKeyMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteKeyMaterialResponseBody(name='body'),
}

/**
  * This operation does not delete the CMK that is created by using the key material.
  * If the CMK is in the PendingDeletion state, the state of the CMK and the scheduled deletion time do not change after you call this operation. If the CMK is not in the PendingDeletion state, the state of the CMK changes to PendingImport after you call this operation.
  * After you delete the key material, you can upload only the same key material into the CMK.
  *
  * @param request DeleteKeyMaterialRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteKeyMaterialResponse
 */
async function deleteKeyMaterialWithOptions(request: DeleteKeyMaterialRequest, runtime: Util.RuntimeOptions): DeleteKeyMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteKeyMaterial',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation does not delete the CMK that is created by using the key material.
  * If the CMK is in the PendingDeletion state, the state of the CMK and the scheduled deletion time do not change after you call this operation. If the CMK is not in the PendingDeletion state, the state of the CMK changes to PendingImport after you call this operation.
  * After you delete the key material, you can upload only the same key material into the CMK.
  *
  * @param request DeleteKeyMaterialRequest
  * @return DeleteKeyMaterialResponse
 */
async function deleteKeyMaterial(request: DeleteKeyMaterialRequest): DeleteKeyMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteKeyMaterialWithOptions(request, runtime);
}

model DeleteSecretRequest {
  forceDeleteWithoutRecovery?: string(name='ForceDeleteWithoutRecovery', description='Specifies whether to forcibly delete the secret. If this parameter is set to true, the secret cannot be recovered.

Valid values:

*   **true**
*   **false** (default value)', example='false'),
  recoveryWindowInDays?: string(name='RecoveryWindowInDays', description='Specifies the recovery period of the secret if you do not forcibly delete it. Default value: 30. Unit: Days.', example='10'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='secret001'),
}

model DeleteSecretResponseBody = {
  plannedDeleteTime?: string(name='PlannedDeleteTime', description='The time when the secret is scheduled to be deleted.', example='2022-09-15T07:02:14Z'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='38bbed2a-15e0-45ad-98d4-816ad2ccf4ea'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='secret001'),
}

model DeleteSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSecretResponseBody(name='body'),
}

/**
  * If you call this operation without specifying a recovery period, the deleted secret can be recovered within 30 days.
  * If you specify a recovery period, the deleted secret can be recovered within the recovery period. You can also forcibly delete a secret. A forcibly deleted secret cannot be recovered.
  *
  * @param request DeleteSecretRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteSecretResponse
 */
async function deleteSecretWithOptions(request: DeleteSecretRequest, runtime: Util.RuntimeOptions): DeleteSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.forceDeleteWithoutRecovery)) {
    query['ForceDeleteWithoutRecovery'] = request.forceDeleteWithoutRecovery;
  }
  if (!Util.isUnset(request.recoveryWindowInDays)) {
    query['RecoveryWindowInDays'] = request.recoveryWindowInDays;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSecret',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you call this operation without specifying a recovery period, the deleted secret can be recovered within 30 days.
  * If you specify a recovery period, the deleted secret can be recovered within the recovery period. You can also forcibly delete a secret. A forcibly deleted secret cannot be recovered.
  *
  * @param request DeleteSecretRequest
  * @return DeleteSecretResponse
 */
async function deleteSecret(request: DeleteSecretRequest): DeleteSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecretWithOptions(request, runtime);
}

model DescribeAccountKmsStatusResponseBody = {
  accountStatus?: string(name='AccountStatus', description='The status of KMS within your Alibaba cloud account. Valid values:

*   Enabled: KMS is enabled.

*   NotEnabled: KMS is disabled.

*   InDebt: Your account is overdue, and KMS stops providing services.

> If your Alibaba Cloud account is overdue, top up your account at the earliest opportunity to avoid impacts on your services.

*   Suspended: KMS is suspended.', example='Enabled'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3ac84333-d64d-4784-a8bc-997834a7ac6c'),
}

model DescribeAccountKmsStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAccountKmsStatusResponseBody(name='body'),
}

async function describeAccountKmsStatusWithOptions(runtime: Util.RuntimeOptions): DescribeAccountKmsStatusResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeAccountKmsStatus',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAccountKmsStatus(): DescribeAccountKmsStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccountKmsStatusWithOptions(runtime);
}

model DescribeCertificateRequest {
  certificateId?: string(name='CertificateId', description='The ID of the certificate. The ID must be globally unique in Certificates Manager.', example='9a28de48-8d8b-484d-a766-dec4****'),
}

model DescribeCertificateResponseBody = {
  arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the certificate.', example='acs:kms:cn-hangzhou:159498693826****:certificate/9a28de48-8d8b-484d-a766-dec4****"'),
  certificateId?: string(name='CertificateId', description='The ID of the certificate. The ID must be globally unique in Certificates Manager.', example='9a28de48-8d8b-484d-a766-dec4****'),
  createdAt?: string(name='CreatedAt', description='The time when the certificate was created.', example='2020-10-13T03:05:03Z'),
  exportablePrivateKey?: boolean(name='ExportablePrivateKey', description='Indicates whether the private key of the certificate can be exported for use. Valid values:

*   true: The private key of the certificate can be exported for use. This is the default value.
*   false: The private key of the certificate cannot be exported for use.', example='true'),
  issuer?: string(name='Issuer', description='The certificate issuer in the distinguished name (DN) format.', example='CN=testCA,OU=kms,O=aliyun,C=CN'),
  keySpec?: string(name='KeySpec', description='The type of the key.', example='RSA_2048'),
  notAfter?: string(name='NotAfter', description='The end of the validity period of the certificate.', example='2022-10-13T03:09:00Z'),
  notBefore?: string(name='NotBefore', description='The beginning of the validity period of the certificate.', example='2020-10-13T03:09:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='edb671a3-c5a1-4ebe-a1de-d748b640bdf2'),
  serial?: string(name='Serial', description='The serial number of the certificate.', example='12345678'),
  signatureAlgorithm?: string(name='SignatureAlgorithm', description='The signature algorithm of the certificate. Valid values:

*   RSA2048-SHA256
*   ECDSA-SHA256
*   SM2-SM3', example='ECDSA-SHA256'),
  status?: string(name='Status', description='The status of the certificate. Valid values:

*   PENDING: The certificate is to be imported.
*   ACTIVE: The certificate is enabled.
*   INACTIVE: The certificate is disabled.
*   REVOKED: The certificate is revoked.', example='ACTIVE'),
  subject?: string(name='Subject', description='The subject of the certificate, which is in the DN format.', example='CN=userName,OU=aliyun,O=aliyun,C=CN'),
  subjectAlternativeNames?: [ string ](name='SubjectAlternativeNames', description='The alias of the certificate subject.

A domain name list is supported. A maximum of 10 domain names are supported.'),
  subjectKeyIdentifier?: string(name='SubjectKeyIdentifier', description='The public key identifier of the certificate subject.', example='79 36 26 DE 9F F5 15 E3 56 DC ****'),
  subjectPublicKey?: string(name='SubjectPublicKey', description='The public key of the certificate.', example='-----BEGIN PUBLIC KEY----- MIIBIjA -----END PUBLIC KEY-----'),
  tags?: map[string]any(name='Tags', description='The tag of the certificate.', example='[{\\"TagKey\\":\\"S1key1\\",\\"TagValue\\":\\"S1val1\\"},{\\"TagKey\\":\\"S1key2\\",\\"TagValue\\":\\"S2val2\\"}]'),
  updatedAt?: string(name='UpdatedAt', description='The time when the certificate was updated.', example='2020-12-23T06:10:13Z'),
}

model DescribeCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCertificateResponseBody(name='body'),
}

/**
  * In this example, the information about the certificate whose ID is `9a28de48-8d8b-484d-a766-dec4****` is queried. The certificate information includes the certificate ID, creation time, certificate issuer, validity period, serial number, and signature algorithm.
  *
  * @param request DescribeCertificateRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeCertificateResponse
 */
async function describeCertificateWithOptions(request: DescribeCertificateRequest, runtime: Util.RuntimeOptions): DescribeCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCertificate',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * In this example, the information about the certificate whose ID is `9a28de48-8d8b-484d-a766-dec4****` is queried. The certificate information includes the certificate ID, creation time, certificate issuer, validity period, serial number, and signature algorithm.
  *
  * @param request DescribeCertificateRequest
  * @return DescribeCertificateResponse
 */
async function describeCertificate(request: DescribeCertificateRequest): DescribeCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCertificateWithOptions(request, runtime);
}

model DescribeKeyRequest {
  keyId?: string(name='KeyId', description='The ID of the CMK. The ID must be globally unique.

You can also set this parameter to an alias that is bound to the CMK. For more information, see [Overview of aliases](~~68522~~).', example='05754286-3ba2-4fa6-8d41-4323aca6****'),
}

model DescribeKeyResponseBody = {
  keyMetadata?: {
    arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the CMK.', example='acs:kms:cn-hangzhou:154035569884****:key/05754286-3ba2-4fa6-8d41-4323aca6****'),
    automaticRotation?: string(name='AutomaticRotation', description='Indicates whether automatic key rotation is enabled. Valid values:

*   Enabled
*   Disabled
*   Suspended

For more information, see [Automatic key rotation](~~134270~~).

>  Only symmetric CMKs support automatic key rotation.', example='Disabled'),
    creationDate?: string(name='CreationDate', description='The time when the CMK was created. The time is displayed in UTC.', example='2021-05-20T06:34:21Z'),
    creator?: string(name='Creator', description='The Alibaba Cloud account that is used to create the CMK.', example='154035569884****'),
    DKMSInstanceId?: string(name='DKMSInstanceId', description='The ID of the dedicated KMS instance.', example='kst-bjj62d8f5e0sgtx8h****'),
    deleteDate?: string(name='DeleteDate', description='The time at which the CMK is scheduled for deletion. The time is displayed in UTC.

For more information, see [ScheduleKeyDeletion](~~44196~~).

>  This parameter is returned only when the value of the KeyState parameter is PendingDeletion.', example='2021-05-26T18:22:03Z'),
    deletionProtection?: string(name='DeletionProtection', description='Indicates whether deletion protection is enabled. Valid values:

*   Enabled
*   Disabled', example='Enabled'),
    deletionProtectionDescription?: string(name='DeletionProtectionDescription', description='The description of deletion protection.'),
    description?: string(name='Description', description='The description of the CMK.', example='key description example'),
    keyId?: string(name='KeyId', description='The ID of the CMK. The ID must be globally unique.', example='05754286-3ba2-4fa6-8d41-4323aca6****'),
    keySpec?: string(name='KeySpec', description='The type of the CMK.', example='Aliyun_AES_256'),
    keyState?: string(name='KeyState', description='The status of the CMK.

For more information, see [Impact of CMK status on API operations](~~44211~~).', example='Enabled'),
    keyUsage?: string(name='KeyUsage', description='The usage of the CMK.', example='ENCRYPT/DECRYPT'),
    lastRotationDate?: string(name='LastRotationDate', description='The time when the last rotation was performed. The time is displayed in UTC. For a new CMK, the value of this parameter is the time when the initial version of the CMK was generated.', example='2021-05-20T06:34:21Z'),
    materialExpireTime?: string(name='MaterialExpireTime', description='The time when the key material expires. The time is displayed in UTC. If this parameter value is empty, the key material does not expire.', example='2021-07-06T18:22:03Z'),
    nextRotationDate?: string(name='NextRotationDate', description='The time when the next rotation will be performed.

>  This parameter is returned only when the value of the AutomaticRotation parameter is Enabled or Suspended.', example='2021-07-06T18:22:03Z'),
    origin?: string(name='Origin', description='The source of the key material for the CMK.', example='Aliyun_KMS'),
    primaryKeyVersion?: string(name='PrimaryKeyVersion', description='The ID of the current primary key version for the symmetric CMK.', example='515e0b0a-624f-45ab-92b5-54f9b551****'),
    protectionLevel?: string(name='ProtectionLevel', description='The protection level of the CMK.', example='HSM'),
    rotationInterval?: string(name='RotationInterval', description='The interval for automatic key rotation.

Unit: seconds.

For example, if the value is 604800s, automatic key rotation is performed at a 7-day interval.

>  This parameter is returned only when the value of the AutomaticRotation parameter is Enabled or Suspended.', example='31536000s'),
  }(name='KeyMetadata', description='The metadata of the CMK.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='f1fdfa9d-bd49-418b-942f-8f3e3ec00a4f'),
}

model DescribeKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeKeyResponseBody(name='body'),
}

/**
  * You can query the information about the CMK `05754286-3ba2-4fa6-8d41-4323aca6****` by using parameter settings provided in this topic. The information includes the creator, creation time, status, and deletion protection status of the CMK.
  *
  * @param request DescribeKeyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeKeyResponse
 */
async function describeKeyWithOptions(request: DescribeKeyRequest, runtime: Util.RuntimeOptions): DescribeKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeKey',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can query the information about the CMK `05754286-3ba2-4fa6-8d41-4323aca6****` by using parameter settings provided in this topic. The information includes the creator, creation time, status, and deletion protection status of the CMK.
  *
  * @param request DescribeKeyRequest
  * @return DescribeKeyResponse
 */
async function describeKey(request: DescribeKeyRequest): DescribeKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeKeyWithOptions(request, runtime);
}

model DescribeKeyVersionRequest {
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK.

You can also set this parameter to an alias that is bound to the CMK. For more information, see [Alias overview](~~68522~~).', example='1234abcd-12ab-34cd-56ef-12345678****'),
  keyVersionId?: string(name='KeyVersionId', description='The globally unique ID of the CMK version.

You can call the [ListKeyVersions](~~133966~~) operation to query the versions of the CMK.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
}

model DescribeKeyVersionResponseBody = {
  keyVersion?: {
    creationDate?: string(name='CreationDate', description='The date and time when the CMK version was created. The time is displayed in UTC.', example='2016-03-25T10:42:40Z'),
    keyId?: string(name='KeyId', description='The globally unique ID of the CMK.

>  If you set the KeyId parameter in the request to an alias of the CMK, the ID of the CMK to which the alias is bound is returned.', example='1234abcd-12ab-34cd-56ef-12345678****'),
    keyVersionId?: string(name='KeyVersionId', description='The globally unique ID of the CMK version.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
  }(name='KeyVersion', description='The metadata of the CMK version.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7021b6ec-4be7-4d3c-8a68-1e85d4d515a0'),
}

model DescribeKeyVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeKeyVersionResponseBody(name='body'),
}

/**
  * This topic provides an example on how to query the information about a version of the CMK `1234abcd-12ab-34cd-56ef-12345678****`. The ID of the CMK version is `2ab1a983-7072-4bbc-a582-584b5bd8****`. The response shows that the creation time of the CMK version is `2016-03-25T10:42:40Z`.
  *
  * @param request DescribeKeyVersionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeKeyVersionResponse
 */
async function describeKeyVersionWithOptions(request: DescribeKeyVersionRequest, runtime: Util.RuntimeOptions): DescribeKeyVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keyVersionId)) {
    query['KeyVersionId'] = request.keyVersionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeKeyVersion',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This topic provides an example on how to query the information about a version of the CMK `1234abcd-12ab-34cd-56ef-12345678****`. The ID of the CMK version is `2ab1a983-7072-4bbc-a582-584b5bd8****`. The response shows that the creation time of the CMK version is `2016-03-25T10:42:40Z`.
  *
  * @param request DescribeKeyVersionRequest
  * @return DescribeKeyVersionResponse
 */
async function describeKeyVersion(request: DescribeKeyVersionRequest): DescribeKeyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeKeyVersionWithOptions(request, runtime);
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
    }
  ](name='Region')
  }(name='Regions', description='The region.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='815240e2-aa37-4c26-9cca-05d4df3e8fe6'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(runtime);
}

model DescribeSecretRequest {
  fetchTags?: string(name='FetchTags', description='Specifies whether to return the resource tags of the secret. Valid values:

*   true: The resource tags are returned.
*   false: The resource tags are not returned. This is the default value.', example='true'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='secret001'),
}

model DescribeSecretResponseBody = {
  arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the secret.', example='acs:kms:cn-hangzhou:154035569884****:secret/secret001'),
  automaticRotation?: string(name='AutomaticRotation', description='Indicates whether automatic rotation is enabled. Valid values:

*   Enabled: indicates that automatic rotation is enabled.
*   Disabled: indicates that automatic rotation is disabled.
*   Invalid: indicates that the status of automatic rotation is abnormal. In this case, Secrets Manager cannot automatically rotate the secret.

>  This parameter is returned only for a managed ApsaraDB RDS secret, a managed RAM secret, or a managed ECS secret.', example='Enabled'),
  createTime?: string(name='CreateTime', description='The time when the secret was created.', example='2022-02-21T15:39:26Z'),
  DKMSInstanceId?: string(name='DKMSInstanceId', description='The ID of the dedicated KMS instance.', example='kst-bjj62d8f5e0sgtx8h****'),
  description?: string(name='Description', description='The description of the secret.', example='userinfo'),
  encryptionKeyId?: string(name='EncryptionKeyId', description='The ID of the customer master key (CMK) that is used to encrypt the secret value.', example='00aa68af-2c02-4f68-95fe-3435d330****'),
  extendedConfig?: string(name='ExtendedConfig', description='The extended configuration of the secret.

>  This parameter is returned only for a managed ApsaraDB RDS secret, a managed Resource Access Management (RAM) secret, or a managed Elastic Compute Service (ECS) secret.', example='{\\"SecretSubType\\":\\"SingleUser\\", \\"DBInstanceId\\":\\"rm-uf667446pc955****\\",  \\"CustomData\\":{} }'),
  lastRotationDate?: string(name='LastRotationDate', description='The time when the last rotation was performed.

>  This parameter is returned if the secret was rotated.', example='2022-07-05T08:22:03Z'),
  nextRotationDate?: string(name='NextRotationDate', description='The time when the next rotation will be performed.

>  This parameter is returned when automatic rotation is enabled.', example='2022-07-06T18:22:03Z'),
  plannedDeleteTime?: string(name='PlannedDeleteTime', description='The time when the secret is scheduled to be deleted.', example='2022-03-21T15:45:12Z'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='93348dfb-3627-4417-8d90-487a76a909c9'),
  rotationInterval?: string(name='RotationInterval', description='The interval for automatic rotation.

The value is in the `integer[unit]` format. `integer` indicates the length of time. `unit`: indicates the time unit. The value of `unit` is fixed as s. For example, if the value is 604800s, automatic rotation is performed at a 7-day interval.

>  This parameter is returned when automatic rotation is enabled.', example='3153600s'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='secret001'),
  secretType?: string(name='SecretType', description='The type of the secret. Valid values:

*   Generic: indicates a generic secret.
*   Rds: indicates a managed ApsaraDB RDS secret.
*   RAMCredentials: indicates a managed RAM secret.
*   ECS: indicates a managed ECS secret.', example='Rds'),
  tags?: {
    tag?: [ 
    {
      tagKey?: string(name='TagKey', description='The tag key.', example='key1'),
      tagValue?: string(name='TagValue', description='The tag value.', example='val1'),
    }
  ](name='Tag')
  }(name='Tags', description='The resource tags of the secret.

This parameter is not returned if you set the FetchTags parameter to false or you do not specify the FetchTags parameter.'),
  updateTime?: string(name='UpdateTime', description='The time when the secret was updated.', example='2022-02-21T15:39:26Z'),
}

model DescribeSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSecretResponseBody(name='body'),
}

/**
  * This operation returns the metadata of a secret. This operation does not return the secret value.
  * In this example, the metadata of the secret named `secret001` is queried.
  *
  * @param request DescribeSecretRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeSecretResponse
 */
async function describeSecretWithOptions(request: DescribeSecretRequest, runtime: Util.RuntimeOptions): DescribeSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fetchTags)) {
    query['FetchTags'] = request.fetchTags;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecret',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation returns the metadata of a secret. This operation does not return the secret value.
  * In this example, the metadata of the secret named `secret001` is queried.
  *
  * @param request DescribeSecretRequest
  * @return DescribeSecretResponse
 */
async function describeSecret(request: DescribeSecretRequest): DescribeSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecretWithOptions(request, runtime);
}

model DisableKeyRequest {
  keyId?: string(name='KeyId', description='The ID of the CMK. The ID must be globally unique.', example='1234abcd-12ab-34cd-56ef-12345678****'),
}

model DisableKeyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2fe70ce2-3303-4fd6-b3ac-472fb2705c62'),
}

model DisableKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableKeyResponseBody(name='body'),
}

/**
  * If a customer master key (CMK) is disabled, the ciphertext encrypted by using this CMK cannot be decrypted until you re-enable it. You can call the [EnableKey](~~35150~~) operation to enable the CMK.
  * In this example, the CMK whose ID is `1234abcd-12ab-34cd-56ef-12345678****` is disabled.
  *
  * @param request DisableKeyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DisableKeyResponse
 */
async function disableKeyWithOptions(request: DisableKeyRequest, runtime: Util.RuntimeOptions): DisableKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableKey',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If a customer master key (CMK) is disabled, the ciphertext encrypted by using this CMK cannot be decrypted until you re-enable it. You can call the [EnableKey](~~35150~~) operation to enable the CMK.
  * In this example, the CMK whose ID is `1234abcd-12ab-34cd-56ef-12345678****` is disabled.
  *
  * @param request DisableKeyRequest
  * @return DisableKeyResponse
 */
async function disableKey(request: DisableKeyRequest): DisableKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableKeyWithOptions(request, runtime);
}

model EnableKeyRequest {
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK.', example='1234abcd-12ab-34cd-56ef-12345678****'),
}

model EnableKeyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='efb1cbbd-a093-4278-bc03-639dd4fcc207'),
}

model EnableKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableKeyResponseBody(name='body'),
}

async function enableKeyWithOptions(request: EnableKeyRequest, runtime: Util.RuntimeOptions): EnableKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableKey',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableKey(request: EnableKeyRequest): EnableKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableKeyWithOptions(request, runtime);
}

model EncryptRequest {
  encryptionContext?: map[string]any(name='EncryptionContext', description='A JSON string that consists of key-value pairs. If you specify this parameter, an equivalent value is required when you call the Decrypt operation. For more information, see [EncryptionContext](~~42975~~).', example='{"Example":"Example"}'),
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK. You can also set this parameter to an alias that is bound to the CMK. For more information, see [Use aliases](~~68522~~).', example='1234abcd-12ab-34cd-56ef-12345678****'),
  plaintext?: string(name='Plaintext', description='The plaintext to be encrypted. The plaintext must be Base64 encoded.', example='SGVsbG8gd29y****'),
}

model EncryptShrinkRequest {
  encryptionContextShrink?: string(name='EncryptionContext', description='A JSON string that consists of key-value pairs. If you specify this parameter, an equivalent value is required when you call the Decrypt operation. For more information, see [EncryptionContext](~~42975~~).', example='{"Example":"Example"}'),
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK. You can also set this parameter to an alias that is bound to the CMK. For more information, see [Use aliases](~~68522~~).', example='1234abcd-12ab-34cd-56ef-12345678****'),
  plaintext?: string(name='Plaintext', description='The plaintext to be encrypted. The plaintext must be Base64 encoded.', example='SGVsbG8gd29y****'),
}

model EncryptResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob', description='The ciphertext of the data that is encrypted by using the primary CMK version.', example='DZhOWVmZDktM2QxNi00ODk0LWJkNGYtMWZjNDNmM2YyYWJmaaSl+TztSIMe43nbTH/Z1Wr4XfLftKhAciUmDQXuMRl4WTvKhxjMThjK****'),
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK. If you set the KeyId parameter to an alias, the ID of the CMK to which the alias is bound is returned.', example='1234abcd-12ab-34cd-56ef-12345678****'),
  keyVersionId?: string(name='KeyVersionId', description='The ID of the key version that is used to encrypt the plaintext. It is the primary version of the CMK.', example='86a9efd9-3d16-4894-bd4f-1fc43f3f****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='475f1620-b9d3-4d35-b5c6-3fbdd941423d'),
}

model EncryptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EncryptResponseBody(name='body'),
}

/**
  * *   KMS uses the primary version of a specified CMK to encrypt data.
  * *   Only data of 6 KB or less can be encrypted. For example, you can call this operation to encrypt RSA keys, database access passwords, or other sensitive information.
  * *   When you migrate encrypted data across regions, you can call this operation in the destination region to encrypt the plaintext of the data key that is used to encrypt the migrated data in the source region. This way, the ciphertext of the data key is generated in the destination region. You can also call the [Decrypt](~~28950~~) operation to decrypt the data key.
  *
  * @param tmpReq EncryptRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return EncryptResponse
 */
async function encryptWithOptions(tmpReq: EncryptRequest, runtime: Util.RuntimeOptions): EncryptResponse {
  Util.validateModel(tmpReq);
  var request = new EncryptShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.encryptionContextShrink)) {
    query['EncryptionContext'] = request.encryptionContextShrink;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.plaintext)) {
    query['Plaintext'] = request.plaintext;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Encrypt',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   KMS uses the primary version of a specified CMK to encrypt data.
  * *   Only data of 6 KB or less can be encrypted. For example, you can call this operation to encrypt RSA keys, database access passwords, or other sensitive information.
  * *   When you migrate encrypted data across regions, you can call this operation in the destination region to encrypt the plaintext of the data key that is used to encrypt the migrated data in the source region. This way, the ciphertext of the data key is generated in the destination region. You can also call the [Decrypt](~~28950~~) operation to decrypt the data key.
  *
  * @param request EncryptRequest
  * @return EncryptResponse
 */
async function encrypt(request: EncryptRequest): EncryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return encryptWithOptions(request, runtime);
}

model ExportDataKeyRequest {
  ciphertextBlob?: string(name='CiphertextBlob', description='The ciphertext of the data key encrypted by using a CMK.', example='ODZhOWVmZDktM2QxNi00ODk0LWJkNGYtMWZjNDNmM2YyYWJmS7FmDBBQ0BkKsQrtRnidtPwirmDcS0ZuJCU41xxAAWk4Z8qsADfbV0b+i6kQmlvj79dJdGOvtX69Uycs901q********'),
  encryptionContext?: map[string]any(name='EncryptionContext', description='A JSON string that consists of key-value pairs. If you specify this parameter when you use a CMK to encrypt the data key, an equivalent value is required here. For more information, see [EncryptionContext](~~42975~~).', example='{"Example":"Example"}'),
  publicKeyBlob?: string(name='PublicKeyBlob', description='A Base64-encoded public key.', example='MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAndKfC2ReLL2+y8a0+ZBBeAft/uBYo86GZiYJuflqgUzKxpyuvlo3uQkBv6b+nx+0tz8g8v7GhpPWMSW5L9mNHYsvYFsa7jTxsYdt17yj6GlUHPuMIs8hr5qbwl38IHU1iIa7nYWwE2fb3ePOvLDACRJVgGpU0yxioW80d2QD+9aU4jF5dlAahcfgsNzo2CXzCUc1+xbmNuq7Rp+H9VJB9dyYOwqnW3RhOLBo21FzpORapf0UiRlrHRpk1V6ez+aE1dofaYh/9bh0m6ioxj7j5hpZbWccuEZTMBKd+cbuBkRhJzc6Tti6qwZbDiu4fUwbZS0Tqpuo1UadiyxMW********'),
  wrappingAlgorithm?: string(name='WrappingAlgorithm', description='The encryption algorithm based on which you want to use the public key specified by PublicKeyBlob to encrypt the data key. For more information about encryption algorithms, see [AsymmetricDecrypt](~~148130~~).

Valid values:

*   RSAES_OAEP_SHA\\_256
*   RSAES_OAEP_SHA\\_1
*   SM2PKE', example='RSAES_OAEP_SHA_256'),
  wrappingKeySpec?: string(name='WrappingKeySpec', description='The key type of the public key specified by PublicKeyBlob. For more information about key types, see [Introduction to asymmetric keys](~~148147~~).

Valid values:

*   RSA\\_2048
*   EC_SM2', example='RSA_2048'),
}

model ExportDataKeyShrinkRequest {
  ciphertextBlob?: string(name='CiphertextBlob', description='The ciphertext of the data key encrypted by using a CMK.', example='ODZhOWVmZDktM2QxNi00ODk0LWJkNGYtMWZjNDNmM2YyYWJmS7FmDBBQ0BkKsQrtRnidtPwirmDcS0ZuJCU41xxAAWk4Z8qsADfbV0b+i6kQmlvj79dJdGOvtX69Uycs901q********'),
  encryptionContextShrink?: string(name='EncryptionContext', description='A JSON string that consists of key-value pairs. If you specify this parameter when you use a CMK to encrypt the data key, an equivalent value is required here. For more information, see [EncryptionContext](~~42975~~).', example='{"Example":"Example"}'),
  publicKeyBlob?: string(name='PublicKeyBlob', description='A Base64-encoded public key.', example='MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAndKfC2ReLL2+y8a0+ZBBeAft/uBYo86GZiYJuflqgUzKxpyuvlo3uQkBv6b+nx+0tz8g8v7GhpPWMSW5L9mNHYsvYFsa7jTxsYdt17yj6GlUHPuMIs8hr5qbwl38IHU1iIa7nYWwE2fb3ePOvLDACRJVgGpU0yxioW80d2QD+9aU4jF5dlAahcfgsNzo2CXzCUc1+xbmNuq7Rp+H9VJB9dyYOwqnW3RhOLBo21FzpORapf0UiRlrHRpk1V6ez+aE1dofaYh/9bh0m6ioxj7j5hpZbWccuEZTMBKd+cbuBkRhJzc6Tti6qwZbDiu4fUwbZS0Tqpuo1UadiyxMW********'),
  wrappingAlgorithm?: string(name='WrappingAlgorithm', description='The encryption algorithm based on which you want to use the public key specified by PublicKeyBlob to encrypt the data key. For more information about encryption algorithms, see [AsymmetricDecrypt](~~148130~~).

Valid values:

*   RSAES_OAEP_SHA\\_256
*   RSAES_OAEP_SHA\\_1
*   SM2PKE', example='RSAES_OAEP_SHA_256'),
  wrappingKeySpec?: string(name='WrappingKeySpec', description='The key type of the public key specified by PublicKeyBlob. For more information about key types, see [Introduction to asymmetric keys](~~148147~~).

Valid values:

*   RSA\\_2048
*   EC_SM2', example='RSA_2048'),
}

model ExportDataKeyResponseBody = {
  exportedDataKey?: string(name='ExportedDataKey', description='The data key encrypted by using the public key and then exported.', example='BQKP+1zK6+ZEMxTP5qaVzcsgXtWplYBKm0NXdSnB5FzliFxE1bSiu4dnEIlca2JpeH7yz1/S6fed630H+hIH6DoM25fTLNcKj+mFB0Xnh9m2+HN59Mn4qyTfcUeadnfCXSWcGBouhXFwcdd2rJ3n337bzTf4jm659gZu3L0i6PLuxM9p7mqdwO0cKJPfGVfhnfMz+f4alMg79WB/NNyE2lyX7/qxvV49ObNrrJbKSFiz8Djocaf0IESNLMbfYI5bXjWkJlX92DQbKhibtQW8ZOJ//ZC6t0AWcUoKL6QDm/dg5koQalcleRinpB+QadFm894sLbVZ9+N4GVs*******'),
  keyId?: string(name='KeyId', description='The ID of the CMK that is used to decrypt the specified ciphertext of the data key.

This parameter is the globally unique ID of the CMK.', example='202b9877-5a25-46e3-a763-e20791b5****'),
  keyVersionId?: string(name='KeyVersionId', description='The ID of the CMK version that is used to decrypt the specified ciphertext of the data key.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4bd560a1-729e-45f1-a3d9-b2a33d61046b'),
}

model ExportDataKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExportDataKeyResponseBody(name='body'),
}

/**
  * You can call the [GenerateDataKeyWithoutPlaintext](~~134043~~) operation to generate a data key, which is encrypted by a CMK. If you want to distribute the data key to other regions or cryptographic modules, you can call the ExportDataKey operation to use a public key to encrypt the data key.
  * Then, you can import the ciphertext of the data key to the cryptographic module where the private key is stored. This way, the data key is securely distributed from KMS to the cryptographic module. After the data key is imported to the cryptographic module, you can use it to encrypt or decrypt data.
  *
  * @param tmpReq ExportDataKeyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ExportDataKeyResponse
 */
async function exportDataKeyWithOptions(tmpReq: ExportDataKeyRequest, runtime: Util.RuntimeOptions): ExportDataKeyResponse {
  Util.validateModel(tmpReq);
  var request = new ExportDataKeyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.ciphertextBlob)) {
    query['CiphertextBlob'] = request.ciphertextBlob;
  }
  if (!Util.isUnset(request.encryptionContextShrink)) {
    query['EncryptionContext'] = request.encryptionContextShrink;
  }
  if (!Util.isUnset(request.publicKeyBlob)) {
    query['PublicKeyBlob'] = request.publicKeyBlob;
  }
  if (!Util.isUnset(request.wrappingAlgorithm)) {
    query['WrappingAlgorithm'] = request.wrappingAlgorithm;
  }
  if (!Util.isUnset(request.wrappingKeySpec)) {
    query['WrappingKeySpec'] = request.wrappingKeySpec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportDataKey',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call the [GenerateDataKeyWithoutPlaintext](~~134043~~) operation to generate a data key, which is encrypted by a CMK. If you want to distribute the data key to other regions or cryptographic modules, you can call the ExportDataKey operation to use a public key to encrypt the data key.
  * Then, you can import the ciphertext of the data key to the cryptographic module where the private key is stored. This way, the data key is securely distributed from KMS to the cryptographic module. After the data key is imported to the cryptographic module, you can use it to encrypt or decrypt data.
  *
  * @param request ExportDataKeyRequest
  * @return ExportDataKeyResponse
 */
async function exportDataKey(request: ExportDataKeyRequest): ExportDataKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportDataKeyWithOptions(request, runtime);
}

model GenerateAndExportDataKeyRequest {
  encryptionContext?: map[string]any(name='EncryptionContext', description='A JSON string of key-value pairs. If you specify this parameter here, an equivalent value is required when you decrypt or re-encrypt the data key. For more information, see [EncryptionContext](~~42975~~).', example='{"Example":"Example"}'),
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK. You can also set this parameter to an alias that is bound to the CMK. For more information, see [Use aliases](~~68522~~).', example='1234abcd-12ab-34cd-56ef-12345678****'),
  keySpec?: string(name='KeySpec', description='The length of the data key that you want to generate. Valid values:

*   AES\\_256: a 256-bit symmetric key
*   AES\\_128: a 128-bit symmetric key

>  We recommend that you use the KeySpec or NumberOfBytes parameter to specify the length of a data key. If both parameters are not specified, KMS generates a 256-bit data key. If both parameters are specified, KMS ignores the KeySpec parameter.', example='AES_256'),
  numberOfBytes?: int32(name='NumberOfBytes', description='The length of the data key that you want to generate.

Valid values: 1 to 1024.

Unit: bytes.', example='32'),
  publicKeyBlob?: string(name='PublicKeyBlob', description='A Base64-encoded public key.', example='MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAndKfC2ReLL2+y8a0+ZBBeAft/uBYo86GZiYJuflqgUzKxpyuvlo3uQkBv6b+nx+0tz8g8v7GhpPWMSW5L9mNHYsvYFsa7jTxsYdt17yj6GlUHPuMIs8hr5qbwl38IHU1iIa7nYWwE2fb3ePOvLDACRJVgGpU0yxioW80d2QD+9aU4jF5dlAahcfgsNzo2CXzCUc1+xbmNuq7Rp+H9VJB9dyYOwqnW3RhOLBo21FzpORapf0UiRlrHRpk1V6ez+aE1dofaYh/9bh0m6ioxj7j5hpZbWccuEZTMBKd+cbuBkRhJzc6Tti6qwZbDiu4fUwbZS0Tqpuo1UadiyxMW********'),
  wrappingAlgorithm?: string(name='WrappingAlgorithm', description='The encryption algorithm based on which you want to use the public key specified by PublicKeyBlob to encrypt the data key. For more information about encryption algorithms, see [AsymmetricDecrypt](~~148130~~).

Valid values:

*   RSAES_OAEP_SHA\\_256
*   RSAES_OAEP_SHA\\_1
*   SM2PKE', example='RSAES_OAEP_SHA_256'),
  wrappingKeySpec?: string(name='WrappingKeySpec', description='The key type of the public key specified by PublicKeyBlob. For more information about key types, see [Introduction to asymmetric keys](~~148147~~).

Valid values:

*   RSA\\_2048
*   EC_SM2', example='RSA_2048'),
}

model GenerateAndExportDataKeyShrinkRequest {
  encryptionContextShrink?: string(name='EncryptionContext', description='A JSON string of key-value pairs. If you specify this parameter here, an equivalent value is required when you decrypt or re-encrypt the data key. For more information, see [EncryptionContext](~~42975~~).', example='{"Example":"Example"}'),
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK. You can also set this parameter to an alias that is bound to the CMK. For more information, see [Use aliases](~~68522~~).', example='1234abcd-12ab-34cd-56ef-12345678****'),
  keySpec?: string(name='KeySpec', description='The length of the data key that you want to generate. Valid values:

*   AES\\_256: a 256-bit symmetric key
*   AES\\_128: a 128-bit symmetric key

>  We recommend that you use the KeySpec or NumberOfBytes parameter to specify the length of a data key. If both parameters are not specified, KMS generates a 256-bit data key. If both parameters are specified, KMS ignores the KeySpec parameter.', example='AES_256'),
  numberOfBytes?: int32(name='NumberOfBytes', description='The length of the data key that you want to generate.

Valid values: 1 to 1024.

Unit: bytes.', example='32'),
  publicKeyBlob?: string(name='PublicKeyBlob', description='A Base64-encoded public key.', example='MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAndKfC2ReLL2+y8a0+ZBBeAft/uBYo86GZiYJuflqgUzKxpyuvlo3uQkBv6b+nx+0tz8g8v7GhpPWMSW5L9mNHYsvYFsa7jTxsYdt17yj6GlUHPuMIs8hr5qbwl38IHU1iIa7nYWwE2fb3ePOvLDACRJVgGpU0yxioW80d2QD+9aU4jF5dlAahcfgsNzo2CXzCUc1+xbmNuq7Rp+H9VJB9dyYOwqnW3RhOLBo21FzpORapf0UiRlrHRpk1V6ez+aE1dofaYh/9bh0m6ioxj7j5hpZbWccuEZTMBKd+cbuBkRhJzc6Tti6qwZbDiu4fUwbZS0Tqpuo1UadiyxMW********'),
  wrappingAlgorithm?: string(name='WrappingAlgorithm', description='The encryption algorithm based on which you want to use the public key specified by PublicKeyBlob to encrypt the data key. For more information about encryption algorithms, see [AsymmetricDecrypt](~~148130~~).

Valid values:

*   RSAES_OAEP_SHA\\_256
*   RSAES_OAEP_SHA\\_1
*   SM2PKE', example='RSAES_OAEP_SHA_256'),
  wrappingKeySpec?: string(name='WrappingKeySpec', description='The key type of the public key specified by PublicKeyBlob. For more information about key types, see [Introduction to asymmetric keys](~~148147~~).

Valid values:

*   RSA\\_2048
*   EC_SM2', example='RSA_2048'),
}

model GenerateAndExportDataKeyResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob', description='The ciphertext of the data key encrypted by using the primary CMK version.', example='ODZhOWVmZDktM2QxNi00ODk0LWJkNGYtMWZjNDNmM2YyYWJmS7FmDBBQ0BkKsQrtRnidtPwirmDcS0ZuJCU41xxAAWk4Z8qsADfbV0b+i6kQmlvj79dJdGOvtX69Uycs901qOjop4bTS****'),
  exportedDataKey?: string(name='ExportedDataKey', description='The data key encrypted by using the public key and then exported.', example='BQKP+1zK6+ZEMxTP5qaVzcsgXtWplYBKm0NXdSnB5FzliFxE1bSiu4dnEIlca2JpeH7yz1/S6fed630H+hIH6DoM25fTLNcKj+mFB0Xnh9m2+HN59Mn4qyTfcUeadnfCXSWcGBouhXFwcdd2rJ3n337bzTf4jm659gZu3L0i6PLuxM9p7mqdwO0cKJPfGVfhnfMz+f4alMg79WB/NNyE2lyX7/qxvV49ObNrrJbKSFiz8Djocaf0IESNLMbfYI5bXjWkJlX92DQbKhibtQW8ZOJ//ZC6t0AWcUoKL6QDm/dg5koQalcleRinpB+QadFm894sLbVZ9+N4GVs*******'),
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK.

>  If you set the KeyId parameter to an alias, the ID of the CMK to which the alias is bound is returned.', example='599fa825-17de-417e-9554-bb032cc6****'),
  keyVersionId?: string(name='KeyVersionId', description='The ID of the CMK version that is used to encrypt the plaintext. It is the primary version of the CMK.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7021b6ec-4be7-4d3c-8a68-1e85d4d515a0'),
}

model GenerateAndExportDataKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateAndExportDataKeyResponseBody(name='body'),
}

/**
  * We recommend that you perform the following steps to import your data key to a cryptographic module:
  * *   Call the GenerateAndExportDataKey operation to generate a data key and obtain both the ciphertext of the data key encrypted by using the CMK and that encrypted by using the public key.
  * *   Store the ciphertext of the data key encrypted by using the CMK in KMS Secrets Manager or in a storage service such as ApsaraDB. This ciphertext is used for backup and restoration.
  * *   Import the ciphertext of the data key encrypted by using the public key to the cryptographic module where the private key is stored. Then, you can use the data key to encrypt or decrypt data.
  * >  The CMK that you specify in the request of this operation is only used to encrypt the data key and is not involved in the generation of the data key. KMS does not record or store the data keys randomly generated by calling this operation. You must take note of the data keys and the returned ciphertext.
  *
  * @param tmpReq GenerateAndExportDataKeyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GenerateAndExportDataKeyResponse
 */
async function generateAndExportDataKeyWithOptions(tmpReq: GenerateAndExportDataKeyRequest, runtime: Util.RuntimeOptions): GenerateAndExportDataKeyResponse {
  Util.validateModel(tmpReq);
  var request = new GenerateAndExportDataKeyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.encryptionContextShrink)) {
    query['EncryptionContext'] = request.encryptionContextShrink;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keySpec)) {
    query['KeySpec'] = request.keySpec;
  }
  if (!Util.isUnset(request.numberOfBytes)) {
    query['NumberOfBytes'] = request.numberOfBytes;
  }
  if (!Util.isUnset(request.publicKeyBlob)) {
    query['PublicKeyBlob'] = request.publicKeyBlob;
  }
  if (!Util.isUnset(request.wrappingAlgorithm)) {
    query['WrappingAlgorithm'] = request.wrappingAlgorithm;
  }
  if (!Util.isUnset(request.wrappingKeySpec)) {
    query['WrappingKeySpec'] = request.wrappingKeySpec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateAndExportDataKey',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * We recommend that you perform the following steps to import your data key to a cryptographic module:
  * *   Call the GenerateAndExportDataKey operation to generate a data key and obtain both the ciphertext of the data key encrypted by using the CMK and that encrypted by using the public key.
  * *   Store the ciphertext of the data key encrypted by using the CMK in KMS Secrets Manager or in a storage service such as ApsaraDB. This ciphertext is used for backup and restoration.
  * *   Import the ciphertext of the data key encrypted by using the public key to the cryptographic module where the private key is stored. Then, you can use the data key to encrypt or decrypt data.
  * >  The CMK that you specify in the request of this operation is only used to encrypt the data key and is not involved in the generation of the data key. KMS does not record or store the data keys randomly generated by calling this operation. You must take note of the data keys and the returned ciphertext.
  *
  * @param request GenerateAndExportDataKeyRequest
  * @return GenerateAndExportDataKeyResponse
 */
async function generateAndExportDataKey(request: GenerateAndExportDataKeyRequest): GenerateAndExportDataKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateAndExportDataKeyWithOptions(request, runtime);
}

model GenerateDataKeyRequest {
  encryptionContext?: map[string]any(name='EncryptionContext', description='The JSON string that consists of key-value pairs.

If you specify this parameter, an equivalent value is required when you call the [Decrypt](~~28950~~) operation. For more information, see [EncryptionContext](~~42975~~).', example='{"Example":"Example"}'),
  keyId?: string(name='KeyId', description='The ID of the CMK. The ID must be globally unique.

You can also set this parameter to an alias that is bound to the CMK. For more information, see [Alias overview](~~68522~~).', example='7906979c-8e06-46a2-be2d-68e3ccbc****'),
  keySpec?: string(name='KeySpec', description='The type of the data key that you want to generate. Valid values:

*   AES\\_256: a 256-bit symmetric key
*   AES\\_128: a 128-bit symmetric key

>  We recommend that you use the KeySpec or NumberOfBytes parameter to specify the length of a data key. If none of the parameters are specified, KMS generates a 256-bit data key. If both parameters are specified, KMS ignores the KeySpec parameter.', example='AES_256'),
  numberOfBytes?: int32(name='NumberOfBytes', description='The length of the data key that you want to generate. Unit: bytes.

Valid values: 1 to 1024.

Default value:

*   If the KeySpec parameter is set to AES\\_256, set the value of the NumberOfBytes parameter to 32.
*   If the KeySpec parameter is set to AES\\_128, set the value of the NumberOfBytes parameter to 16.', example='256'),
}

model GenerateDataKeyShrinkRequest {
  encryptionContextShrink?: string(name='EncryptionContext', description='The JSON string that consists of key-value pairs.

If you specify this parameter, an equivalent value is required when you call the [Decrypt](~~28950~~) operation. For more information, see [EncryptionContext](~~42975~~).', example='{"Example":"Example"}'),
  keyId?: string(name='KeyId', description='The ID of the CMK. The ID must be globally unique.

You can also set this parameter to an alias that is bound to the CMK. For more information, see [Alias overview](~~68522~~).', example='7906979c-8e06-46a2-be2d-68e3ccbc****'),
  keySpec?: string(name='KeySpec', description='The type of the data key that you want to generate. Valid values:

*   AES\\_256: a 256-bit symmetric key
*   AES\\_128: a 128-bit symmetric key

>  We recommend that you use the KeySpec or NumberOfBytes parameter to specify the length of a data key. If none of the parameters are specified, KMS generates a 256-bit data key. If both parameters are specified, KMS ignores the KeySpec parameter.', example='AES_256'),
  numberOfBytes?: int32(name='NumberOfBytes', description='The length of the data key that you want to generate. Unit: bytes.

Valid values: 1 to 1024.

Default value:

*   If the KeySpec parameter is set to AES\\_256, set the value of the NumberOfBytes parameter to 32.
*   If the KeySpec parameter is set to AES\\_128, set the value of the NumberOfBytes parameter to 16.', example='256'),
}

model GenerateDataKeyResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob', description='The ciphertext of the data key that is encrypted by using the primary version of the specified CMK.', example='ODZhOWVmZDktM2QxNi00ODk0LWJkNGYtMWZjNDNmM2YyYWJmS7FmDBBQ0BkKsQrtRnidtPwirmDcS0ZuJCU41xxAAWk4Z8qsADfbV0b+i6kQmlvj79dJdGOvtX69Uycs901qOjop4bTS****'),
  keyId?: string(name='KeyId', description='The ID of the CMK. The ID must be globally unique.

>  If you set the KeyId parameter in the request to an alias of the CMK, the ID of the CMK to which the alias is bound is returned.', example='7906979c-8e06-46a2-be2d-68e3ccbc****'),
  keyVersionId?: string(name='KeyVersionId', description='The ID of the CMK version. The ID must be globally unique.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
  plaintext?: string(name='Plaintext', description='The Base64 encoded plaintext of the data key.', example='QmFzZTY0IGVuY29kZWQgcGxhaW50****'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7021b6ec-4be7-4d3c-8a68-1e85d4d515a0'),
}

model GenerateDataKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateDataKeyResponseBody(name='body'),
}

/**
  * This operation creates a random data key, encrypts the data key by using the specified customer master key (CMK), and returns the plaintext and ciphertext of the data key. You can use the plaintext of the data key to locally encrypt your data without using KMS and store the encrypted data together with the ciphertext of the data key. You can obtain the plaintext of the data key from the Plaintext parameter in the response and the ciphertext of the data key from the CiphertextBlob parameter in the response.
  * The CMK that you specify in the request of this operation is only used to encrypt the data key and is not involved in the generation of the data key. KMS does not record or store the generated data key. Therefore, you need to store the ciphertext of the data key in persistent storage.
  * We recommend that you locally encrypt data by performing the following steps:
  * 1\\. Call the GenerateDataKey operation.
  * 2\\. Use the plaintext of the data key that you obtain to locally encrypt data without using KMS. Then, delete the plaintext of the data key from the memory.
  * 3\\. Store the encrypted data together with the ciphertext of the data key that you obtain.
  * We recommend that you locally decrypt data by performing the following steps:
  * *   Call the [Decrypt](~~28950~~) operation to decrypt the locally stored ciphertext of the data key. The plaintext of data key is then returned.
  * *   Use the plaintext of the data key to locally decrypt data and then delete the plaintext of the data key from the memory.
  * In this example, a random data key is generated for the CMK whose ID is `7906979c-8e06-46a2-be2d-68e3ccbc****`.
  *
  * @param tmpReq GenerateDataKeyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GenerateDataKeyResponse
 */
async function generateDataKeyWithOptions(tmpReq: GenerateDataKeyRequest, runtime: Util.RuntimeOptions): GenerateDataKeyResponse {
  Util.validateModel(tmpReq);
  var request = new GenerateDataKeyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.encryptionContextShrink)) {
    query['EncryptionContext'] = request.encryptionContextShrink;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keySpec)) {
    query['KeySpec'] = request.keySpec;
  }
  if (!Util.isUnset(request.numberOfBytes)) {
    query['NumberOfBytes'] = request.numberOfBytes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateDataKey',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation creates a random data key, encrypts the data key by using the specified customer master key (CMK), and returns the plaintext and ciphertext of the data key. You can use the plaintext of the data key to locally encrypt your data without using KMS and store the encrypted data together with the ciphertext of the data key. You can obtain the plaintext of the data key from the Plaintext parameter in the response and the ciphertext of the data key from the CiphertextBlob parameter in the response.
  * The CMK that you specify in the request of this operation is only used to encrypt the data key and is not involved in the generation of the data key. KMS does not record or store the generated data key. Therefore, you need to store the ciphertext of the data key in persistent storage.
  * We recommend that you locally encrypt data by performing the following steps:
  * 1\\. Call the GenerateDataKey operation.
  * 2\\. Use the plaintext of the data key that you obtain to locally encrypt data without using KMS. Then, delete the plaintext of the data key from the memory.
  * 3\\. Store the encrypted data together with the ciphertext of the data key that you obtain.
  * We recommend that you locally decrypt data by performing the following steps:
  * *   Call the [Decrypt](~~28950~~) operation to decrypt the locally stored ciphertext of the data key. The plaintext of data key is then returned.
  * *   Use the plaintext of the data key to locally decrypt data and then delete the plaintext of the data key from the memory.
  * In this example, a random data key is generated for the CMK whose ID is `7906979c-8e06-46a2-be2d-68e3ccbc****`.
  *
  * @param request GenerateDataKeyRequest
  * @return GenerateDataKeyResponse
 */
async function generateDataKey(request: GenerateDataKeyRequest): GenerateDataKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateDataKeyWithOptions(request, runtime);
}

model GenerateDataKeyWithoutPlaintextRequest {
  encryptionContext?: map[string]any(name='EncryptionContext', description='A JSON string that consists of key-value pairs. If you specify this parameter, an equivalent value is required when you call the Decrypt operation. For more information, see [EncryptionContext](~~42975~~).', example='{"Example":"Example"}'),
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK. You can also set this parameter to an alias that is bound to the CMK. For more information, see Use aliases.', example='1234abcd-12ab-34cd-56ef-12345678****'),
  keySpec?: string(name='KeySpec', description='The length of the data key that you want to generate. Valid values:

*   AES\\_256: 256-bit symmetric key
*   AES\\_128: 128-bit symmetric key

>  We recommend that you use the KeySpec or NumberOfBytes parameter to specify the length of a data key. If both of them are not specified, KMS generates a 256-bit data key. If both of them are specified, KMS ignores the KeySpec parameter.', example='AES_256'),
  numberOfBytes?: int32(name='NumberOfBytes', description='The length of the data key that you want to generate.

Valid values: 1 to 1024.

Unit: bytes.', example='256'),
}

model GenerateDataKeyWithoutPlaintextShrinkRequest {
  encryptionContextShrink?: string(name='EncryptionContext', description='A JSON string that consists of key-value pairs. If you specify this parameter, an equivalent value is required when you call the Decrypt operation. For more information, see [EncryptionContext](~~42975~~).', example='{"Example":"Example"}'),
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK. You can also set this parameter to an alias that is bound to the CMK. For more information, see Use aliases.', example='1234abcd-12ab-34cd-56ef-12345678****'),
  keySpec?: string(name='KeySpec', description='The length of the data key that you want to generate. Valid values:

*   AES\\_256: 256-bit symmetric key
*   AES\\_128: 128-bit symmetric key

>  We recommend that you use the KeySpec or NumberOfBytes parameter to specify the length of a data key. If both of them are not specified, KMS generates a 256-bit data key. If both of them are specified, KMS ignores the KeySpec parameter.', example='AES_256'),
  numberOfBytes?: int32(name='NumberOfBytes', description='The length of the data key that you want to generate.

Valid values: 1 to 1024.

Unit: bytes.', example='256'),
}

model GenerateDataKeyWithoutPlaintextResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob', description='The ciphertext of the data that is encrypted by using the primary CMK version.', example='ODZhOWVmZDktM2QxNi00ODk0LWJkNGYtMWZjNDNmM2YyYWJmS7FmDBBQ0BkKsQrtRnidtPwirmDcS0ZuJCU41xxAAWk4Z8qsADfbV0b+i6kQmlvj79dJdGOvtX69Uycs901qOjop4bTS****'),
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK.

>  If you set the KeyId parameter to an alias, the ID of the CMK to which the alias is bound is returned.', example='599fa825-17de-417e-9554-bb032cc6****'),
  keyVersionId?: string(name='KeyVersionId', description='The ID of the key version that is used to encrypt the plaintext. It is the primary version of the CMK.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7021b6ec-4be7-4d3c-8a68-1e85d4d515a0'),
}

model GenerateDataKeyWithoutPlaintextResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateDataKeyWithoutPlaintextResponseBody(name='body'),
}

/**
  * This operation creates a random data key, encrypts the data key by using a specific symmetric CMK, and returns the ciphertext of the data key. This operation serves the same purpose as the [GenerateDataKey](~~28948~~) operation. The only difference is that this operation does not return the plaintext of the data key.
  * The CMK that you specify in the request of this operation is only used to encrypt the data key and is not involved in the generation of the data key. KMS does not record or store the generated data key.
  * > * This operation applies to the scenario when you do not need to use the data key to immediately encrypt data. Before you can use the data key to encrypt data, you must call the [Decrypt](~~28950~~) operation to decrypt the ciphertext of the data key.
  * > * This operation is also suitable for a distributed system with different trust levels. For example, a system stores data in different partitions based on a preset trust policy. A module creates different partitions and generates different data keys for each partition in advance. This module is not involved in data production and consumption after it completes initialization of the control plane. This module is the key provider. When producing and consuming data, modules on the control plane obtain the ciphertext of the data key for a partition first. After decrypting the ciphertext of the data key, modules on the control plane use the plaintext of the data key to encrypt or decrypt data and then clear the plaintext of the data key from the memory. In such a system, the key provider does not need to obtain the plaintext of the data key. It only needs to have the permissions to call the GenerateDataKeyWithoutPlaintext operation. The data producers or consumers do not need to generate new data keys. They only need to have the permissions to call the Decrypt operation.
  *
  * @param tmpReq GenerateDataKeyWithoutPlaintextRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GenerateDataKeyWithoutPlaintextResponse
 */
async function generateDataKeyWithoutPlaintextWithOptions(tmpReq: GenerateDataKeyWithoutPlaintextRequest, runtime: Util.RuntimeOptions): GenerateDataKeyWithoutPlaintextResponse {
  Util.validateModel(tmpReq);
  var request = new GenerateDataKeyWithoutPlaintextShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encryptionContext)) {
    request.encryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encryptionContext, 'EncryptionContext', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.encryptionContextShrink)) {
    query['EncryptionContext'] = request.encryptionContextShrink;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keySpec)) {
    query['KeySpec'] = request.keySpec;
  }
  if (!Util.isUnset(request.numberOfBytes)) {
    query['NumberOfBytes'] = request.numberOfBytes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateDataKeyWithoutPlaintext',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation creates a random data key, encrypts the data key by using a specific symmetric CMK, and returns the ciphertext of the data key. This operation serves the same purpose as the [GenerateDataKey](~~28948~~) operation. The only difference is that this operation does not return the plaintext of the data key.
  * The CMK that you specify in the request of this operation is only used to encrypt the data key and is not involved in the generation of the data key. KMS does not record or store the generated data key.
  * > * This operation applies to the scenario when you do not need to use the data key to immediately encrypt data. Before you can use the data key to encrypt data, you must call the [Decrypt](~~28950~~) operation to decrypt the ciphertext of the data key.
  * > * This operation is also suitable for a distributed system with different trust levels. For example, a system stores data in different partitions based on a preset trust policy. A module creates different partitions and generates different data keys for each partition in advance. This module is not involved in data production and consumption after it completes initialization of the control plane. This module is the key provider. When producing and consuming data, modules on the control plane obtain the ciphertext of the data key for a partition first. After decrypting the ciphertext of the data key, modules on the control plane use the plaintext of the data key to encrypt or decrypt data and then clear the plaintext of the data key from the memory. In such a system, the key provider does not need to obtain the plaintext of the data key. It only needs to have the permissions to call the GenerateDataKeyWithoutPlaintext operation. The data producers or consumers do not need to generate new data keys. They only need to have the permissions to call the Decrypt operation.
  *
  * @param request GenerateDataKeyWithoutPlaintextRequest
  * @return GenerateDataKeyWithoutPlaintextResponse
 */
async function generateDataKeyWithoutPlaintext(request: GenerateDataKeyWithoutPlaintextRequest): GenerateDataKeyWithoutPlaintextResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateDataKeyWithoutPlaintextWithOptions(request, runtime);
}

model GetCertificateRequest {
  certificateId?: string(name='CertificateId', description='The ID of the certificate. It is the globally unique identifier (GUID) of the certificate in Certificates Manager.', example='9a28de48-8d8b-484d-a766-dec4****'),
}

model GetCertificateResponseBody = {
  certificate?: string(name='Certificate', description='The certificate in the Privacy Enhanced Mail (PEM) format.', example='-----BEGIN CERTIFICATE-----  (X.509 Certificate PEM Content)  -----END CERTIFICATE-----'),
  certificateChain?: string(name='CertificateChain', description='The certificate chain in the PEM format.', example='-----BEGIN CERTIFICATE-----  (Sub CA Certificate PEM Content)  -----END CERTIFICATE-----  -----BEGIN CERTIFICATE-----  (Sub CA Certificate PEM Content)  -----END CERTIFICATE-----  -----BEGIN CERTIFICATE-----  (Root CA Certificate PEM Content)  -----END CERTIFICATE-----'),
  certificateId?: string(name='CertificateId', description='The ID of the certificate.', example='9a28de48-8d8b-484d-a766-dec4****'),
  csr?: string(name='Csr', description='The CSR in the PEM format.', example='-----BEGIN CERTIFICATE REQUEST-----MIICxjCCAa4CAQAwPzELMAkGA1UEBhMCQ04xDzANBgNVBAoTBmFsaXl1bjEMMAoGA1UECxMDa21zMREwDwY****-----END CERTIFICATE REQUEST-----'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='b3e104b4-0319-4a20-ab7f-9fef6****'),
}

model GetCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCertificateResponseBody(name='body'),
}

/**
  * In this example, the certificate whose ID is `9a28de48-8d8b-484d-a766-dec4****` is queried. The certificate, certificate chain, certificate ID, and certificate signing request (CSR) are returned.
  *
  * @param request GetCertificateRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetCertificateResponse
 */
async function getCertificateWithOptions(request: GetCertificateRequest, runtime: Util.RuntimeOptions): GetCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCertificate',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * In this example, the certificate whose ID is `9a28de48-8d8b-484d-a766-dec4****` is queried. The certificate, certificate chain, certificate ID, and certificate signing request (CSR) are returned.
  *
  * @param request GetCertificateRequest
  * @return GetCertificateResponse
 */
async function getCertificate(request: GetCertificateRequest): GetCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCertificateWithOptions(request, runtime);
}

model GetParametersForImportRequest {
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK.

>  You can import key material only for CMKs whose Origin parameter is set to EXTERNAL.', example='202b9877-5a25-46e3-a763-e20791b5****'),
  wrappingAlgorithm?: string(name='WrappingAlgorithm', description='The algorithm that is used to encrypt key material.', example='RSAES_PKCS1_V1_5'),
  wrappingKeySpec?: string(name='WrappingKeySpec', description='The type of the public key that is used to encrypt key material.', example='RSA_2048'),
}

model GetParametersForImportResponseBody = {
  importToken?: string(name='ImportToken', description='The token that is used to import key material.

The token is valid for 24 hours. The value of this parameter is required when you call the [ImportKeyMaterial](~~68622~~) operation.', example='Base64String'),
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK.

The value of this parameter is required when you call the [ImportKeyMaterial](~~68622~~) operation.', example='202b9877-5a25-46e3-a763-e20791b5****'),
  publicKey?: string(name='PublicKey', description='The public key that is used to encrypt key material.

The public key is Base64-encoded.', example='MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAlls4uIBxD0GG84C+lGBO6Dhpf1J3XimC6cPmPNaKKJMOzoX4tD+C+r7aZv8lZ3vnPfxuxvy/YwG+whUxTEEFUdqJTOIzhPfYucupqKM92crVHIuG+xtMVeHKjyTr+UrtKCsQikqHT+19yDRN/RMoo2HUx0gmEnRyXd8t3JyUXun9FdoxKA08GrsV7nodb9ZsoBLhnev7tTLcXvLyKW6XG1ZQCQm6dPnbnwLeDXR7uK0Lqn9PM28mBIdaiQUQxj2XbM1CoJA+JiyVX3Ptdb+4rqukb4Rb05B80Bs9xV/cf7FIku08l7xGhrGiQFq+DFXwQWtwihXHZxz3LhldU+4ZPwID****'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='8cdf51fd-bcd6-d79a-0ef4-e52c9b5466dc'),
  tokenExpireTime?: string(name='TokenExpireTime', description='The time when the token expires.', example='2018-01-25T00:01:02Z'),
}

model GetParametersForImportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetParametersForImportResponseBody(name='body'),
}

/**
  * The returned parameters can be used to call the [ImportKeyMaterial](https://www.alibabacloud.com/help/en/key-management-service/latest/importkeymaterial) operation.
  * - You can import key material only for CMKs whose Origin parameter is set to EXTERNAL.
  * - The public key and token that are returned by the GetParametersForImport operation must be used together. The public key and token can be used to import key material only for the CMK that is specified when you call the operation.
  * - The public key and token that are returned vary each time you call the GetParametersForImport operation.
  * - You must specify the type of the public key and the encryption algorithm that are used to encrypt key material. The following table lists the types of public keys and the encryption algorithms allowed for each type.   
  * | Public key type | Encryption algorithm | Description |
  * | --------------- | -------------------- | ----------- |
  * | RSA_2048 | RSAES_PKCS1_V1_5 
  * RSAES_OAEP_SHA_1 
  * RSAES_OAEP_SHA_256 | CMKs of all regions and all protection levels are supported. 
  * Dedicated Key Management Service (KMS) does not support RSAES_OAEP_SHA_1. |
  * | EC_SM2 | SM2PKE | CMKs whose ProtectionLevel is set to HSM are supported. The SM2 algorithm is developed and approved by the State Cryptography Administration of China. The SM2 algorithm can be used only to import key material for a CMK whose ProtectionLevel is set to HSM. You can use the SM2 algorithm only when you enable the Managed HSM feature for KMS in the Chinese mainland. For more information, see [Overview of Managed HSM](https://www.alibabacloud.com/help/en/key-management-service/latest/managed-hsm-overview). |
  * For more information, see [Import key material](https://www.alibabacloud.com/help/en/key-management-service/latest/import-key-material). This topic provides an example on how to query the parameters that are used to import key material for a CMK. The ID of the CMK is `1234abcd-12ab-34cd-56ef-12345678****`, the encryption algorithm is `RSAES_PKCS1_V1_5`, and the public key is of the `RSA_2048` type. The parameters that are returned include the ID of the CMK, the public key that is used to encrypt the key material, the token that is used to import the key material, and the time when the token expires.
  *
  * @param request GetParametersForImportRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetParametersForImportResponse
 */
async function getParametersForImportWithOptions(request: GetParametersForImportRequest, runtime: Util.RuntimeOptions): GetParametersForImportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.wrappingAlgorithm)) {
    query['WrappingAlgorithm'] = request.wrappingAlgorithm;
  }
  if (!Util.isUnset(request.wrappingKeySpec)) {
    query['WrappingKeySpec'] = request.wrappingKeySpec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetParametersForImport',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The returned parameters can be used to call the [ImportKeyMaterial](https://www.alibabacloud.com/help/en/key-management-service/latest/importkeymaterial) operation.
  * - You can import key material only for CMKs whose Origin parameter is set to EXTERNAL.
  * - The public key and token that are returned by the GetParametersForImport operation must be used together. The public key and token can be used to import key material only for the CMK that is specified when you call the operation.
  * - The public key and token that are returned vary each time you call the GetParametersForImport operation.
  * - You must specify the type of the public key and the encryption algorithm that are used to encrypt key material. The following table lists the types of public keys and the encryption algorithms allowed for each type.   
  * | Public key type | Encryption algorithm | Description |
  * | --------------- | -------------------- | ----------- |
  * | RSA_2048 | RSAES_PKCS1_V1_5 
  * RSAES_OAEP_SHA_1 
  * RSAES_OAEP_SHA_256 | CMKs of all regions and all protection levels are supported. 
  * Dedicated Key Management Service (KMS) does not support RSAES_OAEP_SHA_1. |
  * | EC_SM2 | SM2PKE | CMKs whose ProtectionLevel is set to HSM are supported. The SM2 algorithm is developed and approved by the State Cryptography Administration of China. The SM2 algorithm can be used only to import key material for a CMK whose ProtectionLevel is set to HSM. You can use the SM2 algorithm only when you enable the Managed HSM feature for KMS in the Chinese mainland. For more information, see [Overview of Managed HSM](https://www.alibabacloud.com/help/en/key-management-service/latest/managed-hsm-overview). |
  * For more information, see [Import key material](https://www.alibabacloud.com/help/en/key-management-service/latest/import-key-material). This topic provides an example on how to query the parameters that are used to import key material for a CMK. The ID of the CMK is `1234abcd-12ab-34cd-56ef-12345678****`, the encryption algorithm is `RSAES_PKCS1_V1_5`, and the public key is of the `RSA_2048` type. The parameters that are returned include the ID of the CMK, the public key that is used to encrypt the key material, the token that is used to import the key material, and the time when the token expires.
  *
  * @param request GetParametersForImportRequest
  * @return GetParametersForImportResponse
 */
async function getParametersForImport(request: GetParametersForImportRequest): GetParametersForImportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getParametersForImportWithOptions(request, runtime);
}

model GetPublicKeyRequest {
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK. You can also set this parameter to an alias that is bound to the CMK. For more information, see [Use aliases](~~68522~~).', example='5c438b18-05be-40ad-b6c2-3be6752c****'),
  keyVersionId?: string(name='KeyVersionId', description='The globally unique ID of the CMK version.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
}

model GetPublicKeyResponseBody = {
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK.

>  If you set the KeyId parameter to the alias of the CMK, the ID of the CMK to which the alias is bound is returned.', example='5c438b18-05be-40ad-b6c2-3be6752c****'),
  keyVersionId?: string(name='KeyVersionId', description='The version of the CMK that is used to encrypt the plaintext.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
  publicKey?: string(name='PublicKey', description='The public key returned in the PEM format.', example='-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAs5Yu9AEgATN2/e3nUz1K\\nEy6ng8MSPutcse2/VECG/NUF9C6D4IsJ64ShzY3dcn34WYzTOe916eMJFxyrNrSw\\nHtc4UOR5AvaoRrfpgu2uq+i70/ZXrWL+pGb1hgZV8cWheIHMxwrR3IiQlM5qN7EF\\n9BdyWtyBfUGsp0Bn1VqlPc5G0x0a9xU2z9YtP994yDenNVIoIQ6Cov1lIEuwXAb2\\n7boC41ePXwD0JWt41sP+rgCmpjBx00puIG+IlnoReEgI1ZGYmK98GgA/XzmNjZiD\\nyvXJZAcM33Ue85+PkR5iHTtSEbi4QAoqpJabprUzz3Fin2j1dRrcacxGb7p31A9c\\nJQIDAQAB\\n-----END PUBLIC KEY-----\\n'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='475f1620-b9d3-4d35-b5c6-3fbdd941423d'),
}

model GetPublicKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPublicKeyResponseBody(name='body'),
}

async function getPublicKeyWithOptions(request: GetPublicKeyRequest, runtime: Util.RuntimeOptions): GetPublicKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keyVersionId)) {
    query['KeyVersionId'] = request.keyVersionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPublicKey',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPublicKey(request: GetPublicKeyRequest): GetPublicKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPublicKeyWithOptions(request, runtime);
}

model GetRandomPasswordRequest {
  excludeCharacters?: string(name='ExcludeCharacters', description='The characters that are not included in the password to be generated.

Valid values:

` Valid characters: 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ! \\"#$%&\\"()*+,-. /:;<=>? @[\\] your_project_id} ~  `.

This parameter is empty by default.', example='ABCabc'),
  excludeLowercase?: string(name='ExcludeLowercase', description='Specifies whether to exclude lowercase letters.

Valid values:

*   true
*   false', example='false'),
  excludeNumbers?: string(name='ExcludeNumbers', description='Specifies whether to exclude digits.

Valid values:

*   true
*   false', example='false'),
  excludePunctuation?: string(name='ExcludePunctuation', description='Specifies whether to exclude special characters.

Valid values:

*   true
*   false', example='false'),
  excludeUppercase?: string(name='ExcludeUppercase', description='Specifies whether to exclude uppercase letters.

Valid values:

*   true
*   false', example='false'),
  passwordLength?: string(name='PasswordLength', description='The number of bytes that the password to be generated contains.

Valid values: 8 to 128.

Default value: 32', example='32'),
  requireEachIncludedType?: string(name='RequireEachIncludedType', description='Specifies whether to include all the preceding character types.

Valid values:

*   true
*   false', example='true'),
}

model GetRandomPasswordResponseBody = {
  randomPassword?: string(name='RandomPassword', description='The generated random password.', example='IxGn>NMmNB(y?iZ<Yc,_H/{2GC\\"U****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6b0cbe25-5e33-467e-972e-7a83c6c97604'),
}

model GetRandomPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRandomPasswordResponseBody(name='body'),
}

async function getRandomPasswordWithOptions(request: GetRandomPasswordRequest, runtime: Util.RuntimeOptions): GetRandomPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.excludeCharacters)) {
    query['ExcludeCharacters'] = request.excludeCharacters;
  }
  if (!Util.isUnset(request.excludeLowercase)) {
    query['ExcludeLowercase'] = request.excludeLowercase;
  }
  if (!Util.isUnset(request.excludeNumbers)) {
    query['ExcludeNumbers'] = request.excludeNumbers;
  }
  if (!Util.isUnset(request.excludePunctuation)) {
    query['ExcludePunctuation'] = request.excludePunctuation;
  }
  if (!Util.isUnset(request.excludeUppercase)) {
    query['ExcludeUppercase'] = request.excludeUppercase;
  }
  if (!Util.isUnset(request.passwordLength)) {
    query['PasswordLength'] = request.passwordLength;
  }
  if (!Util.isUnset(request.requireEachIncludedType)) {
    query['RequireEachIncludedType'] = request.requireEachIncludedType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRandomPassword',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRandomPassword(request: GetRandomPasswordRequest): GetRandomPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRandomPasswordWithOptions(request, runtime);
}

model GetSecretValueRequest {
  fetchExtendedConfig?: boolean(name='FetchExtendedConfig', description='Specifies whether to obtain the extended configuration of the secret. Valid values:

*   true
*   false: This is the default value.

>  This parameter is ignored for a generic secret.', example='true'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='secret001'),
  versionId?: string(name='VersionId', description='The version number of the secret value. If you specify this parameter, Secrets Manager returns the secret value of the specified version.

>  This parameter is ignored for a managed ApsaraDB RDS secret, a managed RAM secret, or a managed ECS secret.', example='00000000000000000000000000000001'),
  versionStage?: string(name='VersionStage', description='The stage label that marks the secret version. If you specify this parameter, Secrets Manager returns the secret value of the version that is marked with the specified stage label.

Default value: ACSCurrent.

>  For a managed ApsaraDB RDS secret, a managed RAM secret, or a managed ECS secret, Secrets Manager can return only the secret value of the version marked with ACSPrevious or ACSCurrent.', example='ACSCurrent'),
}

model GetSecretValueResponseBody = {
  automaticRotation?: string(name='AutomaticRotation', description='Indicates whether automatic rotation is enabled. Valid values:

*   Enabled: indicates that automatic rotation is enabled.
*   Disabled: indicates that automatic rotation is disabled.
*   Invalid: indicates that the status of automatic rotation is abnormal. In this case, Secrets Manager cannot automatically rotate the secret.

>  This parameter is returned only for a managed ApsaraDB RDS secret, a managed RAM secret, or a managed ECS secret.', example='Enabled'),
  createTime?: string(name='CreateTime', description='The time when the secret was created.', example='2020-02-21T15:39:26Z'),
  extendedConfig?: string(name='ExtendedConfig', description='The extended configuration of the secret.

>  This parameter is returned if you set the FetchExtendedConfig parameter to true. This parameter is returned only for a managed ApsaraDB RDS secret, a managed RAM secret, or a managed ECS secret.', example='{\\"SecretSubType\\":\\"SingleUser\\", \\"DBInstanceId\\":\\"rm-uf667446pc955****\\",  \\"CustomData\\":{} }'),
  lastRotationDate?: string(name='LastRotationDate', description='The time when the last rotation was performed.

>  This parameter is returned if the secret was rotated.', example='2020-07-05T08:22:03Z'),
  nextRotationDate?: string(name='NextRotationDate', description='The time when the next rotation will be performed.

>  This parameter is returned if automatic rotation is enabled.', example='2020-07-06T18:22:03Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6a3e9c36-1150-4881-84d3-eb8672fcafad'),
  rotationInterval?: string(name='RotationInterval', description='The interval for automatic rotation.

The value is in the `integer[unit]` format. The `unit` field has a fixed value of s. For example, if the value is 604800s, automatic rotation is performed at a 7-day interval.

>  This parameter is returned if automatic rotation is enabled.', example='604800s'),
  secretData?: string(name='SecretData', description='The secret value. Secrets Manager decrypts the ciphertext of the secret value and returns the plaintext of the secret value in this parameter.

*   For a generic secret, the secret value of the specified version is returned.

*   For a managed ApsaraDB RDS secret, the value is returned in the following format:`{"AccountName":"","AccountPassword":""}` .

*   For a managed RAM secret, the secret value is returned in the following format: `{"AccessKeyId":"Adfdsfd","AccessKeySecret":"fdsfdsf","GenerateTimestamp": "2016-03-25T10:42:40Z"}`.

*   For a managed ECS secret, the secret value is returned in one of the following formats:

    *   `{"UserName":"root","Password":"H5asdasdsads****"}`: The secret value is returned in this format if the ECS secret is a password.
    *   `{"UserName":"root","PublicKey":"ssh-rsa ****mKwnVix9YTFY9Rs= imported-openssh-key","PrivateKey": "d6bee1cb-2e14-4277-ba6b-73786b21****"}`: The secret value is returned in this format is the ECS secret is a pair of SSH keys. The private key is in the Privacy Enhanced Mail (PEM) format.', example='testdata1'),
  secretDataType?: string(name='SecretDataType', description='The type of the secret value. Valid values:

*   text
*   binary', example='binary'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='secret001'),
  secretType?: string(name='SecretType', description='The type of the secret. Valid values:

*   Generic: indicates a generic secret.
*   Rds: indicates a managed ApsaraDB RDS secret.
*   RAMCredentials: indicates a managed RAM secret.
*   ECS: indicates a managed ECS secret.', example='Generic'),
  versionId?: string(name='VersionId', description='The version number of the secret value.', example='00000000000000000000000000000001'),
  versionStages?: {
    versionStage?: [ string ](name='VersionStage')
  }(name='VersionStages', description='The stage labels that mark the secret versions.'),
}

model GetSecretValueResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSecretValueResponseBody(name='body'),
}

/**
  * If you do not specify a version number or stage label, Secrets Manager returns the secret value of the version marked with ACSCurrent.
  * If a customer master key (CMK) is specified to encrypt the secret value, you must also have the `kms:Decrypt` permission on the CMK to call the GetSecretValue operation.
  * In this example, the value of the secret named `secret001` is obtained. The secret value is returned in the `SecretData` parameter. The secret value is `testdata1`.
  *
  * @param request GetSecretValueRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetSecretValueResponse
 */
async function getSecretValueWithOptions(request: GetSecretValueRequest, runtime: Util.RuntimeOptions): GetSecretValueResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fetchExtendedConfig)) {
    query['FetchExtendedConfig'] = request.fetchExtendedConfig;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionStage)) {
    query['VersionStage'] = request.versionStage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSecretValue',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you do not specify a version number or stage label, Secrets Manager returns the secret value of the version marked with ACSCurrent.
  * If a customer master key (CMK) is specified to encrypt the secret value, you must also have the `kms:Decrypt` permission on the CMK to call the GetSecretValue operation.
  * In this example, the value of the secret named `secret001` is obtained. The secret value is returned in the `SecretData` parameter. The secret value is `testdata1`.
  *
  * @param request GetSecretValueRequest
  * @return GetSecretValueResponse
 */
async function getSecretValue(request: GetSecretValueRequest): GetSecretValueResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecretValueWithOptions(request, runtime);
}

model ImportKeyMaterialRequest {
  encryptedKeyMaterial?: string(name='EncryptedKeyMaterial', description='Use **GetParametersForImport** the Returned public key and the base64-encoded key material.', example='bCPZx7I6v6KXsqEpr2OXKxuj2CCRtKdwp75Bw+BGncYqBdfjFBYRtOE6HRlT0oeiRDWzwnw9OA54OL36smDJrq4Lo9x0CyYDiuKnRkcKtMtlzW0din7Pd7IlZWWRdVueiw2qpzl7PkUWQGTdsdbzpfJJQ+qj/cRIrk/E83UGyeyytSpgnb+lu0xEYcPajRyWNsbi98N3pqqQzHXNNHO2NJqHlnQgglqTiBEjkGeKFhfKmTc3vjulIdVa3EaVIN6lwWfgx+UUYSrvbA77WDYKlDsZ4SbK2/T7za9Tp1qU7Ynqba7OKGVVj7PMbiaO80AxWZnjUMYCgEp5w7V+seOXqw=='),
  importToken?: string(name='ImportToken', description='By calling **GetParametersForImport** the import token.', example='Base64String'),
  keyId?: string(name='KeyId', description='The ID of the CMK to be imported.', example='1234abcd-12ab-34cd-56ef-12345678****'),
  keyMaterialExpireUnix?: long(name='KeyMaterialExpireUnix', description='The time when the key material expires.

If this parameter is not specified or set this parameter to 0, the key material does not expire.

>  The value cannot be earlier than the time when the API is called (based on the server time).', example='0'),
}

model ImportKeyMaterialResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='ec1017cf-ead4-f3ca-babc-c3b34f3dbecb'),
}

model ImportKeyMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ImportKeyMaterialResponseBody(name='body'),
}

/**
  * Call [CreateKey](~~28947~~) when creating a CMK, you can select its key material source as external. **Origin** set to **EXTERNAL**. This API is used to import the key material into the CMK.
  * *   To view the CMK **Origin**, see [DescribeKey](~~28952~~).
  * *   Before importing key material, you need to call the [GetParametersForImport](~~68621~~) obtain the parameters required to import the key material, including the public key and import token.
  * > *   The key type of the pair is **Aliyun\\_AES\\_256** the key material must be 256 bits. The key type must be **Aliyun\\_SM4** the CMK and key material must be 128 bits.
  * > *   You can set the expiration time for the key material, or you can set it to never expire.
  * > *   You can reimport the key material and reset the expiration time for the specified CMK at any time, but the same key material must be imported.
  * > *   After the imported key material expires or is deleted, the specified CMK is unavailable until the same key material are imported again.
  * > *   A Key material can be imported to multiple cmks, but any Data or Data Key encrypted by one CMK cannot be decrypted by another CMK.
  *
  * @param request ImportKeyMaterialRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ImportKeyMaterialResponse
 */
async function importKeyMaterialWithOptions(request: ImportKeyMaterialRequest, runtime: Util.RuntimeOptions): ImportKeyMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.encryptedKeyMaterial)) {
    query['EncryptedKeyMaterial'] = request.encryptedKeyMaterial;
  }
  if (!Util.isUnset(request.importToken)) {
    query['ImportToken'] = request.importToken;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.keyMaterialExpireUnix)) {
    query['KeyMaterialExpireUnix'] = request.keyMaterialExpireUnix;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportKeyMaterial',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Call [CreateKey](~~28947~~) when creating a CMK, you can select its key material source as external. **Origin** set to **EXTERNAL**. This API is used to import the key material into the CMK.
  * *   To view the CMK **Origin**, see [DescribeKey](~~28952~~).
  * *   Before importing key material, you need to call the [GetParametersForImport](~~68621~~) obtain the parameters required to import the key material, including the public key and import token.
  * > *   The key type of the pair is **Aliyun\\_AES\\_256** the key material must be 256 bits. The key type must be **Aliyun\\_SM4** the CMK and key material must be 128 bits.
  * > *   You can set the expiration time for the key material, or you can set it to never expire.
  * > *   You can reimport the key material and reset the expiration time for the specified CMK at any time, but the same key material must be imported.
  * > *   After the imported key material expires or is deleted, the specified CMK is unavailable until the same key material are imported again.
  * > *   A Key material can be imported to multiple cmks, but any Data or Data Key encrypted by one CMK cannot be decrypted by another CMK.
  *
  * @param request ImportKeyMaterialRequest
  * @return ImportKeyMaterialResponse
 */
async function importKeyMaterial(request: ImportKeyMaterialRequest): ImportKeyMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return importKeyMaterialWithOptions(request, runtime);
}

model ListAliasesRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

Pages start from page 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Valid values: 0 to 100.

Default value: 10.', example='10'),
}

model ListAliasesResponseBody = {
  aliases?: {
    alias?: [ 
    {
      aliasArn?: string(name='AliasArn', description='The Alibaba Cloud Resource Name (ARN) of the alias.', example='acs:kms:cn-hangzhou:123456:alias/ExampleAlias1'),
      aliasName?: string(name='AliasName', description='The ID of the alias.', example='alias/ExampleAlias1'),
      keyId?: string(name='KeyId', description='The CMK to which the alias belongs.', example='08c33a6f-4e0a-4a1b-a3fa-7ddfa1d****'),
    }
  ](name='Alias')
  }(name='Aliases', description='The alias of the user.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1b57992c-834b-4811-a889-f8bac1ba0353'),
  totalCount?: int32(name='TotalCount', description='The total number of returned aliases.', example='1'),
}

model ListAliasesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAliasesResponseBody(name='body'),
}

async function listAliasesWithOptions(request: ListAliasesRequest, runtime: Util.RuntimeOptions): ListAliasesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAliases',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAliases(request: ListAliasesRequest): ListAliasesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAliasesWithOptions(request, runtime);
}

model ListAliasesByKeyIdRequest {
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK.', example='1234abcd-12ab-34cd-56ef-12345678****'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

Valid values: an integer that is greater than 0.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Valid values: 0 to 101.

Default value: 10', example='10'),
}

model ListAliasesByKeyIdResponseBody = {
  aliases?: {
    alias?: [ 
    {
      aliasArn?: string(name='AliasArn', description='The Alibaba Cloud Resource Name (ARN) of the alias.', example='acs:kms:cn-hangzhou:123456:alias/ExampleAlias1'),
      aliasName?: string(name='AliasName', description='The ID of the alias.', example='alias/ExampleAlias1'),
      keyId?: string(name='KeyId', description='The CMK to which an alias is bound.', example='08c33a6f-4e0a-4a1b-a3fa-7ddfa1d4****'),
    }
  ](name='Alias')
  }(name='Aliases', description='An array that consists of aliases.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='1b57992c-834b-4811-a889-f8bac1ba0353'),
  totalCount?: int32(name='TotalCount', description='The total number of returned CMKs.', example='1'),
}

model ListAliasesByKeyIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAliasesByKeyIdResponseBody(name='body'),
}

async function listAliasesByKeyIdWithOptions(request: ListAliasesByKeyIdRequest, runtime: Util.RuntimeOptions): ListAliasesByKeyIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAliasesByKeyId',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAliasesByKeyId(request: ListAliasesByKeyIdRequest): ListAliasesByKeyIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAliasesByKeyIdWithOptions(request, runtime);
}

model ListKeyVersionsRequest {
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK. You can also set this parameter to an alias that is bound to the CMK. For more information, see [Use aliases](~~68522~~).', example='0b30658a-ed1a-4922-b8f7-a673ca9c****'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

Pages start from page 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Valid values: 0 to 101.

Default value: 10.', example='10'),
}

model ListKeyVersionsResponseBody = {
  keyVersions?: {
    keyVersion?: [ 
    {
      creationDate?: string(name='CreationDate', description='The date and time when the CMK version was created. The time is displayed in UTC.', example='2016-03-25T10:42:40Z'),
      keyId?: string(name='KeyId', description='The globally unique ID of the CMK.

>  If you set the KeyId parameter to the alias of the CMK, the ID of the CMK to which the alias is bound is returned.', example='0b30658a-ed1a-4922-b8f7-a673ca9c****'),
      keyVersionId?: string(name='KeyVersionId', description='The globally unique ID of the CMK version.', example='1e3304fd-68ac-4d5b-8886-ae5f01a1****'),
    }
  ](name='KeyVersion')
  }(name='KeyVersions', description='An array that consists of key versions.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='f71204c4-53cd-4eea-b405-653ba2db7e86'),
  totalCount?: int32(name='TotalCount', description='The total number of returned key versions.', example='3'),
}

model ListKeyVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListKeyVersionsResponseBody(name='body'),
}

async function listKeyVersionsWithOptions(request: ListKeyVersionsRequest, runtime: Util.RuntimeOptions): ListKeyVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListKeyVersions',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listKeyVersions(request: ListKeyVersionsRequest): ListKeyVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listKeyVersionsWithOptions(request, runtime);
}

model ListKeysRequest {
  filters?: string(name='Filters', description='The ID of the request, which is used to locate and troubleshoot issues.', example='[{"Key":"KeyState", "Values":["Enabled","Disabled"]}]'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
}

model ListKeysResponseBody = {
  keys?: {
    key?: [ 
    {
      keyArn?: string(name='KeyArn', example='acs:kms:cn-hangzhou:123456:key/80e9409f-78fa-42ab-84bd-83f40c81****'),
      keyId?: string(name='KeyId', example='08c33a6f-4e0a-4a1b-a3fa-7ddfa1d4****'),
    }
  ](name='Key')
  }(name='Keys'),
  pageNumber?: int32(name='PageNumber', description='The total number of CMKs.', example='1'),
  pageSize?: int32(name='PageSize', description='An array that consists of the CMKs of the current Alibaba Cloud account in the current region.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the CMK. The ID must be globally unique.', example='8252db58-2036-408c-a3d5-56e656dc2551'),
  totalCount?: int32(name='TotalCount', description='The Alibaba Cloud Resource Name (ARN) of the CMK.', example='3'),
}

model ListKeysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListKeysResponseBody(name='body'),
}

async function listKeysWithOptions(request: ListKeysRequest, runtime: Util.RuntimeOptions): ListKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListKeys',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listKeys(request: ListKeysRequest): ListKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listKeysWithOptions(request, runtime);
}

model ListResourceTagsRequest {
  keyId?: string(name='KeyId', description='The globally unique ID of the CMK.', example='1234abcd-12ab-34cd-56ef-12345678****'),
}

model ListResourceTagsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4162a6af-bc99-40b3-a552-89dcc8aaf7c8'),
  tags?: {
    tag?: [ 
    {
      keyId?: string(name='KeyId', description='The globally unique ID of the CMK.', example='33caea95-c3e5-4b3e-a9c6-cec76e4e****'),
      tagKey?: string(name='TagKey', description='The tag key.', example='Project'),
      tagValue?: string(name='TagValue', description='The tag value.', example='Test'),
    }
  ](name='Tag')
  }(name='Tags', description='The tags of the CMK.'),
}

model ListResourceTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceTagsResponseBody(name='body'),
}

/**
  * Request format: KeyId="string"
  *
  * @param request ListResourceTagsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListResourceTagsResponse
 */
async function listResourceTagsWithOptions(request: ListResourceTagsRequest, runtime: Util.RuntimeOptions): ListResourceTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceTags',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Request format: KeyId="string"
  *
  * @param request ListResourceTagsRequest
  * @return ListResourceTagsResponse
 */
async function listResourceTags(request: ListResourceTagsRequest): ListResourceTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceTagsWithOptions(request, runtime);
}

model ListSecretVersionIdsRequest {
  includeDeprecated?: string(name='IncludeDeprecated', description='Specifies whether to return deprecated secret versions.

Valid values:

*   false: no
*   true: yes

Default value: false.', example='false'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 10.', example='10'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='secret001'),
}

model ListSecretVersionIdsResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='5b75d8b1-5b6a-4ec0-8e0c-c08befdfad47'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='secret001'),
  totalCount?: int32(name='TotalCount', description='The number of entries returned on the current page.', example='4'),
  versionIds?: {
    versionId?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the secret version was created.', example='2020-02-21T15:39:26Z'),
      versionId?: string(name='VersionId', description='The version number.', example='00000000000000000000000000000000203'),
      versionStages?: {
        versionStage?: [ string ](name='VersionStage')
      }(name='VersionStages', description='The stage labels that mark the secret version.'),
    }
  ](name='VersionId')
  }(name='VersionIds', description='The list of secret versions.'),
}

model ListSecretVersionIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSecretVersionIdsResponseBody(name='body'),
}

/**
  * The secret value is not included in the returned version information. By default, deprecated secret versions are not returned.
  *
  * @param request ListSecretVersionIdsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListSecretVersionIdsResponse
 */
async function listSecretVersionIdsWithOptions(request: ListSecretVersionIdsRequest, runtime: Util.RuntimeOptions): ListSecretVersionIdsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.includeDeprecated)) {
    query['IncludeDeprecated'] = request.includeDeprecated;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSecretVersionIds',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The secret value is not included in the returned version information. By default, deprecated secret versions are not returned.
  *
  * @param request ListSecretVersionIdsRequest
  * @return ListSecretVersionIdsResponse
 */
async function listSecretVersionIds(request: ListSecretVersionIdsRequest): ListSecretVersionIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecretVersionIdsWithOptions(request, runtime);
}

model ListSecretsRequest {
  fetchTags?: string(name='FetchTags', description='The number of entries to return on each page.

Valid values: 1 to 100.

Default value: 10.', example='false'),
  filters?: string(name='Filters', description='The number of entries returned per page.', example='[{"Key":"SecretName", "Values":["Val1","Val2"]}]'),
  pageNumber?: int32(name='PageNumber', description='The secret filter. The filter consists of one or more key-value pairs. You can specify one key-value pair or leave this parameter empty. If you use one tag key or tag value to filter resources, up to 4,000 resources can be queried. If you want to query more than 4,000 resources, call the [ListResourceTags](~~120090~~) operation.

*   Key

    *   Description: the property that you want to filter.

    *   Type: string.

    *   Valid values:

        *   SecretName: the secret name.
        *   Description: the description of the secret.
        *   TagKey: the tag key.
        *   TagValue: the tag value.

*   Values

    *   Description: the value to be included after filtering.

    *   Type: string.

    *   Length: 0 to 10.

    *   Valid values:

        *   If the Key field is set to SecretName, the value must be 1 to 192 characters in length and can contain letters, digits, and special characters `_ / + = . @ -`.
        *   If the Key field is set to Description, the value must be 1 to 256 characters in length.
        *   If the Key field is set to TagKey, the value must be 1 to 256 characters in length and can contain letters, digits, and special characters `/ _ - . + = @ :`.
        *   If the Key field is set to TagValue, the value must be 1 to 256 characters in length and can contain letters, numbers, and special characters `/ _ - . + = @ :`.

The logical relationship between values of the Values field in a key-value pair is OR. Example: `[ {"Key":"SecretName", "Values":["sec1","sec2"]}]`. In this example, the semantics are `SecretName=sec 1 OR SecretName=sec 2`.', example='1'),
  pageSize?: int32(name='PageSize', description='The page number of the returned page.', example='2'),
}

model ListSecretsResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The ID of the request, which is used to locate and troubleshoot issues.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of returned secrets.', example='2'),
  requestId?: string(name='RequestId', description='The list of secrets.', example='6a6287a0-ff34-4780-a790-fdfca900557f'),
  secretList?: {
    secret?: [ 
    {
      createTime?: string(name='CreateTime', description='The tag value.', example='2022-07-17T07:59:05Z'),
      plannedDeleteTime?: string(name='PlannedDeleteTime', description='The resource tags of the secret.

This parameter is not returned if you set the FetchTags parameter to false or do not specify the FetchTags parameter.', example='2022-08-17T07:59:05Z'),
      secretName?: string(name='SecretName', description='The type of the secret. Valid values:

*   Generic: indicates a generic secret.
*   Rds: indicates a managed ApsaraDB RDS secret.', example='secret001'),
      secretType?: string(name='SecretType', description='The time when the secret was created.', example='Generic'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey', example='key1'),
          tagValue?: string(name='TagValue', example='val1'),
        }
      ](name='Tag')
      }(name='Tags', description='The tag key.'),
      updateTime?: string(name='UpdateTime', description='The time when the secret is scheduled to be deleted.', example='2022-07-17T07:59:05Z'),
    }
  ](name='Secret')
  }(name='SecretList', description='The time when the secret was updated.'),
  totalCount?: int32(name='TotalCount', description='The secret name.', example='55'),
}

model ListSecretsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSecretsResponseBody(name='body'),
}

/**
  * Specifies whether to return the resource tags of the secret. Valid values:
  * *   true: returns the resource tags.
  * *   false: does not return the resource tags. This is the default value.
  *
  * @param request ListSecretsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListSecretsResponse
 */
async function listSecretsWithOptions(request: ListSecretsRequest, runtime: Util.RuntimeOptions): ListSecretsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fetchTags)) {
    query['FetchTags'] = request.fetchTags;
  }
  if (!Util.isUnset(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSecrets',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Specifies whether to return the resource tags of the secret. Valid values:
  * *   true: returns the resource tags.
  * *   false: does not return the resource tags. This is the default value.
  *
  * @param request ListSecretsRequest
  * @return ListSecretsResponse
 */
async function listSecrets(request: ListSecretsRequest): ListSecretsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecretsWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model OpenKmsServiceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='3455b9b4-95c1-419d-b310-db6a53b09a39'),
}

model OpenKmsServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenKmsServiceResponseBody(name='body'),
}

/**
  * When you call this operation, note that:
  * - KMS is a paid service. For more information about the billing method, see [Billing description](https://www.alibabacloud.com/help/en/key-management-service/latest/billing-billing).
  * - An Alibaba Cloud account can activate KMS only once.
  * - Make sure that your Alibaba Cloud account has passed real-name authentication.
  *
  * @param request OpenKmsServiceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return OpenKmsServiceResponse
 */
async function openKmsServiceWithOptions(runtime: Util.RuntimeOptions): OpenKmsServiceResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'OpenKmsService',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * When you call this operation, note that:
  * - KMS is a paid service. For more information about the billing method, see [Billing description](https://www.alibabacloud.com/help/en/key-management-service/latest/billing-billing).
  * - An Alibaba Cloud account can activate KMS only once.
  * - Make sure that your Alibaba Cloud account has passed real-name authentication.
  *
  * @return OpenKmsServiceResponse
 */
async function openKmsService(): OpenKmsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openKmsServiceWithOptions(runtime);
}

model PutSecretValueRequest {
  secretData?: string(name='SecretData', description='The secret value. The value is encrypted and then stored in the new version.', example='importantdata'),
  secretDataType?: string(name='SecretDataType', description='The type of the secret value. Valid values:

*   text: This is the default value.
*   binary', example='text'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='secret001'),
  versionId?: string(name='VersionId', description='The new version of the secret value. Version numbers must be unique in each secret.', example='00000000000000000000000000000000203'),
  versionStages?: string(name='VersionStages', description='The stage labels that are used to mark the new version. If you do not specify this parameter, Secrets Manager marks the new version with ACSCurrent.', example='["ACSCurrent","ACSNext"]'),
}

model PutSecretValueResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='f94ec9d3-2d10-4922-9a5c-5dcd5ebcb5e8'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='secret001'),
  versionId?: string(name='VersionId', description='The new version of the secret value.', example='00000000000000000000000000000000203'),
  versionStages?: {
    versionStage?: [ string ](name='VersionStage')
  }(name='VersionStages', description='The stage labels that are used to mark the new version.'),
}

model PutSecretValueResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutSecretValueResponseBody(name='body'),
}

/**
  * This operation is used to store the secret values of new versions. It cannot be used to modify the secret value of an existing version.
  * By default, the newly stored secret value is marked with ACSCurrent, and the mark for the previous version of the secret value is changed from ACSCurrent to ACSPrevious. If you specify the VersionStage parameter, the newly stored secret value is marked with the stage label that you specify.
  * You must specify a version number when you call the operation. Secrets Manager performs operations based on the following rules:
  * *   If the specified version number does not exist in the secret, Secrets Manager creates the version and stores the secret value.
  * *   If the specified version number already exists in the secret and the secret value of the existing version is the same as the secret value that you specify, Secrets Manager ignores the request and returns a success message. The request is idempotent.
  * *   If the specified version number already exists in the secret but the secret value of the existing version is different from the secret value that you specify, Secrets Manager rejects the request and returns a failure message.
  * Limits: This operation is available only for standard secrets.
  * In this example, the secret value of a new version is stored into the `secret001` secret. The `VersionId` parameter is set to `00000000000000000000000000000000203` as the new version, and the `SecretData` parameter is set to `importantdata`.
  *
  * @param request PutSecretValueRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return PutSecretValueResponse
 */
async function putSecretValueWithOptions(request: PutSecretValueRequest, runtime: Util.RuntimeOptions): PutSecretValueResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.secretData)) {
    query['SecretData'] = request.secretData;
  }
  if (!Util.isUnset(request.secretDataType)) {
    query['SecretDataType'] = request.secretDataType;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionStages)) {
    query['VersionStages'] = request.versionStages;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutSecretValue',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation is used to store the secret values of new versions. It cannot be used to modify the secret value of an existing version.
  * By default, the newly stored secret value is marked with ACSCurrent, and the mark for the previous version of the secret value is changed from ACSCurrent to ACSPrevious. If you specify the VersionStage parameter, the newly stored secret value is marked with the stage label that you specify.
  * You must specify a version number when you call the operation. Secrets Manager performs operations based on the following rules:
  * *   If the specified version number does not exist in the secret, Secrets Manager creates the version and stores the secret value.
  * *   If the specified version number already exists in the secret and the secret value of the existing version is the same as the secret value that you specify, Secrets Manager ignores the request and returns a success message. The request is idempotent.
  * *   If the specified version number already exists in the secret but the secret value of the existing version is different from the secret value that you specify, Secrets Manager rejects the request and returns a failure message.
  * Limits: This operation is available only for standard secrets.
  * In this example, the secret value of a new version is stored into the `secret001` secret. The `VersionId` parameter is set to `00000000000000000000000000000000203` as the new version, and the `SecretData` parameter is set to `importantdata`.
  *
  * @param request PutSecretValueRequest
  * @return PutSecretValueResponse
 */
async function putSecretValue(request: PutSecretValueRequest): PutSecretValueResponse {
  var runtime = new Util.RuntimeOptions{};
  return putSecretValueWithOptions(request, runtime);
}

model ReEncryptRequest {
  ciphertextBlob?: string(name='CiphertextBlob', description='The ciphertext that you want to re-encrypt.

You can set this parameter to the ciphertext that is returned after a symmetric or asymmetric encryption operation.

*   Symmetric encryption: the ciphertext returned after you call the [Encrypt](~~28949~~), [GenerateDataKey](~~28948~~), [GenerateDataKeyWithoutPlaintext](~~134043~~), or [GenerateAndExportDataKey](~~176804~~) operation
*   Asymmetric encryption: the public key-encrypted ciphertext returned after you call the [GenerateAndExportDataKey](~~176804~~) operation, or the ciphertext encrypted by using the public key of an asymmetric key pair outside KMS', example='ODZhOWVmZDktM2QxNi00ODk0LWJkNGYtMWZjNDNmM2YyYWJmS7FmDBBQ0BkKsQrtRnidtPwirmDcS0ZuJCU41xxAAWk4Z8qsADfbV0b+i6kQmlvj79dJdGOvtX69Uycs901q********'),
  destinationEncryptionContext?: map[string]any(name='DestinationEncryptionContext', description='A JSON string that consists of key-value pairs. This parameter specifies the EncryptionContext that is used to re-encrypt the decrypted data or data key.', example='{"Example":"Example"}'),
  destinationKeyId?: string(name='DestinationKeyId', description='The ID of the symmetric CMK that is used to re-encrypt the ciphertext after the ciphertext is decrypted.', example='1234abcd-12ab-34cd-56ef-12345678****'),
  sourceEncryptionAlgorithm?: string(name='SourceEncryptionAlgorithm', description='The encryption algorithm based on which the public key is used to encrypt the ciphertext specified by CiphertextBlob. For more information about encryption algorithms, see [AsymmetricDecrypt](~~148130~~).

Valid values:

*   RSAES_OAEP_SHA\\_256
*   RSAES_OAEP_SHA\\_1
*   SM2PKE

>  If you set CiphertextBlob to the public key-encrypted ciphertext that is returned after an asymmetric encryption operation, specify this parameter.', example='RSAES_OAEP_SHA_256'),
  sourceEncryptionContext?: map[string]any(name='SourceEncryptionContext', description='A JSON string that consists of key-value pairs. If you specify EncryptionContext when you call the [Encrypt](~~28949~~), [GenerateDataKey](~~28948~~), [GenerateDataKeyWithoutPlaintext](~~134043~~), or [GenerateAndExportDataKey](~~176804~~) operation to encrypt the data or data key, an equivalent value is required here. For more information, see [EncryptionContext](~~42975~~).

>  If you set CiphertextBlob to the ciphertext that is returned after a symmetric encryption operation, specify this parameter.', example='{"Example":"Example"}'),
  sourceKeyId?: string(name='SourceKeyId', description='The ID of the CMK that is used to decrypt the ciphertext.

This parameter is the globally unique ID of the CMK.

>  If you set CiphertextBlob to the public key-encrypted ciphertext that is returned after an asymmetric encryption operation, specify this parameter.', example='5c438b18-05be-40ad-b6c2-3be6752c****'),
  sourceKeyVersionId?: string(name='SourceKeyVersionId', description='The ID of the CMK version that is used to decrypt the ciphertext.

>  If you set CiphertextBlob to the public key-encrypted ciphertext that is returned after an asymmetric encryption operation, specify this parameter.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
}

model ReEncryptShrinkRequest {
  ciphertextBlob?: string(name='CiphertextBlob', description='The ciphertext that you want to re-encrypt.

You can set this parameter to the ciphertext that is returned after a symmetric or asymmetric encryption operation.

*   Symmetric encryption: the ciphertext returned after you call the [Encrypt](~~28949~~), [GenerateDataKey](~~28948~~), [GenerateDataKeyWithoutPlaintext](~~134043~~), or [GenerateAndExportDataKey](~~176804~~) operation
*   Asymmetric encryption: the public key-encrypted ciphertext returned after you call the [GenerateAndExportDataKey](~~176804~~) operation, or the ciphertext encrypted by using the public key of an asymmetric key pair outside KMS', example='ODZhOWVmZDktM2QxNi00ODk0LWJkNGYtMWZjNDNmM2YyYWJmS7FmDBBQ0BkKsQrtRnidtPwirmDcS0ZuJCU41xxAAWk4Z8qsADfbV0b+i6kQmlvj79dJdGOvtX69Uycs901q********'),
  destinationEncryptionContextShrink?: string(name='DestinationEncryptionContext', description='A JSON string that consists of key-value pairs. This parameter specifies the EncryptionContext that is used to re-encrypt the decrypted data or data key.', example='{"Example":"Example"}'),
  destinationKeyId?: string(name='DestinationKeyId', description='The ID of the symmetric CMK that is used to re-encrypt the ciphertext after the ciphertext is decrypted.', example='1234abcd-12ab-34cd-56ef-12345678****'),
  sourceEncryptionAlgorithm?: string(name='SourceEncryptionAlgorithm', description='The encryption algorithm based on which the public key is used to encrypt the ciphertext specified by CiphertextBlob. For more information about encryption algorithms, see [AsymmetricDecrypt](~~148130~~).

Valid values:

*   RSAES_OAEP_SHA\\_256
*   RSAES_OAEP_SHA\\_1
*   SM2PKE

>  If you set CiphertextBlob to the public key-encrypted ciphertext that is returned after an asymmetric encryption operation, specify this parameter.', example='RSAES_OAEP_SHA_256'),
  sourceEncryptionContextShrink?: string(name='SourceEncryptionContext', description='A JSON string that consists of key-value pairs. If you specify EncryptionContext when you call the [Encrypt](~~28949~~), [GenerateDataKey](~~28948~~), [GenerateDataKeyWithoutPlaintext](~~134043~~), or [GenerateAndExportDataKey](~~176804~~) operation to encrypt the data or data key, an equivalent value is required here. For more information, see [EncryptionContext](~~42975~~).

>  If you set CiphertextBlob to the ciphertext that is returned after a symmetric encryption operation, specify this parameter.', example='{"Example":"Example"}'),
  sourceKeyId?: string(name='SourceKeyId', description='The ID of the CMK that is used to decrypt the ciphertext.

This parameter is the globally unique ID of the CMK.

>  If you set CiphertextBlob to the public key-encrypted ciphertext that is returned after an asymmetric encryption operation, specify this parameter.', example='5c438b18-05be-40ad-b6c2-3be6752c****'),
  sourceKeyVersionId?: string(name='SourceKeyVersionId', description='The ID of the CMK version that is used to decrypt the ciphertext.

>  If you set CiphertextBlob to the public key-encrypted ciphertext that is returned after an asymmetric encryption operation, specify this parameter.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
}

model ReEncryptResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob', description='The ciphertext re-encrypted.', example='DZhOWVmZDktM2QxNi00ODk0LWJkNGYtMWZjNDNmM2YyYWJmaaSl+TztSIMe43nbTH/Z1Wr4XfLftKhAciUmDQXuMRl4WTvKhxjMThjK****'),
  keyId?: string(name='KeyId', description='The ID of the CMK that is used to decrypt the original ciphertext.

This parameter is the globally unique ID of the CMK.', example='2ab1a983-7072-4bbc-a582-584b5bd8****'),
  keyVersionId?: string(name='KeyVersionId', description='The ID of the CMK version that is used to decrypt the original ciphertext.', example='202b9877-5a25-46e3-a763-e20791b5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='207596a2-36d3-4840-b1bd-f87044699bd7'),
}

model ReEncryptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReEncryptResponseBody(name='body'),
}

/**
  * You can call this operation in the following scenarios:
  * *   After the CMK that was used to encrypt your data is rotated, you can call this operation to use the latest CMK version to re-encrypt the data. For more information about automatic key rotation, see [Configure automatic key rotation](~~134270~~).
  * *   The CMK that was used to encrypt your data remains unchanged, but EncryptionContext is changed. In this scenario, you can call this operation to re-encrypt the data.
  * *   You can call this operation to use a CMK in KMS to re-encrypt data or a data key that was previously encrypted by a different CMK.
  * To use the ReEncrypt operation, you must have two permissions:
  * *   kms:ReEncryptFrom on the source CMK
  * *   kms:ReEncryptTo on the destination CMK
  * *   For simplicity, you can specify kms:ReEncrypt\\* to allow both of the preceding permissions.
  *
  * @param tmpReq ReEncryptRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ReEncryptResponse
 */
async function reEncryptWithOptions(tmpReq: ReEncryptRequest, runtime: Util.RuntimeOptions): ReEncryptResponse {
  Util.validateModel(tmpReq);
  var request = new ReEncryptShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.destinationEncryptionContext)) {
    request.destinationEncryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.destinationEncryptionContext, 'DestinationEncryptionContext', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceEncryptionContext)) {
    request.sourceEncryptionContextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceEncryptionContext, 'SourceEncryptionContext', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.ciphertextBlob)) {
    query['CiphertextBlob'] = request.ciphertextBlob;
  }
  if (!Util.isUnset(request.destinationEncryptionContextShrink)) {
    query['DestinationEncryptionContext'] = request.destinationEncryptionContextShrink;
  }
  if (!Util.isUnset(request.destinationKeyId)) {
    query['DestinationKeyId'] = request.destinationKeyId;
  }
  if (!Util.isUnset(request.sourceEncryptionAlgorithm)) {
    query['SourceEncryptionAlgorithm'] = request.sourceEncryptionAlgorithm;
  }
  if (!Util.isUnset(request.sourceEncryptionContextShrink)) {
    query['SourceEncryptionContext'] = request.sourceEncryptionContextShrink;
  }
  if (!Util.isUnset(request.sourceKeyId)) {
    query['SourceKeyId'] = request.sourceKeyId;
  }
  if (!Util.isUnset(request.sourceKeyVersionId)) {
    query['SourceKeyVersionId'] = request.sourceKeyVersionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReEncrypt',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this operation in the following scenarios:
  * *   After the CMK that was used to encrypt your data is rotated, you can call this operation to use the latest CMK version to re-encrypt the data. For more information about automatic key rotation, see [Configure automatic key rotation](~~134270~~).
  * *   The CMK that was used to encrypt your data remains unchanged, but EncryptionContext is changed. In this scenario, you can call this operation to re-encrypt the data.
  * *   You can call this operation to use a CMK in KMS to re-encrypt data or a data key that was previously encrypted by a different CMK.
  * To use the ReEncrypt operation, you must have two permissions:
  * *   kms:ReEncryptFrom on the source CMK
  * *   kms:ReEncryptTo on the destination CMK
  * *   For simplicity, you can specify kms:ReEncrypt\\* to allow both of the preceding permissions.
  *
  * @param request ReEncryptRequest
  * @return ReEncryptResponse
 */
async function reEncrypt(request: ReEncryptRequest): ReEncryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return reEncryptWithOptions(request, runtime);
}

model RestoreSecretRequest {
  secretName?: string(name='SecretName', description='The name of the secret you want to restore.', example='secret001'),
}

model RestoreSecretResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='e4885adf-548f-4ca5-8075-f540bbd3a55f'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='secret001'),
}

model RestoreSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestoreSecretResponseBody(name='body'),
}

/**
  * You can only use this operation to restore a deleted secret that is within its recovery period. If you set **ForceDeleteWithoutRecovery** to **true** when you delete the secret, you cannot restore it.
  *
  * @param request RestoreSecretRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return RestoreSecretResponse
 */
async function restoreSecretWithOptions(request: RestoreSecretRequest, runtime: Util.RuntimeOptions): RestoreSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestoreSecret',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can only use this operation to restore a deleted secret that is within its recovery period. If you set **ForceDeleteWithoutRecovery** to **true** when you delete the secret, you cannot restore it.
  *
  * @param request RestoreSecretRequest
  * @return RestoreSecretResponse
 */
async function restoreSecret(request: RestoreSecretRequest): RestoreSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return restoreSecretWithOptions(request, runtime);
}

model RotateSecretRequest {
  secretName?: string(name='SecretName', description='The name of the secret.', example='RdsSecret/Mysql5.4/MyCred'),
  versionId?: string(name='VersionId', description='The version number of the secret after the secret is rotated.

>  The version number is used to ensure the idempotence of the request. Secrets Manager uses this version number to prevent your application from creating the same version of the secret when the application retries a request. If a version number already exists, Secrets Manager ignores the request for rotation and returns a success message.', example='000000123'),
}

model RotateSecretResponseBody = {
  arn?: string(name='Arn', description='The Alibaba Cloud Resource Name (ARN) of the secret.', example='acs:kms:cn-hangzhou:154035569884****:secret/RdsSecret/Mysql5.4/MyCred'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='10257c86-269d-43aa-aaf3-90ed4144bb7c'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='RdsSecret/Mysql5.4/MyCred'),
  versionId?: string(name='VersionId', description='The version number of the secret after the secret is rotated.', example='000000123'),
}

model RotateSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RotateSecretResponseBody(name='body'),
}

/**
  * Limits:
  * • A secret of each Alibaba Cloud account can be rotated for a maximum of 50 times per hour.
  * • The RotateSecret operation is unavailable for standard secrets.
  * In this example, the `RdsSecret/Mysql5.4/MyCred` secret is manually rotated, and the version number of the secret is set to `000000123` after the secret is rotated.
  *
  * @param request RotateSecretRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return RotateSecretResponse
 */
async function rotateSecretWithOptions(request: RotateSecretRequest, runtime: Util.RuntimeOptions): RotateSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RotateSecret',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Limits:
  * • A secret of each Alibaba Cloud account can be rotated for a maximum of 50 times per hour.
  * • The RotateSecret operation is unavailable for standard secrets.
  * In this example, the `RdsSecret/Mysql5.4/MyCred` secret is manually rotated, and the version number of the secret is set to `000000123` after the secret is rotated.
  *
  * @param request RotateSecretRequest
  * @return RotateSecretResponse
 */
async function rotateSecret(request: RotateSecretRequest): RotateSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return rotateSecretWithOptions(request, runtime);
}

model ScheduleKeyDeletionRequest {
  keyId?: string(name='KeyId', description='The ID of the customer master key (CMK). The ID must be globally unique.', example='7906979c-8e06-46a2-be2d-68e3ccbc****'),
  pendingWindowInDays?: int32(name='PendingWindowInDays', description='The scheduled period after which the CMK is deleted. During this period, the CMK is in the PendingDeletion state. After this period ends, you cannot cancel the key deletion task.

Valid values: 7 to 366.

Unit: days.', example='7'),
}

model ScheduleKeyDeletionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3da5b8cc-8107-40ac-a170-793cd181d7b7'),
}

model ScheduleKeyDeletionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ScheduleKeyDeletionResponseBody(name='body'),
}

/**
  * During the scheduled period, the CMK is in the PendingDeletion state and cannot be used to encrypt data, decrypt data, or generate data keys.
  * After a CMK is deleted, it cannot be recovered. Data that is encrypted and data keys that are generated by using the CMK cannot be decrypted. To prevent accidental deletion of CMKs, Key Management Service (KMS) allows you to only schedule key deletion tasks. You cannot directly delete CMKs. If you want to delete a CMK, call the [DisableKey](~~35151~~) operation to disable the CMK.
  * When you call this operation, you must specify a scheduled period between 7 days to 366 days. The scheduled period starts from the time when you submit the request. You can call the [CancelKeyDeletion](~~44197~~) operation to cancel the key deletion task before the scheduled period ends.
  *
  * @param request ScheduleKeyDeletionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ScheduleKeyDeletionResponse
 */
async function scheduleKeyDeletionWithOptions(request: ScheduleKeyDeletionRequest, runtime: Util.RuntimeOptions): ScheduleKeyDeletionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.pendingWindowInDays)) {
    query['PendingWindowInDays'] = request.pendingWindowInDays;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ScheduleKeyDeletion',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * During the scheduled period, the CMK is in the PendingDeletion state and cannot be used to encrypt data, decrypt data, or generate data keys.
  * After a CMK is deleted, it cannot be recovered. Data that is encrypted and data keys that are generated by using the CMK cannot be decrypted. To prevent accidental deletion of CMKs, Key Management Service (KMS) allows you to only schedule key deletion tasks. You cannot directly delete CMKs. If you want to delete a CMK, call the [DisableKey](~~35151~~) operation to disable the CMK.
  * When you call this operation, you must specify a scheduled period between 7 days to 366 days. The scheduled period starts from the time when you submit the request. You can call the [CancelKeyDeletion](~~44197~~) operation to cancel the key deletion task before the scheduled period ends.
  *
  * @param request ScheduleKeyDeletionRequest
  * @return ScheduleKeyDeletionResponse
 */
async function scheduleKeyDeletion(request: ScheduleKeyDeletionRequest): ScheduleKeyDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  return scheduleKeyDeletionWithOptions(request, runtime);
}

model SetDeletionProtectionRequest {
  deletionProtectionDescription?: string(name='DeletionProtectionDescription', description='The description of deletion protection.

>  This parameter takes effect only when you set the EnableDeletionProtection parameter to true.', example='This key is being used by XXX service. You are protected from deletion.'),
  enableDeletionProtection?: boolean(name='EnableDeletionProtection', description='Specifies whether to enable deletion protection. Valid values:

*   true: enables deletion protection.
*   false: disables deletion protection.', example='true'),
  protectedResourceArn?: string(name='ProtectedResourceArn', description='The ARN of the CMK for which you want to set deletion protection.

You can call the [DescribeKey](~~28952~~) operation to query the CMK ARN.', example='acs:kms:cn-hangzhou:123213123****:key/0225f411-b21d-46d1-be5b-93931c82****'),
}

model SetDeletionProtectionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3455b9b4-95c1-419d-b310-db6a53b09a39'),
}

model SetDeletionProtectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDeletionProtectionResponseBody(name='body'),
}

/**
  * *   After you enable deletion protection for a CMK, you cannot delete the CMK. If you want to delete the CMK, you must first disable deletion protection for the CMK.
  * *   Before you can call the SetDeletionProtection operation, make sure that the required CMK is not in the Pending Deletion state. You can call the [DescribeKey](~~28952~~) operation to query the CMK status, which is specified by the KeyState parameter.
  * You can enable deletion protection for the CMK whose Alibaba Cloud Resource Name (ARN) is `acs:kms:cn-hangzhou:123213123****:key/0225f411-b21d-46d1-be5b-93931c82****` by using parameter settings provided in this topic. The CMK ARN is specified by the ProtectedResourceArn parameter.
  *
  * @param request SetDeletionProtectionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SetDeletionProtectionResponse
 */
async function setDeletionProtectionWithOptions(request: SetDeletionProtectionRequest, runtime: Util.RuntimeOptions): SetDeletionProtectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deletionProtectionDescription)) {
    query['DeletionProtectionDescription'] = request.deletionProtectionDescription;
  }
  if (!Util.isUnset(request.enableDeletionProtection)) {
    query['EnableDeletionProtection'] = request.enableDeletionProtection;
  }
  if (!Util.isUnset(request.protectedResourceArn)) {
    query['ProtectedResourceArn'] = request.protectedResourceArn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDeletionProtection',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   After you enable deletion protection for a CMK, you cannot delete the CMK. If you want to delete the CMK, you must first disable deletion protection for the CMK.
  * *   Before you can call the SetDeletionProtection operation, make sure that the required CMK is not in the Pending Deletion state. You can call the [DescribeKey](~~28952~~) operation to query the CMK status, which is specified by the KeyState parameter.
  * You can enable deletion protection for the CMK whose Alibaba Cloud Resource Name (ARN) is `acs:kms:cn-hangzhou:123213123****:key/0225f411-b21d-46d1-be5b-93931c82****` by using parameter settings provided in this topic. The CMK ARN is specified by the ProtectedResourceArn parameter.
  *
  * @param request SetDeletionProtectionRequest
  * @return SetDeletionProtectionResponse
 */
async function setDeletionProtection(request: SetDeletionProtectionRequest): SetDeletionProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDeletionProtectionWithOptions(request, runtime);
}

model TagResourceRequest {
  certificateId?: string(name='CertificateId', description='The ID of the certificate.

>  You can configure only one of the KeyId, SecretName, and CertificateId parameters.', example='770dbe42-e146-43d1-a55a-1355db86****'),
  keyId?: string(name='KeyId', description='The ID of the customer master key (CMK). The ID must be globally unique.

>  You can configure only one of the KeyId, SecretName, and CertificateId parameters.', example='08c33a6f-4e0a-4a1b-a3fa-7ddf****'),
  secretName?: string(name='SecretName', description='The name of the secret.

>  You can configure only one of the KeyId, SecretName, and CertificateId parameters.', example='MyDbC****'),
  tags?: string(name='Tags', description='One or more tags that you want to add. The value is in the array format.

Tag attributes:

*   TagKey: the tag key.
*   TagValue: the tag value.', example='[{"TagKey":"S1key1","TagValue":"S1val1"},{"TagKey":"S1key2","TagValue":"S2val2"}]'),
}

model TagResourceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4162a6af-bc99-40b3-a552-89dcc8aaf7c8'),
}

model TagResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourceResponseBody(name='body'),
}

/**
  * You can add up to 10 tags to a CMK, secret, or certificate.
  * In this example, the tags `[{"TagKey":"S1key1","TagValue":"S1val1"},{"TagKey":"S1key2","TagValue":"S2val2"}]` are added to the CMK whose ID is `08c33a6f-4e0a-4a1b-a3fa-7ddf****`.
  *
  * @param request TagResourceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return TagResourceResponse
 */
async function tagResourceWithOptions(request: TagResourceRequest, runtime: Util.RuntimeOptions): TagResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResource',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can add up to 10 tags to a CMK, secret, or certificate.
  * In this example, the tags `[{"TagKey":"S1key1","TagValue":"S1val1"},{"TagKey":"S1key2","TagValue":"S2val2"}]` are added to the CMK whose ID is `08c33a6f-4e0a-4a1b-a3fa-7ddf****`.
  *
  * @param request TagResourceRequest
  * @return TagResourceResponse
 */
async function tagResource(request: TagResourceRequest): TagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourceWithOptions(request, runtime);
}

model TagResourcesRequest {
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourceRequest {
  certificateId?: string(name='CertificateId', example='770dbe42-e146-43d1-a55a-1355db86****'),
  keyId?: string(name='KeyId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='08c33a6f-4e0a-4a1b-a3fa-7ddf****'),
  secretName?: string(name='SecretName', example='MyDbC****'),
  tagKeys?: string(name='TagKeys', example='["tagkey1","tagkey2"]'),
}

model UntagResourceResponseBody = {
  requestId?: string(name='RequestId', example='4162a6af-bc99-40b3-a552-89dcc8aaf7c8'),
}

model UntagResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourceResponseBody(name='body'),
}

/**
  * One or more tag keys. Separate multiple tag keys with commas (,).
  * You need to specify only the tag keys, not the tag values.
  * Each tag key must be 1 to 128 bytes in length.
  *
  * @param request UntagResourceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UntagResourceResponse
 */
async function untagResourceWithOptions(request: UntagResourceRequest, runtime: Util.RuntimeOptions): UntagResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.tagKeys)) {
    query['TagKeys'] = request.tagKeys;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResource',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * One or more tag keys. Separate multiple tag keys with commas (,).
  * You need to specify only the tag keys, not the tag values.
  * Each tag key must be 1 to 128 bytes in length.
  *
  * @param request UntagResourceRequest
  * @return UntagResourceResponse
 */
async function untagResource(request: UntagResourceRequest): UntagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourceWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateAliasRequest {
  aliasName?: string(name='AliasName', description='The alias that you want to bind.

The value must be 1 to 255 characters in length and must include the alias/ prefix.', example='alias/example'),
  keyId?: string(name='KeyId', description='The ID of the CMK. The ID must be globally unique.', example='1234abcd-12ab-34cd-56ef-12345678****'),
}

model UpdateAliasResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='1d2baaf3-d357-46c2-832e-13560c2bd9cd'),
}

model UpdateAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAliasResponseBody(name='body'),
}

async function updateAliasWithOptions(request: UpdateAliasRequest, runtime: Util.RuntimeOptions): UpdateAliasResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlias',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAlias(request: UpdateAliasRequest): UpdateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAliasWithOptions(request, runtime);
}

model UpdateCertificateStatusRequest {
  certificateId?: string(name='CertificateId', description='The ID of the certificate. The ID must be globally unique in Certificates Manager.', example='9a28de48-8d8b-484d-a766-dec4****'),
  status?: string(name='Status', description='The status of the certificate. Valid values:

*   INACTIVE: The certificate is disabled.

*   ACTIVE: The certificate is enabled.

*   REVOKED: The certificate is revoked.

> If the certificate is in the REVOKED state, you can use the certificate only to verify a signature, but not to generate a signature.', example='INACTIVE'),
}

model UpdateCertificateStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='e3f57fe0-9ded-40b0-9caf-a3815f2148c1'),
}

model UpdateCertificateStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCertificateStatusResponseBody(name='body'),
}

/**
  * In this example, the status of the certificate whose ID is `9a28de48-8d8b-484d-a766-dec4****` is updated to INACTIVE.
  *
  * @param request UpdateCertificateStatusRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateCertificateStatusResponse
 */
async function updateCertificateStatusWithOptions(request: UpdateCertificateStatusRequest, runtime: Util.RuntimeOptions): UpdateCertificateStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCertificateStatus',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * In this example, the status of the certificate whose ID is `9a28de48-8d8b-484d-a766-dec4****` is updated to INACTIVE.
  *
  * @param request UpdateCertificateStatusRequest
  * @return UpdateCertificateStatusResponse
 */
async function updateCertificateStatus(request: UpdateCertificateStatusRequest): UpdateCertificateStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCertificateStatusWithOptions(request, runtime);
}

model UpdateKeyDescriptionRequest {
  description?: string(name='Description', description='The description of the CMK. This description includes the purpose of the CMK, such as the types of data that you want to protect and applications that can use the CMK.', example='key description example'),
  keyId?: string(name='KeyId', description='The ID of the CMK. The ID must be globally unique.', example='1234abcd-12ab-34cd-56ef-12345678****'),
}

model UpdateKeyDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='3455b9b4-95c1-419d-b310-db6a53b09a39'),
}

model UpdateKeyDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateKeyDescriptionResponseBody(name='body'),
}

/**
  * This operation replaces the description of a customer master key (CMK) with the description that you specify. The original description of the CMK is specified by the Description parameter when you call the [DescribeKey](~~28952~~) operation. You can call this operation to add, modify, or delete the description of a CMK.
  *
  * @param request UpdateKeyDescriptionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateKeyDescriptionResponse
 */
async function updateKeyDescriptionWithOptions(request: UpdateKeyDescriptionRequest, runtime: Util.RuntimeOptions): UpdateKeyDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateKeyDescription',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation replaces the description of a customer master key (CMK) with the description that you specify. The original description of the CMK is specified by the Description parameter when you call the [DescribeKey](~~28952~~) operation. You can call this operation to add, modify, or delete the description of a CMK.
  *
  * @param request UpdateKeyDescriptionRequest
  * @return UpdateKeyDescriptionResponse
 */
async function updateKeyDescription(request: UpdateKeyDescriptionRequest): UpdateKeyDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateKeyDescriptionWithOptions(request, runtime);
}

model UpdateRotationPolicyRequest {
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation', description='Specifies whether to enable automatic key rotation. Valid values:

*   true: enables automatic key rotation.
*   false: disables automatic key rotation.', example='true'),
  keyId?: string(name='KeyId', description='The ID of the customer master key (CMK). The ID must be globally unique.', example='1234abcd-12ab-34cd-56ef-12345678****'),
  rotationInterval?: string(name='RotationInterval', description='The period of automatic key rotation. Specify the value in the integer\\[unit] format. The following units are supported: d (day), h (hour), m (minute), and s (second). For example, you can use either 7d or 604800s to specify a seven-day period. The period can range from 7 days to 730 days.

>  If you set the EnableAutomaticRotation parameter to true, you must also specify this parameter. If you set the EnableAutomaticRotation parameter to false, you can leave this parameter unspecified.', example='30d'),
}

model UpdateRotationPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='efb1cbbd-a093-4278-bc03-639dd4fcc207'),
}

model UpdateRotationPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRotationPolicyResponseBody(name='body'),
}

/**
  * When automatic key rotation is enabled, KMS automatically creates a key version after the preset rotation period arrives. In addition, KMS sets the new key version as the primary key version.
  * An automatic key rotation policy cannot be configured for the following keys:
  * *   Asymmetric key
  * *   Service-managed key
  * *   Bring your own key (BYOK) that is imported into KMS
  * *   Key that is not in the **Enabled** state
  * In this example, automatic key rotation is enabled for a CMK whose ID is `1234abcd-12ab-34cd-56ef-12345678****`. The automatic rotation period is 30 days.
  *
  * @param request UpdateRotationPolicyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateRotationPolicyResponse
 */
async function updateRotationPolicyWithOptions(request: UpdateRotationPolicyRequest, runtime: Util.RuntimeOptions): UpdateRotationPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.enableAutomaticRotation)) {
    query['EnableAutomaticRotation'] = request.enableAutomaticRotation;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.rotationInterval)) {
    query['RotationInterval'] = request.rotationInterval;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRotationPolicy',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * When automatic key rotation is enabled, KMS automatically creates a key version after the preset rotation period arrives. In addition, KMS sets the new key version as the primary key version.
  * An automatic key rotation policy cannot be configured for the following keys:
  * *   Asymmetric key
  * *   Service-managed key
  * *   Bring your own key (BYOK) that is imported into KMS
  * *   Key that is not in the **Enabled** state
  * In this example, automatic key rotation is enabled for a CMK whose ID is `1234abcd-12ab-34cd-56ef-12345678****`. The automatic rotation period is 30 days.
  *
  * @param request UpdateRotationPolicyRequest
  * @return UpdateRotationPolicyResponse
 */
async function updateRotationPolicy(request: UpdateRotationPolicyRequest): UpdateRotationPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRotationPolicyWithOptions(request, runtime);
}

model UpdateSecretRequest {
  extendedConfig?: {
    customData?: map[string]any(name='CustomData', description='The custom data in the extended configuration of the secret.

> *   If this parameter is specified, the existing extended configuration of the secret is updated.
> *   This parameter is unavailable for generic secrets.', example='{"DBName":"app1","Port":"3306"}'),
  }(name='ExtendedConfig'),
  description?: string(name='Description', description='The description of the secret.', example='datainfo'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='secret001'),
}

model UpdateSecretShrinkRequest {
  extendedConfig?: {
    customData?: string(name='CustomData', description='The custom data in the extended configuration of the secret.

> *   If this parameter is specified, the existing extended configuration of the secret is updated.
> *   This parameter is unavailable for generic secrets.', example='{"DBName":"app1","Port":"3306"}'),
  }(name='ExtendedConfig'),
  description?: string(name='Description', description='The description of the secret.', example='datainfo'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='secret001'),
}

model UpdateSecretResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='5b75d8b1-5b6a-4ec0-8e0c-c08befdfad47'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='secret001'),
}

model UpdateSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSecretResponseBody(name='body'),
}

/**
  * In this example, the metadata of the `secret001` secret is updated. The `Description` parameter is set to `datainfo`.
  *
  * @param request UpdateSecretRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateSecretResponse
 */
async function updateSecretWithOptions(request: UpdateSecretRequest, runtime: Util.RuntimeOptions): UpdateSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.extendedConfig)) {
    query['ExtendedConfig'] = request.extendedConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSecret',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * In this example, the metadata of the `secret001` secret is updated. The `Description` parameter is set to `datainfo`.
  *
  * @param request UpdateSecretRequest
  * @return UpdateSecretResponse
 */
async function updateSecret(request: UpdateSecretRequest): UpdateSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSecretWithOptions(request, runtime);
}

model UpdateSecretRotationPolicyRequest {
  enableAutomaticRotation?: boolean(name='EnableAutomaticRotation', description='Specifies whether to enable automatic rotation. Valid values:

*   true: enables automatic rotation.
*   false: does not enable automatic rotation. This is the default value.', example='true'),
  rotationInterval?: string(name='RotationInterval', description='The interval for automatic rotation. Valid values: 6 hours to 8,760 hours (365 days).

The value is in the `integer[unit]` format.````

The unit can be d (day), h (hour), m (minute), or s (second). For example, both 7d and 604800s indicate a seven-day interval.

>  This parameter is required if you set the EnableAutomaticRotation parameter to true. This parameter is ignored if you set the EnableAutomaticRotation parameter to false or does not specify the EnableAutomaticRotation parameter.', example='30d'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='RdsSecret/Mysql5.4/MyCred'),
}

model UpdateSecretRotationPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='2c124f6f-4210-499f-b88a-69f54004d2d8'),
  secretName?: string(name='SecretName', description='The name of the secret.', example='RdsSecret/Mysql5.4/MyCred'),
}

model UpdateSecretRotationPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSecretRotationPolicyResponseBody(name='body'),
}

/**
  * After automatic rotation is enabled, Secrets Manager schedules the first automatic rotation by adding the preset rotation interval to the timestamp of the last rotation.
  * Limits: The UpdateSecretRotationPolicy operation cannot be used to update the rotation policy of generic secrets.
  * In this example, the rotation policy of the `RdsSecret/Mysql5.4/MyCred` secret is updated. The following settings are modified:
  * *   The `EnableAutomaticRotation` parameter is set to `true`, which indicates that automatic rotation is enabled.
  * *   The `RotationInterval` parameter is set to `30d`, which indicates that the interval for automatic rotation is 30 days.
  *
  * @param request UpdateSecretRotationPolicyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateSecretRotationPolicyResponse
 */
async function updateSecretRotationPolicyWithOptions(request: UpdateSecretRotationPolicyRequest, runtime: Util.RuntimeOptions): UpdateSecretRotationPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.enableAutomaticRotation)) {
    query['EnableAutomaticRotation'] = request.enableAutomaticRotation;
  }
  if (!Util.isUnset(request.rotationInterval)) {
    query['RotationInterval'] = request.rotationInterval;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSecretRotationPolicy',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * After automatic rotation is enabled, Secrets Manager schedules the first automatic rotation by adding the preset rotation interval to the timestamp of the last rotation.
  * Limits: The UpdateSecretRotationPolicy operation cannot be used to update the rotation policy of generic secrets.
  * In this example, the rotation policy of the `RdsSecret/Mysql5.4/MyCred` secret is updated. The following settings are modified:
  * *   The `EnableAutomaticRotation` parameter is set to `true`, which indicates that automatic rotation is enabled.
  * *   The `RotationInterval` parameter is set to `30d`, which indicates that the interval for automatic rotation is 30 days.
  *
  * @param request UpdateSecretRotationPolicyRequest
  * @return UpdateSecretRotationPolicyResponse
 */
async function updateSecretRotationPolicy(request: UpdateSecretRotationPolicyRequest): UpdateSecretRotationPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSecretRotationPolicyWithOptions(request, runtime);
}

model UpdateSecretVersionStageRequest {
  moveToVersion?: string(name='MoveToVersion', description='The version from which you want to remove the specified stage label.

>  You must specify at least one of the RemoveFromVersion and MoveToVersion parameters.', example='002'),
  removeFromVersion?: string(name='RemoveFromVersion', description='The specified stage label. Valid values:

*   ACSCurrent
*   ACSPrevious
*   Custom stage label', example='001'),
  secretName?: string(name='SecretName', description='The operation that you want to perform. Set the value to **UpdateSecretVersionStage**.', example='secret001'),
  versionStage?: string(name='VersionStage', description='The name of the secret.', example='ACSCurrent'),
}

model UpdateSecretVersionStageResponseBody = {
  requestId?: string(name='RequestId', description='The name of the secret.', example='8cad259f-4d77-40ec-bbd7-b9c47a423bb9'),
  secretName?: string(name='SecretName', description='The version to which you want to apply the specified stage label.

> * You must specify at least one of the RemoveFromVersion and MoveToVersion parameters.
> * If the VersionStage parameter is set to ACSCurrent or ACSPrevious, this parameter is required.', example='secret001'),
}

model UpdateSecretVersionStageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSecretVersionStageResponseBody(name='body'),
}

/**
  * Updates the stage label that marks a secret version.
  *
  * @param request UpdateSecretVersionStageRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateSecretVersionStageResponse
 */
async function updateSecretVersionStageWithOptions(request: UpdateSecretVersionStageRequest, runtime: Util.RuntimeOptions): UpdateSecretVersionStageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.moveToVersion)) {
    query['MoveToVersion'] = request.moveToVersion;
  }
  if (!Util.isUnset(request.removeFromVersion)) {
    query['RemoveFromVersion'] = request.removeFromVersion;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.versionStage)) {
    query['VersionStage'] = request.versionStage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSecretVersionStage',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Updates the stage label that marks a secret version.
  *
  * @param request UpdateSecretVersionStageRequest
  * @return UpdateSecretVersionStageResponse
 */
async function updateSecretVersionStage(request: UpdateSecretVersionStageRequest): UpdateSecretVersionStageResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSecretVersionStageWithOptions(request, runtime);
}

model UploadCertificateRequest {
  certificate?: string(name='Certificate', description='The certificate issued by the CA, which is in the Privacy Enhanced Mail (PEM) format.', example='-----BEGIN CERTIFICATE-----  (X.509 Certificate PEM Content)  -----END CERTIFICATE-----'),
  certificateChain?: string(name='CertificateChain', description='The certificate chain issued by the CA, which is in the PEM format.', example='-----BEGIN CERTIFICATE-----  (Sub CA Certificate PEM Content)  -----END CERTIFICATE-----  -----BEGIN CERTIFICATE-----  (Sub CA Certificate PEM Content)  -----END CERTIFICATE-----  -----BEGIN CERTIFICATE-----  (Root CA Certificate PEM Content)  -----END CERTIFICATE-----'),
  certificateId?: string(name='CertificateId', description='The ID of the certificate. The ID must be globally unique in Certificates Manager.', example='12345678-1234-1234-1234-12345678****'),
}

model UploadCertificateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='15a735a1-8fe6-45cc-a64c-3c4ff839334e'),
}

model UploadCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadCertificateResponseBody(name='body'),
}

/**
  * In this example, a certificate issued by a CA is imported into Certificates Manager. The ID of the certificate in Certificates Manager is `12345678-1234-1234-1234-12345678****`.
  *
  * @param request UploadCertificateRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UploadCertificateResponse
 */
async function uploadCertificateWithOptions(request: UploadCertificateRequest, runtime: Util.RuntimeOptions): UploadCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificate)) {
    query['Certificate'] = request.certificate;
  }
  if (!Util.isUnset(request.certificateChain)) {
    query['CertificateChain'] = request.certificateChain;
  }
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadCertificate',
    version = '2016-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * In this example, a certificate issued by a CA is imported into Certificates Manager. The ID of the certificate in Certificates Manager is `12345678-1234-1234-1234-12345678****`.
  *
  * @param request UploadCertificateRequest
  * @return UploadCertificateResponse
 */
async function uploadCertificate(request: UploadCertificateRequest): UploadCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadCertificateWithOptions(request, runtime);
}

