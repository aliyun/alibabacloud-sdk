/**
 *
 */
import OpenApi;
import OpenApi.OpenApiUtil;

extends OpenApi;


init(config: OpenApiUtil.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('eflo-controller', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!$isNull(endpoint)) {
    return endpoint;
  }
  
  if (!$isNull(endpointMap) && !$isNull(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ApproveOperationRequest {
  nodeId?: string(name='NodeId', description='The node ID.', example='e01-cn-zvp2tgykr08'),
  operationType?: string(name='OperationType', description='The O\\\\&M operation type

Valid value:

*   RepairMachine', example='RepairMachine'),
}

model ApproveOperationResponseBody = {
  errorMessage?: string(name='ErrorMessage', description='The error message.', example='Resource not found'),
  requestId?: string(name='RequestId', description='The request ID.', example='8F065DDD-6996-5973-9691-9EC57BD0072E'),
}

model ApproveOperationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ApproveOperationResponseBody(name='body'),
}

/**
 * @summary Approves an O\\&M operation.
 *
 * @param request ApproveOperationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApproveOperationResponse
 */
@context("approveOperationWithContext")
async function approveOperationWithOptions(request: ApproveOperationRequest, runtime: $RuntimeOptions): ApproveOperationResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!$isNull(request.operationType)) {
    body['OperationType'] = request.operationType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ApproveOperation',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Approves an O\\&M operation.
 *
 * @param request ApproveOperationRequest
 * @return ApproveOperationResponse
 */
async function approveOperation(request: ApproveOperationRequest): ApproveOperationResponse {
  var runtime = new $RuntimeOptions{};
  return approveOperationWithOptions(request, runtime);
}

model ChangeResourceGroupRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group into which you want to change.

This parameter is required.', example='rg-aekzyqdwnfabx6q'),
  resourceId?: string(name='ResourceId', description='The resource ID.

This parameter is required.', example='i118099391667548921125'),
  resourceRegionId?: string(name='ResourceRegionId', description='The region ID.

This parameter is required.', example='cn-wulanchabu'),
  resourceType?: string(name='ResourceType', description='The resource type.', example='Node'),
}

model ChangeResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='8F065DDD-6996-5973-9691-9EC57BD0072E'),
}

model ChangeResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeResourceGroupResponseBody(name='body'),
}

/**
 * @summary Moves a resource from one resource group to another.
 *
 * @param request ChangeResourceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeResourceGroupResponse
 */
@context("changeResourceGroupWithContext")
async function changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, runtime: $RuntimeOptions): ChangeResourceGroupResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceRegionId)) {
    query['ResourceRegionId'] = request.resourceRegionId;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ChangeResourceGroup',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Moves a resource from one resource group to another.
 *
 * @param request ChangeResourceGroupRequest
 * @return ChangeResourceGroupResponse
 */
async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new $RuntimeOptions{};
  return changeResourceGroupWithOptions(request, runtime);
}

model CloseSessionRequest {
  sessionId?: string(name='SessionId', description='The session ID.', example='i207023871669364793713'),
  sessionToken?: string(name='SessionToken', description='Session token.', example='03f53c719015a9ad4f4f55d66cac2dac161b18e8065ca75a3220b89de389c980'),
}

model CloseSessionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='07AA3A1F-321E-50D8-B834-88C411331C94'),
  sessionId?: string(name='SessionId', description='The session ID.', example='i206495551737511455528'),
  state?: string(name='State', description='status of session', example='Inactive'),
}

model CloseSessionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloseSessionResponseBody(name='body'),
}

/**
 * @summary Disconnect Connection
 *
 * @param request CloseSessionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CloseSessionResponse
 */
@context("closeSessionWithContext")
async function closeSessionWithOptions(request: CloseSessionRequest, runtime: $RuntimeOptions): CloseSessionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.sessionId)) {
    body['SessionId'] = request.sessionId;
  }
  if (!$isNull(request.sessionToken)) {
    body['SessionToken'] = request.sessionToken;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CloseSession',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disconnect Connection
 *
 * @param request CloseSessionRequest
 * @return CloseSessionResponse
 */
async function closeSession(request: CloseSessionRequest): CloseSessionResponse {
  var runtime = new $RuntimeOptions{};
  return closeSessionWithOptions(request, runtime);
}

model CreateClusterRequest {
  clusterDescription?: string(name='ClusterDescription', description='Cluster description', example='Cluster description'),
  clusterName?: string(name='ClusterName', description='Cluster name', example='Standard_Cluster'),
  clusterType?: string(name='ClusterType', description='Cluster type', example='Lite'),
  components?: [ 
    {
      componentConfig?: {
        basicArgs?: any(name='BasicArgs', description='Basic component parameters', example='{
      "EndpointPublicAccess": false,
      "ContainerCidr": "10.4.0.0/24",
      "KeyPair": "test",
      "NodeCidrMask": "25",
      "ResourceGroupId": "rg-axsadm3sdzsdvdsndstdisd",
      "WorkerSystemDiskCategory": "da",
      "WorkerSystemDiskSize": 40,
      "DeletionProtection": false,
      "KubeProxy": "iptables",
      "Name": "da",
      "LoadBalancerSpec": "slb.s1.small",
      "Runtime": {
            "Version": "19.03.15",
            "Name": "docker"
      },
      "IsEnterpriseSecurityGroup": true,
      "Vpcid": "192.168.23.0/24",
      "NumOfNodes": 1,
      "VswitchIds": [
            "dad"
      ],
      "ServiceCidr": "10.0.0.0/16",
      "SnatEntry": false,
      "kubernetesVersion": "1.20.11-aliyunedge.1",
      "WorkerInstanceTypes": [
            "da"
      ]
}'),
        nodeUnits?: [ any ](name='NodeUnits', description='Node pool configuration, used to establish the correspondence between node groups and node pools. Required when ComponentType is "ACKEdge", otherwise it can be empty.'),
      }(name='ComponentConfig', description='Component configuration'),
      componentType?: string(name='ComponentType', description='Component type', example='ACKEdge'),
    }
  ](name='Components', description='Components (software instances)'),
  hpnZone?: string(name='HpnZone', description='Cluster number', example='A1'),
  ignoreFailedNodeTasks?: boolean(name='IgnoreFailedNodeTasks', description='Whether to allow skipping failed nodes, the default value is False', example='False'),
  networks?: {
    ipAllocationPolicy?: [ 
      {
        bondPolicy?: {
          bondDefaultSubnet?: string(name='BondDefaultSubnet', description='Default bond subnet for the cluster', example='172.168.0.0/24'),
          bonds?: [ 
            {
              name?: string(name='Name', description='Bond name', example='bond0'),
              subnet?: string(name='Subnet', description='IP source subnet for the cluster', example='172.16.0.0/24'),
            }
          ](name='Bonds', description='Bond information'),
        }(name='BondPolicy', description='Bond policy'),
        machineTypePolicy?: [ 
          {
            bonds?: [ 
              {
                name?: string(name='Name', description='Bond name', example='bond0'),
                subnet?: string(name='Subnet', description='IP source subnet for the cluster', example='192.168.1.0/24'),
              }
            ](name='Bonds', description='Bond information'),
            machineType?: string(name='MachineType', description='Machine type', example='efg1.nvga8n'),
          }
        ](name='MachineTypePolicy', description='Machine type allocation policy'),
        nodePolicy?: [ 
          {
            bonds?: [ 
              {
                name?: string(name='Name', description='Bond name', example='bond0'),
                subnet?: string(name='Subnet', description='IP source subnet for the cluster', example='10.0.0.0/24'),
              }
            ](name='Bonds', description='Bond information'),
            nodeId?: string(name='NodeId', description='Node ID', example='e01-cn-2r42vq62001'),
          }
        ](name='NodePolicy', description='Node allocation policy'),
      }
    ](name='IpAllocationPolicy', description='IP allocation policy'),
    newVpdInfo?: {
      cenId?: string(name='CenId', description='Cloud Enterprise Network ID', example='cen-1gb1eftc5qp2ao75fo'),
      cloudLinkCidr?: string(name='CloudLinkCidr', description='Cloud link CIDR', example='172.16.0.0/24'),
      cloudLinkId?: string(name='CloudLinkId', description='Cloud link ID', example='vcc-cn-c4dtycm5i08'),
      monitorVpcId?: string(name='MonitorVpcId', description='Virtual Private Cloud (VPC)', example='vpc-0jl2x45apm6odc2c10h25'),
      monitorVswitchId?: string(name='MonitorVswitchId', description='VPC switch', example='vsw-0jl2w3ffbghkss0x2foff'),
      vpdCidr?: string(name='VpdCidr', description='Cluster network segment', example='192.168.0.0/16'),
      vpdSubnets?: [ 
        {
          subnetCidr?: string(name='SubnetCidr', description='Subnet CIDR', example='10.0.1.8/24'),
          subnetType?: string(name='SubnetType', description='Subnet type', example='10.0.2.8/24'),
          zoneId?: string(name='ZoneId', description='Zone ID', example='cn-wulanchabu-b'),
        }
      ](name='VpdSubnets', description='Cluster subnets'),
    }(name='NewVpdInfo', description='Vpd configuration information'),
    securityGroupId?: string(name='SecurityGroupId', description='Security group ID', example='sg-bp1d3dvbh9by7j5rujax'),
    tailIpVersion?: string(name='TailIpVersion', description='IP version', example='IPv4'),
    vSwitchId?: string(name='VSwitchId', description='VSwitch ID', example='vsw-asjdfklj'),
    vSwitchZoneId?: string(name='VSwitchZoneId', description='VSwitch Zone ID', example='cn-shanghai-b'),
    vpcId?: string(name='VpcId', description='VPC ID', example='vpc-0jl36lqzmc06qogy0t5ll'),
    vpdInfo?: {
      vpdId?: string(name='VpdId', description='VPC ID', example='vpd-vfuz6ejv'),
      vpdSubnets?: [ string ](name='VpdSubnets', description='List of cluster subnet IDs'),
    }(name='VpdInfo', description='Reuse VPD information'),
  }(name='Networks', description='Network information'),
  nimizVSwitches?: [ string ](name='NimizVSwitches', description='Node VSwitches'),
  nodeGroups?: [ 
    {
      fileSystemMountEnabled?: boolean(name='FileSystemMountEnabled', description='Whether to support file system mounting', example='true'),
      hyperNodes?: [ 
        {
          dataDisk?: [ 
            {
              category?: string(name='Category'),
              deleteWithNode?: boolean(name='DeleteWithNode'),
              performanceLevel?: string(name='PerformanceLevel'),
              size?: int32(name='Size'),
            }
          ](name='DataDisk'),
          hostname?: string(name='Hostname'),
          hyperNodeId?: string(name='HyperNodeId'),
          loginPassword?: string(name='LoginPassword'),
          vSwitchId?: string(name='VSwitchId'),
          vpcId?: string(name='VpcId'),
        }
      ](name='HyperNodes'),
      imageId?: string(name='ImageId', description='System image ID', example='i190297201634099844192'),
      keyPairName?: string(name='KeyPairName', description='Key pair name.', example='test-keypair'),
      loginPassword?: string(name='LoginPassword', description='Login password', example='Password'),
      machineType?: string(name='MachineType', description='Machine type', example='efg1.nvga1'),
      nodeGroupDescription?: string(name='NodeGroupDescription', description='Node group description', example='Node group description'),
      nodeGroupName?: string(name='NodeGroupName', description='Node group name', example='emr-default'),
      nodes?: [ 
        {
          dataDisk?: [ 
            {
              category?: string(name='Category', description='Type', example='cloud_essd'),
              deleteWithNode?: boolean(name='DeleteWithNode', description='Whether the data disk is deleted with the node when it is unsubscribed', example='true'),
              performanceLevel?: string(name='PerformanceLevel', description='Data disk performance level', example='PL0'),
              size?: int32(name='Size', description='Disk size', example='10'),
            }
          ](name='DataDisk', description='Data disk specifications.'),
          hostname?: string(name='Hostname', description='Hostname', example='8d13b784-17a9-11ed-bc7b-acde48001122'),
          loginPassword?: string(name='LoginPassword', description='Login password', example='***'),
          nodeId?: string(name='NodeId', description='Node ID', example='e01poc-cn-i7m2wnivf0d'),
          vSwitchId?: string(name='VSwitchId', description='VSwitch ID', example='vsw-bp169pi5fj151rrms4sia'),
          vpcId?: string(name='VpcId', description='VPC ID', example='vpc-0jlasms92fdxqd3wlf8ny'),
        }
      ](name='Nodes', description='Node list'),
      systemDisk?: {
        category?: string(name='Category', description='Disk type. The value range is:

- cloud_essd: ESSD disk.', example='cloud_essd'),
        performanceLevel?: string(name='PerformanceLevel', description='When creating an ESSD disk as the system disk, set the performance level of the disk. The value range is:
- PL0: Maximum random read/write IOPS for a single disk is 10,000.
- PL1: Maximum random read/write IOPS for a single disk is 50,000.', example='PL1'),
        size?: int32(name='Size', description='Unit: GB.', example='9999'),
      }(name='SystemDisk', description='System disk information'),
      userData?: string(name='UserData', description='Instance custom data. It needs to be encoded in Base64, and the original data should not exceed 16 KB.', example='ZWNobyBoZWxsbyBlY3Mh'),
      virtualGpuEnabled?: boolean(name='VirtualGpuEnabled', description='Whether to enable gpu virtualization or not', example='false'),
      zoneId?: string(name='ZoneId', description='Zone ID', example='cn-hangzhou-i'),
    }
  ](name='NodeGroups', description='Node group list'),
  openEniJumboFrame?: boolean(name='OpenEniJumboFrame', description='Whether the network interface supports jumbo frames', example='false'),
  resourceGroupId?: string(name='ResourceGroupId', description='Resource group ID', example='rg-aek2xdkc6icwfha'),
  tag?: [ 
    {
      key?: string(name='Key', description='Key', example='env-name'),
      value?: string(name='Value', description='Value', example='dev'),
    }
  ](name='Tag', description='Resource tags'),
}

model CreateClusterShrinkRequest {
  clusterDescription?: string(name='ClusterDescription', description='Cluster description', example='Cluster description'),
  clusterName?: string(name='ClusterName', description='Cluster name', example='Standard_Cluster'),
  clusterType?: string(name='ClusterType', description='Cluster type', example='Lite'),
  componentsShrink?: string(name='Components', description='Components (software instances)'),
  hpnZone?: string(name='HpnZone', description='Cluster number', example='A1'),
  ignoreFailedNodeTasks?: boolean(name='IgnoreFailedNodeTasks', description='Whether to allow skipping failed nodes, the default value is False', example='False'),
  networksShrink?: string(name='Networks', description='Network information'),
  nimizVSwitchesShrink?: string(name='NimizVSwitches', description='Node VSwitches'),
  nodeGroupsShrink?: string(name='NodeGroups', description='Node group list'),
  openEniJumboFrame?: boolean(name='OpenEniJumboFrame', description='Whether the network interface supports jumbo frames', example='false'),
  resourceGroupId?: string(name='ResourceGroupId', description='Resource group ID', example='rg-aek2xdkc6icwfha'),
  tag?: [ 
    {
      key?: string(name='Key', description='Key', example='env-name'),
      value?: string(name='Value', description='Value', example='dev'),
    }
  ](name='Tag', description='Resource tags'),
}

model CreateClusterResponseBody = {
  clusterId?: string(name='ClusterId', description='Cluster ID', example='i116913051663373010974'),
  requestId?: string(name='RequestId', description='Request ID', example='3C683243-7915-57FB-9570-A2932C1C0F78'),
  taskId?: string(name='TaskId', description='Task ID', example='i159809891662373011015'),
}

model CreateClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateClusterResponseBody(name='body'),
}

/**
 * @summary Create a large-scale computing cluster
 *
 * @param tmpReq CreateClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateClusterResponse
 */
@context("createClusterWithContext")
async function createClusterWithOptions(tmpReq: CreateClusterRequest, runtime: $RuntimeOptions): CreateClusterResponse {
  tmpReq.validate();
  var request = new CreateClusterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.components)) {
    request.componentsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.components, 'Components', 'json');
  }
  if (!$isNull(tmpReq.networks)) {
    request.networksShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.networks, 'Networks', 'json');
  }
  if (!$isNull(tmpReq.nimizVSwitches)) {
    request.nimizVSwitchesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.nimizVSwitches, 'NimizVSwitches', 'json');
  }
  if (!$isNull(tmpReq.nodeGroups)) {
    request.nodeGroupsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.nodeGroups, 'NodeGroups', 'json');
  }
  var query = {};
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var body : map[string]any = {};
  if (!$isNull(request.clusterDescription)) {
    body['ClusterDescription'] = request.clusterDescription;
  }
  if (!$isNull(request.clusterName)) {
    body['ClusterName'] = request.clusterName;
  }
  if (!$isNull(request.clusterType)) {
    body['ClusterType'] = request.clusterType;
  }
  if (!$isNull(request.componentsShrink)) {
    body['Components'] = request.componentsShrink;
  }
  if (!$isNull(request.hpnZone)) {
    body['HpnZone'] = request.hpnZone;
  }
  if (!$isNull(request.ignoreFailedNodeTasks)) {
    body['IgnoreFailedNodeTasks'] = request.ignoreFailedNodeTasks;
  }
  if (!$isNull(request.networksShrink)) {
    body['Networks'] = request.networksShrink;
  }
  if (!$isNull(request.nimizVSwitchesShrink)) {
    body['NimizVSwitches'] = request.nimizVSwitchesShrink;
  }
  if (!$isNull(request.nodeGroupsShrink)) {
    body['NodeGroups'] = request.nodeGroupsShrink;
  }
  if (!$isNull(request.openEniJumboFrame)) {
    body['OpenEniJumboFrame'] = request.openEniJumboFrame;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateCluster',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create a large-scale computing cluster
 *
 * @param request CreateClusterRequest
 * @return CreateClusterResponse
 */
async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new $RuntimeOptions{};
  return createClusterWithOptions(request, runtime);
}

model CreateDiagnosticTaskRequest {
  aiJobLogInfo?: {
    aiJobLogs?: [ 
      {
        aiInstance?: string(name='AiInstance', description='The instance ID.', example='null'),
        logs?: [ 
          {
            datetime?: string(name='Datetime', description='The sending date in the yyyymmdd format.', example='2024-08-05T10:10:01'),
            logContent?: string(name='LogContent', description='The log content.', example='success'),
          }
        ](name='Logs', description='The logs.'),
        nodeId?: string(name='NodeId', description='The node ID.', example='e01-tw-p2p2al5u1hn'),
      }
    ](name='AiJobLogs', description='The task logs.'),
    endTime?: string(name='EndTime', description='The end time. The value is in the timestamp format. Unit: seconds.

>  This timestamp must indicate a point in time that is accurate to the minute.', example='2024-08-05T10:10:01'),
    startTime?: string(name='StartTime', description='The start time. The value is in the timestamp format. Unit: seconds.

>  This timestamp must indicate a point in time that is accurate to the minute.', example='2024-10-11T00:00:00Z'),
  }(name='AiJobLogInfo', description='The log information.'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='i118913031696573280136'),
  diagnosticType?: string(name='DiagnosticType', description='The diagnostics type.', example='CheckByAiJobLogs'),
  nodeIds?: [ string ](name='NodeIds', description='The IDs of the nodes.'),
}

model CreateDiagnosticTaskShrinkRequest {
  aiJobLogInfoShrink?: string(name='AiJobLogInfo', description='The log information.'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='i118913031696573280136'),
  diagnosticType?: string(name='DiagnosticType', description='The diagnostics type.', example='CheckByAiJobLogs'),
  nodeIdsShrink?: string(name='NodeIds', description='The IDs of the nodes.'),
}

model CreateDiagnosticTaskResponseBody = {
  diagnosticId?: string(name='DiagnosticId', description='The ID of the diagnostics task.', example='diag-i150553931717380274931'),
  requestId?: string(name='RequestId', description='The request ID.', example='A511C02A-0127-51AA-A9F9-966382C9A1B5'),
}

model CreateDiagnosticTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDiagnosticTaskResponseBody(name='body'),
}

/**
 * @summary Creates a diagnostics task.
 *
 * @param tmpReq CreateDiagnosticTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDiagnosticTaskResponse
 */
@context("createDiagnosticTaskWithContext")
async function createDiagnosticTaskWithOptions(tmpReq: CreateDiagnosticTaskRequest, runtime: $RuntimeOptions): CreateDiagnosticTaskResponse {
  tmpReq.validate();
  var request = new CreateDiagnosticTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.aiJobLogInfo)) {
    request.aiJobLogInfoShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.aiJobLogInfo, 'AiJobLogInfo', 'json');
  }
  if (!$isNull(tmpReq.nodeIds)) {
    request.nodeIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.nodeIds, 'NodeIds', 'simple');
  }
  var body : map[string]any = {};
  if (!$isNull(request.aiJobLogInfoShrink)) {
    body['AiJobLogInfo'] = request.aiJobLogInfoShrink;
  }
  if (!$isNull(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.diagnosticType)) {
    body['DiagnosticType'] = request.diagnosticType;
  }
  if (!$isNull(request.nodeIdsShrink)) {
    body['NodeIds'] = request.nodeIdsShrink;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateDiagnosticTask',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a diagnostics task.
 *
 * @param request CreateDiagnosticTaskRequest
 * @return CreateDiagnosticTaskResponse
 */
async function createDiagnosticTask(request: CreateDiagnosticTaskRequest): CreateDiagnosticTaskResponse {
  var runtime = new $RuntimeOptions{};
  return createDiagnosticTaskWithOptions(request, runtime);
}

model CreateNetTestTaskRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='i119982311660892626523'),
  clusterName?: string(name='ClusterName', description='The cluster name.', example='Eflo-YJ-Test-Cluster'),
  commTest?: {
    GPUNum?: long(name='GPUNum', description='The number of GPUs.', example='1'),
    hosts?: [ 
      {
        IP?: string(name='IP', description='The IP address.', example='169.253.253.15'),
        nodeId?: string(name='NodeId', description='The node ID.', example='e01-tw-bqisacl3z6l'),
        resourceId?: string(name='ResourceId', description='The resource ID.', example='i111670831721110797708'),
        serverName?: string(name='ServerName', description='The name of the service.', example='VBw'),
      }
    ](name='Hosts', description='The host IDs.'),
    model?: string(name='Model', description='The communication library model.', example='intention_v4'),
    type?: string(name='Type', description='The CommTest type, which can be ACCL or NCCL.', example='ACCL'),
  }(name='CommTest', description='Specify when NetTestType is CommTest.'),
  delayTest?: {
    hosts?: [ 
      {
        bond?: string(name='Bond', description='The bonding of network interface card.', example='bond1'),
        IP?: string(name='IP', description='The IP address of the node.', example='125.210.225.48'),
        nodeId?: string(name='NodeId', description='The node ID.', example='e01-cn-fou43an0a05'),
        resourceId?: string(name='ResourceId', description='The resource ID.', example='e01-cn-bcd3u1aee06'),
        serverName?: string(name='ServerName', description='The name of the service.', example='NQU'),
      }
    ](name='Hosts', description='The hosts of the test node.'),
  }(name='DelayTest', description='Specify when NetTestType is DelayTest.'),
  netTestType?: string(name='NetTestType', description='The type of the network test. Valid values: DelayTest, TrafficTest, and CommTest.', example='DelayTest'),
  networkMode?: string(name='NetworkMode', description='The network mode.', example='2'),
  port?: string(name='Port', description='The port number.', example='23604'),
  trafficTest?: {
    clients?: [ 
      {
        bond?: string(name='Bond', description='The bonding of network interface card.', example='bond1'),
        IP?: string(name='IP', description='The IP address of the node.', example='192.168.1.1'),
        nodeId?: string(name='NodeId', description='The node ID.', example='e01-tw-w5elqg7pw18'),
        resourceId?: string(name='ResourceId', description='The resource ID.', example='e01-cn-20s41p6cx01'),
        serverName?: string(name='ServerName', description='The name of the service.', example='xMv'),
      }
    ](name='Clients', description='The client IDs.'),
    duration?: long(name='Duration', description='The running duration of the pipeline job. Unit: seconds.', example='1'),
    GDR?: boolean(name='GDR', description='If the protocol is RDMA, enter True or False. If the protocol is TCP, leave this field empty.', example='False'),
    protocol?: string(name='Protocol', description='The network protocol, which can be RDMA or TCP.', example='TCP'),
    QP?: long(name='QP', description='If the protocol is TCP, enter the number of concurrent connections. If the protocol is RDMA, enter the configured QP value.', example='1'),
    servers?: [ 
      {
        bond?: string(name='Bond', description='The bonding of network interface card.', example='bond1'),
        IP?: string(name='IP', description='The IP address of the node.', example='47.121.110.190'),
        nodeId?: string(name='NodeId', description='The node ID.', example='e01-tw-bqisacl3z6l'),
        resourceId?: string(name='ResourceId', description='The resource ID.', example='e01-cn-wwo3etaqu0b'),
        serverName?: string(name='ServerName', description='The name of the service.', example='xMv'),
      }
    ](name='Servers', description='The services.'),
    trafficModel?: string(name='TrafficModel', description='The traffic model, which can be MTON or Fullmesh.', example='Fullmesh'),
  }(name='TrafficTest', description='If the TrafficModel is Fullmesh, leave this parameter empty.'),
}

model CreateNetTestTaskShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='i119982311660892626523'),
  clusterName?: string(name='ClusterName', description='The cluster name.', example='Eflo-YJ-Test-Cluster'),
  commTestShrink?: string(name='CommTest', description='Specify when NetTestType is CommTest.'),
  delayTestShrink?: string(name='DelayTest', description='Specify when NetTestType is DelayTest.'),
  netTestType?: string(name='NetTestType', description='The type of the network test. Valid values: DelayTest, TrafficTest, and CommTest.', example='DelayTest'),
  networkMode?: string(name='NetworkMode', description='The network mode.', example='2'),
  port?: string(name='Port', description='The port number.', example='23604'),
  trafficTestShrink?: string(name='TrafficTest', description='If the TrafficModel is Fullmesh, leave this parameter empty.'),
}

model CreateNetTestTaskResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE*****'),
  testId?: string(name='TestId', description='The ID of the test task. The unique identifier of a network test task.', example='dr-uf6i0tv2refv8wz*****'),
}

model CreateNetTestTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateNetTestTaskResponseBody(name='body'),
}

/**
 * @summary Creates a network test task.
 *
 * @description The API creates a session, returns the frontend endpoint, and starts a periodic task to track the session status.
 *
 * @param tmpReq CreateNetTestTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNetTestTaskResponse
 */
@context("createNetTestTaskWithContext")
async function createNetTestTaskWithOptions(tmpReq: CreateNetTestTaskRequest, runtime: $RuntimeOptions): CreateNetTestTaskResponse {
  tmpReq.validate();
  var request = new CreateNetTestTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.commTest)) {
    request.commTestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.commTest, 'CommTest', 'json');
  }
  if (!$isNull(tmpReq.delayTest)) {
    request.delayTestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.delayTest, 'DelayTest', 'json');
  }
  if (!$isNull(tmpReq.trafficTest)) {
    request.trafficTestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.trafficTest, 'TrafficTest', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.clusterName)) {
    body['ClusterName'] = request.clusterName;
  }
  if (!$isNull(request.commTestShrink)) {
    body['CommTest'] = request.commTestShrink;
  }
  if (!$isNull(request.delayTestShrink)) {
    body['DelayTest'] = request.delayTestShrink;
  }
  if (!$isNull(request.netTestType)) {
    body['NetTestType'] = request.netTestType;
  }
  if (!$isNull(request.networkMode)) {
    body['NetworkMode'] = request.networkMode;
  }
  if (!$isNull(request.port)) {
    body['Port'] = request.port;
  }
  if (!$isNull(request.trafficTestShrink)) {
    body['TrafficTest'] = request.trafficTestShrink;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateNetTestTask',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a network test task.
 *
 * @description The API creates a session, returns the frontend endpoint, and starts a periodic task to track the session status.
 *
 * @param request CreateNetTestTaskRequest
 * @return CreateNetTestTaskResponse
 */
async function createNetTestTask(request: CreateNetTestTaskRequest): CreateNetTestTaskResponse {
  var runtime = new $RuntimeOptions{};
  return createNetTestTaskWithOptions(request, runtime);
}

model CreateNodeGroupRequest {
  clusterId?: string(name='ClusterId', description='Cluster ID

This parameter is required.', example='i118191731740041623425'),
  nodeGroup?: {
    az?: string(name='Az', description='Availability Zone

This parameter is required.', example='cn-wulanchabu-b'),
    fileSystemMountEnabled?: boolean(name='FileSystemMountEnabled', description='Whether file storage mounting is supported', example='true'),
    imageId?: string(name='ImageId', description='Image ID.

This parameter is required.', example='i191887641687336652616'),
    keyPairName?: string(name='KeyPairName', description='Key pair name.', example='test-keypair'),
    loginPassword?: string(name='LoginPassword', description='Password', example='test-LoginPassword'),
    machineType?: string(name='MachineType', description='Machine type

This parameter is required.', example='mock-machine-type3'),
    nodeGroupDescription?: string(name='NodeGroupDescription', description='Node group description', example='describe for node group'),
    nodeGroupName?: string(name='NodeGroupName', description='Node group name

This parameter is required.', example='PAI-LINGJUN'),
    systemDisk?: {
      category?: string(name='Category', description='Disk type. Value range:

 - cloud_essd: ESSD cloud disk.', example='clou_essd'),
      performanceLevel?: string(name='PerformanceLevel', description='When creating an ESSD cloud disk as a system disk, set the performance level of the cloud disk. Value range:
- PL0: Maximum random read/write IOPS per disk 10,000.
- PL1: Maximum random read/write IOPS per disk 50,000.', example='PL1'),
      size?: int32(name='Size', description='Unit: GB.', example='1000'),
    }(name='SystemDisk', description='Details of the node system disk configuration.'),
    userData?: string(name='UserData', description='User-defined data', example='#!/bin/bash
uptime
echo "aaaaaaa" >> /tmp/ttttt20250110141010.sh'),
    virtualGpuEnabled?: boolean(name='VirtualGpuEnabled', description='Whether to enable gpu virtualization or not', example='false'),
  }(name='NodeGroup', description='Node ID.

This parameter is required.'),
  nodeUnit?: map[string]any(name='NodeUnit', description='Node information', example='{\\\\"NodeUnitId\\\\":\\\\"3c2999a8-2b95-4409-93c5-ad3985fc5c9f\\\\",\\\\"ResourceGroupId\\\\":\\\\"\\\\",\\\\"MaxNodes\\\\":0,\\\\"NodeUnitName\\\\":\\\\"asi_cn-serverless-sale_e01-lingjun-psale\\\\"}'),
}

model CreateNodeGroupShrinkRequest {
  clusterId?: string(name='ClusterId', description='Cluster ID

This parameter is required.', example='i118191731740041623425'),
  nodeGroupShrink?: string(name='NodeGroup', description='Node ID.

This parameter is required.'),
  nodeUnitShrink?: string(name='NodeUnit', description='Node information', example='{\\\\"NodeUnitId\\\\":\\\\"3c2999a8-2b95-4409-93c5-ad3985fc5c9f\\\\",\\\\"ResourceGroupId\\\\":\\\\"\\\\",\\\\"MaxNodes\\\\":0,\\\\"NodeUnitName\\\\":\\\\"asi_cn-serverless-sale_e01-lingjun-psale\\\\"}'),
}

model CreateNodeGroupResponseBody = {
  nodeGroupId?: string(name='NodeGroupId', description='Node group ID', example='ng-ec3c96ff0aa4c60d'),
  nodeGroupName?: string(name='NodeGroupName', description='NodeGroupName', example='emr-default'),
  requestId?: string(name='RequestId', description='ID of the request', example='887FA855-89F4-5DB3-B305-C5879EC480E6'),
}

model CreateNodeGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateNodeGroupResponseBody(name='body'),
}

/**
 * @summary Create Node Group under Cluster
 *
 * @param tmpReq CreateNodeGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNodeGroupResponse
 */
@context("createNodeGroupWithContext")
async function createNodeGroupWithOptions(tmpReq: CreateNodeGroupRequest, runtime: $RuntimeOptions): CreateNodeGroupResponse {
  tmpReq.validate();
  var request = new CreateNodeGroupShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.nodeGroup)) {
    request.nodeGroupShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.nodeGroup, 'NodeGroup', 'json');
  }
  if (!$isNull(tmpReq.nodeUnit)) {
    request.nodeUnitShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.nodeUnit, 'NodeUnit', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.nodeGroupShrink)) {
    body['NodeGroup'] = request.nodeGroupShrink;
  }
  if (!$isNull(request.nodeUnitShrink)) {
    body['NodeUnit'] = request.nodeUnitShrink;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateNodeGroup',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create Node Group under Cluster
 *
 * @param request CreateNodeGroupRequest
 * @return CreateNodeGroupResponse
 */
async function createNodeGroup(request: CreateNodeGroupRequest): CreateNodeGroupResponse {
  var runtime = new $RuntimeOptions{};
  return createNodeGroupWithOptions(request, runtime);
}

model CreateSessionRequest {
  nodeId?: string(name='NodeId', description='The instance ID.', example='e01-cn-kvw44e6dn04'),
  sessionType?: string(name='SessionType', description='The type of the session corresponding to the session package.', example='Valid values: Sol (default): based on serial port Assistant: based on cloud assistant'),
  startTime?: string(name='StartTime', description='The start time. The value is a 13-digit timestamp.', example='1669340937156'),
}

model CreateSessionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='887FA855-89F4-5DB3-B305-C5879EC480E6'),
  serverSn?: string(name='ServerSn', description='The node ID.', example='2A59143F1'),
  sessionId?: string(name='SessionId', description='The session ID.', example='i207023871669364793713'),
  sessionToken?: string(name='SessionToken', description='The session credential.', example='03f53c719015a9ad4f4f55d66cac2dac161b18e8065ca75a3220b89de389c980'),
  wssEndpoint?: string(name='WssEndpoint', description='The WebSocket address.', example='ws://x.x.x.x:xx/calypso_web_console'),
}

model CreateSessionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSessionResponseBody(name='body'),
}

/**
 * @summary Creates a Web Terminal session.
 *
 * @description The API creates a session, returns the frontend endpoint, and starts a periodic task to track the session status.
 *
 * @param request CreateSessionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSessionResponse
 */
@context("createSessionWithContext")
async function createSessionWithOptions(request: CreateSessionRequest, runtime: $RuntimeOptions): CreateSessionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!$isNull(request.sessionType)) {
    body['SessionType'] = request.sessionType;
  }
  if (!$isNull(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateSession',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a Web Terminal session.
 *
 * @description The API creates a session, returns the frontend endpoint, and starts a periodic task to track the session status.
 *
 * @param request CreateSessionRequest
 * @return CreateSessionResponse
 */
async function createSession(request: CreateSessionRequest): CreateSessionResponse {
  var runtime = new $RuntimeOptions{};
  return createSessionWithOptions(request, runtime);
}

model CreateVscRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.', example='123e4567-e89b-12d3-a456-426655440000'),
  nodeId?: string(name='NodeId', description='The node ID.

This parameter is required.', example='e01-cn-zvp2tgykr08'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-aek2xdkc6icwfha'),
  tag?: [ 
    {
      key?: string(name='Key', description='The resource tag key.', example='key001'),
      value?: string(name='Value', description='The resource tag value.', example='value001'),
    }
  ](name='Tag', description='The resource tags.'),
  vscName?: string(name='VscName', description='The custom name of the VSC, which is unique on a compute node.', example='test_name'),
  vscType?: string(name='VscType', description='The VSC type. Valid values: primary and standard. Default value: primary.', example='primary'),
}

model CreateVscResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='887FA855-89F4-5DB3-B305-C5879EC480E6'),
  vscId?: string(name='VscId', description='The VSC ID.', example='vsc-001'),
}

model CreateVscResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateVscResponseBody(name='body'),
}

/**
 * @summary Creates a virtual storage channel (VSC).
 *
 * @param request CreateVscRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVscResponse
 */
@context("createVscWithContext")
async function createVscWithOptions(request: CreateVscRequest, runtime: $RuntimeOptions): CreateVscResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  var body : map[string]any = {};
  if (!$isNull(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.tag)) {
    body['Tag'] = request.tag;
  }
  if (!$isNull(request.vscName)) {
    body['VscName'] = request.vscName;
  }
  if (!$isNull(request.vscType)) {
    body['VscType'] = request.vscType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateVsc',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a virtual storage channel (VSC).
 *
 * @param request CreateVscRequest
 * @return CreateVscResponse
 */
async function createVsc(request: CreateVscRequest): CreateVscResponse {
  var runtime = new $RuntimeOptions{};
  return createVscWithOptions(request, runtime);
}

model DeleteClusterRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='i116913051662373010974'),
}

model DeleteClusterResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0FC4A1C7-421C-5EAB-9361-4C0338EFA287'),
}

model DeleteClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteClusterResponseBody(name='body'),
}

/**
 * @summary Deletes a Lingjun cluster.
 *
 * @param request DeleteClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteClusterResponse
 */
@context("deleteClusterWithContext")
async function deleteClusterWithOptions(request: DeleteClusterRequest, runtime: $RuntimeOptions): DeleteClusterResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteCluster',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a Lingjun cluster.
 *
 * @param request DeleteClusterRequest
 * @return DeleteClusterResponse
 */
async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new $RuntimeOptions{};
  return deleteClusterWithOptions(request, runtime);
}

model DeleteNodeRequest {
  nodeId?: string(name='NodeId', description='This parameter is required.', example='e01-cn-kvw****dn04'),
}

model DeleteNodeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='8F065DDD-6996-5973-9691-9EC57BD0****'),
}

model DeleteNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteNodeResponseBody(name='body'),
}

/**
 * @summary 删除一个未使用节点
 *
 * @param request DeleteNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNodeResponse
 */
@context("deleteNodeWithContext")
async function deleteNodeWithOptions(request: DeleteNodeRequest, runtime: $RuntimeOptions): DeleteNodeResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteNode',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除一个未使用节点
 *
 * @param request DeleteNodeRequest
 * @return DeleteNodeResponse
 */
async function deleteNode(request: DeleteNodeRequest): DeleteNodeResponse {
  var runtime = new $RuntimeOptions{};
  return deleteNodeWithOptions(request, runtime);
}

model DeleteNodeGroupRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='i114444141733395242745'),
  nodeGroupId?: string(name='NodeGroupId', description='The node group ID.', example='i121824791737080429819'),
}

model DeleteNodeGroupResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='887FA855-89F4-5DB3-B305-C5879EC480E6'),
}

model DeleteNodeGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteNodeGroupResponseBody(name='body'),
}

/**
 * @summary 删除节点分组
 *
 * @param request DeleteNodeGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNodeGroupResponse
 */
@context("deleteNodeGroupWithContext")
async function deleteNodeGroupWithOptions(request: DeleteNodeGroupRequest, runtime: $RuntimeOptions): DeleteNodeGroupResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.nodeGroupId)) {
    body['NodeGroupId'] = request.nodeGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteNodeGroup',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除节点分组
 *
 * @param request DeleteNodeGroupRequest
 * @return DeleteNodeGroupResponse
 */
async function deleteNodeGroup(request: DeleteNodeGroupRequest): DeleteNodeGroupResponse {
  var runtime = new $RuntimeOptions{};
  return deleteNodeGroupWithOptions(request, runtime);
}

model DeleteVscRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.', example='123e4567-e89b-12d3-a456-426655440000'),
  vscId?: string(name='VscId', description='The ID of the VSC that you want to delete.

This parameter is required.', example='vsc-001'),
}

model DeleteVscResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='4FD06DF0-9167-5C6F-A145-F30CA4A15D54'),
}

model DeleteVscResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteVscResponseBody(name='body'),
}

/**
 * @summary Deletes a virtual storage channel (VSC).
 *
 * @param request DeleteVscRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVscResponse
 */
@context("deleteVscWithContext")
async function deleteVscWithOptions(request: DeleteVscRequest, runtime: $RuntimeOptions): DeleteVscResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  var body : map[string]any = {};
  if (!$isNull(request.vscId)) {
    body['VscId'] = request.vscId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteVsc',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a virtual storage channel (VSC).
 *
 * @param request DeleteVscRequest
 * @return DeleteVscResponse
 */
async function deleteVsc(request: DeleteVscRequest): DeleteVscResponse {
  var runtime = new $RuntimeOptions{};
  return deleteVscWithOptions(request, runtime);
}

model DescribeClusterRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='i119982311660892626523'),
}

model DescribeClusterResponseBody = {
  clusterDescription?: string(name='ClusterDescription', description='The cluster description.', example='Test cluster'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='i116913051662373010974'),
  clusterName?: string(name='ClusterName', description='The cluster name.', example='Eflo-YJ-Test-Cluster'),
  clusterType?: string(name='ClusterType', description='The cluster type.', example='AckEdgePro'),
  components?: [ 
    {
      componentId?: string(name='ComponentId', description='The component ID.', example='i149549021660892626529'),
      componentType?: string(name='ComponentType', description='The component type.

Valid values:

*   ARMS
*   ACKEdge', example='ACKEdge'),
    }
  ](name='Components', description='The component information.'),
  computingIpVersion?: string(name='ComputingIpVersion', description='The IP type of the computing network.', example='IPv4'),
  createTime?: string(name='CreateTime', description='The creation time.', example='2022-06-08T07:05:11Z'),
  hpnZone?: string(name='HpnZone', description='The cluster number.', example='A2'),
  networks?: {
    vpdId?: string(name='VpdId', description='The ID of the CIDR block for the cluster.', example='vpd-iqd7xunc'),
  }(name='Networks', description='The network information.'),
  nodeCount?: long(name='NodeCount', description='The number of nodes.', example='2'),
  nodeGroupCount?: long(name='NodeGroupCount', description='The number of node groups.', example='2'),
  openEniJumboFrame?: string(name='OpenEniJumboFrame', description='The status of Jumbo Frames for the elastic network interface (ENI).', example='unsupported'),
  operatingState?: string(name='OperatingState', description='The cluster status.', example='running'),
  requestId?: string(name='RequestId', description='The request ID.', example='887FA855-89F4-5DB3-B305-C5879EC480E6'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-aek2k3rqlvv6ytq'),
  taskId?: string(name='TaskId', description='The job ID.', example='i152609221670466904596'),
  updateTime?: string(name='UpdateTime', description='The update time.', example='2022-08-23T06:36:17.000Z'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-0jlkqysom5dmcviymep3f'),
}

model DescribeClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterResponseBody(name='body'),
}

/**
 * @summary Queries information about a Lingjun cluster.
 *
 * @param request DescribeClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClusterResponse
 */
@context("describeClusterWithContext")
async function describeClusterWithOptions(request: DescribeClusterRequest, runtime: $RuntimeOptions): DescribeClusterResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeCluster',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries information about a Lingjun cluster.
 *
 * @param request DescribeClusterRequest
 * @return DescribeClusterResponse
 */
async function describeCluster(request: DescribeClusterRequest): DescribeClusterResponse {
  var runtime = new $RuntimeOptions{};
  return describeClusterWithOptions(request, runtime);
}

model DescribeDiagnosticResultRequest {
  diagnosticId?: string(name='DiagnosticId', description='The diagnostic task ID.', example='diag-i151942361720577788844'),
}

model DescribeDiagnosticResultResponseBody = {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='i118913031696573280136'),
  createdTime?: string(name='CreatedTime', description='The creation time.', example='2024-06-15T10:17:56'),
  diagnosticId?: string(name='DiagnosticId', description='The diagnostic task ID.', example='diag-i155363241720059671316'),
  diagnosticResults?: [ any ](name='DiagnosticResults', description='The diagnostic information.'),
  diagnosticState?: string(name='DiagnosticState', description='The diagnostic status.', example='Fault'),
  diagnosticType?: string(name='DiagnosticType', description='The type of the diagnostic task.', example='CheckByAiJobLogs'),
  endTime?: string(name='EndTime', description='The end time of the instance exception. The time format with time zone based on the ISO8601 standard. The format is yyyy-MM-ddTHH:mm:ss +0800.', example='2024-06-11T10:00:30'),
  nodeIds?: [ string ](name='NodeIds', description='The node IDs.'),
  requestId?: string(name='RequestId', description='The request ID.', example='8F065DDD-6996-5973-9691-9EC57BD0072E'),
}

model DescribeDiagnosticResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDiagnosticResultResponseBody(name='body'),
}

/**
 * @summary Queries the results of a diagnostic task.
 *
 * @description The API creates a session, returns the frontend endpoint, and starts a periodic task to track the session status.
 *
 * @param request DescribeDiagnosticResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDiagnosticResultResponse
 */
@context("describeDiagnosticResultWithContext")
async function describeDiagnosticResultWithOptions(request: DescribeDiagnosticResultRequest, runtime: $RuntimeOptions): DescribeDiagnosticResultResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.diagnosticId)) {
    body['DiagnosticId'] = request.diagnosticId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDiagnosticResult',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the results of a diagnostic task.
 *
 * @description The API creates a session, returns the frontend endpoint, and starts a periodic task to track the session status.
 *
 * @param request DescribeDiagnosticResultRequest
 * @return DescribeDiagnosticResultResponse
 */
async function describeDiagnosticResult(request: DescribeDiagnosticResultRequest): DescribeDiagnosticResultResponse {
  var runtime = new $RuntimeOptions{};
  return describeDiagnosticResultWithOptions(request, runtime);
}

model DescribeInvocationsRequest {
  contentEncoding?: string(name='ContentEncoding', description='The encoding mode of the `CommandContent` and `Output` response parameters. Valid values:

*   PlainText: returns the original command content and command outputs.
*   Base64 (default): returns the Base64-encoded command content and command output.', example='PlainText'),
  includeOutput?: boolean(name='IncludeOutput', description='Specifies whether to return the command outputs in the response.

*   true: returns the command outputs. When this parameter is set to true, you must specify `InvokeId`, `InstanceId`, or both.
*   false (default)', example='true'),
  invokeId?: string(name='InvokeId', description='The execution ID.

This parameter is required.', example='t-cd03crwys0lrls0'),
  nodeId?: string(name='NodeId', description='The instance ID.', example='e01-cn-zvp2tgykr08'),
}

model DescribeInvocationsResponseBody = {
  invocations?: {
    invocation?: [ 
      {
        commandContent?: string(name='CommandContent', description='The executed command.

*   If ContentEncoding is set to PlainText in the request, the original command content is returned.
*   If ContentEncoding is set to Base64 in the request, the Base64-encoded command content is returned.', example='cnBtIC1xYSB8IGdyZXAgdnNm****'),
        commandDescription?: string(name='CommandDescription', description='The command description.', example='testDescription'),
        commandName?: string(name='CommandName', description='The command name.', example='CommandTestName'),
        creationTime?: string(name='CreationTime', description='The time when the command task was created.', example='2020-01-19T09:15:46Z'),
        frequency?: string(name='Frequency', description='The schedule on which the command was run.'),
        invocationStatus?: string(name='InvocationStatus', description='The overall execution state of the command task. The value of this parameter depends on the execution states of the command task on all the involved instances. Valid values:

*   Pending: The command was being verified or sent. If the execution state on at least one instance is Pending, the overall execution state is Pending.

*   Scheduled: The command that is set to run on a schedule is sent and waiting to be run. If the execution state on at least one instance is Scheduled, the overall execution state is Scheduled.

*   Running: The command is being run on the instance. When the execution state on at least one instance is Running, the overall execution state is Running.

*   Success: When the execution state on at least one instance is Success and the execution state on the other instances is Stopped or Success, the overall execution state is Success.

    *   One-time task: The execution is complete, and the exit code is 0.
    *   Scheduled task: The last execution was complete, the exit code was 0, and the specified period ended.

*   Failed: When the execution state on all instances is Stopped or Failed, the overall execution state is Failed. When the execution state on an instance is one of the following values, Failed is returned as the overall execution state:

    *   Invalid: The command is invalid.
    *   Aborted: The command failed to be sent.
    *   Failed: The execution was complete, but the exit code was not 0.
    *   Timeout: The execution timed out.
    *   Error: An error occurred while the command was being run.

*   Stopping: The command task is being stopped. When the execution state on at least one instance is Stopping, the overall execution state is Stopping.

*   Stopped: The task was stopped. When the execution state on all instances is Stopped, the overall execution state is Stopped. When the execution state on an instance is one of the following values, Stopped is returned as the overall execution state:

    *   Cancelled: The task was canceled.
    *   Terminated: The task was terminated.

*   PartialFailed: The execution was complete on some instances and failed on other instances. When the execution state is Success on some instances and is Failed or Stopped on the other instances, the overall execution state is PartialFailed.

>  The value of the `InvokeStatus` response parameter is similar to the value of InvocationStatus. We recommend that you ignore InvokeStatus and check the value of InvocationStatus.', example='Success'),
        invokeId?: string(name='InvokeId', description='The execution ID.', example='t-ind3k9ytvvduoe8'),
        invokeNodes?: {
          invokeNode?: [ 
            {
              creationTime?: string(name='CreationTime', description='The start time of the execution.', example='2023-02-06T07:12:50Z'),
              dropped?: int32(name='Dropped', description='The size of the Output text that was truncated and discarded because the Output value exceeded 24 KB in size.', example='0'),
              errorCode?: string(name='ErrorCode', description='The error code returned when the file failed to be sent to the instance. Valid values:

*   Null: The file is sent to the instance.
*   NodeNotExists: The specified instance does not exist or has been released.
*   NodeReleased: The instance was released while the file was being sent.
*   NodeNotRunning: The instance was not running while the file sending task was being created.
*   AccountNotExists: The specified account does not exist.
*   ClientNotRunning: Cloud Assistant Agent is not running.
*   ClientNotResponse: Cloud Assistant Agent does not respond.
*   ClientIsUpgrading: Cloud Assistant Agent is being upgraded.
*   ClientNeedUpgrade: Cloud Assistant Agent needs to be upgraded.
*   DeliveryTimeout: The file sending task timed out.
*   FileCreateFail: The file failed to be created.
*   FileAlreadyExists: A file with the same name exists in the specified directory.
*   FileContentInvalid: The file content is invalid.
*   FileNameInvalid: The file name is invalid.
*   FilePathInvalid: The specified directory is invalid.
*   FileAuthorityInvalid: The specified permissions on the file are invalid.
*   UserGroupNotExists: The specified user group does not exist.', example='NodeNotExists'),
              errorInfo?: string(name='ErrorInfo', description='The error message returned when the command cannot be sent or run.

*   If this parameter is empty, the command was run as expected.
*   the specified node does not exists: The specified instance does not exist or is released.
*   the node has node when create task: The instance is released when the command is being run.
*   the node is not running when create task: The instance is not in the Running state while the command is being run.
*   the command is not applicable: The command is not applicable to the specified instance.
*   the specified account does not exists: The specified account does not exist.
*   the specified directory does not exists: The specified directory does not exist.
*   the cron job expression is invalid: The cron expression that specifies the execution time is invalid.
*   the aliyun service is not running on the instance: Cloud Assistant Agent is not running.
*   the aliyun service in the instance does not response: Cloud Assistant Agent does not respond.
*   the aliyun service in the node is upgrading now: Cloud Assistant Agent is being upgraded.
*   the aliyun service in the node need upgrade: Cloud Assistant Agent needs to be upgraded.
*   the command delivery has been timeout: The request to send the command timed out.
*   the command execution has been timeout: The command execution timed out.
*   the command execution got an exception: An exception occurred when the command is being run.
*   the command execution has been interrupted: The command execution is interrupted.
*   the command execution exit code is not zero: The command execution completes, but the exit code is not 0.
*   the specified node has been released: The instance is released while the file is being sent.', example='the specified node does not exists'),
              exitCode?: int32(name='ExitCode', description='The exit code of the execution. Valid values:

*   For Linux instances, the value is the exit code of the shell process.
*   For Windows instances, the value is the exit code of the batch or PowerShell process.', example='0'),
              finishTime?: string(name='FinishTime', description='The end time of the execution.', example='2023-02-06T07:12:50Z'),
              invocationStatus?: string(name='InvocationStatus', description='The execution status of the command on a single instance. Valid values:

*   Pending: The command was being verified or sent.

*   Invalid: The specified command type or parameter is invalid.

*   Aborted: The command failed to be sent to the instance. To send a command to an instance, make sure that the instance is in the Running state and the command can be sent to the instance within 1 minute.

*   Running: The command is being run on the instance.

*   Success:

    *   One-time task: The execution was complete, and the exit code was 0.
    *   Recurring execution: The previous occurrence of the execution is complete, and the exit code is 0. The specified recurring period during which the command is run ends.

*   Failed:

    *   One-time task: The execution was complete, but the exit code was not 0.
    *   Recurring execution: The previous occurrence of the execution is complete, but the exit code is not 0. The specified recurring period during which the command is run is about to end.

*   Error: The execution cannot proceed due to an exception.

*   Timeout: The execution timed out.

*   Cancelled: The execution was canceled before it started.

*   Stopping: The command task is being stopped.

*   Terminated: The execution was terminated before completion.

*   Scheduled:

    *   One-time task: The execution state can never be Scheduled.
    *   Recurring execution: The command is waiting to be run.', example='Pending'),
              nodeId?: string(name='NodeId', description='The node ID.', example='e01-cn-lbj36wkp70b'),
              nodeInvokeStatus?: string(name='NodeInvokeStatus', description='The execution status of the command on a single instance.', example='Finished'),
              output?: string(name='Output', description='The command output.

*   If ContentEncoding is set to PlainText in the request, the original command output is returned.
*   If ContentEncoding is set to Base64 in the request, the Base64-encoded command output is returned.', example='OutPutTestmsg'),
              repeats?: int32(name='Repeats', description='The number of times that the command was run on the instance.

*   If the command is set to run only once, the value is 0 or 1.
*   If the command is set to run on a schedule, the value is the number of times that the command has been run on the instance.', example='0'),
              startTime?: string(name='StartTime', description='The start time.', example='2019-12-20T06:15:55Z'),
              stopTime?: string(name='StopTime', description='The time when the command task was stopped. If you call the StopInvocation operation to stop the command task, the value of this parameter is the time when the operation is called.', example='2019-12-20T06:15:55Z'),
              timed?: string(name='Timed', description='Indicates whether the command is to be automatically run. Valid values:

*   true: The command is run by calling the `RunCommand` or `InvokeCommand` operation with `RepeatMode` set to `Period`, `NextRebootOnly`, or `EveryReboot`.

*   false (default): The command meets the following requirements.

    *   The command is run by calling the `RunCommand` or `InvokeCommand` operation with `RepeatMode` set to `Once`.
    *   The command task is canceled, stopped, or completed.', example='false'),
              updateTime?: string(name='UpdateTime', description='The update time of the execution.', example='2023-02-06T07:12:50Z'),
            }
          ](name='InvokeNode', description='The command execution records of the node.'),
        }(name='InvokeNodes', description='The command execution records.'),
        invokeStatus?: string(name='InvokeStatus', description='The overall execution status of the command task. The value of this parameter depends on the execution states of the command task on all involved instances. Valid values:

*   Running:

    *   Scheduled task: Before you stop the scheduled execution of the command, the overall execution state is always Running.
    *   One-time task: If the command is being run on instances, the overall execution state is Running.

*   Finished:

    *   Scheduled task: The overall execution state can never be Finished.
    *   One-time task: The execution is complete on all instances, or the execution is stopped on some instances and is complete on the other instances.

*   Failed:

    *   Scheduled task: The overall execution state can never be Failed.
    *   One-time task: The execution failed on all instances.

*   Stopped: The task is stopped.

*   Stopping: The task is being stopped.

*   PartialFailed: The task fails on some instances. If you specify both this parameter and `InstanceId`, this parameter does not take effect.', example='Running'),
        parameters?: string(name='Parameters', description='The custom parameters in the command.', example='{}'),
        repeatMode?: string(name='RepeatMode', description='The execution mode of the command. Valid values:

*   Once: The command is run immediately.
*   Period: The command is run on a schedule.
*   NextRebootOnly: The command is run the next time the instances start.
*   EveryReboot: runs the command every time the instances start.', example='Once'),
        timeout?: int32(name='Timeout', description='The timeout period for the command execution. Unit: seconds.', example='60'),
        username?: string(name='Username', description='The username that is used to run the command.', example='root'),
        workingDir?: string(name='WorkingDir', description='The working directory of the command on the instance.', example='/home'),
      }
    ](name='Invocation', description='The file sending records.'),
  }(name='Invocations', description='The command execution record.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4FD06DF0-9167-5C6F-A145-F30CA4A15D54'),
}

model DescribeInvocationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInvocationsResponseBody(name='body'),
}

/**
 * @summary Queries the execution list and status of O\\&M Assistant commands.
 *
 * @param request DescribeInvocationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInvocationsResponse
 */
@context("describeInvocationsWithContext")
async function describeInvocationsWithOptions(request: DescribeInvocationsRequest, runtime: $RuntimeOptions): DescribeInvocationsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.contentEncoding)) {
    body['ContentEncoding'] = request.contentEncoding;
  }
  if (!$isNull(request.includeOutput)) {
    body['IncludeOutput'] = request.includeOutput;
  }
  if (!$isNull(request.invokeId)) {
    body['InvokeId'] = request.invokeId;
  }
  if (!$isNull(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeInvocations',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the execution list and status of O\\&M Assistant commands.
 *
 * @param request DescribeInvocationsRequest
 * @return DescribeInvocationsResponse
 */
async function describeInvocations(request: DescribeInvocationsRequest): DescribeInvocationsResponse {
  var runtime = new $RuntimeOptions{};
  return describeInvocationsWithOptions(request, runtime);
}

model DescribeNetTestResultRequest {
  testId?: string(name='TestId', description='The ID of the test task. The unique identifier of a network test task.', example='dr-uf6i0tv2refv8wz*****'),
}

model DescribeNetTestResultResponseBody = {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='i119982311660892626523'),
  clusterName?: string(name='ClusterName', description='The cluster name.', example='Standard_Cluster'),
  commTest?: {
    GPUNum?: string(name='GPUNum', description='Number of GPUs', example='1'),
    hosts?: [ 
      {
        IP?: string(name='IP', description='The IP address.', example='169.253.253.15'),
        resourceId?: string(name='ResourceId', description='The resource ID.', example='i111670831721110797708'),
        serverName?: string(name='ServerName', description='Service name.', example='VBw'),
      }
    ](name='Hosts', description='All hosts infomation'),
    model?: string(name='Model', description='The communication library model.', example='intention_v4'),
    type?: string(name='Type', description='The CommTest type, which can be ACCL or NCCL.', example='ACCL'),
  }(name='CommTest', description='Specify when NetTestType is CommTest.'),
  creationTime?: string(name='CreationTime', description='create time', example='2024-10-15T10:25:42+08:00'),
  delayTest?: {
    hosts?: [ 
      {
        bond?: string(name='Bond', description='The bonding of network interface card.', example='bond1'),
        IP?: string(name='IP', description='The IP address.', example='125.210.225.48'),
        resourceId?: string(name='ResourceId', description='The resource ID.', example='e01-cn-bcd3u1aee06'),
        serverName?: string(name='ServerName', description='Service name.', example='NQU'),
      }
    ](name='Hosts', description='All hosts infomation'),
  }(name='DelayTest', description='Fill in when the network test type is a delay test.'),
  finishedTime?: string(name='FinishedTime', description='finish time', example='2024-10-16T02:04Z'),
  netTestType?: string(name='NetTestType', description='The type of the network test.', example='DelayTest'),
  port?: string(name='Port', description='Test port number.', example='23604'),
  requestId?: string(name='RequestId', description='The request ID.', example='8F065DDD-6996-5973-9691-9EC57BD0072E'),
  resultDetial?: string(name='ResultDetial', description='result detail', example='{}'),
  status?: string(name='Status', description='status of session', example='Failed'),
  testId?: string(name='TestId', description='The ID of the test task. The unique identifier of a network test task.', example='af35ce53-7c35-4277-834a-fbf49c316a96'),
  trafficTest?: {
    clients?: [ 
      {
        bond?: string(name='Bond', description='Network interface bond port', example='bond1'),
        IP?: string(name='IP', description='IP address.', example='192.168.1.1'),
        resourceId?: string(name='ResourceId', description='The resource ID.', example='e01-cn-20s41p6cx01'),
        serverName?: string(name='ServerName', description='The name of the service.', example='xMv'),
      }
    ](name='Clients', description='All clients information'),
    duration?: long(name='Duration', description='Call duration, in seconds.', example='1'),
    GDR?: string(name='GDR', description='When the protocol is RDMA, fill in True/False,
when the protocol is TCP, this field is empty.', example='False'),
    protocol?: string(name='Protocol', description='Network protocol, either RDMA or TCP.', example='TCP'),
    QP?: long(name='QP', description='When the protocol is TCP, fill in the number of concurrent connections; when the protocol is RDMA, fill in the configured QP value.', example='1'),
    servers?: [ 
      {
        bond?: string(name='Bond', description='Network interface bond port', example='bond1'),
        IP?: string(name='IP', description='The IP address.', example='47.121.110.190'),
        resourceId?: string(name='ResourceId', description='The resource ID.', example='e01-cn-wwo3etaqu0b'),
        serverName?: string(name='ServerName', description='Service name.', example='xMv'),
      }
    ](name='Servers', description='Servers infomation.'),
    trafficModel?: string(name='TrafficModel', description='Traffic model, either MTON or Fullmesh.', example='Fullmesh'),
  }(name='TrafficTest', description='Fill in when the network test type is a traffic test.'),
}

model DescribeNetTestResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeNetTestResultResponseBody(name='body'),
}

/**
 * @summary Query Network Test Result
 *
 * @param request DescribeNetTestResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNetTestResultResponse
 */
@context("describeNetTestResultWithContext")
async function describeNetTestResultWithOptions(request: DescribeNetTestResultRequest, runtime: $RuntimeOptions): DescribeNetTestResultResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.testId)) {
    body['TestId'] = request.testId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeNetTestResult',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Query Network Test Result
 *
 * @param request DescribeNetTestResultRequest
 * @return DescribeNetTestResultResponse
 */
async function describeNetTestResult(request: DescribeNetTestResultRequest): DescribeNetTestResultResponse {
  var runtime = new $RuntimeOptions{};
  return describeNetTestResultWithOptions(request, runtime);
}

model DescribeNodeRequest {
  nodeId?: string(name='NodeId', description='The node ID.

This parameter is required.', example='mock-sn-2060'),
}

model DescribeNodeResponseBody = {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='i116913051662373010974'),
  clusterName?: string(name='ClusterName', description='The cluster name.', example='Standard_Cluster'),
  createTime?: string(name='CreateTime', description='The creation time.', example='2022-09-30T03:35:53Z'),
  disks?: [ 
    {
      category?: string(name='Category', description='The disk type. Valid values:

*   cloud_essd', example='cloud_essd'),
      diskId?: string(name='DiskId', description='The disk ID.', example='d-bp1fi88ryk4yah8a6yos'),
      performanceLevel?: string(name='PerformanceLevel', description='The performance level of the ESSD that is used as the system disk. Valid values:

*   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.', example='PL1'),
      size?: int32(name='Size', description='The disk size. Unit: GiB.', example='100'),
      type?: string(name='Type', description='The disk type. Valid values:

*   system: system disk
*   data: data disk', example='system'),
    }
  ](name='Disks', description='The disks.'),
  expiredTime?: string(name='ExpiredTime', description='The expiration time.', example='2022-06-23T16:00:00Z'),
  fileSystemMountEnabled?: boolean(name='FileSystemMountEnabled', description='Indicates whether file storage mounting is supported.', example='False'),
  hostname?: string(name='Hostname', description='The hostname.', example='31d38530-241e-11ed-bc63-acde48001122'),
  hpnZone?: string(name='HpnZone', description='The cluster number.', example='A1'),
  imageId?: string(name='ImageId', description='The image ID.', example='i190297201634099844192'),
  imageName?: string(name='ImageName', description='The image name.', example='Centos7.9_all_0811'),
  machineType?: string(name='MachineType', description='The instance type.', example='efg1.nvga1'),
  networks?: [ 
    {
      bondName?: string(name='BondName', description='The port information of the elastic network interface (ENI).', example='Bond0'),
      ip?: string(name='Ip', description='The IP address of the node.', example='47.254.235.44'),
      subnetId?: string(name='SubnetId', description='The subnet ID.', example='vsw-uf68v51fldm5egmui5a6k'),
      vpdId?: string(name='VpdId', description='The ID of the cluster network.', example='vpd-xcuhjyrj'),
    }
  ](name='Networks', description='The network information.'),
  nodeGroupId?: string(name='NodeGroupId', description='The node group ID.', example='ng-ec3c96ff0aa4c60d'),
  nodeGroupName?: string(name='NodeGroupName', description='The node group name.', example='emr-default'),
  nodeId?: string(name='NodeId', description='The node ID.', example='e01-cn-zvp2tgykr08'),
  nodeType?: string(name='NodeType', example='standard'),
  operatingState?: string(name='OperatingState', description='The node status.

Valid values:

*   Extending
*   UnusedNodeStopped
*   UnusedNodeStopping
*   Unused
*   Using
*   ReleaseLocking
*   Operating
*   Cutting
*   ClusterNodeStopped
*   UnusedNodeRecovering
*   ClusterNodeStopping
*   ClusterNodeRecovering
*   Replacing', example='Using'),
  requestId?: string(name='RequestId', description='The request ID.', example='AC4F0004-7BCE-52E0-891B-CAC7D64E3368'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-acfmywpvugkh7kq'),
  sn?: string(name='Sn', description='The serial number of the node.', example='sag42ckf4jx'),
  userData?: string(name='UserData', description='The custom script.', example='#!/bin/bash
uptime
echo "aaaaaaa" >> /tmp/ttttt20250110141010.sh'),
  zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-i'),
}

model DescribeNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeNodeResponseBody(name='body'),
}

/**
 * @summary Queries a list of nodes.
 *
 * @param request DescribeNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNodeResponse
 */
@context("describeNodeWithContext")
async function describeNodeWithOptions(request: DescribeNodeRequest, runtime: $RuntimeOptions): DescribeNodeResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeNode',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of nodes.
 *
 * @param request DescribeNodeRequest
 * @return DescribeNodeResponse
 */
async function describeNode(request: DescribeNodeRequest): DescribeNodeResponse {
  var runtime = new $RuntimeOptions{};
  return describeNodeWithOptions(request, runtime);
}

model DescribeNodeTypeRequest {
  nodeType?: string(name='NodeType', example='standard'),
}

model DescribeNodeTypeResponseBody = {
  eniHighDenseQuantity?: int32(name='EniHighDenseQuantity', example='63'),
  eniIpv6AddressQuantity?: int32(name='EniIpv6AddressQuantity', example='256'),
  eniPrivateIpAddressQuantity?: int32(name='EniPrivateIpAddressQuantity', example='256'),
  eniQuantity?: int32(name='EniQuantity', example='22'),
  requestId?: string(name='RequestId', example='4FD06DF0-9167-5C6F-A145-F30CA4A15D54'),
}

model DescribeNodeTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeNodeTypeResponseBody(name='body'),
}

/**
 * @summary 创建Web Terminal会话
 *
 * @param request DescribeNodeTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNodeTypeResponse
 */
@context("describeNodeTypeWithContext")
async function describeNodeTypeWithOptions(request: DescribeNodeTypeRequest, runtime: $RuntimeOptions): DescribeNodeTypeResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.nodeType)) {
    body['NodeType'] = request.nodeType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeNodeType',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建Web Terminal会话
 *
 * @param request DescribeNodeTypeRequest
 * @return DescribeNodeTypeResponse
 */
async function describeNodeType(request: DescribeNodeTypeRequest): DescribeNodeTypeResponse {
  var runtime = new $RuntimeOptions{};
  return describeNodeTypeWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The natural language that is used to filter responses. For more information, see RFC 7231.

zh-CN en-US Default value: zh-CN.

Valid values:

*   en-US
*   zh-CN', example='zh-CN'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName', description='The region name.', example='Hang Zhou'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
    }
  ](name='Regions', description='The regions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='1D2FBB36-C39B-5EBB-9928-FCC1A236D65D'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @summary Queries a list of regions.
 *
 * @param request DescribeRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
@context("describeRegionsWithContext")
async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: $RuntimeOptions): DescribeRegionsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.acceptLanguage)) {
    body['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeRegions',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of regions.
 *
 * @param request DescribeRegionsRequest
 * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new $RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeSendFileResultsRequest {
  invokeId?: string(name='InvokeId', description='The command execution ID.

This parameter is required.', example='t-bj038i0d6r8zoqo'),
  nodeId?: string(name='NodeId', description='The node ID.', example='e01-cn-zvp2tgykr08'),
}

model DescribeSendFileResultsResponseBody = {
  invocations?: {
    invocation?: [ 
      {
        content?: string(name='Content', description='The command output.

If ContentEncoding is set to PlainText in the request, the original command output is returned. If ContentEncoding is set to Base64 in the request, the Base64-encoded command output is returned.', example='Base64'),
        contentType?: string(name='ContentType', description='The content type of the file.

PlainText: The file content is not encoded. Base64: The file content is encoded in Base64. Default value: PlainText.', example='PlainText'),
        creationTime?: string(name='CreationTime', description='The time when the file sending task was created.', example='2023-04-10T10:53:46.156+08:00'),
        description?: string(name='Description', description='The command description.', example='Description'),
        fileGroup?: string(name='FileGroup', description='The user group of the file.', example='root'),
        fileMode?: string(name='FileMode', description='The permissions on the file.', example='0644'),
        fileOwner?: string(name='FileOwner', description='The owner of the file.', example='root'),
        invocationStatus?: string(name='InvocationStatus', description='The overall sending status of the file. The overall sending status of the file varies based on the sending status of the file on all destination instances. Valid values:

*   Pending: The file is being verified or sent. If the sending state of the file on at least one instance is Pending, the overall sending state of the file is Pending.

*   Running: The file is being sent to the instance. If the sending state of the file on at least one instance is Running, the overall sending state of the file is Running.

*   Success: If the sending state of the file on all instances is Success, the overall sending state of the file is Success.

*   Failed: If the sending state of the file on all instances is Failed, the overall sending state of the file is Failed. If the sending state of the file on one or more instances is one of the following values, the overall sending state of the file is Failed:

    *   Invalid: The file is invalid.
    *   Aborted: The file failed to be sent to the instances.
    *   Failed: The file failed to be created on the instances.
    *   Timeout: The file sending task timed out.
    *   Error: An error occurred and interrupted the file sending task.

*   PartialFailed: The file sending task was completed on some instances but failed on other instances. If the sending state of the file is Success on some instances and is Failed on other instances, the overall sending state of the file is PartialFailed.', example='Pending'),
        invokeNodes?: {
          invokeNode?: [ 
            {
              creationTime?: string(name='CreationTime', description='The time when the file sending task was created.', example='2023-02-06T07:12:50Z'),
              errorCode?: string(name='ErrorCode', description='The error code returned when the file failed to be sent to the instance. Valid values:

Null: The file is sent to the instance. NodeNotExists: The specified instance does not exist or has been released. NodeReleased: The instance was released while the file was being sent. NodeNotRunning: The instance was not running while the file sending task was being created. AccountNotExists: The specified account does not exist. ClientNotRunning: Cloud Assistant Agent is not running. ClientNotResponse: Cloud Assistant Agent did not respond. ClientIsUpgrading: Cloud Assistant Agent was being upgraded. ClientNeedUpgrade: Cloud Assistant Agent needs to be upgraded. DeliveryTimeout: The file sending task timed out. FileCreateFail: The file failed to be created. FileAlreadyExists: A file with the same name exists in the specified directory. FileContentInvalid: The file content is invalid. FileNameInvalid: The file name is invalid. FilePathInvalid: The specified directory is invalid. FileAuthorityInvalid: The specified permissions on the file are invalid. UserGroupNotExists: The specified user group does not exist.', example='AccountNotExists'),
              errorInfo?: string(name='ErrorInfo', description='The error message returned if the command failed to be sent or run. Valid values:

*   null: The command is run as expected.
*   the specified instance does not exists: The specified instance does not exist or is released.
*   the node has released when create task: The instance is released when the command is being run.
*   the node is not running when create task: The instance is not in the Running state while the command is being run.
*   the command is not applicable: The command is not applicable to the specified instance.
*   the specified account does not exists: The specified account does not exist.
*   the specified directory does not exists: The specified directory does not exist.
*   the cron job expression is invalid: The cron expression that specifies the execution time is invalid.
*   the aliyun service is not running on the instance: Cloud Assistant Agent is not running.
*   the aliyun service in the instance does not response: Cloud Assistant Agent does not respond.
*   the aliyun service in the node is upgrading now: Cloud Assistant Agent is being upgraded.
*   the aliyun service in the node need upgrade: Cloud Assistant Agent needs to be upgraded.
*   the command delivery has been timeout: The request to send the command timed out.
*   the command execution has been timeout: The command execution timed out.
*   the command execution got an exception: An exception occurred when the command is being run.
*   the command execution has been interrupted: The command execution is interrupted.
*   the command execution exit code is not zero: The command execution completes, but the exit code is not 0.
*   the specified instance has been released: The instance is released while the file is being sent.', example='the specified instance does not exists'),
              finishTime?: string(name='FinishTime', description='The time when the file sending task ends. The time is in the 2020-05-22T17:04:18 format.', example='2023-04-10T10:53:46.156+08:00'),
              invocationStatus?: string(name='InvocationStatus', description='The status of the file sending task on an instance. Valid values:

*   Pending: The file is being verified or sent.
*   Invalid: The file is invalid.
*   Running: The file is being sent to the instance.
*   Aborted: The file failed to be sent to the instance.
*   Success: The file is sent.
*   Failed: The file failed to be created on the instance.
*   Error: An error occurred and interrupted the file sending task.
*   Timeout: The file sending task timed out.', example='Success'),
              nodeId?: string(name='NodeId', description='The node ID.', example='e01-cn-9lb3c15m81j'),
              startTime?: string(name='StartTime', description='The start time.', example='2023-03-30T16:00:00Z'),
              updateTime?: string(name='UpdateTime', description='The update time.', example='2023-03-30T16:00:00Z'),
            }
          ](name='InvokeNode', description='The file sending records on a node.'),
        }(name='InvokeNodes', description='The file sending records.'),
        name?: string(name='Name', description='The name of the file sending task.', example='test'),
        nodeCount?: int32(name='NodeCount', description='The number of nodes.', example='3'),
        overwrite?: boolean(name='Overwrite', description='Indicates whether a file was overwritten in the destination directory if the file has the same name as the sent file.

*   true
*   false

Default value: false.', example='true'),
        targetDir?: string(name='TargetDir', description='The destination directory.', example='/home/user'),
      }
    ](name='Invocation', description='The command execution ID.'),
  }(name='Invocations', description='The file sending records.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4FD06DF0-9167-5C6F-A145-F30CA4A15D54'),
  totalCount?: string(name='TotalCount', description='The total number of the commands.', example='1'),
}

model DescribeSendFileResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSendFileResultsResponseBody(name='body'),
}

/**
 * @summary Queries the files that are sent by an O\\&M assistant and the status of the files.
 *
 * @param request DescribeSendFileResultsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSendFileResultsResponse
 */
@context("describeSendFileResultsWithContext")
async function describeSendFileResultsWithOptions(request: DescribeSendFileResultsRequest, runtime: $RuntimeOptions): DescribeSendFileResultsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.invokeId)) {
    body['InvokeId'] = request.invokeId;
  }
  if (!$isNull(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeSendFileResults',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the files that are sent by an O\\&M assistant and the status of the files.
 *
 * @param request DescribeSendFileResultsRequest
 * @return DescribeSendFileResultsResponse
 */
async function describeSendFileResults(request: DescribeSendFileResultsRequest): DescribeSendFileResultsResponse {
  var runtime = new $RuntimeOptions{};
  return describeSendFileResultsWithOptions(request, runtime);
}

model DescribeTaskRequest {
  taskId?: string(name='TaskId', description='The task ID.

This parameter is required.', example='i156331731670384438138'),
}

model DescribeTaskResponseBody = {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='i119982311660892626523'),
  clusterName?: string(name='ClusterName', description='The cluster name.', example='Standard_Cluster'),
  createTime?: string(name='CreateTime', description='The create time.', example='2022-11-30T02:00:00.852Z'),
  message?: string(name='Message', description='The error message returned for failed tasks.', example='Releasing [prod_main_mid_26e234cf] in region [cn-beijing] with weight [0]'),
  nodeIds?: [ string ](name='NodeIds', description='The IDs of the nodes.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A7FD7411-9395-52E8-AF42-EB3A4A55446D'),
  steps?: [ 
    {
      message?: string(name='Message', description='The error message of the step.', example='get taskinfo failed'),
      stageTag?: string(name='StageTag', description='The stage marker.

Valid values:

*   机器释放: Machine release.
*   节点并发初始化: Node concurrent initialization.
*   节点释放: Node release.
*   机器替换: Machine replacement.
*   节点缩容: Node scale-in.
*   提前续费: Early renewal.
*   物理机清理: Physical machine cleanup.
*   节点清理: Node cleanup.
*   创建K8s集群: Create Kubernetes cluster.
*   网络初始化: Network initialization.
*   节点重启: Node restart.
*   节点退订: Node unsubscribe.
*   集群扩容: Cluster scale-out.
*   异常机器释放: Abnormal machine release.', example='节点缩容'),
      startTime?: string(name='StartTime', description='The start time.', example='2022-11-30T2:00:00.852Z'),
      stepName?: string(name='StepName', description='The name of the step.', example='create_vpd'),
      stepState?: string(name='StepState', description='The step status.

Valid values:

*   execution_success
*   execution_failed', example='execution_success'),
      stepType?: string(name='StepType', description='The type of the step.

Valid values:

*   normal: A normal step has only one successor step.
*   dispersive: A dispersive step has multiple successor steps.', example='normal'),
      subTasks?: [ 
        {
          createTime?: string(name='CreateTime', description='The creation time.', example='2022-11-30T2:00:00.852Z'),
          message?: string(name='Message', description='The error message returned for failed sub tasks.', example='Releasing [prod_main_mid_26e234cf] in region [cn-beijing] with weight [0]'),
          taskId?: string(name='TaskId', description='The task ID.', example='i158805051661047928377'),
          taskState?: string(name='TaskState', description='The task status.', example='running'),
          taskType?: string(name='TaskType', description='The task type.

Valid values:

*   reclone_node_sub_task
*   initialize_bare_cluster
*   extend_bare_cluster
*   reclone_node
*   reboot_node
*   extend_ack_edge_cluster
*   extend_cluster
*   initialize_ack_edge_cluster
*   cut_node_sub_task
*   reboot_node_sub_task
*   reclone_ack_edge_node
*   initialize_cluster
*   cut_cluster
*   reclone_bare_node
*   cut_bare_cluster', example='cut_node_sub_task'),
          updateTime?: string(name='UpdateTime', description='The update time.', example='2022-11-30T02:20:14.852Z'),
        }
      ](name='SubTasks', description='The sub tasks.'),
      updateTime?: string(name='UpdateTime', description='The update time.', example='2022-11-30T02:20:14.852Z'),
    }
  ](name='Steps', description='The steps.'),
  taskState?: string(name='TaskState', description='The task status.

Valid values:

*   running
*   execution_success
*   execution_fail
*   waiting_to_run', example='running'),
  taskType?: string(name='TaskType', description='The task type.

Valid values:

*   reclone_node_sub_task
*   initialize_bare_cluster
*   extend_bare_cluster
*   reclone_node
*   reboot_node
*   extend_ack_edge_cluster
*   extend_cluster
*   initialize_ack_edge_cluster
*   cut_node_sub_task
*   reboot_node_sub_task
*   reclone_ack_edge_node
*   initialize_cluster
*   cut_cluster
*   reclone_bare_node
*   cut_bare_cluster', example='cut_cluster'),
  updateTime?: string(name='UpdateTime', description='The update time.', example='2022-11-30T03:40:14.852Z'),
}

model DescribeTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTaskResponseBody(name='body'),
}

/**
 * @summary Queries the details of a task.
 *
 * @param request DescribeTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTaskResponse
 */
@context("describeTaskWithContext")
async function describeTaskWithOptions(request: DescribeTaskRequest, runtime: $RuntimeOptions): DescribeTaskResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeTask',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a task.
 *
 * @param request DescribeTaskRequest
 * @return DescribeTaskResponse
 */
async function describeTask(request: DescribeTaskRequest): DescribeTaskResponse {
  var runtime = new $RuntimeOptions{};
  return describeTaskWithOptions(request, runtime);
}

model DescribeVscRequest {
  vscId?: string(name='VscId', description='The VSC ID.

This parameter is required.', example='vsc-001'),
}

model DescribeVscResponseBody = {
  nodeId?: string(name='NodeId', description='The ID of the compute node in which the VSC resides.', example='e01-cn-kvw44e6dn04'),
  requestId?: string(name='RequestId', description='The request ID.', example='4FD06DF0-9167-5C6F-A145-F30CA4A15D54'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-aek2k3rqlvv6ytq'),
  status?: string(name='Status', description='The VSC status.

Valid values:

*   Creating
*   Normal
*   Deleting', example='Normal'),
  vscId?: string(name='VscId', description='The VSC ID.', example='vsc-001'),
  vscName?: string(name='VscName', description='The custom name of the VSC.', example='test_name'),
  vscType?: string(name='VscType', description='The VSC type.', example='primary'),
}

model DescribeVscResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeVscResponseBody(name='body'),
}

/**
 * @summary Queries information about a virtual storage channel (VSC).
 *
 * @param request DescribeVscRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVscResponse
 */
@context("describeVscWithContext")
async function describeVscWithOptions(request: DescribeVscRequest, runtime: $RuntimeOptions): DescribeVscResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.vscId)) {
    body['VscId'] = request.vscId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeVsc',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries information about a virtual storage channel (VSC).
 *
 * @param request DescribeVscRequest
 * @return DescribeVscResponse
 */
async function describeVsc(request: DescribeVscRequest): DescribeVscResponse {
  var runtime = new $RuntimeOptions{};
  return describeVscWithOptions(request, runtime);
}

model DescribeZonesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The natural language that is used to filter responses. For more information, see RFC 7231. Valid values:

zh-CN en-US Default value: zh-CN.

Valid values:

*   en-US
*   zh-CN', example='zh-CN'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='E9116F2D-82F8-501E-9ADB-2BE0C02B6A84'),
  zones?: [ 
    {
      localName?: string(name='LocalName', description='The zone name.', example='Hang Zhou'),
      zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-i'),
    }
  ](name='Zones', description='The list of zones.'),
}

model DescribeZonesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeZonesResponseBody(name='body'),
}

/**
 * @summary Queries a list of zones.
 *
 * @param request DescribeZonesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeZonesResponse
 */
@context("describeZonesWithContext")
async function describeZonesWithOptions(request: DescribeZonesRequest, runtime: $RuntimeOptions): DescribeZonesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.acceptLanguage)) {
    body['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeZones',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of zones.
 *
 * @param request DescribeZonesRequest
 * @return DescribeZonesResponse
 */
async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  var runtime = new $RuntimeOptions{};
  return describeZonesWithOptions(request, runtime);
}

model ExtendClusterRequest {
  clusterId?: string(name='ClusterId', description='Cluster ID', example='i15b480fbd2fcdbc2869cd80'),
  ignoreFailedNodeTasks?: boolean(name='IgnoreFailedNodeTasks', description='Whether to allow skipping failed node tasks, default value is False', example='False'),
  ipAllocationPolicy?: [ 
    {
      bondPolicy?: {
        bondDefaultSubnet?: string(name='BondDefaultSubnet', description='Default bond cluster subnet', example='subnet-3od2fe'),
        bonds?: [ 
          {
            name?: string(name='Name', description='Bond name', example='Bond0'),
            subnet?: string(name='Subnet', description='IP source cluster subnet', example='subnet-3od2fe'),
          }
        ](name='Bonds', description='Bond information'),
      }(name='BondPolicy', description='Specify the cluster subnet ID based on the bond name'),
      machineTypePolicy?: [ 
        {
          bonds?: [ 
            {
              name?: string(name='Name', description='Bond name', example='Bond0'),
              subnet?: string(name='Subnet', description='IP source cluster subnet', example='subnet-fdo3dv'),
            }
          ](name='Bonds', description='Bond information'),
          machineType?: string(name='MachineType', description='Machine type', example='efg1.nvga1'),
        }
      ](name='MachineTypePolicy', description='Machine type allocation policy'),
      nodePolicy?: [ 
        {
          bonds?: [ 
            {
              name?: string(name='Name', description='Bond name', example='Bond0'),
              subnet?: string(name='Subnet', description='IP source cluster subnet', example='subnet-fdo3dv'),
            }
          ](name='Bonds', description='Bond information'),
          hostname?: string(name='Hostname', description='Hostname', example='a100-xa5dza28-0085'),
          nodeId?: string(name='NodeId', description='Node ID', example='i-3fdodw2'),
        }
      ](name='NodePolicy', description='Node allocation policy'),
    }
  ](name='IpAllocationPolicy', description='IP allocation combination policy: Each policy can only choose one type, and multiple policies can be combined'),
  nodeGroups?: [ 
    {
      amount?: long(name='Amount', description='Number of nodes to purchase. Range: 0~500. If the Amount parameter is set to 0, it means no new nodes will be purchased and existing nodes will be used for scaling. If the Amount parameter is set to 1~500, it means a certain number of nodes will be purchased and used for scaling. Default value: 0', example='4'),
      autoRenew?: boolean(name='AutoRenew', description='Whether to automatically renew the purchased nodes. This parameter takes effect when the Amount parameter is not 0 and the ChargeType is set to PrePaid. Valid values: True (auto-renewal); False (no auto-renewal). Default value: False', example='True'),
      chargeType?: string(name='ChargeType', description='Payment method for the nodes. When the Amount parameter is set to 0, this parameter does not take effect. Valid values: PrePaid (Subscription); PostPaid (Pay-As-You-Go). Default value: PrePaid.', example='PostPaid'),
      hostnames?: [ string ](name='Hostnames', description='Set the hostnames for the purchased nodes. This parameter does not take effect when the Amount parameter is set to 0.'),
      hyperNodes?: [ 
        {
          dataDisk?: [ 
            {
              category?: string(name='Category'),
              deleteWithNode?: boolean(name='DeleteWithNode'),
              performanceLevel?: string(name='PerformanceLevel'),
              size?: int32(name='Size'),
            }
          ](name='DataDisk'),
          hostname?: string(name='Hostname'),
          hyperNodeId?: string(name='HyperNodeId'),
          loginPassword?: string(name='LoginPassword'),
          vSwitchId?: string(name='VSwitchId'),
          vpcId?: string(name='VpcId'),
        }
      ](name='HyperNodes'),
      loginPassword?: string(name='LoginPassword', description='Set the login password for the purchased nodes. This parameter is not effective when the Amount parameter is set to 0.', example='skkO(*89Y'),
      nodeGroupId?: string(name='NodeGroupId', description='Node Group ID', example='i16d4883a46cbadeb4bc9'),
      nodeTag?: [ 
        {
          key?: string(name='Key', description='Node tag key', example='key_my'),
          value?: string(name='Value', description='Node tag value', example='value_my'),
        }
      ](name='NodeTag', description='Node tags'),
      nodes?: [ 
        {
          dataDisk?: [ 
            {
              category?: string(name='Category', description='Type', example='cloud_essd'),
              deleteWithNode?: boolean(name='DeleteWithNode', description='Whether the data disk is deleted with the node', example='true'),
              performanceLevel?: string(name='PerformanceLevel', description='Data Disk Performance Level', example='PL0'),
              size?: int32(name='Size', description='Disk Size', example='80'),
            }
          ](name='DataDisk', description='Data Disk Specifications'),
          hostname?: string(name='Hostname', description='Hostname', example='d044d220-33fd-11ed-86a6'),
          loginPassword?: string(name='LoginPassword', description='Login Password', example='***'),
          nodeId?: string(name='NodeId', description='Node ID', example='e01-cn-zvp2zdpy601'),
          vSwitchId?: string(name='VSwitchId', description='VSwitch ID', example='vsw-bp169pi5fj151rrms4sia'),
          vpcId?: string(name='VpcId', description='VPC ID', example='vpc-0jlasms92fdxqd3wlf8ny'),
        }
      ](name='Nodes', description='List of Nodes'),
      period?: long(name='Period', description='Duration of the node purchase (in months). Valid values: 1, 6, 12, 24, 36, 48. This parameter takes effect when the Amount parameter is not 0 and the ChargeType is set to PrePaid.', example='6'),
      userData?: string(name='UserData', description='Custom Data', example='#!/bin/sh
echo "Hello World. The time is now $(date -R)!" | tee /root/userdata_test.txt'),
      vSwitchId?: string(name='VSwitchId', description='VSwitch ID', example='vsw-uf65m8xqjgy55xj9jw92n'),
      vpcId?: string(name='VpcId', description='VPC ID', example='vpc-0jl3b0c0ukydlfezr13n6'),
      zoneId?: string(name='ZoneId', description='Zone ID', example='cn-hangzhou-i'),
    }
  ](name='NodeGroups', description='Node Groups'),
  vSwitchZoneId?: string(name='VSwitchZoneId', description='VSwitch availability zone ID', example='cn-shanghai-b'),
  vpdSubnets?: [ string ](name='VpdSubnets', description='List of cluster subnets'),
}

model ExtendClusterShrinkRequest {
  clusterId?: string(name='ClusterId', description='Cluster ID', example='i15b480fbd2fcdbc2869cd80'),
  ignoreFailedNodeTasks?: boolean(name='IgnoreFailedNodeTasks', description='Whether to allow skipping failed node tasks, default value is False', example='False'),
  ipAllocationPolicyShrink?: string(name='IpAllocationPolicy', description='IP allocation combination policy: Each policy can only choose one type, and multiple policies can be combined'),
  nodeGroupsShrink?: string(name='NodeGroups', description='Node Groups'),
  vSwitchZoneId?: string(name='VSwitchZoneId', description='VSwitch availability zone ID', example='cn-shanghai-b'),
  vpdSubnetsShrink?: string(name='VpdSubnets', description='List of cluster subnets'),
}

model ExtendClusterResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='03668372-18FF-5959-98D9-6B36A4643C7A'),
  taskId?: string(name='TaskId', description='Task ID', example='i158475611663639202234'),
}

model ExtendClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExtendClusterResponseBody(name='body'),
}

/**
 * @summary Cluster Scaling
 *
 * @param tmpReq ExtendClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExtendClusterResponse
 */
@context("extendClusterWithContext")
async function extendClusterWithOptions(tmpReq: ExtendClusterRequest, runtime: $RuntimeOptions): ExtendClusterResponse {
  tmpReq.validate();
  var request = new ExtendClusterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.ipAllocationPolicy)) {
    request.ipAllocationPolicyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ipAllocationPolicy, 'IpAllocationPolicy', 'json');
  }
  if (!$isNull(tmpReq.nodeGroups)) {
    request.nodeGroupsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.nodeGroups, 'NodeGroups', 'json');
  }
  if (!$isNull(tmpReq.vpdSubnets)) {
    request.vpdSubnetsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.vpdSubnets, 'VpdSubnets', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.ignoreFailedNodeTasks)) {
    body['IgnoreFailedNodeTasks'] = request.ignoreFailedNodeTasks;
  }
  if (!$isNull(request.ipAllocationPolicyShrink)) {
    body['IpAllocationPolicy'] = request.ipAllocationPolicyShrink;
  }
  if (!$isNull(request.nodeGroupsShrink)) {
    body['NodeGroups'] = request.nodeGroupsShrink;
  }
  if (!$isNull(request.vSwitchZoneId)) {
    body['VSwitchZoneId'] = request.vSwitchZoneId;
  }
  if (!$isNull(request.vpdSubnetsShrink)) {
    body['VpdSubnets'] = request.vpdSubnetsShrink;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ExtendCluster',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Cluster Scaling
 *
 * @param request ExtendClusterRequest
 * @return ExtendClusterResponse
 */
async function extendCluster(request: ExtendClusterRequest): ExtendClusterResponse {
  var runtime = new $RuntimeOptions{};
  return extendClusterWithOptions(request, runtime);
}

model ListClusterNodesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='i15b480fbd2fcdbc2869cd80'),
  maxResults?: long(name='MaxResults', description='The number of entries per page. Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='The token that determines the start position of the query. Set this parameter to the value of the NextToken parameter that is returned from the last call.', example='AAAAAdQ3Z+oPlg49gsr2y8jb6wY='),
  nodeGroupId?: string(name='NodeGroupId', description='The node group ID.', example='ng-ec3c96ff0aa4c60d'),
  operatingStates?: [ string ](name='OperatingStates'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-xxkxkllss'),
  tags?: [ 
    {
      key?: string(name='Key', description='The tag key for the node.', example='aa_key'),
      value?: string(name='Value', description='The tag value for the node.', example='aa_value'),
    }
  ](name='Tags', description='The tags.'),
}

model ListClusterNodesResponseBody = {
  nextToken?: string(name='NextToken', description='The returned pagination token which can be used in the next request to retrieve a new page of results.', example='AAAAAXW/ZB9TBvH+0ZK0phtCibQgQmu1RbqplAI6Velo2OKR'),
  nodes?: [ 
    {
      commodityCode?: string(name='CommodityCode', description='The commodity code.', example='bcccluster'),
      createTime?: string(name='CreateTime', description='The creation time.', example='1642472468000'),
      expiredTime?: string(name='ExpiredTime', description='The time when the node expires.', example='1762185600000'),
      fileSystemMountEnabled?: boolean(name='FileSystemMountEnabled', description='Indicates whether file storage mounting is supported.', example='False'),
      hostname?: string(name='Hostname', description='The hostname.', example='72432f80-273e-11ed-b57a-acde48001122'),
      hpnZone?: string(name='HpnZone', description='The cluster number.', example='A1'),
      imageId?: string(name='ImageId', description='The system image ID.', example='i190297201669099844192'),
      imageName?: string(name='ImageName', description='The image name.', example='Alinux3_x86_AMD_R_Host_D3_E3_24.13.00_UEFI_N_250121'),
      machineType?: string(name='MachineType', description='The node type.', example='cn-wulanchabu-b11'),
      networks?: [ 
        {
          bondName?: string(name='BondName', description='The name of the network port for the node.', example='bond0'),
          ip?: string(name='Ip', description='The IP address of the node in the virtual private cloud (VPC).', example='192.168.22.2'),
          subnetId?: string(name='SubnetId', description='The subnet ID.', example='subnet-fwekrvg9'),
          vpdId?: string(name='VpdId', description='The VPC ID.', example='vpd-eoiy88ju'),
        }
      ](name='Networks', description='The network information.'),
      nodeGroupId?: string(name='NodeGroupId', description='The node group ID.', example='ng-e9b74f4d450cf18d'),
      nodeGroupName?: string(name='NodeGroupName', description='The node group name.', example='emr_master'),
      nodeId?: string(name='NodeId', description='The node ID.', example='e01-cn-2r42tmj4z02'),
      operatingState?: string(name='OperatingState', description='The node status.

Valid values:

*   Extending
*   UnusedNodeStopped
*   UnusedNodeStopping
*   Unused
*   Using
*   ReleaseLocking
*   Operating
*   Cutting
*   ClusterNodeStopped
*   UnusedNodeRecovering
*   ClusterNodeStopping
*   ClusterNodeRecovering
*   Replacing', example='Extending'),
      sn?: string(name='Sn', description='The serial number of the node.', example='sn_tOuUk'),
      tags?: [ 
        {
          key?: string(name='Key', description='The tag key.', example='aa_key'),
          value?: string(name='Value', description='The tag value.', example='aa_value'),
        }
      ](name='Tags', description='The tags.'),
      taskId?: string(name='TaskId', description='The job ID.', example='i28ddkdkkdkdd'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-bp1mxqhw8o20tgv3xk47h'),
      vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-0jltf9vinjz3if3lltdy7'),
      zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-b'),
    }
  ](name='Nodes', description='The nodes.'),
  requestId?: string(name='RequestId', description='The request ID.', example='2BA76272-6608-5AEC-BBA8-B6F0D3D14CDB'),
}

model ListClusterNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClusterNodesResponseBody(name='body'),
}

/**
 * @summary Queries a list of nodes in a cluster.
 *
 * @param request ListClusterNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClusterNodesResponse
 */
@context("listClusterNodesWithContext")
async function listClusterNodesWithOptions(request: ListClusterNodesRequest, runtime: $RuntimeOptions): ListClusterNodesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.tags)) {
    query['Tags'] = request.tags;
  }
  var body : map[string]any = {};
  if (!$isNull(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.nodeGroupId)) {
    body['NodeGroupId'] = request.nodeGroupId;
  }
  if (!$isNull(request.operatingStates)) {
    body['OperatingStates'] = request.operatingStates;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListClusterNodes',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of nodes in a cluster.
 *
 * @param request ListClusterNodesRequest
 * @return ListClusterNodesResponse
 */
async function listClusterNodes(request: ListClusterNodesRequest): ListClusterNodesResponse {
  var runtime = new $RuntimeOptions{};
  return listClusterNodesWithOptions(request, runtime);
}

model ListClustersRequest {
  maxResults?: long(name='MaxResults', description='The number of entries per page. Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='The token that determines the start position of the query. Set this parameter to the value of the NextToken parameter that is returned from the last call.', example='a3f2224a5ec7224116c4f5246120abe4'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-aek2bg6wyoox6jq'),
  tags?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='key_aa'),
      value?: string(name='Value', description='The tag value.', example='value_aa'),
    }
  ](name='Tags', description='The tags.'),
}

model ListClustersResponseBody = {
  clusters?: [ 
    {
      clusterDescription?: string(name='ClusterDescription', description='The cluster description.', example='PPU-cluster2 bz'),
      clusterId?: string(name='ClusterId', description='The cluster ID.', example='i137590131672134915401'),
      clusterName?: string(name='ClusterName', description='The cluster name.', example='cnp_test_cluster'),
      clusterType?: string(name='ClusterType', description='The cluster type.

Valid values:

*   AckEdgePro
*   ExclusiveBareCluster
*   Lite', example='AckEdgePro'),
      components?: any(name='Components', description='The component information.', example='{}'),
      computingIpVersion?: string(name='ComputingIpVersion', description='The IP type of the computing network.', example='IPv4'),
      createTime?: string(name='CreateTime', description='The creation time.', example='1672134938'),
      hpnZone?: string(name='HpnZone', description='The cluster number.', example='B1'),
      nodeCount?: long(name='NodeCount', description='The number of nodes.', example='12'),
      nodeGroupCount?: long(name='NodeGroupCount', description='The number of node groups.', example='2'),
      operatingState?: string(name='OperatingState', description='The cluster status.

Valid values:

*   running
*   expanding
*   shrinking
*   initializing', example='initializing'),
      resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-aek2ajbjoloa23q'),
      tags?: [ 
        {
          key?: string(name='Key', description='The tag key.', example='aa_key'),
          value?: string(name='Value', description='The tag value.', example='aa_value'),
        }
      ](name='Tags', description='The tags.'),
      taskId?: string(name='TaskId', description='The job ID.', example='i156365121663149566024'),
      updateTime?: string(name='UpdateTime', description='The update time.', example='1672134968'),
      vpcId?: string(name='VpcId', description='The virtual private cloud (VPC) ID.', example='vpc-0jlx4hol2bjboafzmffvd'),
    }
  ](name='Clusters', description='The clusters.'),
  nextToken?: string(name='NextToken', description='The returned pagination token which can be used in the next request to retrieve a new page of results.', example='f4f9a292c17072a2'),
  requestId?: string(name='RequestId', description='The request ID.', example='2FE2B22C-CF9D-59DE-BF63-DC9B9B33A9D1'),
}

model ListClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClustersResponseBody(name='body'),
}

/**
 * @summary Queries a list of clusters.
 *
 * @param request ListClustersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClustersResponse
 */
@context("listClustersWithContext")
async function listClustersWithOptions(request: ListClustersRequest, runtime: $RuntimeOptions): ListClustersResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.tags)) {
    query['Tags'] = request.tags;
  }
  var body : map[string]any = {};
  if (!$isNull(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListClusters',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of clusters.
 *
 * @param request ListClustersRequest
 * @return ListClustersResponse
 */
async function listClusters(request: ListClustersRequest): ListClustersResponse {
  var runtime = new $RuntimeOptions{};
  return listClustersWithOptions(request, runtime);
}

model ListDiagnosticResultsRequest {
  diagType?: string(name='DiagType', description='Type of diagnosis, indicating which diagnostic rules are hit.', example='NetDiag'),
  maxResults?: long(name='MaxResults', description='Number of items per page in a paginated query. The maximum value is 100.

Default value:

- If no value is set or the set value is less than 20, the default value is 20.
- If the set value is greater than 100, the default value is 100.', example='20'),
  nextToken?: string(name='NextToken', description='NextToken for the next page. Include this value when requesting the next page.', example='a3f2224a5ec7224116c4f5246120abe4'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-acfmywpvugkh7kq'),
}

model ListDiagnosticResultsResponseBody = {
  diagnosticResults?: [ 
    {
      clusterId?: string(name='ClusterId', description='The cluster ID.', example='i118578141694745246055'),
      clusterName?: string(name='ClusterName', description='Cluster Name', example='pjlab-lingjun'),
      creationTime?: string(name='CreationTime', description='Creation time of the diagnostic task.', example='2024-01-15T02:01:12Z'),
      diagContent?: string(name='DiagContent', description='Diagnostic content. For example, in network diagnostics, there are static configuration checks, dynamic operation checks, and other diagnostic contents.', example='diagcontent'),
      diagId?: string(name='DiagId', description='Diagnosis ID', example='123'),
      diagResult?: string(name='DiagResult', description='Diagnostic result, either success or failure.', example='Success'),
      finishedTime?: string(name='FinishedTime', description='Completion time of the diagnostic task.', example='2024-10-16T02:04Z'),
      resourceId?: string(name='ResourceId', description='The resource ID.', example='e01-cn-bl03ofg6206'),
      serverName?: string(name='ServerName', description='Server name.', example='proxy-rps.mos.csvw.com'),
      status?: string(name='Status', description='Status of the diagnostic task. Possible values:
- InProgress: Diagnosing.
- Finished: Diagnosis completed.
- Failed: Diagnosis failed.', example='succeed'),
    }
  ](name='DiagnosticResults', description='The diagnostic information.'),
  maxResults?: long(name='MaxResults', description='Number of items per page in a paginated query. The maximum value is 100.

Default value:

- If no value is set or the set value is less than 20, the default value is 20.
- If the set value is greater than 100, the default value is 100.', example='20'),
  nextToken?: string(name='NextToken', description='NextToken for the next page. Include this value when requesting the next page.', example='a3f2224a5ec7224116c4f5246120abe4'),
  requestId?: string(name='RequestId', description='The request ID.', example='AC4F0004-7BCE-52E0-891B-CAC7D64E3368'),
}

model ListDiagnosticResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDiagnosticResultsResponseBody(name='body'),
}

/**
 * @summary List of Diagnostic Tasks
 *
 * @param request ListDiagnosticResultsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDiagnosticResultsResponse
 */
@context("listDiagnosticResultsWithContext")
async function listDiagnosticResultsWithOptions(request: ListDiagnosticResultsRequest, runtime: $RuntimeOptions): ListDiagnosticResultsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.diagType)) {
    body['DiagType'] = request.diagType;
  }
  if (!$isNull(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListDiagnosticResults',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary List of Diagnostic Tasks
 *
 * @param request ListDiagnosticResultsRequest
 * @return ListDiagnosticResultsResponse
 */
async function listDiagnosticResults(request: ListDiagnosticResultsRequest): ListDiagnosticResultsResponse {
  var runtime = new $RuntimeOptions{};
  return listDiagnosticResultsWithOptions(request, runtime);
}

model ListFreeNodesRequest {
  hpnZone?: string(name='HpnZone', description='The cluster number.', example='A1'),
  machineType?: string(name='MachineType', description='The instance type.', example='mock-machine-type2'),
  maxResults?: long(name='MaxResults', description='The number of entries per page. Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='The token that determines the start position of the query. Set this parameter to the value of the NextToken parameter that is returned from the last call.', example='a3f2224a5ec7224116c4f5246120abe4'),
  operatingStates?: [ string ](name='OperatingStates', description='The types of the returned nodes that are not used.'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-acfmxno4vh5muoq'),
  tags?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='key_aa'),
      value?: string(name='Value', description='The tag value.', example='value_aa'),
    }
  ](name='Tags', description='The tags.'),
}

model ListFreeNodesResponseBody = {
  nextToken?: string(name='NextToken', description='The returned pagination token which can be used in the next request to retrieve a new page of results.', example='a3f2224a5ec7224116c4f5246120abe4'),
  nodes?: [ 
    {
      commodityCode?: string(name='CommodityCode', description='The commodity code.', example='bccluster_eflocomputing_public_cn'),
      createTime?: string(name='CreateTime', description='The creation time.', example='1652321554'),
      expiredTime?: string(name='ExpiredTime', description='The time when the node expires.', example='1673107200'),
      hpnZone?: string(name='HpnZone', description='The cluster number.', example='A1'),
      machineType?: string(name='MachineType', description='The instance type.', example='efg1.nvga1'),
      nodeId?: string(name='NodeId', description='The node ID.', example='e01-cn-7pp2x193801'),
      operatingState?: string(name='OperatingState', description='The node status.', example='Unused'),
      resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-aekzkkbrpl4owgy'),
      sn?: string(name='Sn', description='The serial number of the node.', example='sn_pozkHBgicd'),
      tags?: [ 
        {
          key?: string(name='Key', description='The tag key.', example='aa_key'),
          value?: string(name='Value', description='The tag value.', example='aa_vakye'),
        }
      ](name='Tags', description='The tags.'),
      zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-j'),
    }
  ](name='Nodes', description='The nodes.'),
  requestId?: string(name='RequestId', description='The request ID.', example='AA14CB86-70C4-5CB7-9E7B-6CCA77F3512B'),
}

model ListFreeNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFreeNodesResponseBody(name='body'),
}

/**
 * @summary Queries a list of nodes that are not used.
 *
 * @param request ListFreeNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFreeNodesResponse
 */
@context("listFreeNodesWithContext")
async function listFreeNodesWithOptions(request: ListFreeNodesRequest, runtime: $RuntimeOptions): ListFreeNodesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.tags)) {
    query['Tags'] = request.tags;
  }
  var body : map[string]any = {};
  if (!$isNull(request.hpnZone)) {
    body['HpnZone'] = request.hpnZone;
  }
  if (!$isNull(request.machineType)) {
    body['MachineType'] = request.machineType;
  }
  if (!$isNull(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.operatingStates)) {
    body['OperatingStates'] = request.operatingStates;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListFreeNodes',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of nodes that are not used.
 *
 * @param request ListFreeNodesRequest
 * @return ListFreeNodesResponse
 */
async function listFreeNodes(request: ListFreeNodesRequest): ListFreeNodesResponse {
  var runtime = new $RuntimeOptions{};
  return listFreeNodesWithOptions(request, runtime);
}

model ListImagesRequest {
  architecture?: string(name='Architecture', description='The architecture.', example='x86_64'),
  imageVersion?: string(name='ImageVersion', description='The image version.', example='7.9'),
  platform?: string(name='Platform', description='The platform.', example='ALinux3'),
}

model ListImagesResponseBody = {
  images?: [ 
    {
      architecture?: string(name='Architecture', description='The architecture.', example='x86_64'),
      description?: string(name='Description', description='The description.', example='alibaba cloud linux 3 full for H800'),
      imageId?: string(name='ImageId', description='The image ID.', example='i190951671671438639388'),
      imageName?: string(name='ImageName', description='The image name.', example='CentOS_7.9_x86_64_FULL_20221110'),
      imageVersion?: string(name='ImageVersion', description='The image version.', example='7.9'),
      nodeCount?: long(name='NodeCount', description='The number of nodes.', example='20'),
      platform?: string(name='Platform', description='The platform.', example='ALinux3'),
      releaseFileMd5?: string(name='ReleaseFileMd5', description='The MD5 hash value of the file.', example='40741292480fc6d778138adcf8c'),
      releaseFileSize?: string(name='ReleaseFileSize', description='The image size.', example='5.8G'),
      type?: string(name='Type', description='The image type.', example='Public'),
    }
  ](name='Images', description='The image details.'),
  nextToken?: string(name='NextToken', description='The token that is used in the next request to retrieve a new page of results.', example='3a6b93229825ac667104463b56790c91'),
  requestId?: string(name='RequestId', description='Id of the request', example='0FC4A1C7-421C-5EAB-9361-4C0338EFA287'),
}

model ListImagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListImagesResponseBody(name='body'),
}

/**
 * @summary Lists available images.
 *
 * @param request ListImagesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListImagesResponse
 */
@context("listImagesWithContext")
async function listImagesWithOptions(request: ListImagesRequest, runtime: $RuntimeOptions): ListImagesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.architecture)) {
    body['Architecture'] = request.architecture;
  }
  if (!$isNull(request.imageVersion)) {
    body['ImageVersion'] = request.imageVersion;
  }
  if (!$isNull(request.platform)) {
    body['Platform'] = request.platform;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListImages',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Lists available images.
 *
 * @param request ListImagesRequest
 * @return ListImagesResponse
 */
async function listImages(request: ListImagesRequest): ListImagesResponse {
  var runtime = new $RuntimeOptions{};
  return listImagesWithOptions(request, runtime);
}

model ListMachineNetworkInfoRequest {
  machineHpnInfo?: [ 
    {
      hpnZone?: string(name='HpnZone', description='hpn zone infomation', example='C1'),
      machineType?: string(name='MachineType', description='The type of machine.', example='efg2.C48cNHmcn'),
      regionId?: string(name='RegionId', description='The ID of the region in which the application is located.', example='cn-heyuan'),
    }
  ](name='MachineHpnInfo', description='hpn information of machine'),
}

model ListMachineNetworkInfoShrinkRequest {
  machineHpnInfoShrink?: string(name='MachineHpnInfo', description='hpn information of machine'),
}

model ListMachineNetworkInfoResponseBody = {
  machineNetworkInfo?: [ 
    {
      clusterNet?: string(name='ClusterNet', description='Network of cluster', example='vpc/acl'),
      enableJumboFrame?: boolean(name='EnableJumboFrame', description='Specifies whether to enable the Jumbo Frames feature for the instance. Valid values:

*   true: The Jumbo Frame feature is enabled for the instance.
*   false: The Jumbo Frame feature is disabled for the instance.

Take note of the following items:

*   The instance must be in the Running (`Running`) or Stopped (`Stopped`) state.
*   The instance must reside in a VPC.
*   After the Jumbo Frames feature is enabled, the MTU value of the instance is set to 8500. After the Jumbo Frames feature is disabled, the MTU value of the instance is set to 1500. You can enable the Jumbo Frames feature only for specific instance types. For more information, see [Jumbo Frames](https://help.aliyun.com/document_detail/200512.html).', example='true'),
      hpnZone?: string(name='HpnZone', description='HPN zone', example='B1'),
      isDpuMode?: boolean(name='IsDpuMode', description='Specifies whether dpu machine.', example='true'),
      machineType?: string(name='MachineType', description='The type of machine.', example='efg1.nvga8n'),
      netArch?: string(name='NetArch', description='Network architecture', example='XX-7.0'),
      regionId?: string(name='RegionId', description='The ID of the region in which the application is located.', example='cn-heyuan'),
    }
  ](name='MachineNetworkInfo', description='machine network infomation'),
  requestId?: string(name='RequestId', description='Id of the request', example='4FD06DF0-9167-5C6F-A145-F30CA4A15D54'),
}

model ListMachineNetworkInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMachineNetworkInfoResponseBody(name='body'),
}

/**
 * @summary Query machine network configuration using HPNZone and machine type
 *
 * @param tmpReq ListMachineNetworkInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMachineNetworkInfoResponse
 */
@context("listMachineNetworkInfoWithContext")
async function listMachineNetworkInfoWithOptions(tmpReq: ListMachineNetworkInfoRequest, runtime: $RuntimeOptions): ListMachineNetworkInfoResponse {
  tmpReq.validate();
  var request = new ListMachineNetworkInfoShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.machineHpnInfo)) {
    request.machineHpnInfoShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.machineHpnInfo, 'MachineHpnInfo', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.machineHpnInfoShrink)) {
    body['MachineHpnInfo'] = request.machineHpnInfoShrink;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMachineNetworkInfo',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Query machine network configuration using HPNZone and machine type
 *
 * @param request ListMachineNetworkInfoRequest
 * @return ListMachineNetworkInfoResponse
 */
async function listMachineNetworkInfo(request: ListMachineNetworkInfoRequest): ListMachineNetworkInfoResponse {
  var runtime = new $RuntimeOptions{};
  return listMachineNetworkInfoWithOptions(request, runtime);
}

model ListMachineTypesRequest {
  name?: string(name='Name', description='The name of the instance type.', example='efg1.nvga1'),
}

model ListMachineTypesResponseBody = {
  machineTypes?: [ 
    {
      bondNum?: int32(name='BondNum', description='The number of bonds.', example='2'),
      cpuInfo?: string(name='CpuInfo', description='The CPU information.', example='2x Intel Icelake 8369B 32C CPU'),
      diskInfo?: string(name='DiskInfo', description='The disk information.', example='2x 480GB SATA SSD'),
      gpuInfo?: string(name='GpuInfo', description='The GPU information.', example='8x NVIDIA SXM4 80GB A100 GPU'),
      memoryInfo?: string(name='MemoryInfo', description='The storage information.', example='32x 64GB DDR4 3200 Memory'),
      name?: string(name='Name', description='The name of the instance type.', example='efg1.nvga1'),
      networkInfo?: string(name='NetworkInfo', description='The network information.', example='2x 100Gbps DP NIC'),
      nodeCount?: string(name='NodeCount', description='The number of nodes.', example='10'),
      totalCpuCore?: int32(name='TotalCpuCore', description='The number of vCPUs.', example='48'),
      type?: string(name='Type', description='The access type.', example='Public'),
    }
  ](name='MachineTypes', description='The instance types.'),
  nextToken?: string(name='NextToken', description='The token that is used in the next request to retrieve a new page of results.', example='a3f2224a5ec7224116c4f5246120abe4'),
  requestId?: string(name='RequestId', description='The request ID.', example='F16BA4D8-FF50-53B6-A026-F443FE31006C'),
}

model ListMachineTypesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMachineTypesResponseBody(name='body'),
}

/**
 * @summary Queries a list of instance types that are available to users.
 *
 * @param request ListMachineTypesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMachineTypesResponse
 */
@context("listMachineTypesWithContext")
async function listMachineTypesWithOptions(request: ListMachineTypesRequest, runtime: $RuntimeOptions): ListMachineTypesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMachineTypes',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of instance types that are available to users.
 *
 * @param request ListMachineTypesRequest
 * @return ListMachineTypesResponse
 */
async function listMachineTypes(request: ListMachineTypesRequest): ListMachineTypesResponse {
  var runtime = new $RuntimeOptions{};
  return listMachineTypesWithOptions(request, runtime);
}

model ListNetTestResultsRequest {
  maxResults?: long(name='MaxResults', description='The number of entries to return on each page. Maximum value: 100.

Default value:

*   If you do not configure this parameter or if you set this parameter to a value less than 20, the default value is 20.
*   If you set this parameter to a value that is greater than 100, the default value is 100.', example='20'),
  netTestType?: string(name='NetTestType', description='The type of the network test.', example='DelayTest'),
  nextToken?: string(name='NextToken', description='The token that determines the start position of the query. Set this parameter to the value of the NextToken parameter that is returned from the last call.', example='3a6b93229825ac667104463b56790c91'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-acfmxno4vh5muoq'),
}

model ListNetTestResultsResponseBody = {
  maxResults?: long(name='MaxResults', description='The number of entries to return on each page. Maximum value: 100.

Default value:

*   If you do not configure this parameter or if you set this parameter to a value less than 20, the default value is 20.
*   If you set this parameter to a value that is greater than 100, the default value is 100.', example='20'),
  netTestResults?: [ 
    {
      clusterId?: string(name='ClusterId', description='The cluster ID.', example='i110667211718265012218'),
      clusterName?: string(name='ClusterName', description='The cluster name.', example='test'),
      commTest?: {
        GPUNum?: string(name='GPUNum', description='The number of GPUs.', example='4'),
        hosts?: [ 
          {
            IP?: string(name='IP', description='The IP address of the node.', example='10.51.16.21'),
            resourceId?: string(name='ResourceId', description='The resource ID.', example='e01-cn-wwo3eteze19'),
            serverName?: string(name='ServerName', description='The name of the service.', example='www.xinjiaoyu.com'),
          }
        ](name='Hosts', description='The hosts of the test node.'),
        model?: string(name='Model', description='The communication library model.', example='AllToAll'),
        type?: string(name='Type', description='The CommTest type, which can be ACCL or NCCL.', example='ACCL'),
      }(name='CommTest', description='Returned when NetTestType is CommTest.'),
      creationTime?: string(name='CreationTime', description='The creation time.', example='2024-01-19T02:18:12Z'),
      delayTest?: {
        hosts?: [ 
          {
            bond?: string(name='Bond', description='The bonding of network interface card.', example='bond1'),
            IP?: string(name='IP', description='The IP address of the node.', example='pgm-bp174z988a27wre71o.pg.rds.aliyuncs.com'),
            resourceId?: string(name='ResourceId', description='The resource ID.', example='e01-cn-wwo3eteze19'),
            serverName?: string(name='ServerName', description='The name of the service.', example='WrF'),
          }
        ](name='Hosts', description='The hosts.'),
      }(name='DelayTest', description='Returned when NetTestType is DelayTest.'),
      finishedTime?: string(name='FinishedTime', description='The finish time.', example='2024-10-30T02:07Z'),
      netTestType?: string(name='NetTestType', description='The type of the network test.', example='NetDiag'),
      networkMode?: string(name='NetworkMode', description='The network mode.', example='01'),
      port?: string(name='Port', description='The port number.', example='80'),
      status?: string(name='Status', description='The status of the network test task. Valid values:\\\\
● InProgress\\\\
● Finished\\\\
● Failed', example='InProgress'),
      testId?: string(name='TestId', description='The test ID. The unique identifier of the resource test task.', example='String	i-uf6i0tv2refv8wz*****'),
      trafficTest?: {
        clients?: [ 
          {
            bond?: string(name='Bond', description='The bonding of network interface card.', example='bond1'),
            IP?: string(name='IP', description='The IP address.', example='74.73.100.1'),
            resourceId?: string(name='ResourceId', description='The resource ID.', example='e01-cn-20p36bqet39'),
            serverName?: string(name='ServerName', description='The name of the service.', example='prod-gf-cn.juequling.com'),
          }
        ](name='Clients', description='The clients.'),
        duration?: long(name='Duration', description='The running duration of the pipeline job. Unit: seconds.', example='1'),
        GDR?: string(name='GDR', description='If the protocol is RDMA, can be True or False. If the protocol is TCP, this field is empty.', example='True'),
        protocol?: string(name='Protocol', description='The network protocol, which can be RDMA or TCP.', example='TCP'),
        QP?: long(name='QP', description='If the protocol is TCP, the number of concurrent connections. If the protocol is RDMA, the configured QP value.', example='RDMA'),
        servers?: [ 
          {
            bond?: string(name='Bond', description='The bonding of network interface card.', example='bond1'),
            IP?: string(name='IP', description='The IP address of the node.', example='10.1.168.183'),
            resourceId?: string(name='ResourceId', description='The resource ID.', example='e01-cn-wwo3eteze19'),
            serverName?: string(name='ServerName', description='The name of the service.', example='prod-gf-cn.juequling.com'),
          }
        ](name='Servers', description='If the TrafficModel is Fullmesh, this parameter is empty.'),
        trafficModel?: string(name='TrafficModel', description='The traffic model, which can be MTON or Fullmesh.', example='Fullmesh'),
      }(name='TrafficTest', description='Returned when NetTestType is TrafficTest.'),
    }
  ](name='NetTestResults', description='The results.'),
  nextToken?: string(name='NextToken', description='The token that is used in the next request to retrieve a new page of results.', example='3a6b93229825ac667104463b56790c91'),
  requestId?: string(name='RequestId', description='The request ID.', example='3C683243-7915-57FB-9570-A2932C1C0F78'),
}

model ListNetTestResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListNetTestResultsResponseBody(name='body'),
}

/**
 * @summary Lists the results of network test results.
 *
 * @description The API creates a session, returns the frontend endpoint, and starts a periodic task to track the session status.
 *
 * @param request ListNetTestResultsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListNetTestResultsResponse
 */
@context("listNetTestResultsWithContext")
async function listNetTestResultsWithOptions(request: ListNetTestResultsRequest, runtime: $RuntimeOptions): ListNetTestResultsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.netTestType)) {
    body['NetTestType'] = request.netTestType;
  }
  if (!$isNull(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListNetTestResults',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Lists the results of network test results.
 *
 * @description The API creates a session, returns the frontend endpoint, and starts a periodic task to track the session status.
 *
 * @param request ListNetTestResultsRequest
 * @return ListNetTestResultsResponse
 */
async function listNetTestResults(request: ListNetTestResultsRequest): ListNetTestResultsResponse {
  var runtime = new $RuntimeOptions{};
  return listNetTestResultsWithOptions(request, runtime);
}

model ListNodeGroupsRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='i119982311660892626523'),
  maxResults?: int32(name='MaxResults', description='The number of entries per page. Maximum value: 100.

Default value:

• If you do not configure this parameter or if you set this parameter to a value less than 20, the default value is 20.

• If you set this parameter to a value greater than 100, the default value is 100.', example='20'),
  nextToken?: string(name='NextToken', description='The token that is used in the next request to retrieve a new page of results.', example='a3f2224a5ec7224116c4f5246120abe4'),
  nodeGroupId?: string(name='NodeGroupId', description='The node group ID.', example='ng-ec3c96ff0aa4c60d'),
}

model ListNodeGroupsResponseBody = {
  groups?: [ 
    {
      clusterId?: string(name='ClusterId', description='The cluster ID.', example='i113952461729854708648'),
      clusterName?: string(name='ClusterName', description='The cluster name.', example='wzq-exclusivelite-71'),
      createTime?: string(name='CreateTime', description='The creation time.', example='2024-02-27T13:16:31.599'),
      description?: string(name='Description', description='The description.', example='created by ga2_prepare'),
      fileSystemMountEnabled?: boolean(name='FileSystemMountEnabled', description='Indicates whether file storage mounting is supported.', example='False'),
      groupId?: string(name='GroupId', description='The group ID.', example='238276221'),
      groupName?: string(name='GroupName', description='The group name.', example='backend-group'),
      imageId?: string(name='ImageId', description='The image ID.', example='i194015071707321240258'),
      imageName?: string(name='ImageName', description='The image name.', example='CentOS_7.9_x86_64_FULL_20221110'),
      machineType?: string(name='MachineType', description='The instance type.', example='efg1.nvga1n'),
      nodeCount?: long(name='NodeCount', description='The number of nodes.', example='2'),
      updateTime?: string(name='UpdateTime', description='The update time.', example='2023-09-22T00:03:05.114'),
      virtualGpuEnabled?: boolean(name='VirtualGpuEnabled', description='Whether to enable gpu virtualization or not', example='false'),
      zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-shenzhen-c'),
    }
  ](name='Groups', description='The node groups.'),
  nextToken?: string(name='NextToken', description='The token that is used in the next request to retrieve a new page of results.', example='563d42ae0b17572449ec8c97f7f66069'),
  requestId?: string(name='RequestId', description='The request ID.', example='887FA855-89F4-5DB3-B305-C5879EC480E6'),
}

model ListNodeGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListNodeGroupsResponseBody(name='body'),
}

/**
 * @summary Queries node groups in a cluster.
 *
 * @param request ListNodeGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListNodeGroupsResponse
 */
@context("listNodeGroupsWithContext")
async function listNodeGroupsWithOptions(request: ListNodeGroupsRequest, runtime: $RuntimeOptions): ListNodeGroupsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.nodeGroupId)) {
    body['NodeGroupId'] = request.nodeGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListNodeGroups',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries node groups in a cluster.
 *
 * @param request ListNodeGroupsRequest
 * @return ListNodeGroupsResponse
 */
async function listNodeGroups(request: ListNodeGroupsRequest): ListNodeGroupsResponse {
  var runtime = new $RuntimeOptions{};
  return listNodeGroupsWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', description='The token that determines the start position of the query. Set this parameter to the value of the NextToken parameter that is returned from the last call.', example='AAAAAdQ3Z+oPlg49gsr2y8jb6wY='),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The IDs of the resources.'),
  resourceType?: string(name='ResourceType', description='The resource type.

Valid values:

*   Node
*   Vcc
*   Cluster
*   Subnet
*   Vpd

This parameter is required.', example='Node'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='PodName'),
      value?: string(name='Value', description='The tag value.', example='WFT-OTC'),
    }
  ](name='Tag', description='The tags.'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='The token that is used in the next request to retrieve a new page of results.', example='AAAAAdQ3Z+oPlg49gsr2y8jb6wY='),
  requestId?: string(name='RequestId', description='The request ID.', example='8F208B6D-4C42-5FD3-B6BE-E826E92A44DD'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId', description='The resource ID.', example='i15azeddnvf7uhw2oij57o0'),
      resourceType?: string(name='ResourceType', description='The resource type.

Valid values:

*   Node
*   Cluster', example='Cluster'),
      tagKey?: string(name='TagKey', description='The tag key.', example='env'),
      tagValue?: string(name='TagValue', description='The tag value.', example='dev'),
    }
  ](name='TagResource')
  }(name='TagResources', description='The tags.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
 * @summary Queries the tags of resources.
 *
 * @param request ListTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
@context("listTagResourcesWithContext")
async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: $RuntimeOptions): ListTagResourcesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListTagResources',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the tags of resources.
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListUserClusterTypesResponseBody = {
  clusterTypes?: [ 
    {
      accessType?: string(name='AccessType', description='The access type of cluster type', example='Public'),
      typeName?: string(name='TypeName', description='The name of cluster type', example='AckEdgePro'),
    }
  ](name='ClusterTypes', description='The list of cluster types. Number of elements in the array: 1 to 100.'),
  nextToken?: string(name='NextToken', description='NextToken for the next page. Include this value when requesting the next page.', example='3a6b93229825ac667104463b56790c91'),
  requestId?: string(name='RequestId', description='Id of the request', example='4FD06DF0-9167-5C6F-A145-F30CA4A15D54'),
}

model ListUserClusterTypesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserClusterTypesResponseBody(name='body'),
}

/**
 * @summary Query the cluster types available to the user
 *
 * @param request ListUserClusterTypesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUserClusterTypesResponse
 */
async function listUserClusterTypesWithOptions(runtime: $RuntimeOptions): ListUserClusterTypesResponse {
  var req = new OpenApiUtil.OpenApiRequest{};
  var params = new OpenApiUtil.Params{
    action = 'ListUserClusterTypes',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Query the cluster types available to the user
 *
 * @return ListUserClusterTypesResponse
 */
async function listUserClusterTypes(): ListUserClusterTypesResponse {
  var runtime = new $RuntimeOptions{};
  return listUserClusterTypesWithOptions(runtime);
}

model ListVscsRequest {
  maxResults?: int32(name='MaxResults', description='The maximum number of data entries to return.', example='20'),
  nextToken?: string(name='NextToken', description='The token that is used in the next request to retrieve a new page of results. If you leave this parameter empty, the query starts from the beginning.', example='563d42ae0b17572449ec8c97f7f66069'),
  nodeIds?: [ string ](name='NodeIds', description='The IDs of the nodes.'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-aek2xdkc6icwfha'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='key001'),
      value?: string(name='Value', description='The tag value.', example='value001'),
    }
  ](name='Tag', description='The tags.'),
  vscName?: string(name='VscName', description='The VSC name.', example='test_name'),
}

model ListVscsShrinkRequest {
  maxResults?: int32(name='MaxResults', description='The maximum number of data entries to return.', example='20'),
  nextToken?: string(name='NextToken', description='The token that is used in the next request to retrieve a new page of results. If you leave this parameter empty, the query starts from the beginning.', example='563d42ae0b17572449ec8c97f7f66069'),
  nodeIdsShrink?: string(name='NodeIds', description='The IDs of the nodes.'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-aek2xdkc6icwfha'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='key001'),
      value?: string(name='Value', description='The tag value.', example='value001'),
    }
  ](name='Tag', description='The tags.'),
  vscName?: string(name='VscName', description='The VSC name.', example='test_name'),
}

model ListVscsResponseBody = {
  maxResults?: int32(name='MaxResults', description='No response is returned. The TotalCount parameter is used.', example='0'),
  nextToken?: string(name='NextToken', description='The token. It can be used in the next request to retrieve a new page of results. If this parameter is empty, no next page exists.

This parameter is required.', example='3a6b93229825ac667104463b56790c91'),
  requestId?: string(name='RequestId', description='The request ID.', example='03668372-18FF-5959-98D9-6B36A4643C7A'),
  totalCount?: int32(name='TotalCount', description='The total number of VSCs.', example='3'),
  vscs?: [ 
    {
      nodeId?: string(name='NodeId', description='The ID of the Lingjun node.', example='e01-cn-fzh47xd7u08'),
      resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-acfm2zkwhkns57i'),
      status?: string(name='Status', description='The VSC status.

Valid values:

*   Creating
*   Normal
*   Deleting', example='Normal'),
      tags?: [ 
        {
          tagKey?: string(name='TagKey', description='The tag key.', example='key001'),
          tagValue?: string(name='TagValue', description='The tag value.', example='value001'),
        }
      ](name='Tags', description='The tags.'),
      vscId?: string(name='VscId', description='The VSC ID.', example='vsc-001'),
      vscName?: string(name='VscName', description='The custom name of the VSC.', example='test_name'),
      vscType?: string(name='VscType', description='The VSC type. Valid values: primary and standard.', example='primary'),
    }
  ](name='Vscs', description='The VSCs.'),
}

model ListVscsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVscsResponseBody(name='body'),
}

/**
 * @summary Queries a list of virtual storage channels (VSC).
 *
 * @param tmpReq ListVscsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVscsResponse
 */
@context("listVscsWithContext")
async function listVscsWithOptions(tmpReq: ListVscsRequest, runtime: $RuntimeOptions): ListVscsResponse {
  tmpReq.validate();
  var request = new ListVscsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.nodeIds)) {
    request.nodeIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.nodeIds, 'NodeIds', 'json');
  }
  var query = {};
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var body : map[string]any = {};
  if (!$isNull(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.nodeIdsShrink)) {
    body['NodeIds'] = request.nodeIdsShrink;
  }
  if (!$isNull(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.vscName)) {
    body['VscName'] = request.vscName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListVscs',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of virtual storage channels (VSC).
 *
 * @param request ListVscsRequest
 * @return ListVscsResponse
 */
async function listVscs(request: ListVscsRequest): ListVscsResponse {
  var runtime = new $RuntimeOptions{};
  return listVscsWithOptions(request, runtime);
}

model RebootNodesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='i15b480fbd2fcdbc2869cd80'),
  ignoreFailedNodeTasks?: boolean(name='IgnoreFailedNodeTasks', description='Specifies whether to allow skipping failed nodes. Default value: False.', example='False'),
  nodes?: [ string ](name='Nodes', description='The nodes.'),
}

model RebootNodesShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='i15b480fbd2fcdbc2869cd80'),
  ignoreFailedNodeTasks?: boolean(name='IgnoreFailedNodeTasks', description='Specifies whether to allow skipping failed nodes. Default value: False.', example='False'),
  nodesShrink?: string(name='Nodes', description='The nodes.'),
}

model RebootNodesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='4FD06DF0-9167-5C6F-A145-F30CA4A15D54'),
  taskId?: string(name='TaskId', description='The job ID.', example='i158475611663639202234'),
}

model RebootNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RebootNodesResponseBody(name='body'),
}

/**
 * @summary Restarts nodes.
 *
 * @param tmpReq RebootNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RebootNodesResponse
 */
@context("rebootNodesWithContext")
async function rebootNodesWithOptions(tmpReq: RebootNodesRequest, runtime: $RuntimeOptions): RebootNodesResponse {
  tmpReq.validate();
  var request = new RebootNodesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.nodes)) {
    request.nodesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.nodes, 'Nodes', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.ignoreFailedNodeTasks)) {
    body['IgnoreFailedNodeTasks'] = request.ignoreFailedNodeTasks;
  }
  if (!$isNull(request.nodesShrink)) {
    body['Nodes'] = request.nodesShrink;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'RebootNodes',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Restarts nodes.
 *
 * @param request RebootNodesRequest
 * @return RebootNodesResponse
 */
async function rebootNodes(request: RebootNodesRequest): RebootNodesResponse {
  var runtime = new $RuntimeOptions{};
  return rebootNodesWithOptions(request, runtime);
}

model ReimageNodesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='i15dfa12e8f27c44f4a006c2c8bb'),
  ignoreFailedNodeTasks?: boolean(name='IgnoreFailedNodeTasks', description='Specifies whether to allow skipping failed nodes. Default value: False.', example='False'),
  nodes?: [ 
    {
      hostname?: string(name='Hostname', description='The hostname.', example='457db5ca-241d-11ed-9fd7-acde48001122'),
      imageId?: string(name='ImageId', description='The system image ID.', example='m-8vbf8rpv2nn14y7oybjy'),
      loginPassword?: string(name='LoginPassword', description='The logon password.', example='***'),
      nodeId?: string(name='NodeId', description='The node ID.', example='e01-cn-zvp2tgykr0b'),
    }
  ](name='Nodes', description='The nodes.'),
  userData?: string(name='UserData', description='The user data.', example='#!/bin/sh
echo "Hello World. The time is now $(date -R)!" | tee /root/userdata_test.txt'),
}

model ReimageNodesShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='i15dfa12e8f27c44f4a006c2c8bb'),
  ignoreFailedNodeTasks?: boolean(name='IgnoreFailedNodeTasks', description='Specifies whether to allow skipping failed nodes. Default value: False.', example='False'),
  nodesShrink?: string(name='Nodes', description='The nodes.'),
  userData?: string(name='UserData', description='The user data.', example='#!/bin/sh
echo "Hello World. The time is now $(date -R)!" | tee /root/userdata_test.txt'),
}

model ReimageNodesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='15FBCD9B-C93F-54E8-A168-AADE7E66DAD2'),
  taskId?: string(name='TaskId', description='The job ID.', example='i158782151663841517926'),
}

model ReimageNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReimageNodesResponseBody(name='body'),
}

/**
 * @summary Reinstall a node.
 *
 * @param tmpReq ReimageNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReimageNodesResponse
 */
@context("reimageNodesWithContext")
async function reimageNodesWithOptions(tmpReq: ReimageNodesRequest, runtime: $RuntimeOptions): ReimageNodesResponse {
  tmpReq.validate();
  var request = new ReimageNodesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.nodes)) {
    request.nodesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.nodes, 'Nodes', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.ignoreFailedNodeTasks)) {
    body['IgnoreFailedNodeTasks'] = request.ignoreFailedNodeTasks;
  }
  if (!$isNull(request.nodesShrink)) {
    body['Nodes'] = request.nodesShrink;
  }
  if (!$isNull(request.userData)) {
    body['UserData'] = request.userData;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ReimageNodes',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Reinstall a node.
 *
 * @param request ReimageNodesRequest
 * @return ReimageNodesResponse
 */
async function reimageNodes(request: ReimageNodesRequest): ReimageNodesResponse {
  var runtime = new $RuntimeOptions{};
  return reimageNodesWithOptions(request, runtime);
}

model RunCommandRequest {
  clientToken?: string(name='ClientToken', description='The client token to ensure the idempotency of the request. Use your client to generate the token that is unique among requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see "How to ensure idempotence".', example='123e4567-e89b-12d3-a456-426655440000'),
  commandContent?: string(name='CommandContent', description='The command content. Take note of the following:

*   When `EnableParameter` is set to true, you can use custom parameters in the command.
*   Define custom parameters in the {{}} format. Within `{{}}`, the spaces and line feeds before and after the parameter names are ignored.
*   You can specify up to 20 custom parameters.
*   A custom parameter name can contain only letters, digits, underscores (_), and hyphens (-). The name is not case-sensitive.
*   Each custom parameter name is up to 64 bytes in length.', example='ZWNobyAxMjM='),
  commandId?: string(name='CommandId', description='The ID of the command.', example='c-e996287206324975b5fbe1d***'),
  contentEncoding?: string(name='ContentEncoding', description='The encoding mode of the command content. Valid values:

*   PlainText
*   Base64

Default value: PlainText. If the specified value of this parameter is invalid, PlainText is used by default.', example='Base64'),
  description?: string(name='Description', description='The command description.', example='testDescription'),
  enableParameter?: boolean(name='EnableParameter', description='Specifies whether to use custom parameters in the command.

Default value: false.', example='false'),
  frequency?: string(name='Frequency', description='The schedule to run the command. Supported schedule types: at a fixed interval based on a rate expression, run only once at a specific time, or run at specific times based on a cron expression.

*   To run the command at a fixed interval, use a rate expression to specify the interval. The interval can be in seconds, minutes, hours, or days. This option is suitable for scenarios in which tasks need to be executed at a fixed interval. Format: rate(\\\\<Execution interval value> \\\\<Execution interval unit>). For example, rate(5m) means to run the command every 5 minutes. When you specify an interval, take note of the following limits:

    *   The interval can be anywhere from 60 seconds to 7 days, but must be longer than the timeout period of the scheduled task.
    *   The interval is the time between two consecutive executions, irrelevant of the time required to run the command. For example, assume that you set the interval to 5 minutes and that it takes 2 minutes to run the command each time. The system waits 3 minutes before running the command again.
    *   The command is not immediately executed after the task is created. For example, assume that you set the interval to 5 minutes. The task begins to be executed 5 minutes after it is created.

*   To run a command only once at a specific point in time, specify a point in time and a time zone. Format: at(yyyy-MM-dd HH:mm:ss \\\\<Time zone>). If you do not specify a time zone, the Coordinated Universal Time (UTC) time zone is used by default. The time zone name supports the following formats: Full name, such as Asia/Shanghai and America/Los_Angeles. The time offset from GMT. Examples: GMT+8:00 (UTC+8) and GMT-7:00 (UTC-7). If you use the GMT format, you cannot add leading zeros to the hour value. The time zone abbreviation. Only UTC is supported. For example, to configure a command to run only once at 13:15:30 on June 6, 2022 (Shanghai time), set the time to at(2022-06-06 13:15:30 Asia/Shanghai). To configure a command to run only once at 13:15:30 on June 6, 2022 (UTC-7), set the time to at(2022-06-06 13:15:30 GMT-7:00).

*   To run a command at designated points in time, use a cron expression to define the schedule. Format: \\\\<Cron expression> \\\\<Time zone>. Example: \\\\<Seconds> \\\\<Minutes> \\\\<Hours> \\\\<Day of the month> \\\\<Month> \\\\<Day of the week> \\\\<Year (optional)> \\\\<Time zone>. The system calculates the execution times of the command based on the specified cron expression and time zone and runs the command as scheduled. If you do not specify a time zone, the system time zone of the instance is used by default. For more information, see Cron expressions. The time zone name supports the following formats:

    *   Full name, such as Asia/Shanghai and America/Los_Angeles.
    *   The time offset from GMT. Examples: GMT+8:00 (UTC+8) and GMT-7:00 (UTC-7). If you use the GMT format, you cannot add leading zeros to the hour value.
    *   The time zone abbreviation. Only UTC is supported.

    For example, if you specify a command to run at 10:15:00 every day in 2022 in China/Shanghai time, set the time to 0 15 10 ? \\\\* \\\\* 2022 Asia/Shanghai. To configure a command to run every half an hour from 10:00:00 to 11:30:00 every day in 2022 (UTC+8), set the schedule to 0 0/30 10-11 \\\\* \\\\* ? 2022 GMT+8:00. To configure a command to run every 5 minutes from 14:00:00 to 14:55:00 every October every two years from 2022 in UTC, set the schedule to 0 0/5 14 \\\\* 10 ? 2022/2 UTC.'),
  launcher?: string(name='Launcher', description='The launcher for script execution. Cannot exceed 1 KB.', example='python3 -u {{ACS::ScriptFileName|Ext(".py")}}'),
  name?: string(name='Name', description='The command name.', example='testName'),
  nodeIdList?: [ string ](name='NodeIdList', description='The node list.'),
  parameters?: map[string]any(name='Parameters', description='The key-value pairs of custom parameters to pass in when the command includes custom parameters. For example, the command content is `echo {{name}}`. You can use `Parameters` to pass in the `{"name":"Jack"}` key-value pair. The `name` key of the custom parameter is automatically replaced by the paired Jack value to generate a new command. As a result, the `echo Jack` command is run.

You can specify 0 to 10 custom parameters. Take note of the following:

*   The key of a custom parameter can be up to 64 characters in length, and cannot be an empty string.
*   The value of a custom parameter can be an empty string.
*   If you want to retain a command, make sure that the command after Base64 encoding, including custom parameters and original command content, does not exceed 18 KB in size. If you do not want to retain the command, make sure that the command after Base64 encoding does not exceed 24 KB in size. You can set `KeepCommand` to specify whether to retain the command.
*   The specified custom parameter names must be included in the custom parameter names that you specify when you create the command. You can use empty strings to represent the parameters that are not passed in.

This parameter is left empty by default, which indicates that the custom parameter feature is disabled.', example='{"name":"Jack", "accessKey":"LTAIdyvdIqaRY****"}'),
  repeatMode?: string(name='RepeatMode', description='The mode to run the command. Valid values:

*   Once: runs the command immediately.
*   Period: runs the command based on a schedule. When set to `Period`, `Frequency` is required.
*   NextRebootOnly: runs the command the next time the instances is started.
*   EveryReboot: runs the command every time the instance is started.

Default value:

*   If you do not specify `Frequency`, the default value is `Once`.
*   If you specify `Frequency`, RepeatMode is set to `Period` regardless of whether a value is already specified.', example='Once'),
  terminationMode?: string(name='TerminationMode', description='Indicates how the command task is stopped when a command execution is manually stopped or times out. Valid values:

Process: The process of the command is stopped. ProcessTree: The process tree of the command is stopped. In this case, the process of the command and all subprocesses are stopped.', example='ProcessTree'),
  timeout?: int32(name='Timeout', description='The timeout period for the command. Unit: seconds. A timeout error occurs if the command cannot be run because the process slows down or because a specific module or Cloud Assistant Agent does not exist. When the specified timeout period ends, the command process is forcefully terminated. Default value: 60.', example='3600'),
  username?: string(name='Username', description='The username that you use to run the command. The name can be up to 255 characters in length. For Linux instances, the root user is used by default.', example='root'),
  workingDir?: string(name='WorkingDir', description='The working path of the command. You can specify a custom path. Default path:

Linux instances: By default, the path is in the /home directory of the root user.', example='/home/user'),
}

model RunCommandShrinkRequest {
  clientToken?: string(name='ClientToken', description='The client token to ensure the idempotency of the request. Use your client to generate the token that is unique among requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see "How to ensure idempotence".', example='123e4567-e89b-12d3-a456-426655440000'),
  commandContent?: string(name='CommandContent', description='The command content. Take note of the following:

*   When `EnableParameter` is set to true, you can use custom parameters in the command.
*   Define custom parameters in the {{}} format. Within `{{}}`, the spaces and line feeds before and after the parameter names are ignored.
*   You can specify up to 20 custom parameters.
*   A custom parameter name can contain only letters, digits, underscores (_), and hyphens (-). The name is not case-sensitive.
*   Each custom parameter name is up to 64 bytes in length.', example='ZWNobyAxMjM='),
  commandId?: string(name='CommandId', description='The ID of the command.', example='c-e996287206324975b5fbe1d***'),
  contentEncoding?: string(name='ContentEncoding', description='The encoding mode of the command content. Valid values:

*   PlainText
*   Base64

Default value: PlainText. If the specified value of this parameter is invalid, PlainText is used by default.', example='Base64'),
  description?: string(name='Description', description='The command description.', example='testDescription'),
  enableParameter?: boolean(name='EnableParameter', description='Specifies whether to use custom parameters in the command.

Default value: false.', example='false'),
  frequency?: string(name='Frequency', description='The schedule to run the command. Supported schedule types: at a fixed interval based on a rate expression, run only once at a specific time, or run at specific times based on a cron expression.

*   To run the command at a fixed interval, use a rate expression to specify the interval. The interval can be in seconds, minutes, hours, or days. This option is suitable for scenarios in which tasks need to be executed at a fixed interval. Format: rate(\\\\<Execution interval value> \\\\<Execution interval unit>). For example, rate(5m) means to run the command every 5 minutes. When you specify an interval, take note of the following limits:

    *   The interval can be anywhere from 60 seconds to 7 days, but must be longer than the timeout period of the scheduled task.
    *   The interval is the time between two consecutive executions, irrelevant of the time required to run the command. For example, assume that you set the interval to 5 minutes and that it takes 2 minutes to run the command each time. The system waits 3 minutes before running the command again.
    *   The command is not immediately executed after the task is created. For example, assume that you set the interval to 5 minutes. The task begins to be executed 5 minutes after it is created.

*   To run a command only once at a specific point in time, specify a point in time and a time zone. Format: at(yyyy-MM-dd HH:mm:ss \\\\<Time zone>). If you do not specify a time zone, the Coordinated Universal Time (UTC) time zone is used by default. The time zone name supports the following formats: Full name, such as Asia/Shanghai and America/Los_Angeles. The time offset from GMT. Examples: GMT+8:00 (UTC+8) and GMT-7:00 (UTC-7). If you use the GMT format, you cannot add leading zeros to the hour value. The time zone abbreviation. Only UTC is supported. For example, to configure a command to run only once at 13:15:30 on June 6, 2022 (Shanghai time), set the time to at(2022-06-06 13:15:30 Asia/Shanghai). To configure a command to run only once at 13:15:30 on June 6, 2022 (UTC-7), set the time to at(2022-06-06 13:15:30 GMT-7:00).

*   To run a command at designated points in time, use a cron expression to define the schedule. Format: \\\\<Cron expression> \\\\<Time zone>. Example: \\\\<Seconds> \\\\<Minutes> \\\\<Hours> \\\\<Day of the month> \\\\<Month> \\\\<Day of the week> \\\\<Year (optional)> \\\\<Time zone>. The system calculates the execution times of the command based on the specified cron expression and time zone and runs the command as scheduled. If you do not specify a time zone, the system time zone of the instance is used by default. For more information, see Cron expressions. The time zone name supports the following formats:

    *   Full name, such as Asia/Shanghai and America/Los_Angeles.
    *   The time offset from GMT. Examples: GMT+8:00 (UTC+8) and GMT-7:00 (UTC-7). If you use the GMT format, you cannot add leading zeros to the hour value.
    *   The time zone abbreviation. Only UTC is supported.

    For example, if you specify a command to run at 10:15:00 every day in 2022 in China/Shanghai time, set the time to 0 15 10 ? \\\\* \\\\* 2022 Asia/Shanghai. To configure a command to run every half an hour from 10:00:00 to 11:30:00 every day in 2022 (UTC+8), set the schedule to 0 0/30 10-11 \\\\* \\\\* ? 2022 GMT+8:00. To configure a command to run every 5 minutes from 14:00:00 to 14:55:00 every October every two years from 2022 in UTC, set the schedule to 0 0/5 14 \\\\* 10 ? 2022/2 UTC.'),
  launcher?: string(name='Launcher', description='The launcher for script execution. Cannot exceed 1 KB.', example='python3 -u {{ACS::ScriptFileName|Ext(".py")}}'),
  name?: string(name='Name', description='The command name.', example='testName'),
  nodeIdListShrink?: string(name='NodeIdList', description='The node list.'),
  parametersShrink?: string(name='Parameters', description='The key-value pairs of custom parameters to pass in when the command includes custom parameters. For example, the command content is `echo {{name}}`. You can use `Parameters` to pass in the `{"name":"Jack"}` key-value pair. The `name` key of the custom parameter is automatically replaced by the paired Jack value to generate a new command. As a result, the `echo Jack` command is run.

You can specify 0 to 10 custom parameters. Take note of the following:

*   The key of a custom parameter can be up to 64 characters in length, and cannot be an empty string.
*   The value of a custom parameter can be an empty string.
*   If you want to retain a command, make sure that the command after Base64 encoding, including custom parameters and original command content, does not exceed 18 KB in size. If you do not want to retain the command, make sure that the command after Base64 encoding does not exceed 24 KB in size. You can set `KeepCommand` to specify whether to retain the command.
*   The specified custom parameter names must be included in the custom parameter names that you specify when you create the command. You can use empty strings to represent the parameters that are not passed in.

This parameter is left empty by default, which indicates that the custom parameter feature is disabled.', example='{"name":"Jack", "accessKey":"LTAIdyvdIqaRY****"}'),
  repeatMode?: string(name='RepeatMode', description='The mode to run the command. Valid values:

*   Once: runs the command immediately.
*   Period: runs the command based on a schedule. When set to `Period`, `Frequency` is required.
*   NextRebootOnly: runs the command the next time the instances is started.
*   EveryReboot: runs the command every time the instance is started.

Default value:

*   If you do not specify `Frequency`, the default value is `Once`.
*   If you specify `Frequency`, RepeatMode is set to `Period` regardless of whether a value is already specified.', example='Once'),
  terminationMode?: string(name='TerminationMode', description='Indicates how the command task is stopped when a command execution is manually stopped or times out. Valid values:

Process: The process of the command is stopped. ProcessTree: The process tree of the command is stopped. In this case, the process of the command and all subprocesses are stopped.', example='ProcessTree'),
  timeout?: int32(name='Timeout', description='The timeout period for the command. Unit: seconds. A timeout error occurs if the command cannot be run because the process slows down or because a specific module or Cloud Assistant Agent does not exist. When the specified timeout period ends, the command process is forcefully terminated. Default value: 60.', example='3600'),
  username?: string(name='Username', description='The username that you use to run the command. The name can be up to 255 characters in length. For Linux instances, the root user is used by default.', example='root'),
  workingDir?: string(name='WorkingDir', description='The working path of the command. You can specify a custom path. Default path:

Linux instances: By default, the path is in the /home directory of the root user.', example='/home/user'),
}

model RunCommandResponseBody = {
  invokeId?: string(name='InvokeId', description='The ID of the execution.', example='t-7d2a745b412b4601b2d47f6a768d*'),
  requestId?: string(name='RequestId', description='Id of the request', example='2FE2B22C-CF9D-59DE-BF63-DC9B9B33A9D1'),
}

model RunCommandResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RunCommandResponseBody(name='body'),
}

/**
 * @summary Runs a Shell script on one or more Lingjun nodes.
 *
 * @param tmpReq RunCommandRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RunCommandResponse
 */
@context("runCommandWithContext")
async function runCommandWithOptions(tmpReq: RunCommandRequest, runtime: $RuntimeOptions): RunCommandResponse {
  tmpReq.validate();
  var request = new RunCommandShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.nodeIdList)) {
    request.nodeIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.nodeIdList, 'NodeIdList', 'json');
  }
  if (!$isNull(tmpReq.parameters)) {
    request.parametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.parameters, 'Parameters', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.commandContent)) {
    body['CommandContent'] = request.commandContent;
  }
  if (!$isNull(request.commandId)) {
    body['CommandId'] = request.commandId;
  }
  if (!$isNull(request.contentEncoding)) {
    body['ContentEncoding'] = request.contentEncoding;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.enableParameter)) {
    body['EnableParameter'] = request.enableParameter;
  }
  if (!$isNull(request.frequency)) {
    body['Frequency'] = request.frequency;
  }
  if (!$isNull(request.launcher)) {
    body['Launcher'] = request.launcher;
  }
  if (!$isNull(request.name)) {
    body['Name'] = request.name;
  }
  if (!$isNull(request.nodeIdListShrink)) {
    body['NodeIdList'] = request.nodeIdListShrink;
  }
  if (!$isNull(request.parametersShrink)) {
    body['Parameters'] = request.parametersShrink;
  }
  if (!$isNull(request.repeatMode)) {
    body['RepeatMode'] = request.repeatMode;
  }
  if (!$isNull(request.terminationMode)) {
    body['TerminationMode'] = request.terminationMode;
  }
  if (!$isNull(request.timeout)) {
    body['Timeout'] = request.timeout;
  }
  if (!$isNull(request.username)) {
    body['Username'] = request.username;
  }
  if (!$isNull(request.workingDir)) {
    body['WorkingDir'] = request.workingDir;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'RunCommand',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Runs a Shell script on one or more Lingjun nodes.
 *
 * @param request RunCommandRequest
 * @return RunCommandResponse
 */
async function runCommand(request: RunCommandRequest): RunCommandResponse {
  var runtime = new $RuntimeOptions{};
  return runCommandWithOptions(request, runtime);
}

model SendFileRequest {
  content?: string(name='Content', description='The content of the file. The file must not exceed 32 KB in size after it is encoded in Base64.

*   If `ContentType` is set to `PlainText`, the value of Content is in plaintext.
*   If `ContentType` is set to `Base64`, the value of Content is Base64-encoded.

This parameter is required.', example='#!/bin/bash echo "Current User is :" echo $(ps | grep "$$" | awk \\\\"{print $2}\\\\") -------- oss://bucketName/objectName'),
  contentType?: string(name='ContentType', description='The content type of the file. Valid values:

PlainText Base64 Default value: PlainText.', example='PlainText'),
  description?: string(name='Description', description='The description of the file. The description can be up to 512 characters in length and can contain any characters.', example='This is a test file.'),
  fileGroup?: string(name='FileGroup', description='The user group of the file. This parameter takes effect only on Linux instances. Default value: root. The value can be up to 64 characters in length.

Note If you want to use a non-root user group, make sure that the user group exists in the instances.', example='test'),
  fileMode?: string(name='FileMode', description='The permissions on the file. This parameter takes effect only on Linux instances. You can configure this parameter in the same way as you configure the chmod command.

Default value: 0644: the owner of the file has the read and write permission. The user group of the file and other users have read-only permission.', example='0644'),
  fileOwner?: string(name='FileOwner', description='The owner of the file. This parameter takes effect only on Linux instances. Default value: root.', example='root'),
  name?: string(name='Name', description='The file name. The name can be up to 255 characters in length and can contain any characters.

This parameter is required.', example='file.txt'),
  nodeIdList?: [ string ](name='NodeIdList', description='The node list.

This parameter is required.'),
  overwrite?: boolean(name='Overwrite', description='Specifies whether to overwrite file with the same name in the destination directory.

*   true
*   false

Default value: false.', example='True'),
  targetDir?: string(name='TargetDir', description='The directory in the Lingjun node to which the file is sent. If the specified directory does not exist, the system creates the directory automatically.

This parameter is required.', example='/home'),
  timeout?: int32(name='Timeout', description='The timeout period for the file sending task. Unit: seconds.

*   A timeout error occurs when a file cannot be sent because the process slows down or because a specific module or Cloud Assistant Agent does not exist.
*   If the specified timeout period is less than 10 seconds, the system sets the timeout period to 10 seconds to ensure that the file can be sent.

Default value: 60.', example='600'),
}

model SendFileShrinkRequest {
  content?: string(name='Content', description='The content of the file. The file must not exceed 32 KB in size after it is encoded in Base64.

*   If `ContentType` is set to `PlainText`, the value of Content is in plaintext.
*   If `ContentType` is set to `Base64`, the value of Content is Base64-encoded.

This parameter is required.', example='#!/bin/bash echo "Current User is :" echo $(ps | grep "$$" | awk \\\\"{print $2}\\\\") -------- oss://bucketName/objectName'),
  contentType?: string(name='ContentType', description='The content type of the file. Valid values:

PlainText Base64 Default value: PlainText.', example='PlainText'),
  description?: string(name='Description', description='The description of the file. The description can be up to 512 characters in length and can contain any characters.', example='This is a test file.'),
  fileGroup?: string(name='FileGroup', description='The user group of the file. This parameter takes effect only on Linux instances. Default value: root. The value can be up to 64 characters in length.

Note If you want to use a non-root user group, make sure that the user group exists in the instances.', example='test'),
  fileMode?: string(name='FileMode', description='The permissions on the file. This parameter takes effect only on Linux instances. You can configure this parameter in the same way as you configure the chmod command.

Default value: 0644: the owner of the file has the read and write permission. The user group of the file and other users have read-only permission.', example='0644'),
  fileOwner?: string(name='FileOwner', description='The owner of the file. This parameter takes effect only on Linux instances. Default value: root.', example='root'),
  name?: string(name='Name', description='The file name. The name can be up to 255 characters in length and can contain any characters.

This parameter is required.', example='file.txt'),
  nodeIdListShrink?: string(name='NodeIdList', description='The node list.

This parameter is required.'),
  overwrite?: boolean(name='Overwrite', description='Specifies whether to overwrite file with the same name in the destination directory.

*   true
*   false

Default value: false.', example='True'),
  targetDir?: string(name='TargetDir', description='The directory in the Lingjun node to which the file is sent. If the specified directory does not exist, the system creates the directory automatically.

This parameter is required.', example='/home'),
  timeout?: int32(name='Timeout', description='The timeout period for the file sending task. Unit: seconds.

*   A timeout error occurs when a file cannot be sent because the process slows down or because a specific module or Cloud Assistant Agent does not exist.
*   If the specified timeout period is less than 10 seconds, the system sets the timeout period to 10 seconds to ensure that the file can be sent.

Default value: 60.', example='600'),
}

model SendFileResponseBody = {
  invokeId?: string(name='InvokeId', description='The ID of the execution.', example='t-hz03la52z1zkvls'),
  requestId?: string(name='RequestId', description='Id of the request', example='3C683243-7915-57FB-9570-A2932C1C0F78'),
}

model SendFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SendFileResponseBody(name='body'),
}

/**
 * @summary Sends a file to one or more Lingjun nodes.
 *
 * @param tmpReq SendFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SendFileResponse
 */
@context("sendFileWithContext")
async function sendFileWithOptions(tmpReq: SendFileRequest, runtime: $RuntimeOptions): SendFileResponse {
  tmpReq.validate();
  var request = new SendFileShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.nodeIdList)) {
    request.nodeIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.nodeIdList, 'NodeIdList', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.content)) {
    body['Content'] = request.content;
  }
  if (!$isNull(request.contentType)) {
    body['ContentType'] = request.contentType;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.fileGroup)) {
    body['FileGroup'] = request.fileGroup;
  }
  if (!$isNull(request.fileMode)) {
    body['FileMode'] = request.fileMode;
  }
  if (!$isNull(request.fileOwner)) {
    body['FileOwner'] = request.fileOwner;
  }
  if (!$isNull(request.name)) {
    body['Name'] = request.name;
  }
  if (!$isNull(request.nodeIdListShrink)) {
    body['NodeIdList'] = request.nodeIdListShrink;
  }
  if (!$isNull(request.overwrite)) {
    body['Overwrite'] = request.overwrite;
  }
  if (!$isNull(request.targetDir)) {
    body['TargetDir'] = request.targetDir;
  }
  if (!$isNull(request.timeout)) {
    body['Timeout'] = request.timeout;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'SendFile',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Sends a file to one or more Lingjun nodes.
 *
 * @param request SendFileRequest
 * @return SendFileResponse
 */
async function sendFile(request: SendFileRequest): SendFileResponse {
  var runtime = new $RuntimeOptions{};
  return sendFileWithOptions(request, runtime);
}

model ShrinkClusterRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='i15dfa12e8f27c44f4a006c2c8bb'),
  ignoreFailedNodeTasks?: boolean(name='IgnoreFailedNodeTasks', description='Specifies whether to allow skipping failed nodes. Default value: False.', example='False'),
  nodeGroups?: [ 
    {
      hyperNodes?: [ 
        {
          hyperNodeId?: string(name='HyperNodeId'),
        }
      ](name='HyperNodes'),
      nodeGroupId?: string(name='NodeGroupId', description='The node group ID.', example='ng-3b6fbd24b1b845a0'),
      nodes?: [ 
        {
          nodeId?: string(name='NodeId', description='The node ID.', example='e01poc-cn-zmb2ypjdc01'),
        }
      ](name='Nodes', description='The nodes.'),
    }
  ](name='NodeGroups', description='The node groups.'),
}

model ShrinkClusterShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='i15dfa12e8f27c44f4a006c2c8bb'),
  ignoreFailedNodeTasks?: boolean(name='IgnoreFailedNodeTasks', description='Specifies whether to allow skipping failed nodes. Default value: False.', example='False'),
  nodeGroupsShrink?: string(name='NodeGroups', description='The node groups.'),
}

model ShrinkClusterResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CC9FEF89-9BE5-5E03-845E-238B48D7599B'),
  taskId?: string(name='TaskId', description='The job ID.', example='i159136551662516768776'),
}

model ShrinkClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ShrinkClusterResponseBody(name='body'),
}

/**
 * @summary Scales in a cluster.
 *
 * @param tmpReq ShrinkClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ShrinkClusterResponse
 */
@context("shrinkClusterWithContext")
async function shrinkClusterWithOptions(tmpReq: ShrinkClusterRequest, runtime: $RuntimeOptions): ShrinkClusterResponse {
  tmpReq.validate();
  var request = new ShrinkClusterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.nodeGroups)) {
    request.nodeGroupsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.nodeGroups, 'NodeGroups', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.clusterId)) {
    body['ClusterId'] = request.clusterId;
  }
  if (!$isNull(request.ignoreFailedNodeTasks)) {
    body['IgnoreFailedNodeTasks'] = request.ignoreFailedNodeTasks;
  }
  if (!$isNull(request.nodeGroupsShrink)) {
    body['NodeGroups'] = request.nodeGroupsShrink;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ShrinkCluster',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Scales in a cluster.
 *
 * @param request ShrinkClusterRequest
 * @return ShrinkClusterResponse
 */
async function shrinkCluster(request: ShrinkClusterRequest): ShrinkClusterResponse {
  var runtime = new $RuntimeOptions{};
  return shrinkClusterWithOptions(request, runtime);
}

model StopInvocationRequest {
  invokeId?: string(name='InvokeId', description='The execution ID.

This parameter is required.', example='f-hz044748dzepds0'),
  nodeIdList?: [ string ](name='NodeIdList', description='The nodes.'),
}

model StopInvocationShrinkRequest {
  invokeId?: string(name='InvokeId', description='The execution ID.

This parameter is required.', example='f-hz044748dzepds0'),
  nodeIdListShrink?: string(name='NodeIdList', description='The nodes.'),
}

model StopInvocationResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A7FD7411-9395-52E8-AF42-EB3A4A55446D'),
}

model StopInvocationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopInvocationResponseBody(name='body'),
}

/**
 * @summary Stops the O\\&M assistant command execution.
 *
 * @param tmpReq StopInvocationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopInvocationResponse
 */
@context("stopInvocationWithContext")
async function stopInvocationWithOptions(tmpReq: StopInvocationRequest, runtime: $RuntimeOptions): StopInvocationResponse {
  tmpReq.validate();
  var request = new StopInvocationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.nodeIdList)) {
    request.nodeIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.nodeIdList, 'NodeIdList', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.invokeId)) {
    body['InvokeId'] = request.invokeId;
  }
  if (!$isNull(request.nodeIdListShrink)) {
    body['NodeIdList'] = request.nodeIdListShrink;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'StopInvocation',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Stops the O\\&M assistant command execution.
 *
 * @param request StopInvocationRequest
 * @return StopInvocationResponse
 */
async function stopInvocation(request: StopInvocationRequest): StopInvocationResponse {
  var runtime = new $RuntimeOptions{};
  return stopInvocationWithOptions(request, runtime);
}

model StopNodesRequest {
  ignoreFailedNodeTasks?: boolean(name='IgnoreFailedNodeTasks', description='Specifies whether to allow skipping failed nodes. Default value: False.', example='False'),
  nodes?: [ string ](name='Nodes', description='The nodes.'),
}

model StopNodesShrinkRequest {
  ignoreFailedNodeTasks?: boolean(name='IgnoreFailedNodeTasks', description='Specifies whether to allow skipping failed nodes. Default value: False.', example='False'),
  nodesShrink?: string(name='Nodes', description='The nodes.'),
}

model StopNodesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='4FD06DF0-9167-5C6F-A145-F30CA4A15D54'),
  taskId?: string(name='TaskId', description='The task ID.', example='i155847351716171893489'),
}

model StopNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopNodesResponseBody(name='body'),
}

/**
 * @summary Stops nodes.
 *
 * @param tmpReq StopNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopNodesResponse
 */
@context("stopNodesWithContext")
async function stopNodesWithOptions(tmpReq: StopNodesRequest, runtime: $RuntimeOptions): StopNodesResponse {
  tmpReq.validate();
  var request = new StopNodesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.nodes)) {
    request.nodesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.nodes, 'Nodes', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.ignoreFailedNodeTasks)) {
    body['IgnoreFailedNodeTasks'] = request.ignoreFailedNodeTasks;
  }
  if (!$isNull(request.nodesShrink)) {
    body['Nodes'] = request.nodesShrink;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'StopNodes',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Stops nodes.
 *
 * @param request StopNodesRequest
 * @return StopNodesResponse
 */
async function stopNodes(request: StopNodesRequest): StopNodesResponse {
  var runtime = new $RuntimeOptions{};
  return stopNodesWithOptions(request, runtime);
}

model TagResourcesRequest {
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The IDs of the resources.

This parameter is required.'),
  resourceType?: string(name='ResourceType', description='The resource type.

Valid values:

*   Node
*   Vcc
*   Cluster
*   Vpd
*   Subnet

This parameter is required.', example='Cluster'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='app'),
      value?: string(name='Value', description='The tag value.', example='v3'),
    }
  ](name='Tag', description='The tags.

This parameter is required.'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='E7BB53E1-0B08-5C4E-BA66-9225548C3151'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
 * @summary Tags resources.
 *
 * @param request TagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
@context("tagResourcesWithContext")
async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: $RuntimeOptions): TagResourcesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'TagResources',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Tags resources.
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to remove all tags. This parameter takes effect only when TagKey.N is not specified. Valid values:

*   True
*   False

Default value: false.', example='False'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs.

This parameter is required.'),
  resourceType?: string(name='ResourceType', description='The resource type.

Valid values:

*   Node
*   Cluster

This parameter is required.', example='Cluster'),
  tagKey?: [ string ](name='TagKey', description='The tag keys.'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='81F648D0-5570-5351-AE98-6F501C7E957F'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
 * @summary Deletes a custom tag from a resource.
 *
 * @param request UntagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesResponse
 */
@context("untagResourcesWithContext")
async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: $RuntimeOptions): UntagResourcesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.all)) {
    query['All'] = request.all;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UntagResources',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a custom tag from a resource.
 *
 * @param request UntagResourcesRequest
 * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateNodeGroupRequest {
  fileSystemMountEnabled?: boolean(name='FileSystemMountEnabled', description='Whether file storage mounting is supported', example='True'),
  imageId?: string(name='ImageId', description='The default image ID of the node group. If not set, it will not change.', example='i1232142432432'),
  keyPairName?: string(name='KeyPairName', description='Key pair name.', example='test'),
  loginPassword?: string(name='LoginPassword', description='Login password for machines within the node group', example='LoginPassword'),
  newNodeGroupName?: string(name='NewNodeGroupName', description='Node group name', example='test-update'),
  nodeGroupId?: string(name='NodeGroupId', description='Node group ID', example='i120021051733814190732'),
  userData?: string(name='UserData', description='User-defined script', example='#!/bin/bash
uptime
echo "aaaaaaa" >> /tmp/ttttt20250110141010.sh'),
}

model UpdateNodeGroupResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='8F065DDD-6996-5973-9691-9EC57BD0072E'),
  taskId?: string(name='TaskId', description='Task ID', example='i154273451745372344629'),
}

model UpdateNodeGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateNodeGroupResponseBody(name='body'),
}

/**
 * @summary Update Node Group
 *
 * @param request UpdateNodeGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNodeGroupResponse
 */
@context("updateNodeGroupWithContext")
async function updateNodeGroupWithOptions(request: UpdateNodeGroupRequest, runtime: $RuntimeOptions): UpdateNodeGroupResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.fileSystemMountEnabled)) {
    body['FileSystemMountEnabled'] = request.fileSystemMountEnabled;
  }
  if (!$isNull(request.imageId)) {
    body['ImageId'] = request.imageId;
  }
  if (!$isNull(request.keyPairName)) {
    body['KeyPairName'] = request.keyPairName;
  }
  if (!$isNull(request.loginPassword)) {
    body['LoginPassword'] = request.loginPassword;
  }
  if (!$isNull(request.newNodeGroupName)) {
    body['NewNodeGroupName'] = request.newNodeGroupName;
  }
  if (!$isNull(request.nodeGroupId)) {
    body['NodeGroupId'] = request.nodeGroupId;
  }
  if (!$isNull(request.userData)) {
    body['UserData'] = request.userData;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateNodeGroup',
    version = '2022-12-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update Node Group
 *
 * @param request UpdateNodeGroupRequest
 * @return UpdateNodeGroupResponse
 */
async function updateNodeGroup(request: UpdateNodeGroupRequest): UpdateNodeGroupResponse {
  var runtime = new $RuntimeOptions{};
  return updateNodeGroupWithOptions(request, runtime);
}

