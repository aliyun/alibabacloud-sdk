/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('devops-rdc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddCodeupSourceToPipelineRequest {
  codeBranch?: string(name='CodeBranch'),
  codePath?: string(name='CodePath'),
  orgId?: string(name='OrgId'),
  pipelineId?: long(name='PipelineId'),
}

model AddCodeupSourceToPipelineResponseBody = {
  pipelineId?: long(name='PipelineId'),
  requestId?: string(name='RequestId'),
}

model AddCodeupSourceToPipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddCodeupSourceToPipelineResponseBody(name='body'),
}

async function addCodeupSourceToPipelineWithOptions(request: AddCodeupSourceToPipelineRequest, runtime: Util.RuntimeOptions): AddCodeupSourceToPipelineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.codeBranch)) {
    query['CodeBranch'] = request.codeBranch;
  }
  if (!Util.isUnset(request.codePath)) {
    query['CodePath'] = request.codePath;
  }
  if (!Util.isUnset(request.orgId)) {
    query['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddCodeupSourceToPipeline',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addCodeupSourceToPipeline(request: AddCodeupSourceToPipelineRequest): AddCodeupSourceToPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCodeupSourceToPipelineWithOptions(request, runtime);
}

model BatchInsertMembersRequest {
  members?: string(name='Members'),
  orgId?: string(name='OrgId'),
  realPk?: string(name='RealPk'),
}

model BatchInsertMembersResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: boolean(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchInsertMembersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchInsertMembersResponseBody(name='body'),
}

async function batchInsertMembersWithOptions(request: BatchInsertMembersRequest, runtime: Util.RuntimeOptions): BatchInsertMembersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.members)) {
    body['Members'] = request.members;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.realPk)) {
    body['RealPk'] = request.realPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchInsertMembers',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchInsertMembers(request: BatchInsertMembersRequest): BatchInsertMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchInsertMembersWithOptions(request, runtime);
}

model CancelPipelineRequest {
  flowInstanceId?: long(name='FlowInstanceId'),
  orgId?: string(name='OrgId'),
  pipelineId?: long(name='PipelineId'),
  userPk?: string(name='UserPk'),
}

model CancelPipelineResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: boolean(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelPipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelPipelineResponseBody(name='body'),
}

async function cancelPipelineWithOptions(request: CancelPipelineRequest, runtime: Util.RuntimeOptions): CancelPipelineResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.flowInstanceId)) {
    body['FlowInstanceId'] = request.flowInstanceId;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    body['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CancelPipeline',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelPipeline(request: CancelPipelineRequest): CancelPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelPipelineWithOptions(request, runtime);
}

model CreateCommonGroupRequest {
  description?: string(name='Description'),
  name?: string(name='Name'),
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
  smartGroupId?: string(name='SmartGroupId'),
}

model CreateCommonGroupResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    id?: string(name='Id'),
  }(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model CreateCommonGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCommonGroupResponseBody(name='body'),
}

async function createCommonGroupWithOptions(request: CreateCommonGroupRequest, runtime: Util.RuntimeOptions): CreateCommonGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.smartGroupId)) {
    body['SmartGroupId'] = request.smartGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCommonGroup',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCommonGroup(request: CreateCommonGroupRequest): CreateCommonGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCommonGroupWithOptions(request, runtime);
}

model CreateCredentialRequest {
  name?: string(name='Name'),
  orgId?: string(name='OrgId'),
  password?: string(name='Password'),
  type?: string(name='Type'),
  userName?: string(name='UserName'),
  userPk?: string(name='UserPk'),
}

model CreateCredentialResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: long(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCredentialResponseBody(name='body'),
}

async function createCredentialWithOptions(request: CreateCredentialRequest, runtime: Util.RuntimeOptions): CreateCredentialResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCredential',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCredential(request: CreateCredentialRequest): CreateCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCredentialWithOptions(request, runtime);
}

model CreateDevopsProjectRequest {
  description?: string(name='Description'),
  name?: string(name='Name'),
  orgId?: string(name='OrgId'),
}

model CreateDevopsProjectResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: string(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDevopsProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDevopsProjectResponseBody(name='body'),
}

async function createDevopsProjectWithOptions(request: CreateDevopsProjectRequest, runtime: Util.RuntimeOptions): CreateDevopsProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDevopsProject',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDevopsProject(request: CreateDevopsProjectRequest): CreateDevopsProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDevopsProjectWithOptions(request, runtime);
}

model CreateDevopsProjectSprintRequest {
  description?: string(name='Description'),
  dueDate?: string(name='DueDate'),
  executorId?: string(name='ExecutorId'),
  name?: string(name='Name'),
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
  startDate?: string(name='StartDate'),
}

model CreateDevopsProjectSprintResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    accomplished?: string(name='Accomplished'),
    created?: string(name='Created'),
    creatorId?: string(name='CreatorId'),
    description?: string(name='Description'),
    dueDate?: string(name='DueDate'),
    executor?: string(name='Executor'),
    id?: string(name='Id'),
    isDeleted?: boolean(name='IsDeleted'),
    name?: string(name='Name'),
    planToDo?: {
      storyPoints?: int32(name='StoryPoints'),
      tasks?: int32(name='Tasks'),
      workTimes?: int32(name='WorkTimes'),
    }(name='PlanToDo'),
    projectId?: string(name='ProjectId'),
    startDate?: string(name='StartDate'),
    status?: string(name='Status'),
    updated?: string(name='Updated'),
  }(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model CreateDevopsProjectSprintResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDevopsProjectSprintResponseBody(name='body'),
}

async function createDevopsProjectSprintWithOptions(request: CreateDevopsProjectSprintRequest, runtime: Util.RuntimeOptions): CreateDevopsProjectSprintResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.dueDate)) {
    body['DueDate'] = request.dueDate;
  }
  if (!Util.isUnset(request.executorId)) {
    body['ExecutorId'] = request.executorId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.startDate)) {
    body['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDevopsProjectSprint',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDevopsProjectSprint(request: CreateDevopsProjectSprintRequest): CreateDevopsProjectSprintResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDevopsProjectSprintWithOptions(request, runtime);
}

model CreateDevopsProjectTaskRequest {
  content?: string(name='Content'),
  dueDate?: string(name='DueDate'),
  executorId?: string(name='ExecutorId'),
  note?: string(name='Note'),
  orgId?: string(name='OrgId'),
  parentTaskId?: string(name='ParentTaskId'),
  priority?: int32(name='Priority'),
  projectId?: string(name='ProjectId'),
  scenarioFieldConfigId?: string(name='ScenarioFieldConfigId'),
  sprintId?: string(name='SprintId'),
  startDate?: string(name='StartDate'),
  taskFlowStatusId?: string(name='TaskFlowStatusId'),
  taskListId?: string(name='TaskListId'),
  visible?: string(name='Visible'),
}

model CreateDevopsProjectTaskResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    content?: string(name='Content'),
    created?: string(name='Created'),
    creatorId?: string(name='CreatorId'),
    dueDate?: string(name='DueDate'),
    executorId?: string(name='ExecutorId'),
    id?: string(name='Id'),
    isDone?: boolean(name='IsDone'),
    note?: string(name='Note'),
    organizationId?: string(name='OrganizationId'),
    pos?: int32(name='Pos'),
    priority?: int32(name='Priority'),
    projectId?: string(name='ProjectId'),
    rating?: int32(name='Rating'),
    scenarioFieldConfigId?: string(name='ScenarioFieldConfigId'),
    source?: string(name='Source'),
    sprintId?: string(name='SprintId'),
    startDate?: string(name='StartDate'),
    storyPoint?: string(name='StoryPoint'),
    taskType?: string(name='TaskType'),
    taskflowstatusId?: string(name='TaskflowstatusId'),
    tasklistId?: string(name='TasklistId'),
    uniqueId?: int32(name='UniqueId'),
    updated?: string(name='Updated'),
    visible?: string(name='Visible'),
  }(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model CreateDevopsProjectTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDevopsProjectTaskResponseBody(name='body'),
}

async function createDevopsProjectTaskWithOptions(request: CreateDevopsProjectTaskRequest, runtime: Util.RuntimeOptions): CreateDevopsProjectTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.dueDate)) {
    body['DueDate'] = request.dueDate;
  }
  if (!Util.isUnset(request.executorId)) {
    body['ExecutorId'] = request.executorId;
  }
  if (!Util.isUnset(request.note)) {
    body['Note'] = request.note;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.parentTaskId)) {
    body['ParentTaskId'] = request.parentTaskId;
  }
  if (!Util.isUnset(request.priority)) {
    body['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.scenarioFieldConfigId)) {
    body['ScenarioFieldConfigId'] = request.scenarioFieldConfigId;
  }
  if (!Util.isUnset(request.sprintId)) {
    body['SprintId'] = request.sprintId;
  }
  if (!Util.isUnset(request.startDate)) {
    body['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.taskFlowStatusId)) {
    body['TaskFlowStatusId'] = request.taskFlowStatusId;
  }
  if (!Util.isUnset(request.taskListId)) {
    body['TaskListId'] = request.taskListId;
  }
  if (!Util.isUnset(request.visible)) {
    body['Visible'] = request.visible;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDevopsProjectTask',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDevopsProjectTask(request: CreateDevopsProjectTaskRequest): CreateDevopsProjectTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDevopsProjectTaskWithOptions(request, runtime);
}

model CreatePipelineFromTemplateRequest {
  orgId?: string(name='OrgId'),
  pipelineName?: string(name='PipelineName'),
  pipelineTemplateId?: long(name='PipelineTemplateId'),
}

model CreatePipelineFromTemplateResponseBody = {
  pipelineId?: long(name='PipelineId'),
  requestId?: string(name='RequestId'),
}

model CreatePipelineFromTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePipelineFromTemplateResponseBody(name='body'),
}

async function createPipelineFromTemplateWithOptions(request: CreatePipelineFromTemplateRequest, runtime: Util.RuntimeOptions): CreatePipelineFromTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orgId)) {
    query['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pipelineName)) {
    query['PipelineName'] = request.pipelineName;
  }
  if (!Util.isUnset(request.pipelineTemplateId)) {
    query['PipelineTemplateId'] = request.pipelineTemplateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePipelineFromTemplate',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPipelineFromTemplate(request: CreatePipelineFromTemplateRequest): CreatePipelineFromTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPipelineFromTemplateWithOptions(request, runtime);
}

model CreateServiceConnectionRequest {
  orgId?: string(name='OrgId'),
  serviceConnectionType?: string(name='ServiceConnectionType'),
  userPk?: string(name='UserPk'),
}

model CreateServiceConnectionResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: long(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateServiceConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceConnectionResponseBody(name='body'),
}

async function createServiceConnectionWithOptions(request: CreateServiceConnectionRequest, runtime: Util.RuntimeOptions): CreateServiceConnectionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.serviceConnectionType)) {
    body['ServiceConnectionType'] = request.serviceConnectionType;
  }
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceConnection',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createServiceConnection(request: CreateServiceConnectionRequest): CreateServiceConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceConnectionWithOptions(request, runtime);
}

model DeleteCommonGroupRequest {
  commonGroupId?: string(name='CommonGroupId'),
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
}

model DeleteCommonGroupResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    id?: string(name='Id'),
  }(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model DeleteCommonGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCommonGroupResponseBody(name='body'),
}

async function deleteCommonGroupWithOptions(request: DeleteCommonGroupRequest, runtime: Util.RuntimeOptions): DeleteCommonGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.commonGroupId)) {
    body['CommonGroupId'] = request.commonGroupId;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCommonGroup',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCommonGroup(request: DeleteCommonGroupRequest): DeleteCommonGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCommonGroupWithOptions(request, runtime);
}

model DeleteDevopsOrganizationMembersRequest {
  orgId?: string(name='OrgId'),
  realPk?: string(name='RealPk'),
  userId?: string(name='UserId'),
}

model DeleteDevopsOrganizationMembersResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: boolean(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDevopsOrganizationMembersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDevopsOrganizationMembersResponseBody(name='body'),
}

async function deleteDevopsOrganizationMembersWithOptions(request: DeleteDevopsOrganizationMembersRequest, runtime: Util.RuntimeOptions): DeleteDevopsOrganizationMembersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.realPk)) {
    body['RealPk'] = request.realPk;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDevopsOrganizationMembers',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDevopsOrganizationMembers(request: DeleteDevopsOrganizationMembersRequest): DeleteDevopsOrganizationMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDevopsOrganizationMembersWithOptions(request, runtime);
}

model DeleteDevopsProjectRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
}

model DeleteDevopsProjectResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: string(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDevopsProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDevopsProjectResponseBody(name='body'),
}

async function deleteDevopsProjectWithOptions(request: DeleteDevopsProjectRequest, runtime: Util.RuntimeOptions): DeleteDevopsProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDevopsProject',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDevopsProject(request: DeleteDevopsProjectRequest): DeleteDevopsProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDevopsProjectWithOptions(request, runtime);
}

model DeleteDevopsProjectMembersRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
  userIds?: string(name='UserIds'),
}

model DeleteDevopsProjectMembersResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: boolean(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model DeleteDevopsProjectMembersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDevopsProjectMembersResponseBody(name='body'),
}

async function deleteDevopsProjectMembersWithOptions(request: DeleteDevopsProjectMembersRequest, runtime: Util.RuntimeOptions): DeleteDevopsProjectMembersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.userIds)) {
    body['UserIds'] = request.userIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDevopsProjectMembers',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDevopsProjectMembers(request: DeleteDevopsProjectMembersRequest): DeleteDevopsProjectMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDevopsProjectMembersWithOptions(request, runtime);
}

model DeleteDevopsProjectSprintRequest {
  orgId?: string(name='OrgId'),
  sprintId?: string(name='SprintId'),
}

model DeleteDevopsProjectSprintResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: boolean(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model DeleteDevopsProjectSprintResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDevopsProjectSprintResponseBody(name='body'),
}

async function deleteDevopsProjectSprintWithOptions(request: DeleteDevopsProjectSprintRequest, runtime: Util.RuntimeOptions): DeleteDevopsProjectSprintResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.sprintId)) {
    body['SprintId'] = request.sprintId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDevopsProjectSprint',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDevopsProjectSprint(request: DeleteDevopsProjectSprintRequest): DeleteDevopsProjectSprintResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDevopsProjectSprintWithOptions(request, runtime);
}

model DeleteDevopsProjectTaskRequest {
  orgId?: string(name='OrgId'),
  taskId?: string(name='TaskId'),
}

model DeleteDevopsProjectTaskResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: boolean(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model DeleteDevopsProjectTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDevopsProjectTaskResponseBody(name='body'),
}

async function deleteDevopsProjectTaskWithOptions(request: DeleteDevopsProjectTaskRequest, runtime: Util.RuntimeOptions): DeleteDevopsProjectTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDevopsProjectTask',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDevopsProjectTask(request: DeleteDevopsProjectTaskRequest): DeleteDevopsProjectTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDevopsProjectTaskWithOptions(request, runtime);
}

model DeletePipelineMemberRequest {
  orgId?: string(name='OrgId'),
  pipelineId?: long(name='PipelineId'),
  userId?: string(name='UserId'),
  userPk?: string(name='UserPk'),
}

model DeletePipelineMemberResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: boolean(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeletePipelineMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePipelineMemberResponseBody(name='body'),
}

async function deletePipelineMemberWithOptions(request: DeletePipelineMemberRequest, runtime: Util.RuntimeOptions): DeletePipelineMemberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orgId)) {
    query['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeletePipelineMember',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePipelineMember(request: DeletePipelineMemberRequest): DeletePipelineMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePipelineMemberWithOptions(request, runtime);
}

model ExecutePipelineRequest {
  orgId?: string(name='OrgId'),
  parameters?: string(name='Parameters'),
  pipelineId?: long(name='PipelineId'),
  userPk?: string(name='UserPk'),
}

model ExecutePipelineResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: long(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExecutePipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecutePipelineResponseBody(name='body'),
}

async function executePipelineWithOptions(request: ExecutePipelineRequest, runtime: Util.RuntimeOptions): ExecutePipelineResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.parameters)) {
    body['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.pipelineId)) {
    body['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ExecutePipeline',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function executePipeline(request: ExecutePipelineRequest): ExecutePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return executePipelineWithOptions(request, runtime);
}

model GetDevopsOrganizationMembersRequest {
  orgId?: string(name='OrgId'),
}

model GetDevopsOrganizationMembersResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: [ 
    {
      avatarUrl?: string(name='AvatarUrl'),
      email?: string(name='Email'),
      memberId?: string(name='MemberId'),
      name?: string(name='Name'),
      phone?: string(name='Phone'),
      role?: int32(name='Role'),
      userId?: string(name='UserId'),
    }
  ](name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model GetDevopsOrganizationMembersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDevopsOrganizationMembersResponseBody(name='body'),
}

async function getDevopsOrganizationMembersWithOptions(request: GetDevopsOrganizationMembersRequest, runtime: Util.RuntimeOptions): GetDevopsOrganizationMembersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDevopsOrganizationMembers',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDevopsOrganizationMembers(request: GetDevopsOrganizationMembersRequest): GetDevopsOrganizationMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDevopsOrganizationMembersWithOptions(request, runtime);
}

model GetDevopsProjectInfoRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
}

model GetDevopsProjectInfoResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    category?: string(name='Category'),
    created?: string(name='Created'),
    creatorId?: string(name='CreatorId'),
    customfields?: string(name='Customfields'),
    defaultCollectionId?: string(name='DefaultCollectionId'),
    defaultRoleId?: string(name='DefaultRoleId'),
    description?: string(name='Description'),
    endDate?: string(name='EndDate'),
    id?: string(name='Id'),
    isArchived?: boolean(name='IsArchived'),
    isDeleted?: boolean(name='IsDeleted'),
    isSuspended?: boolean(name='IsSuspended'),
    isTemplate?: boolean(name='IsTemplate'),
    logo?: string(name='Logo'),
    modifierId?: string(name='ModifierId'),
    name?: string(name='Name'),
    nextTaskUniqueId?: int32(name='NextTaskUniqueId'),
    normalType?: string(name='NormalType'),
    organizationId?: string(name='OrganizationId'),
    pinyin?: string(name='Pinyin'),
    py?: string(name='Py'),
    rootCollectionId?: string(name='RootCollectionId'),
    sortMethod?: string(name='SortMethod'),
    sourceId?: string(name='SourceId'),
    sourceType?: string(name='SourceType'),
    startDate?: string(name='StartDate'),
    uniqueIdPrefix?: string(name='UniqueIdPrefix'),
    updated?: string(name='Updated'),
    visibility?: string(name='Visibility'),
  }(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model GetDevopsProjectInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDevopsProjectInfoResponseBody(name='body'),
}

async function getDevopsProjectInfoWithOptions(request: GetDevopsProjectInfoRequest, runtime: Util.RuntimeOptions): GetDevopsProjectInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDevopsProjectInfo',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDevopsProjectInfo(request: GetDevopsProjectInfoRequest): GetDevopsProjectInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDevopsProjectInfoWithOptions(request, runtime);
}

model GetDevopsProjectMembersRequest {
  orgId?: string(name='OrgId'),
  pageSize?: int32(name='PageSize'),
  pageToken?: string(name='PageToken'),
  projectId?: string(name='ProjectId'),
}

model GetDevopsProjectMembersResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  nextPageToken?: string(name='NextPageToken'),
  object?: [ 
    {
      avatarUrl?: string(name='AvatarUrl'),
      email?: string(name='Email'),
      memberId?: string(name='MemberId'),
      name?: string(name='Name'),
      phone?: string(name='Phone'),
      role?: int32(name='Role'),
      userId?: string(name='UserId'),
    }
  ](name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
  total?: int32(name='Total'),
}

model GetDevopsProjectMembersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDevopsProjectMembersResponseBody(name='body'),
}

async function getDevopsProjectMembersWithOptions(request: GetDevopsProjectMembersRequest, runtime: Util.RuntimeOptions): GetDevopsProjectMembersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pageToken)) {
    body['PageToken'] = request.pageToken;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDevopsProjectMembers',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDevopsProjectMembers(request: GetDevopsProjectMembersRequest): GetDevopsProjectMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDevopsProjectMembersWithOptions(request, runtime);
}

model GetDevopsProjectSprintInfoRequest {
  orgId?: string(name='OrgId'),
  sprintId?: string(name='SprintId'),
}

model GetDevopsProjectSprintInfoResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    accomplished?: string(name='Accomplished'),
    created?: string(name='Created'),
    creatorId?: string(name='CreatorId'),
    dueDate?: string(name='DueDate'),
    id?: string(name='Id'),
    isDeleted?: boolean(name='IsDeleted'),
    name?: string(name='Name'),
    planToDo?: {
      storyPoints?: int32(name='StoryPoints'),
      tasks?: int32(name='Tasks'),
      workTimes?: int32(name='WorkTimes'),
    }(name='PlanToDo'),
    projectId?: string(name='ProjectId'),
    startDate?: string(name='StartDate'),
    status?: string(name='Status'),
    updated?: string(name='Updated'),
  }(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model GetDevopsProjectSprintInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDevopsProjectSprintInfoResponseBody(name='body'),
}

async function getDevopsProjectSprintInfoWithOptions(request: GetDevopsProjectSprintInfoRequest, runtime: Util.RuntimeOptions): GetDevopsProjectSprintInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.sprintId)) {
    body['SprintId'] = request.sprintId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDevopsProjectSprintInfo',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDevopsProjectSprintInfo(request: GetDevopsProjectSprintInfoRequest): GetDevopsProjectSprintInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDevopsProjectSprintInfoWithOptions(request, runtime);
}

model GetDevopsProjectTaskInfoRequest {
  orgId?: string(name='OrgId'),
  taskId?: string(name='TaskId'),
}

model GetDevopsProjectTaskInfoResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    content?: string(name='Content'),
    created?: string(name='Created'),
    creatorId?: string(name='CreatorId'),
    dueDate?: string(name='DueDate'),
    executorId?: string(name='ExecutorId'),
    id?: string(name='Id'),
    involveMembers?: [ string ](name='InvolveMembers'),
    isDeleted?: boolean(name='IsDeleted'),
    isDone?: boolean(name='IsDone'),
    isTopInProject?: boolean(name='IsTopInProject'),
    note?: string(name='Note'),
    organizationId?: string(name='OrganizationId'),
    priority?: string(name='Priority'),
    projectId?: string(name='ProjectId'),
    sprintId?: string(name='SprintId'),
    startDate?: string(name='StartDate'),
    storyPoint?: string(name='StoryPoint'),
    taskType?: string(name='TaskType'),
    taskflowstatusId?: string(name='TaskflowstatusId'),
    tasklistId?: string(name='TasklistId'),
    updated?: string(name='Updated'),
    visible?: string(name='Visible'),
  }(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model GetDevopsProjectTaskInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDevopsProjectTaskInfoResponseBody(name='body'),
}

async function getDevopsProjectTaskInfoWithOptions(request: GetDevopsProjectTaskInfoRequest, runtime: Util.RuntimeOptions): GetDevopsProjectTaskInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDevopsProjectTaskInfo',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDevopsProjectTaskInfo(request: GetDevopsProjectTaskInfoRequest): GetDevopsProjectTaskInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDevopsProjectTaskInfoWithOptions(request, runtime);
}

model GetPipelineInstHistoryRequest {
  endTime?: string(name='EndTime'),
  orgId?: string(name='OrgId'),
  pageSize?: long(name='PageSize'),
  pageStart?: long(name='PageStart'),
  pipelineId?: long(name='PipelineId'),
  startTime?: string(name='StartTime'),
  userPk?: string(name='UserPk'),
}

model GetPipelineInstHistoryResponseBody = {
  data?: {
    dataList?: [ 
      {
        createTime?: long(name='CreateTime'),
        creator?: string(name='Creator'),
        deletion?: string(name='Deletion'),
        flowInstId?: int32(name='FlowInstId'),
        flowInstance?: {
          autoDrivenStatus?: boolean(name='AutoDrivenStatus'),
          createTime?: long(name='CreateTime'),
          creator?: string(name='Creator'),
          groups?: [ 
            {
              createTime?: long(name='CreateTime'),
              creator?: string(name='Creator'),
              deleteStatus?: string(name='DeleteStatus'),
              endTime?: long(name='EndTime'),
              flowInstId?: int32(name='FlowInstId'),
              id?: int32(name='Id'),
              idExtent?: int32(name='IdExtent'),
              modifier?: string(name='Modifier'),
              modifyTime?: long(name='ModifyTime'),
              name?: string(name='Name'),
              resultStatus?: string(name='ResultStatus'),
              startTime?: long(name='StartTime'),
              status?: string(name='Status'),
            }
          ](name='Groups'),
          id?: int32(name='Id'),
          modifier?: string(name='Modifier'),
          modifyTime?: long(name='ModifyTime'),
          result?: {
            caches?: string(name='Caches'),
            dateTime?: string(name='DateTime'),
            enginePipelineId?: int32(name='EnginePipelineId'),
            enginePipelineInstId?: int32(name='EnginePipelineInstId'),
            enginePipelineName?: string(name='EnginePipelineName'),
            enginePipelineNumber?: int32(name='EnginePipelineNumber'),
            mixFlowInstId?: string(name='MixFlowInstId'),
            sources?: string(name='Sources'),
            timeStamp?: string(name='TimeStamp'),
            triggerMode?: string(name='TriggerMode'),
          }(name='Result'),
          resultStatus?: string(name='ResultStatus'),
          runningStatus?: string(name='RunningStatus'),
          stageTopo?: string(name='StageTopo'),
          stages?: map[string]any(name='Stages'),
          status?: string(name='Status'),
          statusName?: string(name='StatusName'),
          systemCode?: string(name='SystemCode'),
          systemId?: string(name='SystemId'),
        }(name='FlowInstance'),
        id?: int32(name='Id'),
        instNumber?: int32(name='InstNumber'),
        modifier?: string(name='Modifier'),
        modifyTime?: long(name='ModifyTime'),
        packages?: string(name='Packages'),
        pipelineConfigId?: int32(name='PipelineConfigId'),
        pipelineId?: int32(name='PipelineId'),
        status?: string(name='Status'),
        statusName?: string(name='StatusName'),
        triggerMode?: int32(name='TriggerMode'),
      }
    ](name='DataList'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPipelineInstHistoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPipelineInstHistoryResponseBody(name='body'),
}

async function getPipelineInstHistoryWithOptions(request: GetPipelineInstHistoryRequest, runtime: Util.RuntimeOptions): GetPipelineInstHistoryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pageStart)) {
    body['PageStart'] = request.pageStart;
  }
  if (!Util.isUnset(request.pipelineId)) {
    body['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetPipelineInstHistory',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPipelineInstHistory(request: GetPipelineInstHistoryRequest): GetPipelineInstHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPipelineInstHistoryWithOptions(request, runtime);
}

model GetPipelineInstanceBuildNumberStatusRequest {
  buildNum?: long(name='BuildNum'),
  orgId?: string(name='OrgId'),
  pipelineId?: long(name='PipelineId'),
  userPk?: string(name='UserPk'),
}

model GetPipelineInstanceBuildNumberStatusResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: {
    groups?: [ 
      {
        name?: string(name='Name'),
        stages?: [ 
          {
            components?: [ 
              {
                jobId?: long(name='JobId'),
                name?: string(name='Name'),
                status?: string(name='Status'),
              }
            ](name='Components'),
            sign?: string(name='Sign'),
            status?: string(name='Status'),
          }
        ](name='Stages'),
        status?: string(name='Status'),
      }
    ](name='Groups'),
    status?: string(name='Status'),
  }(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPipelineInstanceBuildNumberStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPipelineInstanceBuildNumberStatusResponseBody(name='body'),
}

async function getPipelineInstanceBuildNumberStatusWithOptions(request: GetPipelineInstanceBuildNumberStatusRequest, runtime: Util.RuntimeOptions): GetPipelineInstanceBuildNumberStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orgId)) {
    query['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.buildNum)) {
    body['BuildNum'] = request.buildNum;
  }
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetPipelineInstanceBuildNumberStatus',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPipelineInstanceBuildNumberStatus(request: GetPipelineInstanceBuildNumberStatusRequest): GetPipelineInstanceBuildNumberStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPipelineInstanceBuildNumberStatusWithOptions(request, runtime);
}

model GetPipelineInstanceGroupStatusRequest {
  flowInstanceId?: long(name='FlowInstanceId'),
  orgId?: string(name='OrgId'),
  pipelineId?: long(name='PipelineId'),
  userPk?: string(name='UserPk'),
}

model GetPipelineInstanceGroupStatusResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: {
    groups?: [ 
      {
        name?: string(name='Name'),
        stages?: [ 
          {
            components?: [ 
              {
                jobId?: string(name='JobId'),
                name?: string(name='Name'),
                status?: string(name='Status'),
              }
            ](name='Components'),
            sign?: string(name='Sign'),
            status?: string(name='Status'),
          }
        ](name='Stages'),
        status?: string(name='Status'),
      }
    ](name='Groups'),
    status?: string(name='Status'),
  }(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPipelineInstanceGroupStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPipelineInstanceGroupStatusResponseBody(name='body'),
}

async function getPipelineInstanceGroupStatusWithOptions(request: GetPipelineInstanceGroupStatusRequest, runtime: Util.RuntimeOptions): GetPipelineInstanceGroupStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orgId)) {
    query['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.flowInstanceId)) {
    body['FlowInstanceId'] = request.flowInstanceId;
  }
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetPipelineInstanceGroupStatus',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPipelineInstanceGroupStatus(request: GetPipelineInstanceGroupStatusRequest): GetPipelineInstanceGroupStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPipelineInstanceGroupStatusWithOptions(request, runtime);
}

model GetPipelineInstanceInfoRequest {
  flowInstanceId?: string(name='FlowInstanceId'),
  orgId?: string(name='OrgId'),
  pipelineId?: long(name='PipelineId'),
  userPk?: string(name='UserPk'),
}

model GetPipelineInstanceInfoResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: {
    dockerImages?: [ string ](name='DockerImages'),
    employeeId?: string(name='EmployeeId'),
    endTime?: long(name='EndTime'),
    packageDownloadUrls?: [ string ](name='PackageDownloadUrls'),
    sources?: string(name='Sources'),
    startTime?: long(name='StartTime'),
    status?: string(name='Status'),
  }(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPipelineInstanceInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPipelineInstanceInfoResponseBody(name='body'),
}

async function getPipelineInstanceInfoWithOptions(request: GetPipelineInstanceInfoRequest, runtime: Util.RuntimeOptions): GetPipelineInstanceInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.flowInstanceId)) {
    body['FlowInstanceId'] = request.flowInstanceId;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    body['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetPipelineInstanceInfo',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPipelineInstanceInfo(request: GetPipelineInstanceInfoRequest): GetPipelineInstanceInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPipelineInstanceInfoWithOptions(request, runtime);
}

model GetPipelineInstanceStatusRequest {
  flowInstanceId?: long(name='FlowInstanceId'),
  orgId?: string(name='OrgId'),
  pipelineId?: long(name='PipelineId'),
  userPk?: string(name='UserPk'),
}

model GetPipelineInstanceStatusResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: string(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPipelineInstanceStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPipelineInstanceStatusResponseBody(name='body'),
}

async function getPipelineInstanceStatusWithOptions(request: GetPipelineInstanceStatusRequest, runtime: Util.RuntimeOptions): GetPipelineInstanceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.flowInstanceId)) {
    query['FlowInstanceId'] = request.flowInstanceId;
  }
  if (!Util.isUnset(request.orgId)) {
    query['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetPipelineInstanceStatus',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPipelineInstanceStatus(request: GetPipelineInstanceStatusRequest): GetPipelineInstanceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPipelineInstanceStatusWithOptions(request, runtime);
}

model GetPipelineLogRequest {
  jobId?: long(name='JobId'),
  orgId?: string(name='OrgId'),
  pipelineId?: long(name='PipelineId'),
  userPk?: string(name='UserPk'),
}

model GetPipelineLogResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: [ 
    {
      actionName?: string(name='ActionName'),
      buildProcessNodes?: [ 
        {
          nodeIndex?: int32(name='NodeIndex'),
          nodeName?: string(name='NodeName'),
          status?: string(name='Status'),
        }
      ](name='BuildProcessNodes'),
      jobId?: long(name='JobId'),
      startTime?: string(name='StartTime'),
    }
  ](name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPipelineLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPipelineLogResponseBody(name='body'),
}

async function getPipelineLogWithOptions(request: GetPipelineLogRequest, runtime: Util.RuntimeOptions): GetPipelineLogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    body['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetPipelineLog',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPipelineLog(request: GetPipelineLogRequest): GetPipelineLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPipelineLogWithOptions(request, runtime);
}

model GetPipelineStepLogRequest {
  jobId?: long(name='JobId'),
  limit?: long(name='Limit'),
  offset?: long(name='Offset'),
  orgId?: string(name='OrgId'),
  pipelineId?: long(name='PipelineId'),
  stepIndex?: string(name='StepIndex'),
  userPk?: string(name='UserPk'),
}

model GetPipelineStepLogResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: {
    last?: int32(name='Last'),
    logs?: string(name='Logs'),
    more?: boolean(name='More'),
  }(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPipelineStepLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPipelineStepLogResponseBody(name='body'),
}

async function getPipelineStepLogWithOptions(request: GetPipelineStepLogRequest, runtime: Util.RuntimeOptions): GetPipelineStepLogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.offset)) {
    body['Offset'] = request.offset;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    body['PipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.stepIndex)) {
    body['StepIndex'] = request.stepIndex;
  }
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetPipelineStepLog',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPipelineStepLog(request: GetPipelineStepLogRequest): GetPipelineStepLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPipelineStepLogWithOptions(request, runtime);
}

model GetPipleineLatestInstanceStatusRequest {
  orgId?: string(name='OrgId'),
  pipelineId?: long(name='PipelineId'),
  userPk?: string(name='UserPk'),
}

model GetPipleineLatestInstanceStatusResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: {
    groups?: [ 
      {
        name?: string(name='Name'),
        stages?: [ 
          {
            components?: [ 
              {
                jobId?: long(name='JobId'),
                name?: string(name='Name'),
                status?: string(name='Status'),
              }
            ](name='Components'),
            sign?: string(name='Sign'),
            status?: string(name='Status'),
          }
        ](name='Stages'),
        status?: string(name='Status'),
      }
    ](name='Groups'),
    status?: string(name='Status'),
  }(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPipleineLatestInstanceStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPipleineLatestInstanceStatusResponseBody(name='body'),
}

async function getPipleineLatestInstanceStatusWithOptions(request: GetPipleineLatestInstanceStatusRequest, runtime: Util.RuntimeOptions): GetPipleineLatestInstanceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orgId)) {
    query['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetPipleineLatestInstanceStatus',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPipleineLatestInstanceStatus(request: GetPipleineLatestInstanceStatusRequest): GetPipleineLatestInstanceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPipleineLatestInstanceStatusWithOptions(request, runtime);
}

model GetProjectOptionRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
  query?: string(name='Query'),
  type?: string(name='Type'),
}

model GetProjectOptionResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: [ 
    {
      kind?: string(name='Kind'),
      name?: string(name='Name'),
      scopeName?: string(name='ScopeName'),
      value?: string(name='Value'),
    }
  ](name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model GetProjectOptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProjectOptionResponseBody(name='body'),
}

async function getProjectOptionWithOptions(request: GetProjectOptionRequest, runtime: Util.RuntimeOptions): GetProjectOptionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.query)) {
    body['Query'] = request.query;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetProjectOption',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProjectOption(request: GetProjectOptionRequest): GetProjectOptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProjectOptionWithOptions(request, runtime);
}

model GetTaskDetailActivityRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
  taskId?: string(name='TaskId'),
}

model GetTaskDetailActivityResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  object?: [ 
    {
      action?: string(name='Action'),
      content?: map[string]any(name='Content'),
      created?: string(name='Created'),
      title?: string(name='Title'),
      updated?: string(name='Updated'),
    }
  ](name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model GetTaskDetailActivityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskDetailActivityResponseBody(name='body'),
}

async function getTaskDetailActivityWithOptions(request: GetTaskDetailActivityRequest, runtime: Util.RuntimeOptions): GetTaskDetailActivityResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskDetailActivity',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTaskDetailActivity(request: GetTaskDetailActivityRequest): GetTaskDetailActivityResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskDetailActivityWithOptions(request, runtime);
}

model GetTaskDetailBaseRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
  taskId?: string(name='TaskId'),
}

model GetTaskDetailBaseResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    accomplished?: string(name='Accomplished'),
    ancestorIds?: [ string ](name='AncestorIds'),
    ancestors?: [ string ](name='Ancestors'),
    attachmentsCount?: int32(name='AttachmentsCount'),
    badges?: {
      attachmentsCount?: int32(name='AttachmentsCount'),
      commentsCount?: int32(name='CommentsCount'),
      likesCount?: int32(name='LikesCount'),
      objectlinksCount?: int32(name='ObjectlinksCount'),
    }(name='Badges'),
    commentsCount?: int32(name='CommentsCount'),
    content?: string(name='Content'),
    created?: string(name='Created'),
    creator?: {
      id?: string(name='Id'),
      name?: string(name='Name'),
    }(name='Creator'),
    creatorId?: string(name='CreatorId'),
    customfields?: [ 
      {
        customfieldId?: string(name='CustomfieldId'),
        type?: string(name='Type'),
        value?: [ 
          {
            id?: string(name='Id'),
            title?: string(name='Title'),
          }
        ](name='Value'),
        values?: [ string ](name='Values'),
      }
    ](name='Customfields'),
    divisions?: [ string ](name='Divisions'),
    dueDate?: string(name='DueDate'),
    executor?: {
      avatarUrl?: string(name='AvatarUrl'),
      id?: string(name='Id'),
      name?: string(name='Name'),
    }(name='Executor'),
    executorId?: string(name='ExecutorId'),
    id?: string(name='Id'),
    involveMembers?: [ string ](name='InvolveMembers'),
    involvers?: [ 
      {
        id?: string(name='Id'),
        name?: string(name='Name'),
      }
    ](name='Involvers'),
    isArchived?: boolean(name='IsArchived'),
    isDone?: boolean(name='IsDone'),
    isFavorite?: boolean(name='IsFavorite'),
    isTopInProject?: boolean(name='IsTopInProject'),
    labels?: [ string ](name='Labels'),
    likesCount?: int32(name='LikesCount'),
    note?: string(name='Note'),
    objectType?: string(name='ObjectType'),
    objectlinksCount?: int32(name='ObjectlinksCount'),
    organization?: string(name='Organization'),
    organizationId?: string(name='OrganizationId'),
    parent?: string(name='Parent'),
    priority?: int32(name='Priority'),
    progress?: int32(name='Progress'),
    projectId?: string(name='ProjectId'),
    rating?: int32(name='Rating'),
    recurrence?: string(name='Recurrence'),
    reminder?: {
      creatorId?: string(name='CreatorId'),
      date?: string(name='Date'),
      memberRoles?: [ string ](name='MemberRoles'),
      members?: [ string ](name='Members'),
      method?: string(name='Method'),
      rules?: [ string ](name='Rules'),
      type?: string(name='Type'),
    }(name='Reminder'),
    scenariofieldconfig?: {
      icon?: string(name='Icon'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      proTemplateConfigType?: string(name='ProTemplateConfigType'),
    }(name='Scenariofieldconfig'),
    scenariofieldconfigId?: string(name='ScenariofieldconfigId'),
    shareStatus?: int32(name='ShareStatus'),
    source?: string(name='Source'),
    sourceDate?: string(name='SourceDate'),
    sourceId?: string(name='SourceId'),
    sprint?: string(name='Sprint'),
    sprintId?: string(name='SprintId'),
    stage?: {
      id?: string(name='Id'),
      name?: string(name='Name'),
    }(name='Stage'),
    stageId?: string(name='StageId'),
    startDate?: string(name='StartDate'),
    storyPoint?: string(name='StoryPoint'),
    subtaskCount?: {
      done?: int32(name='Done'),
      total?: int32(name='Total'),
    }(name='SubtaskCount'),
    subtasks?: [ 
      {
        content?: string(name='Content'),
        id?: string(name='Id'),
      }
    ](name='Subtasks'),
    tagIds?: [ string ](name='TagIds'),
    taskId?: string(name='TaskId'),
    taskflowstatus?: {
      id?: string(name='Id'),
      kind?: string(name='Kind'),
      name?: string(name='Name'),
      taskflowId?: string(name='TaskflowId'),
    }(name='Taskflowstatus'),
    taskflowstatusId?: string(name='TaskflowstatusId'),
    tasklist?: {
      id?: string(name='Id'),
      title?: string(name='Title'),
    }(name='Tasklist'),
    uniqueId?: int32(name='UniqueId'),
    untilDate?: string(name='UntilDate'),
    updated?: string(name='Updated'),
    visible?: string(name='Visible'),
    workTime?: {
      totalTime?: int32(name='TotalTime'),
      unit?: string(name='Unit'),
      usedTime?: int32(name='UsedTime'),
    }(name='WorkTime'),
  }(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model GetTaskDetailBaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskDetailBaseResponseBody(name='body'),
}

async function getTaskDetailBaseWithOptions(request: GetTaskDetailBaseRequest, runtime: Util.RuntimeOptions): GetTaskDetailBaseResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskDetailBase',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTaskDetailBase(request: GetTaskDetailBaseRequest): GetTaskDetailBaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskDetailBaseWithOptions(request, runtime);
}

model GetTaskListFilterRequest {
  creatorId?: string(name='CreatorId'),
  dueDateEnd?: string(name='DueDateEnd'),
  dueDateStart?: string(name='DueDateStart'),
  executorId?: string(name='ExecutorId'),
  extra?: string(name='Extra'),
  involveMembers?: string(name='InvolveMembers'),
  isDone?: boolean(name='IsDone'),
  name?: string(name='Name'),
  objectType?: string(name='ObjectType'),
  order?: string(name='Order'),
  orderCondition?: string(name='OrderCondition'),
  orgId?: string(name='OrgId'),
  pageSize?: int32(name='PageSize'),
  pageToken?: string(name='PageToken'),
  priority?: string(name='Priority'),
  projectId?: string(name='ProjectId'),
  scenarioFieldConfigId?: string(name='ScenarioFieldConfigId'),
  sprintId?: string(name='SprintId'),
  tagId?: string(name='TagId'),
  taskFlowStatusId?: string(name='TaskFlowStatusId'),
}

model GetTaskListFilterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    nextPageToken?: string(name='NextPageToken'),
    result?: [ 
      {
        accomplished?: string(name='Accomplished'),
        ancestorIds?: [ string ](name='AncestorIds'),
        attachmentsCount?: int32(name='AttachmentsCount'),
        badges?: {
          attachmentsCount?: int32(name='AttachmentsCount'),
          commentsCount?: int32(name='CommentsCount'),
          likesCount?: int32(name='LikesCount'),
          objectlinksCount?: int32(name='ObjectlinksCount'),
        }(name='Badges'),
        commentsCount?: int32(name='CommentsCount'),
        content?: string(name='Content'),
        created?: string(name='Created'),
        creator?: {
          avatarUrl?: string(name='AvatarUrl'),
          id?: string(name='Id'),
          name?: string(name='Name'),
        }(name='Creator'),
        creatorId?: string(name='CreatorId'),
        customfields?: [ 
          {
            customfieldId?: string(name='CustomfieldId'),
            type?: string(name='Type'),
            value?: [ 
              {
                id?: string(name='Id'),
                title?: string(name='Title'),
              }
            ](name='Value'),
            values?: string(name='Values'),
          }
        ](name='Customfields'),
        divisions?: [ string ](name='Divisions'),
        dueDate?: string(name='DueDate'),
        executor?: {
          avatarUrl?: string(name='AvatarUrl'),
          id?: string(name='Id'),
          name?: string(name='Name'),
        }(name='Executor'),
        executorId?: string(name='ExecutorId'),
        id?: string(name='Id'),
        involveMembers?: [ string ](name='InvolveMembers'),
        isArchived?: boolean(name='IsArchived'),
        isDone?: boolean(name='IsDone'),
        isFavorite?: boolean(name='IsFavorite'),
        isTopInProject?: boolean(name='IsTopInProject'),
        labels?: [ string ](name='Labels'),
        likesCount?: int32(name='LikesCount'),
        note?: string(name='Note'),
        objectType?: string(name='ObjectType'),
        objectlinksCount?: int32(name='ObjectlinksCount'),
        organizationId?: string(name='OrganizationId'),
        parent?: string(name='Parent'),
        priority?: int32(name='Priority'),
        progress?: int32(name='Progress'),
        projectId?: string(name='ProjectId'),
        rating?: int32(name='Rating'),
        recurrence?: string(name='Recurrence'),
        reminder?: {
          creatorId?: string(name='CreatorId'),
          date?: string(name='Date'),
          members?: [ string ](name='Members'),
          rules?: [ string ](name='Rules'),
          type?: string(name='Type'),
        }(name='Reminder'),
        scenariofFeldConfigId?: string(name='ScenariofFeldConfigId'),
        shareStatus?: int32(name='ShareStatus'),
        source?: string(name='Source'),
        sourceDate?: string(name='SourceDate'),
        sourceId?: string(name='SourceId'),
        sprint?: string(name='Sprint'),
        sprintId?: string(name='SprintId'),
        stage?: {
          id?: string(name='Id'),
          name?: string(name='Name'),
        }(name='Stage'),
        stageId?: string(name='StageId'),
        startDate?: string(name='StartDate'),
        storyPoint?: string(name='StoryPoint'),
        subtaskCount?: {
          done?: int32(name='Done'),
          total?: int32(name='Total'),
        }(name='SubtaskCount'),
        tagIds?: [ string ](name='TagIds'),
        taskFlowStatus?: {
          id?: string(name='Id'),
          kind?: string(name='Kind'),
          name?: string(name='Name'),
          pos?: int32(name='Pos'),
          taskFlowId?: string(name='TaskFlowId'),
        }(name='TaskFlowStatus'),
        taskFlowStatusId?: string(name='TaskFlowStatusId'),
        taskId?: string(name='TaskId'),
        taskListId?: string(name='TaskListId'),
        taskUniqueId?: string(name='TaskUniqueId'),
        uniqueId?: int32(name='UniqueId'),
        untilDate?: string(name='UntilDate'),
        updated?: string(name='Updated'),
        visible?: string(name='Visible'),
        workTime?: {
          totalTime?: int32(name='TotalTime'),
          unit?: string(name='Unit'),
          usedTime?: int32(name='UsedTime'),
        }(name='WorkTime'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
  }(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: string(name='Successful'),
}

model GetTaskListFilterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskListFilterResponseBody(name='body'),
}

async function getTaskListFilterWithOptions(request: GetTaskListFilterRequest, runtime: Util.RuntimeOptions): GetTaskListFilterResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.creatorId)) {
    body['CreatorId'] = request.creatorId;
  }
  if (!Util.isUnset(request.dueDateEnd)) {
    body['DueDateEnd'] = request.dueDateEnd;
  }
  if (!Util.isUnset(request.dueDateStart)) {
    body['DueDateStart'] = request.dueDateStart;
  }
  if (!Util.isUnset(request.executorId)) {
    body['ExecutorId'] = request.executorId;
  }
  if (!Util.isUnset(request.extra)) {
    body['Extra'] = request.extra;
  }
  if (!Util.isUnset(request.involveMembers)) {
    body['InvolveMembers'] = request.involveMembers;
  }
  if (!Util.isUnset(request.isDone)) {
    body['IsDone'] = request.isDone;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.objectType)) {
    body['ObjectType'] = request.objectType;
  }
  if (!Util.isUnset(request.order)) {
    body['Order'] = request.order;
  }
  if (!Util.isUnset(request.orderCondition)) {
    body['OrderCondition'] = request.orderCondition;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pageToken)) {
    body['PageToken'] = request.pageToken;
  }
  if (!Util.isUnset(request.priority)) {
    body['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.scenarioFieldConfigId)) {
    body['ScenarioFieldConfigId'] = request.scenarioFieldConfigId;
  }
  if (!Util.isUnset(request.sprintId)) {
    body['SprintId'] = request.sprintId;
  }
  if (!Util.isUnset(request.tagId)) {
    body['TagId'] = request.tagId;
  }
  if (!Util.isUnset(request.taskFlowStatusId)) {
    body['TaskFlowStatusId'] = request.taskFlowStatusId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskListFilter',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTaskListFilter(request: GetTaskListFilterRequest): GetTaskListFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskListFilterWithOptions(request, runtime);
}

model InsertPipelineMemberRequest {
  orgId?: string(name='OrgId'),
  pipelineId?: long(name='PipelineId'),
  roleName?: string(name='RoleName'),
  userId?: string(name='UserId'),
  userPk?: string(name='UserPk'),
}

model InsertPipelineMemberResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: boolean(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InsertPipelineMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InsertPipelineMemberResponseBody(name='body'),
}

async function insertPipelineMemberWithOptions(request: InsertPipelineMemberRequest, runtime: Util.RuntimeOptions): InsertPipelineMemberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orgId)) {
    query['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.roleName)) {
    body['RoleName'] = request.roleName;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'InsertPipelineMember',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function insertPipelineMember(request: InsertPipelineMemberRequest): InsertPipelineMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertPipelineMemberWithOptions(request, runtime);
}

model InsertProjectMembersRequest {
  members?: string(name='Members'),
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
}

model InsertProjectMembersResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: boolean(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model InsertProjectMembersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InsertProjectMembersResponseBody(name='body'),
}

async function insertProjectMembersWithOptions(request: InsertProjectMembersRequest, runtime: Util.RuntimeOptions): InsertProjectMembersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.members)) {
    body['Members'] = request.members;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'InsertProjectMembers',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function insertProjectMembers(request: InsertProjectMembersRequest): InsertProjectMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertProjectMembersWithOptions(request, runtime);
}

model ListCommonGroupRequest {
  all?: boolean(name='All'),
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
  smartGroupId?: string(name='SmartGroupId'),
}

model ListCommonGroupResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: [ 
    {
      creatorId?: string(name='CreatorId'),
      isRoot?: boolean(name='IsRoot'),
      name?: string(name='Name'),
      pinyin?: string(name='Pinyin'),
      pos?: int32(name='Pos'),
      projectId?: string(name='ProjectId'),
      resourceCount?: int32(name='ResourceCount'),
      smartGroupId?: string(name='SmartGroupId'),
      id?: string(name='id'),
    }
  ](name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model ListCommonGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCommonGroupResponseBody(name='body'),
}

async function listCommonGroupWithOptions(request: ListCommonGroupRequest, runtime: Util.RuntimeOptions): ListCommonGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    body['All'] = request.all;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.smartGroupId)) {
    body['SmartGroupId'] = request.smartGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListCommonGroup',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCommonGroup(request: ListCommonGroupRequest): ListCommonGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCommonGroupWithOptions(request, runtime);
}

model ListCredentialsRequest {
  orgId?: string(name='OrgId'),
  userPk?: string(name='UserPk'),
}

model ListCredentialsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: [  map[string]any ](name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListCredentialsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCredentialsResponseBody(name='body'),
}

async function listCredentialsWithOptions(request: ListCredentialsRequest, runtime: Util.RuntimeOptions): ListCredentialsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListCredentials',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCredentials(request: ListCredentialsRequest): ListCredentialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCredentialsWithOptions(request, runtime);
}

model ListDevopsProjectSprintsRequest {
  orgId?: string(name='OrgId'),
  pageSize?: long(name='PageSize'),
  pageToken?: string(name='PageToken'),
  projectId?: string(name='ProjectId'),
}

model ListDevopsProjectSprintsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  nextPageToken?: string(name='NextPageToken'),
  object?: [ 
    {
      accomplished?: string(name='Accomplished'),
      created?: string(name='Created'),
      creatorId?: string(name='CreatorId'),
      dueDate?: string(name='DueDate'),
      id?: string(name='Id'),
      isDeleted?: boolean(name='IsDeleted'),
      name?: string(name='Name'),
      planToDo?: {
        storyPoints?: int32(name='StoryPoints'),
        tasks?: int32(name='Tasks'),
        workTimes?: int32(name='WorkTimes'),
      }(name='PlanToDo'),
      projectId?: string(name='ProjectId'),
      startDate?: string(name='StartDate'),
      status?: string(name='Status'),
      updated?: string(name='Updated'),
    }
  ](name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model ListDevopsProjectSprintsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDevopsProjectSprintsResponseBody(name='body'),
}

async function listDevopsProjectSprintsWithOptions(request: ListDevopsProjectSprintsRequest, runtime: Util.RuntimeOptions): ListDevopsProjectSprintsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pageToken)) {
    body['PageToken'] = request.pageToken;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDevopsProjectSprints',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDevopsProjectSprints(request: ListDevopsProjectSprintsRequest): ListDevopsProjectSprintsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDevopsProjectSprintsWithOptions(request, runtime);
}

model ListDevopsProjectTaskFlowRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
}

model ListDevopsProjectTaskFlowResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      type?: string(name='Type'),
    }
  ](name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model ListDevopsProjectTaskFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDevopsProjectTaskFlowResponseBody(name='body'),
}

async function listDevopsProjectTaskFlowWithOptions(request: ListDevopsProjectTaskFlowRequest, runtime: Util.RuntimeOptions): ListDevopsProjectTaskFlowResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDevopsProjectTaskFlow',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDevopsProjectTaskFlow(request: ListDevopsProjectTaskFlowRequest): ListDevopsProjectTaskFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDevopsProjectTaskFlowWithOptions(request, runtime);
}

model ListDevopsProjectTaskFlowStatusRequest {
  orgId?: string(name='OrgId'),
  taskFlowId?: string(name='TaskFlowId'),
}

model ListDevopsProjectTaskFlowStatusResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: [ 
    {
      created?: string(name='Created'),
      creatorId?: string(name='CreatorId'),
      id?: string(name='Id'),
      isDeleted?: boolean(name='IsDeleted'),
      kind?: string(name='Kind'),
      name?: string(name='Name'),
      pos?: int32(name='Pos'),
      rejectStatusIds?: string(name='RejectStatusIds'),
      taskflowId?: string(name='TaskflowId'),
      updated?: string(name='Updated'),
    }
  ](name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model ListDevopsProjectTaskFlowStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDevopsProjectTaskFlowStatusResponseBody(name='body'),
}

async function listDevopsProjectTaskFlowStatusWithOptions(request: ListDevopsProjectTaskFlowStatusRequest, runtime: Util.RuntimeOptions): ListDevopsProjectTaskFlowStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.taskFlowId)) {
    body['TaskFlowId'] = request.taskFlowId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDevopsProjectTaskFlowStatus',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDevopsProjectTaskFlowStatus(request: ListDevopsProjectTaskFlowStatusRequest): ListDevopsProjectTaskFlowStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDevopsProjectTaskFlowStatusWithOptions(request, runtime);
}

model ListDevopsProjectTaskListRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
}

model ListDevopsProjectTaskListResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    result?: [ 
      {
        id?: string(name='Id'),
      }
    ](name='Result'),
  }(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model ListDevopsProjectTaskListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDevopsProjectTaskListResponseBody(name='body'),
}

async function listDevopsProjectTaskListWithOptions(request: ListDevopsProjectTaskListRequest, runtime: Util.RuntimeOptions): ListDevopsProjectTaskListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDevopsProjectTaskList',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDevopsProjectTaskList(request: ListDevopsProjectTaskListRequest): ListDevopsProjectTaskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDevopsProjectTaskListWithOptions(request, runtime);
}

model ListDevopsProjectsRequest {
  orderBy?: string(name='OrderBy'),
  orgId?: string(name='OrgId'),
  pageSize?: int32(name='PageSize'),
  pageToken?: string(name='PageToken'),
  selectBy?: string(name='SelectBy'),
}

model ListDevopsProjectsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    nextPageToken?: string(name='NextPageToken'),
    result?: [ 
      {
        created?: string(name='Created'),
        creatorId?: string(name='CreatorId'),
        description?: string(name='Description'),
        id?: string(name='Id'),
        isArchived?: boolean(name='IsArchived'),
        isPublic?: boolean(name='IsPublic'),
        isStar?: boolean(name='IsStar'),
        isTemplate?: boolean(name='IsTemplate'),
        logo?: string(name='Logo'),
        membersCount?: int32(name='MembersCount'),
        name?: string(name='Name'),
        organizationId?: string(name='OrganizationId'),
        roleId?: string(name='RoleId'),
        tasksCount?: int32(name='TasksCount'),
        updated?: string(name='Updated'),
        visibility?: string(name='Visibility'),
      }
    ](name='Result'),
  }(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model ListDevopsProjectsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDevopsProjectsResponseBody(name='body'),
}

async function listDevopsProjectsWithOptions(request: ListDevopsProjectsRequest, runtime: Util.RuntimeOptions): ListDevopsProjectsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orderBy)) {
    body['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pageToken)) {
    body['PageToken'] = request.pageToken;
  }
  if (!Util.isUnset(request.selectBy)) {
    body['SelectBy'] = request.selectBy;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDevopsProjects',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDevopsProjects(request: ListDevopsProjectsRequest): ListDevopsProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDevopsProjectsWithOptions(request, runtime);
}

model ListDevopsScenarioFieldConfigRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
}

model ListDevopsScenarioFieldConfigResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      type?: string(name='Type'),
    }
  ](name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model ListDevopsScenarioFieldConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDevopsScenarioFieldConfigResponseBody(name='body'),
}

async function listDevopsScenarioFieldConfigWithOptions(request: ListDevopsScenarioFieldConfigRequest, runtime: Util.RuntimeOptions): ListDevopsScenarioFieldConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDevopsScenarioFieldConfig',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDevopsScenarioFieldConfig(request: ListDevopsScenarioFieldConfigRequest): ListDevopsScenarioFieldConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDevopsScenarioFieldConfigWithOptions(request, runtime);
}

model ListPipelineTemplatesRequest {
  orgId?: string(name='OrgId'),
  pageNum?: int32(name='PageNum'),
  pageStart?: int32(name='PageStart'),
}

model ListPipelineTemplatesResponseBody = {
  data?: {
    dataList?: [ 
      {
        id?: long(name='Id'),
        templateName?: string(name='TemplateName'),
      }
    ](name='DataList'),
    total?: float(name='Total'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListPipelineTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPipelineTemplatesResponseBody(name='body'),
}

async function listPipelineTemplatesWithOptions(request: ListPipelineTemplatesRequest, runtime: Util.RuntimeOptions): ListPipelineTemplatesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPipelineTemplates',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPipelineTemplates(request: ListPipelineTemplatesRequest): ListPipelineTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPipelineTemplatesWithOptions(request, runtime);
}

model ListPipelinesRequest {
  createEndTime?: string(name='CreateEndTime'),
  createStartTime?: string(name='CreateStartTime'),
  creators?: string(name='Creators'),
  executeEndTime?: string(name='ExecuteEndTime'),
  executeStartTime?: string(name='ExecuteStartTime'),
  operators?: string(name='Operators'),
  orgId?: string(name='OrgId'),
  pageSize?: int32(name='PageSize'),
  pageStart?: int32(name='PageStart'),
  pipelineName?: string(name='PipelineName'),
  resultStatusList?: string(name='ResultStatusList'),
  userPk?: string(name='UserPk'),
}

model ListPipelinesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: map[string]any(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListPipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPipelinesResponseBody(name='body'),
}

async function listPipelinesWithOptions(request: ListPipelinesRequest, runtime: Util.RuntimeOptions): ListPipelinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orgId)) {
    query['OrgId'] = request.orgId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.createEndTime)) {
    body['CreateEndTime'] = request.createEndTime;
  }
  if (!Util.isUnset(request.createStartTime)) {
    body['CreateStartTime'] = request.createStartTime;
  }
  if (!Util.isUnset(request.creators)) {
    body['Creators'] = request.creators;
  }
  if (!Util.isUnset(request.executeEndTime)) {
    body['ExecuteEndTime'] = request.executeEndTime;
  }
  if (!Util.isUnset(request.executeStartTime)) {
    body['ExecuteStartTime'] = request.executeStartTime;
  }
  if (!Util.isUnset(request.operators)) {
    body['Operators'] = request.operators;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pageStart)) {
    body['PageStart'] = request.pageStart;
  }
  if (!Util.isUnset(request.pipelineName)) {
    body['PipelineName'] = request.pipelineName;
  }
  if (!Util.isUnset(request.resultStatusList)) {
    body['ResultStatusList'] = request.resultStatusList;
  }
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPipelines',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPipelines(request: ListPipelinesRequest): ListPipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPipelinesWithOptions(request, runtime);
}

model ListProjectCustomFieldsRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
}

model ListProjectCustomFieldsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: [ 
    {
      customFieldId?: string(name='CustomFieldId'),
      name?: string(name='Name'),
      subtype?: string(name='Subtype'),
      type?: string(name='Type'),
      values?: [ 
        {
          id?: string(name='Id'),
          value?: string(name='Value'),
        }
      ](name='Values'),
    }
  ](name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model ListProjectCustomFieldsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProjectCustomFieldsResponseBody(name='body'),
}

async function listProjectCustomFieldsWithOptions(request: ListProjectCustomFieldsRequest, runtime: Util.RuntimeOptions): ListProjectCustomFieldsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListProjectCustomFields',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProjectCustomFields(request: ListProjectCustomFieldsRequest): ListProjectCustomFieldsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectCustomFieldsWithOptions(request, runtime);
}

model ListServiceConnectionsRequest {
  orgId?: string(name='OrgId'),
  scType?: string(name='ScType'),
  userPk?: string(name='UserPk'),
}

model ListServiceConnectionsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: [  map[string]any ](name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListServiceConnectionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceConnectionsResponseBody(name='body'),
}

async function listServiceConnectionsWithOptions(request: ListServiceConnectionsRequest, runtime: Util.RuntimeOptions): ListServiceConnectionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.scType)) {
    body['ScType'] = request.scType;
  }
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceConnections',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServiceConnections(request: ListServiceConnectionsRequest): ListServiceConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServiceConnectionsWithOptions(request, runtime);
}

model ListSmartGroupRequest {
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
}

model ListSmartGroupResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: [ 
    {
      id?: string(name='Id'),
      type?: string(name='Type'),
    }
  ](name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model ListSmartGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSmartGroupResponseBody(name='body'),
}

async function listSmartGroupWithOptions(request: ListSmartGroupRequest, runtime: Util.RuntimeOptions): ListSmartGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListSmartGroup',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSmartGroup(request: ListSmartGroupRequest): ListSmartGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSmartGroupWithOptions(request, runtime);
}

model ListUserOrganizationRequest {
  realPk?: string(name='RealPk'),
}

model ListUserOrganizationResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
    }
  ](name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListUserOrganizationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserOrganizationResponseBody(name='body'),
}

async function listUserOrganizationWithOptions(request: ListUserOrganizationRequest, runtime: Util.RuntimeOptions): ListUserOrganizationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.realPk)) {
    body['RealPk'] = request.realPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListUserOrganization',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserOrganization(request: ListUserOrganizationRequest): ListUserOrganizationResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserOrganizationWithOptions(request, runtime);
}

model TransferPipelineOwnerRequest {
  newOwnerId?: string(name='NewOwnerId'),
  orgId?: string(name='OrgId'),
  pipelineId?: long(name='PipelineId'),
  userPk?: string(name='UserPk'),
}

model TransferPipelineOwnerResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: map[string]any(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model TransferPipelineOwnerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransferPipelineOwnerResponseBody(name='body'),
}

async function transferPipelineOwnerWithOptions(request: TransferPipelineOwnerRequest, runtime: Util.RuntimeOptions): TransferPipelineOwnerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orgId)) {
    query['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.newOwnerId)) {
    body['NewOwnerId'] = request.newOwnerId;
  }
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TransferPipelineOwner',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function transferPipelineOwner(request: TransferPipelineOwnerRequest): TransferPipelineOwnerResponse {
  var runtime = new Util.RuntimeOptions{};
  return transferPipelineOwnerWithOptions(request, runtime);
}

model UpdateCommonGroupRequest {
  commonGroupId?: string(name='CommonGroupId'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
  smartGroupId?: string(name='SmartGroupId'),
}

model UpdateCommonGroupResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: {
    id?: string(name='Id'),
  }(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model UpdateCommonGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCommonGroupResponseBody(name='body'),
}

async function updateCommonGroupWithOptions(request: UpdateCommonGroupRequest, runtime: Util.RuntimeOptions): UpdateCommonGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.commonGroupId)) {
    body['CommonGroupId'] = request.commonGroupId;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.smartGroupId)) {
    body['SmartGroupId'] = request.smartGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCommonGroup',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCommonGroup(request: UpdateCommonGroupRequest): UpdateCommonGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCommonGroupWithOptions(request, runtime);
}

model UpdateDevopsProjectRequest {
  description?: string(name='Description'),
  name?: string(name='Name'),
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
}

model UpdateDevopsProjectResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: string(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDevopsProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDevopsProjectResponseBody(name='body'),
}

async function updateDevopsProjectWithOptions(request: UpdateDevopsProjectRequest, runtime: Util.RuntimeOptions): UpdateDevopsProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDevopsProject',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDevopsProject(request: UpdateDevopsProjectRequest): UpdateDevopsProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDevopsProjectWithOptions(request, runtime);
}

model UpdateDevopsProjectSprintRequest {
  description?: string(name='Description'),
  dueDate?: string(name='DueDate'),
  executorId?: string(name='ExecutorId'),
  name?: string(name='Name'),
  orgId?: string(name='OrgId'),
  projectId?: string(name='ProjectId'),
  sprintId?: string(name='SprintId'),
  startDate?: string(name='StartDate'),
}

model UpdateDevopsProjectSprintResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: boolean(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model UpdateDevopsProjectSprintResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDevopsProjectSprintResponseBody(name='body'),
}

async function updateDevopsProjectSprintWithOptions(request: UpdateDevopsProjectSprintRequest, runtime: Util.RuntimeOptions): UpdateDevopsProjectSprintResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.dueDate)) {
    body['DueDate'] = request.dueDate;
  }
  if (!Util.isUnset(request.executorId)) {
    body['ExecutorId'] = request.executorId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.sprintId)) {
    body['SprintId'] = request.sprintId;
  }
  if (!Util.isUnset(request.startDate)) {
    body['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDevopsProjectSprint',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDevopsProjectSprint(request: UpdateDevopsProjectSprintRequest): UpdateDevopsProjectSprintResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDevopsProjectSprintWithOptions(request, runtime);
}

model UpdateDevopsProjectTaskRequest {
  content?: string(name='Content'),
  dueDate?: string(name='DueDate'),
  executorId?: string(name='ExecutorId'),
  note?: string(name='Note'),
  orgId?: string(name='OrgId'),
  parentTaskId?: string(name='ParentTaskId'),
  priority?: int32(name='Priority'),
  projectId?: string(name='ProjectId'),
  scenarioFiieldConfigId?: string(name='ScenarioFiieldConfigId'),
  sprintId?: string(name='SprintId'),
  startDate?: string(name='StartDate'),
  taskFlowStatusId?: string(name='TaskFlowStatusId'),
  taskId?: string(name='TaskId'),
  visible?: string(name='Visible'),
}

model UpdateDevopsProjectTaskResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: boolean(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model UpdateDevopsProjectTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDevopsProjectTaskResponseBody(name='body'),
}

async function updateDevopsProjectTaskWithOptions(request: UpdateDevopsProjectTaskRequest, runtime: Util.RuntimeOptions): UpdateDevopsProjectTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.dueDate)) {
    body['DueDate'] = request.dueDate;
  }
  if (!Util.isUnset(request.executorId)) {
    body['ExecutorId'] = request.executorId;
  }
  if (!Util.isUnset(request.note)) {
    body['Note'] = request.note;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.parentTaskId)) {
    body['ParentTaskId'] = request.parentTaskId;
  }
  if (!Util.isUnset(request.priority)) {
    body['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.scenarioFiieldConfigId)) {
    body['ScenarioFiieldConfigId'] = request.scenarioFiieldConfigId;
  }
  if (!Util.isUnset(request.sprintId)) {
    body['SprintId'] = request.sprintId;
  }
  if (!Util.isUnset(request.startDate)) {
    body['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.taskFlowStatusId)) {
    body['TaskFlowStatusId'] = request.taskFlowStatusId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.visible)) {
    body['Visible'] = request.visible;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDevopsProjectTask',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDevopsProjectTask(request: UpdateDevopsProjectTaskRequest): UpdateDevopsProjectTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDevopsProjectTaskWithOptions(request, runtime);
}

model UpdatePipelineEnvVarsRequest {
  envVars?: string(name='EnvVars'),
  orgId?: string(name='OrgId'),
  pipelineId?: long(name='PipelineId'),
}

model UpdatePipelineEnvVarsResponseBody = {
  pipelineId?: long(name='PipelineId'),
  requestId?: string(name='RequestId'),
}

model UpdatePipelineEnvVarsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePipelineEnvVarsResponseBody(name='body'),
}

async function updatePipelineEnvVarsWithOptions(request: UpdatePipelineEnvVarsRequest, runtime: Util.RuntimeOptions): UpdatePipelineEnvVarsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.envVars)) {
    query['EnvVars'] = request.envVars;
  }
  if (!Util.isUnset(request.orgId)) {
    query['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePipelineEnvVars',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePipelineEnvVars(request: UpdatePipelineEnvVarsRequest): UpdatePipelineEnvVarsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePipelineEnvVarsWithOptions(request, runtime);
}

model UpdatePipelineMemberRequest {
  orgId?: string(name='OrgId'),
  pipelineId?: long(name='PipelineId'),
  roleName?: string(name='RoleName'),
  userId?: string(name='UserId'),
  userPk?: string(name='UserPk'),
}

model UpdatePipelineMemberResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  object?: boolean(name='Object'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdatePipelineMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePipelineMemberResponseBody(name='body'),
}

async function updatePipelineMemberWithOptions(request: UpdatePipelineMemberRequest, runtime: Util.RuntimeOptions): UpdatePipelineMemberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orgId)) {
    query['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.roleName)) {
    body['RoleName'] = request.roleName;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userPk)) {
    body['UserPk'] = request.userPk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePipelineMember',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePipelineMember(request: UpdatePipelineMemberRequest): UpdatePipelineMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePipelineMemberWithOptions(request, runtime);
}

model UpdateTaskDetailRequest {
  addInvolvers?: string(name='AddInvolvers'),
  content?: string(name='Content'),
  customFieldId?: string(name='CustomFieldId'),
  customFieldValues?: string(name='CustomFieldValues'),
  delInvolvers?: string(name='DelInvolvers'),
  dueDate?: string(name='DueDate'),
  executorId?: string(name='ExecutorId'),
  note?: string(name='Note'),
  orgId?: string(name='OrgId'),
  priority?: long(name='Priority'),
  projectId?: string(name='ProjectId'),
  sprintId?: string(name='SprintId'),
  startDate?: string(name='StartDate'),
  storyPoint?: string(name='StoryPoint'),
  tagIds?: string(name='TagIds'),
  taskFlowStatusId?: string(name='TaskFlowStatusId'),
  taskId?: string(name='TaskId'),
  workTimes?: long(name='WorkTimes'),
}

model UpdateTaskDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  object?: boolean(name='Object'),
  requestId?: string(name='RequestId'),
  successful?: boolean(name='Successful'),
}

model UpdateTaskDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTaskDetailResponseBody(name='body'),
}

async function updateTaskDetailWithOptions(request: UpdateTaskDetailRequest, runtime: Util.RuntimeOptions): UpdateTaskDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.addInvolvers)) {
    body['AddInvolvers'] = request.addInvolvers;
  }
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.customFieldId)) {
    body['CustomFieldId'] = request.customFieldId;
  }
  if (!Util.isUnset(request.customFieldValues)) {
    body['CustomFieldValues'] = request.customFieldValues;
  }
  if (!Util.isUnset(request.delInvolvers)) {
    body['DelInvolvers'] = request.delInvolvers;
  }
  if (!Util.isUnset(request.dueDate)) {
    body['DueDate'] = request.dueDate;
  }
  if (!Util.isUnset(request.executorId)) {
    body['ExecutorId'] = request.executorId;
  }
  if (!Util.isUnset(request.note)) {
    body['Note'] = request.note;
  }
  if (!Util.isUnset(request.orgId)) {
    body['OrgId'] = request.orgId;
  }
  if (!Util.isUnset(request.priority)) {
    body['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.sprintId)) {
    body['SprintId'] = request.sprintId;
  }
  if (!Util.isUnset(request.startDate)) {
    body['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.storyPoint)) {
    body['StoryPoint'] = request.storyPoint;
  }
  if (!Util.isUnset(request.tagIds)) {
    body['TagIds'] = request.tagIds;
  }
  if (!Util.isUnset(request.taskFlowStatusId)) {
    body['TaskFlowStatusId'] = request.taskFlowStatusId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.workTimes)) {
    body['WorkTimes'] = request.workTimes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTaskDetail',
    version = '2020-03-03',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTaskDetail(request: UpdateTaskDetailRequest): UpdateTaskDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTaskDetailWithOptions(request, runtime);
}

