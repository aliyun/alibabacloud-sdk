/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'datalake-daily.aliyuncs.com',
    ap-northeast-2-pop = 'datalake-daily.aliyuncs.com',
    ap-south-1 = 'datalake-daily.aliyuncs.com',
    ap-southeast-1 = 'datalake-daily.aliyuncs.com',
    ap-southeast-2 = 'datalake-daily.aliyuncs.com',
    ap-southeast-3 = 'datalake-daily.aliyuncs.com',
    ap-southeast-5 = 'datalake-daily.aliyuncs.com',
    cn-beijing = 'dlf.cn-beijing.aliyuncs.com',
    cn-beijing-finance-1 = 'datalake-daily.aliyuncs.com',
    cn-beijing-finance-pop = 'datalake-daily.aliyuncs.com',
    cn-beijing-gov-1 = 'datalake-daily.aliyuncs.com',
    cn-beijing-nu16-b01 = 'datalake-daily.aliyuncs.com',
    cn-chengdu = 'datalake-daily.aliyuncs.com',
    cn-edge-1 = 'datalake-daily.aliyuncs.com',
    cn-fujian = 'datalake-daily.aliyuncs.com',
    cn-haidian-cm12-c01 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou = 'dlf.cn-hangzhou.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-finance = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-test-306 = 'datalake-daily.aliyuncs.com',
    cn-hongkong = 'datalake-daily.aliyuncs.com',
    cn-hongkong-finance-pop = 'datalake-daily.aliyuncs.com',
    cn-huhehaote = 'datalake-daily.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'datalake-daily.aliyuncs.com',
    cn-north-2-gov-1 = 'datalake-daily.aliyuncs.com',
    cn-qingdao = 'datalake-daily.aliyuncs.com',
    cn-qingdao-nebula = 'datalake-daily.aliyuncs.com',
    cn-shanghai = 'dlf.cn-shanghai.aliyuncs.com',
    cn-shanghai-et15-b01 = 'datalake-daily.aliyuncs.com',
    cn-shanghai-et2-b01 = 'datalake-daily.aliyuncs.com',
    cn-shanghai-finance-1 = 'datalake-daily.aliyuncs.com',
    cn-shanghai-inner = 'datalake-daily.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'datalake-daily.aliyuncs.com',
    cn-shenzhen = 'dlf.cn-shenzhen.aliyuncs.com',
    cn-shenzhen-finance-1 = 'datalake-daily.aliyuncs.com',
    cn-shenzhen-inner = 'datalake-daily.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'datalake-daily.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'datalake-daily.aliyuncs.com',
    cn-wuhan = 'datalake-daily.aliyuncs.com',
    cn-wulanchabu = 'datalake-daily.aliyuncs.com',
    cn-yushanfang = 'datalake-daily.aliyuncs.com',
    cn-zhangbei = 'datalake-daily.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'datalake-daily.aliyuncs.com',
    cn-zhangjiakou = 'datalake-daily.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'datalake-daily.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'datalake-daily.aliyuncs.com',
    eu-central-1 = 'datalake-daily.aliyuncs.com',
    eu-west-1 = 'datalake-daily.aliyuncs.com',
    eu-west-1-oxs = 'datalake-daily.aliyuncs.com',
    me-east-1 = 'datalake-daily.aliyuncs.com',
    rus-west-1-pop = 'datalake-daily.aliyuncs.com',
    us-east-1 = 'datalake-daily.aliyuncs.com',
    us-west-1 = 'datalake-daily.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('datalake', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AccessRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  principal?: Principal(name='Principal'),
  privilegeResources?: [
PrivilegeResource
](name='PrivilegeResources'),
}

model Catalog {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  createTime?: int32(name='CreateTime', description='CreateTime'),
}

model ColumnResource {
  columnNames?: [ string ](name='ColumnNames', description='ColumnName'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
}

model ColumnStatistics {
  columnStatisticsDesc?: ColumnStatisticsDesc(name='ColumnStatisticsDesc'),
  columnStatisticsObjList?: [
    ColumnStatisticsObj
  ](name='ColumnStatisticsObjList', description='ColumnStatisticsObjList'),
  engine?: string(name='Engine', description='Engine for hive3+'),
  isStatsCompliant?: boolean(name='IsStatsCompliant', description='IsStatsCompliant for hive3+'),
}

model ColumnStatisticsDesc {
  lastAnalyzedTime?: long(name='LastAnalyzedTime', description='optional'),
  partitionName?: string(name='PartitionName', description='required'),
}

model ColumnStatisticsObj {
  columnName?: string(name='ColumnName', description='ColumnName of the table'),
  columnStatisticsData?: {
    statisticsData?: string(name='StatisticsData', description='StatisticsData'),
    statisticsType?: string(name='StatisticsType', description='StatisticsType'),
  }(name='ColumnStatisticsData', description='ColumnStatisticsData'),
  columnType?: string(name='ColumnType', description='ColumnType'),
}

model Database {
  createTime?: int32(name='CreateTime', description='createTime'),
  createdBy?: string(name='CreatedBy', description='CreatedBy'),
  description?: string(name='Description', description='description'),
  locationUri?: string(name='LocationUri', description='locationUri'),
  name?: string(name='Name', description='name'),
  ownerName?: string(name='OwnerName', description='ownerName'),
  ownerType?: string(name='OwnerType', description='ownerType'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  updateTime?: int32(name='UpdateTime', description='updateTime'),
}

model DatabaseInput {
  createTime?: int32(name='CreateTime', description='createTime'),
  description?: string(name='Description', description='Description'),
  locationUri?: string(name='LocationUri', description='locationUri'),
  name?: string(name='Name', description='name'),
  ownerName?: string(name='OwnerName', description='ownerName'),
  ownerType?: string(name='OwnerType', description='ownerType'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
}

model DatabaseResource {
  databaseName?: string(name='DatabaseName', description='Database name'),
  databaseWildcard?: string(name='DatabaseWildcard', description='A wildcard member representing every resource under a database'),
}

model ErrorDetail {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
}

model FieldSchema {
  comment?: string(name='Comment', description='Comment'),
  name?: string(name='Name', description='Name'),
  parameters?: map[string]string(name='Parameters'),
  type?: string(name='Type', description='Type'),
}

model Function {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  className?: string(name='ClassName', description='ClassName'),
  createTime?: int32(name='CreateTime', description='CreateTime'),
  createdBy?: string(name='CreatedBy', description='CreatedBy'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  functionName?: string(name='FunctionName', description='FunctionName'),
  functionType?: string(name='FunctionType', description='FunctionType'),
  ownerName?: string(name='OwnerName', description='OwnerName'),
  ownerType?: string(name='OwnerType', description='OwnerType'),
  resourceUri?: [
    ResourceUri
  ](name='ResourceUri', description='ResourceUri'),
  updateTime?: int32(name='UpdateTime', description='UpdateTime'),
}

model FunctionInput {
  className?: string(name='ClassName', description='ClassName'),
  createTime?: int32(name='CreateTime', description='createTime'),
  functionName?: string(name='FunctionName', description='FunctionName'),
  functionType?: string(name='FunctionType', description='FunctionType'),
  ownerName?: string(name='OwnerName', description='OwnerName'),
  ownerType?: string(name='OwnerType', description='OwnerType'),
  resourceUri?: [
    ResourceUri
  ](name='ResourceUri', description='ResourceUri'),
}

model FunctionResource {
  databaseName?: string(name='DatabaseName', description='Database name'),
  functionName?: string(name='FunctionName', description='Function name'),
}

model HighLight {
  key?: string(name='Key', description='高亮的key'),
  value?: string(name='Value', description='高亮的value'),
}

model LockObj {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  partitionName?: string(name='PartitionName', description='PartitionName'),
  tableName?: string(name='TableName', description='TableName'),
}

model LockStatus {
  lockId?: long(name='LockId', description='LockId'),
  lockState?: string(name='LockState', description='ACQUIRED/NOT_ACQUIRED'),
}

model MetaResource {
  columnResource?: ColumnResource(name='ColumnResource', description='column resource'),
  databaseResource?: DatabaseResource(name='DatabaseResource', description='database resource'),
  functionResource?: FunctionResource(name='FunctionResource', description='function resource'),
  resourceType?: string(name='ResourceType', description='DATABASE, TABLE, FUNCTION, COLUMN任选其一'),
  tableResource?: TableResource(name='TableResource', description='table resource'),
}

model Order {
  col?: string(name='Col', description='Col'),
  order?: int32(name='Order', description='Order'),
}

model Partition {
  createTime?: int32(name='CreateTime', description='CreateTime'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime', description='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime', description='LastAnalyzedTime'),
  parameters?: map[string]string(name='Parameters', description='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName', description='TableName'),
  values?: [ string ](name='Values', description='Values'),
}

model PartitionError {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  partitionValues?: [ string ](name='PartitionValues'),
}

model PartitionInput {
  createTime?: int32(name='CreateTime', description='createTime'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime', description='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime', description='LastAnalyzedTime'),
  parameters?: map[string]string(name='Parameters', description='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName', description='TableName'),
  values?: [ string ](name='Values', description='Values'),
}

model PartitionSpec {
  sharedSDPartitions?: [
    Partition
  ](name='SharedSDPartitions', description='SharedSDPartitions'),
  sharedStorageDescriptor?: {
    cols?: [
      FieldSchema
    ](name='Cols', description='Cols'),
    location?: string(name='Location', description='Location'),
  }(name='SharedStorageDescriptor', description='SharedStorageDescriptor'),
}

model Principal {
  principalArn?: string(name='PrincipalArn', description='身份标识'),
}

model PrincipalPrivilegeSet {
  groupPrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='GroupPrivileges'),
  rolePrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='RolePrivileges'),
  userPrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='UserPrivileges'),
}

model PrivilegeGrantInfo {
  createTime?: int32(name='CreateTime', description='createTime'),
  grantOption?: boolean(name='GrantOption', description='grantOption'),
  grantor?: string(name='Grantor', description='grantor'),
  grantorType?: string(name='GrantorType', description='grantorType'),
  privilege?: string(name='Privilege', description='privilege'),
}

model PrivilegeResource {
  access?: string(name='Access', description='Access type'),
  metaResource?: MetaResource(name='MetaResource', description='resource'),
}

model ResourceUri {
  resourceType?: string(name='ResourceType', description='ResourceType'),
  uri?: string(name='Uri', description='Uri'),
}

model SerDeInfo {
  name?: string(name='Name', description='Name'),
  parameters?: map[string]string(name='Parameters'),
  serializationLib?: string(name='SerializationLib', description='SerializationLib'),
}

model SkewedInfo {
  skewedColNames?: [ string ](name='SkewedColNames', description='SkewedColNames'),
  skewedColValueLocationMaps?: map[string]string(name='SkewedColValueLocationMaps', description='SkewedColValueLocationMaps'),
  skewedColValues?: [[ string ]  ](name='SkewedColValues', description='SkewedColValueLocationMaps'),
}

model SortCriterion {
  fieldName?: string(name='FieldName', description='排序字段'),
  sort?: string(name='Sort', description='排序方式'),
}

model StorageDescriptor {
  bucketCols?: [ string ](name='BucketCols'),
  cols?: [
    FieldSchema
  ](name='Cols', description='Cols'),
  compressed?: boolean(name='Compressed', description='Compressed'),
  inputFormat?: string(name='InputFormat', description='InputFormat'),
  location?: string(name='Location', description='Location'),
  numBuckets?: int32(name='NumBuckets', description='NumBuckets'),
  outputFormat?: string(name='OutputFormat', description='OutputFormat'),
  parameters?: map[string]string(name='Parameters', description='Parameters'),
  serDeInfo?: SerDeInfo(name='SerDeInfo'),
  skewedInfo?: SkewedInfo(name='SkewedInfo'),
  sortCols?: [
    Order
  ](name='SortCols', description='SortCols'),
  storedAsSubDirectories?: boolean(name='StoredAsSubDirectories', description='StoredAsSubDirectories'),
}

model Table {
  cascade?: boolean(name='Cascade', description='Cascade'),
  createTime?: int32(name='CreateTime', description='CreateTime'),
  createdBy?: string(name='CreatedBy', description='CreatedBy'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime', description='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime', description='LastAnalyzedTime'),
  owner?: string(name='Owner', description='Owner'),
  ownerType?: string(name='OwnerType', description='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  retention?: int32(name='Retention', description='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled', description='RewriteEnabled'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName', description='TableName'),
  tableType?: string(name='TableType', description='TableType'),
  temporary?: boolean(name='Temporary', description='Temporary'),
  updateTime?: int32(name='UpdateTime', description='UpdateTime'),
  viewExpandedText?: string(name='ViewExpandedText', description='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText', description='ViewOriginalText'),
}

model TableError {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  tableName?: string(name='TableName', description='TableName'),
}

model TableInput {
  cascade?: boolean(name='Cascade', description='Cascade'),
  createTime?: int32(name='CreateTime', description='CreateTime'),
  createdBy?: string(name='CreatedBy', description='CreatedBy'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime', description='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime', description='LastAnalyzedTime'),
  owner?: string(name='Owner', description='Owner'),
  ownerType?: string(name='OwnerType', description='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  retention?: int32(name='Retention', description='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled', description='RewriteEnabled'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName', description='TableName'),
  tableType?: string(name='TableType', description='TableType'),
  temporary?: boolean(name='Temporary', description='Temporary'),
  viewExpandedText?: string(name='ViewExpandedText', description='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText', description='ViewOriginalText'),
}

model TableProfile {
  fileCnt?: long(name='FileCnt', description='文件数量'),
  fileSize?: long(name='FileSize', description='文件大小'),
  isPartitioned?: boolean(name='IsPartitioned', description='是否分区表'),
  lastModifyTime?: string(name='LastModifyTime', description='最后跟新时间'),
  partitionCnt?: long(name='PartitionCnt', description='分区数量'),
  recordCnt?: long(name='RecordCnt', description='记录数'),
}

model TableResource {
  databaseName?: string(name='DatabaseName', description='database name'),
  tableName?: string(name='TableName', description='tablename'),
}

model TableVersion {
  table?: Table(name='Table'),
  versionId?: int32(name='VersionId', description='table version'),
}

model TaskStatus {
  message?: string(name='Message', description='message of the task'),
  status?: string(name='Status', description='status of the task'),
}

model UpdateTablePartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  columnStatisticsList?: [
    ColumnStatistics
  ](name='ColumnStatisticsList', description='ColumnStatisticsList'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  engine?: string(name='Engine', description='Engine'),
  isStatsCompliant?: boolean(name='IsStatsCompliant', description='IsStatsCompliant'),
  tableName?: string(name='TableName', description='TableName'),
  validWriteIdList?: string(name='ValidWriteIdList', description='ValidWriteIdList, optional'),
  writeId?: string(name='WriteId', description='WriteId, optional'),
}

model AbortLockRequest {
  lockId?: long(name='LockId', description='LockId'),
}

model AbortLockResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model AbortLockResponse = {
  headers: map[string]string(name='headers'),
  body: AbortLockResponseBody(name='body'),
}

async function abortLock(request: AbortLockRequest): AbortLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return abortLockWithOptions(request, headers, runtime);
}

async function abortLockWithOptions(request: AbortLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AbortLockResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.lockId)) {
    query['LockId'] = request.lockId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AbortLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks/abort`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchCreatePartitionsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  ifNotExists?: boolean(name='IfNotExists', description='IfNotExists'),
  needResult?: boolean(name='NeedResult', description='NeedResult'),
  partitionInputs?: [
    PartitionInput
  ](name='PartitionInputs', description='PartitionInputs'),
  tableName?: string(name='TableName', description='TableName'),
}

model BatchCreatePartitionsResponseBody = {
  code?: string(name='Code', description='响应代码'),
  message?: string(name='Message', description='响应消息'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='分区出错信息'),
  partitions?: [
    Partition
  ](name='Partitions', description='Partitions'),
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='是否成功'),
}

model BatchCreatePartitionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchCreatePartitionsResponseBody(name='body'),
}

async function batchCreatePartitions(request: BatchCreatePartitionsRequest): BatchCreatePartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchCreatePartitionsWithOptions(request, headers, runtime);
}

async function batchCreatePartitionsWithOptions(request: BatchCreatePartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchCreatePartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifNotExists)) {
    body['IfNotExists'] = request.ifNotExists;
  }
  if (!Util.isUnset(request.needResult)) {
    body['NeedResult'] = request.needResult;
  }
  if (!Util.isUnset(request.partitionInputs)) {
    body['PartitionInputs'] = request.partitionInputs;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchCreatePartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/batchcreate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchCreateTablesRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  ifNotExists?: boolean(name='IfNotExists', description='IfNotExists'),
  tableInputs?: [
    TableInput
  ](name='TableInputs', description='TableInputs'),
}

model BatchCreateTablesResponseBody = {
  code?: string(name='Code', description='响应代码'),
  message?: string(name='Message', description='响应消息'),
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='是否成功'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='表出错信息'),
}

model BatchCreateTablesResponse = {
  headers: map[string]string(name='headers'),
  body: BatchCreateTablesResponseBody(name='body'),
}

async function batchCreateTables(request: BatchCreateTablesRequest): BatchCreateTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchCreateTablesWithOptions(request, headers, runtime);
}

async function batchCreateTablesWithOptions(request: BatchCreateTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchCreateTablesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifNotExists)) {
    body['IfNotExists'] = request.ifNotExists;
  }
  if (!Util.isUnset(request.tableInputs)) {
    body['TableInputs'] = request.tableInputs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchCreateTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/batchcreate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchDeletePartitionsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  ifExists?: boolean(name='IfExists', description='IfExists'),
  partitionValueList?: [ 
{
values?: [ string ](name='Values'),
}
](name='PartitionValueList'),
  tableName?: string(name='TableName', description='TableName'),
}

model BatchDeletePartitionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='PartitionErrors'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model BatchDeletePartitionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchDeletePartitionsResponseBody(name='body'),
}

async function batchDeletePartitions(request: BatchDeletePartitionsRequest): BatchDeletePartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchDeletePartitionsWithOptions(request, headers, runtime);
}

async function batchDeletePartitionsWithOptions(request: BatchDeletePartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchDeletePartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifExists)) {
    body['IfExists'] = request.ifExists;
  }
  if (!Util.isUnset(request.partitionValueList)) {
    body['PartitionValueList'] = request.partitionValueList;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeletePartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/batchdelete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchDeleteTableVersionsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
  versionIds?: [ int32 ](name='VersionIds', description='Table versionIds'),
}

model BatchDeleteTableVersionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model BatchDeleteTableVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchDeleteTableVersionsResponseBody(name='body'),
}

async function batchDeleteTableVersions(request: BatchDeleteTableVersionsRequest): BatchDeleteTableVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchDeleteTableVersionsWithOptions(request, headers, runtime);
}

async function batchDeleteTableVersionsWithOptions(request: BatchDeleteTableVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchDeleteTableVersionsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }
  if (!Util.isUnset(request.versionIds)) {
    body['VersionIds'] = request.versionIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteTableVersions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/versions/batchdelete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchDeleteTablesRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  ifExists?: boolean(name='IfExists', description='IfExists'),
  tableNames?: [ string ](name='TableNames', description='TableName'),
}

model BatchDeleteTablesResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='PartitionErrors'),
}

model BatchDeleteTablesResponse = {
  headers: map[string]string(name='headers'),
  body: BatchDeleteTablesResponseBody(name='body'),
}

async function batchDeleteTables(request: BatchDeleteTablesRequest): BatchDeleteTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchDeleteTablesWithOptions(request, headers, runtime);
}

async function batchDeleteTablesWithOptions(request: BatchDeleteTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchDeleteTablesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifExists)) {
    body['IfExists'] = request.ifExists;
  }
  if (!Util.isUnset(request.tableNames)) {
    body['TableNames'] = request.tableNames;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/batchdelete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchGetPartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  columnNames?: [ string ](name='ColumnNames'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  partitionNames?: [ string ](name='PartitionNames'),
  tableName?: string(name='TableName', description='TableName'),
}

model BatchGetPartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partitionStatisticsMap?: map[string][
    ColumnStatisticsObj
  ](name='PartitionStatisticsMap', description='PartitionStatisticsMap'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model BatchGetPartitionColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchGetPartitionColumnStatisticsResponseBody(name='body'),
}

async function batchGetPartitionColumnStatistics(request: BatchGetPartitionColumnStatisticsRequest): BatchGetPartitionColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGetPartitionColumnStatisticsWithOptions(request, headers, runtime);
}

async function batchGetPartitionColumnStatisticsWithOptions(request: BatchGetPartitionColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchGetPartitionColumnStatisticsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.columnNames)) {
    body['ColumnNames'] = request.columnNames;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionNames)) {
    body['PartitionNames'] = request.partitionNames;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetPartitionColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/columnstatistics/batchget`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchGetPartitionsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  isShareSd?: boolean(name='IsShareSd', description='IsShareSd'),
  partitionValueList?: [ 
{
values?: [ string ](name='Values'),
}
](name='PartitionValueList'),
  tableName?: string(name='TableName', description='TableName'),
}

model BatchGetPartitionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='PartitionErrors'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs', description='PartitionSpecs'),
  partitions?: [
    Partition
  ](name='Partitions', description='Partitions'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model BatchGetPartitionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchGetPartitionsResponseBody(name='body'),
}

async function batchGetPartitions(request: BatchGetPartitionsRequest): BatchGetPartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGetPartitionsWithOptions(request, headers, runtime);
}

async function batchGetPartitionsWithOptions(request: BatchGetPartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchGetPartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.isShareSd)) {
    body['IsShareSd'] = request.isShareSd;
  }
  if (!Util.isUnset(request.partitionValueList)) {
    body['PartitionValueList'] = request.partitionValueList;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetPartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/batchget`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchGetTablesRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableNames?: [ string ](name='TableNames'),
}

model BatchGetTablesResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='TableErrors'),
  tables?: [
    Table
  ](name='Tables', description='Tables'),
}

model BatchGetTablesResponse = {
  headers: map[string]string(name='headers'),
  body: BatchGetTablesResponseBody(name='body'),
}

async function batchGetTables(request: BatchGetTablesRequest): BatchGetTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGetTablesWithOptions(request, headers, runtime);
}

async function batchGetTablesWithOptions(request: BatchGetTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchGetTablesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableNames)) {
    body['TableNames'] = request.tableNames;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/batchget`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchUpdatePartitionsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  partitionInputs?: [
    PartitionInput
  ](name='PartitionInputs', description='PartitionInputs'),
  tableName?: string(name='TableName', description='TableName'),
}

model BatchUpdatePartitionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='PartitionErrors'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model BatchUpdatePartitionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchUpdatePartitionsResponseBody(name='body'),
}

async function batchUpdatePartitions(request: BatchUpdatePartitionsRequest): BatchUpdatePartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchUpdatePartitionsWithOptions(request, headers, runtime);
}

async function batchUpdatePartitionsWithOptions(request: BatchUpdatePartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchUpdatePartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionInputs)) {
    body['PartitionInputs'] = request.partitionInputs;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchUpdatePartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/batchupdate`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchUpdateTablesRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  isAsync?: boolean(name='IsAsync', description='是否异步'),
  tableInputs?: [
    TableInput
  ](name='TableInputs', description='TableInputs'),
}

model BatchUpdateTablesResponseBody = {
  code?: string(name='Code', description='响应代码'),
  message?: string(name='Message', description='响应消息'),
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='是否成功'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='表出错信息'),
  taskId?: string(name='TaskId', description='异步更新 taskId'),
}

model BatchUpdateTablesResponse = {
  headers: map[string]string(name='headers'),
  body: BatchUpdateTablesResponseBody(name='body'),
}

async function batchUpdateTables(request: BatchUpdateTablesRequest): BatchUpdateTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchUpdateTablesWithOptions(request, headers, runtime);
}

async function batchUpdateTablesWithOptions(request: BatchUpdateTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchUpdateTablesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.isAsync)) {
    body['IsAsync'] = request.isAsync;
  }
  if (!Util.isUnset(request.tableInputs)) {
    body['TableInputs'] = request.tableInputs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchUpdateTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/batchupdate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CancelQueryRequest {
  queryId?: string(name='QueryId'),
}

model CancelQueryResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelQueryResponse = {
  headers: map[string]string(name='headers'),
  body: CancelQueryResponseBody(name='body'),
}

async function cancelQuery(request: CancelQueryRequest): CancelQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelQueryWithOptions(request, headers, runtime);
}

async function cancelQueryWithOptions(request: CancelQueryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelQueryResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.queryId)) {
    query['QueryId'] = request.queryId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelQuery',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/cancelQuery`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CheckBlueprintInstanceNameRequest {
  name?: string(name='Name'),
}

model CheckBlueprintInstanceNameResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckBlueprintInstanceNameResponse = {
  headers: map[string]string(name='headers'),
  body: CheckBlueprintInstanceNameResponseBody(name='body'),
}

async function checkBlueprintInstanceName(request: CheckBlueprintInstanceNameRequest): CheckBlueprintInstanceNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkBlueprintInstanceNameWithOptions(request, headers, runtime);
}

async function checkBlueprintInstanceNameWithOptions(request: CheckBlueprintInstanceNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckBlueprintInstanceNameResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckBlueprintInstanceName',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/blueprintinstance/checkName`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CheckConnectionRequest {
  dataSourceInstanceId?: string(name='DataSourceInstanceId'),
  dataSourceType?: string(name='DataSourceType'),
  password?: string(name='Password'),
  userName?: string(name='UserName'),
}

model CheckConnectionResponseBody = {
  data?: {
    code?: string(name='Code'),
    isValid?: boolean(name='IsValid'),
    msg?: string(name='Msg'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CheckConnectionResponseBody(name='body'),
}

async function checkConnection(request: CheckConnectionRequest): CheckConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkConnectionWithOptions(request, headers, runtime);
}

async function checkConnectionWithOptions(request: CheckConnectionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckConnectionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.dataSourceInstanceId)) {
    query['DataSourceInstanceId'] = request.dataSourceInstanceId;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    query['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckConnection',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/connectivity/connectionCheck`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CheckConnectivityRequest {
  bizId?: string(name='BizId'),
  dataSourceInstanceId?: string(name='DataSourceInstanceId'),
  dataSourceType?: string(name='DataSourceType'),
  password?: string(name='Password'),
  userName?: string(name='UserName'),
}

model CheckConnectivityResponseBody = {
  data?: {
    code?: string(name='Code'),
    isValid?: boolean(name='IsValid'),
    msg?: string(name='Msg'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckConnectivityResponse = {
  headers: map[string]string(name='headers'),
  body: CheckConnectivityResponseBody(name='body'),
}

async function checkConnectivity(request: CheckConnectivityRequest): CheckConnectivityResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkConnectivityWithOptions(request, headers, runtime);
}

async function checkConnectivityWithOptions(request: CheckConnectivityRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckConnectivityResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.dataSourceInstanceId)) {
    body['DataSourceInstanceId'] = request.dataSourceInstanceId;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    body['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CheckConnectivity',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/connectivity/check`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CheckPermissionsRequest {
  body?: AccessRequest(name='Body'),
}

model CheckPermissionsResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Message Code'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model CheckPermissionsResponse = {
  headers: map[string]string(name='headers'),
  body: CheckPermissionsResponseBody(name='body'),
}

async function checkPermissions(request: CheckPermissionsRequest): CheckPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkPermissionsWithOptions(request, headers, runtime);
}

async function checkPermissionsWithOptions(request: CheckPermissionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckPermissionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CheckPermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/check`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateBlueprintInstanceHeaders {
  commonHeaders?: map[string]string,
  clientToken?: string(name='ClientToken'),
}

model CreateBlueprintInstanceRequest {
  blueprintType?: string(name='BlueprintType'),
  dataSourceConfig?: string(name='DataSourceConfig'),
  executeCapacity?: string(name='ExecuteCapacity'),
  executeParameters?: string(name='ExecuteParameters'),
  executeType?: string(name='ExecuteType'),
  name?: string(name='Name'),
  preProcessingConfig?: string(name='PreProcessingConfig'),
  roleName?: string(name='RoleName'),
  targetDatabase?: string(name='TargetDatabase'),
  targetFormat?: string(name='TargetFormat'),
  targetLocationUri?: string(name='TargetLocationUri'),
  targetPartitions?: string(name='TargetPartitions'),
  targetTable?: string(name='TargetTable'),
}

model CreateBlueprintInstanceResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateBlueprintInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBlueprintInstanceResponseBody(name='body'),
}

async function createBlueprintInstance(request: CreateBlueprintInstanceRequest): CreateBlueprintInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateBlueprintInstanceHeaders{};
  return createBlueprintInstanceWithOptions(request, headers, runtime);
}

async function createBlueprintInstanceWithOptions(request: CreateBlueprintInstanceRequest, headers: CreateBlueprintInstanceHeaders, runtime: Util.RuntimeOptions): CreateBlueprintInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.blueprintType)) {
    body['BlueprintType'] = request.blueprintType;
  }
  if (!Util.isUnset(request.dataSourceConfig)) {
    body['DataSourceConfig'] = request.dataSourceConfig;
  }
  if (!Util.isUnset(request.executeCapacity)) {
    body['ExecuteCapacity'] = request.executeCapacity;
  }
  if (!Util.isUnset(request.executeParameters)) {
    body['ExecuteParameters'] = request.executeParameters;
  }
  if (!Util.isUnset(request.executeType)) {
    body['ExecuteType'] = request.executeType;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.preProcessingConfig)) {
    body['PreProcessingConfig'] = request.preProcessingConfig;
  }
  if (!Util.isUnset(request.roleName)) {
    body['RoleName'] = request.roleName;
  }
  if (!Util.isUnset(request.targetDatabase)) {
    body['TargetDatabase'] = request.targetDatabase;
  }
  if (!Util.isUnset(request.targetFormat)) {
    body['TargetFormat'] = request.targetFormat;
  }
  if (!Util.isUnset(request.targetLocationUri)) {
    body['TargetLocationUri'] = request.targetLocationUri;
  }
  if (!Util.isUnset(request.targetPartitions)) {
    body['TargetPartitions'] = request.targetPartitions;
  }
  if (!Util.isUnset(request.targetTable)) {
    body['TargetTable'] = request.targetTable;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.clientToken)) {
    realHeaders['ClientToken'] = Util.toJSONString(headers.clientToken);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateBlueprintInstance',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/blueprintinstance/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateDataSourceHeaders {
  commonHeaders?: map[string]string,
  clientToken?: string(name='ClientToken'),
}

model CreateDataSourceRequest {
  connectionInfo?: string(name='ConnectionInfo'),
  dataSourceType?: string(name='DataSourceType'),
  name?: string(name='Name'),
}

model CreateDataSourceResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataSourceResponseBody(name='body'),
}

async function createDataSource(request: CreateDataSourceRequest): CreateDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateDataSourceHeaders{};
  return createDataSourceWithOptions(request, headers, runtime);
}

async function createDataSourceWithOptions(request: CreateDataSourceRequest, headers: CreateDataSourceHeaders, runtime: Util.RuntimeOptions): CreateDataSourceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.connectionInfo)) {
    body['ConnectionInfo'] = request.connectionInfo;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    body['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.clientToken)) {
    realHeaders['ClientToken'] = Util.toJSONString(headers.clientToken);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataSource',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/datasource/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateDatabaseRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseInput?: DatabaseInput(name='DatabaseInput'),
}

model CreateDatabaseResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Response Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model CreateDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDatabaseResponseBody(name='body'),
}

async function createDatabase(request: CreateDatabaseRequest): CreateDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDatabaseWithOptions(request, headers, runtime);
}

async function createDatabaseWithOptions(request: CreateDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDatabaseResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseInput)) {
    body['DatabaseInput'] = request.databaseInput;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDatabase',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateFunctionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  functionInput?: FunctionInput(name='FunctionInput'),
}

model CreateFunctionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model CreateFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFunctionResponseBody(name='body'),
}

async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFunctionWithOptions(request, headers, runtime);
}

async function createFunctionWithOptions(request: CreateFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionInput)) {
    body['FunctionInput'] = request.functionInput;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFunction',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateLockRequest {
  lockObjList?: [
    LockObj
  ](name='LockObjList', description='LockObjList'),
}

model CreateLockResponseBody = {
  code?: string(name='Code', description='Code'),
  lockStatus?: LockStatus(name='LockStatus'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model CreateLockResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLockResponseBody(name='body'),
}

async function createLock(request: CreateLockRequest): CreateLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLockWithOptions(request, headers, runtime);
}

async function createLockWithOptions(request: CreateLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLockResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.lockObjList)) {
    body['LockObjList'] = request.lockObjList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateMetastoreCrawlerRequest {
  datasourceExcludePath?: string(name='DatasourceExcludePath'),
  datasourcePath?: string(name='DatasourcePath'),
  datasourceType?: string(name='DatasourceType'),
  executeCron?: string(name='ExecuteCron'),
  executeMode?: string(name='ExecuteMode'),
  executeType?: string(name='ExecuteType'),
  fileFormat?: string(name='FileFormat'),
  fileFormatConfig?: string(name='FileFormatConfig'),
  immediatelyRun?: boolean(name='ImmediatelyRun'),
  name?: string(name='Name'),
  roleName?: string(name='RoleName'),
  targetDatabase?: string(name='TargetDatabase'),
  targetTablePrefix?: string(name='TargetTablePrefix'),
  targetUpdateStrategy?: string(name='TargetUpdateStrategy'),
}

model CreateMetastoreCrawlerResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateMetastoreCrawlerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMetastoreCrawlerResponseBody(name='body'),
}

async function createMetastoreCrawler(request: CreateMetastoreCrawlerRequest): CreateMetastoreCrawlerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMetastoreCrawlerWithOptions(request, headers, runtime);
}

async function createMetastoreCrawlerWithOptions(request: CreateMetastoreCrawlerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMetastoreCrawlerResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.datasourceExcludePath)) {
    body['DatasourceExcludePath'] = request.datasourceExcludePath;
  }
  if (!Util.isUnset(request.datasourcePath)) {
    body['DatasourcePath'] = request.datasourcePath;
  }
  if (!Util.isUnset(request.datasourceType)) {
    body['DatasourceType'] = request.datasourceType;
  }
  if (!Util.isUnset(request.executeCron)) {
    body['ExecuteCron'] = request.executeCron;
  }
  if (!Util.isUnset(request.executeMode)) {
    body['ExecuteMode'] = request.executeMode;
  }
  if (!Util.isUnset(request.executeType)) {
    body['ExecuteType'] = request.executeType;
  }
  if (!Util.isUnset(request.fileFormat)) {
    body['FileFormat'] = request.fileFormat;
  }
  if (!Util.isUnset(request.fileFormatConfig)) {
    body['FileFormatConfig'] = request.fileFormatConfig;
  }
  if (!Util.isUnset(request.immediatelyRun)) {
    body['ImmediatelyRun'] = request.immediatelyRun;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.roleName)) {
    body['RoleName'] = request.roleName;
  }
  if (!Util.isUnset(request.targetDatabase)) {
    body['TargetDatabase'] = request.targetDatabase;
  }
  if (!Util.isUnset(request.targetTablePrefix)) {
    body['TargetTablePrefix'] = request.targetTablePrefix;
  }
  if (!Util.isUnset(request.targetUpdateStrategy)) {
    body['TargetUpdateStrategy'] = request.targetUpdateStrategy;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMetastoreCrawler',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/crawler/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateMetastoreMigrationRequest {
  desc?: string(name='Desc'),
  metastoreInfo?: string(name='MetastoreInfo'),
  metastoreType?: string(name='MetastoreType'),
  name?: string(name='Name'),
  roleName?: string(name='RoleName'),
  runOptions?: string(name='RunOptions'),
}

model CreateMetastoreMigrationResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateMetastoreMigrationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMetastoreMigrationResponseBody(name='body'),
}

async function createMetastoreMigration(request: CreateMetastoreMigrationRequest): CreateMetastoreMigrationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMetastoreMigrationWithOptions(request, headers, runtime);
}

async function createMetastoreMigrationWithOptions(request: CreateMetastoreMigrationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMetastoreMigrationResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.desc)) {
    body['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.metastoreInfo)) {
    body['MetastoreInfo'] = request.metastoreInfo;
  }
  if (!Util.isUnset(request.metastoreType)) {
    body['MetastoreType'] = request.metastoreType;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.roleName)) {
    body['RoleName'] = request.roleName;
  }
  if (!Util.isUnset(request.runOptions)) {
    body['RunOptions'] = request.runOptions;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMetastoreMigration',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/migration/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreatePartitionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  ifNotExists?: boolean(name='IfNotExists', description='IfNotExists'),
  needResult?: boolean(name='NeedResult', description='NeedResult'),
  partitionInput?: PartitionInput(name='PartitionInput'),
  tableName?: string(name='TableName', description='TableName'),
}

model CreatePartitionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partition?: Partition(name='Partition'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model CreatePartitionResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePartitionResponseBody(name='body'),
}

async function createPartition(request: CreatePartitionRequest): CreatePartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPartitionWithOptions(request, headers, runtime);
}

async function createPartitionWithOptions(request: CreatePartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePartitionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifNotExists)) {
    body['IfNotExists'] = request.ifNotExists;
  }
  if (!Util.isUnset(request.needResult)) {
    body['NeedResult'] = request.needResult;
  }
  if (!Util.isUnset(request.partitionInput)) {
    body['PartitionInput'] = request.partitionInput;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePartition',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateSavedQueryRequest {
  description?: string(name='Description'),
  name?: string(name='Name'),
  savedQueryId?: string(name='SavedQueryId'),
  sql?: string(name='Sql'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateSavedQueryResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSavedQueryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSavedQueryResponseBody(name='body'),
}

async function createSavedQuery(request: CreateSavedQueryRequest): CreateSavedQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSavedQueryWithOptions(request, headers, runtime);
}

async function createSavedQueryWithOptions(request: CreateSavedQueryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSavedQueryResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.savedQueryId)) {
    body['SavedQueryId'] = request.savedQueryId;
  }
  if (!Util.isUnset(request.sql)) {
    body['Sql'] = request.sql;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSavedQuery',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/createSavedQueryRequestBody`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateStorageCollectorRequest {
  datasourceType?: string(name='DatasourceType', description='数据源类型'),
}

model CreateStorageCollectorResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model CreateStorageCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: CreateStorageCollectorResponseBody(name='body'),
}

async function createStorageCollector(request: CreateStorageCollectorRequest): CreateStorageCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createStorageCollectorWithOptions(request, headers, runtime);
}

async function createStorageCollectorWithOptions(request: CreateStorageCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateStorageCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.datasourceType)) {
    query['DatasourceType'] = request.datasourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateStorageCollector',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/storagecollect/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateTableRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableInput?: TableInput(name='TableInput'),
}

model CreateTableResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model CreateTableResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTableResponseBody(name='body'),
}

async function createTable(request: CreateTableRequest): CreateTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTableWithOptions(request, headers, runtime);
}

async function createTableWithOptions(request: CreateTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTableResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableInput)) {
    body['TableInput'] = request.tableInput;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateTpcdsDatabaseRequest {
  body?: string(name='body'),
}

model CreateTpcdsDatabaseResponseBody = {
  data?: [ string ](name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model CreateTpcdsDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTpcdsDatabaseResponseBody(name='body'),
}

async function createTpcdsDatabase(request: CreateTpcdsDatabaseRequest): CreateTpcdsDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTpcdsDatabaseWithOptions(request, headers, runtime);
}

async function createTpcdsDatabaseWithOptions(request: CreateTpcdsDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTpcdsDatabaseResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateTpcdsDatabase',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/createTpcdsDatabase`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateUserFeedbackRequest {
  description?: string(name='Description'),
  score?: string(name='Score'),
  tags?: string(name='Tags'),
}

model CreateUserFeedbackResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateUserFeedbackResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUserFeedbackResponseBody(name='body'),
}

async function createUserFeedback(request: CreateUserFeedbackRequest): CreateUserFeedbackResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createUserFeedbackWithOptions(request, headers, runtime);
}

async function createUserFeedbackWithOptions(request: CreateUserFeedbackRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateUserFeedbackResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.score)) {
    body['Score'] = request.score;
  }
  if (!Util.isUnset(request.tags)) {
    body['Tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateUserFeedback',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/feedback/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteBlueprintInstanceRequest {
  blueprintInstanceId?: string(name='BlueprintInstanceId'),
}

model DeleteBlueprintInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DeleteBlueprintInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBlueprintInstanceResponseBody(name='body'),
}

async function deleteBlueprintInstance(request: DeleteBlueprintInstanceRequest): DeleteBlueprintInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBlueprintInstanceWithOptions(request, headers, runtime);
}

async function deleteBlueprintInstanceWithOptions(request: DeleteBlueprintInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBlueprintInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.blueprintInstanceId)) {
    query['BlueprintInstanceId'] = request.blueprintInstanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBlueprintInstance',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/blueprintinstance/delete`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteDataSourceRequest {
  dataSourceId?: string(name='DataSourceId'),
}

model DeleteDataSourceResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataSourceResponseBody(name='body'),
}

async function deleteDataSource(request: DeleteDataSourceRequest): DeleteDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDataSourceWithOptions(request, headers, runtime);
}

async function deleteDataSourceWithOptions(request: DeleteDataSourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDataSourceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.dataSourceId)) {
    query['DataSourceId'] = request.dataSourceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataSource',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/datasource/delete`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteDatabaseRequest {
  cascade?: boolean(name='Cascade', description='Cascade'),
  catalogId?: string(name='CatalogId', description='CatalogId'),
  name?: string(name='Name', description='Name'),
}

model DeleteDatabaseResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Response Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Request is success or not'),
}

model DeleteDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDatabaseResponseBody(name='body'),
}

async function deleteDatabase(request: DeleteDatabaseRequest): DeleteDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDatabaseWithOptions(request, headers, runtime);
}

async function deleteDatabaseWithOptions(request: DeleteDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDatabaseResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.cascade)) {
    query['Cascade'] = request.cascade;
  }
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDatabase',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteFunctionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  functionName?: string(name='FunctionName', description='FunctionName'),
}

model DeleteFunctionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeleteFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFunctionResponseBody(name='body'),
}

async function deleteFunction(request: DeleteFunctionRequest): DeleteFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionWithOptions(request, headers, runtime);
}

async function deleteFunctionWithOptions(request: DeleteFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunction',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteMetastoreCrawlerRequest {
  crawlerId?: string(name='CrawlerId'),
}

model DeleteMetastoreCrawlerResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMetastoreCrawlerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMetastoreCrawlerResponseBody(name='body'),
}

async function deleteMetastoreCrawler(request: DeleteMetastoreCrawlerRequest): DeleteMetastoreCrawlerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMetastoreCrawlerWithOptions(request, headers, runtime);
}

async function deleteMetastoreCrawlerWithOptions(request: DeleteMetastoreCrawlerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMetastoreCrawlerResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.crawlerId)) {
    query['CrawlerId'] = request.crawlerId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMetastoreCrawler',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/crawler/delete`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteMetastoreMigrationRequest {
  instanceId?: string(name='InstanceId'),
}

model DeleteMetastoreMigrationResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DeleteMetastoreMigrationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMetastoreMigrationResponseBody(name='body'),
}

async function deleteMetastoreMigration(request: DeleteMetastoreMigrationRequest): DeleteMetastoreMigrationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMetastoreMigrationWithOptions(request, headers, runtime);
}

async function deleteMetastoreMigrationWithOptions(request: DeleteMetastoreMigrationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMetastoreMigrationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMetastoreMigration',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/migration/delete`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeletePartitionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  ifExists?: boolean(name='IfExists', description='IfExists'),
  partitionValues?: [ string ](name='PartitionValues'),
  tableName?: string(name='TableName', description='TableName'),
}

model DeletePartitionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeletePartitionResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePartitionResponseBody(name='body'),
}

async function deletePartition(request: DeletePartitionRequest): DeletePartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePartitionWithOptions(request, headers, runtime);
}

async function deletePartitionWithOptions(request: DeletePartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePartitionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifExists)) {
    body['IfExists'] = request.ifExists;
  }
  if (!Util.isUnset(request.partitionValues)) {
    body['PartitionValues'] = request.partitionValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeletePartition',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeletePartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  columnNames?: [ string ](name='ColumnNames'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  partitionNames?: [ string ](name='PartitionNames'),
  tableName?: string(name='TableName', description='TableName'),
}

model DeletePartitionColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  columnNamesShrink?: string(name='ColumnNames'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  partitionNamesShrink?: string(name='PartitionNames'),
  tableName?: string(name='TableName', description='TableName'),
}

model DeletePartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeletePartitionColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePartitionColumnStatisticsResponseBody(name='body'),
}

async function deletePartitionColumnStatistics(request: DeletePartitionColumnStatisticsRequest): DeletePartitionColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePartitionColumnStatisticsWithOptions(request, headers, runtime);
}

async function deletePartitionColumnStatisticsWithOptions(tmpReq: DeletePartitionColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePartitionColumnStatisticsResponse {
  Util.validateModel(tmpReq);
  var request = new DeletePartitionColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  if (!Util.isUnset(tmpReq.partitionNames)) {
    request.partitionNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.partitionNames, 'PartitionNames', 'json');
  }
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.columnNamesShrink)) {
    query['ColumnNames'] = request.columnNamesShrink;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionNamesShrink)) {
    query['PartitionNames'] = request.partitionNamesShrink;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePartitionColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/columnstatistics`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteSavedQueryRequest {
  savedQueryId?: string(name='SavedQueryId'),
}

model DeleteSavedQueryResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSavedQueryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSavedQueryResponseBody(name='body'),
}

async function deleteSavedQuery(request: DeleteSavedQueryRequest): DeleteSavedQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSavedQueryWithOptions(request, headers, runtime);
}

async function deleteSavedQueryWithOptions(request: DeleteSavedQueryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSavedQueryResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.savedQueryId)) {
    query['SavedQueryId'] = request.savedQueryId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSavedQuery',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/deleteSavedQuery`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteTableRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
}

model DeleteTableResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeleteTableResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTableResponseBody(name='body'),
}

async function deleteTable(request: DeleteTableRequest): DeleteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTableWithOptions(request, headers, runtime);
}

async function deleteTableWithOptions(request: DeleteTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTableResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteTableColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  columnNames?: [ string ](name='ColumnNames'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
}

model DeleteTableColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  columnNamesShrink?: string(name='ColumnNames'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
}

model DeleteTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeleteTableColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTableColumnStatisticsResponseBody(name='body'),
}

async function deleteTableColumnStatistics(request: DeleteTableColumnStatisticsRequest): DeleteTableColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTableColumnStatisticsWithOptions(request, headers, runtime);
}

async function deleteTableColumnStatisticsWithOptions(tmpReq: DeleteTableColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTableColumnStatisticsResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteTableColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.columnNamesShrink)) {
    query['ColumnNames'] = request.columnNamesShrink;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTableColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/columnstatistics`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteTableVersionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
  versionId?: int32(name='VersionId', description='table version id'),
}

model DeleteTableVersionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeleteTableVersionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTableVersionResponseBody(name='body'),
}

async function deleteTableVersion(request: DeleteTableVersionRequest): DeleteTableVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTableVersionWithOptions(request, headers, runtime);
}

async function deleteTableVersionWithOptions(request: DeleteTableVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTableVersionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTableVersion',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/versions`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeBlueprintInstanceRequest {
  blueprintInstanceId?: string(name='BlueprintInstanceId'),
}

model DescribeBlueprintInstanceResponseBody = {
  blueprintInstance?: {
    blueprintInstanceId?: string(name='BlueprintInstanceId'),
    blueprintType?: string(name='BlueprintType'),
    creator?: string(name='Creator'),
    dataSourceConfig?: string(name='DataSourceConfig'),
    emrFlowId?: string(name='EmrFlowId'),
    emrFlowProjectId?: string(name='EmrFlowProjectId'),
    emrFlowScheduleStatus?: string(name='EmrFlowScheduleStatus'),
    executeCapacity?: long(name='ExecuteCapacity'),
    executeParameters?: string(name='ExecuteParameters'),
    executeType?: string(name='ExecuteType'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    lastRunFlowInstance?: {
      clusterId?: string(name='ClusterId'),
      duration?: long(name='Duration'),
      endTime?: string(name='EndTime'),
      flowId?: string(name='FlowId'),
      flowInstanceId?: string(name='FlowInstanceId'),
      flowName?: string(name='FlowName'),
      projectId?: string(name='ProjectId'),
      reason?: string(name='Reason'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
    }(name='LastRunFlowInstance'),
    name?: string(name='Name'),
    owner?: string(name='Owner'),
    preProcessingConfig?: string(name='PreProcessingConfig'),
    reason?: string(name='Reason'),
    regionId?: string(name='RegionId'),
    roleName?: long(name='RoleName'),
    sourceChannelId?: string(name='SourceChannelId'),
    sourceChannelName?: string(name='SourceChannelName'),
    sourceChannelType?: string(name='SourceChannelType'),
    sourceDataSourceId?: string(name='SourceDataSourceId'),
    sourceDataSourceName?: string(name='SourceDataSourceName'),
    sourceFormat?: string(name='SourceFormat'),
    sourceInclude?: string(name='SourceInclude'),
    sourceLocationUri?: string(name='SourceLocationUri'),
    sourcePrimaryColumn?: string(name='SourcePrimaryColumn'),
    sourceSchema?: string(name='SourceSchema'),
    status?: int32(name='Status'),
    targetDatabase?: string(name='TargetDatabase'),
    targetFormat?: string(name='TargetFormat'),
    targetLocationUri?: string(name='TargetLocationUri'),
    targetTablePrefix?: string(name='TargetTablePrefix'),
  }(name='BlueprintInstance'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeBlueprintInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBlueprintInstanceResponseBody(name='body'),
}

async function describeBlueprintInstance(request: DescribeBlueprintInstanceRequest): DescribeBlueprintInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeBlueprintInstanceWithOptions(request, headers, runtime);
}

async function describeBlueprintInstanceWithOptions(request: DescribeBlueprintInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeBlueprintInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.blueprintInstanceId)) {
    query['BlueprintInstanceId'] = request.blueprintInstanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBlueprintInstance',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/blueprintinstance/describe`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeDataSourceRequest {
  dataSourceId?: string(name='DataSourceId'),
}

model DescribeDataSourceResponseBody = {
  dataSource?: {
    connectionInfo?: string(name='ConnectionInfo'),
    dataSourceId?: string(name='DataSourceId'),
    dataSourceType?: string(name='DataSourceType'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    name?: string(name='Name'),
  }(name='DataSource'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDataSourceResponseBody(name='body'),
}

async function describeDataSource(request: DescribeDataSourceRequest): DescribeDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDataSourceWithOptions(request, headers, runtime);
}

async function describeDataSourceWithOptions(request: DescribeDataSourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDataSourceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.dataSourceId)) {
    query['DataSourceId'] = request.dataSourceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDataSource',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/datasource/describe`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeMetastoreCrawlerRequest {
  crawlerId?: string(name='CrawlerId'),
}

model DescribeMetastoreCrawlerResponseBody = {
  creator?: long(name='Creator'),
  datasourceExcludePath?: string(name='DatasourceExcludePath'),
  datasourcePath?: string(name='DatasourcePath'),
  datasourceType?: string(name='DatasourceType'),
  executeCron?: string(name='ExecuteCron'),
  executeMode?: string(name='ExecuteMode'),
  executeType?: string(name='ExecuteType'),
  fileFormat?: string(name='FileFormat'),
  fileFormatConfig?: string(name='FileFormatConfig'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  owner?: long(name='Owner'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  roleName?: string(name='RoleName'),
  status?: string(name='Status'),
  success?: boolean(name='Success'),
  targetDatabase?: string(name='TargetDatabase'),
  targetTablePrefix?: string(name='TargetTablePrefix'),
  targetUpdateStrategy?: string(name='TargetUpdateStrategy'),
  workflowLastRunInstance?: {
    batchProgress?: int32(name='BatchProgress'),
    clusterId?: string(name='ClusterId'),
    duration?: long(name='Duration'),
    endTime?: long(name='EndTime'),
    failureInfo?: string(name='FailureInfo'),
    flowExtendResult?: string(name='FlowExtendResult'),
    flowId?: string(name='FlowId'),
    flowInstanceId?: string(name='FlowInstanceId'),
    flowName?: string(name='FlowName'),
    projectId?: string(name='ProjectId'),
    startTime?: long(name='StartTime'),
    status?: string(name='Status'),
  }(name='WorkflowLastRunInstance'),
}

model DescribeMetastoreCrawlerResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMetastoreCrawlerResponseBody(name='body'),
}

async function describeMetastoreCrawler(request: DescribeMetastoreCrawlerRequest): DescribeMetastoreCrawlerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeMetastoreCrawlerWithOptions(request, headers, runtime);
}

async function describeMetastoreCrawlerWithOptions(request: DescribeMetastoreCrawlerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeMetastoreCrawlerResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.crawlerId)) {
    query['CrawlerId'] = request.crawlerId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetastoreCrawler',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/crawler/describe`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      showName?: string(name='ShowName'),
      type?: string(name='Type'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(headers, runtime);
}

async function describeRegionsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/service/describeRegions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ExportQueryResultRequest {
  queryId?: string(name='QueryId'),
}

model ExportQueryResultResponseBody = {
  downloadUrlList?: [ string ](name='DownloadUrlList'),
  isReady?: boolean(name='IsReady'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExportQueryResultResponse = {
  headers: map[string]string(name='headers'),
  body: ExportQueryResultResponseBody(name='body'),
}

async function exportQueryResult(request: ExportQueryResultRequest): ExportQueryResultResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return exportQueryResultWithOptions(request, headers, runtime);
}

async function exportQueryResultWithOptions(request: ExportQueryResultRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ExportQueryResultResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.queryId)) {
    query['QueryId'] = request.queryId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportQueryResult',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/exportQueryResult`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetAsyncTaskStatusRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  taskId?: string(name='TaskId', description='TaskId'),
}

model GetAsyncTaskStatusResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  taskStatus?: TaskStatus(name='TaskStatus'),
}

model GetAsyncTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetAsyncTaskStatusResponseBody(name='body'),
}

async function getAsyncTaskStatus(request: GetAsyncTaskStatusRequest): GetAsyncTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAsyncTaskStatusWithOptions(request, headers, runtime);
}

async function getAsyncTaskStatusWithOptions(request: GetAsyncTaskStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAsyncTaskStatusResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAsyncTaskStatus',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetBlueprintInstanceRequest {
  blueprintInstanceId?: string(name='BlueprintInstanceId'),
}

model GetBlueprintInstanceResponseBody = {
  blueprintInstance?: {
    blueprintInstanceId?: string(name='BlueprintInstanceId'),
    blueprintType?: string(name='BlueprintType'),
    creator?: string(name='Creator'),
    dataSourceConfig?: string(name='DataSourceConfig'),
    executeCapacity?: long(name='ExecuteCapacity'),
    executeParameters?: string(name='ExecuteParameters'),
    executeType?: string(name='ExecuteType'),
    failureInfo?: string(name='FailureInfo'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    name?: string(name='Name'),
    owner?: string(name='Owner'),
    preProcessingConfig?: string(name='PreProcessingConfig'),
    regionId?: string(name='RegionId'),
    roleName?: string(name='RoleName'),
    status?: int32(name='Status'),
    targetDatabase?: string(name='TargetDatabase'),
    targetFormat?: string(name='TargetFormat'),
    targetLocationUri?: string(name='TargetLocationUri'),
    targetPartitions?: string(name='TargetPartitions'),
    targetTable?: string(name='TargetTable'),
    workflow?: {
      latestEndTime?: string(name='LatestEndTime'),
      latestInstanceStatus?: string(name='LatestInstanceStatus'),
      latestStartTime?: string(name='LatestStartTime'),
      workflowId?: string(name='WorkflowId'),
    }(name='Workflow'),
    workflowId?: string(name='WorkflowId'),
    workflowLastRunInstance?: {
      clusterId?: string(name='ClusterId'),
      duration?: long(name='Duration'),
      endTime?: string(name='EndTime'),
      failureInfo?: string(name='FailureInfo'),
      flowId?: string(name='FlowId'),
      flowInstanceId?: string(name='FlowInstanceId'),
      flowName?: string(name='FlowName'),
      projectId?: string(name='ProjectId'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
    }(name='WorkflowLastRunInstance'),
    workflowProjectId?: string(name='WorkflowProjectId'),
  }(name='BlueprintInstance'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetBlueprintInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: GetBlueprintInstanceResponseBody(name='body'),
}

async function getBlueprintInstance(request: GetBlueprintInstanceRequest): GetBlueprintInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBlueprintInstanceWithOptions(request, headers, runtime);
}

async function getBlueprintInstanceWithOptions(request: GetBlueprintInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetBlueprintInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.blueprintInstanceId)) {
    query['BlueprintInstanceId'] = request.blueprintInstanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetBlueprintInstance',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/blueprintinstance/get`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetDataSourceRequest {
  dataSourceId?: string(name='DataSourceId'),
}

model GetDataSourceResponseBody = {
  dataSource?: {
    connectionInfo?: string(name='ConnectionInfo'),
    dataSourceId?: string(name='DataSourceId'),
    dataSourceType?: string(name='DataSourceType'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    name?: string(name='Name'),
  }(name='DataSource'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: GetDataSourceResponseBody(name='body'),
}

async function getDataSource(request: GetDataSourceRequest): GetDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDataSourceWithOptions(request, headers, runtime);
}

async function getDataSourceWithOptions(request: GetDataSourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDataSourceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.dataSourceId)) {
    query['DataSourceId'] = request.dataSourceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDataSource',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/datasource/get`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetDatabaseRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  name?: string(name='Name', description='The name of the database to query.'),
}

model GetDatabaseResponseBody = {
  code?: string(name='Code', description='Response Code'),
  database?: Database(name='Database'),
  message?: string(name='Message', description='Response Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='API is success or not'),
}

model GetDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: GetDatabaseResponseBody(name='body'),
}

async function getDatabase(request: GetDatabaseRequest): GetDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDatabaseWithOptions(request, headers, runtime);
}

async function getDatabaseWithOptions(request: GetDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDatabaseResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDatabase',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetEtlResourceUsagesRequest {
  months?: string(name='Months'),
}

model GetEtlResourceUsagesResponseBody = {
  etlResourceUsages?: [ 
    {
      cuUsage?: long(name='CuUsage'),
      month?: string(name='Month'),
      queryTime?: string(name='QueryTime'),
    }
  ](name='EtlResourceUsages'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: string(name='TotalCount'),
}

model GetEtlResourceUsagesResponse = {
  headers: map[string]string(name='headers'),
  body: GetEtlResourceUsagesResponseBody(name='body'),
}

async function getEtlResourceUsages(request: GetEtlResourceUsagesRequest): GetEtlResourceUsagesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEtlResourceUsagesWithOptions(request, headers, runtime);
}

async function getEtlResourceUsagesWithOptions(request: GetEtlResourceUsagesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetEtlResourceUsagesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.months)) {
    query['Months'] = request.months;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEtlResourceUsages',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/measure/getEtlResourceUsages`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFunctionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  functionName?: string(name='FunctionName', description='FunctionName'),
}

model GetFunctionResponseBody = {
  code?: string(name='Code', description='Code'),
  function?: Function(name='Function'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GetFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: GetFunctionResponseBody(name='body'),
}

async function getFunction(request: GetFunctionRequest): GetFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionWithOptions(request, headers, runtime);
}

async function getFunctionWithOptions(request: GetFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunction',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetIndicatorDetailsRequest {
  dateRange?: string(name='dateRange'),
  indicatorCodeList?: [ string ](name='indicatorCodeList'),
  timeUnit?: string(name='timeUnit'),
}

model GetIndicatorDetailsResponseBody = {
  data?: [ 
    {
      indicatorStatistic?: {
        data?: long(name='data'),
        date?: string(name='date'),
      }(name='IndicatorStatistic'),
    }
  ](name='Data'),
  requestId?: string(name='requestId', description='Id of the request'),
}

model GetIndicatorDetailsResponse = {
  headers: map[string]string(name='headers'),
  body: GetIndicatorDetailsResponseBody(name='body'),
}

async function getIndicatorDetails(request: GetIndicatorDetailsRequest): GetIndicatorDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIndicatorDetailsWithOptions(request, headers, runtime);
}

async function getIndicatorDetailsWithOptions(request: GetIndicatorDetailsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetIndicatorDetailsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.dateRange)) {
    body['dateRange'] = request.dateRange;
  }
  if (!Util.isUnset(request.indicatorCodeList)) {
    body['indicatorCodeList'] = request.indicatorCodeList;
  }
  if (!Util.isUnset(request.timeUnit)) {
    body['timeUnit'] = request.timeUnit;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetIndicatorDetails',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/storageindicator/getIndicatorDetails`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetLatestDateResponse = {
  headers: map[string]string(name='headers'),
}

async function getLatestDate(): GetLatestDateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLatestDateWithOptions(headers, runtime);
}

async function getLatestDateWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetLatestDateResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLatestDate',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/storageindicator/getLatestDate`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetLockRequest {
  lockId?: long(name='LockId', description='LockId'),
}

model GetLockResponseBody = {
  code?: string(name='Code', description='Code'),
  lockStatus?: LockStatus(name='LockStatus'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GetLockResponse = {
  headers: map[string]string(name='headers'),
  body: GetLockResponseBody(name='body'),
}

async function getLock(request: GetLockRequest): GetLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLockWithOptions(request, headers, runtime);
}

async function getLockWithOptions(request: GetLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetLockResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.lockId)) {
    query['LockId'] = request.lockId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetMetaDataApiCallUsagesRequest {
  months?: string(name='Months'),
}

model GetMetaDataApiCallUsagesResponseBody = {
  metaDataApiCallUsages?: [ 
    {
      apiCall?: long(name='ApiCall'),
      month?: string(name='Month'),
      queryTime?: string(name='QueryTime'),
    }
  ](name='MetaDataApiCallUsages'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model GetMetaDataApiCallUsagesResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaDataApiCallUsagesResponseBody(name='body'),
}

async function getMetaDataApiCallUsages(request: GetMetaDataApiCallUsagesRequest): GetMetaDataApiCallUsagesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMetaDataApiCallUsagesWithOptions(request, headers, runtime);
}

async function getMetaDataApiCallUsagesWithOptions(request: GetMetaDataApiCallUsagesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMetaDataApiCallUsagesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.months)) {
    query['Months'] = request.months;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaDataApiCallUsages',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/measure/getMetaDataApiCallUsages`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetMetaDataStorageUsagesRequest {
  months?: string(name='Months'),
}

model GetMetaDataStorageUsagesResponseBody = {
  metaDataStorageUsages?: [ 
    {
      catalog?: long(name='Catalog'),
      database?: long(name='Database'),
      function?: long(name='Function'),
      month?: string(name='Month'),
      partition?: long(name='Partition'),
      queryTime?: string(name='QueryTime'),
      storageUsage?: long(name='StorageUsage'),
      table?: long(name='Table'),
    }
  ](name='MetaDataStorageUsages'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: string(name='TotalCount'),
}

model GetMetaDataStorageUsagesResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaDataStorageUsagesResponseBody(name='body'),
}

async function getMetaDataStorageUsages(request: GetMetaDataStorageUsagesRequest): GetMetaDataStorageUsagesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMetaDataStorageUsagesWithOptions(request, headers, runtime);
}

async function getMetaDataStorageUsagesWithOptions(request: GetMetaDataStorageUsagesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMetaDataStorageUsagesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.months)) {
    query['Months'] = request.months;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaDataStorageUsages',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/measure/getMetaDataStorageUsages`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetMetastoreMigrationRequest {
  instanceId?: string(name='InstanceId'),
}

model GetMetastoreMigrationResponseBody = {
  data?: {
    desc?: string(name='Desc'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    instanceId?: string(name='InstanceId'),
    metastoreInfo?: string(name='MetastoreInfo'),
    metastoreType?: string(name='MetastoreType'),
    name?: string(name='Name'),
    roleName?: string(name='RoleName'),
    runOptions?: string(name='RunOptions'),
    status?: string(name='Status'),
    workflowLastRunInstance?: {
      batchProgress?: int32(name='BatchProgress'),
      clusterId?: string(name='ClusterId'),
      duration?: long(name='Duration'),
      endTime?: long(name='EndTime'),
      executeMode?: string(name='ExecuteMode'),
      failureInfo?: string(name='FailureInfo'),
      flowExtendResult?: string(name='FlowExtendResult'),
      flowId?: string(name='FlowId'),
      flowInstanceId?: string(name='FlowInstanceId'),
      flowName?: string(name='FlowName'),
      offsetTime?: int32(name='OffsetTime'),
      opsUrl?: string(name='OpsUrl'),
      projectId?: string(name='ProjectId'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      totalCuUsage?: float(name='TotalCuUsage'),
    }(name='WorkflowLastRunInstance'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetastoreMigrationResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetastoreMigrationResponseBody(name='body'),
}

async function getMetastoreMigration(request: GetMetastoreMigrationRequest): GetMetastoreMigrationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMetastoreMigrationWithOptions(request, headers, runtime);
}

async function getMetastoreMigrationWithOptions(request: GetMetastoreMigrationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMetastoreMigrationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetastoreMigration',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/migration/get`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetMigrationWorkflowInstanceLogInfoRequest {
  flowInstanceId?: string(name='FlowInstanceId'),
}

model GetMigrationWorkflowInstanceLogInfoResponseBody = {
  data?: {
    instanceId?: string(name='InstanceId'),
    logContent?: string(name='LogContent'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model GetMigrationWorkflowInstanceLogInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetMigrationWorkflowInstanceLogInfoResponseBody(name='body'),
}

async function getMigrationWorkflowInstanceLogInfo(request: GetMigrationWorkflowInstanceLogInfoRequest): GetMigrationWorkflowInstanceLogInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMigrationWorkflowInstanceLogInfoWithOptions(request, headers, runtime);
}

async function getMigrationWorkflowInstanceLogInfoWithOptions(request: GetMigrationWorkflowInstanceLogInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMigrationWorkflowInstanceLogInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.flowInstanceId)) {
    query['FlowInstanceId'] = request.flowInstanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMigrationWorkflowInstanceLogInfo',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/migration/workflow/log/get`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPartitionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  partitionValues?: [ string ](name='PartitionValues'),
  tableName?: string(name='TableName', description='TableName'),
}

model GetPartitionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partition?: Partition(name='Partition'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GetPartitionResponse = {
  headers: map[string]string(name='headers'),
  body: GetPartitionResponseBody(name='body'),
}

async function getPartition(request: GetPartitionRequest): GetPartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPartitionWithOptions(request, headers, runtime);
}

async function getPartitionWithOptions(request: GetPartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetPartitionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionValues)) {
    body['PartitionValues'] = request.partitionValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetPartition',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  columnNames?: [ string ](name='ColumnNames'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  partitionNames?: [ string ](name='PartitionNames'),
  tableName?: string(name='TableName', description='TableName'),
}

model GetPartitionColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  columnNamesShrink?: string(name='ColumnNames'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  partitionNamesShrink?: string(name='PartitionNames'),
  tableName?: string(name='TableName', description='TableName'),
}

model GetPartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partitionStatisticsMap?: map[string][
    ColumnStatisticsObj
  ](name='PartitionStatisticsMap', description='PartitionStatisticsMap'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GetPartitionColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: GetPartitionColumnStatisticsResponseBody(name='body'),
}

async function getPartitionColumnStatistics(request: GetPartitionColumnStatisticsRequest): GetPartitionColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPartitionColumnStatisticsWithOptions(request, headers, runtime);
}

async function getPartitionColumnStatisticsWithOptions(tmpReq: GetPartitionColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetPartitionColumnStatisticsResponse {
  Util.validateModel(tmpReq);
  var request = new GetPartitionColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  if (!Util.isUnset(tmpReq.partitionNames)) {
    request.partitionNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.partitionNames, 'PartitionNames', 'json');
  }
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.columnNamesShrink)) {
    query['ColumnNames'] = request.columnNamesShrink;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionNamesShrink)) {
    query['PartitionNames'] = request.partitionNamesShrink;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPartitionColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/columnstatistics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetQueryResultRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  queryId?: string(name='QueryId'),
}

model GetQueryResultResponseBody = {
  duration?: long(name='Duration'),
  endTime?: string(name='EndTime'),
  errorMessage?: string(name='ErrorMessage'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  id?: string(name='Id'),
  jobCompleted?: boolean(name='JobCompleted'),
  logs?: string(name='Logs'),
  owner?: long(name='Owner'),
  progress?: int32(name='Progress'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resultTmpDb?: string(name='ResultTmpDb'),
  resultTmpTable?: string(name='ResultTmpTable'),
  rowCount?: int32(name='RowCount'),
  rowCountOverLimit?: boolean(name='RowCountOverLimit'),
  rows?: string(name='Rows'),
  schema?: string(name='Schema'),
  sql?: string(name='Sql'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
  success?: boolean(name='Success'),
}

model GetQueryResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetQueryResultResponseBody(name='body'),
}

async function getQueryResult(request: GetQueryResultRequest): GetQueryResultResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getQueryResultWithOptions(request, headers, runtime);
}

async function getQueryResultWithOptions(request: GetQueryResultRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetQueryResultResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryId)) {
    query['QueryId'] = request.queryId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetQueryResult',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/getQueryResult`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRdsDBInstanceAttributeRequest {
  DBInstanceId?: string(name='DBInstanceId'),
}

model GetRdsDBInstanceAttributeResponseBody = {
  DBInstance?: {
    connectionString?: string(name='ConnectionString'),
    DBInstanceDescription?: string(name='DBInstanceDescription'),
    DBInstanceId?: string(name='DBInstanceId'),
    DBInstanceNetType?: string(name='DBInstanceNetType'),
    DBInstanceStatus?: string(name='DBInstanceStatus'),
    DBInstanceType?: string(name='DBInstanceType'),
    engine?: string(name='Engine'),
    engineVersion?: string(name='EngineVersion'),
    instanceNetworkType?: string(name='InstanceNetworkType'),
    port?: string(name='Port'),
    regionId?: string(name='RegionId'),
    resourceGroupId?: string(name='ResourceGroupId'),
    vSwitchId?: string(name='VSwitchId'),
    vpcCloudInstanceId?: string(name='VpcCloudInstanceId'),
    vpcId?: string(name='VpcId'),
    zoneId?: string(name='ZoneId'),
  }(name='DBInstance'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetRdsDBInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: GetRdsDBInstanceAttributeResponseBody(name='body'),
}

async function getRdsDBInstanceAttribute(request: GetRdsDBInstanceAttributeRequest): GetRdsDBInstanceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRdsDBInstanceAttributeWithOptions(request, headers, runtime);
}

async function getRdsDBInstanceAttributeWithOptions(request: GetRdsDBInstanceAttributeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRdsDBInstanceAttributeResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRdsDBInstanceAttribute',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/resource/rds/getDBInstanceAttribute`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRegionClusterInfoResponseBody = {
  data?: {
    clusterType?: string(name='ClusterType'),
    regionId?: string(name='RegionId'),
    zoneId?: string(name='ZoneId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetRegionClusterInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetRegionClusterInfoResponseBody(name='body'),
}

async function getRegionClusterInfo(): GetRegionClusterInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRegionClusterInfoWithOptions(headers, runtime);
}

async function getRegionClusterInfoWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetRegionClusterInfoResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetRegionClusterInfo',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/profile/getRegionClusterInfo`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRegionStatusRequest {
  regionId?: string(name='RegionId'),
}

model GetRegionStatusResponseBody = {
  data?: {
    accountStatus?: string(name='AccountStatus'),
    isDependencyReady?: boolean(name='IsDependencyReady'),
    isDlfServiceOpen?: boolean(name='IsDlfServiceOpen'),
    regionId?: string(name='RegionId'),
    regionStatus?: string(name='RegionStatus'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetRegionStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetRegionStatusResponseBody(name='body'),
}

async function getRegionStatus(request: GetRegionStatusRequest): GetRegionStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRegionStatusWithOptions(request, headers, runtime);
}

async function getRegionStatusWithOptions(request: GetRegionStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRegionStatusResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRegionStatus',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/service/getRegionStatus`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetServiceStatusRequest {
  regionId?: string(name='RegionId'),
}

model GetServiceStatusResponseBody = {
  data?: {
    hasRamPermissions?: boolean(name='HasRamPermissions'),
    isDlfServiceOpen?: boolean(name='IsDlfServiceOpen'),
    isOssOpen?: boolean(name='IsOssOpen'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceStatusResponseBody(name='body'),
}

async function getServiceStatus(request: GetServiceStatusRequest): GetServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceStatusWithOptions(request, headers, runtime);
}

async function getServiceStatusWithOptions(request: GetServiceStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceStatusResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceStatus',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/service/getServiceStatus`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetStatisticsRequest {
  singleIndicatorList?: [ 
    {
      indicatorCode?: string(name='indicatorCode'),
      indicatorTypes?: [ string ](name='indicatorTypes'),
    }
  ](name='singleIndicatorList'),
}

model GetStatisticsResponse = {
  headers: map[string]string(name='headers'),
}

async function getStatistics(request: GetStatisticsRequest): GetStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getStatisticsWithOptions(request, headers, runtime);
}

async function getStatisticsWithOptions(request: GetStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetStatisticsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.singleIndicatorList)) {
    body['singleIndicatorList'] = request.singleIndicatorList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/storageindicator/getStatistics`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetStorageAnalysisRequest {
  analysisTypeList?: [ string ](name='analysisTypeList'),
  date?: string(name='date'),
  dbName?: string(name='dbName'),
  tableName?: string(name='tableName'),
}

model GetStorageAnalysisResponseBody = {
  requestId?: string(name='requestId', description='Id of the request'),
}

model GetStorageAnalysisResponse = {
  headers: map[string]string(name='headers'),
  body: GetStorageAnalysisResponseBody(name='body'),
}

async function getStorageAnalysis(request: GetStorageAnalysisRequest): GetStorageAnalysisResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getStorageAnalysisWithOptions(request, headers, runtime);
}

async function getStorageAnalysisWithOptions(request: GetStorageAnalysisRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetStorageAnalysisResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.analysisTypeList)) {
    body['analysisTypeList'] = request.analysisTypeList;
  }
  if (!Util.isUnset(request.date)) {
    body['date'] = request.date;
  }
  if (!Util.isUnset(request.dbName)) {
    body['dbName'] = request.dbName;
  }
  if (!Util.isUnset(request.tableName)) {
    body['tableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetStorageAnalysis',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/storageindicator/getStorageAnalysis`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetStorageRankRequest {
  order?: string(name='order'),
  rankType?: [ string ](name='rankType'),
}

model GetStorageRankResponseBody = {
  requestId?: string(name='requestId', description='Id of the request'),
}

model GetStorageRankResponse = {
  headers: map[string]string(name='headers'),
  body: GetStorageRankResponseBody(name='body'),
}

async function getStorageRank(request: GetStorageRankRequest): GetStorageRankResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getStorageRankWithOptions(request, headers, runtime);
}

async function getStorageRankWithOptions(request: GetStorageRankRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetStorageRankResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.order)) {
    body['order'] = request.order;
  }
  if (!Util.isUnset(request.rankType)) {
    body['rankType'] = request.rankType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetStorageRank',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/storageindicator/getStorageRank`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTableRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
}

model GetTableResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  table?: Table(name='Table'),
}

model GetTableResponse = {
  headers: map[string]string(name='headers'),
  body: GetTableResponseBody(name='body'),
}

async function getTable(request: GetTableRequest): GetTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableWithOptions(request, headers, runtime);
}

async function getTableWithOptions(request: GetTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTableColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  columnNames?: [ string ](name='ColumnNames'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
}

model GetTableColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  columnNamesShrink?: string(name='ColumnNames'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
}

model GetTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  columnStatisticsObjList?: [
    ColumnStatisticsObj
  ](name='ColumnStatisticsObjList', description='ColumnStatisticsObjList'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GetTableColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: GetTableColumnStatisticsResponseBody(name='body'),
}

async function getTableColumnStatistics(request: GetTableColumnStatisticsRequest): GetTableColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableColumnStatisticsWithOptions(request, headers, runtime);
}

async function getTableColumnStatisticsWithOptions(tmpReq: GetTableColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableColumnStatisticsResponse {
  Util.validateModel(tmpReq);
  var request = new GetTableColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.columnNamesShrink)) {
    query['ColumnNames'] = request.columnNamesShrink;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTableColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/columnstatistics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTableProfileRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
}

model GetTableProfileResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tableProfile?: TableProfile(name='TableProfile'),
}

model GetTableProfileResponse = {
  headers: map[string]string(name='headers'),
  body: GetTableProfileResponseBody(name='body'),
}

async function getTableProfile(request: GetTableProfileRequest): GetTableProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableProfileWithOptions(request, headers, runtime);
}

async function getTableProfileWithOptions(request: GetTableProfileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableProfileResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTableProfile',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/metastorehouse/catalog/database/tableprofile`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTableVersionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
  versionId?: int32(name='VersionId', description='Table Version'),
}

model GetTableVersionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tableVersion?: TableVersion(name='TableVersion'),
}

model GetTableVersionResponse = {
  headers: map[string]string(name='headers'),
  body: GetTableVersionResponseBody(name='body'),
}

async function getTableVersion(request: GetTableVersionRequest): GetTableVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableVersionWithOptions(request, headers, runtime);
}

async function getTableVersionWithOptions(request: GetTableVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableVersionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTableVersion',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetWorkflowInstanceRequest {
  flowInstanceId?: string(name='FlowInstanceId'),
  projectId?: string(name='ProjectId'),
}

model GetWorkflowInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  workflowInstanceDetail?: {
    failedNodeInstance?: {
      externalId?: string(name='ExternalId'),
      externalInfo?: string(name='ExternalInfo'),
      jobName?: string(name='JobName'),
      jobType?: string(name='JobType'),
      nodeInstanceId?: string(name='NodeInstanceId'),
      status?: string(name='Status'),
    }(name='FailedNodeInstance'),
    flowInstanceId?: string(name='FlowInstanceId'),
    flowNodeSize?: string(name='FlowNodeSize'),
    hasFailedNode?: string(name='HasFailedNode'),
    runtimeLogs?: [ 
      {
        bizTime?: string(name='BizTime'),
        instanceId?: string(name='InstanceId'),
        logContent?: string(name='LogContent'),
        logId?: string(name='LogId'),
        logSummary?: string(name='LogSummary'),
        logType?: string(name='LogType'),
        trigger?: string(name='Trigger'),
      }
    ](name='RuntimeLogs'),
  }(name='WorkflowInstanceDetail'),
}

model GetWorkflowInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: GetWorkflowInstanceResponseBody(name='body'),
}

async function getWorkflowInstance(request: GetWorkflowInstanceRequest): GetWorkflowInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getWorkflowInstanceWithOptions(request, headers, runtime);
}

async function getWorkflowInstanceWithOptions(request: GetWorkflowInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetWorkflowInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.flowInstanceId)) {
    query['FlowInstanceId'] = request.flowInstanceId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWorkflowInstance',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/blueprintinstance/getWorkflowInstance`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListBlueprintInstanceCreatorsResponseBody = {
  data?: [ 
    {
      creator?: string(name='Creator'),
      creatorLoginName?: string(name='CreatorLoginName'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListBlueprintInstanceCreatorsResponse = {
  headers: map[string]string(name='headers'),
  body: ListBlueprintInstanceCreatorsResponseBody(name='body'),
}

async function listBlueprintInstanceCreators(): ListBlueprintInstanceCreatorsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listBlueprintInstanceCreatorsWithOptions(headers, runtime);
}

async function listBlueprintInstanceCreatorsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListBlueprintInstanceCreatorsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListBlueprintInstanceCreators',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/blueprintinstance/listBlueprintInstanceCreators`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListBlueprintInstancesRequest {
  blueprintInstanceId?: string(name='BlueprintInstanceId'),
  blueprintType?: string(name='BlueprintType'),
  creatorUid?: string(name='CreatorUid'),
  executeType?: string(name='ExecuteType'),
  namePrefix?: string(name='NamePrefix'),
  orderCol?: string(name='OrderCol'),
  orderType?: string(name='OrderType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model ListBlueprintInstancesResponseBody = {
  blueprintInstances?: [ 
    {
      batchProgress?: int32(name='BatchProgress'),
      blueprintInstanceId?: string(name='BlueprintInstanceId'),
      blueprintType?: string(name='BlueprintType'),
      creator?: long(name='Creator'),
      creatorLoginName?: string(name='CreatorLoginName'),
      dataSourceConfig?: string(name='DataSourceConfig'),
      executeCapacity?: string(name='ExecuteCapacity'),
      executeParameters?: string(name='ExecuteParameters'),
      executeType?: string(name='ExecuteType'),
      failureInfo?: string(name='FailureInfo'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      name?: string(name='Name'),
      offsetTime?: int32(name='OffsetTime'),
      owner?: long(name='Owner'),
      regionId?: string(name='RegionId'),
      roleName?: string(name='RoleName'),
      status?: int32(name='Status'),
      targetDatabase?: string(name='TargetDatabase'),
      targetFormat?: string(name='TargetFormat'),
      targetLocationUri?: string(name='TargetLocationUri'),
      targetPartitions?: string(name='TargetPartitions'),
      targetTable?: string(name='TargetTable'),
      workflow?: {
        latestEndTime?: string(name='LatestEndTime'),
        latestInstanceStatus?: string(name='LatestInstanceStatus'),
        latestStartTime?: string(name='LatestStartTime'),
        workflowId?: string(name='WorkflowId'),
      }(name='Workflow'),
      workflowId?: string(name='WorkflowId'),
      workflowLastRunInstance?: {
        batchProgress?: int32(name='BatchProgress'),
        clusterId?: string(name='ClusterId'),
        duration?: long(name='Duration'),
        endTime?: string(name='EndTime'),
        failureInfo?: string(name='FailureInfo'),
        flowId?: string(name='FlowId'),
        flowInstanceId?: string(name='FlowInstanceId'),
        flowName?: string(name='FlowName'),
        offsetTime?: int32(name='OffsetTime'),
        projectId?: string(name='ProjectId'),
        startTime?: string(name='StartTime'),
        status?: string(name='Status'),
      }(name='WorkflowLastRunInstance'),
      workflowProjectId?: string(name='WorkflowProjectId'),
    }
  ](name='BlueprintInstances'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListBlueprintInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListBlueprintInstancesResponseBody(name='body'),
}

async function listBlueprintInstances(request: ListBlueprintInstancesRequest): ListBlueprintInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listBlueprintInstancesWithOptions(request, headers, runtime);
}

async function listBlueprintInstancesWithOptions(request: ListBlueprintInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListBlueprintInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.blueprintInstanceId)) {
    query['BlueprintInstanceId'] = request.blueprintInstanceId;
  }
  if (!Util.isUnset(request.blueprintType)) {
    query['BlueprintType'] = request.blueprintType;
  }
  if (!Util.isUnset(request.creatorUid)) {
    query['CreatorUid'] = request.creatorUid;
  }
  if (!Util.isUnset(request.executeType)) {
    query['ExecuteType'] = request.executeType;
  }
  if (!Util.isUnset(request.namePrefix)) {
    query['NamePrefix'] = request.namePrefix;
  }
  if (!Util.isUnset(request.orderCol)) {
    query['OrderCol'] = request.orderCol;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBlueprintInstances',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/blueprintinstance/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListCatalogsRequest {
  idPattern?: string(name='IdPattern', description='catalogId'),
  nextPageToken?: string(name='NextPageToken', description='namePattern'),
  pageSize?: int32(name='PageSize', description='pageSize'),
}

model ListCatalogsResponseBody = {
  catalogs?: [
    Catalog
  ](name='Catalogs', description='Catalogs'),
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListCatalogsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCatalogsResponseBody(name='body'),
}

async function listCatalogs(request: ListCatalogsRequest): ListCatalogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCatalogsWithOptions(request, headers, runtime);
}

async function listCatalogsWithOptions(request: ListCatalogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCatalogsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.idPattern)) {
    query['IdPattern'] = request.idPattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCatalogs',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListCrawlerWorkflowInstanceRequest {
  crawlerId?: string(name='CrawlerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model ListCrawlerWorkflowInstanceResponseBody = {
  data?: [ 
    {
      batchProgress?: int32(name='BatchProgress'),
      clusterId?: string(name='ClusterId'),
      crawlerId?: string(name='CrawlerId'),
      crawlerIsDelete?: boolean(name='CrawlerIsDelete'),
      creator?: long(name='Creator'),
      datasourceExcludePath?: string(name='DatasourceExcludePath'),
      datasourcePath?: string(name='DatasourcePath'),
      datasourceType?: string(name='DatasourceType'),
      duration?: int32(name='Duration'),
      endTime?: long(name='EndTime'),
      executeCron?: string(name='ExecuteCron'),
      executeMode?: string(name='ExecuteMode'),
      executeType?: string(name='ExecuteType'),
      failureInfo?: string(name='FailureInfo'),
      fileFormat?: string(name='FileFormat'),
      fileFormatConfig?: string(name='FileFormatConfig'),
      flowExtendResult?: string(name='FlowExtendResult'),
      flowId?: string(name='FlowId'),
      flowInstanceId?: string(name='FlowInstanceId'),
      flowName?: string(name='FlowName'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      name?: string(name='Name'),
      owner?: long(name='Owner'),
      projectId?: string(name='ProjectId'),
      regionId?: string(name='RegionId'),
      roleName?: string(name='RoleName'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      targetDatabase?: string(name='TargetDatabase'),
      targetTablePrefix?: string(name='TargetTablePrefix'),
      targetUpdateStrategy?: string(name='TargetUpdateStrategy'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListCrawlerWorkflowInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ListCrawlerWorkflowInstanceResponseBody(name='body'),
}

async function listCrawlerWorkflowInstance(request: ListCrawlerWorkflowInstanceRequest): ListCrawlerWorkflowInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCrawlerWorkflowInstanceWithOptions(request, headers, runtime);
}

async function listCrawlerWorkflowInstanceWithOptions(request: ListCrawlerWorkflowInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCrawlerWorkflowInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.crawlerId)) {
    query['CrawlerId'] = request.crawlerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCrawlerWorkflowInstance',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/crawler/workflow/listInstance`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDataSourcesRequest {
  dataSourceType?: string(name='DataSourceType'),
  name?: string(name='Name'),
  orderCol?: string(name='OrderCol'),
  orderType?: string(name='OrderType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListDataSourcesResponseBody = {
  dataSources?: [ 
    {
      connectionInfo?: string(name='ConnectionInfo'),
      dataSourceId?: string(name='DataSourceId'),
      dataSourceType?: string(name='DataSourceType'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      name?: string(name='Name'),
    }
  ](name='DataSources'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListDataSourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataSourcesResponseBody(name='body'),
}

async function listDataSources(request: ListDataSourcesRequest): ListDataSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataSourcesWithOptions(request, headers, runtime);
}

async function listDataSourcesWithOptions(request: ListDataSourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataSourcesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.dataSourceType)) {
    query['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.orderCol)) {
    query['OrderCol'] = request.orderCol;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDataSources',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/datasource/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDatabasesRequest {
  catalogId?: string(name='CatalogId', description='catalogId'),
  namePattern?: string(name='NamePattern', description='namePattern'),
  nextPageToken?: string(name='NextPageToken', description='namePattern'),
  pageSize?: int32(name='PageSize', description='pageSize'),
}

model ListDatabasesResponseBody = {
  code?: string(name='Code', description='Code'),
  databases?: [
    Database
  ](name='Databases', description='Database List'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListDatabasesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDatabasesResponseBody(name='body'),
}

async function listDatabases(request: ListDatabasesRequest): ListDatabasesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDatabasesWithOptions(request, headers, runtime);
}

async function listDatabasesWithOptions(request: ListDatabasesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDatabasesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.namePattern)) {
    query['NamePattern'] = request.namePattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDatabases',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFunctionNamesRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  functionNamePattern?: string(name='FunctionNamePattern', description='FunctionNamePattern'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  pageSize?: int32(name='PageSize', description='PageSize'),
}

model ListFunctionNamesResponseBody = {
  code?: string(name='Code', description='Code'),
  functionNames?: [ string ](name='FunctionNames', description='FunctionNames'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListFunctionNamesResponse = {
  headers: map[string]string(name='headers'),
  body: ListFunctionNamesResponseBody(name='body'),
}

async function listFunctionNames(request: ListFunctionNamesRequest): ListFunctionNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionNamesWithOptions(request, headers, runtime);
}

async function listFunctionNamesWithOptions(request: ListFunctionNamesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionNamesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionNamePattern)) {
    query['FunctionNamePattern'] = request.functionNamePattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctionNames',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions/names`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFunctionsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  functionNamePattern?: string(name='FunctionNamePattern', description='FunctionNamePattern'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  pageSize?: int32(name='PageSize', description='PageSize'),
}

model ListFunctionsResponseBody = {
  code?: string(name='Code', description='Code'),
  functions?: [
    Function
  ](name='Functions', description='Functions'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListFunctionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFunctionsResponseBody(name='body'),
}

async function listFunctions(request: ListFunctionsRequest): ListFunctionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionsWithOptions(request, headers, runtime);
}

async function listFunctionsWithOptions(request: ListFunctionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionNamePattern)) {
    query['FunctionNamePattern'] = request.functionNamePattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListMetastoreCrawlerRequest {
  creator?: string(name='Creator'),
  dataSourceType?: string(name='DataSourceType'),
  executeType?: string(name='ExecuteType'),
  name?: string(name='Name'),
  orderCol?: string(name='OrderCol'),
  orderType?: string(name='OrderType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model ListMetastoreCrawlerResponseBody = {
  data?: [ 
    {
      creator?: string(name='Creator'),
      creatorLoginName?: string(name='CreatorLoginName'),
      datasourceExcludePath?: string(name='DatasourceExcludePath'),
      datasourcePath?: string(name='DatasourcePath'),
      datasourceType?: string(name='DatasourceType'),
      executeMode?: string(name='ExecuteMode'),
      executeType?: string(name='ExecuteType'),
      fileFormat?: string(name='FileFormat'),
      fileFormatConfig?: string(name='FileFormatConfig'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      owner?: string(name='Owner'),
      regionId?: string(name='RegionId'),
      roleName?: string(name='RoleName'),
      status?: string(name='Status'),
      success?: boolean(name='Success'),
      targetDatabase?: string(name='TargetDatabase'),
      targetTablePrefix?: string(name='TargetTablePrefix'),
      targetUpdateStrategy?: string(name='TargetUpdateStrategy'),
      workflowLastRunInstance?: {
        batchProgress?: int32(name='BatchProgress'),
        clusterId?: string(name='ClusterId'),
        duration?: int32(name='Duration'),
        endTime?: long(name='EndTime'),
        failureInfo?: string(name='FailureInfo'),
        flowExtendResult?: string(name='FlowExtendResult'),
        flowId?: string(name='FlowId'),
        flowInstanceId?: string(name='FlowInstanceId'),
        flowName?: string(name='FlowName'),
        projectId?: string(name='ProjectId'),
        startTime?: long(name='StartTime'),
        status?: string(name='Status'),
      }(name='WorkflowLastRunInstance'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListMetastoreCrawlerResponse = {
  headers: map[string]string(name='headers'),
  body: ListMetastoreCrawlerResponseBody(name='body'),
}

async function listMetastoreCrawler(request: ListMetastoreCrawlerRequest): ListMetastoreCrawlerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMetastoreCrawlerWithOptions(request, headers, runtime);
}

async function listMetastoreCrawlerWithOptions(request: ListMetastoreCrawlerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMetastoreCrawlerResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.creator)) {
    query['Creator'] = request.creator;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    query['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.executeType)) {
    query['ExecuteType'] = request.executeType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.orderCol)) {
    query['OrderCol'] = request.orderCol;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMetastoreCrawler',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/crawler/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListMetastoreCrawlerCreatorsResponseBody = {
  data?: [ 
    {
      creator?: string(name='Creator'),
      creatorLoginName?: string(name='CreatorLoginName'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListMetastoreCrawlerCreatorsResponse = {
  headers: map[string]string(name='headers'),
  body: ListMetastoreCrawlerCreatorsResponseBody(name='body'),
}

async function listMetastoreCrawlerCreators(): ListMetastoreCrawlerCreatorsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMetastoreCrawlerCreatorsWithOptions(headers, runtime);
}

async function listMetastoreCrawlerCreatorsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListMetastoreCrawlerCreatorsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListMetastoreCrawlerCreators',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/crawler/listCreators`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListMetastoreMigrationsRequest {
  instanceId?: string(name='InstanceId'),
  metastoreType?: string(name='MetastoreType'),
  name?: string(name='Name'),
  orderCol?: string(name='OrderCol'),
  orderType?: string(name='OrderType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model ListMetastoreMigrationsResponseBody = {
  data?: [ 
    {
      desc?: string(name='Desc'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      instanceId?: string(name='InstanceId'),
      metastoreInfo?: string(name='MetastoreInfo'),
      metastoreType?: string(name='MetastoreType'),
      name?: string(name='Name'),
      roleName?: string(name='RoleName'),
      runOptions?: string(name='RunOptions'),
      status?: string(name='Status'),
      workflowLastRunInstance?: {
        batchProgress?: int32(name='BatchProgress'),
        clusterId?: string(name='ClusterId'),
        duration?: long(name='Duration'),
        endTime?: long(name='EndTime'),
        executeMode?: string(name='ExecuteMode'),
        failureInfo?: string(name='FailureInfo'),
        flowExtendResult?: string(name='FlowExtendResult'),
        flowId?: string(name='FlowId'),
        flowInstanceId?: string(name='FlowInstanceId'),
        flowName?: string(name='FlowName'),
        offsetTime?: int32(name='OffsetTime'),
        opsUrl?: string(name='OpsUrl'),
        projectId?: string(name='ProjectId'),
        startTime?: long(name='StartTime'),
        status?: string(name='Status'),
        totalCuUsage?: float(name='TotalCuUsage'),
      }(name='WorkflowLastRunInstance'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListMetastoreMigrationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListMetastoreMigrationsResponseBody(name='body'),
}

async function listMetastoreMigrations(request: ListMetastoreMigrationsRequest): ListMetastoreMigrationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMetastoreMigrationsWithOptions(request, headers, runtime);
}

async function listMetastoreMigrationsWithOptions(request: ListMetastoreMigrationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMetastoreMigrationsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.metastoreType)) {
    query['MetastoreType'] = request.metastoreType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.orderCol)) {
    query['OrderCol'] = request.orderCol;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMetastoreMigrations',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/migration/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListMigrationWorkflowInstancesRequest {
  instanceId?: string(name='InstanceId'),
  orderCol?: string(name='OrderCol'),
  orderType?: string(name='OrderType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model ListMigrationWorkflowInstancesResponseBody = {
  data?: [ 
    {
      batchProgress?: int32(name='BatchProgress'),
      duration?: long(name='Duration'),
      endTime?: long(name='EndTime'),
      failureInfo?: string(name='FailureInfo'),
      flowExtendResult?: string(name='FlowExtendResult'),
      flowId?: string(name='FlowId'),
      flowInstanceId?: string(name='FlowInstanceId'),
      flowName?: string(name='FlowName'),
      instanceId?: string(name='InstanceId'),
      metastoreType?: string(name='MetastoreType'),
      name?: string(name='Name'),
      projectId?: string(name='ProjectId'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListMigrationWorkflowInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListMigrationWorkflowInstancesResponseBody(name='body'),
}

async function listMigrationWorkflowInstances(request: ListMigrationWorkflowInstancesRequest): ListMigrationWorkflowInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMigrationWorkflowInstancesWithOptions(request, headers, runtime);
}

async function listMigrationWorkflowInstancesWithOptions(request: ListMigrationWorkflowInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMigrationWorkflowInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.orderCol)) {
    query['OrderCol'] = request.orderCol;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMigrationWorkflowInstances',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/migration/workflow/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPartitionNamesRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  pageSize?: int32(name='PageSize', description='PageSize'),
  partialPartValues?: [ string ](name='PartialPartValues'),
  tableName?: string(name='TableName', description='TableName'),
}

model ListPartitionNamesResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  partitionNames?: [ string ](name='PartitionNames', description='PartitionNames'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListPartitionNamesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPartitionNamesResponseBody(name='body'),
}

async function listPartitionNames(request: ListPartitionNamesRequest): ListPartitionNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionNamesWithOptions(request, headers, runtime);
}

async function listPartitionNamesWithOptions(request: ListPartitionNamesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPartitionNamesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    body['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.partialPartValues)) {
    body['PartialPartValues'] = request.partialPartValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPartitionNames',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/names`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPartitionsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  isShareSd?: boolean(name='IsShareSd', description='IsShareSd'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  pageSize?: int32(name='PageSize', description='PageSize'),
  partialPartValues?: [ string ](name='PartialPartValues'),
  tableName?: string(name='TableName', description='TableName'),
}

model ListPartitionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs', description='PartitionSpecs'),
  partitions?: [
    Partition
  ](name='Partitions', description='Partitions'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListPartitionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListPartitionsResponseBody(name='body'),
}

async function listPartitions(request: ListPartitionsRequest): ListPartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionsWithOptions(request, headers, runtime);
}

async function listPartitionsWithOptions(request: ListPartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.isShareSd)) {
    body['IsShareSd'] = request.isShareSd;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    body['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.partialPartValues)) {
    body['PartialPartValues'] = request.partialPartValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPartitionsByExprResponse = {
  headers: map[string]string(name='headers'),
}

async function listPartitionsByExpr(): ListPartitionsByExprResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionsByExprWithOptions(headers, runtime);
}

async function listPartitionsByExprWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListPartitionsByExprResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListPartitionsByExpr',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/listbyexpr`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ListPartitionsByFilterRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  filter?: string(name='Filter', description='Filter'),
  isShareSd?: boolean(name='IsShareSd', description='IsShareSd'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  pageSize?: int32(name='PageSize', description='PageSize'),
  tableName?: string(name='TableName', description='TableName'),
}

model ListPartitionsByFilterResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs', description='PartitionSpecs'),
  partitions?: [
    Partition
  ](name='Partitions', description='Partitions'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListPartitionsByFilterResponse = {
  headers: map[string]string(name='headers'),
  body: ListPartitionsByFilterResponseBody(name='body'),
}

async function listPartitionsByFilter(request: ListPartitionsByFilterRequest): ListPartitionsByFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionsByFilterWithOptions(request, headers, runtime);
}

async function listPartitionsByFilterWithOptions(request: ListPartitionsByFilterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPartitionsByFilterResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.filter)) {
    body['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.isShareSd)) {
    body['IsShareSd'] = request.isShareSd;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    body['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPartitionsByFilter',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/listbyfilter`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListQueryHistoryRequest {
  keyword?: string(name='Keyword'),
  orderCol?: string(name='OrderCol'),
  orderType?: string(name='OrderType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListQueryHistoryResponseBody = {
  data?: [ 
    {
      creator?: long(name='Creator'),
      creatorLoginName?: string(name='CreatorLoginName'),
      duration?: long(name='Duration'),
      endTime?: string(name='EndTime'),
      errorMessage?: string(name='ErrorMessage'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: string(name='Id'),
      jobCompleted?: boolean(name='JobCompleted'),
      owner?: string(name='Owner'),
      progress?: int32(name='Progress'),
      regionId?: string(name='RegionId'),
      resultOssPath?: string(name='ResultOssPath'),
      resultTmpDb?: string(name='ResultTmpDb'),
      resultTmpTable?: string(name='ResultTmpTable'),
      rowCount?: int32(name='RowCount'),
      rowCountOverLimit?: string(name='RowCountOverLimit'),
      sql?: string(name='Sql'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      success?: boolean(name='Success'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListQueryHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: ListQueryHistoryResponseBody(name='body'),
}

async function listQueryHistory(request: ListQueryHistoryRequest): ListQueryHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listQueryHistoryWithOptions(request, headers, runtime);
}

async function listQueryHistoryWithOptions(request: ListQueryHistoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListQueryHistoryResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.orderCol)) {
    query['OrderCol'] = request.orderCol;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListQueryHistory',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/listQueryHistory`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRdsDBInstancesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListRdsDBInstancesResponseBody = {
  rdsInstances?: [ 
    {
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceNetType?: string(name='DBInstanceNetType'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      DBInstanceType?: string(name='DBInstanceType'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      instanceNetworkType?: string(name='InstanceNetworkType'),
      lockMode?: string(name='LockMode'),
      mutriORsignle?: boolean(name='MutriORsignle'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      vSwitchId?: string(name='VSwitchId'),
      vpcCloudInstanceId?: string(name='VpcCloudInstanceId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='RdsInstances'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListRdsDBInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListRdsDBInstancesResponseBody(name='body'),
}

async function listRdsDBInstances(request: ListRdsDBInstancesRequest): ListRdsDBInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRdsDBInstancesWithOptions(request, headers, runtime);
}

async function listRdsDBInstancesWithOptions(request: ListRdsDBInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRdsDBInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRdsDBInstances',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/resource/rds/listDBInstances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSavedQueryRequest {
  keyword?: string(name='Keyword'),
  orderCol?: string(name='OrderCol'),
  orderType?: string(name='OrderType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListSavedQueryResponseBody = {
  data?: [ 
    {
      creator?: string(name='Creator'),
      creatorLoginName?: string(name='CreatorLoginName'),
      description?: string(name='Description'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      owner?: string(name='Owner'),
      regionId?: string(name='RegionId'),
      sql?: string(name='Sql'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListSavedQueryResponse = {
  headers: map[string]string(name='headers'),
  body: ListSavedQueryResponseBody(name='body'),
}

async function listSavedQuery(request: ListSavedQueryRequest): ListSavedQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSavedQueryWithOptions(request, headers, runtime);
}

async function listSavedQueryWithOptions(request: ListSavedQueryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSavedQueryResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.orderCol)) {
    query['OrderCol'] = request.orderCol;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSavedQuery',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/listSavedQuery`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListStorageCollectorResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  storageCollectors?: [ 
    {
      datasourceType?: string(name='DatasourceType'),
      status?: string(name='Status'),
    }
  ](name='StorageCollectors'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListStorageCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: ListStorageCollectorResponseBody(name='body'),
}

async function listStorageCollector(): ListStorageCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listStorageCollectorWithOptions(headers, runtime);
}

async function listStorageCollectorWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListStorageCollectorResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListStorageCollector',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/storagecollect/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTableNamesRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  pageSize?: int32(name='PageSize', description='PageSize'),
  tableNamePattern?: string(name='TableNamePattern', description='TableNamePattern'),
  tableType?: string(name='TableType', description='TableType filter'),
}

model ListTableNamesResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tableNames?: [ string ](name='TableNames', description='TableNames'),
}

model ListTableNamesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTableNamesResponseBody(name='body'),
}

async function listTableNames(request: ListTableNamesRequest): ListTableNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTableNamesWithOptions(request, headers, runtime);
}

async function listTableNamesWithOptions(request: ListTableNamesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTableNamesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tableNamePattern)) {
    query['TableNamePattern'] = request.tableNamePattern;
  }
  if (!Util.isUnset(request.tableType)) {
    query['TableType'] = request.tableType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTableNames',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/names`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTableVersionsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  pageSize?: int32(name='PageSize', description='max result of this query'),
  tableName?: string(name='TableName', description='TableName'),
}

model ListTableVersionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tableVersions?: [
    TableVersion
  ](name='TableVersions', description='table versions'),
}

model ListTableVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTableVersionsResponseBody(name='body'),
}

async function listTableVersions(request: ListTableVersionsRequest): ListTableVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTableVersionsWithOptions(request, headers, runtime);
}

async function listTableVersionsWithOptions(request: ListTableVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTableVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTableVersions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/versions/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTablesRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  pageSize?: int32(name='PageSize', description='PageSize'),
  tableNamePattern?: string(name='TableNamePattern', description='TableNamePattern'),
  tableType?: string(name='TableType', description='TableType filter'),
}

model ListTablesResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tables?: [
    Table
  ](name='Tables', description='Tables'),
}

model ListTablesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTablesResponseBody(name='body'),
}

async function listTables(request: ListTablesRequest): ListTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTablesWithOptions(request, headers, runtime);
}

async function listTablesWithOptions(request: ListTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTablesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tableNamePattern)) {
    query['TableNamePattern'] = request.tableNamePattern;
  }
  if (!Util.isUnset(request.tableType)) {
    query['TableType'] = request.tableType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/databases/tables/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListWorkflowInstantencesRequest {
  blueprintInstanceId?: string(name='BlueprintInstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  statusList?: map[string]any(name='StatusList'),
}

model ListWorkflowInstantencesResponseBody = {
  flowInstances?: [ 
    {
      batchProgress?: int32(name='BatchProgress'),
      clusterId?: string(name='ClusterId'),
      duration?: long(name='Duration'),
      endTime?: string(name='EndTime'),
      flowId?: string(name='FlowId'),
      flowInstanceId?: string(name='FlowInstanceId'),
      flowName?: string(name='FlowName'),
      offsetTime?: int32(name='OffsetTime'),
      projectId?: string(name='ProjectId'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      totalCuUsage?: float(name='TotalCuUsage'),
    }
  ](name='FlowInstances'),
  requestId?: string(name='RequestId'),
  success?: long(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListWorkflowInstantencesResponse = {
  headers: map[string]string(name='headers'),
  body: ListWorkflowInstantencesResponseBody(name='body'),
}

async function listWorkflowInstantences(request: ListWorkflowInstantencesRequest): ListWorkflowInstantencesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listWorkflowInstantencesWithOptions(request, headers, runtime);
}

async function listWorkflowInstantencesWithOptions(request: ListWorkflowInstantencesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListWorkflowInstantencesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.blueprintInstanceId)) {
    query['BlueprintInstanceId'] = request.blueprintInstanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkflowInstantences',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/blueprintinstance/listWorkflowInstances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListWorkspacesResponseBody = {
  data?: [ 
    {
      config?: string(name='Config'),
      description?: string(name='Description'),
      isDefault?: boolean(name='IsDefault'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      type?: string(name='Type'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListWorkspacesResponse = {
  headers: map[string]string(name='headers'),
  body: ListWorkspacesResponseBody(name='body'),
}

async function listWorkspaces(): ListWorkspacesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listWorkspacesWithOptions(headers, runtime);
}

async function listWorkspacesWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListWorkspacesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListWorkspaces',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/listWorkspaces`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyMetastoreCrawlerRequest {
  datasourceExcludePath?: string(name='DatasourceExcludePath'),
  executeCron?: string(name='ExecuteCron'),
  executeType?: string(name='ExecuteType'),
  fileFormat?: string(name='FileFormat'),
  fileFormatConfig?: string(name='FileFormatConfig'),
  id?: string(name='Id'),
  immediatelyRun?: boolean(name='ImmediatelyRun'),
  name?: string(name='Name'),
  roleName?: string(name='RoleName'),
  targetUpdateStrategy?: string(name='TargetUpdateStrategy'),
}

model ModifyMetastoreCrawlerResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyMetastoreCrawlerResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyMetastoreCrawlerResponseBody(name='body'),
}

async function modifyMetastoreCrawler(request: ModifyMetastoreCrawlerRequest): ModifyMetastoreCrawlerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyMetastoreCrawlerWithOptions(request, headers, runtime);
}

async function modifyMetastoreCrawlerWithOptions(request: ModifyMetastoreCrawlerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyMetastoreCrawlerResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.datasourceExcludePath)) {
    body['DatasourceExcludePath'] = request.datasourceExcludePath;
  }
  if (!Util.isUnset(request.executeCron)) {
    body['ExecuteCron'] = request.executeCron;
  }
  if (!Util.isUnset(request.executeType)) {
    body['ExecuteType'] = request.executeType;
  }
  if (!Util.isUnset(request.fileFormat)) {
    body['FileFormat'] = request.fileFormat;
  }
  if (!Util.isUnset(request.fileFormatConfig)) {
    body['FileFormatConfig'] = request.fileFormatConfig;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.immediatelyRun)) {
    body['ImmediatelyRun'] = request.immediatelyRun;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.roleName)) {
    body['RoleName'] = request.roleName;
  }
  if (!Util.isUnset(request.targetUpdateStrategy)) {
    body['TargetUpdateStrategy'] = request.targetUpdateStrategy;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyMetastoreCrawler',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/crawler/modify`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyWorkflowExecuteInfoRequest {
  blueprintInstanceId?: string(name='BlueprintInstanceId'),
  executeCapacity?: string(name='ExecuteCapacity'),
  executeParameters?: string(name='ExecuteParameters'),
  executeType?: string(name='ExecuteType'),
}

model ModifyWorkflowExecuteInfoResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model ModifyWorkflowExecuteInfoResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyWorkflowExecuteInfoResponseBody(name='body'),
}

async function modifyWorkflowExecuteInfo(request: ModifyWorkflowExecuteInfoRequest): ModifyWorkflowExecuteInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyWorkflowExecuteInfoWithOptions(request, headers, runtime);
}

async function modifyWorkflowExecuteInfoWithOptions(request: ModifyWorkflowExecuteInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyWorkflowExecuteInfoResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.blueprintInstanceId)) {
    body['BlueprintInstanceId'] = request.blueprintInstanceId;
  }
  if (!Util.isUnset(request.executeCapacity)) {
    body['ExecuteCapacity'] = request.executeCapacity;
  }
  if (!Util.isUnset(request.executeParameters)) {
    body['ExecuteParameters'] = request.executeParameters;
  }
  if (!Util.isUnset(request.executeType)) {
    body['ExecuteType'] = request.executeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWorkflowExecuteInfo',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/blueprintinstance/modifyWorkflowExecuteInfo`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PreviewMetastoreCrawlerRequest {
  datasourceExcludePath?: string(name='DatasourceExcludePath'),
  datasourcePath?: string(name='DatasourcePath'),
  datasourceType?: string(name='DatasourceType'),
  fileFormat?: string(name='FileFormat'),
  fileFormatConfig?: string(name='FileFormatConfig'),
  name?: string(name='Name'),
  roleName?: string(name='RoleName'),
  targetDatabase?: string(name='TargetDatabase'),
  targetTablePrefix?: string(name='TargetTablePrefix'),
  targetUpdateStrategy?: string(name='TargetUpdateStrategy'),
}

model PreviewMetastoreCrawlerResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PreviewMetastoreCrawlerResponse = {
  headers: map[string]string(name='headers'),
  body: PreviewMetastoreCrawlerResponseBody(name='body'),
}

async function previewMetastoreCrawler(request: PreviewMetastoreCrawlerRequest): PreviewMetastoreCrawlerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return previewMetastoreCrawlerWithOptions(request, headers, runtime);
}

async function previewMetastoreCrawlerWithOptions(request: PreviewMetastoreCrawlerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PreviewMetastoreCrawlerResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.datasourceExcludePath)) {
    body['DatasourceExcludePath'] = request.datasourceExcludePath;
  }
  if (!Util.isUnset(request.datasourcePath)) {
    body['DatasourcePath'] = request.datasourcePath;
  }
  if (!Util.isUnset(request.datasourceType)) {
    body['DatasourceType'] = request.datasourceType;
  }
  if (!Util.isUnset(request.fileFormat)) {
    body['FileFormat'] = request.fileFormat;
  }
  if (!Util.isUnset(request.fileFormatConfig)) {
    body['FileFormatConfig'] = request.fileFormatConfig;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.roleName)) {
    body['RoleName'] = request.roleName;
  }
  if (!Util.isUnset(request.targetDatabase)) {
    body['TargetDatabase'] = request.targetDatabase;
  }
  if (!Util.isUnset(request.targetTablePrefix)) {
    body['TargetTablePrefix'] = request.targetTablePrefix;
  }
  if (!Util.isUnset(request.targetUpdateStrategy)) {
    body['TargetUpdateStrategy'] = request.targetUpdateStrategy;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PreviewMetastoreCrawler',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/crawler/preview`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RefreshLockRequest {
  lockId?: long(name='LockId', description='LockId'),
}

model RefreshLockResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model RefreshLockResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshLockResponseBody(name='body'),
}

async function refreshLock(request: RefreshLockRequest): RefreshLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return refreshLockWithOptions(request, headers, runtime);
}

async function refreshLockWithOptions(request: RefreshLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RefreshLockResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.lockId)) {
    query['LockId'] = request.lockId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RefreshUserSessionResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RefreshUserSessionResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshUserSessionResponseBody(name='body'),
}

async function refreshUserSession(): RefreshUserSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return refreshUserSessionWithOptions(headers, runtime);
}

async function refreshUserSessionWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): RefreshUserSessionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RefreshUserSession',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/userSessionHeartbeat`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RenamePartitionRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  partitionInput?: PartitionInput(name='PartitionInput'),
  partitionValues?: [ string ](name='PartitionValues'),
  tableName?: string(name='TableName', description='TableName'),
}

model RenamePartitionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model RenamePartitionResponse = {
  headers: map[string]string(name='headers'),
  body: RenamePartitionResponseBody(name='body'),
}

async function renamePartition(request: RenamePartitionRequest): RenamePartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renamePartitionWithOptions(request, headers, runtime);
}

async function renamePartitionWithOptions(request: RenamePartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenamePartitionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionInput)) {
    body['PartitionInput'] = request.partitionInput;
  }
  if (!Util.isUnset(request.partitionValues)) {
    body['PartitionValues'] = request.partitionValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RenamePartition',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/rename`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RenameTableRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  isAsync?: boolean(name='IsAsync', description='IsAsync'),
  tableInput?: TableInput(name='TableInput'),
  tableName?: string(name='TableName', description='TableName'),
}

model RenameTableResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  taskId?: string(name='TaskId', description='Async task Id'),
}

model RenameTableResponse = {
  headers: map[string]string(name='headers'),
  body: RenameTableResponseBody(name='body'),
}

async function renameTable(request: RenameTableRequest): RenameTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renameTableWithOptions(request, headers, runtime);
}

async function renameTableWithOptions(request: RenameTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenameTableResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.isAsync)) {
    body['IsAsync'] = request.isAsync;
  }
  if (!Util.isUnset(request.tableInput)) {
    body['TableInput'] = request.tableInput;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RenameTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/rename`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RunBlueprintInstanceWorkflowRequest {
  blueprintInstanceId?: string(name='BlueprintInstanceId'),
}

model RunBlueprintInstanceWorkflowResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RunBlueprintInstanceWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: RunBlueprintInstanceWorkflowResponseBody(name='body'),
}

async function runBlueprintInstanceWorkflow(request: RunBlueprintInstanceWorkflowRequest): RunBlueprintInstanceWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return runBlueprintInstanceWorkflowWithOptions(request, headers, runtime);
}

async function runBlueprintInstanceWorkflowWithOptions(request: RunBlueprintInstanceWorkflowRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RunBlueprintInstanceWorkflowResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.blueprintInstanceId)) {
    query['BlueprintInstanceId'] = request.blueprintInstanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RunBlueprintInstanceWorkflow',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/blueprintinstance/runWorkflow`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RunCrawlerWorkflowRequest {
  crawlerId?: string(name='CrawlerId'),
}

model RunCrawlerWorkflowResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RunCrawlerWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: RunCrawlerWorkflowResponseBody(name='body'),
}

async function runCrawlerWorkflow(request: RunCrawlerWorkflowRequest): RunCrawlerWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return runCrawlerWorkflowWithOptions(request, headers, runtime);
}

async function runCrawlerWorkflowWithOptions(request: RunCrawlerWorkflowRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RunCrawlerWorkflowResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.crawlerId)) {
    body['CrawlerId'] = request.crawlerId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RunCrawlerWorkflow',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/crawler/workflow/run`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RunMigrationWorkflowRequest {
  instanceId?: string(name='InstanceId'),
}

model RunMigrationWorkflowResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RunMigrationWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: RunMigrationWorkflowResponseBody(name='body'),
}

async function runMigrationWorkflow(request: RunMigrationWorkflowRequest): RunMigrationWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return runMigrationWorkflowWithOptions(request, headers, runtime);
}

async function runMigrationWorkflowWithOptions(request: RunMigrationWorkflowRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RunMigrationWorkflowResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RunMigrationWorkflow',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/migration/workflow/run`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SearchRequest {
  catalogId?: string(name='CatalogId', description='catalogid'),
  pageNumber?: long(name='PageNumber', description='当前查询的页号'),
  pageSize?: long(name='PageSize', description='当前查询的页大小'),
  searchText?: string(name='SearchText', description='搜索问题'),
  sortCriteria?: [
    SortCriterion
  ](name='SortCriteria', description='排序结构'),
}

model SearchResponseBody = {
  code?: string(name='Code', description='响应代码'),
  databaseResult?: {
    databases?: [ 
      {
        database?: Database(name='Database', description='返回的Database'),
        highLightList?: [
          HighLight
        ](name='HighLightList', description='返回高亮文本'),
      }
    ](name='Databases', description='返回的DatabaseList'),
    totalCount?: long(name='TotalCount', description='满足匹配条件的总的Database个数'),
  }(name='DatabaseResult', description='返回的db结果'),
  message?: string(name='Message', description='响应消息'),
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='是否成功'),
  tableResult?: {
    tables?: [ 
      {
        highLightList?: [
          HighLight
        ](name='HighLightList', description='返回的高亮文本'),
        table?: Table(name='Table', description='返回的Table'),
      }
    ](name='Tables', description='返回的TableList'),
    totalCount?: long(name='TotalCount', description='满足匹配条件的总的Table个数'),
  }(name='TableResult', description='返回的table result'),
}

model SearchResponse = {
  headers: map[string]string(name='headers'),
  body: SearchResponseBody(name='body'),
}

async function search(request: SearchRequest): SearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchWithOptions(request, headers, runtime);
}

async function searchWithOptions(request: SearchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchText)) {
    body['SearchText'] = request.searchText;
  }
  if (!Util.isUnset(request.sortCriteria)) {
    body['SortCriteria'] = request.sortCriteria;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'Search',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopBlueprintInstanceWorkflowRequest {
  blueprintInstanceId?: string(name='BlueprintInstanceId'),
}

model StopBlueprintInstanceWorkflowResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StopBlueprintInstanceWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: StopBlueprintInstanceWorkflowResponseBody(name='body'),
}

async function stopBlueprintInstanceWorkflow(request: StopBlueprintInstanceWorkflowRequest): StopBlueprintInstanceWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopBlueprintInstanceWorkflowWithOptions(request, headers, runtime);
}

async function stopBlueprintInstanceWorkflowWithOptions(request: StopBlueprintInstanceWorkflowRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopBlueprintInstanceWorkflowResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.blueprintInstanceId)) {
    query['BlueprintInstanceId'] = request.blueprintInstanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopBlueprintInstanceWorkflow',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/blueprintinstance/stopWorkflow`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopCrawlerWorkflowRequest {
  crawlerId?: string(name='CrawlerId'),
}

model StopCrawlerWorkflowResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StopCrawlerWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: StopCrawlerWorkflowResponseBody(name='body'),
}

async function stopCrawlerWorkflow(request: StopCrawlerWorkflowRequest): StopCrawlerWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopCrawlerWorkflowWithOptions(request, headers, runtime);
}

async function stopCrawlerWorkflowWithOptions(request: StopCrawlerWorkflowRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopCrawlerWorkflowResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.crawlerId)) {
    body['CrawlerId'] = request.crawlerId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopCrawlerWorkflow',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/crawler/workflow/stop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopMigrationWorkflowRequest {
  instanceId?: string(name='InstanceId'),
}

model StopMigrationWorkflowResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StopMigrationWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: StopMigrationWorkflowResponseBody(name='body'),
}

async function stopMigrationWorkflow(request: StopMigrationWorkflowRequest): StopMigrationWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopMigrationWorkflowWithOptions(request, headers, runtime);
}

async function stopMigrationWorkflowWithOptions(request: StopMigrationWorkflowRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopMigrationWorkflowResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopMigrationWorkflow',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/migration/workflow/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SubmitQueryRequest {
  sql?: string(name='Sql'),
  workspaceId?: string(name='WorkspaceId'),
}

model SubmitQueryResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubmitQueryResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitQueryResponseBody(name='body'),
}

async function submitQuery(request: SubmitQueryRequest): SubmitQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return submitQueryWithOptions(request, headers, runtime);
}

async function submitQueryWithOptions(request: SubmitQueryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SubmitQueryResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.sql)) {
    body['Sql'] = request.sql;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SubmitQuery',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/submitQueryRequestBody`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UnLockRequest {
  lockId?: long(name='LockId', description='LockId'),
}

model UnLockResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model UnLockResponse = {
  headers: map[string]string(name='headers'),
  body: UnLockResponseBody(name='body'),
}

async function unLock(request: UnLockRequest): UnLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unLockWithOptions(request, headers, runtime);
}

async function unLockWithOptions(request: UnLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UnLockResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.lockId)) {
    query['LockId'] = request.lockId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateBlueprintInstanceRequest {
  executeCapacity?: int32(name='ExecuteCapacity'),
  executeConcurrency?: int32(name='ExecuteConcurrency'),
  executeParameters?: string(name='ExecuteParameters'),
  executeType?: string(name='ExecuteType'),
  id?: string(name='Id'),
}

model UpdateBlueprintInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model UpdateBlueprintInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateBlueprintInstanceResponseBody(name='body'),
}

async function updateBlueprintInstance(request: UpdateBlueprintInstanceRequest): UpdateBlueprintInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateBlueprintInstanceWithOptions(request, headers, runtime);
}

async function updateBlueprintInstanceWithOptions(request: UpdateBlueprintInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateBlueprintInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.executeCapacity)) {
    body['ExecuteCapacity'] = request.executeCapacity;
  }
  if (!Util.isUnset(request.executeConcurrency)) {
    body['ExecuteConcurrency'] = request.executeConcurrency;
  }
  if (!Util.isUnset(request.executeParameters)) {
    body['ExecuteParameters'] = request.executeParameters;
  }
  if (!Util.isUnset(request.executeType)) {
    body['ExecuteType'] = request.executeType;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBlueprintInstance',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/blueprintinstance/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateDataSourceRequest {
  connectionInfo?: string(name='ConnectionInfo'),
  dataSourceId?: string(name='DataSourceId'),
  dataSourceType?: string(name='DataSourceType'),
}

model UpdateDataSourceResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDataSourceResponseBody(name='body'),
}

async function updateDataSource(request: UpdateDataSourceRequest): UpdateDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDataSourceWithOptions(request, headers, runtime);
}

async function updateDataSourceWithOptions(request: UpdateDataSourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDataSourceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.connectionInfo)) {
    body['ConnectionInfo'] = request.connectionInfo;
  }
  if (!Util.isUnset(request.dataSourceId)) {
    body['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    body['DataSourceType'] = request.dataSourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDataSource',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/datasource/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateDatabaseRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseInput?: DatabaseInput(name='DatabaseInput'),
  name?: string(name='Name', description='Name'),
}

model UpdateDatabaseResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Response Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Request is success or not'),
}

model UpdateDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDatabaseResponseBody(name='body'),
}

async function updateDatabase(request: UpdateDatabaseRequest): UpdateDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDatabaseWithOptions(request, headers, runtime);
}

async function updateDatabaseWithOptions(request: UpdateDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDatabaseResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseInput)) {
    body['DatabaseInput'] = request.databaseInput;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDatabase',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateFunctionRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  functionInput?: FunctionInput(name='FunctionInput'),
  functionName?: string(name='FunctionName'),
}

model UpdateFunctionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model UpdateFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFunctionResponseBody(name='body'),
}

async function updateFunction(request: UpdateFunctionRequest): UpdateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFunctionWithOptions(request, headers, runtime);
}

async function updateFunctionWithOptions(request: UpdateFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionInput)) {
    body['FunctionInput'] = request.functionInput;
  }
  if (!Util.isUnset(request.functionName)) {
    body['FunctionName'] = request.functionName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFunction',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateMetastoreMigrationRequest {
  desc?: string(name='Desc'),
  instanceId?: string(name='InstanceId'),
  metastoreInfo?: string(name='MetastoreInfo'),
  metastoreType?: string(name='MetastoreType'),
  name?: string(name='Name'),
  roleName?: string(name='RoleName'),
  runOptions?: string(name='RunOptions'),
}

model UpdateMetastoreMigrationResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateMetastoreMigrationResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMetastoreMigrationResponseBody(name='body'),
}

async function updateMetastoreMigration(request: UpdateMetastoreMigrationRequest): UpdateMetastoreMigrationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMetastoreMigrationWithOptions(request, headers, runtime);
}

async function updateMetastoreMigrationWithOptions(request: UpdateMetastoreMigrationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMetastoreMigrationResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.desc)) {
    body['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.metastoreInfo)) {
    body['MetastoreInfo'] = request.metastoreInfo;
  }
  if (!Util.isUnset(request.metastoreType)) {
    body['MetastoreType'] = request.metastoreType;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.roleName)) {
    body['RoleName'] = request.roleName;
  }
  if (!Util.isUnset(request.runOptions)) {
    body['RunOptions'] = request.runOptions;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMetastoreMigration',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/migration/update`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdatePartitionColumnStatisticsRequest {
  updateTablePartitionColumnStatisticsRequest?: UpdateTablePartitionColumnStatisticsRequest(name='UpdateTablePartitionColumnStatisticsRequest'),
}

model UpdatePartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model UpdatePartitionColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePartitionColumnStatisticsResponseBody(name='body'),
}

async function updatePartitionColumnStatistics(request: UpdatePartitionColumnStatisticsRequest): UpdatePartitionColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePartitionColumnStatisticsWithOptions(request, headers, runtime);
}

async function updatePartitionColumnStatisticsWithOptions(request: UpdatePartitionColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePartitionColumnStatisticsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.updateTablePartitionColumnStatisticsRequest),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePartitionColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/columnstatistics`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateTableRequest {
  allowPartitionKeyChange?: boolean(name='AllowPartitionKeyChange', description='AllowPartitionKeyChange'),
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  isAsync?: boolean(name='IsAsync', description='IsAsync'),
  skipArchive?: boolean(name='SkipArchive', description='SkipArchive'),
  tableInput?: TableInput(name='TableInput'),
  tableName?: string(name='TableName', description='TableName'),
}

model UpdateTableResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  taskId?: string(name='TaskId', description='Async task Id'),
}

model UpdateTableResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTableResponseBody(name='body'),
}

async function updateTable(request: UpdateTableRequest): UpdateTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTableWithOptions(request, headers, runtime);
}

async function updateTableWithOptions(request: UpdateTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTableResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.allowPartitionKeyChange)) {
    body['AllowPartitionKeyChange'] = request.allowPartitionKeyChange;
  }
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.isAsync)) {
    body['IsAsync'] = request.isAsync;
  }
  if (!Util.isUnset(request.skipArchive)) {
    body['SkipArchive'] = request.skipArchive;
  }
  if (!Util.isUnset(request.tableInput)) {
    body['TableInput'] = request.tableInput;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateTableColumnStatisticsRequest {
  updateTablePartitionColumnStatisticsRequest?: UpdateTablePartitionColumnStatisticsRequest(name='UpdateTablePartitionColumnStatisticsRequest'),
}

model UpdateTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model UpdateTableColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTableColumnStatisticsResponseBody(name='body'),
}

async function updateTableColumnStatistics(request: UpdateTableColumnStatisticsRequest): UpdateTableColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTableColumnStatisticsWithOptions(request, headers, runtime);
}

async function updateTableColumnStatisticsWithOptions(request: UpdateTableColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTableColumnStatisticsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.updateTablePartitionColumnStatisticsRequest),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTableColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/columnstatistics`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateWorkflowExecuteInfoRequest {
  blueprintInstanceId?: string(name='BlueprintInstanceId'),
  executeCapacity?: string(name='ExecuteCapacity'),
  executeParameters?: string(name='ExecuteParameters'),
  executeType?: string(name='ExecuteType'),
}

model UpdateWorkflowExecuteInfoResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model UpdateWorkflowExecuteInfoResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWorkflowExecuteInfoResponseBody(name='body'),
}

async function updateWorkflowExecuteInfo(request: UpdateWorkflowExecuteInfoRequest): UpdateWorkflowExecuteInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateWorkflowExecuteInfoWithOptions(request, headers, runtime);
}

async function updateWorkflowExecuteInfoWithOptions(request: UpdateWorkflowExecuteInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateWorkflowExecuteInfoResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.blueprintInstanceId)) {
    body['BlueprintInstanceId'] = request.blueprintInstanceId;
  }
  if (!Util.isUnset(request.executeCapacity)) {
    body['ExecuteCapacity'] = request.executeCapacity;
  }
  if (!Util.isUnset(request.executeParameters)) {
    body['ExecuteParameters'] = request.executeParameters;
  }
  if (!Util.isUnset(request.executeType)) {
    body['ExecuteType'] = request.executeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWorkflowExecuteInfo',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/blueprintinstance/updateWorkflowExecuteInfo`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateWorkflowScheduleStatusRequest {
  blueprintInstanceId?: string(name='BlueprintInstanceId'),
  underSchedule?: boolean(name='UnderSchedule'),
}

model UpdateWorkflowScheduleStatusResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateWorkflowScheduleStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWorkflowScheduleStatusResponseBody(name='body'),
}

async function updateWorkflowScheduleStatus(request: UpdateWorkflowScheduleStatusRequest): UpdateWorkflowScheduleStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateWorkflowScheduleStatusWithOptions(request, headers, runtime);
}

async function updateWorkflowScheduleStatusWithOptions(request: UpdateWorkflowScheduleStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateWorkflowScheduleStatusResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.blueprintInstanceId)) {
    query['BlueprintInstanceId'] = request.blueprintInstanceId;
  }
  if (!Util.isUnset(request.underSchedule)) {
    query['UnderSchedule'] = request.underSchedule;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWorkflowScheduleStatus',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/blueprintinstance/updateWorkflowScheduleStatus`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateWorkspaceConfigRequest {
  config?: string(name='Config'),
  workspaceId?: string(name='WorkspaceId'),
}

model UpdateWorkspaceConfigResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateWorkspaceConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWorkspaceConfigResponseBody(name='body'),
}

async function updateWorkspaceConfig(request: UpdateWorkspaceConfigRequest): UpdateWorkspaceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateWorkspaceConfigWithOptions(request, headers, runtime);
}

async function updateWorkspaceConfigWithOptions(request: UpdateWorkspaceConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateWorkspaceConfigResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWorkspaceConfig',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/updateWorkspaceConfig`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

