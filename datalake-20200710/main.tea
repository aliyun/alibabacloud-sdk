/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'datalake-daily.aliyuncs.com',
    ap-northeast-2-pop = 'datalake-daily.aliyuncs.com',
    ap-south-1 = 'datalake-daily.aliyuncs.com',
    ap-southeast-1 = 'datalake-daily.aliyuncs.com',
    ap-southeast-2 = 'datalake-daily.aliyuncs.com',
    ap-southeast-3 = 'datalake-daily.aliyuncs.com',
    ap-southeast-5 = 'datalake-daily.aliyuncs.com',
    cn-beijing = 'dlf.cn-beijing.aliyuncs.com',
    cn-beijing-finance-1 = 'datalake-daily.aliyuncs.com',
    cn-beijing-finance-pop = 'datalake-daily.aliyuncs.com',
    cn-beijing-gov-1 = 'datalake-daily.aliyuncs.com',
    cn-beijing-nu16-b01 = 'datalake-daily.aliyuncs.com',
    cn-chengdu = 'datalake-daily.aliyuncs.com',
    cn-edge-1 = 'datalake-daily.aliyuncs.com',
    cn-fujian = 'datalake-daily.aliyuncs.com',
    cn-haidian-cm12-c01 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou = 'dlf.cn-hangzhou.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-finance = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-test-306 = 'datalake-daily.aliyuncs.com',
    cn-hongkong = 'datalake-daily.aliyuncs.com',
    cn-hongkong-finance-pop = 'datalake-daily.aliyuncs.com',
    cn-huhehaote = 'datalake-daily.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'datalake-daily.aliyuncs.com',
    cn-north-2-gov-1 = 'datalake-daily.aliyuncs.com',
    cn-qingdao = 'datalake-daily.aliyuncs.com',
    cn-qingdao-nebula = 'datalake-daily.aliyuncs.com',
    cn-shanghai = 'dlf.cn-shanghai.aliyuncs.com',
    cn-shanghai-et15-b01 = 'datalake-daily.aliyuncs.com',
    cn-shanghai-et2-b01 = 'datalake-daily.aliyuncs.com',
    cn-shanghai-finance-1 = 'datalake-daily.aliyuncs.com',
    cn-shanghai-inner = 'datalake-daily.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'datalake-daily.aliyuncs.com',
    cn-shenzhen = 'dlf.cn-shenzhen.aliyuncs.com',
    cn-shenzhen-finance-1 = 'datalake-daily.aliyuncs.com',
    cn-shenzhen-inner = 'datalake-daily.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'datalake-daily.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'datalake-daily.aliyuncs.com',
    cn-wuhan = 'datalake-daily.aliyuncs.com',
    cn-wulanchabu = 'datalake-daily.aliyuncs.com',
    cn-yushanfang = 'datalake-daily.aliyuncs.com',
    cn-zhangbei = 'datalake-daily.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'datalake-daily.aliyuncs.com',
    cn-zhangjiakou = 'datalake-daily.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'datalake-daily.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'datalake-daily.aliyuncs.com',
    eu-central-1 = 'datalake-daily.aliyuncs.com',
    eu-west-1 = 'datalake-daily.aliyuncs.com',
    eu-west-1-oxs = 'datalake-daily.aliyuncs.com',
    me-east-1 = 'datalake-daily.aliyuncs.com',
    rus-west-1-pop = 'datalake-daily.aliyuncs.com',
    us-east-1 = 'datalake-daily.aliyuncs.com',
    us-west-1 = 'datalake-daily.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('datalake', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AccessRequest {
  catalogId?: string(name='CatalogId'),
  principal?: Principal(name='Principal'),
  privilegeResources?: [
PrivilegeResource
](name='PrivilegeResources'),
}

model Catalog {
  catalogId?: string(name='CatalogId'),
  catalogType?: string(name='CatalogType'),
  createTime?: long(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  defaultCatalog?: boolean(name='DefaultCatalog'),
  description?: string(name='Description'),
  jdbcEnabled?: boolean(name='JdbcEnabled'),
  locationUri?: string(name='LocationUri'),
  owner?: string(name='Owner'),
  status?: string(name='Status'),
  storageAccessConfig?: string(name='StorageAccessConfig'),
  thriftEnabled?: boolean(name='ThriftEnabled'),
  updateTime?: long(name='UpdateTime'),
}

model CatalogConnection {
  jdbcPassword?: string(name='JdbcPassword'),
  jdbcUri?: string(name='JdbcUri'),
  jdbcUserName?: string(name='JdbcUserName'),
  thriftUri?: string(name='ThriftUri'),
  vpcConnectionId?: string(name='VpcConnectionId', example='CONN-607A0053D874****'),
}

model CatalogInput {
  catalogId?: string(name='CatalogId', description='This parameter is required.'),
  catalogType?: string(name='CatalogType'),
  description?: string(name='Description'),
  jdbcEnabled?: boolean(name='JdbcEnabled'),
  locationUri?: string(name='LocationUri'),
  owner?: string(name='Owner'),
  storageAccessConfig?: string(name='StorageAccessConfig'),
  thriftEnabled?: boolean(name='ThriftEnabled'),
}

model CatalogResource {
  catalogId?: string(name='CatalogId'),
}

model CatalogSettings {
  config?: map[string]string(name='Config'),
}

model CatalogVpcConnection {
  catalogId?: string(name='CatalogId', example='catalog_test'),
  connectionName?: string(name='ConnectionName'),
  connectionStatus?: string(name='ConnectionStatus', example='CONNECTED'),
  creator?: long(name='Creator', example='120215474170****'),
  errorMessage?: string(name='ErrorMessage'),
  gmtCreate?: string(name='GmtCreate', example='2023-07-12 15:26:12'),
  gmtModified?: string(name='GmtModified', example='2023-07-17 17:51:04'),
  jdbcUri?: string(name='JdbcUri'),
  modifier?: long(name='Modifier', example='120215474170****'),
  owner?: long(name='Owner', example='120215474170****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  securityGroupIds?: [ string ](name='SecurityGroupIds'),
  thriftUri?: string(name='ThriftUri'),
  vpcConnectionId?: string(name='VpcConnectionId', example='CONN-607A0053D874****'),
  vpcId?: string(name='VpcId', example='vpc-2ze0c41hvmesel7pu****'),
  zones?: [ 
    {
      IP?: string(name='IP', example='192.168.XX.XX'),
      vSwitchId?: string(name='VSwitchId', example='vsw-hp3uf6045ljdhd5zr****'),
      zoneId?: string(name='ZoneId', example='cn-hangzhou-g'),
    }
  ](name='Zones'),
}

model CatalogVpcConnectionInput {
  connectionName?: string(name='ConnectionName'),
  securityGroupIds?: [ string ](name='SecurityGroupIds'),
  vpcId?: string(name='VpcId', example='vpc-hp356stwkxg3fn2xe****'),
  zones?: [ 
    {
      IP?: string(name='IP', example='192.168.XX.XX'),
      vSwitchId?: string(name='VSwitchId', example='vsw-hp3uf6045ljdhd5zr****'),
      zoneId?: string(name='ZoneId', example='cn-hangzhou-g'),
    }
  ](name='Zones'),
}

model ColumnResource {
  columnNames?: [ string ](name='ColumnNames'),
  databaseName?: string(name='DatabaseName', example='default'),
  tableName?: string(name='TableName', example='test'),
}

model ColumnStatistics {
  columnStatisticsDesc?: ColumnStatisticsDesc(name='ColumnStatisticsDesc'),
  columnStatisticsObjList?: [
    ColumnStatisticsObj
  ](name='ColumnStatisticsObjList'),
  engine?: string(name='Engine'),
  isStatsCompliant?: boolean(name='IsStatsCompliant'),
}

model ColumnStatisticsDesc {
  lastAnalyzedTime?: long(name='LastAnalyzedTime'),
  partitionName?: string(name='PartitionName'),
}

model ColumnStatisticsObj {
  columnName?: string(name='ColumnName'),
  columnStatisticsData?: {
    statisticsData?: string(name='StatisticsData'),
    statisticsType?: string(name='StatisticsType'),
  }(name='ColumnStatisticsData'),
  columnType?: string(name='ColumnType'),
}

model Database {
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  description?: string(name='Description'),
  locationUri?: string(name='LocationUri', example='oss://examplebuket/exampledb'),
  name?: string(name='Name'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  updateTime?: int32(name='UpdateTime'),
}

model DatabaseInput {
  createTime?: int32(name='CreateTime'),
  description?: string(name='Description'),
  locationUri?: string(name='LocationUri', example='oss://examplebuket/exampledb'),
  name?: string(name='Name'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
}

model DatabaseProfile {
  createTime?: string(name='CreateTime'),
  fileCnt?: long(name='FileCnt'),
  fileSize?: long(name='FileSize'),
  latestDate?: string(name='LatestDate'),
  location?: string(name='Location'),
  name?: string(name='Name'),
  objectCnt?: long(name='ObjectCnt'),
  objectSize?: long(name='ObjectSize'),
}

model DatabaseResource {
  databaseName?: string(name='DatabaseName', example='default'),
  databaseWildcard?: string(name='DatabaseWildcard'),
}

model DbStorageRank {
  dbName?: string(name='DbName'),
  quantity?: long(name='Quantity'),
}

model ErrorDetail {
  code?: string(name='Code'),
  message?: string(name='Message'),
}

model FieldSchema {
  comment?: string(name='Comment'),
  name?: string(name='Name'),
  parameters?: map[string]string(name='Parameters'),
  type?: string(name='Type'),
}

model FileCnt {
  large?: long(name='Large'),
  middle?: long(name='Middle'),
  small?: long(name='Small'),
  tiny?: long(name='Tiny'),
}

model Function {
  catalogId?: string(name='CatalogId'),
  className?: string(name='ClassName'),
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy', example='CreatedBy'),
  databaseName?: string(name='DatabaseName'),
  functionName?: string(name='FunctionName'),
  functionType?: string(name='FunctionType'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  resourceUri?: [
    ResourceUri
  ](name='ResourceUri'),
  updateTime?: int32(name='UpdateTime'),
}

model FunctionInput {
  className?: string(name='ClassName'),
  createTime?: int32(name='CreateTime'),
  functionName?: string(name='FunctionName'),
  functionType?: string(name='FunctionType'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  resourceUri?: [
    ResourceUri
  ](name='ResourceUri'),
}

model FunctionResource {
  databaseName?: string(name='DatabaseName', example='default'),
  functionName?: string(name='FunctionName', example='default'),
}

model GrantRevokeEntry {
  accesses?: [ string ](name='Accesses'),
  delegateAccesses?: [ string ](name='DelegateAccesses'),
  id?: string(name='Id'),
  metaResource?: MetaResource(name='MetaResource'),
  principal?: Principal(name='Principal'),
}

model GrantRevokeFailureEntry {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  grantRevokeEntry?: GrantRevokeEntry(name='GrantRevokeEntry'),
}

model HighLight {
  key?: string(name='Key', example='name'),
  value?: string(name='Value', example='<em>tab</em>2'),
}

model IndicatorStatistic {
  data?: long(name='Data'),
  date?: string(name='Date'),
}

model LifecycleResource {
  bizId?: string(name='BizId'),
  catalogId?: string(name='CatalogId'),
  database?: {
    createTime?: long(name='CreateTime'),
    description?: string(name='Description'),
    locationUri?: string(name='LocationUri'),
    name?: string(name='Name'),
    updateTime?: long(name='UpdateTime'),
  }(name='Database'),
  databaseName?: string(name='DatabaseName'),
  databaseProfile?: DatabaseProfile(name='DatabaseProfile'),
  gmtCreate?: string(name='GmtCreate'),
  lifecycleRuleBizId?: string(name='LifecycleRuleBizId'),
  owner?: long(name='Owner'),
  table?: {
    createTime?: long(name='CreateTime'),
    databaseName?: string(name='DatabaseName'),
    parameters?: map[string]string(name='Parameters'),
    sd?: {
      bucketCols?: [ string ](name='BucketCols'),
      inputFormat?: string(name='InputFormat'),
      location?: string(name='Location'),
      outputFormat?: string(name='OutputFormat'),
      parameters?: map[string]string(name='Parameters'),
      serDeInfo?: {
        name?: string(name='Name'),
        parameters?: map[string]string(name='Parameters'),
        serializationLib?: string(name='SerializationLib'),
      }(name='SerDeInfo'),
    }(name='Sd'),
    tableName?: string(name='TableName'),
    tableType?: string(name='TableType'),
  }(name='Table'),
  tableName?: string(name='TableName'),
  tableProfile?: TableProfile(name='TableProfile'),
}

model LifecycleRule {
  archiveDays?: int32(name='ArchiveDays'),
  bindCount?: int32(name='BindCount'),
  bizId?: string(name='BizId'),
  catalogId?: string(name='CatalogId'),
  coldArchiveDays?: int32(name='ColdArchiveDays'),
  config?: string(name='Config'),
  description?: string(name='Description'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  iaDays?: int32(name='IaDays'),
  name?: string(name='Name'),
  resourceType?: string(name='ResourceType'),
  ruleType?: string(name='RuleType'),
  scheduleStatus?: string(name='ScheduleStatus'),
  workflow?: Workflow(name='Workflow'),
  workflowId?: string(name='WorkflowId'),
  workflowInstance?: WorkflowInstance(name='WorkflowInstance'),
}

model LifecycleTask {
  bizId?: string(name='BizId'),
  lifecycleRule?: LifecycleRule(name='LifecycleRule'),
  name?: string(name='Name'),
  workflowInstance?: WorkflowInstance(name='WorkflowInstance'),
}

model LocationStorageRankDTO {
  fileCnt?: long(name='FileCnt'),
  location?: string(name='Location'),
  storage?: long(name='Storage'),
}

model LockObj {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  partitionName?: string(name='PartitionName'),
  tableName?: string(name='TableName'),
}

model LockStatus {
  lockId?: long(name='LockId'),
  lockState?: string(name='LockState'),
}

model LogInfo {
  bizTime?: string(name='BizTime'),
  gmtCreate?: string(name='GmtCreate'),
  instanceId?: string(name='InstanceId'),
  logContent?: string(name='LogContent'),
  logId?: string(name='LogId'),
  logSummary?: string(name='LogSummary'),
  logType?: string(name='LogType'),
}

model MetaResource {
  catalogResource?: CatalogResource(name='CatalogResource'),
  columnResource?: ColumnResource(name='ColumnResource'),
  databaseResource?: DatabaseResource(name='DatabaseResource'),
  functionResource?: FunctionResource(name='FunctionResource'),
  resourceType?: string(name='ResourceType', example='TABLE'),
  tableResource?: TableResource(name='TableResource'),
}

model Order {
  col?: string(name='Col'),
  order?: int32(name='Order'),
}

model Partition {
  createTime?: int32(name='CreateTime'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName'),
  values?: [ string ](name='Values'),
}

model PartitionError {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  partitionValues?: [ string ](name='PartitionValues'),
}

model PartitionInput {
  createTime?: int32(name='CreateTime'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName'),
  values?: [ string ](name='Values'),
}

model PartitionProfile {
  accessNum?: long(name='AccessNum', example='0'),
  accessNumMonthly?: long(name='AccessNumMonthly', example='0'),
  accessNumWeekly?: long(name='AccessNumWeekly', example='0'),
  archiveStatus?: string(name='ArchiveStatus', example='STANDARD'),
  createTime?: string(name='CreateTime', example='2023-08-16 18:02:22'),
  dataSourceType?: string(name='DataSourceType', example='OSS_HDFS'),
  databaseName?: string(name='DatabaseName', example='test_db'),
  fileCnt?: long(name='FileCnt', example='1'),
  fileSize?: long(name='FileSize', example='13'),
  lastAccessNumTime?: string(name='LastAccessNumTime'),
  lastAccessTime?: string(name='LastAccessTime', example='2023-08-22 12:14:42'),
  lastModifyTime?: string(name='LastModifyTime', example='2023-08-16 18:02:25'),
  location?: string(name='Location', example='oss://mybucket.cn-hangzhou.oss-dls.aliyuncs.com/test_tb/test_tbl/year=2023/month=1'),
  objectAccessNum?: long(name='ObjectAccessNum', example='0'),
  objectAccessNumMonthly?: long(name='ObjectAccessNumMonthly', example='4'),
  objectAccessNumWeekly?: long(name='ObjectAccessNumWeekly', example='4'),
  objectCnt?: long(name='ObjectCnt', example='1'),
  objectSize?: long(name='ObjectSize', example='13'),
  partitionName?: string(name='PartitionName', example='year=2023/month=1'),
  tableName?: string(name='TableName', example='test_tbl'),
}

model PartitionSpec {
  sharedSDPartitions?: [
    Partition
  ](name='SharedSDPartitions'),
  sharedStorageDescriptor?: {
    cols?: [
      FieldSchema
    ](name='Cols'),
    location?: string(name='Location', example='相对路径'),
  }(name='SharedStorageDescriptor'),
}

model Principal {
  principalArn?: string(name='PrincipalArn', example='acs:ram::[AliyunAccountId]:user/username_abc'),
}

model PrincipalPrivilegeSet {
  groupPrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='GroupPrivileges'),
  rolePrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='RolePrivileges'),
  userPrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='UserPrivileges'),
}

model PrincipalResourcePermissions {
  accesses?: [ string ](name='Accesses'),
  delegateAccesses?: [ string ](name='DelegateAccesses'),
  metaResource?: MetaResource(name='MetaResource', description='This parameter is required.'),
  principal?: Principal(name='Principal', description='This parameter is required.'),
}

model PrivilegeGrantInfo {
  createTime?: int32(name='CreateTime'),
  grantOption?: boolean(name='GrantOption'),
  grantor?: string(name='Grantor'),
  grantorType?: string(name='GrantorType'),
  privilege?: string(name='Privilege'),
}

model PrivilegeResource {
  access?: string(name='Access'),
  metaResource?: MetaResource(name='MetaResource'),
}

model ResourceUri {
  resourceType?: string(name='ResourceType'),
  uri?: string(name='Uri'),
}

model Role {
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  displayName?: string(name='DisplayName', example='显示名称，允许中文'),
  isPredefined?: int32(name='IsPredefined'),
  name?: string(name='Name'),
  principalArn?: string(name='PrincipalArn'),
  updateTime?: long(name='UpdateTime'),
  users?: [
Principal
](name='Users'),
}

model RoleInput {
  description?: string(name='Description'),
  displayName?: string(name='DisplayName', example='显示名称，允许中文'),
  name?: string(name='Name'),
}

model SerDeInfo {
  name?: string(name='Name'),
  parameters?: map[string]string(name='Parameters'),
  serializationLib?: string(name='SerializationLib'),
}

model SingleIndicatorDTO {
  dayIncrement?: long(name='DayIncrement'),
  dayOnDay?: double(name='DayOnDay'),
  monthIncrement?: long(name='MonthIncrement'),
  monthOnMonth?: double(name='MonthOnMonth'),
  total?: long(name='Total'),
}

model SkewedInfo {
  skewedColNames?: [ string ](name='SkewedColNames'),
  skewedColValueLocationMaps?: map[string]string(name='SkewedColValueLocationMaps'),
  skewedColValues?: [[ string ]  ](name='SkewedColValues'),
}

model SmallFileCntRank {
  dbName?: string(name='DbName'),
  location?: string(name='Location'),
  quantity?: long(name='Quantity'),
  tableName?: string(name='TableName'),
}

model SortCriterion {
  fieldName?: string(name='FieldName', example='name'),
  sort?: string(name='Sort', example='asc/desc'),
}

model StorageCollectTaskOperationResult {
  dlfCreated?: boolean(name='DlfCreated'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
}

model StorageDescriptor {
  bucketCols?: [ string ](name='BucketCols'),
  cols?: [
    FieldSchema
  ](name='Cols'),
  compressed?: boolean(name='Compressed'),
  inputFormat?: string(name='InputFormat'),
  location?: string(name='Location'),
  numBuckets?: int32(name='NumBuckets'),
  outputFormat?: string(name='OutputFormat'),
  parameters?: map[string]string(name='Parameters'),
  serDeInfo?: SerDeInfo(name='SerDeInfo'),
  skewedInfo?: SkewedInfo(name='SkewedInfo'),
  sortCols?: [
    Order
  ](name='SortCols'),
  storedAsSubDirectories?: boolean(name='StoredAsSubDirectories'),
}

model StorageFormat {
  avro?: long(name='Avro'),
  csv?: long(name='Csv'),
  delta?: long(name='Delta'),
  hudi?: long(name='Hudi'),
  iceberg?: long(name='Iceberg'),
  json?: long(name='Json'),
  orc?: long(name='Orc'),
  parquet?: long(name='Parquet'),
  uncategorized?: long(name='Uncategorized'),
}

model StorageLayer {
  archive?: long(name='Archive'),
  coldArchive?: long(name='ColdArchive'),
  infrequent?: long(name='Infrequent'),
  standard?: long(name='Standard'),
  unknown?: long(name='Unknown'),
}

model StorageRankDTO {
  dbStorageRank?: [
    DbStorageRank
  ](name='dbStorageRank'),
  smallFileCntRank?: [
    SmallFileCntRank
  ](name='smallFileCntRank'),
  tableStorageRank?: [
    TableStorageRank
  ](name='tableStorageRank'),
}

model StorageSummary {
  databaseNum?: int32(name='DatabaseNum'),
  partitionNum?: int32(name='PartitionNum'),
  tableNum?: int32(name='TableNum'),
}

model StrogeCollectTask {
  destinationBucketName?: string(name='DestinationBucketName'),
  destinationPrefix?: string(name='DestinationPrefix'),
  dlfCreated?: boolean(name='DlfCreated'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  id?: string(name='Id'),
  inventoryId?: string(name='InventoryId'),
  location?: string(name='Location'),
  status?: string(name='Status'),
  taskType?: string(name='TaskType'),
}

model Table {
  cascade?: boolean(name='Cascade'),
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  owner?: string(name='Owner'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  retention?: int32(name='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled'),
  sd?: StorageDescriptor(name='Sd'),
  tableId?: string(name='TableId', example='59c6c8fefeaa46d8b599c1f790c59a19'),
  tableName?: string(name='TableName'),
  tableType?: string(name='TableType'),
  tableVersion?: TableVersion(name='TableVersion'),
  temporary?: boolean(name='Temporary'),
  updateTime?: int32(name='UpdateTime'),
  viewExpandedText?: string(name='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText'),
}

model TableError {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  tableName?: string(name='TableName'),
}

model TableExtended {
  cascade?: boolean(name='Cascade'),
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  owner?: string(name='Owner'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: {
    rolePrivileges?: map[string][ TableExtendedPrivilegesRolePrivilegesValue     ](name='RolePrivileges'),
    userPrivileges?: map[string][ TableExtendedPrivilegesUserPrivilegesValue     ](name='UserPrivileges'),
    groupPrivileges?: map[string][ TableExtendedPrivilegesGroupPrivilegesValue     ](name='groupPrivileges'),
  }(name='Privileges'),
  retention?: int32(name='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled'),
  sd?: {
    bucketCols?: [ string ](name='BucketCols'),
    cols?: [
      FieldSchema
    ](name='Cols'),
    compressed?: boolean(name='Compressed'),
    inputFormat?: string(name='InputFormat'),
    location?: string(name='Location'),
    numBuckets?: int32(name='NumBuckets'),
    outputFormat?: string(name='OutputFormat'),
    parameters?: map[string]string(name='Parameters'),
    serDeInfo?: {
      name?: string(name='Name'),
      parameters?: map[string]string(name='Parameters'),
      serializationLib?: string(name='SerializationLib'),
    }(name='SerDeInfo'),
    skewedInfo?: {
      skewedColNames?: [ string ](name='SkewedColNames'),
      skewedColValueLocationMaps?: map[string]string(name='SkewedColValueLocationMaps'),
      skewedColValues?: [[ string ]      ](name='SkewedColValues'),
    }(name='SkewedInfo'),
    sortCols?: [
      Order
    ](name='SortCols'),
    storedAsSubDirectories?: boolean(name='StoredAsSubDirectories'),
  }(name='Sd'),
  tableFormat?: string(name='TableFormat'),
  tableName?: string(name='TableName'),
  tableType?: string(name='TableType'),
  temporary?: boolean(name='Temporary'),
  updateTime?: int32(name='UpdateTime'),
  viewExpandedText?: string(name='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText'),
}

model TableInput {
  cascade?: boolean(name='Cascade'),
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  owner?: string(name='Owner'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  retention?: int32(name='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName'),
  tableType?: string(name='TableType'),
  temporary?: boolean(name='Temporary'),
  viewExpandedText?: string(name='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText'),
}

model TableProfile {
  accessNum?: long(name='AccessNum', example='0'),
  accessNumMonthly?: long(name='AccessNumMonthly', example='0'),
  accessNumWeekly?: long(name='AccessNumWeekly', example='0'),
  createTime?: string(name='CreateTime', example='2023-08-14 10:44:13'),
  dataSourceType?: string(name='DataSourceType', example='OSS_HDFS'),
  databaseName?: string(name='DatabaseName', example='test_db'),
  fileCnt?: long(name='FileCnt', example='5'),
  fileSize?: long(name='FileSize', example='31'),
  isPartitioned?: boolean(name='IsPartitioned', example='true'),
  lastAccessNumTime?: string(name='LastAccessNumTime'),
  lastAccessTime?: string(name='LastAccessTime', example='2023-08-22 12:14:42'),
  lastDdlTime?: string(name='LastDdlTime', example='2023-08-16 18:02:24'),
  lastModifyTime?: string(name='LastModifyTime', example='2023-08-16 18:02:25'),
  latestAccessNumDate?: string(name='LatestAccessNumDate'),
  latestDate?: string(name='LatestDate', example='2023-08-30 19:16:10'),
  location?: string(name='Location', example='oss://mybucket.cn-hangzhou.oss-dls.aliyuncs.com/test_db/test_tbl/'),
  objectAccessNum?: long(name='ObjectAccessNum', example='0'),
  objectAccessNumMonthly?: long(name='ObjectAccessNumMonthly', example='18'),
  objectAccessNumWeekly?: long(name='ObjectAccessNumWeekly', example='18'),
  objectCnt?: long(name='ObjectCnt', example='5'),
  objectSize?: long(name='ObjectSize', example='31'),
  partitionCnt?: long(name='PartitionCnt', example='3'),
  recordCnt?: long(name='RecordCnt'),
  tableName?: string(name='TableName', example='test_tbl'),
}

model TableResource {
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
}

model TableStorageRank {
  dbName?: string(name='DbName'),
  quantity?: long(name='Quantity'),
  tableName?: string(name='TableName'),
}

model TableVersion {
  table?: Table(name='Table'),
  versionId?: int32(name='VersionId'),
}

model TaskStatus {
  message?: string(name='Message'),
  status?: string(name='Status'),
}

model UnarchiveDetail {
  apiCallTimes?: long(name='ApiCallTimes'),
  cost?: long(name='Cost'),
  storageSize?: long(name='StorageSize'),
  storageType?: string(name='StorageType'),
  unarchiveTaskStatus?: string(name='UnarchiveTaskStatus'),
}

model UpdateTablePartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId'),
  columnStatisticsList?: [
    ColumnStatistics
  ](name='ColumnStatisticsList'),
  databaseName?: string(name='DatabaseName'),
  engine?: string(name='Engine'),
  isStatsCompliant?: boolean(name='IsStatsCompliant'),
  tableName?: string(name='TableName'),
  validWriteIdList?: string(name='ValidWriteIdList'),
  writeId?: string(name='WriteId'),
}

model UserRole {
  grantTime?: long(name='GrantTime'),
  role?: Role(name='Role'),
  user?: Principal(name='User'),
}

model Workflow {
  latestEndTime?: string(name='LatestEndTime'),
  latestInstanceId?: string(name='LatestInstanceId'),
  latestInstanceStatus?: string(name='LatestInstanceStatus'),
  latestStartTime?: string(name='LatestStartTime'),
}

model WorkflowInstance {
  batchProgress?: int32(name='BatchProgress'),
  dlfWorkflowId?: string(name='DlfWorkflowId'),
  endTime?: long(name='EndTime'),
  externalInstanceId?: string(name='ExternalInstanceId'),
  runtimeLogs?: [
    LogInfo
  ](name='RuntimeLogs'),
  startTime?: long(name='StartTime'),
  status?: string(name='Status'),
}

model TableExtendedPrivilegesRolePrivilegesValue = {
  createTime?: int32(name='CreateTime'),
  grantOption?: boolean(name='GrantOption'),
  grantor?: string(name='Grantor'),
  grantorType?: string(name='GrantorType'),
  privilege?: string(name='Privilege'),
}

model TableExtendedPrivilegesUserPrivilegesValue = {
  createTime?: int32(name='CreateTime'),
  grantOption?: boolean(name='GrantOption'),
  grantor?: string(name='Grantor'),
  grantorType?: string(name='GrantorType'),
  privilege?: string(name='Privilege'),
}

model TableExtendedPrivilegesGroupPrivilegesValue = {
  createTime?: int32(name='CreateTime'),
  grantOption?: boolean(name='GrantOption'),
  grantor?: string(name='Grantor'),
  grantorType?: string(name='GrantorType'),
  privilege?: string(name='Privilege'),
}

model AbortLockRequest {
  lockId?: long(name='LockId', description='The lock ID.', example='16530'),
}

model AbortLockResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The returned message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='01D8DD6B-4929-5999-9BB3-950AA30E3BD0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false.', example='True'),
}

model AbortLockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AbortLockResponseBody(name='body'),
}

/**
 * @summary Aborts the specified metadata lock.
 *
 * @param request AbortLockRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AbortLockResponse
 */
async function abortLockWithOptions(request: AbortLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AbortLockResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lockId)) {
    query['LockId'] = request.lockId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AbortLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks/abort`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Aborts the specified metadata lock.
 *
 * @param request AbortLockRequest
 * @return AbortLockResponse
 */
async function abortLock(request: AbortLockRequest): AbortLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return abortLockWithOptions(request, headers, runtime);
}

model BatchCreatePartitionsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  ifNotExists?: boolean(name='IfNotExists', description='Specifies whether to ignore the exception if a partition with the same name already exists.', example='true'),
  needResult?: boolean(name='NeedResult', description='Indicates whether to return partition information. If the value is true, Partitions is returned.', example='true'),
  partitionInputs?: [
    PartitionInput
  ](name='PartitionInputs', description='The list of partition input information.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model BatchCreatePartitionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='The list of error messages.'),
  partitions?: [
    Partition
  ](name='Partitions', description='The list of partitioning results. This parameter is returned if NeedResult=true.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchCreatePartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchCreatePartitionsResponseBody(name='body'),
}

/**
 * @summary Add multiple partitions to a data table in a data lake at a time.
 *
 * @param request BatchCreatePartitionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchCreatePartitionsResponse
 */
async function batchCreatePartitionsWithOptions(request: BatchCreatePartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchCreatePartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifNotExists)) {
    body['IfNotExists'] = request.ifNotExists;
  }
  if (!Util.isUnset(request.needResult)) {
    body['NeedResult'] = request.needResult;
  }
  if (!Util.isUnset(request.partitionInputs)) {
    body['PartitionInputs'] = request.partitionInputs;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchCreatePartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/batchcreate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Add multiple partitions to a data table in a data lake at a time.
 *
 * @param request BatchCreatePartitionsRequest
 * @return BatchCreatePartitionsResponse
 */
async function batchCreatePartitions(request: BatchCreatePartitionsRequest): BatchCreatePartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchCreatePartitionsWithOptions(request, headers, runtime);
}

model BatchCreateTablesRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  ifNotExists?: boolean(name='IfNotExists', description='Specifies whether to ignore the exception if a table with the same name already exists.', example='true'),
  tableInputs?: [
    TableInput
  ](name='TableInputs', description='The list of data tables.'),
}

model BatchCreateTablesResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='The list of error messages for creating data tables.', example='["ErrorDetail":{},"TableName":"test"]'),
}

model BatchCreateTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchCreateTablesResponseBody(name='body'),
}

/**
 * @summary Add data tables to a data lake at a time.
 *
 * @param request BatchCreateTablesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchCreateTablesResponse
 */
async function batchCreateTablesWithOptions(request: BatchCreateTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchCreateTablesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifNotExists)) {
    body['IfNotExists'] = request.ifNotExists;
  }
  if (!Util.isUnset(request.tableInputs)) {
    body['TableInputs'] = request.tableInputs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchCreateTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/batchcreate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Add data tables to a data lake at a time.
 *
 * @param request BatchCreateTablesRequest
 * @return BatchCreateTablesResponse
 */
async function batchCreateTables(request: BatchCreateTablesRequest): BatchCreateTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchCreateTablesWithOptions(request, headers, runtime);
}

model BatchDeletePartitionsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  ifExists?: boolean(name='IfExists', description='If a partition with the same name has been deleted, whether to ignore the exception.', example='true'),
  partitionValueList?: [ 
  {
    values?: [ string ](name='Values'),
  }
](name='PartitionValueList', description='The list of partition values to be deleted.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201225'),
}

model BatchDeletePartitionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='The list of error messages.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchDeletePartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeletePartitionsResponseBody(name='body'),
}

/**
 * @summary Deletes multiple partitions of a data table in the data lake.
 *
 * @param request BatchDeletePartitionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDeletePartitionsResponse
 */
async function batchDeletePartitionsWithOptions(request: BatchDeletePartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchDeletePartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifExists)) {
    body['IfExists'] = request.ifExists;
  }
  if (!Util.isUnset(request.partitionValueList)) {
    body['PartitionValueList'] = request.partitionValueList;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeletePartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/batchdelete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes multiple partitions of a data table in the data lake.
 *
 * @param request BatchDeletePartitionsRequest
 * @return BatchDeletePartitionsResponse
 */
async function batchDeletePartitions(request: BatchDeletePartitionsRequest): BatchDeletePartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchDeletePartitionsWithOptions(request, headers, runtime);
}

model BatchDeleteTableVersionsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
  versionIds?: [ int32 ](name='VersionIds', description='The list of version numbers.'),
}

model BatchDeleteTableVersionsResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchDeleteTableVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteTableVersionsResponseBody(name='body'),
}

/**
 * @summary Deletes a specified version of a data table in a data lake at a time.
 *
 * @param request BatchDeleteTableVersionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDeleteTableVersionsResponse
 */
async function batchDeleteTableVersionsWithOptions(request: BatchDeleteTableVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchDeleteTableVersionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }
  if (!Util.isUnset(request.versionIds)) {
    body['VersionIds'] = request.versionIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteTableVersions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/versions/batchdelete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a specified version of a data table in a data lake at a time.
 *
 * @param request BatchDeleteTableVersionsRequest
 * @return BatchDeleteTableVersionsResponse
 */
async function batchDeleteTableVersions(request: BatchDeleteTableVersionsRequest): BatchDeleteTableVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchDeleteTableVersionsWithOptions(request, headers, runtime);
}

model BatchDeleteTablesRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  ifExists?: boolean(name='IfExists', description='If a table with the same name has been deleted, whether to ignore the exception.', example='true'),
  tableNames?: [ string ](name='TableNames', description='The list of data table names.'),
}

model BatchDeleteTablesResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false', example='true'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='A collection of error messages.'),
}

model BatchDeleteTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteTablesResponseBody(name='body'),
}

/**
 * @summary Deletes multiple data tables in a data lake by name.
 *
 * @param request BatchDeleteTablesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDeleteTablesResponse
 */
async function batchDeleteTablesWithOptions(request: BatchDeleteTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchDeleteTablesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifExists)) {
    body['IfExists'] = request.ifExists;
  }
  if (!Util.isUnset(request.tableNames)) {
    body['TableNames'] = request.tableNames;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/batchdelete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes multiple data tables in a data lake by name.
 *
 * @param request BatchDeleteTablesRequest
 * @return BatchDeleteTablesResponse
 */
async function batchDeleteTables(request: BatchDeleteTablesRequest): BatchDeleteTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchDeleteTablesWithOptions(request, headers, runtime);
}

model BatchGetPartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  columnNames?: [ string ](name='ColumnNames', description='The list of fields in the data table.'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  partitionNames?: [ string ](name='PartitionNames', description='The list of partition names of the data table.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model BatchGetPartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionStatisticsMap?: map[string][
    ColumnStatisticsObj
  ](name='PartitionStatisticsMap', description='The partition statistics.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchGetPartitionColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetPartitionColumnStatisticsResponseBody(name='body'),
}

/**
 * @summary Obtains the field statistics of data table partitions in a data lake at a time.
 *
 * @param request BatchGetPartitionColumnStatisticsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetPartitionColumnStatisticsResponse
 */
async function batchGetPartitionColumnStatisticsWithOptions(request: BatchGetPartitionColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchGetPartitionColumnStatisticsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.columnNames)) {
    body['ColumnNames'] = request.columnNames;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionNames)) {
    body['PartitionNames'] = request.partitionNames;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetPartitionColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/columnstatistics/batchget`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the field statistics of data table partitions in a data lake at a time.
 *
 * @param request BatchGetPartitionColumnStatisticsRequest
 * @return BatchGetPartitionColumnStatisticsResponse
 */
async function batchGetPartitionColumnStatistics(request: BatchGetPartitionColumnStatisticsRequest): BatchGetPartitionColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGetPartitionColumnStatisticsWithOptions(request, headers, runtime);
}

model BatchGetPartitionsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  isShareSd?: boolean(name='IsShareSd', description='Specifies whether to share the column information in the SD of the partition.', example='true'),
  partitionValueList?: [ 
  {
    values?: [ string ](name='Values'),
  }
](name='PartitionValueList', description='The list of partition values.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
}

model BatchGetPartitionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='The list of error messages.'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs', description='The list of partition specifications.'),
  partitions?: [
    Partition
  ](name='Partitions', description='The list of partition details.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchGetPartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetPartitionsResponseBody(name='body'),
}

/**
 * @summary Obtains the details of database partitions in a data lake in batches.
 *
 * @param request BatchGetPartitionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetPartitionsResponse
 */
async function batchGetPartitionsWithOptions(request: BatchGetPartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchGetPartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.isShareSd)) {
    body['IsShareSd'] = request.isShareSd;
  }
  if (!Util.isUnset(request.partitionValueList)) {
    body['PartitionValueList'] = request.partitionValueList;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetPartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/batchget`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the details of database partitions in a data lake in batches.
 *
 * @param request BatchGetPartitionsRequest
 * @return BatchGetPartitionsResponse
 */
async function batchGetPartitions(request: BatchGetPartitionsRequest): BatchGetPartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGetPartitionsWithOptions(request, headers, runtime);
}

model BatchGetTablesRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableNames?: [ string ](name='TableNames', description='The name of the data table.'),
}

model BatchGetTablesResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false', example='true'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='The list of error messages.'),
  tables?: [
    Table
  ](name='Tables', description='The list of data tables.'),
}

model BatchGetTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetTablesResponseBody(name='body'),
}

/**
 * @summary Obtain detailed information about data tables in the data lake in batches.
 *
 * @param request BatchGetTablesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetTablesResponse
 */
async function batchGetTablesWithOptions(request: BatchGetTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchGetTablesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableNames)) {
    body['TableNames'] = request.tableNames;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/batchget`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtain detailed information about data tables in the data lake in batches.
 *
 * @param request BatchGetTablesRequest
 * @return BatchGetTablesResponse
 */
async function batchGetTables(request: BatchGetTablesRequest): BatchGetTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGetTablesWithOptions(request, headers, runtime);
}

model BatchGrantPermissionsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  grantRevokeEntries?: [
    GrantRevokeEntry
  ](name='GrantRevokeEntries', description='The list to be authorized.'),
  type?: string(name='Type', description='The type of the authorization. Only Hive is supported.

This parameter is required.', example='Hive'),
}

model BatchGrantPermissionsResponseBody = {
  batchGrantRevokeFailureResult?: [
  GrantRevokeFailureEntry
](name='BatchGrantRevokeFailureResult', description='The result of batch authorization errors.'),
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchGrantPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGrantPermissionsResponseBody(name='body'),
}

/**
 * @summary Grant the operation permissions on resources to a user or a data lake role at a time.
 *
 * @param request BatchGrantPermissionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGrantPermissionsResponse
 */
async function batchGrantPermissionsWithOptions(request: BatchGrantPermissionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchGrantPermissionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.grantRevokeEntries)) {
    body['GrantRevokeEntries'] = request.grantRevokeEntries;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchGrantPermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/batchgrant`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Grant the operation permissions on resources to a user or a data lake role at a time.
 *
 * @param request BatchGrantPermissionsRequest
 * @return BatchGrantPermissionsResponse
 */
async function batchGrantPermissions(request: BatchGrantPermissionsRequest): BatchGrantPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGrantPermissionsWithOptions(request, headers, runtime);
}

model BatchRevokePermissionsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  grantRevokeEntries?: [
    GrantRevokeEntry
  ](name='GrantRevokeEntries', description='The list to be authorized.'),
  type?: string(name='Type', description='The type of the authorization. Only Hive is supported.

This parameter is required.', example='Hive'),
}

model BatchRevokePermissionsResponseBody = {
  batchGrantRevokeFailureResult?: [
  GrantRevokeFailureEntry
](name='BatchGrantRevokeFailureResult', description='The result of batch authorization revocation failures.'),
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C9E535E1-F040-56F4-B4EE-592B555DAE19'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model BatchRevokePermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchRevokePermissionsResponseBody(name='body'),
}

/**
 * @summary You can call this operation to revoke permissions on resources from a user or data lake role at a time.
 *
 * @param request BatchRevokePermissionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchRevokePermissionsResponse
 */
async function batchRevokePermissionsWithOptions(request: BatchRevokePermissionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchRevokePermissionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.grantRevokeEntries)) {
    body['GrantRevokeEntries'] = request.grantRevokeEntries;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchRevokePermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/batchrevoke`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call this operation to revoke permissions on resources from a user or data lake role at a time.
 *
 * @param request BatchRevokePermissionsRequest
 * @return BatchRevokePermissionsResponse
 */
async function batchRevokePermissions(request: BatchRevokePermissionsRequest): BatchRevokePermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchRevokePermissionsWithOptions(request, headers, runtime);
}

model BatchUpdatePartitionsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  partitionInputs?: [
    PartitionInput
  ](name='PartitionInputs', description='The list of partition input information.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model BatchUpdatePartitionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='The list of error messages.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchUpdatePartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchUpdatePartitionsResponseBody(name='body'),
}

/**
 * @summary Batch update multiple partitions for a data table in a data lake.
 *
 * @param request BatchUpdatePartitionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchUpdatePartitionsResponse
 */
async function batchUpdatePartitionsWithOptions(request: BatchUpdatePartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchUpdatePartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionInputs)) {
    body['PartitionInputs'] = request.partitionInputs;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchUpdatePartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/batchupdate`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Batch update multiple partitions for a data table in a data lake.
 *
 * @param request BatchUpdatePartitionsRequest
 * @return BatchUpdatePartitionsResponse
 */
async function batchUpdatePartitions(request: BatchUpdatePartitionsRequest): BatchUpdatePartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchUpdatePartitionsWithOptions(request, headers, runtime);
}

model BatchUpdateTablesRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  isAsync?: boolean(name='IsAsync', description='Whether the table is updated asynchronously. Valid values:

*   true: The API operation is called asynchronously and does not wait for the background task to be returned. The response contains a taskid. In this way, the client can query the status of the task by using the taskid.
*   false: indicates a synchronous call. The interface returns results only when the background task is completed. Then the risk of false is that the interface will time out if the background task needs to be done very long.', example='true'),
  tableInputs?: [
    TableInput
  ](name='TableInputs', description='The details of the updated data table.'),
}

model BatchUpdateTablesResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='The list of error messages.', example='{"ErrorDetails":{},"TableName":"test"}'),
  taskId?: string(name='TaskId', description='The ID of the asynchronous update task.', example='f8deec55f54ac566e7ec8944fbe01588'),
}

model BatchUpdateTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchUpdateTablesResponseBody(name='body'),
}

/**
 * @summary Update the details of data tables in the data lake in batches.
 *
 * @param request BatchUpdateTablesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchUpdateTablesResponse
 */
async function batchUpdateTablesWithOptions(request: BatchUpdateTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchUpdateTablesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.isAsync)) {
    body['IsAsync'] = request.isAsync;
  }
  if (!Util.isUnset(request.tableInputs)) {
    body['TableInputs'] = request.tableInputs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchUpdateTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/batchupdate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update the details of data tables in the data lake in batches.
 *
 * @param request BatchUpdateTablesRequest
 * @return BatchUpdateTablesResponse
 */
async function batchUpdateTables(request: BatchUpdateTablesRequest): BatchUpdateTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchUpdateTablesWithOptions(request, headers, runtime);
}

model CancelQueryRequest {
  queryId?: string(name='QueryId', description='The query ID.

>  You can call the SubmitQuery operation to query the query ID.', example='Q-BCA5E96CB84BB8B8'),
}

model CancelQueryResponseBody = {
  data?: string(name='Data', description='Query ID', example='Q-BCA5E96CB84BB8B8'),
  requestId?: string(name='RequestId', description='The request ID.', example='DB07AAE9-4B88-5DEA-8F1D-4D1A9A864A85'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model CancelQueryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelQueryResponseBody(name='body'),
}

/**
 * @summary Cancel a query request.
 *
 * @param request CancelQueryRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelQueryResponse
 */
async function cancelQueryWithOptions(request: CancelQueryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelQueryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.queryId)) {
    query['QueryId'] = request.queryId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelQuery',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/cancelQuery`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Cancel a query request.
 *
 * @param request CancelQueryRequest
 * @return CancelQueryResponse
 */
async function cancelQuery(request: CancelQueryRequest): CancelQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelQueryWithOptions(request, headers, runtime);
}

model CheckPermissionsRequest {
  body?: AccessRequest(name='Body', description='The HTTP request body, which is in the JSON format.'),
}

model CheckPermissionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='81B90E1B-7514-5817-9D59-0EA9E2215876'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model CheckPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckPermissionsResponseBody(name='body'),
}

/**
 * @summary Verify user permissions.
 *
 * @param request CheckPermissionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckPermissionsResponse
 */
async function checkPermissionsWithOptions(request: CheckPermissionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckPermissionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CheckPermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/check`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Verify user permissions.
 *
 * @param request CheckPermissionsRequest
 * @return CheckPermissionsResponse
 */
async function checkPermissions(request: CheckPermissionsRequest): CheckPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkPermissionsWithOptions(request, headers, runtime);
}

model CreateCatalogRequest {
  catalogInput?: CatalogInput(name='CatalogInput', description='Create /update the structure of the Catalog.'),
}

model CreateCatalogResponseBody = {
  code?: string(name='Code', description='The status code returned.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='BA84F8D4-5160-5544-BE76-3A306CD3A7B0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model CreateCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCatalogResponseBody(name='body'),
}

/**
 * @summary Create a Data Catalog for Data Lake.
 *
 * @param request CreateCatalogRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCatalogResponse
 */
async function createCatalogWithOptions(request: CreateCatalogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateCatalogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogInput)) {
    body['CatalogInput'] = request.catalogInput;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCatalog',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create a Data Catalog for Data Lake.
 *
 * @param request CreateCatalogRequest
 * @return CreateCatalogResponse
 */
async function createCatalog(request: CreateCatalogRequest): CreateCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createCatalogWithOptions(request, headers, runtime);
}

model CreateDatabaseRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseInput?: DatabaseInput(name='DatabaseInput', description='The details of the database.'),
}

model CreateDatabaseResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request is successful.
*   false: The request failed.', example='true'),
}

model CreateDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDatabaseResponseBody(name='body'),
}

/**
 * @summary Create a metadabase in the data lake metadata.
 *
 * @param request CreateDatabaseRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDatabaseResponse
 */
async function createDatabaseWithOptions(request: CreateDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDatabaseResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseInput)) {
    body['DatabaseInput'] = request.databaseInput;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDatabase',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create a metadabase in the data lake metadata.
 *
 * @param request CreateDatabaseRequest
 * @return CreateDatabaseResponse
 */
async function createDatabase(request: CreateDatabaseRequest): CreateDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDatabaseWithOptions(request, headers, runtime);
}

model CreateFunctionRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  functionInput?: FunctionInput(name='FunctionInput', description='The details of the function definition.'),
}

model CreateFunctionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model CreateFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFunctionResponseBody(name='body'),
}

/**
 * @summary Added user-defined functions for databases in the data lake.
 *
 * @param request CreateFunctionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFunctionResponse
 */
async function createFunctionWithOptions(request: CreateFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionInput)) {
    body['FunctionInput'] = request.functionInput;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFunction',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Added user-defined functions for databases in the data lake.
 *
 * @param request CreateFunctionRequest
 * @return CreateFunctionResponse
 */
async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFunctionWithOptions(request, headers, runtime);
}

model CreateLockRequest {
  lockObjList?: [
    LockObj
  ](name='LockObjList', description='The list of lock information.', example='{"databaseName":"db","tableName":"test"}'),
}

model CreateLockResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  lockStatus?: LockStatus(name='LockStatus', description='The lock status information.', example='{"lockId":12323,"lockStatus":"ACQUIRED"}'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='73201200-4C1A-4FEF-BD6B-C0DA7994FFA2'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false.', example='True'),
}

model CreateLockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLockResponseBody(name='body'),
}

/**
 * @summary Creates a specified metadata lock.
 *
 * @param request CreateLockRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLockResponse
 */
async function createLockWithOptions(request: CreateLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLockResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.lockObjList)) {
    body['LockObjList'] = request.lockObjList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a specified metadata lock.
 *
 * @param request CreateLockRequest
 * @return CreateLockResponse
 */
async function createLock(request: CreateLockRequest): CreateLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLockWithOptions(request, headers, runtime);
}

model CreatePartitionRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  ifNotExists?: boolean(name='IfNotExists', description='Specifies whether to ignore the exception if a partition with the same name already exists.', example='true'),
  needResult?: boolean(name='NeedResult', description='Indicates whether to return partition information. If the value is true, Partitions is returned.', example='true'),
  partitionInput?: PartitionInput(name='PartitionInput', description='The partition input information.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model CreatePartitionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partition?: Partition(name='Partition', description='The partitioning result. This parameter is returned if NeedResult=true.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model CreatePartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePartitionResponseBody(name='body'),
}

/**
 * @summary Add a partition to the data table of the data lake.
 *
 * @param request CreatePartitionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePartitionResponse
 */
async function createPartitionWithOptions(request: CreatePartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePartitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifNotExists)) {
    body['IfNotExists'] = request.ifNotExists;
  }
  if (!Util.isUnset(request.needResult)) {
    body['NeedResult'] = request.needResult;
  }
  if (!Util.isUnset(request.partitionInput)) {
    body['PartitionInput'] = request.partitionInput;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePartition',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Add a partition to the data table of the data lake.
 *
 * @param request CreatePartitionRequest
 * @return CreatePartitionResponse
 */
async function createPartition(request: CreatePartitionRequest): CreatePartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPartitionWithOptions(request, headers, runtime);
}

model CreateRoleRequest {
  body?: RoleInput(name='body', description='The HTTP request body, which is in the JSON format.'),
}

model CreateRoleResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='77BC2016-BA80-570F-BD15-2FB80281FED6'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model CreateRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRoleResponseBody(name='body'),
}

/**
 * @summary In the Data Lake Permissions section, add a role.
 *
 * @param request CreateRoleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRoleResponse
 */
async function createRoleWithOptions(request: CreateRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRoleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRole',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary In the Data Lake Permissions section, add a role.
 *
 * @param request CreateRoleRequest
 * @return CreateRoleResponse
 */
async function createRole(request: CreateRoleRequest): CreateRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRoleWithOptions(request, headers, runtime);
}

model CreateTableRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableInput?: TableInput(name='TableInput', description='The detailed information about the data table.'),
}

model CreateTableResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model CreateTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTableResponseBody(name='body'),
}

/**
 * @summary Add a data table for the data lake.
 *
 * @param request CreateTableRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTableResponse
 */
async function createTableWithOptions(request: CreateTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTableResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableInput)) {
    body['TableInput'] = request.tableInput;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Add a data table for the data lake.
 *
 * @param request CreateTableRequest
 * @return CreateTableResponse
 */
async function createTable(request: CreateTableRequest): CreateTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTableWithOptions(request, headers, runtime);
}

model DeleteCatalogRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.

This parameter is required.', example='catalog_test'),
  isAsync?: boolean(name='IsAsync', description='Whether asynchronous, synchronous by default.', example='true'),
}

model DeleteCatalogResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
  taskId?: string(name='TaskId', description='The ID of the task for asynchronously deleting a catalog.', example='c38206c3aca0c41332ffe49294243009'),
}

model DeleteCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCatalogResponseBody(name='body'),
}

/**
 * @summary Deletes a data directory.
 *
 * @param request DeleteCatalogRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCatalogResponse
 */
async function deleteCatalogWithOptions(request: DeleteCatalogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteCatalogResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.isAsync)) {
    query['IsAsync'] = request.isAsync;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCatalog',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a data directory.
 *
 * @param request DeleteCatalogRequest
 * @return DeleteCatalogResponse
 */
async function deleteCatalog(request: DeleteCatalogRequest): DeleteCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteCatalogWithOptions(request, headers, runtime);
}

model DeleteDatabaseRequest {
  async?: boolean(name='Async', description='Whether to asynchronously execute.', example='true'),
  cascade?: boolean(name='Cascade', description='Whether to cascade delete data. Valid values:

*   true: deletes a table from the database.
*   false: does not delete tables from the database. If a table still exists in the database, the deletion fails.', example='false'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  name?: string(name='Name', description='The name of a database.', example='database_test'),
}

model DeleteDatabaseResponseBody = {
  code?: string(name='Code', description='The description of the distribution status.', example='OK'),
  message?: string(name='Message', description='A related error message is displayed.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='73201200-4C1A-4FEF-BD6B-C0DA7994FFA2'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
  taskId?: string(name='TaskId', description='The ID of the task that is used to asynchronously delete a database.', example='c38206c3aca0c41332ffe49294243009'),
}

model DeleteDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDatabaseResponseBody(name='body'),
}

/**
 * @summary Deletes a database in the data lake by name.
 *
 * @param request DeleteDatabaseRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDatabaseResponse
 */
async function deleteDatabaseWithOptions(request: DeleteDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDatabaseResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.async)) {
    query['Async'] = request.async;
  }
  if (!Util.isUnset(request.cascade)) {
    query['Cascade'] = request.cascade;
  }
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDatabase',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a database in the data lake by name.
 *
 * @param request DeleteDatabaseRequest
 * @return DeleteDatabaseResponse
 */
async function deleteDatabase(request: DeleteDatabaseRequest): DeleteDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDatabaseWithOptions(request, headers, runtime);
}

model DeleteFunctionRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  functionName?: string(name='FunctionName', description='The function name.', example='func2'),
}

model DeleteFunctionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeleteFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFunctionResponseBody(name='body'),
}

/**
 * @summary Deletes a user-defined function for a database in the data lake by name.
 *
 * @param request DeleteFunctionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFunctionResponse
 */
async function deleteFunctionWithOptions(request: DeleteFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunction',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a user-defined function for a database in the data lake by name.
 *
 * @param request DeleteFunctionRequest
 * @return DeleteFunctionResponse
 */
async function deleteFunction(request: DeleteFunctionRequest): DeleteFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionWithOptions(request, headers, runtime);
}

model DeletePartitionRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  ifExists?: boolean(name='IfExists', description='If a partition with the same name has been deleted, whether to ignore the exception.', example='true'),
  partitionValues?: [ string ](name='PartitionValues', description='The value in a partition key column.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201225'),
}

model DeletePartitionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeletePartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePartitionResponseBody(name='body'),
}

/**
 * @summary Deletes a specified partition from a data table in the data lake.
 *
 * @param request DeletePartitionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePartitionResponse
 */
async function deletePartitionWithOptions(request: DeletePartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePartitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifExists)) {
    body['IfExists'] = request.ifExists;
  }
  if (!Util.isUnset(request.partitionValues)) {
    body['PartitionValues'] = request.partitionValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeletePartition',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a specified partition from a data table in the data lake.
 *
 * @param request DeletePartitionRequest
 * @return DeletePartitionResponse
 */
async function deletePartition(request: DeletePartitionRequest): DeletePartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePartitionWithOptions(request, headers, runtime);
}

model DeletePartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  columnNames?: [ string ](name='ColumnNames', description='The list of field names.'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  partitionNames?: [ string ](name='PartitionNames', description='The list of partition names.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model DeletePartitionColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  columnNamesShrink?: string(name='ColumnNames', description='The list of field names.'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  partitionNamesShrink?: string(name='PartitionNames', description='The list of partition names.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model DeletePartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeletePartitionColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePartitionColumnStatisticsResponseBody(name='body'),
}

/**
 * @summary Reclaim the field statistics of data table partitions in the data lake.
 *
 * @param tmpReq DeletePartitionColumnStatisticsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePartitionColumnStatisticsResponse
 */
async function deletePartitionColumnStatisticsWithOptions(tmpReq: DeletePartitionColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePartitionColumnStatisticsResponse {
  Util.validateModel(tmpReq);
  var request = new DeletePartitionColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  if (!Util.isUnset(tmpReq.partitionNames)) {
    request.partitionNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.partitionNames, 'PartitionNames', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.columnNamesShrink)) {
    query['ColumnNames'] = request.columnNamesShrink;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionNamesShrink)) {
    query['PartitionNames'] = request.partitionNamesShrink;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePartitionColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/columnstatistics`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Reclaim the field statistics of data table partitions in the data lake.
 *
 * @param request DeletePartitionColumnStatisticsRequest
 * @return DeletePartitionColumnStatisticsResponse
 */
async function deletePartitionColumnStatistics(request: DeletePartitionColumnStatisticsRequest): DeletePartitionColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePartitionColumnStatisticsWithOptions(request, headers, runtime);
}

model DeleteRoleRequest {
  roleName?: string(name='RoleName', description='The name of the role to be deleted.', example='roleId/roleName至少有一个是非空'),
}

model DeleteRoleResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeleteRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRoleResponseBody(name='body'),
}

/**
 * @summary Delete a role from Data Lake Permissions.
 *
 * @param request DeleteRoleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRoleResponse
 */
async function deleteRoleWithOptions(request: DeleteRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRoleResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.roleName)) {
    query['RoleName'] = request.roleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRole',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete a role from Data Lake Permissions.
 *
 * @param request DeleteRoleRequest
 * @return DeleteRoleResponse
 */
async function deleteRole(request: DeleteRoleRequest): DeleteRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRoleWithOptions(request, headers, runtime);
}

model DeleteTableRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model DeleteTableResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeleteTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTableResponseBody(name='body'),
}

/**
 * @summary Deletes a data table in a data lake by name.
 *
 * @param request DeleteTableRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTableResponse
 */
async function deleteTableWithOptions(request: DeleteTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTableResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a data table in a data lake by name.
 *
 * @param request DeleteTableRequest
 * @return DeleteTableResponse
 */
async function deleteTable(request: DeleteTableRequest): DeleteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTableWithOptions(request, headers, runtime);
}

model DeleteTableColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  columnNames?: [ string ](name='ColumnNames', description='The list of field names.'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model DeleteTableColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  columnNamesShrink?: string(name='ColumnNames', description='The list of field names.'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model DeleteTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeleteTableColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTableColumnStatisticsResponseBody(name='body'),
}

/**
 * @summary Recycle field statistics for data tables in the data lake.
 *
 * @param tmpReq DeleteTableColumnStatisticsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTableColumnStatisticsResponse
 */
async function deleteTableColumnStatisticsWithOptions(tmpReq: DeleteTableColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTableColumnStatisticsResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteTableColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.columnNamesShrink)) {
    query['ColumnNames'] = request.columnNamesShrink;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTableColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/columnstatistics`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Recycle field statistics for data tables in the data lake.
 *
 * @param request DeleteTableColumnStatisticsRequest
 * @return DeleteTableColumnStatisticsResponse
 */
async function deleteTableColumnStatistics(request: DeleteTableColumnStatisticsRequest): DeleteTableColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTableColumnStatisticsWithOptions(request, headers, runtime);
}

model DeleteTableVersionRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
  versionId?: int32(name='VersionId', description='The version number.', example='1'),
}

model DeleteTableVersionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeleteTableVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTableVersionResponseBody(name='body'),
}

/**
 * @summary Deletes a specified version of a data table in the data lake.
 *
 * @param request DeleteTableVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTableVersionResponse
 */
async function deleteTableVersionWithOptions(request: DeleteTableVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTableVersionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTableVersion',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/versions`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a specified version of a data table in the data lake.
 *
 * @param request DeleteTableVersionRequest
 * @return DeleteTableVersionResponse
 */
async function deleteTableVersion(request: DeleteTableVersionRequest): DeleteTableVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTableVersionWithOptions(request, headers, runtime);
}

model DeregisterLocationRequest {
  locationId?: string(name='LocationId', description='Location ID

>  You can call the RegisterLocation operation to obtain the Location ID.

This parameter is required.', example='LOC-AB8FBC17F95A4AF5'),
}

model DeregisterLocationResponseBody = {
  data?: {
    locationId?: string(name='LocationId', description='Location ID', example='LOC-AB8FBC17F95A4AF5'),
    storageCollectTaskOperationResultList?: [
      StorageCollectTaskOperationResult
    ](name='StorageCollectTaskOperationResultList', description='Disable the result list of a collection task'),
  }(name='Data', description='The response parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='E47920CD-BAE6-1305-88DF-FBDD3D300845'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true.
*   false: The request failed.', example='true'),
}

model DeregisterLocationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeregisterLocationResponseBody(name='body'),
}

/**
 * @summary Cancel Location registration.
 *
 * @param request DeregisterLocationRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeregisterLocationResponse
 */
async function deregisterLocationWithOptions(request: DeregisterLocationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeregisterLocationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.locationId)) {
    query['LocationId'] = request.locationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeregisterLocation',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/locations`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Cancel Location registration.
 *
 * @param request DeregisterLocationRequest
 * @return DeregisterLocationResponse
 */
async function deregisterLocation(request: DeregisterLocationRequest): DeregisterLocationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deregisterLocationWithOptions(request, headers, runtime);
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      description?: string(name='Description', description='The description of the filtering table.'),
      name?: string(name='Name', description='The name of the data.', example='cn-hangzhou'),
      showName?: string(name='ShowName', description='The display name.'),
      type?: string(name='Type', description='The type.', example='region'),
    }
  ](name='Regions', description='The region list.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the test feature is enabled.', example='true'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @summary Obtains the list of open regions.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
async function describeRegionsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/service/describeRegions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the list of open regions.
 *
 * @return DescribeRegionsResponse
 */
async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(headers, runtime);
}

model GetAsyncTaskStatusRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  taskId?: string(name='TaskId', description='The result returned by the asynchronous task.', example='f546c761570e5efc8146a1986f7890d2'),
}

model GetAsyncTaskStatusResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The message that is returned.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  taskStatus?: TaskStatus(name='TaskStatus', description='The state of the task.', example='Success'),
}

model GetAsyncTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAsyncTaskStatusResponseBody(name='body'),
}

/**
 * @summary Used in metadata-related asynchronous APIs to check the status of asynchronous execution tasks.
 *
 * @param request GetAsyncTaskStatusRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAsyncTaskStatusResponse
 */
async function getAsyncTaskStatusWithOptions(request: GetAsyncTaskStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAsyncTaskStatusResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAsyncTaskStatus',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Used in metadata-related asynchronous APIs to check the status of asynchronous execution tasks.
 *
 * @param request GetAsyncTaskStatusRequest
 * @return GetAsyncTaskStatusResponse
 */
async function getAsyncTaskStatus(request: GetAsyncTaskStatusRequest): GetAsyncTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAsyncTaskStatusWithOptions(request, headers, runtime);
}

model GetCatalogRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='catalog_test'),
}

model GetCatalogResponseBody = {
  catalog?: Catalog(name='Catalog', description='The catalog details.'),
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The returned message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='DB07AAE9-4B88-5DEA-8F1D-4D1A9A864A85'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model GetCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCatalogResponseBody(name='body'),
}

/**
 * @summary Obtains the details of a data directory.
 *
 * @param request GetCatalogRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCatalogResponse
 */
async function getCatalogWithOptions(request: GetCatalogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCatalogResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCatalog',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the details of a data directory.
 *
 * @param request GetCatalogRequest
 * @return GetCatalogResponse
 */
async function getCatalog(request: GetCatalogRequest): GetCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCatalogWithOptions(request, headers, runtime);
}

model GetCatalogSettingsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
}

model GetCatalogSettingsResponseBody = {
  catalogSettings?: CatalogSettings(name='CatalogSettings', description='Data lake-related configurations.'),
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model GetCatalogSettingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCatalogSettingsResponseBody(name='body'),
}

/**
 * @summary To obtain the configurations of Data Lake Catalog, you must assume the admin role or above.
 *
 * @param request GetCatalogSettingsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCatalogSettingsResponse
 */
async function getCatalogSettingsWithOptions(request: GetCatalogSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCatalogSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCatalogSettings',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/settings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary To obtain the configurations of Data Lake Catalog, you must assume the admin role or above.
 *
 * @param request GetCatalogSettingsRequest
 * @return GetCatalogSettingsResponse
 */
async function getCatalogSettings(request: GetCatalogSettingsRequest): GetCatalogSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCatalogSettingsWithOptions(request, headers, runtime);
}

model GetDatabaseRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  name?: string(name='Name', description='The name of a database.', example='database_test'),
}

model GetDatabaseResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  database?: Database(name='Database', description='The database object.', example='{"name":"test"}'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D659761F-29C3-409D-805A-0CF33A320128'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model GetDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDatabaseResponseBody(name='body'),
}

/**
 * @summary Obtains the details of a database in a data lake.
 *
 * @param request GetDatabaseRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDatabaseResponse
 */
async function getDatabaseWithOptions(request: GetDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDatabaseResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDatabase',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the details of a database in a data lake.
 *
 * @param request GetDatabaseRequest
 * @return GetDatabaseResponse
 */
async function getDatabase(request: GetDatabaseRequest): GetDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDatabaseWithOptions(request, headers, runtime);
}

model GetDatabaseProfileRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory. By default, the ID of the primary account is entered.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of the metadatabase.

This parameter is required.', example='530_db'),
}

model GetDatabaseProfileResponseBody = {
  code?: string(name='Code', description='The error code.', example='200'),
  databaseProfile?: DatabaseProfile(name='DatabaseProfile', description='Database Data Overview', example='{
	"FileCnt": 213,
	"FileSize": 34324
}'),
  message?: string(name='Message', description='The error message.', example='-'),
  requestId?: string(name='RequestId', description='The request ID.', example='AEA7DCC8-DBF5-561B-A7FD-0747D7D51FEB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model GetDatabaseProfileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDatabaseProfileResponseBody(name='body'),
}

/**
 * @summary Gets the details of the database data profile.
 *
 * @description To use a data profile, you must first host the OSS bucket of the database.
 *
 * @param request GetDatabaseProfileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDatabaseProfileResponse
 */
async function getDatabaseProfileWithOptions(request: GetDatabaseProfileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDatabaseProfileResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDatabaseProfile',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/metastorehouse/catalog/database/databaseprofile`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Gets the details of the database data profile.
 *
 * @description To use a data profile, you must first host the OSS bucket of the database.
 *
 * @param request GetDatabaseProfileRequest
 * @return GetDatabaseProfileResponse
 */
async function getDatabaseProfile(request: GetDatabaseProfileRequest): GetDatabaseProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDatabaseProfileWithOptions(request, headers, runtime);
}

model GetFunctionRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  functionName?: string(name='FunctionName', description='The name of the user-defined function.', example='func2'),
}

model GetFunctionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  function?: Function(name='Function', description='The description of the function.', example='{"FunctionName":test}'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GetFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionResponseBody(name='body'),
}

/**
 * @summary Obtain the user-defined function of the database in the data lake based on the function name.
 *
 * @param request GetFunctionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionResponse
 */
async function getFunctionWithOptions(request: GetFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunction',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtain the user-defined function of the database in the data lake based on the function name.
 *
 * @param request GetFunctionRequest
 * @return GetFunctionResponse
 */
async function getFunction(request: GetFunctionRequest): GetFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionWithOptions(request, headers, runtime);
}

model GetLifecycleRuleRequest {
  bizId?: string(name='BizId', description='The business ID.', example='LCRU-17E7192705C365C0'),
  resourceName?: string(name='ResourceName', description='The name of the resource, which is a string that consists of the data directory, database, and table.', example='demo_catalog_id.demo_db_name.demo_table_name'),
}

model GetLifecycleRuleResponseBody = {
  data?: LifecycleRule(name='Data', description='The information about the lifecycle rule.'),
  requestId?: string(name='RequestId', description='The request ID.', example='EDBC848F-7CC7-52E3-9FBF-924D09B5C27A'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false.', example='True'),
}

model GetLifecycleRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLifecycleRuleResponseBody(name='body'),
}

/**
 * @summary Obtains the lifecycle rules of a database and table.
 *
 * @param request GetLifecycleRuleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLifecycleRuleResponse
 */
async function getLifecycleRuleWithOptions(request: GetLifecycleRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetLifecycleRuleResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLifecycleRule',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/metastorehouse/lifecycle/rule/getLifecycleRule`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the lifecycle rules of a database and table.
 *
 * @param request GetLifecycleRuleRequest
 * @return GetLifecycleRuleResponse
 */
async function getLifecycleRule(request: GetLifecycleRuleRequest): GetLifecycleRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLifecycleRuleWithOptions(request, headers, runtime);
}

model GetLockRequest {
  lockId?: long(name='LockId', description='The lock ID.', example='16533'),
}

model GetLockResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  lockStatus?: LockStatus(name='LockStatus', description='The lock status information.', example='{"lockId":123,"lockStatus":"Acquired"}'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='558D764F-8C55-49CA-BF38-80EA532FC08F'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false.', example='True'),
}

model GetLockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLockResponseBody(name='body'),
}

/**
 * @summary Queries the specified metadata lock.
 *
 * @param request GetLockRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLockResponse
 */
async function getLockWithOptions(request: GetLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetLockResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lockId)) {
    query['LockId'] = request.lockId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the specified metadata lock.
 *
 * @param request GetLockRequest
 * @return GetLockResponse
 */
async function getLock(request: GetLockRequest): GetLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLockWithOptions(request, headers, runtime);
}

model GetPartitionRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  partitionValues?: [ string ](name='PartitionValues', description='The data disk partitions.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
}

model GetPartitionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partition?: Partition(name='Partition', description='The partition details.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GetPartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPartitionResponseBody(name='body'),
}

/**
 * @summary Get details about the database partitions in the data lake.
 *
 * @param request GetPartitionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPartitionResponse
 */
async function getPartitionWithOptions(request: GetPartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetPartitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionValues)) {
    body['PartitionValues'] = request.partitionValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetPartition',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get details about the database partitions in the data lake.
 *
 * @param request GetPartitionRequest
 * @return GetPartitionResponse
 */
async function getPartition(request: GetPartitionRequest): GetPartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPartitionWithOptions(request, headers, runtime);
}

model GetPartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  columnNames?: [ string ](name='ColumnNames', description='The list of fields in the data table.'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  partitionNames?: [ string ](name='PartitionNames', description='The list of partitions in the data table.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model GetPartitionColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  columnNamesShrink?: string(name='ColumnNames', description='The list of fields in the data table.'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  partitionNamesShrink?: string(name='PartitionNames', description='The list of partitions in the data table.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model GetPartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionStatisticsMap?: map[string][
    ColumnStatisticsObj
  ](name='PartitionStatisticsMap', description='The partition statistics.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GetPartitionColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPartitionColumnStatisticsResponseBody(name='body'),
}

/**
 * @summary Obtains the statistics of a specified field for a data partition in a data lake.
 *
 * @param tmpReq GetPartitionColumnStatisticsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPartitionColumnStatisticsResponse
 */
async function getPartitionColumnStatisticsWithOptions(tmpReq: GetPartitionColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetPartitionColumnStatisticsResponse {
  Util.validateModel(tmpReq);
  var request = new GetPartitionColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  if (!Util.isUnset(tmpReq.partitionNames)) {
    request.partitionNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.partitionNames, 'PartitionNames', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.columnNamesShrink)) {
    query['ColumnNames'] = request.columnNamesShrink;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionNamesShrink)) {
    query['PartitionNames'] = request.partitionNamesShrink;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPartitionColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/columnstatistics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the statistics of a specified field for a data partition in a data lake.
 *
 * @param request GetPartitionColumnStatisticsRequest
 * @return GetPartitionColumnStatisticsResponse
 */
async function getPartitionColumnStatistics(request: GetPartitionColumnStatisticsRequest): GetPartitionColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPartitionColumnStatisticsWithOptions(request, headers, runtime);
}

model GetQueryResultRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum value is 1000.', example='100'),
  queryId?: string(name='QueryId', description='The query ID.

>  You can call the SubmitQuery operation to query the query ID.', example='Q-41676378709440CE'),
}

model GetQueryResultResponseBody = {
  duration?: long(name='Duration', description='up time in milliseconds.', example='8000'),
  endTime?: string(name='EndTime', description='The time when the query was completed.', example='2022-05-09 16:19:09'),
  errorMessage?: string(name='ErrorMessage', description='The error message of the query.', example='Table or view not found:'),
  gmtCreate?: string(name='GmtCreate', description='The time when the query was created.', example='2022-05-09 16:18:09'),
  gmtModified?: string(name='GmtModified', description='The time when the query result was updated.', example='2022-05-09 16:19:09'),
  id?: string(name='Id', description='The query ID.', example='Q-41676378709440CE'),
  jobCompleted?: boolean(name='JobCompleted', description='Whether the query has been completed. false indicates that you need to continue polling this interface.', example='true'),
  logs?: string(name='Logs', description='Run logs.', example='["this is log"]'),
  owner?: long(name='Owner', description='The uid of the primary account of the creator.', example='229167306180609***'),
  progress?: int32(name='Progress', description='The progress of the query. The value ranges from 0 to 100.', example='99'),
  regionId?: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='The request ID.', example='1D2BCFBA-7639-59A9-817B-944EC1339279'),
  resultTmpDb?: string(name='ResultTmpDb', description='The result temporary library is not available.', example='db'),
  resultTmpTable?: string(name='ResultTmpTable', description='The result temporary table, which is not available.', example='table'),
  rowCount?: int32(name='RowCount', description='The total number of rows in the result. This parameter is returned only when the status is AVAILABLE.', example='100'),
  rowCountOverLimit?: boolean(name='RowCountOverLimit', description='Whether the total number of rows in the result exceeds the maximum value.', example='false'),
  rows?: string(name='Rows', description='The returned result. This value is returned only when the status is AVAILABLE. The content is represented as a two-dimensional JSON array.', example='[[10,"Tom"],[11,"Jerry"]]'),
  schema?: string(name='Schema', description='The header field and type of the query result. This parameter is returned only when the status is AVAILABLE.', example='[{"name":"id","type":"INT"},{"name":"student_name","type":"VARCHAR"}]'),
  sql?: string(name='Sql', description='The original SQL statement.', example='select * from db.student'),
  startTime?: string(name='StartTime', description='The point in time when the query was initiated.', example='2022-05-09 16:18:09'),
  status?: string(name='Status', description='The query status.

Valid values:

*   AVAILABLE
*   CANCELLED: The has canceled the.
*
*   CANCELLING: The is being canceled.
*   WAITING: The is waiting for.
*   ERROR', example='AVAILABLE'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
  totalBytesProcessed?: long(name='TotalBytesProcessed', description='The total amount of data scanned. Unit: bytes.', example='1024'),
}

model GetQueryResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQueryResultResponseBody(name='body'),
}

/**
 * @summary Obtains the results of a data exploration query.
 *
 * @param request GetQueryResultRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetQueryResultResponse
 */
async function getQueryResultWithOptions(request: GetQueryResultRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetQueryResultResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryId)) {
    query['QueryId'] = request.queryId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetQueryResult',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/getQueryResult`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the results of a data exploration query.
 *
 * @param request GetQueryResultRequest
 * @return GetQueryResultResponse
 */
async function getQueryResult(request: GetQueryResultRequest): GetQueryResultResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getQueryResultWithOptions(request, headers, runtime);
}

model GetRegionStatusRequest {
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model GetRegionStatusResponseBody = {
  data?: {
    accountStatus?: string(name='AccountStatus', description='Account status enabled or disabled', example='enabled'),
    isDependencyReady?: boolean(name='IsDependencyReady', description='Whether the dependency is ready', example='true'),
    isDlfServiceOpen?: boolean(name='IsDlfServiceOpen', description='Whether the DLF service is activated', example='True'),
    regionId?: string(name='RegionId', description='region id', example='cn_hangzhou'),
    regionStatus?: string(name='RegionStatus', description='The status of the region. SERVICE_INVALID: The service is unavailable. UNITITIALIZED: Not initialized. READY: Normal.', example='READY'),
  }(name='Data', description='The returned data.', example='{\\\\"RegionId\\\\": \\\\"cn-shanghai\\\\", \\\\"RegionStatus\\\\": \\\\"SERVICE_INVALID\\\\", \\\\"AccountStatus\\\\": \\\\"\\\\", \\\\"IsDlfServiceOpen\\\\": False}'),
  requestId?: string(name='RequestId', description='The request ID.', example='CC58A776-0662-5C6D-B467-FFD4CF7F4C40'),
  success?: string(name='Success', description='Indicates whether the request is successful.', example='true'),
}

model GetRegionStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRegionStatusResponseBody(name='body'),
}

/**
 * @summary You can Data Lake Formation the activation status of the service in the specified region.
 *
 * @param request GetRegionStatusRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRegionStatusResponse
 */
async function getRegionStatusWithOptions(request: GetRegionStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRegionStatusResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRegionStatus',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/service/getRegionStatus`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can Data Lake Formation the activation status of the service in the specified region.
 *
 * @param request GetRegionStatusRequest
 * @return GetRegionStatusResponse
 */
async function getRegionStatus(request: GetRegionStatusRequest): GetRegionStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRegionStatusWithOptions(request, headers, runtime);
}

model GetRoleRequest {
  roleName?: string(name='RoleName', description='The name of the role.', example='role_name'),
}

model GetRoleResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4316D7DA-9816-596D-A3D7-12676FA59BDA'),
  role?: Role(name='Role', description='The role of the current API caller.'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GetRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRoleResponseBody(name='body'),
}

/**
 * @summary Obtain the role in Data Lake Permissions based on the role name.
 *
 * @param request GetRoleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRoleResponse
 */
async function getRoleWithOptions(request: GetRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRoleResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.roleName)) {
    query['RoleName'] = request.roleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRole',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtain the role in Data Lake Permissions based on the role name.
 *
 * @param request GetRoleRequest
 * @return GetRoleResponse
 */
async function getRole(request: GetRoleRequest): GetRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRoleWithOptions(request, headers, runtime);
}

model GetServiceStatusRequest {
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model GetServiceStatusResponseBody = {
  data?: {
    hasRamPermissions?: boolean(name='HasRamPermissions', description='Whether to complete RAM authorization', example='true'),
    isDlfServiceOpen?: boolean(name='IsDlfServiceOpen', description='Whether the DLF service is activated', example='true'),
    isOssOpen?: boolean(name='IsOssOpen', description='Whether the OSS service is enabled', example='true'),
  }(name='Data', description='Service status', example='{ 			"AccountStatus":"", 			"RegionStatus":"READY", 			"RegionId":"cn-shanghai", 			"IsDependencyReady":true, 			"IsDlfServiceOpen":true 		}'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the test feature is enabled.', example='true'),
}

model GetServiceStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetServiceStatusResponseBody(name='body'),
}

/**
 * @summary Obtains the service activation status of a Data Lake Formation user.
 *
 * @param request GetServiceStatusRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetServiceStatusResponse
 */
async function getServiceStatusWithOptions(request: GetServiceStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceStatusResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceStatus',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/service/getServiceStatus`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the service activation status of a Data Lake Formation user.
 *
 * @param request GetServiceStatusRequest
 * @return GetServiceStatusResponse
 */
async function getServiceStatus(request: GetServiceStatusRequest): GetServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceStatusWithOptions(request, headers, runtime);
}

model GetTableRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
}

model GetTableResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
  table?: Table(name='Table', description='The detailed information about the data table.'),
}

model GetTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTableResponseBody(name='body'),
}

/**
 * @summary Get detailed information about the data tables in the data lake.
 *
 * @param request GetTableRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTableResponse
 */
async function getTableWithOptions(request: GetTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get detailed information about the data tables in the data lake.
 *
 * @param request GetTableRequest
 * @return GetTableResponse
 */
async function getTable(request: GetTableRequest): GetTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableWithOptions(request, headers, runtime);
}

model GetTableColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  columnNames?: [ string ](name='ColumnNames', description='The list of fields in the data table.'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model GetTableColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  columnNamesShrink?: string(name='ColumnNames', description='The list of fields in the data table.'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model GetTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  columnStatisticsObjList?: [
    ColumnStatisticsObj
  ](name='ColumnStatisticsObjList', description='The list of field statistics.', example='[]'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   true and
*   false', example='true'),
}

model GetTableColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTableColumnStatisticsResponseBody(name='body'),
}

/**
 * @summary You can call this operation to obtain statistics about a specified field in a data table in a data lake.
 *
 * @param tmpReq GetTableColumnStatisticsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTableColumnStatisticsResponse
 */
async function getTableColumnStatisticsWithOptions(tmpReq: GetTableColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableColumnStatisticsResponse {
  Util.validateModel(tmpReq);
  var request = new GetTableColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.columnNamesShrink)) {
    query['ColumnNames'] = request.columnNamesShrink;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTableColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/columnstatistics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call this operation to obtain statistics about a specified field in a data table in a data lake.
 *
 * @param request GetTableColumnStatisticsRequest
 * @return GetTableColumnStatisticsResponse
 */
async function getTableColumnStatistics(request: GetTableColumnStatisticsRequest): GetTableColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableColumnStatisticsWithOptions(request, headers, runtime);
}

model GetTableProfileRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory. By default, the ID of the primary account is entered.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of the metadatabase.

This parameter is required.', example='exp_table'),
  tableName?: string(name='TableName', description='The name of the metadata table.

This parameter is required.', example='admin_user'),
}

model GetTableProfileResponseBody = {
  code?: string(name='Code', description='The error code.', example='OK'),
  message?: string(name='Message', description='The error message.', example='None'),
  requestId?: string(name='RequestId', description='The request ID.', example='C742A04F-F304-5440-9ED8-AD58C36D1915'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
  tableProfile?: TableProfile(name='TableProfile', description='Table Data Overview'),
}

model GetTableProfileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTableProfileResponseBody(name='body'),
}

/**
 * @summary Obtains the details of a table data profile.
 *
 * @description To use a data profile, you must first host the OSS bucket of the table.
 *
 * @param request GetTableProfileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTableProfileResponse
 */
async function getTableProfileWithOptions(request: GetTableProfileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableProfileResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTableProfile',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/metastorehouse/catalog/database/tableprofile`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the details of a table data profile.
 *
 * @description To use a data profile, you must first host the OSS bucket of the table.
 *
 * @param request GetTableProfileRequest
 * @return GetTableProfileResponse
 */
async function getTableProfile(request: GetTableProfileRequest): GetTableProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableProfileWithOptions(request, headers, runtime);
}

model GetTableVersionRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
  versionId?: int32(name='VersionId', description='The version number of the data table.', example='1'),
}

model GetTableVersionResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  tableVersion?: TableVersion(name='TableVersion', description='A data table with version information.', example='{"VersionId":123,"Table":{}}'),
}

model GetTableVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTableVersionResponseBody(name='body'),
}

/**
 * @summary Gets a specified version of a data table in the data lake.
 *
 * @param request GetTableVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTableVersionResponse
 */
async function getTableVersionWithOptions(request: GetTableVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableVersionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTableVersion',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Gets a specified version of a data table in the data lake.
 *
 * @param request GetTableVersionRequest
 * @return GetTableVersionResponse
 */
async function getTableVersion(request: GetTableVersionRequest): GetTableVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableVersionWithOptions(request, headers, runtime);
}

model GrantPermissionsRequest {
  accesses?: [ string ](name='Accesses', description='The list of authorized access items.

This parameter is required.'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.'),
  delegateAccesses?: [ string ](name='DelegateAccesses', description='The list of authorized access permissions.

This parameter is required.'),
  metaResource?: MetaResource(name='MetaResource', description='Authorize meta resources.

This parameter is required.'),
  principal?: Principal(name='Principal', description='Specify the authorized users or roles. The format of the name must meet the following requirements:

*   RAM user: acs:ram::[accountId]:user/[userName].
*   RAM role: acs:ram::[accountId]:role/[roleName].
*   Data Lake Role: acs:dlf::[accountId]:role/[roleName].

This parameter is required.'),
  type?: string(name='Type', description='The type of the authorization. Only Hive is supported.

This parameter is required.', example='Hive'),
}

model GrantPermissionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4912024D-2A06-5E9F-9667-35D9319917D7'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GrantPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GrantPermissionsResponseBody(name='body'),
}

/**
 * @summary Grant the operation permissions on resources to the User /Data Lake role.
 *
 * @param request GrantPermissionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantPermissionsResponse
 */
async function grantPermissionsWithOptions(request: GrantPermissionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GrantPermissionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accesses)) {
    body['Accesses'] = request.accesses;
  }
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.delegateAccesses)) {
    body['DelegateAccesses'] = request.delegateAccesses;
  }
  if (!Util.isUnset(request.metaResource)) {
    body['MetaResource'] = request.metaResource;
  }
  if (!Util.isUnset(request.principal)) {
    body['Principal'] = request.principal;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GrantPermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/grant`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Grant the operation permissions on resources to the User /Data Lake role.
 *
 * @param request GrantPermissionsRequest
 * @return GrantPermissionsResponse
 */
async function grantPermissions(request: GrantPermissionsRequest): GrantPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return grantPermissionsWithOptions(request, headers, runtime);
}

model GrantRoleToUsersRequest {
  roleName?: string(name='RoleName', description='The name of the role.', example='test_role_8'),
  users?: [
  Principal
](name='Users', description='Specify the authorized users or roles. The format of the name must meet the following requirements:

*   RAM user: acs:ram::[accountId]:user/[userName].
*   RAM role: acs:ram::[accountId]:role/[roleName].'),
}

model GrantRoleToUsersResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4316D7DA-9816-596D-A3D7-12676FA59BDA'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GrantRoleToUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GrantRoleToUsersResponseBody(name='body'),
}

/**
 * @summary Grant a Data Lake role to multiple users.
 *
 * @param request GrantRoleToUsersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantRoleToUsersResponse
 */
async function grantRoleToUsersWithOptions(request: GrantRoleToUsersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GrantRoleToUsersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.roleName)) {
    body['RoleName'] = request.roleName;
  }
  if (!Util.isUnset(request.users)) {
    body['Users'] = request.users;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GrantRoleToUsers',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/grantusers`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Grant a Data Lake role to multiple users.
 *
 * @param request GrantRoleToUsersRequest
 * @return GrantRoleToUsersResponse
 */
async function grantRoleToUsers(request: GrantRoleToUsersRequest): GrantRoleToUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return grantRoleToUsersWithOptions(request, headers, runtime);
}

model GrantRolesToUserRequest {
  roleNames?: [ string ](name='RoleNames', description='The list of role names to be authorized.

This parameter is required.'),
  user?: Principal(name='User', description='Specify the authorized users or roles. The format of the name must meet the following requirements:

RAM user: acs:ram::[accountId]:user/[userName].

RAM role: acs:ram::[accountId]:role/[roleName].

This parameter is required.'),
}

model GrantRolesToUserResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='81B90E1B-7514-5817-9D59-0EA9E2215876'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GrantRolesToUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GrantRolesToUserResponseBody(name='body'),
}

/**
 * @summary Grant multiple roles to a single user.
 *
 * @param request GrantRolesToUserRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantRolesToUserResponse
 */
async function grantRolesToUserWithOptions(request: GrantRolesToUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GrantRolesToUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.roleNames)) {
    body['RoleNames'] = request.roleNames;
  }
  if (!Util.isUnset(request.user)) {
    body['User'] = request.user;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GrantRolesToUser',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/grantroles`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Grant multiple roles to a single user.
 *
 * @param request GrantRolesToUserRequest
 * @return GrantRolesToUserResponse
 */
async function grantRolesToUser(request: GrantRolesToUserRequest): GrantRolesToUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return grantRolesToUserWithOptions(request, headers, runtime);
}

model ListCatalogsRequest {
  idPattern?: string(name='IdPattern', description='Regular matching of CatalogId', example='.*'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is returned from the returned result. If none is returned, an empty string or\\\\"\\\\"', example='‘’'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
}

model ListCatalogsResponseBody = {
  catalogs?: [
    Catalog
  ](name='Catalogs', description='Catalog list', example='[{"CatalogId":"xx"}]'),
  code?: string(name='Code', description='Status Code Description', example='OK'),
  message?: string(name='Message', description='The error message that is returned.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='Page Flip token', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the test feature is enabled.', example='true'),
}

model ListCatalogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCatalogsResponseBody(name='body'),
}

/**
 * @summary You can call this operation to query the list of metabase namespaces (catalogs).
 *
 * @param request ListCatalogsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCatalogsResponse
 */
async function listCatalogsWithOptions(request: ListCatalogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCatalogsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.idPattern)) {
    query['IdPattern'] = request.idPattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCatalogs',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call this operation to query the list of metabase namespaces (catalogs).
 *
 * @param request ListCatalogsRequest
 * @return ListCatalogsResponse
 */
async function listCatalogs(request: ListCatalogsRequest): ListCatalogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCatalogsWithOptions(request, headers, runtime);
}

model ListDatabasesRequest {
  catalogId?: string(name='CatalogId', description='The namespace of the database category. By default, the Uid of the primary account is entered.', example='1344371'),
  namePattern?: string(name='NamePattern', description='The regular expression used to match the database name. If all matches are specified, this parameter is specified. \\\\*', example='.*'),
  nextPageToken?: string(name='NextPageToken', description='The paging token, which is returned by the result. For example, you can specify "" for the first page.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa!'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
}

model ListDatabasesResponseBody = {
  code?: string(name='Code', description='Description', example='OK'),
  databases?: [
    Database
  ](name='Databases', description='The list of metadatabases.', example='[{"name":"test"}]'),
  message?: string(name='Message', description='The error message that is returned.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='Page Flip token', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='558D764F-8C55-49CA-BF38-80EA532FC08F'),
  success?: boolean(name='Success', description='Indicates whether the test feature is enabled.', example='true'),
}

model ListDatabasesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDatabasesResponseBody(name='body'),
}

/**
 * @summary Obtains a list of databases in the data lake and queries them by page. You can match them based on the database name.
 *
 * @param request ListDatabasesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDatabasesResponse
 */
async function listDatabasesWithOptions(request: ListDatabasesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDatabasesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.namePattern)) {
    query['NamePattern'] = request.namePattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDatabases',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a list of databases in the data lake and queries them by page. You can match them based on the database name.
 *
 * @param request ListDatabasesRequest
 * @return ListDatabasesResponse
 */
async function listDatabases(request: ListDatabasesRequest): ListDatabasesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDatabasesWithOptions(request, headers, runtime);
}

model ListFunctionNamesRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  functionNamePattern?: string(name='FunctionNamePattern', description='The regular expression that matches the function name.', example='.*'),
  nextPageToken?: string(name='NextPageToken', description='The pagination token, which is returned from the returned result. If none is returned, an empty string or \\\\"\\\\"is passed.', example='\\\\"\\\\"'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum value is 1000.', example='10'),
}

model ListFunctionNamesResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  functionNames?: [ string ](name='FunctionNames', description='The list of function names.'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model ListFunctionNamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionNamesResponseBody(name='body'),
}

/**
 * @summary Paged query to obtain the list of function names of the database.
 *
 * @param request ListFunctionNamesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFunctionNamesResponse
 */
async function listFunctionNamesWithOptions(request: ListFunctionNamesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionNamesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionNamePattern)) {
    query['FunctionNamePattern'] = request.functionNamePattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctionNames',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions/names`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Paged query to obtain the list of function names of the database.
 *
 * @param request ListFunctionNamesRequest
 * @return ListFunctionNamesResponse
 */
async function listFunctionNames(request: ListFunctionNamesRequest): ListFunctionNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionNamesWithOptions(request, headers, runtime);
}

model ListFunctionsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  functionNamePattern?: string(name='FunctionNamePattern', description='The regular match expression for the user-defined function name.', example='.*'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data. If not provided in the response result, a string ("") or empty string (") is empty string.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum value is 1000.', example='10'),
}

model ListFunctionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  functions?: [
    Function
  ](name='Functions', description='Details of the functions.'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model ListFunctionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionsResponseBody(name='body'),
}

/**
 * @summary Obtains a list of user-defined functions for databases in the data lake in bulk.
 *
 * @param request ListFunctionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFunctionsResponse
 */
async function listFunctionsWithOptions(request: ListFunctionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionNamePattern)) {
    query['FunctionNamePattern'] = request.functionNamePattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a list of user-defined functions for databases in the data lake in bulk.
 *
 * @param request ListFunctionsRequest
 * @return ListFunctionsResponse
 */
async function listFunctions(request: ListFunctionsRequest): ListFunctionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionsWithOptions(request, headers, runtime);
}

model ListPartitionNamesRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  nextPageToken?: string(name='NextPageToken', description='The pagination token, which is returned from the returned result. If none is returned, an empty string or \\\\"\\\\"is passed.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum value is 1000.', example='10'),
  partialPartValues?: [ string ](name='PartialPartValues', description='The list of partition values. You can specify only the values of some partitions. Partition names of all lower-level partitions are queried.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
}

model ListPartitionNamesResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  partitionNames?: [ string ](name='PartitionNames', description='The list of partition names.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model ListPartitionNamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPartitionNamesResponseBody(name='body'),
}

/**
 * @summary You can call this operation to obtain a list of partition names of data tables in a data lake. This method is usually used for multi-level partitioning.
 *
 * @param request ListPartitionNamesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPartitionNamesResponse
 */
async function listPartitionNamesWithOptions(request: ListPartitionNamesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPartitionNamesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    body['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.partialPartValues)) {
    body['PartialPartValues'] = request.partialPartValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPartitionNames',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/names`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call this operation to obtain a list of partition names of data tables in a data lake. This method is usually used for multi-level partitioning.
 *
 * @param request ListPartitionNamesRequest
 * @return ListPartitionNamesResponse
 */
async function listPartitionNames(request: ListPartitionNamesRequest): ListPartitionNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionNamesWithOptions(request, headers, runtime);
}

model ListPartitionsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  isShareSd?: boolean(name='IsShareSd', description='Whether to share the column information in the SD in the partition. Valid values:

*   true: shares the partition columns information in the SD. In this way, only one copy of data is returned for the same columns. This reduces network transmission and improves the performance of this interface.
*   false: does not share the data.', example='true'),
  nextPageToken?: string(name='NextPageToken', description='The pagination token, which is returned from the returned result. If none is returned, an empty string or \\\\"\\\\"is passed.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum value is 1000.', example='10'),
  partialPartValues?: [ string ](name='PartialPartValues', description='The list of partition values. You can specify only the values of some partitions. Partition names of all lower-level partitions are queried.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
}

model ListPartitionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs', description='The list of partition specifications.'),
  partitions?: [
    Partition
  ](name='Partitions', description='The list of partition details.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model ListPartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPartitionsResponseBody(name='body'),
}

/**
 * @summary Obtains a list of database partition details in the data lake.
 *
 * @param request ListPartitionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPartitionsResponse
 */
async function listPartitionsWithOptions(request: ListPartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.isShareSd)) {
    body['IsShareSd'] = request.isShareSd;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    body['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.partialPartValues)) {
    body['PartialPartValues'] = request.partialPartValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a list of database partition details in the data lake.
 *
 * @param request ListPartitionsRequest
 * @return ListPartitionsResponse
 */
async function listPartitions(request: ListPartitionsRequest): ListPartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionsWithOptions(request, headers, runtime);
}

model ListPartitionsByExprResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Obtains a list of data table partitions in the data lake and queries them by condition.
 *
 * @description You cannot specify expr to filter partitions. Currently, you need to call the listpartitionsbyfilter to complete the corresponding function.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPartitionsByExprResponse
 */
async function listPartitionsByExprWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListPartitionsByExprResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListPartitionsByExpr',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/listbyexpr`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a list of data table partitions in the data lake and queries them by condition.
 *
 * @description You cannot specify expr to filter partitions. Currently, you need to call the listpartitionsbyfilter to complete the corresponding function.
 *
 * @return ListPartitionsByExprResponse
 */
async function listPartitionsByExpr(): ListPartitionsByExprResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionsByExprWithOptions(headers, runtime);
}

model ListPartitionsByFilterRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  filter?: string(name='Filter', description='The expression of the query condition. The following operators are supported:

*   Comparison operators: =, <>, ! =, <, <=, >, >=. For example: ds > 20240101.
*   Logical operators: AND, OR, and NOT. Example: ds like \\\\"20240%\\\\".
*   BETWEEN operator: specifies a range. For example: ds BETWEEN 20240101 AND 20241201.
*   IN operator: Used to specify a specific set of values. Example: ds IN (20240101, 20240102).', example='ds>20201201'),
  isShareSd?: boolean(name='IsShareSd', description='Specifies whether to share the column information in the SD of the partition. Valid values:

*   true: shared
*   false: does not share the data.', example='true'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data. If not provided in the response result, a string ("") or empty string (") is empty string.', example='\\\\"\\\\"'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum size is 1000.', example='10'),
  tableName?: string(name='TableName', description='Indicates the name of the table.', example='test_table_20200715162543389'),
}

model ListPartitionsByFilterResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs', description='The list of partition specifications.'),
  partitions?: [
    Partition
  ](name='Partitions', description='The list of partition details after query.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model ListPartitionsByFilterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPartitionsByFilterResponseBody(name='body'),
}

/**
 * @summary Obtain the list of data table partitions in the data lake and query them by filter condition.
 *
 * @param request ListPartitionsByFilterRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPartitionsByFilterResponse
 */
async function listPartitionsByFilterWithOptions(request: ListPartitionsByFilterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPartitionsByFilterResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.filter)) {
    body['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.isShareSd)) {
    body['IsShareSd'] = request.isShareSd;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    body['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPartitionsByFilter',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/listbyfilter`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtain the list of data table partitions in the data lake and query them by filter condition.
 *
 * @param request ListPartitionsByFilterRequest
 * @return ListPartitionsByFilterResponse
 */
async function listPartitionsByFilter(request: ListPartitionsByFilterRequest): ListPartitionsByFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionsByFilterWithOptions(request, headers, runtime);
}

model ListPartitionsProfileRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory. By default, the ID of the primary account is entered.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of the metadatabase.

This parameter is required.', example='test_db'),
  pageNumber?: int32(name='PageNumber', description='Page number', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  partitionNames?: [ string ](name='PartitionNames', description='The names of partitions.'),
  tableName?: string(name='TableName', description='The name of the metadata table.', example='test_tbl'),
}

model ListPartitionsProfileShrinkRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory. By default, the ID of the primary account is entered.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of the metadatabase.

This parameter is required.', example='test_db'),
  pageNumber?: int32(name='PageNumber', description='Page number', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  partitionNamesShrink?: string(name='PartitionNames', description='The names of partitions.'),
  tableName?: string(name='TableName', description='The name of the metadata table.', example='test_tbl'),
}

model ListPartitionsProfileResponseBody = {
  code?: string(name='Code', description='The error code.', example='-'),
  data?: [
    PartitionProfile
  ](name='Data', description='List of partition data profiles'),
  latestAccessNumDate?: string(name='LatestAccessNumDate', description='The time when the access frequency is updated. This parameter is obsolete.', example='-'),
  latestDate?: string(name='LatestDate', description='The time when the metadata warehouse was updated.', example='2023-08-30 19:16:10'),
  message?: string(name='Message', description='The error message.', example='-'),
  requestId?: string(name='RequestId', description='The request ID.', example='97434FA4-A6B2-1AE4-A174-76964F29C759'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
  total?: int32(name='Total', description='The total number of entries returned.', example='10'),
}

model ListPartitionsProfileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPartitionsProfileResponseBody(name='body'),
}

/**
 * @summary Obtains the details of a partition data profile.
 *
 * @description To use a data profile, you must first host the OSS bucket of the table.
 *
 * @param tmpReq ListPartitionsProfileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPartitionsProfileResponse
 */
async function listPartitionsProfileWithOptions(tmpReq: ListPartitionsProfileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPartitionsProfileResponse {
  Util.validateModel(tmpReq);
  var request = new ListPartitionsProfileShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.partitionNames)) {
    request.partitionNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.partitionNames, 'PartitionNames', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.partitionNamesShrink)) {
    query['PartitionNames'] = request.partitionNamesShrink;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPartitionsProfile',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/metastorehouse/catalog/database/tableprofile/partitionprofile/listPartitionsProfile`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the details of a partition data profile.
 *
 * @description To use a data profile, you must first host the OSS bucket of the table.
 *
 * @param request ListPartitionsProfileRequest
 * @return ListPartitionsProfileResponse
 */
async function listPartitionsProfile(request: ListPartitionsProfileRequest): ListPartitionsProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionsProfileWithOptions(request, headers, runtime);
}

model ListPermissionsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  isListUserRolePermissions?: boolean(name='IsListUserRolePermissions', description='Specifies whether to obtain the permissions of the role to which the user belongs. This field takes effect only when you specify a specific resource object.', example='false'),
  metaResource?: MetaResource(name='MetaResource', description='Filters permission information based on resources.'),
  metaResourceType?: string(name='MetaResourceType', description='Specifies the type of resource to filter, such as database or table. If not specified, both are included.', example='DATABASE'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data. If not provided in the response result, a string ("") or empty string (") is empty string.', example='token!'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum value is 1000.', example='100'),
  principal?: Principal(name='Principal', description='Filters permission information based on the principal.'),
  type?: string(name='Type', description='The type for obtaining permission information. Currently, only Hive is supported.

This parameter is required.', example='Hive'),
}

model ListPermissionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='token!'),
  principalResourcePermissionsList?: [
  PrincipalResourcePermissions
](name='PrincipalResourcePermissionsList', description='The permissions.', example='[]'),
  requestId?: string(name='RequestId', description='The request ID.', example='745EAAE2-5010-5C9F-A95C-B8FC5C1B03BF'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.'),
}

model ListPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPermissionsResponseBody(name='body'),
}

/**
 * @summary Queries permissions.
 *
 * @param request ListPermissionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPermissionsResponse
 */
async function listPermissionsWithOptions(request: ListPermissionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPermissionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.isListUserRolePermissions)) {
    body['IsListUserRolePermissions'] = request.isListUserRolePermissions;
  }
  if (!Util.isUnset(request.metaResource)) {
    body['MetaResource'] = request.metaResource;
  }
  if (!Util.isUnset(request.metaResourceType)) {
    body['MetaResourceType'] = request.metaResourceType;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    body['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.principal)) {
    body['Principal'] = request.principal;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries permissions.
 *
 * @param request ListPermissionsRequest
 * @return ListPermissionsResponse
 */
async function listPermissions(request: ListPermissionsRequest): ListPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPermissionsWithOptions(request, headers, runtime);
}

model ListRoleUsersRequest {
  nextPageToken?: string(name='NextPageToken', description='The pagination token, which is returned from the returned result. If none is returned, an empty string or \\\\"\\\\"is passed.', example='token!'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum value is 1000.', example='-1/100'),
  roleName?: string(name='RoleName', description='The name of the role.', example='admin'),
  userNamePattern?: string(name='UserNamePattern', description='The regular expression that matches the user name.', example='.*user.*'),
}

model ListRoleUsersResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='token!'),
  requestId?: string(name='RequestId', description='The request ID.', example='558D764F-8C55-49CA-BF38-80EA532FC08F'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  userRoles?: [
  UserRole
](name='UserRoles', description='The roles assigned to the user.'),
}

model ListRoleUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRoleUsersResponseBody(name='body'),
}

/**
 * @summary Gets the list of users for a single role.
 *
 * @param request ListRoleUsersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRoleUsersResponse
 */
async function listRoleUsersWithOptions(request: ListRoleUsersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRoleUsersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.roleName)) {
    query['RoleName'] = request.roleName;
  }
  if (!Util.isUnset(request.userNamePattern)) {
    query['UserNamePattern'] = request.userNamePattern;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRoleUsers',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/roleusers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Gets the list of users for a single role.
 *
 * @param request ListRoleUsersRequest
 * @return ListRoleUsersResponse
 */
async function listRoleUsers(request: ListRoleUsersRequest): ListRoleUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRoleUsersWithOptions(request, headers, runtime);
}

model ListRolesRequest {
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data. If not provided in the response result, a string ("") or empty string (") is empty string.', example='token!'),
  pageSize?: int32(name='PageSize', description='the number of entries returned on each page, the maximum value is 1000.', example='-1/100'),
  roleNamePattern?: string(name='RoleNamePattern', description='The regular expression that matches the role name. Fuzzy search is supported, such as.\\\\*test.\\\\*.', example='.*test.*'),
}

model ListRolesResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  roles?: [
  Role
](name='Roles', description='The list of roles.', example='[
	{
		"Description":"reserved by the system",
		"DisplayName":"admin",
		"UpdateTime":0,
		"IsPredefined":1,
		"Name":"admin"
	}
]'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false.', example='True'),
}

model ListRolesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRolesResponseBody(name='body'),
}

/**
 * @summary You can query the list of data lake roles.
 *
 * @param request ListRolesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRolesResponse
 */
async function listRolesWithOptions(request: ListRolesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRolesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.roleNamePattern)) {
    query['RoleNamePattern'] = request.roleNamePattern;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRoles',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can query the list of data lake roles.
 *
 * @param request ListRolesRequest
 * @return ListRolesResponse
 */
async function listRoles(request: ListRolesRequest): ListRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRolesWithOptions(request, headers, runtime);
}

model ListTableNamesRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  nextPageToken?: string(name='NextPageToken', description='The pagination token, which is returned from the returned result. If none is returned, an empty string or \\\\"\\\\"is passed.', example='\\\\"\\\\"'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  tableNamePattern?: string(name='TableNamePattern', description='The data table name matches the regular expression.', example='.*'),
  tableType?: string(name='TableType', description='The type of the data table. Valid values:

MANAGED_TABLE: internal table

EXTERNAL_TABLE: foreign table

VIRTUAL_VIEW: virtual view

INDEX_TABLE: index table

MATERIALIZED_VIEW: materialized view.', example='MANAGED_TABLE'),
}

model ListTableNamesResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
  tableNames?: [ string ](name='TableNames', description='The names of the data tables.'),
}

model ListTableNamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTableNamesResponseBody(name='body'),
}

/**
 * @summary This function is used only to query the names of data tables in Data Lake.
 *
 * @param request ListTableNamesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTableNamesResponse
 */
async function listTableNamesWithOptions(request: ListTableNamesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTableNamesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tableNamePattern)) {
    query['TableNamePattern'] = request.tableNamePattern;
  }
  if (!Util.isUnset(request.tableType)) {
    query['TableType'] = request.tableType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTableNames',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/names`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary This function is used only to query the names of data tables in Data Lake.
 *
 * @param request ListTableNamesRequest
 * @return ListTableNamesResponse
 */
async function listTableNames(request: ListTableNamesRequest): ListTableNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTableNamesWithOptions(request, headers, runtime);
}

model ListTableVersionsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data. If not provided in the response result, a string ("") or empty string (") is empty string.', example='\\\\"\\\\"'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum value is 1000.', example='10'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
}

model ListTableVersionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
  tableVersions?: [
    TableVersion
  ](name='TableVersions', description='List of data tables with versions.'),
}

model ListTableVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTableVersionsResponseBody(name='body'),
}

/**
 * @summary Queries the list of specified versions of data tables in a data lake by page.
 *
 * @param request ListTableVersionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTableVersionsResponse
 */
async function listTableVersionsWithOptions(request: ListTableVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTableVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTableVersions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/versions/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the list of specified versions of data tables in a data lake by page.
 *
 * @param request ListTableVersionsRequest
 * @return ListTableVersionsResponse
 */
async function listTableVersions(request: ListTableVersionsRequest): ListTableVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTableVersionsWithOptions(request, headers, runtime);
}

model ListTablesRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  nextPageToken?: string(name='NextPageToken', description='The pagination token, which is returned from the returned result. If none is returned, an empty string or \\\\"\\\\"is passed.', example='\\\\"\\\\"'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  tableNamePattern?: string(name='TableNamePattern', description='The name of the data table, which is matched by a regular expression.', example='.*'),
  tableType?: string(name='TableType', description='The type of the data table. Valid values:

*   MANAGED_TABLE: internal table
*   EXTERNAL_TABLE: foreign table
*   VIRTUAL_VIEW: virtual view
*   INDEX_TABLE: index table
*   MATERIALIZED_VIEW: materialized view.', example='MANAGED_TABLE'),
}

model ListTablesResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  tables?: [
    Table
  ](name='Tables', description='The list of data tables.', example='[{"TableName":"xx"}]'),
}

model ListTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTablesResponseBody(name='body'),
}

/**
 * @summary You can call this operation to obtain a list of data tables in the data lake.
 *
 * @param request ListTablesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTablesResponse
 */
async function listTablesWithOptions(request: ListTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTablesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tableNamePattern)) {
    query['TableNamePattern'] = request.tableNamePattern;
  }
  if (!Util.isUnset(request.tableType)) {
    query['TableType'] = request.tableType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/databases/tables/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call this operation to obtain a list of data tables in the data lake.
 *
 * @param request ListTablesRequest
 * @return ListTablesResponse
 */
async function listTables(request: ListTablesRequest): ListTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTablesWithOptions(request, headers, runtime);
}

model ListUserRolesRequest {
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data. If not provided in the response result, a string ("") or empty string (") is empty string.', example='token!'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum value is 1000.', example='-1/100'),
  principalArn?: string(name='PrincipalArn', description='Used to uniquely identify a RAM user or RAM role. The OSS URL is in the following format:

*   RAM user: acs:ram::[accountId]:user/[userName].
*   RAM role: acs:ram::[accountId]:role/[roleName].', example='acs:ram::1111:user/userName'),
  roleNamePattern?: string(name='RoleNamePattern', description='The regular expression that matches the role name. Fuzzy search is supported.', example='.*test.*'),
}

model ListUserRolesResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  userRoles?: [
  UserRole
](name='UserRoles', description='The roles assigned to the user.'),
}

model ListUserRolesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserRolesResponseBody(name='body'),
}

/**
 * @summary Obtains the list of data lake roles for a single user.
 *
 * @param request ListUserRolesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUserRolesResponse
 */
async function listUserRolesWithOptions(request: ListUserRolesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListUserRolesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.principalArn)) {
    query['PrincipalArn'] = request.principalArn;
  }
  if (!Util.isUnset(request.roleNamePattern)) {
    query['RoleNamePattern'] = request.roleNamePattern;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserRoles',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/userroles`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the list of data lake roles for a single user.
 *
 * @param request ListUserRolesRequest
 * @return ListUserRolesResponse
 */
async function listUserRoles(request: ListUserRolesRequest): ListUserRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUserRolesWithOptions(request, headers, runtime);
}

model RefreshLockRequest {
  lockId?: long(name='LockId', description='The lock ID.', example='12324'),
}

model RefreshLockResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The returned message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='81B90E1B-7514-5817-9D59-0EA9E2215876'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false.', example='True'),
}

model RefreshLockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RefreshLockResponseBody(name='body'),
}

/**
 * @summary Refreshes the specified metadata lock.
 *
 * @param request RefreshLockRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshLockResponse
 */
async function refreshLockWithOptions(request: RefreshLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RefreshLockResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lockId)) {
    query['LockId'] = request.lockId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Refreshes the specified metadata lock.
 *
 * @param request RefreshLockRequest
 * @return RefreshLockResponse
 */
async function refreshLock(request: RefreshLockRequest): RefreshLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return refreshLockWithOptions(request, headers, runtime);
}

model RegisterLocationRequest {
  inventoryCollectEnabled?: boolean(name='InventoryCollectEnabled', description='Whether to enable OSS bucket inventory', example='true'),
  location?: string(name='Location', description='Registered OSS path

This parameter is required.', example='oss://mybucket/'),
  ossLogCollectEnabled?: boolean(name='OssLogCollectEnabled', description='Whether to enable OSS log storage', example='true'),
  roleName?: string(name='RoleName', description='RAM role name

>  Data Lake Formation read and write data in the OSS path. If you want to AliyunDLFWorkFlowDefaultRole a role, the role is automatically built in to the role. Alternatively, you can create a custom role, but you must manually ensure that the role has the read and write permissions on the corresponding path.

This parameter is required.', example='AliyunDLFWorkFlowDefaultRole'),
}

model RegisterLocationResponseBody = {
  data?: {
    locationId?: string(name='LocationId', description='Location ID', example='LOC-AB8FBC17F95A4AF5'),
    storageCollectTaskOperationResultList?: [
      StorageCollectTaskOperationResult
    ](name='StorageCollectTaskOperationResultList', description='Enable the result list of the collection task'),
  }(name='Data', description='The response parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='3C2678BA-3451-14C3-90E2-D4EF5B4E7A84'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true.
*   false: The request failed.', example='true'),
}

model RegisterLocationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RegisterLocationResponseBody(name='body'),
}

/**
 * @summary Register the OSS path to be managed by DLF.
 *
 * @param request RegisterLocationRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RegisterLocationResponse
 */
async function registerLocationWithOptions(request: RegisterLocationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RegisterLocationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.inventoryCollectEnabled)) {
    body['InventoryCollectEnabled'] = request.inventoryCollectEnabled;
  }
  if (!Util.isUnset(request.location)) {
    body['Location'] = request.location;
  }
  if (!Util.isUnset(request.ossLogCollectEnabled)) {
    body['OssLogCollectEnabled'] = request.ossLogCollectEnabled;
  }
  if (!Util.isUnset(request.roleName)) {
    body['RoleName'] = request.roleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RegisterLocation',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/locations`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Register the OSS path to be managed by DLF.
 *
 * @param request RegisterLocationRequest
 * @return RegisterLocationResponse
 */
async function registerLocation(request: RegisterLocationRequest): RegisterLocationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return registerLocationWithOptions(request, headers, runtime);
}

model RenamePartitionRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  partitionInput?: PartitionInput(name='PartitionInput', description='The updated partition information, which is the same as the CreatePartition.'),
  partitionValues?: [ string ](name='PartitionValues', description='The value in a partition key column.'),
  tableName?: string(name='TableName', description='Indicates the name of the table.', example='test_table_20200715162543389'),
}

model RenamePartitionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model RenamePartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenamePartitionResponseBody(name='body'),
}

/**
 * @summary Update the partition name of the data table in the data lake.
 *
 * @param request RenamePartitionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RenamePartitionResponse
 */
async function renamePartitionWithOptions(request: RenamePartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenamePartitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionInput)) {
    body['PartitionInput'] = request.partitionInput;
  }
  if (!Util.isUnset(request.partitionValues)) {
    body['PartitionValues'] = request.partitionValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RenamePartition',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/rename`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update the partition name of the data table in the data lake.
 *
 * @param request RenamePartitionRequest
 * @return RenamePartitionResponse
 */
async function renamePartition(request: RenamePartitionRequest): RenamePartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renamePartitionWithOptions(request, headers, runtime);
}

model RenameTableRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  isAsync?: boolean(name='IsAsync', description='Whether to synchronize the update. Valid values:

*   false (default): indicates that the operation is called synchronously. The operation returns results only when the background task is completed. Then the risk of false is that the interface will time out if the background task needs to be done very long.
*   true: The API operation is called asynchronously and does not wait for the background task to be returned. The response contains a taskid. In this way, the client can query the status of the task by using the taskid.', example='false'),
  tableInput?: TableInput(name='TableInput', description='The data table object. Note that you only need to enter TableName.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model RenameTableResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request is successful.
*   false', example='true'),
  taskId?: string(name='TaskId', description='The ID of the asynchronous task.', example='c38206c3aca0c41332ffe49294243009'),
}

model RenameTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenameTableResponseBody(name='body'),
}

/**
 * @summary is used only to update the name of a data table in the data lake.
 *
 * @param request RenameTableRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RenameTableResponse
 */
async function renameTableWithOptions(request: RenameTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenameTableResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.isAsync)) {
    body['IsAsync'] = request.isAsync;
  }
  if (!Util.isUnset(request.tableInput)) {
    body['TableInput'] = request.tableInput;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RenameTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/rename`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary is used only to update the name of a data table in the data lake.
 *
 * @param request RenameTableRequest
 * @return RenameTableResponse
 */
async function renameTable(request: RenameTableRequest): RenameTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renameTableWithOptions(request, headers, runtime);
}

model RevokePermissionsRequest {
  accesses?: [ string ](name='Accesses', description='The list of access items for which you want to revoke authorization.

This parameter is required.'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  delegateAccesses?: [ string ](name='DelegateAccesses', description='The list of grantable access items that are not supported.'),
  metaResource?: MetaResource(name='MetaResource', description='Cancels authorization on a meta resource.

This parameter is required.'),
  principal?: Principal(name='Principal', description='Cancels authorization for a user or role. The format of the name must meet the following requirements:

*   RAM user: acs:ram::[accountId]:user/[userName].
*   RAM role: acs:ram::[accountId]:role/[roleName].
*   Data Lake Role: acs:dlf::[accountId]:role/[roleName].

This parameter is required.'),
  type?: string(name='Type', description='The type of the authorization to cancel. Currently, only Hive is supported.

This parameter is required.', example='Hive'),
}

model RevokePermissionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The returned message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7CB5765C-F209-5B10-8792-D2BE9156ABE8'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model RevokePermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokePermissionsResponseBody(name='body'),
}

/**
 * @summary Cancels the operation permissions on resources granted to a User /Data Lake role.
 *
 * @param request RevokePermissionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokePermissionsResponse
 */
async function revokePermissionsWithOptions(request: RevokePermissionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RevokePermissionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accesses)) {
    body['Accesses'] = request.accesses;
  }
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.delegateAccesses)) {
    body['DelegateAccesses'] = request.delegateAccesses;
  }
  if (!Util.isUnset(request.metaResource)) {
    body['MetaResource'] = request.metaResource;
  }
  if (!Util.isUnset(request.principal)) {
    body['Principal'] = request.principal;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RevokePermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/revoke`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Cancels the operation permissions on resources granted to a User /Data Lake role.
 *
 * @param request RevokePermissionsRequest
 * @return RevokePermissionsResponse
 */
async function revokePermissions(request: RevokePermissionsRequest): RevokePermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return revokePermissionsWithOptions(request, headers, runtime);
}

model RevokeRoleFromUsersRequest {
  roleName?: string(name='RoleName', description='The role to be removed.', example='test_role_3'),
  users?: [
  Principal
](name='Users', description='The list of users or roles to be removed. The format of the name must meet the following requirements:

*   RAM user: acs:ram::[accountId]:user/[userName].
*   RAM role: acs:ram::[accountId]:role/[roleName].'),
}

model RevokeRoleFromUsersResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model RevokeRoleFromUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokeRoleFromUsersResponseBody(name='body'),
}

/**
 * @summary Removes multiple users from a single data lake role.
 *
 * @param request RevokeRoleFromUsersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokeRoleFromUsersResponse
 */
async function revokeRoleFromUsersWithOptions(request: RevokeRoleFromUsersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RevokeRoleFromUsersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.roleName)) {
    body['RoleName'] = request.roleName;
  }
  if (!Util.isUnset(request.users)) {
    body['Users'] = request.users;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RevokeRoleFromUsers',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/revokeusers`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Removes multiple users from a single data lake role.
 *
 * @param request RevokeRoleFromUsersRequest
 * @return RevokeRoleFromUsersResponse
 */
async function revokeRoleFromUsers(request: RevokeRoleFromUsersRequest): RevokeRoleFromUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return revokeRoleFromUsersWithOptions(request, headers, runtime);
}

model RevokeRolesFromUserRequest {
  roleNames?: [ string ](name='RoleNames', description='The list of roles to be deleted.

This parameter is required.'),
  user?: Principal(name='User', description='Remove the user /role. The format of the name must meet the following requirements:

*   RAM user: acs:ram::[accountId]:user/[userName].
*   RAM role: acs:ram::[accountId]:role/[roleName].

This parameter is required.'),
}

model RevokeRolesFromUserResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model RevokeRolesFromUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokeRolesFromUserResponseBody(name='body'),
}

/**
 * @summary Removes multiple roles from a single user.
 *
 * @param request RevokeRolesFromUserRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokeRolesFromUserResponse
 */
async function revokeRolesFromUserWithOptions(request: RevokeRolesFromUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RevokeRolesFromUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.roleNames)) {
    body['RoleNames'] = request.roleNames;
  }
  if (!Util.isUnset(request.user)) {
    body['User'] = request.user;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RevokeRolesFromUser',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/revokeroles`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Removes multiple roles from a single user.
 *
 * @param request RevokeRolesFromUserRequest
 * @return RevokeRolesFromUserResponse
 */
async function revokeRolesFromUser(request: RevokeRolesFromUserRequest): RevokeRolesFromUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return revokeRolesFromUserWithOptions(request, headers, runtime);
}

model RunMigrationWorkflowRequest {
  instanceId?: string(name='InstanceId', description='The ID of the migration instance.

This parameter is required.', example='M-EDD8BF959BB97345'),
}

model RunMigrationWorkflowResponseBody = {
  data?: string(name='Data', description='The returned data. The value is the ID of the workflow instance.', example='FI-7193B85809CAD95C'),
  requestId?: string(name='RequestId', description='The request ID.', example='A048EA8E-3519-5B18-B81E-EE3E0B6DBE0C'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model RunMigrationWorkflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RunMigrationWorkflowResponseBody(name='body'),
}

/**
 * @summary Run the metadata migration task.
 *
 * @param request RunMigrationWorkflowRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RunMigrationWorkflowResponse
 */
async function runMigrationWorkflowWithOptions(request: RunMigrationWorkflowRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RunMigrationWorkflowResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RunMigrationWorkflow',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/migration/workflow/run`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Run the metadata migration task.
 *
 * @param request RunMigrationWorkflowRequest
 * @return RunMigrationWorkflowResponse
 */
async function runMigrationWorkflow(request: RunMigrationWorkflowRequest): RunMigrationWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return runMigrationWorkflowWithOptions(request, headers, runtime);
}

model SearchRequest {
  catalogId?: string(name='CatalogId', description='catalogid', example='默认是空，在多catalogid下填写对应的id'),
  pageNumber?: long(name='PageNumber', description='Page number of the current query', example='1'),
  pageSize?: long(name='PageSize', description='Page size of the current query', example='1000'),
  searchText?: string(name='SearchText', description='Search-related Issue', example='tags:tag1 or comment:^iso and name=aliyun and (createTime > "20211111" and createTime < "20211117") and has category'),
  searchType?: string(name='SearchType', description='Search Type', example='TABLE/DATABASE/CATALOG'),
  sortCriteria?: [
    SortCriterion
  ](name='SortCriteria', description='Sorting structure'),
}

model SearchResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  databaseResult?: {
    databases?: [ 
      {
        database?: Database(name='Database', description='Returned Database'),
        highLightList?: [
          HighLight
        ](name='HighLightList', description='Return highlighted text'),
      }
    ](name='Databases', description='Returned DatabaseList'),
    totalCount?: long(name='TotalCount', description='Total number of databases that meet the match conditions', example='11000'),
  }(name='DatabaseResult', description='The returned db result.'),
  message?: string(name='Message', description='Response', example='""'),
  requestId?: string(name='RequestId', description='The request ID.', example='460C862F-BB91-5C04-BC3F-946EEF467862'),
  success?: boolean(name='Success', description='Indicates whether the information about the service was queried.', example='True'),
  tableResult?: {
    tables?: [ 
      {
        highLightList?: [
          HighLight
        ](name='HighLightList', description='Returned highlighted text'),
        table?: Table(name='Table', description='Returned Table'),
      }
    ](name='Tables', description='Returned TableList'),
    totalCount?: long(name='TotalCount', description='The total number of tables that meet the match conditions.', example='1100'),
  }(name='TableResult', description='The returned table result.'),
}

model SearchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchResponseBody(name='body'),
}

/**
 * @summary Metadata retrieval.
 *
 * @description Metadata search
 *
 * @param request SearchRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchResponse
 */
async function searchWithOptions(request: SearchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchText)) {
    body['SearchText'] = request.searchText;
  }
  if (!Util.isUnset(request.searchType)) {
    body['SearchType'] = request.searchType;
  }
  if (!Util.isUnset(request.sortCriteria)) {
    body['SortCriteria'] = request.sortCriteria;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'Search',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Metadata retrieval.
 *
 * @description Metadata search
 *
 * @param request SearchRequest
 * @return SearchResponse
 */
async function search(request: SearchRequest): SearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchWithOptions(request, headers, runtime);
}

model SearchAcrossCatalogRequest {
  catalogIds?: [ string ](name='CatalogIds', description='The array of CatalogId. If this parameter is empty, all catalogs are searched.'),
  pageNumber?: long(name='PageNumber', description='Page number of the current query', example='1'),
  pageSize?: long(name='PageSize', description='Page size of the current query', example='1000'),
  searchText?: string(name='SearchText', description='Search-related Issue', example='tags:tag1 or comment:^iso and name=aliyun and (createTime > "20211111" and createTime < "20211117") and has category'),
  searchTypes?: [ string ](name='SearchTypes', description='The SearchTypes array. The value can be ALL, CATALOG, DATABASE, or TABLE.'),
  sortCriteria?: [
    SortCriterion
  ](name='SortCriteria', description='Sorting structure'),
}

model SearchAcrossCatalogResponseBody = {
  catalogResult?: {
    catalogs?: [ 
      {
        catalog?: Catalog(name='Catalog', description='Catalog details'),
        highLightList?: [
          HighLight
        ](name='HighLightList', description='Return highlighted text'),
      }
    ](name='Catalogs', description='Catalog details'),
    totalCount?: long(name='TotalCount', description='Total number of catalogs that meet the match conditions', example='100'),
  }(name='CatalogResult', description='Returned Catalog result'),
  code?: string(name='Code', description='The response code.', example='OK'),
  databaseResult?: {
    databases?: [ 
      {
        database?: Database(name='Database', description='Returned Database'),
        highLightList?: [
          HighLight
        ](name='HighLightList', description='Return highlighted text'),
      }
    ](name='Databases', description='Returned DatabaseList'),
    totalCount?: long(name='TotalCount', description='Total number of databases that meet the match conditions', example='11000'),
  }(name='DatabaseResult', description='The returned db result.'),
  message?: string(name='Message', description='Response', example='""'),
  requestId?: string(name='RequestId', description='The request ID.', example='460C862F-BB91-5C04-BC3F-946EEF467862'),
  success?: boolean(name='Success', description='Indicates whether the information about the service was queried.', example='True'),
  tableResult?: {
    tables?: [ 
      {
        highLightList?: [
          HighLight
        ](name='HighLightList', description='Returned highlighted text'),
        table?: Table(name='Table', description='Returned Table'),
      }
    ](name='Tables', description='Returned TableList'),
    totalCount?: long(name='TotalCount', description='The total number of tables that meet the match conditions.', example='1100'),
  }(name='TableResult', description='The returned table result.'),
}

model SearchAcrossCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchAcrossCatalogResponseBody(name='body'),
}

/**
 * @summary Search across catalogs for content such as libraries, tables, and fields.
 *
 * @param request SearchAcrossCatalogRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchAcrossCatalogResponse
 */
async function searchAcrossCatalogWithOptions(request: SearchAcrossCatalogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchAcrossCatalogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogIds)) {
    body['CatalogIds'] = request.catalogIds;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchText)) {
    body['SearchText'] = request.searchText;
  }
  if (!Util.isUnset(request.searchTypes)) {
    body['SearchTypes'] = request.searchTypes;
  }
  if (!Util.isUnset(request.sortCriteria)) {
    body['SortCriteria'] = request.sortCriteria;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchAcrossCatalog',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/search/search-across-catalog`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Search across catalogs for content such as libraries, tables, and fields.
 *
 * @param request SearchAcrossCatalogRequest
 * @return SearchAcrossCatalogResponse
 */
async function searchAcrossCatalog(request: SearchAcrossCatalogRequest): SearchAcrossCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchAcrossCatalogWithOptions(request, headers, runtime);
}

model StopMigrationWorkflowRequest {
  instanceId?: string(name='InstanceId', description='The ID of the migration task instance.

This parameter is required.', example='M-6DCF5D8EF92E2195'),
}

model StopMigrationWorkflowResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the test feature is enabled.', example='true'),
}

model StopMigrationWorkflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopMigrationWorkflowResponseBody(name='body'),
}

/**
 * @summary Stop the metadata migration task.
 *
 * @param request StopMigrationWorkflowRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopMigrationWorkflowResponse
 */
async function stopMigrationWorkflowWithOptions(request: StopMigrationWorkflowRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopMigrationWorkflowResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopMigrationWorkflow',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/migration/workflow/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Stop the metadata migration task.
 *
 * @param request StopMigrationWorkflowRequest
 * @return StopMigrationWorkflowResponse
 */
async function stopMigrationWorkflow(request: StopMigrationWorkflowRequest): StopMigrationWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopMigrationWorkflowWithOptions(request, headers, runtime);
}

model SubmitQueryRequest {
  catalogId?: string(name='catalogId', description='The ID of the data directory.', example='catalog1'),
  sql?: string(name='sql', description='The SQL statement.', example='show databases'),
  workspaceId?: string(name='workspaceId', description='The workspace ID.', example='WS-A129E61C4892D2B4'),
}

model SubmitQueryResponseBody = {
  data?: string(name='Data', description='The data returned', example='Q-14475CF9B51FCE5E'),
  requestId?: string(name='RequestId', description='The request ID.', example='279AA630-A8ED-5EA9-80A3-2E213D63548C'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model SubmitQueryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SubmitQueryResponseBody(name='body'),
}

/**
 * @summary Submit an SQL query task.
 *
 * @description *   Only suitable for submitting small and medium-sized queries. The execution time cannot exceed 1 hour.
 * *   A maximum of 10000 query results can be returned.
 * *   There are limits on concurrent execution under a single master account. If multiple queries are submitted at the same time, they will be queued.
 *
 * @param request SubmitQueryRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitQueryResponse
 */
async function submitQueryWithOptions(request: SubmitQueryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SubmitQueryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['catalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.sql)) {
    body['sql'] = request.sql;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['workspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SubmitQuery',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/submitQueryRequestBody`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Submit an SQL query task.
 *
 * @description *   Only suitable for submitting small and medium-sized queries. The execution time cannot exceed 1 hour.
 * *   A maximum of 10000 query results can be returned.
 * *   There are limits on concurrent execution under a single master account. If multiple queries are submitted at the same time, they will be queued.
 *
 * @param request SubmitQueryRequest
 * @return SubmitQueryResponse
 */
async function submitQuery(request: SubmitQueryRequest): SubmitQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return submitQueryWithOptions(request, headers, runtime);
}

model UnLockRequest {
  lockId?: long(name='LockId', description='The lock ID.', example='11709'),
}

model UnLockResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='37C8470A-5E6D-5E4E-AEF0-EA3EBE9C89EE'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model UnLockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnLockResponseBody(name='body'),
}

/**
 * @summary Unlocks the specified metadata lock.
 *
 * @param request UnLockRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnLockResponse
 */
async function unLockWithOptions(request: UnLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UnLockResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lockId)) {
    query['LockId'] = request.lockId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Unlocks the specified metadata lock.
 *
 * @param request UnLockRequest
 * @return UnLockResponse
 */
async function unLock(request: UnLockRequest): UnLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unLockWithOptions(request, headers, runtime);
}

model UpdateCatalogRequest {
  catalogInput?: CatalogInput(name='CatalogInput', description='Create /update the structure of the Catalog.

This parameter is required.'),
}

model UpdateCatalogResponseBody = {
  code?: string(name='Code', description='Response encoding.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='64E46067-49EA-5A91-A7B1-E812E18FC243'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request is successful.
*   false: The request failed.', example='true'),
}

model UpdateCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCatalogResponseBody(name='body'),
}

/**
 * @summary Updates the contents of the Data Catalog.
 *
 * @param request UpdateCatalogRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCatalogResponse
 */
async function updateCatalogWithOptions(request: UpdateCatalogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCatalogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogInput)) {
    body['CatalogInput'] = request.catalogInput;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCatalog',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the contents of the Data Catalog.
 *
 * @param request UpdateCatalogRequest
 * @return UpdateCatalogResponse
 */
async function updateCatalog(request: UpdateCatalogRequest): UpdateCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCatalogWithOptions(request, headers, runtime);
}

model UpdateCatalogSettingsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.'),
  catalogSettings?: CatalogSettings(name='CatalogSettings', description='Data lake-related configurations.'),
}

model UpdateCatalogSettingsResponseBody = {
  code?: string(name='Code', description='The HTTP status code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='01D8DD6B-4929-5999-9BB3-950AA30E3BD0'),
  success?: boolean(name='Success', description='Whether the operation is successful. Valid values:

*   true: The request was successful.
*   false: The operation failed.', example='true'),
}

model UpdateCatalogSettingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCatalogSettingsResponseBody(name='body'),
}

/**
 * @summary To update the configurations of Data Lake Catalog, you must assume the admin role or more.
 *
 * @param request UpdateCatalogSettingsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCatalogSettingsResponse
 */
async function updateCatalogSettingsWithOptions(request: UpdateCatalogSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCatalogSettingsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.catalogSettings)) {
    body['CatalogSettings'] = request.catalogSettings;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCatalogSettings',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/settings`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary To update the configurations of Data Lake Catalog, you must assume the admin role or more.
 *
 * @param request UpdateCatalogSettingsRequest
 * @return UpdateCatalogSettingsResponse
 */
async function updateCatalogSettings(request: UpdateCatalogSettingsRequest): UpdateCatalogSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCatalogSettingsWithOptions(request, headers, runtime);
}

model UpdateDatabaseRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseInput?: DatabaseInput(name='DatabaseInput', description='The new database'),
  name?: string(name='Name', description='The name of the database before the modification. If the database before and after the update is the same, only other Meta is updated.', example='database_test'),
}

model UpdateDatabaseResponseBody = {
  code?: string(name='Code', description='The description of the distribution status.', example='OK'),
  message?: string(name='Message', description='A related error message is displayed.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='161F5EFC-E97E-43C0-AACF-FF18FAC912F0'),
  success?: boolean(name='Success', description='Indicates whether the operation was successful. Valid values:

*   true: The request is successful.
*   false: The request failed.', example='true'),
}

model UpdateDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDatabaseResponseBody(name='body'),
}

/**
 * @summary Update the details of a database in the data lake.
 *
 * @param request UpdateDatabaseRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDatabaseResponse
 */
async function updateDatabaseWithOptions(request: UpdateDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDatabaseResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseInput)) {
    body['DatabaseInput'] = request.databaseInput;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDatabase',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update the details of a database in the data lake.
 *
 * @param request UpdateDatabaseRequest
 * @return UpdateDatabaseResponse
 */
async function updateDatabase(request: UpdateDatabaseRequest): UpdateDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDatabaseWithOptions(request, headers, runtime);
}

model UpdateFunctionRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  functionInput?: FunctionInput(name='FunctionInput', description='The details of the function to be updated.'),
  functionName?: string(name='FunctionName', description='The function name.', example='func2'),
}

model UpdateFunctionResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model UpdateFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFunctionResponseBody(name='body'),
}

/**
 * @summary Updates the user-defined function information for a database in the data lake by name.
 *
 * @param request UpdateFunctionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFunctionResponse
 */
async function updateFunctionWithOptions(request: UpdateFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionInput)) {
    body['FunctionInput'] = request.functionInput;
  }
  if (!Util.isUnset(request.functionName)) {
    body['FunctionName'] = request.functionName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFunction',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the user-defined function information for a database in the data lake by name.
 *
 * @param request UpdateFunctionRequest
 * @return UpdateFunctionResponse
 */
async function updateFunction(request: UpdateFunctionRequest): UpdateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFunctionWithOptions(request, headers, runtime);
}

model UpdatePartitionColumnStatisticsRequest {
  updateTablePartitionColumnStatisticsRequest?: UpdateTablePartitionColumnStatisticsRequest(name='UpdateTablePartitionColumnStatisticsRequest', description='Updates data table partition parameters.'),
}

model UpdatePartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model UpdatePartitionColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePartitionColumnStatisticsResponseBody(name='body'),
}

/**
 * @summary Creates or updates the field statistics of a data table partition.
 *
 * @param request UpdatePartitionColumnStatisticsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePartitionColumnStatisticsResponse
 */
async function updatePartitionColumnStatisticsWithOptions(request: UpdatePartitionColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePartitionColumnStatisticsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.updateTablePartitionColumnStatisticsRequest),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePartitionColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/columnstatistics`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates or updates the field statistics of a data table partition.
 *
 * @param request UpdatePartitionColumnStatisticsRequest
 * @return UpdatePartitionColumnStatisticsResponse
 */
async function updatePartitionColumnStatistics(request: UpdatePartitionColumnStatisticsRequest): UpdatePartitionColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePartitionColumnStatisticsWithOptions(request, headers, runtime);
}

model UpdatePermissionsRequest {
  accesses?: [ string ](name='Accesses', description='The list of authorized access permissions.

This parameter is required.'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  delegateAccesses?: [ string ](name='DelegateAccesses', description='The list of access permissions that can be delegated.

This parameter is required.'),
  metaResource?: MetaResource(name='MetaResource', description='The metadata resource to be authorized.

This parameter is required.'),
  principal?: Principal(name='Principal', description='Specify the authorized users or roles. The format of the name must meet the following requirements:

*   RAM user: acs:ram::[accountId]:user/[userName].
*   RAM role: acs:ram::[accountId]:role/[roleName].
*   Data Lake Role: acs:dlf::[accountId]:role/[roleName].

This parameter is required.'),
  type?: string(name='Type', description='The type of the authorization. Only Hive is supported.

This parameter is required.', example='Hive'),
}

model UpdatePermissionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model UpdatePermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePermissionsResponseBody(name='body'),
}

/**
 * @summary Update the permissions of the User /Data Lake role.
 *
 * @param request UpdatePermissionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePermissionsResponse
 */
async function updatePermissionsWithOptions(request: UpdatePermissionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePermissionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accesses)) {
    body['Accesses'] = request.accesses;
  }
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.delegateAccesses)) {
    body['DelegateAccesses'] = request.delegateAccesses;
  }
  if (!Util.isUnset(request.metaResource)) {
    body['MetaResource'] = request.metaResource;
  }
  if (!Util.isUnset(request.principal)) {
    body['Principal'] = request.principal;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update the permissions of the User /Data Lake role.
 *
 * @param request UpdatePermissionsRequest
 * @return UpdatePermissionsResponse
 */
async function updatePermissions(request: UpdatePermissionsRequest): UpdatePermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePermissionsWithOptions(request, headers, runtime);
}

model UpdateRegisteredLocationRequest {
  inventoryCollectEnabled?: boolean(name='InventoryCollectEnabled', description='Whether to enable OSS bucket inventory', example='true'),
  locationId?: string(name='LocationId', description='Location ID

>  You can call the RegisterLocation operation to obtain the Location ID.

This parameter is required.', example='LOC-AB8FBC17F95A4AF5'),
  ossLogCollectEnabled?: boolean(name='OssLogCollectEnabled', description='Whether to enable OSS log storage', example='true'),
}

model UpdateRegisteredLocationResponseBody = {
  data?: {
    locationId?: string(name='LocationId', description='Location ID', example='LOC-AB8FBC17F95A4AF5'),
    storageCollectTaskOperationResultList?: [
      StorageCollectTaskOperationResult
    ](name='StorageCollectTaskOperationResultList', description='Modify the result list of a collection task'),
  }(name='Data', description='The response parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='8030C902-C25B-1839-867D-E6F70A5B9810'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true.
*   false: The request failed.', example='true'),
}

model UpdateRegisteredLocationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRegisteredLocationResponseBody(name='body'),
}

/**
 * @summary Edit a Registered Location.
 *
 * @param request UpdateRegisteredLocationRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRegisteredLocationResponse
 */
async function updateRegisteredLocationWithOptions(request: UpdateRegisteredLocationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRegisteredLocationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.inventoryCollectEnabled)) {
    body['InventoryCollectEnabled'] = request.inventoryCollectEnabled;
  }
  if (!Util.isUnset(request.locationId)) {
    body['LocationId'] = request.locationId;
  }
  if (!Util.isUnset(request.ossLogCollectEnabled)) {
    body['OssLogCollectEnabled'] = request.ossLogCollectEnabled;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRegisteredLocation',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/locations`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Edit a Registered Location.
 *
 * @param request UpdateRegisteredLocationRequest
 * @return UpdateRegisteredLocationResponse
 */
async function updateRegisteredLocation(request: UpdateRegisteredLocationRequest): UpdateRegisteredLocationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRegisteredLocationWithOptions(request, headers, runtime);
}

model UpdateRoleRequest {
  roleInput?: RoleInput(name='RoleInput', description='Input information of the updated element'),
  roleName?: string(name='RoleName', description='Role name', example='原始名称'),
}

model UpdateRoleResponseBody = {
  code?: string(name='Code', description='The status of the request.', example='OK'),
  message?: string(name='Message', description='The returned message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='604E5919-C6FF-54CE-9C23-C5350E6F5415'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false', example='true'),
}

model UpdateRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRoleResponseBody(name='body'),
}

/**
 * @summary Update a role in Data Lake Permissions in which the RDS instance resides.
 *
 * @param request UpdateRoleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRoleResponse
 */
async function updateRoleWithOptions(request: UpdateRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRoleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.roleInput)) {
    body['RoleInput'] = request.roleInput;
  }
  if (!Util.isUnset(request.roleName)) {
    body['RoleName'] = request.roleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRole',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update a role in Data Lake Permissions in which the RDS instance resides.
 *
 * @param request UpdateRoleRequest
 * @return UpdateRoleResponse
 */
async function updateRole(request: UpdateRoleRequest): UpdateRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRoleWithOptions(request, headers, runtime);
}

model UpdateRoleUsersRequest {
  roleName?: string(name='RoleName', description='The name of the role.', example='test_role_8'),
  users?: [
  Principal
](name='Users', description='The list of users or roles. The format of the name must meet the following requirements:

RAM user: acs:ram::[accountId]:user/[userName].

RAM role: acs:ram::[accountId]:role/[roleName].'),
}

model UpdateRoleUsersResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model UpdateRoleUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRoleUsersResponseBody(name='body'),
}

/**
 * @summary Update the user in the role to include ram user/ram role.
 *
 * @param request UpdateRoleUsersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRoleUsersResponse
 */
async function updateRoleUsersWithOptions(request: UpdateRoleUsersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRoleUsersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.roleName)) {
    body['RoleName'] = request.roleName;
  }
  if (!Util.isUnset(request.users)) {
    body['Users'] = request.users;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRoleUsers',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/updateroleusers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update the user in the role to include ram user/ram role.
 *
 * @param request UpdateRoleUsersRequest
 * @return UpdateRoleUsersResponse
 */
async function updateRoleUsers(request: UpdateRoleUsersRequest): UpdateRoleUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRoleUsersWithOptions(request, headers, runtime);
}

model UpdateTableRequest {
  allowPartitionKeyChange?: boolean(name='AllowPartitionKeyChange', description='Indicates whether the partition key can be updated.', example='false'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  isAsync?: boolean(name='IsAsync', description='Whether to synchronize the update.', example='true'),
  skipArchive?: boolean(name='SkipArchive', description='By default, updating a data table creates a new archive version, but if skipArchive is set to true, no version is created.', example='false'),
  tableInput?: TableInput(name='TableInput', description='The details of the updated data table.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model UpdateTableResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
  taskId?: string(name='TaskId', description='The ID of the asynchronous task.', example='aa689782deb97265701f57324fc4ae42'),
}

model UpdateTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateTableResponseBody(name='body'),
}

/**
 * @summary Update the data table information in the data lake based on the name.
 *
 * @param request UpdateTableRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTableResponse
 */
async function updateTableWithOptions(request: UpdateTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTableResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.allowPartitionKeyChange)) {
    body['AllowPartitionKeyChange'] = request.allowPartitionKeyChange;
  }
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.isAsync)) {
    body['IsAsync'] = request.isAsync;
  }
  if (!Util.isUnset(request.skipArchive)) {
    body['SkipArchive'] = request.skipArchive;
  }
  if (!Util.isUnset(request.tableInput)) {
    body['TableInput'] = request.tableInput;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update the data table information in the data lake based on the name.
 *
 * @param request UpdateTableRequest
 * @return UpdateTableResponse
 */
async function updateTable(request: UpdateTableRequest): UpdateTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTableWithOptions(request, headers, runtime);
}

model UpdateTableColumnStatisticsRequest {
  updateTablePartitionColumnStatisticsRequest?: UpdateTablePartitionColumnStatisticsRequest(name='UpdateTablePartitionColumnStatisticsRequest', description='The request to update statistics.'),
}

model UpdateTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The error message that is returned.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request is successful.
*   false: The request failed.', example='true'),
}

model UpdateTableColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateTableColumnStatisticsResponseBody(name='body'),
}

/**
 * @summary Creates or updates field statistics for a data table.
 *
 * @param request UpdateTableColumnStatisticsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTableColumnStatisticsResponse
 */
async function updateTableColumnStatisticsWithOptions(request: UpdateTableColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTableColumnStatisticsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.updateTablePartitionColumnStatisticsRequest),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTableColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/columnstatistics`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates or updates field statistics for a data table.
 *
 * @param request UpdateTableColumnStatisticsRequest
 * @return UpdateTableColumnStatisticsResponse
 */
async function updateTableColumnStatistics(request: UpdateTableColumnStatisticsRequest): UpdateTableColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTableColumnStatisticsWithOptions(request, headers, runtime);
}

