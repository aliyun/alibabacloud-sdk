/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'datalake-daily.aliyuncs.com',
    ap-northeast-2-pop = 'datalake-daily.aliyuncs.com',
    ap-south-1 = 'datalake-daily.aliyuncs.com',
    ap-southeast-1 = 'datalake-daily.aliyuncs.com',
    ap-southeast-2 = 'datalake-daily.aliyuncs.com',
    ap-southeast-3 = 'datalake-daily.aliyuncs.com',
    ap-southeast-5 = 'datalake-daily.aliyuncs.com',
    cn-beijing = 'dlf.cn-beijing.aliyuncs.com',
    cn-beijing-finance-1 = 'datalake-daily.aliyuncs.com',
    cn-beijing-finance-pop = 'datalake-daily.aliyuncs.com',
    cn-beijing-gov-1 = 'datalake-daily.aliyuncs.com',
    cn-beijing-nu16-b01 = 'datalake-daily.aliyuncs.com',
    cn-chengdu = 'datalake-daily.aliyuncs.com',
    cn-edge-1 = 'datalake-daily.aliyuncs.com',
    cn-fujian = 'datalake-daily.aliyuncs.com',
    cn-haidian-cm12-c01 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou = 'dlf.cn-hangzhou.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-finance = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-test-306 = 'datalake-daily.aliyuncs.com',
    cn-hongkong = 'datalake-daily.aliyuncs.com',
    cn-hongkong-finance-pop = 'datalake-daily.aliyuncs.com',
    cn-huhehaote = 'datalake-daily.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'datalake-daily.aliyuncs.com',
    cn-north-2-gov-1 = 'datalake-daily.aliyuncs.com',
    cn-qingdao = 'datalake-daily.aliyuncs.com',
    cn-qingdao-nebula = 'datalake-daily.aliyuncs.com',
    cn-shanghai = 'dlf.cn-shanghai.aliyuncs.com',
    cn-shanghai-et15-b01 = 'datalake-daily.aliyuncs.com',
    cn-shanghai-et2-b01 = 'datalake-daily.aliyuncs.com',
    cn-shanghai-finance-1 = 'datalake-daily.aliyuncs.com',
    cn-shanghai-inner = 'datalake-daily.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'datalake-daily.aliyuncs.com',
    cn-shenzhen = 'dlf.cn-shenzhen.aliyuncs.com',
    cn-shenzhen-finance-1 = 'datalake-daily.aliyuncs.com',
    cn-shenzhen-inner = 'datalake-daily.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'datalake-daily.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'datalake-daily.aliyuncs.com',
    cn-wuhan = 'datalake-daily.aliyuncs.com',
    cn-wulanchabu = 'datalake-daily.aliyuncs.com',
    cn-yushanfang = 'datalake-daily.aliyuncs.com',
    cn-zhangbei = 'datalake-daily.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'datalake-daily.aliyuncs.com',
    cn-zhangjiakou = 'datalake-daily.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'datalake-daily.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'datalake-daily.aliyuncs.com',
    eu-central-1 = 'datalake-daily.aliyuncs.com',
    eu-west-1 = 'datalake-daily.aliyuncs.com',
    eu-west-1-oxs = 'datalake-daily.aliyuncs.com',
    me-east-1 = 'datalake-daily.aliyuncs.com',
    rus-west-1-pop = 'datalake-daily.aliyuncs.com',
    us-east-1 = 'datalake-daily.aliyuncs.com',
    us-west-1 = 'datalake-daily.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('datalake', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AccessRequest {
  catalogId?: string(name='CatalogId'),
  principal?: Principal(name='Principal'),
  privilegeResources?: [
PrivilegeResource
](name='PrivilegeResources'),
}

model Catalog {
  catalogId?: string(name='CatalogId'),
  createTime?: long(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  description?: string(name='Description'),
  locationUri?: string(name='LocationUri'),
  owner?: string(name='Owner'),
  status?: string(name='Status'),
  updateTime?: long(name='UpdateTime'),
}

model CatalogInput {
  catalogId?: string(name='CatalogId'),
  description?: string(name='Description'),
  locationUri?: string(name='LocationUri'),
  owner?: string(name='Owner'),
}

model CatalogResource {
  catalogId?: string(name='CatalogId'),
}

model CatalogSettings {
  config?: map[string]string(name='Config'),
}

model ColumnResource {
  columnNames?: [ string ](name='ColumnNames'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
}

model ColumnStatistics {
  columnStatisticsDesc?: ColumnStatisticsDesc(name='ColumnStatisticsDesc'),
  columnStatisticsObjList?: [
    ColumnStatisticsObj
  ](name='ColumnStatisticsObjList'),
  engine?: string(name='Engine'),
  isStatsCompliant?: boolean(name='IsStatsCompliant'),
}

model ColumnStatisticsDesc {
  lastAnalyzedTime?: long(name='LastAnalyzedTime'),
  partitionName?: string(name='PartitionName'),
}

model ColumnStatisticsObj {
  columnName?: string(name='ColumnName'),
  columnStatisticsData?: {
    statisticsData?: string(name='StatisticsData'),
    statisticsType?: string(name='StatisticsType'),
  }(name='ColumnStatisticsData'),
  columnType?: string(name='ColumnType'),
}

model Database {
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  description?: string(name='Description'),
  locationUri?: string(name='LocationUri'),
  name?: string(name='Name'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  updateTime?: int32(name='UpdateTime'),
}

model DatabaseInput {
  createTime?: int32(name='CreateTime'),
  description?: string(name='Description'),
  locationUri?: string(name='LocationUri'),
  name?: string(name='Name'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
}

model DatabaseProfile {
  createTime?: string(name='CreateTime'),
  fileCnt?: long(name='FileCnt'),
  fileSize?: long(name='FileSize'),
  location?: string(name='Location'),
  name?: string(name='Name'),
}

model DatabaseResource {
  databaseName?: string(name='DatabaseName'),
  databaseWildcard?: string(name='DatabaseWildcard'),
}

model DbStorageRank {
  dbName?: string(name='DbName'),
  quantity?: long(name='Quantity'),
}

model ErrorDetail {
  code?: string(name='Code'),
  message?: string(name='Message'),
}

model FieldSchema {
  comment?: string(name='Comment'),
  name?: string(name='Name'),
  parameters?: map[string]string(name='Parameters'),
  type?: string(name='Type'),
}

model FileCnt {
  large?: long(name='Large'),
  middle?: long(name='Middle'),
  small?: long(name='Small'),
  tiny?: long(name='Tiny'),
}

model Function {
  catalogId?: string(name='CatalogId'),
  className?: string(name='ClassName'),
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  databaseName?: string(name='DatabaseName'),
  functionName?: string(name='FunctionName'),
  functionType?: string(name='FunctionType'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  resourceUri?: [
    ResourceUri
  ](name='ResourceUri'),
  updateTime?: int32(name='UpdateTime'),
}

model FunctionInput {
  className?: string(name='ClassName'),
  createTime?: int32(name='CreateTime'),
  functionName?: string(name='FunctionName'),
  functionType?: string(name='FunctionType'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  resourceUri?: [
    ResourceUri
  ](name='ResourceUri'),
}

model FunctionResource {
  databaseName?: string(name='DatabaseName'),
  functionName?: string(name='FunctionName'),
}

model GrantRevokeEntry {
  accesses?: [ string ](name='Accesses'),
  delegateAccesses?: [ string ](name='DelegateAccesses'),
  id?: string(name='Id'),
  metaResource?: MetaResource(name='MetaResource'),
  principal?: Principal(name='Principal'),
}

model GrantRevokeFailureEntry {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  grantRevokeEntry?: GrantRevokeEntry(name='GrantRevokeEntry'),
}

model HighLight {
  key?: string(name='Key'),
  value?: string(name='Value'),
}

model IndicatorStatistic {
  data?: long(name='Data'),
  date?: string(name='Date'),
}

model LifecycleResource {
  bizId?: string(name='BizId'),
  database?: {
    createTime?: long(name='CreateTime'),
    description?: string(name='Description'),
    locationUri?: string(name='LocationUri'),
    name?: string(name='Name'),
    updateTime?: long(name='UpdateTime'),
  }(name='Database'),
  databaseName?: string(name='DatabaseName'),
  databaseProfile?: DatabaseProfile(name='DatabaseProfile'),
  gmtCreate?: string(name='GmtCreate'),
  lifecycleRuleBizId?: string(name='LifecycleRuleBizId'),
  owner?: long(name='Owner'),
  table?: {
    createTime?: long(name='CreateTime'),
    databaseName?: string(name='DatabaseName'),
    parameters?: map[string]string(name='Parameters'),
    sd?: {
      bucketCols?: [ string ](name='BucketCols'),
      inputFormat?: string(name='InputFormat'),
      location?: string(name='Location'),
      outputFormat?: string(name='OutputFormat'),
      parameters?: map[string]string(name='Parameters'),
      serDeInfo?: {
        name?: string(name='Name'),
        parameters?: map[string]string(name='Parameters'),
        serializationLib?: string(name='SerializationLib'),
      }(name='SerDeInfo'),
    }(name='Sd'),
    tableName?: string(name='TableName'),
    tableType?: string(name='TableType'),
  }(name='Table'),
  tableName?: string(name='TableName'),
  tableProfile?: TableProfile(name='TableProfile'),
}

model LifecycleRule {
  archiveDays?: int32(name='ArchiveDays'),
  bindCount?: int32(name='BindCount'),
  bizId?: string(name='BizId'),
  coldArchiveDays?: int32(name='ColdArchiveDays'),
  config?: string(name='Config'),
  description?: string(name='Description'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  iaDays?: int32(name='IaDays'),
  name?: string(name='Name'),
  resourceType?: string(name='ResourceType'),
  ruleType?: string(name='RuleType'),
  scheduleStatus?: string(name='ScheduleStatus'),
  workflow?: Workflow(name='Workflow'),
  workflowId?: string(name='WorkflowId'),
  workflowInstance?: WorkflowInstance(name='WorkflowInstance'),
}

model LifecycleTask {
  bizId?: string(name='BizId'),
  lifecycleRule?: LifecycleRule(name='LifecycleRule'),
  name?: string(name='Name'),
  workflowInstance?: WorkflowInstance(name='WorkflowInstance'),
}

model LockObj {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  partitionName?: string(name='PartitionName'),
  tableName?: string(name='TableName'),
}

model LockStatus {
  lockId?: long(name='LockId'),
  lockState?: string(name='LockState'),
}

model LogInfo {
  bizTime?: string(name='BizTime'),
  gmtCreate?: string(name='GmtCreate'),
  instanceId?: string(name='InstanceId'),
  logContent?: string(name='LogContent'),
  logId?: string(name='LogId'),
  logSummary?: string(name='LogSummary'),
  logType?: string(name='LogType'),
}

model MetaResource {
  catalogResource?: CatalogResource(name='CatalogResource'),
  columnResource?: ColumnResource(name='ColumnResource'),
  databaseResource?: DatabaseResource(name='DatabaseResource'),
  functionResource?: FunctionResource(name='FunctionResource'),
  resourceType?: string(name='ResourceType'),
  tableResource?: TableResource(name='TableResource'),
}

model Order {
  col?: string(name='Col'),
  order?: int32(name='Order'),
}

model Partition {
  createTime?: int32(name='CreateTime'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName'),
  values?: [ string ](name='Values'),
}

model PartitionError {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  partitionValues?: [ string ](name='PartitionValues'),
}

model PartitionInput {
  createTime?: int32(name='CreateTime'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName'),
  values?: [ string ](name='Values'),
}

model PartitionProfile {
  archiveStatus?: string(name='ArchiveStatus'),
  createTime?: string(name='CreateTime'),
  databaseName?: string(name='DatabaseName'),
  dmlTime?: string(name='DmlTime'),
  location?: string(name='Location'),
  partitionName?: string(name='PartitionName'),
  tableName?: string(name='TableName'),
}

model PartitionSpec {
  sharedSDPartitions?: [
    Partition
  ](name='SharedSDPartitions'),
  sharedStorageDescriptor?: {
    cols?: [
      FieldSchema
    ](name='Cols'),
    location?: string(name='Location'),
  }(name='SharedStorageDescriptor'),
}

model Principal {
  principalArn?: string(name='PrincipalArn'),
}

model PrincipalPrivilegeSet {
  groupPrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='GroupPrivileges'),
  rolePrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='RolePrivileges'),
  userPrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='UserPrivileges'),
}

model PrincipalResourcePermissions {
  accesses?: [ string ](name='Accesses'),
  delegateAccesses?: [ string ](name='DelegateAccesses'),
  metaResource?: MetaResource(name='MetaResource'),
  principal?: Principal(name='Principal'),
}

model PrivilegeGrantInfo {
  createTime?: int32(name='CreateTime'),
  grantOption?: boolean(name='GrantOption'),
  grantor?: string(name='Grantor'),
  grantorType?: string(name='GrantorType'),
  privilege?: string(name='Privilege'),
}

model PrivilegeResource {
  access?: string(name='Access'),
  metaResource?: MetaResource(name='MetaResource'),
}

model ResourceUri {
  resourceType?: string(name='ResourceType'),
  uri?: string(name='Uri'),
}

model Role {
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  displayName?: string(name='DisplayName'),
  isPredefined?: int32(name='IsPredefined'),
  name?: string(name='Name'),
  principalArn?: string(name='PrincipalArn'),
  updateTime?: long(name='UpdateTime'),
  users?: [
Principal
](name='Users'),
}

model RoleInput {
  description?: string(name='Description'),
  displayName?: string(name='DisplayName'),
  name?: string(name='Name'),
}

model SerDeInfo {
  name?: string(name='Name'),
  parameters?: map[string]string(name='Parameters'),
  serializationLib?: string(name='SerializationLib'),
}

model SingleIndicatorDTO {
  dayIncrement?: long(name='DayIncrement'),
  dayOnDay?: double(name='DayOnDay'),
  monthIncrement?: long(name='MonthIncrement'),
  monthOnMonth?: double(name='MonthOnMonth'),
  total?: long(name='Total'),
}

model SkewedInfo {
  skewedColNames?: [ string ](name='SkewedColNames'),
  skewedColValueLocationMaps?: map[string]string(name='SkewedColValueLocationMaps'),
  skewedColValues?: [[ string ]  ](name='SkewedColValues'),
}

model SmallFileCntRank {
  dbName?: string(name='DbName'),
  location?: string(name='Location'),
  quantity?: long(name='Quantity'),
  tableName?: string(name='TableName'),
}

model SortCriterion {
  fieldName?: string(name='FieldName'),
  sort?: string(name='Sort'),
}

model StorageDescriptor {
  bucketCols?: [ string ](name='BucketCols'),
  cols?: [
    FieldSchema
  ](name='Cols'),
  compressed?: boolean(name='Compressed'),
  inputFormat?: string(name='InputFormat'),
  location?: string(name='Location'),
  numBuckets?: int32(name='NumBuckets'),
  outputFormat?: string(name='OutputFormat'),
  parameters?: map[string]string(name='Parameters'),
  serDeInfo?: SerDeInfo(name='SerDeInfo'),
  skewedInfo?: SkewedInfo(name='SkewedInfo'),
  sortCols?: [
    Order
  ](name='SortCols'),
  storedAsSubDirectories?: boolean(name='StoredAsSubDirectories'),
}

model StorageFormat {
  avro?: long(name='Avro'),
  csv?: long(name='Csv'),
  delta?: long(name='Delta'),
  hudi?: long(name='Hudi'),
  iceberg?: long(name='Iceberg'),
  json?: long(name='Json'),
  orc?: long(name='Orc'),
  parquet?: long(name='Parquet'),
  uncategorized?: long(name='Uncategorized'),
}

model StorageLayer {
  archive?: long(name='Archive'),
  coldArchive?: long(name='ColdArchive'),
  infrequent?: long(name='Infrequent'),
  standard?: long(name='Standard'),
}

model StorageRankDTO {
  dbStorageRank?: [
    DbStorageRank
  ](name='dbStorageRank'),
  smallFileCntRank?: [
    SmallFileCntRank
  ](name='smallFileCntRank'),
  tableStorageRank?: [
    TableStorageRank
  ](name='tableStorageRank'),
}

model StorageSummary {
  databaseNum?: int32(name='DatabaseNum'),
  partitionNum?: int32(name='PartitionNum'),
  tableNum?: int32(name='TableNum'),
}

model Table {
  cascade?: boolean(name='Cascade'),
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  owner?: string(name='Owner'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  retention?: int32(name='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled'),
  sd?: StorageDescriptor(name='Sd'),
  tableId?: string(name='TableId'),
  tableName?: string(name='TableName'),
  tableType?: string(name='TableType'),
  tableVersion?: TableVersion(name='TableVersion'),
  temporary?: boolean(name='Temporary'),
  updateTime?: int32(name='UpdateTime'),
  viewExpandedText?: string(name='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText'),
}

model TableError {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  tableName?: string(name='TableName'),
}

model TableExtended {
  cascade?: boolean(name='Cascade'),
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  owner?: string(name='Owner'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: {
    rolePrivileges?: map[string][ TableExtendedPrivilegesRolePrivilegesValue     ](name='RolePrivileges'),
    userPrivileges?: map[string][ TableExtendedPrivilegesUserPrivilegesValue     ](name='UserPrivileges'),
    groupPrivileges?: map[string][ TableExtendedPrivilegesGroupPrivilegesValue     ](name='groupPrivileges'),
  }(name='Privileges'),
  retention?: int32(name='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled'),
  sd?: {
    bucketCols?: [ string ](name='BucketCols'),
    cols?: [
      FieldSchema
    ](name='Cols'),
    compressed?: boolean(name='Compressed'),
    inputFormat?: string(name='InputFormat'),
    location?: string(name='Location'),
    numBuckets?: int32(name='NumBuckets'),
    outputFormat?: string(name='OutputFormat'),
    parameters?: map[string]string(name='Parameters'),
    serDeInfo?: {
      name?: string(name='Name'),
      parameters?: map[string]string(name='Parameters'),
      serializationLib?: string(name='SerializationLib'),
    }(name='SerDeInfo'),
    skewedInfo?: {
      skewedColNames?: [ string ](name='SkewedColNames'),
      skewedColValueLocationMaps?: map[string]string(name='SkewedColValueLocationMaps'),
      skewedColValues?: [[ string ]      ](name='SkewedColValues'),
    }(name='SkewedInfo'),
    sortCols?: [
      Order
    ](name='SortCols'),
    storedAsSubDirectories?: boolean(name='StoredAsSubDirectories'),
  }(name='Sd'),
  tableFormat?: string(name='TableFormat'),
  tableName?: string(name='TableName'),
  tableType?: string(name='TableType'),
  temporary?: boolean(name='Temporary'),
  updateTime?: int32(name='UpdateTime'),
  viewExpandedText?: string(name='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText'),
}

model TableInput {
  cascade?: boolean(name='Cascade'),
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  owner?: string(name='Owner'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  retention?: int32(name='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName'),
  tableType?: string(name='TableType'),
  temporary?: boolean(name='Temporary'),
  viewExpandedText?: string(name='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText'),
}

model TableProfile {
  createTime?: string(name='CreateTime'),
  databaseName?: string(name='DatabaseName'),
  fileCnt?: long(name='FileCnt'),
  fileSize?: long(name='FileSize'),
  isPartitioned?: boolean(name='IsPartitioned'),
  lastModifyTime?: string(name='LastModifyTime'),
  location?: string(name='Location'),
  partitionCnt?: long(name='PartitionCnt'),
  recordCnt?: long(name='RecordCnt'),
  tableName?: string(name='TableName'),
}

model TableResource {
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
}

model TableStorageRank {
  dbName?: string(name='DbName'),
  quantity?: long(name='Quantity'),
  tableName?: string(name='TableName'),
}

model TableVersion {
  table?: Table(name='Table'),
  versionId?: int32(name='VersionId'),
}

model TaskStatus {
  message?: string(name='Message'),
  status?: string(name='Status'),
}

model UnarchiveDetail {
  apiCallTimes?: long(name='ApiCallTimes'),
  cost?: long(name='Cost'),
  storageSize?: long(name='StorageSize'),
  storageType?: string(name='StorageType'),
  unarchiveTaskStatus?: string(name='UnarchiveTaskStatus'),
}

model UpdateTablePartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId'),
  columnStatisticsList?: [
    ColumnStatistics
  ](name='ColumnStatisticsList'),
  databaseName?: string(name='DatabaseName'),
  engine?: string(name='Engine'),
  isStatsCompliant?: boolean(name='IsStatsCompliant'),
  tableName?: string(name='TableName'),
  validWriteIdList?: string(name='ValidWriteIdList'),
  writeId?: string(name='WriteId'),
}

model UserRole {
  grantTime?: long(name='GrantTime'),
  role?: Role(name='Role'),
  user?: Principal(name='User'),
}

model Workflow {
  latestEndTime?: string(name='LatestEndTime'),
  latestInstanceId?: string(name='LatestInstanceId'),
  latestInstanceStatus?: string(name='LatestInstanceStatus'),
  latestStartTime?: string(name='LatestStartTime'),
}

model WorkflowInstance {
  batchProgress?: int32(name='BatchProgress'),
  dlfWorkflowId?: string(name='DlfWorkflowId'),
  endTime?: long(name='EndTime'),
  externalInstanceId?: string(name='ExternalInstanceId'),
  runtimeLogs?: [
    LogInfo
  ](name='RuntimeLogs'),
  startTime?: long(name='StartTime'),
  status?: string(name='Status'),
}

model AbortLockRequest {
  lockId?: long(name='LockId'),
}

model AbortLockResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AbortLockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AbortLockResponseBody(name='body'),
}

async function abortLock(request: AbortLockRequest): AbortLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return abortLockWithOptions(request, headers, runtime);
}

async function abortLockWithOptions(request: AbortLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AbortLockResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lockId)) {
    query['LockId'] = request.lockId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AbortLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks/abort`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchCreatePartitionsRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  ifNotExists?: boolean(name='IfNotExists'),
  needResult?: boolean(name='NeedResult'),
  partitionInputs?: [
    PartitionInput
  ](name='PartitionInputs'),
  tableName?: string(name='TableName'),
}

model BatchCreatePartitionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors'),
  partitions?: [
    Partition
  ](name='Partitions'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchCreatePartitionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchCreatePartitionsResponseBody(name='body'),
}

async function batchCreatePartitions(request: BatchCreatePartitionsRequest): BatchCreatePartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchCreatePartitionsWithOptions(request, headers, runtime);
}

async function batchCreatePartitionsWithOptions(request: BatchCreatePartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchCreatePartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifNotExists)) {
    body['IfNotExists'] = request.ifNotExists;
  }
  if (!Util.isUnset(request.needResult)) {
    body['NeedResult'] = request.needResult;
  }
  if (!Util.isUnset(request.partitionInputs)) {
    body['PartitionInputs'] = request.partitionInputs;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchCreatePartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/batchcreate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchCreateTablesRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  ifNotExists?: boolean(name='IfNotExists'),
  tableInputs?: [
    TableInput
  ](name='TableInputs'),
}

model BatchCreateTablesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tableErrors?: [
    TableError
  ](name='TableErrors'),
}

model BatchCreateTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchCreateTablesResponseBody(name='body'),
}

async function batchCreateTables(request: BatchCreateTablesRequest): BatchCreateTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchCreateTablesWithOptions(request, headers, runtime);
}

async function batchCreateTablesWithOptions(request: BatchCreateTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchCreateTablesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifNotExists)) {
    body['IfNotExists'] = request.ifNotExists;
  }
  if (!Util.isUnset(request.tableInputs)) {
    body['TableInputs'] = request.tableInputs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchCreateTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/batchcreate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchDeletePartitionsRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  ifExists?: boolean(name='IfExists'),
  partitionValueList?: [ 
{
values?: [ string ](name='Values'),
}
](name='PartitionValueList'),
  tableName?: string(name='TableName'),
}

model BatchDeletePartitionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchDeletePartitionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchDeletePartitionsResponseBody(name='body'),
}

async function batchDeletePartitions(request: BatchDeletePartitionsRequest): BatchDeletePartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchDeletePartitionsWithOptions(request, headers, runtime);
}

async function batchDeletePartitionsWithOptions(request: BatchDeletePartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchDeletePartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifExists)) {
    body['IfExists'] = request.ifExists;
  }
  if (!Util.isUnset(request.partitionValueList)) {
    body['PartitionValueList'] = request.partitionValueList;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeletePartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/batchdelete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchDeleteTableVersionsRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  versionIds?: [ int32 ](name='VersionIds'),
}

model BatchDeleteTableVersionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchDeleteTableVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchDeleteTableVersionsResponseBody(name='body'),
}

async function batchDeleteTableVersions(request: BatchDeleteTableVersionsRequest): BatchDeleteTableVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchDeleteTableVersionsWithOptions(request, headers, runtime);
}

async function batchDeleteTableVersionsWithOptions(request: BatchDeleteTableVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchDeleteTableVersionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }
  if (!Util.isUnset(request.versionIds)) {
    body['VersionIds'] = request.versionIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteTableVersions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/versions/batchdelete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchDeleteTablesRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  ifExists?: boolean(name='IfExists'),
  tableNames?: [ string ](name='TableNames'),
}

model BatchDeleteTablesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tableErrors?: [
    TableError
  ](name='TableErrors'),
}

model BatchDeleteTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchDeleteTablesResponseBody(name='body'),
}

async function batchDeleteTables(request: BatchDeleteTablesRequest): BatchDeleteTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchDeleteTablesWithOptions(request, headers, runtime);
}

async function batchDeleteTablesWithOptions(request: BatchDeleteTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchDeleteTablesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifExists)) {
    body['IfExists'] = request.ifExists;
  }
  if (!Util.isUnset(request.tableNames)) {
    body['TableNames'] = request.tableNames;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/batchdelete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchGetPartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId'),
  columnNames?: [ string ](name='ColumnNames'),
  databaseName?: string(name='DatabaseName'),
  partitionNames?: [ string ](name='PartitionNames'),
  tableName?: string(name='TableName'),
}

model BatchGetPartitionColumnStatisticsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  partitionStatisticsMap?: map[string][
    ColumnStatisticsObj
  ](name='PartitionStatisticsMap'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchGetPartitionColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchGetPartitionColumnStatisticsResponseBody(name='body'),
}

async function batchGetPartitionColumnStatistics(request: BatchGetPartitionColumnStatisticsRequest): BatchGetPartitionColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGetPartitionColumnStatisticsWithOptions(request, headers, runtime);
}

async function batchGetPartitionColumnStatisticsWithOptions(request: BatchGetPartitionColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchGetPartitionColumnStatisticsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.columnNames)) {
    body['ColumnNames'] = request.columnNames;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionNames)) {
    body['PartitionNames'] = request.partitionNames;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetPartitionColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/columnstatistics/batchget`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchGetPartitionsRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  isShareSd?: boolean(name='IsShareSd'),
  partitionValueList?: [ 
{
values?: [ string ](name='Values'),
}
](name='PartitionValueList'),
  tableName?: string(name='TableName'),
}

model BatchGetPartitionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs'),
  partitions?: [
    Partition
  ](name='Partitions'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchGetPartitionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchGetPartitionsResponseBody(name='body'),
}

async function batchGetPartitions(request: BatchGetPartitionsRequest): BatchGetPartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGetPartitionsWithOptions(request, headers, runtime);
}

async function batchGetPartitionsWithOptions(request: BatchGetPartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchGetPartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.isShareSd)) {
    body['IsShareSd'] = request.isShareSd;
  }
  if (!Util.isUnset(request.partitionValueList)) {
    body['PartitionValueList'] = request.partitionValueList;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetPartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/batchget`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchGetTablesRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  tableNames?: [ string ](name='TableNames'),
}

model BatchGetTablesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tableErrors?: [
    TableError
  ](name='TableErrors'),
  tables?: [
    Table
  ](name='Tables'),
}

model BatchGetTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchGetTablesResponseBody(name='body'),
}

async function batchGetTables(request: BatchGetTablesRequest): BatchGetTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGetTablesWithOptions(request, headers, runtime);
}

async function batchGetTablesWithOptions(request: BatchGetTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchGetTablesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableNames)) {
    body['TableNames'] = request.tableNames;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/batchget`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchGrantPermissionsRequest {
  catalogId?: string(name='CatalogId'),
  grantRevokeEntries?: [
    GrantRevokeEntry
  ](name='GrantRevokeEntries'),
  type?: string(name='Type'),
}

model BatchGrantPermissionsResponseBody = {
  batchGrantRevokeFailureResult?: [
  GrantRevokeFailureEntry
](name='BatchGrantRevokeFailureResult'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchGrantPermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchGrantPermissionsResponseBody(name='body'),
}

async function batchGrantPermissions(request: BatchGrantPermissionsRequest): BatchGrantPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGrantPermissionsWithOptions(request, headers, runtime);
}

async function batchGrantPermissionsWithOptions(request: BatchGrantPermissionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchGrantPermissionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.grantRevokeEntries)) {
    body['GrantRevokeEntries'] = request.grantRevokeEntries;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchGrantPermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/batchgrant`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchRevokePermissionsRequest {
  catalogId?: string(name='CatalogId'),
  grantRevokeEntries?: [
    GrantRevokeEntry
  ](name='GrantRevokeEntries'),
  type?: string(name='Type'),
}

model BatchRevokePermissionsResponseBody = {
  batchGrantRevokeFailureResult?: [
  GrantRevokeFailureEntry
](name='BatchGrantRevokeFailureResult'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchRevokePermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchRevokePermissionsResponseBody(name='body'),
}

async function batchRevokePermissions(request: BatchRevokePermissionsRequest): BatchRevokePermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchRevokePermissionsWithOptions(request, headers, runtime);
}

async function batchRevokePermissionsWithOptions(request: BatchRevokePermissionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchRevokePermissionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.grantRevokeEntries)) {
    body['GrantRevokeEntries'] = request.grantRevokeEntries;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchRevokePermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/batchrevoke`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchUpdatePartitionsRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  partitionInputs?: [
    PartitionInput
  ](name='PartitionInputs'),
  tableName?: string(name='TableName'),
}

model BatchUpdatePartitionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchUpdatePartitionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchUpdatePartitionsResponseBody(name='body'),
}

async function batchUpdatePartitions(request: BatchUpdatePartitionsRequest): BatchUpdatePartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchUpdatePartitionsWithOptions(request, headers, runtime);
}

async function batchUpdatePartitionsWithOptions(request: BatchUpdatePartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchUpdatePartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionInputs)) {
    body['PartitionInputs'] = request.partitionInputs;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchUpdatePartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/batchupdate`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchUpdateTablesRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  isAsync?: boolean(name='IsAsync'),
  tableInputs?: [
    TableInput
  ](name='TableInputs'),
}

model BatchUpdateTablesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tableErrors?: [
    TableError
  ](name='TableErrors'),
  taskId?: string(name='TaskId'),
}

model BatchUpdateTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchUpdateTablesResponseBody(name='body'),
}

async function batchUpdateTables(request: BatchUpdateTablesRequest): BatchUpdateTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchUpdateTablesWithOptions(request, headers, runtime);
}

async function batchUpdateTablesWithOptions(request: BatchUpdateTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchUpdateTablesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.isAsync)) {
    body['IsAsync'] = request.isAsync;
  }
  if (!Util.isUnset(request.tableInputs)) {
    body['TableInputs'] = request.tableInputs;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchUpdateTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/batchupdate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CancelQueryRequest {
  queryId?: string(name='QueryId'),
}

model CancelQueryResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelQueryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelQueryResponseBody(name='body'),
}

async function cancelQuery(request: CancelQueryRequest): CancelQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelQueryWithOptions(request, headers, runtime);
}

async function cancelQueryWithOptions(request: CancelQueryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelQueryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.queryId)) {
    query['QueryId'] = request.queryId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelQuery',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/cancelQuery`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CheckPermissionsRequest {
  body?: AccessRequest(name='Body'),
}

model CheckPermissionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckPermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckPermissionsResponseBody(name='body'),
}

async function checkPermissions(request: CheckPermissionsRequest): CheckPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkPermissionsWithOptions(request, headers, runtime);
}

async function checkPermissionsWithOptions(request: CheckPermissionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckPermissionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CheckPermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/check`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateCatalogRequest {
  catalogInput?: CatalogInput(name='CatalogInput'),
}

model CreateCatalogResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateCatalogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCatalogResponseBody(name='body'),
}

async function createCatalog(request: CreateCatalogRequest): CreateCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createCatalogWithOptions(request, headers, runtime);
}

async function createCatalogWithOptions(request: CreateCatalogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateCatalogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogInput)) {
    body['CatalogInput'] = request.catalogInput;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCatalog',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateDatabaseRequest {
  catalogId?: string(name='CatalogId'),
  databaseInput?: DatabaseInput(name='DatabaseInput'),
}

model CreateDatabaseResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDatabaseResponseBody(name='body'),
}

async function createDatabase(request: CreateDatabaseRequest): CreateDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDatabaseWithOptions(request, headers, runtime);
}

async function createDatabaseWithOptions(request: CreateDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDatabaseResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseInput)) {
    body['DatabaseInput'] = request.databaseInput;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDatabase',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateFunctionRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  functionInput?: FunctionInput(name='FunctionInput'),
}

model CreateFunctionResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFunctionResponseBody(name='body'),
}

async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFunctionWithOptions(request, headers, runtime);
}

async function createFunctionWithOptions(request: CreateFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionInput)) {
    body['FunctionInput'] = request.functionInput;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFunction',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateLockRequest {
  lockObjList?: [
    LockObj
  ](name='LockObjList'),
}

model CreateLockResponseBody = {
  code?: string(name='Code'),
  lockStatus?: LockStatus(name='LockStatus'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateLockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLockResponseBody(name='body'),
}

async function createLock(request: CreateLockRequest): CreateLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLockWithOptions(request, headers, runtime);
}

async function createLockWithOptions(request: CreateLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLockResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.lockObjList)) {
    body['LockObjList'] = request.lockObjList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreatePartitionRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  ifNotExists?: boolean(name='IfNotExists'),
  needResult?: boolean(name='NeedResult'),
  partitionInput?: PartitionInput(name='PartitionInput'),
  tableName?: string(name='TableName'),
}

model CreatePartitionResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  partition?: Partition(name='Partition'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreatePartitionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePartitionResponseBody(name='body'),
}

async function createPartition(request: CreatePartitionRequest): CreatePartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPartitionWithOptions(request, headers, runtime);
}

async function createPartitionWithOptions(request: CreatePartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePartitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifNotExists)) {
    body['IfNotExists'] = request.ifNotExists;
  }
  if (!Util.isUnset(request.needResult)) {
    body['NeedResult'] = request.needResult;
  }
  if (!Util.isUnset(request.partitionInput)) {
    body['PartitionInput'] = request.partitionInput;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePartition',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateRoleRequest {
  body?: RoleInput(name='body'),
}

model CreateRoleResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRoleResponseBody(name='body'),
}

async function createRole(request: CreateRoleRequest): CreateRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRoleWithOptions(request, headers, runtime);
}

async function createRoleWithOptions(request: CreateRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRoleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRole',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateTableRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  tableInput?: TableInput(name='TableInput'),
}

model CreateTableResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTableResponseBody(name='body'),
}

async function createTable(request: CreateTableRequest): CreateTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTableWithOptions(request, headers, runtime);
}

async function createTableWithOptions(request: CreateTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTableResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableInput)) {
    body['TableInput'] = request.tableInput;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteCatalogRequest {
  catalogId?: string(name='CatalogId'),
  isAsync?: boolean(name='IsAsync'),
  systemDebug?: string(name='SystemDebug'),
}

model DeleteCatalogResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model DeleteCatalogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCatalogResponseBody(name='body'),
}

async function deleteCatalog(request: DeleteCatalogRequest): DeleteCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteCatalogWithOptions(request, headers, runtime);
}

async function deleteCatalogWithOptions(request: DeleteCatalogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteCatalogResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.isAsync)) {
    query['IsAsync'] = request.isAsync;
  }
  if (!Util.isUnset(request.systemDebug)) {
    query['SystemDebug'] = request.systemDebug;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCatalog',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteDatabaseRequest {
  cascade?: boolean(name='Cascade'),
  catalogId?: string(name='CatalogId'),
  name?: string(name='Name'),
}

model DeleteDatabaseResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDatabaseResponseBody(name='body'),
}

async function deleteDatabase(request: DeleteDatabaseRequest): DeleteDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDatabaseWithOptions(request, headers, runtime);
}

async function deleteDatabaseWithOptions(request: DeleteDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDatabaseResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.cascade)) {
    query['Cascade'] = request.cascade;
  }
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDatabase',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteFunctionRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  functionName?: string(name='FunctionName'),
}

model DeleteFunctionResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFunctionResponseBody(name='body'),
}

async function deleteFunction(request: DeleteFunctionRequest): DeleteFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionWithOptions(request, headers, runtime);
}

async function deleteFunctionWithOptions(request: DeleteFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunction',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeletePartitionRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  ifExists?: boolean(name='IfExists'),
  partitionValues?: [ string ](name='PartitionValues'),
  tableName?: string(name='TableName'),
}

model DeletePartitionResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeletePartitionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePartitionResponseBody(name='body'),
}

async function deletePartition(request: DeletePartitionRequest): DeletePartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePartitionWithOptions(request, headers, runtime);
}

async function deletePartitionWithOptions(request: DeletePartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePartitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.ifExists)) {
    body['IfExists'] = request.ifExists;
  }
  if (!Util.isUnset(request.partitionValues)) {
    body['PartitionValues'] = request.partitionValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeletePartition',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeletePartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId'),
  columnNames?: [ string ](name='ColumnNames'),
  databaseName?: string(name='DatabaseName'),
  partitionNames?: [ string ](name='PartitionNames'),
  tableName?: string(name='TableName'),
}

model DeletePartitionColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId'),
  columnNamesShrink?: string(name='ColumnNames'),
  databaseName?: string(name='DatabaseName'),
  partitionNamesShrink?: string(name='PartitionNames'),
  tableName?: string(name='TableName'),
}

model DeletePartitionColumnStatisticsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeletePartitionColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePartitionColumnStatisticsResponseBody(name='body'),
}

async function deletePartitionColumnStatistics(request: DeletePartitionColumnStatisticsRequest): DeletePartitionColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePartitionColumnStatisticsWithOptions(request, headers, runtime);
}

async function deletePartitionColumnStatisticsWithOptions(tmpReq: DeletePartitionColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePartitionColumnStatisticsResponse {
  Util.validateModel(tmpReq);
  var request = new DeletePartitionColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  if (!Util.isUnset(tmpReq.partitionNames)) {
    request.partitionNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.partitionNames, 'PartitionNames', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.columnNamesShrink)) {
    query['ColumnNames'] = request.columnNamesShrink;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionNamesShrink)) {
    query['PartitionNames'] = request.partitionNamesShrink;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePartitionColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/columnstatistics`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteRoleRequest {
  roleName?: string(name='RoleName'),
}

model DeleteRoleResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRoleResponseBody(name='body'),
}

async function deleteRole(request: DeleteRoleRequest): DeleteRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRoleWithOptions(request, headers, runtime);
}

async function deleteRoleWithOptions(request: DeleteRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRoleResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.roleName)) {
    query['RoleName'] = request.roleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRole',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteTableRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
}

model DeleteTableResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTableResponseBody(name='body'),
}

async function deleteTable(request: DeleteTableRequest): DeleteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTableWithOptions(request, headers, runtime);
}

async function deleteTableWithOptions(request: DeleteTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTableResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteTableColumnStatisticsRequest {
  catalogId?: string(name='CatalogId'),
  columnNames?: [ string ](name='ColumnNames'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
}

model DeleteTableColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId'),
  columnNamesShrink?: string(name='ColumnNames'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
}

model DeleteTableColumnStatisticsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteTableColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTableColumnStatisticsResponseBody(name='body'),
}

async function deleteTableColumnStatistics(request: DeleteTableColumnStatisticsRequest): DeleteTableColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTableColumnStatisticsWithOptions(request, headers, runtime);
}

async function deleteTableColumnStatisticsWithOptions(tmpReq: DeleteTableColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTableColumnStatisticsResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteTableColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.columnNamesShrink)) {
    query['ColumnNames'] = request.columnNamesShrink;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTableColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/columnstatistics`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteTableVersionRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  versionId?: int32(name='VersionId'),
}

model DeleteTableVersionResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteTableVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTableVersionResponseBody(name='body'),
}

async function deleteTableVersion(request: DeleteTableVersionRequest): DeleteTableVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTableVersionWithOptions(request, headers, runtime);
}

async function deleteTableVersionWithOptions(request: DeleteTableVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTableVersionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTableVersion',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/versions`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      showName?: string(name='ShowName'),
      type?: string(name='Type'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(headers, runtime);
}

async function describeRegionsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/service/describeRegions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetAsyncTaskStatusRequest {
  catalogId?: string(name='CatalogId'),
  taskId?: string(name='TaskId'),
}

model GetAsyncTaskStatusResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskStatus?: TaskStatus(name='TaskStatus'),
}

model GetAsyncTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAsyncTaskStatusResponseBody(name='body'),
}

async function getAsyncTaskStatus(request: GetAsyncTaskStatusRequest): GetAsyncTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAsyncTaskStatusWithOptions(request, headers, runtime);
}

async function getAsyncTaskStatusWithOptions(request: GetAsyncTaskStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAsyncTaskStatusResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAsyncTaskStatus',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetCatalogRequest {
  catalogId?: string(name='CatalogId'),
}

model GetCatalogResponseBody = {
  catalog?: Catalog(name='Catalog'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetCatalogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCatalogResponseBody(name='body'),
}

async function getCatalog(request: GetCatalogRequest): GetCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCatalogWithOptions(request, headers, runtime);
}

async function getCatalogWithOptions(request: GetCatalogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCatalogResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCatalog',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetCatalogSettingsRequest {
  catalogId?: string(name='CatalogId'),
}

model GetCatalogSettingsResponseBody = {
  catalogSettings?: CatalogSettings(name='CatalogSettings'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetCatalogSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCatalogSettingsResponseBody(name='body'),
}

async function getCatalogSettings(request: GetCatalogSettingsRequest): GetCatalogSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCatalogSettingsWithOptions(request, headers, runtime);
}

async function getCatalogSettingsWithOptions(request: GetCatalogSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCatalogSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCatalogSettings',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/settings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetCatalogSummaryRequest {
  catalogId?: string(name='CatalogId'),
}

model GetCatalogSummaryResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  storageSummary?: StorageSummary(name='StorageSummary'),
  success?: boolean(name='Success'),
}

model GetCatalogSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCatalogSummaryResponseBody(name='body'),
}

/**
 * GetCatalogSummary
 */
async function getCatalogSummary(request: GetCatalogSummaryRequest): GetCatalogSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCatalogSummaryWithOptions(request, headers, runtime);
}

async function getCatalogSummaryWithOptions(request: GetCatalogSummaryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCatalogSummaryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCatalogSummary',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/summary`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetDatabaseRequest {
  catalogId?: string(name='CatalogId'),
  name?: string(name='Name'),
}

model GetDatabaseResponseBody = {
  code?: string(name='Code'),
  database?: Database(name='Database'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDatabaseResponseBody(name='body'),
}

async function getDatabase(request: GetDatabaseRequest): GetDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDatabaseWithOptions(request, headers, runtime);
}

async function getDatabaseWithOptions(request: GetDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDatabaseResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDatabase',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetDatabaseSummaryRequest {
  catalogId?: string(name='CatalogId'),
  name?: string(name='Name'),
}

model GetDatabaseSummaryResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  storageSummary?: StorageSummary(name='StorageSummary'),
  success?: boolean(name='Success'),
}

model GetDatabaseSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDatabaseSummaryResponseBody(name='body'),
}

/**
 * GetDatabaseSummary
 */
async function getDatabaseSummary(request: GetDatabaseSummaryRequest): GetDatabaseSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDatabaseSummaryWithOptions(request, headers, runtime);
}

async function getDatabaseSummaryWithOptions(request: GetDatabaseSummaryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDatabaseSummaryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDatabaseSummary',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/summary`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFunctionRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  functionName?: string(name='FunctionName'),
}

model GetFunctionResponseBody = {
  code?: string(name='Code'),
  function?: Function(name='Function'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFunctionResponseBody(name='body'),
}

async function getFunction(request: GetFunctionRequest): GetFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionWithOptions(request, headers, runtime);
}

async function getFunctionWithOptions(request: GetFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunction',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetLockRequest {
  lockId?: long(name='LockId'),
}

model GetLockResponseBody = {
  code?: string(name='Code'),
  lockStatus?: LockStatus(name='LockStatus'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetLockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLockResponseBody(name='body'),
}

async function getLock(request: GetLockRequest): GetLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLockWithOptions(request, headers, runtime);
}

async function getLockWithOptions(request: GetLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetLockResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lockId)) {
    query['LockId'] = request.lockId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPartitionRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  partitionValues?: [ string ](name='PartitionValues'),
  tableName?: string(name='TableName'),
}

model GetPartitionResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  partition?: Partition(name='Partition'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPartitionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPartitionResponseBody(name='body'),
}

async function getPartition(request: GetPartitionRequest): GetPartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPartitionWithOptions(request, headers, runtime);
}

async function getPartitionWithOptions(request: GetPartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetPartitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionValues)) {
    body['PartitionValues'] = request.partitionValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetPartition',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId'),
  columnNames?: [ string ](name='ColumnNames'),
  databaseName?: string(name='DatabaseName'),
  partitionNames?: [ string ](name='PartitionNames'),
  tableName?: string(name='TableName'),
}

model GetPartitionColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId'),
  columnNamesShrink?: string(name='ColumnNames'),
  databaseName?: string(name='DatabaseName'),
  partitionNamesShrink?: string(name='PartitionNames'),
  tableName?: string(name='TableName'),
}

model GetPartitionColumnStatisticsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  partitionStatisticsMap?: map[string][
    ColumnStatisticsObj
  ](name='PartitionStatisticsMap'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPartitionColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPartitionColumnStatisticsResponseBody(name='body'),
}

async function getPartitionColumnStatistics(request: GetPartitionColumnStatisticsRequest): GetPartitionColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPartitionColumnStatisticsWithOptions(request, headers, runtime);
}

async function getPartitionColumnStatisticsWithOptions(tmpReq: GetPartitionColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetPartitionColumnStatisticsResponse {
  Util.validateModel(tmpReq);
  var request = new GetPartitionColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  if (!Util.isUnset(tmpReq.partitionNames)) {
    request.partitionNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.partitionNames, 'PartitionNames', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.columnNamesShrink)) {
    query['ColumnNames'] = request.columnNamesShrink;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionNamesShrink)) {
    query['PartitionNames'] = request.partitionNamesShrink;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPartitionColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/columnstatistics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetQueryResultRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  queryId?: string(name='QueryId'),
}

model GetQueryResultResponseBody = {
  duration?: long(name='Duration'),
  endTime?: string(name='EndTime'),
  errorMessage?: string(name='ErrorMessage'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  id?: string(name='Id'),
  jobCompleted?: boolean(name='JobCompleted'),
  logs?: string(name='Logs'),
  owner?: long(name='Owner'),
  progress?: int32(name='Progress'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resultTmpDb?: string(name='ResultTmpDb'),
  resultTmpTable?: string(name='ResultTmpTable'),
  rowCount?: int32(name='RowCount'),
  rowCountOverLimit?: boolean(name='RowCountOverLimit'),
  rows?: string(name='Rows'),
  schema?: string(name='Schema'),
  sql?: string(name='Sql'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
  success?: boolean(name='Success'),
  totalBytesProcessed?: long(name='TotalBytesProcessed'),
}

model GetQueryResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetQueryResultResponseBody(name='body'),
}

async function getQueryResult(request: GetQueryResultRequest): GetQueryResultResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getQueryResultWithOptions(request, headers, runtime);
}

async function getQueryResultWithOptions(request: GetQueryResultRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetQueryResultResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryId)) {
    query['QueryId'] = request.queryId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetQueryResult',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/getQueryResult`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRegionStatusRequest {
  regionId?: string(name='RegionId'),
}

model GetRegionStatusResponseBody = {
  data?: {
    accountStatus?: string(name='AccountStatus'),
    isDependencyReady?: boolean(name='IsDependencyReady'),
    isDlfServiceOpen?: boolean(name='IsDlfServiceOpen'),
    regionId?: string(name='RegionId'),
    regionStatus?: string(name='RegionStatus'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetRegionStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRegionStatusResponseBody(name='body'),
}

async function getRegionStatus(request: GetRegionStatusRequest): GetRegionStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRegionStatusWithOptions(request, headers, runtime);
}

async function getRegionStatusWithOptions(request: GetRegionStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRegionStatusResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRegionStatus',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/service/getRegionStatus`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRoleRequest {
  roleName?: string(name='RoleName'),
}

model GetRoleResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  role?: Role(name='Role'),
  success?: boolean(name='Success'),
}

model GetRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRoleResponseBody(name='body'),
}

async function getRole(request: GetRoleRequest): GetRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRoleWithOptions(request, headers, runtime);
}

async function getRoleWithOptions(request: GetRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRoleResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.roleName)) {
    query['RoleName'] = request.roleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRole',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetServiceStatusRequest {
  regionId?: string(name='RegionId'),
}

model GetServiceStatusResponseBody = {
  data?: {
    hasRamPermissions?: boolean(name='HasRamPermissions'),
    isDlfServiceOpen?: boolean(name='IsDlfServiceOpen'),
    isOssOpen?: boolean(name='IsOssOpen'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceStatusResponseBody(name='body'),
}

async function getServiceStatus(request: GetServiceStatusRequest): GetServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceStatusWithOptions(request, headers, runtime);
}

async function getServiceStatusWithOptions(request: GetServiceStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceStatusResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceStatus',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/service/getServiceStatus`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTableRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
}

model GetTableResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  table?: Table(name='Table'),
}

model GetTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTableResponseBody(name='body'),
}

async function getTable(request: GetTableRequest): GetTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableWithOptions(request, headers, runtime);
}

async function getTableWithOptions(request: GetTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTableColumnStatisticsRequest {
  catalogId?: string(name='CatalogId'),
  columnNames?: [ string ](name='ColumnNames'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
}

model GetTableColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId'),
  columnNamesShrink?: string(name='ColumnNames'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
}

model GetTableColumnStatisticsResponseBody = {
  code?: string(name='Code'),
  columnStatisticsObjList?: [
    ColumnStatisticsObj
  ](name='ColumnStatisticsObjList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTableColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTableColumnStatisticsResponseBody(name='body'),
}

async function getTableColumnStatistics(request: GetTableColumnStatisticsRequest): GetTableColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableColumnStatisticsWithOptions(request, headers, runtime);
}

async function getTableColumnStatisticsWithOptions(tmpReq: GetTableColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableColumnStatisticsResponse {
  Util.validateModel(tmpReq);
  var request = new GetTableColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.columnNamesShrink)) {
    query['ColumnNames'] = request.columnNamesShrink;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTableColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/columnstatistics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTableProfileRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
}

model GetTableProfileResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tableProfile?: TableProfile(name='TableProfile'),
}

model GetTableProfileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTableProfileResponseBody(name='body'),
}

async function getTableProfile(request: GetTableProfileRequest): GetTableProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableProfileWithOptions(request, headers, runtime);
}

async function getTableProfileWithOptions(request: GetTableProfileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableProfileResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTableProfile',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/metastorehouse/catalog/database/tableprofile`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTableVersionRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
  versionId?: int32(name='VersionId'),
}

model GetTableVersionResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tableVersion?: TableVersion(name='TableVersion'),
}

model GetTableVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTableVersionResponseBody(name='body'),
}

async function getTableVersion(request: GetTableVersionRequest): GetTableVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableVersionWithOptions(request, headers, runtime);
}

async function getTableVersionWithOptions(request: GetTableVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableVersionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTableVersion',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GrantPermissionsRequest {
  accesses?: [ string ](name='Accesses'),
  catalogId?: string(name='CatalogId'),
  delegateAccesses?: [ string ](name='DelegateAccesses'),
  metaResource?: MetaResource(name='MetaResource'),
  principal?: Principal(name='Principal'),
  type?: string(name='Type'),
}

model GrantPermissionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GrantPermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GrantPermissionsResponseBody(name='body'),
}

async function grantPermissions(request: GrantPermissionsRequest): GrantPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return grantPermissionsWithOptions(request, headers, runtime);
}

async function grantPermissionsWithOptions(request: GrantPermissionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GrantPermissionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accesses)) {
    body['Accesses'] = request.accesses;
  }
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.delegateAccesses)) {
    body['DelegateAccesses'] = request.delegateAccesses;
  }
  if (!Util.isUnset(request.metaResource)) {
    body['MetaResource'] = request.metaResource;
  }
  if (!Util.isUnset(request.principal)) {
    body['Principal'] = request.principal;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GrantPermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/grant`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GrantRoleToUsersRequest {
  roleName?: string(name='RoleName'),
  users?: [
Principal
](name='Users'),
}

model GrantRoleToUsersResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GrantRoleToUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GrantRoleToUsersResponseBody(name='body'),
}

async function grantRoleToUsers(request: GrantRoleToUsersRequest): GrantRoleToUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return grantRoleToUsersWithOptions(request, headers, runtime);
}

async function grantRoleToUsersWithOptions(request: GrantRoleToUsersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GrantRoleToUsersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.roleName)) {
    body['RoleName'] = request.roleName;
  }
  if (!Util.isUnset(request.users)) {
    body['Users'] = request.users;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GrantRoleToUsers',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/grantusers`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GrantRolesToUserRequest {
  roleNames?: [ string ](name='RoleNames'),
  user?: Principal(name='User'),
}

model GrantRolesToUserResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GrantRolesToUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GrantRolesToUserResponseBody(name='body'),
}

async function grantRolesToUser(request: GrantRolesToUserRequest): GrantRolesToUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return grantRolesToUserWithOptions(request, headers, runtime);
}

async function grantRolesToUserWithOptions(request: GrantRolesToUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GrantRolesToUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.roleNames)) {
    body['RoleNames'] = request.roleNames;
  }
  if (!Util.isUnset(request.user)) {
    body['User'] = request.user;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GrantRolesToUser',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/grantroles`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListCatalogsRequest {
  idPattern?: string(name='IdPattern'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize'),
}

model ListCatalogsResponseBody = {
  catalogs?: [
    Catalog
  ](name='Catalogs'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListCatalogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCatalogsResponseBody(name='body'),
}

async function listCatalogs(request: ListCatalogsRequest): ListCatalogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCatalogsWithOptions(request, headers, runtime);
}

async function listCatalogsWithOptions(request: ListCatalogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCatalogsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.idPattern)) {
    query['IdPattern'] = request.idPattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCatalogs',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDatabasesRequest {
  catalogId?: string(name='CatalogId'),
  namePattern?: string(name='NamePattern'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize'),
}

model ListDatabasesResponseBody = {
  code?: string(name='Code'),
  databases?: [
    Database
  ](name='Databases'),
  message?: string(name='Message'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDatabasesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDatabasesResponseBody(name='body'),
}

async function listDatabases(request: ListDatabasesRequest): ListDatabasesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDatabasesWithOptions(request, headers, runtime);
}

async function listDatabasesWithOptions(request: ListDatabasesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDatabasesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.namePattern)) {
    query['NamePattern'] = request.namePattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDatabases',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFunctionNamesRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  functionNamePattern?: string(name='FunctionNamePattern'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize'),
}

model ListFunctionNamesResponseBody = {
  code?: string(name='Code'),
  functionNames?: [ string ](name='FunctionNames'),
  message?: string(name='Message'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListFunctionNamesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFunctionNamesResponseBody(name='body'),
}

async function listFunctionNames(request: ListFunctionNamesRequest): ListFunctionNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionNamesWithOptions(request, headers, runtime);
}

async function listFunctionNamesWithOptions(request: ListFunctionNamesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionNamesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionNamePattern)) {
    query['FunctionNamePattern'] = request.functionNamePattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctionNames',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions/names`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFunctionsRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  functionNamePattern?: string(name='FunctionNamePattern'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize'),
}

model ListFunctionsResponseBody = {
  code?: string(name='Code'),
  functions?: [
    Function
  ](name='Functions'),
  message?: string(name='Message'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListFunctionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFunctionsResponseBody(name='body'),
}

async function listFunctions(request: ListFunctionsRequest): ListFunctionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionsWithOptions(request, headers, runtime);
}

async function listFunctionsWithOptions(request: ListFunctionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionNamePattern)) {
    query['FunctionNamePattern'] = request.functionNamePattern;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPartitionNamesRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize'),
  partialPartValues?: [ string ](name='PartialPartValues'),
  tableName?: string(name='TableName'),
}

model ListPartitionNamesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nextPageToken?: string(name='NextPageToken'),
  partitionNames?: [ string ](name='PartitionNames'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListPartitionNamesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPartitionNamesResponseBody(name='body'),
}

async function listPartitionNames(request: ListPartitionNamesRequest): ListPartitionNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionNamesWithOptions(request, headers, runtime);
}

async function listPartitionNamesWithOptions(request: ListPartitionNamesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPartitionNamesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    body['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.partialPartValues)) {
    body['PartialPartValues'] = request.partialPartValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPartitionNames',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/names`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPartitionsRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  isShareSd?: boolean(name='IsShareSd'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize'),
  partialPartValues?: [ string ](name='PartialPartValues'),
  tableName?: string(name='TableName'),
}

model ListPartitionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nextPageToken?: string(name='NextPageToken'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs'),
  partitions?: [
    Partition
  ](name='Partitions'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListPartitionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPartitionsResponseBody(name='body'),
}

async function listPartitions(request: ListPartitionsRequest): ListPartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionsWithOptions(request, headers, runtime);
}

async function listPartitionsWithOptions(request: ListPartitionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPartitionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.isShareSd)) {
    body['IsShareSd'] = request.isShareSd;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    body['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.partialPartValues)) {
    body['PartialPartValues'] = request.partialPartValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPartitionsByExprResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function listPartitionsByExpr(): ListPartitionsByExprResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionsByExprWithOptions(headers, runtime);
}

async function listPartitionsByExprWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListPartitionsByExprResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListPartitionsByExpr',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/listbyexpr`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ListPartitionsByFilterRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  filter?: string(name='Filter'),
  isShareSd?: boolean(name='IsShareSd'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize'),
  tableName?: string(name='TableName'),
}

model ListPartitionsByFilterResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nextPageToken?: string(name='NextPageToken'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs'),
  partitions?: [
    Partition
  ](name='Partitions'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListPartitionsByFilterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPartitionsByFilterResponseBody(name='body'),
}

async function listPartitionsByFilter(request: ListPartitionsByFilterRequest): ListPartitionsByFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionsByFilterWithOptions(request, headers, runtime);
}

async function listPartitionsByFilterWithOptions(request: ListPartitionsByFilterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPartitionsByFilterResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.filter)) {
    body['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.isShareSd)) {
    body['IsShareSd'] = request.isShareSd;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    body['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPartitionsByFilter',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/listbyfilter`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPermissionsRequest {
  catalogId?: string(name='CatalogId'),
  isListUserRolePermissions?: boolean(name='IsListUserRolePermissions'),
  metaResource?: MetaResource(name='MetaResource'),
  metaResourceType?: string(name='MetaResourceType'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize'),
  principal?: Principal(name='Principal'),
  type?: string(name='Type'),
}

model ListPermissionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nextPageToken?: string(name='NextPageToken'),
  principalResourcePermissionsList?: [
  PrincipalResourcePermissions
](name='PrincipalResourcePermissionsList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListPermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPermissionsResponseBody(name='body'),
}

async function listPermissions(request: ListPermissionsRequest): ListPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPermissionsWithOptions(request, headers, runtime);
}

async function listPermissionsWithOptions(request: ListPermissionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPermissionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.isListUserRolePermissions)) {
    body['IsListUserRolePermissions'] = request.isListUserRolePermissions;
  }
  if (!Util.isUnset(request.metaResource)) {
    body['MetaResource'] = request.metaResource;
  }
  if (!Util.isUnset(request.metaResourceType)) {
    body['MetaResourceType'] = request.metaResourceType;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    body['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.principal)) {
    body['Principal'] = request.principal;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRoleUsersRequest {
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize'),
  roleName?: string(name='RoleName'),
  userNamePattern?: string(name='UserNamePattern'),
}

model ListRoleUsersResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  userRoles?: [
  UserRole
](name='UserRoles'),
}

model ListRoleUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRoleUsersResponseBody(name='body'),
}

async function listRoleUsers(request: ListRoleUsersRequest): ListRoleUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRoleUsersWithOptions(request, headers, runtime);
}

async function listRoleUsersWithOptions(request: ListRoleUsersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRoleUsersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.roleName)) {
    query['RoleName'] = request.roleName;
  }
  if (!Util.isUnset(request.userNamePattern)) {
    query['UserNamePattern'] = request.userNamePattern;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRoleUsers',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/roleusers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRolesRequest {
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize'),
  roleNamePattern?: string(name='RoleNamePattern'),
}

model ListRolesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
  roles?: [
  Role
](name='Roles'),
  success?: boolean(name='Success'),
}

model ListRolesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRolesResponseBody(name='body'),
}

async function listRoles(request: ListRolesRequest): ListRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRolesWithOptions(request, headers, runtime);
}

async function listRolesWithOptions(request: ListRolesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRolesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.roleNamePattern)) {
    query['RoleNamePattern'] = request.roleNamePattern;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRoles',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTableNamesRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize'),
  tableNamePattern?: string(name='TableNamePattern'),
  tableType?: string(name='TableType'),
}

model ListTableNamesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tableNames?: [ string ](name='TableNames'),
}

model ListTableNamesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTableNamesResponseBody(name='body'),
}

async function listTableNames(request: ListTableNamesRequest): ListTableNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTableNamesWithOptions(request, headers, runtime);
}

async function listTableNamesWithOptions(request: ListTableNamesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTableNamesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tableNamePattern)) {
    query['TableNamePattern'] = request.tableNamePattern;
  }
  if (!Util.isUnset(request.tableType)) {
    query['TableType'] = request.tableType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTableNames',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/names`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTableVersionsRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize'),
  tableName?: string(name='TableName'),
}

model ListTableVersionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tableVersions?: [
    TableVersion
  ](name='TableVersions'),
}

model ListTableVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTableVersionsResponseBody(name='body'),
}

async function listTableVersions(request: ListTableVersionsRequest): ListTableVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTableVersionsWithOptions(request, headers, runtime);
}

async function listTableVersionsWithOptions(request: ListTableVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTableVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTableVersions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/versions/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTablesRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize'),
  tableNamePattern?: string(name='TableNamePattern'),
  tableType?: string(name='TableType'),
}

model ListTablesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tables?: [
    Table
  ](name='Tables'),
}

model ListTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTablesResponseBody(name='body'),
}

async function listTables(request: ListTablesRequest): ListTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTablesWithOptions(request, headers, runtime);
}

async function listTablesWithOptions(request: ListTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTablesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tableNamePattern)) {
    query['TableNamePattern'] = request.tableNamePattern;
  }
  if (!Util.isUnset(request.tableType)) {
    query['TableType'] = request.tableType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/databases/tables/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListUserRolesRequest {
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize'),
  principalArn?: string(name='PrincipalArn'),
  roleNamePattern?: string(name='RoleNamePattern'),
}

model ListUserRolesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  userRoles?: [
  UserRole
](name='UserRoles'),
}

model ListUserRolesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserRolesResponseBody(name='body'),
}

async function listUserRoles(request: ListUserRolesRequest): ListUserRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUserRolesWithOptions(request, headers, runtime);
}

async function listUserRolesWithOptions(request: ListUserRolesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListUserRolesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.principalArn)) {
    query['PrincipalArn'] = request.principalArn;
  }
  if (!Util.isUnset(request.roleNamePattern)) {
    query['RoleNamePattern'] = request.roleNamePattern;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserRoles',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/userroles`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RefreshLockRequest {
  lockId?: long(name='LockId'),
}

model RefreshLockResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RefreshLockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefreshLockResponseBody(name='body'),
}

async function refreshLock(request: RefreshLockRequest): RefreshLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return refreshLockWithOptions(request, headers, runtime);
}

async function refreshLockWithOptions(request: RefreshLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RefreshLockResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lockId)) {
    query['LockId'] = request.lockId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RenamePartitionRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  partitionInput?: PartitionInput(name='PartitionInput'),
  partitionValues?: [ string ](name='PartitionValues'),
  tableName?: string(name='TableName'),
}

model RenamePartitionResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RenamePartitionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenamePartitionResponseBody(name='body'),
}

async function renamePartition(request: RenamePartitionRequest): RenamePartitionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renamePartitionWithOptions(request, headers, runtime);
}

async function renamePartitionWithOptions(request: RenamePartitionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenamePartitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.partitionInput)) {
    body['PartitionInput'] = request.partitionInput;
  }
  if (!Util.isUnset(request.partitionValues)) {
    body['PartitionValues'] = request.partitionValues;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RenamePartition',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/rename`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RenameTableRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  isAsync?: boolean(name='IsAsync'),
  tableInput?: TableInput(name='TableInput'),
  tableName?: string(name='TableName'),
}

model RenameTableResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model RenameTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenameTableResponseBody(name='body'),
}

async function renameTable(request: RenameTableRequest): RenameTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renameTableWithOptions(request, headers, runtime);
}

async function renameTableWithOptions(request: RenameTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenameTableResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.isAsync)) {
    body['IsAsync'] = request.isAsync;
  }
  if (!Util.isUnset(request.tableInput)) {
    body['TableInput'] = request.tableInput;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RenameTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/rename`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RevokePermissionsRequest {
  accesses?: [ string ](name='Accesses'),
  catalogId?: string(name='CatalogId'),
  delegateAccesses?: [ string ](name='DelegateAccesses'),
  metaResource?: MetaResource(name='MetaResource'),
  principal?: Principal(name='Principal'),
  type?: string(name='Type'),
}

model RevokePermissionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RevokePermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokePermissionsResponseBody(name='body'),
}

async function revokePermissions(request: RevokePermissionsRequest): RevokePermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return revokePermissionsWithOptions(request, headers, runtime);
}

async function revokePermissionsWithOptions(request: RevokePermissionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RevokePermissionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accesses)) {
    body['Accesses'] = request.accesses;
  }
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.delegateAccesses)) {
    body['DelegateAccesses'] = request.delegateAccesses;
  }
  if (!Util.isUnset(request.metaResource)) {
    body['MetaResource'] = request.metaResource;
  }
  if (!Util.isUnset(request.principal)) {
    body['Principal'] = request.principal;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RevokePermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/revoke`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RevokeRoleFromUsersRequest {
  roleName?: string(name='RoleName'),
  users?: [
Principal
](name='Users'),
}

model RevokeRoleFromUsersResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RevokeRoleFromUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokeRoleFromUsersResponseBody(name='body'),
}

async function revokeRoleFromUsers(request: RevokeRoleFromUsersRequest): RevokeRoleFromUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return revokeRoleFromUsersWithOptions(request, headers, runtime);
}

async function revokeRoleFromUsersWithOptions(request: RevokeRoleFromUsersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RevokeRoleFromUsersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.roleName)) {
    body['RoleName'] = request.roleName;
  }
  if (!Util.isUnset(request.users)) {
    body['Users'] = request.users;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RevokeRoleFromUsers',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/revokeusers`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RevokeRolesFromUserRequest {
  roleNames?: [ string ](name='RoleNames'),
  user?: Principal(name='User'),
}

model RevokeRolesFromUserResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RevokeRolesFromUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokeRolesFromUserResponseBody(name='body'),
}

async function revokeRolesFromUser(request: RevokeRolesFromUserRequest): RevokeRolesFromUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return revokeRolesFromUserWithOptions(request, headers, runtime);
}

async function revokeRolesFromUserWithOptions(request: RevokeRolesFromUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RevokeRolesFromUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.roleNames)) {
    body['RoleNames'] = request.roleNames;
  }
  if (!Util.isUnset(request.user)) {
    body['User'] = request.user;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RevokeRolesFromUser',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/revokeroles`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RunMigrationWorkflowRequest {
  instanceId?: string(name='InstanceId'),
}

model RunMigrationWorkflowResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RunMigrationWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RunMigrationWorkflowResponseBody(name='body'),
}

async function runMigrationWorkflow(request: RunMigrationWorkflowRequest): RunMigrationWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return runMigrationWorkflowWithOptions(request, headers, runtime);
}

async function runMigrationWorkflowWithOptions(request: RunMigrationWorkflowRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RunMigrationWorkflowResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RunMigrationWorkflow',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/migration/workflow/run`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SearchRequest {
  catalogId?: string(name='CatalogId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  searchText?: string(name='SearchText'),
  searchType?: string(name='SearchType'),
  sortCriteria?: [
    SortCriterion
  ](name='SortCriteria'),
}

model SearchResponseBody = {
  code?: string(name='Code'),
  databaseResult?: {
    databases?: [ 
      {
        database?: Database(name='Database'),
        highLightList?: [
          HighLight
        ](name='HighLightList'),
      }
    ](name='Databases'),
    totalCount?: long(name='TotalCount'),
  }(name='DatabaseResult'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tableResult?: {
    tables?: [ 
      {
        highLightList?: [
          HighLight
        ](name='HighLightList'),
        table?: Table(name='Table'),
      }
    ](name='Tables'),
    totalCount?: long(name='TotalCount'),
  }(name='TableResult'),
}

model SearchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchResponseBody(name='body'),
}

async function search(request: SearchRequest): SearchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchWithOptions(request, headers, runtime);
}

async function searchWithOptions(request: SearchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchText)) {
    body['SearchText'] = request.searchText;
  }
  if (!Util.isUnset(request.searchType)) {
    body['SearchType'] = request.searchType;
  }
  if (!Util.isUnset(request.sortCriteria)) {
    body['SortCriteria'] = request.sortCriteria;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'Search',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SearchAcrossCatalogRequest {
  catalogIds?: [ string ](name='CatalogIds'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  searchText?: string(name='SearchText'),
  searchTypes?: [ string ](name='SearchTypes'),
  sortCriteria?: [
    SortCriterion
  ](name='SortCriteria'),
}

model SearchAcrossCatalogResponseBody = {
  catalogResult?: {
    catalogs?: [ 
      {
        catalog?: Catalog(name='Catalog'),
        highLightList?: [
          HighLight
        ](name='HighLightList'),
      }
    ](name='Catalogs'),
    totalCount?: long(name='TotalCount'),
  }(name='CatalogResult'),
  code?: string(name='Code'),
  databaseResult?: {
    databases?: [ 
      {
        database?: Database(name='Database'),
        highLightList?: [
          HighLight
        ](name='HighLightList'),
      }
    ](name='Databases'),
    totalCount?: long(name='TotalCount'),
  }(name='DatabaseResult'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tableResult?: {
    tables?: [ 
      {
        highLightList?: [
          HighLight
        ](name='HighLightList'),
        table?: Table(name='Table'),
      }
    ](name='Tables'),
    totalCount?: long(name='TotalCount'),
  }(name='TableResult'),
}

model SearchAcrossCatalogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchAcrossCatalogResponseBody(name='body'),
}

async function searchAcrossCatalog(request: SearchAcrossCatalogRequest): SearchAcrossCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchAcrossCatalogWithOptions(request, headers, runtime);
}

async function searchAcrossCatalogWithOptions(request: SearchAcrossCatalogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchAcrossCatalogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogIds)) {
    body['CatalogIds'] = request.catalogIds;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchText)) {
    body['SearchText'] = request.searchText;
  }
  if (!Util.isUnset(request.searchTypes)) {
    body['SearchTypes'] = request.searchTypes;
  }
  if (!Util.isUnset(request.sortCriteria)) {
    body['SortCriteria'] = request.sortCriteria;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchAcrossCatalog',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/search/search-across-catalog`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopMigrationWorkflowRequest {
  instanceId?: string(name='InstanceId'),
}

model StopMigrationWorkflowResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StopMigrationWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopMigrationWorkflowResponseBody(name='body'),
}

async function stopMigrationWorkflow(request: StopMigrationWorkflowRequest): StopMigrationWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopMigrationWorkflowWithOptions(request, headers, runtime);
}

async function stopMigrationWorkflowWithOptions(request: StopMigrationWorkflowRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopMigrationWorkflowResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopMigrationWorkflow',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/migration/workflow/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SubmitQueryRequest {
  sql?: string(name='sql'),
  workspaceId?: string(name='workspaceId'),
}

model SubmitQueryResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubmitQueryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitQueryResponseBody(name='body'),
}

async function submitQuery(request: SubmitQueryRequest): SubmitQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return submitQueryWithOptions(request, headers, runtime);
}

async function submitQueryWithOptions(request: SubmitQueryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SubmitQueryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.sql)) {
    body['sql'] = request.sql;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['workspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SubmitQuery',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/submitQueryRequestBody`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UnLockRequest {
  lockId?: long(name='LockId'),
}

model UnLockResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UnLockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnLockResponseBody(name='body'),
}

async function unLock(request: UnLockRequest): UnLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unLockWithOptions(request, headers, runtime);
}

async function unLockWithOptions(request: UnLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UnLockResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lockId)) {
    query['LockId'] = request.lockId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateCatalogRequest {
  catalogInput?: CatalogInput(name='CatalogInput'),
}

model UpdateCatalogResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateCatalogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCatalogResponseBody(name='body'),
}

async function updateCatalog(request: UpdateCatalogRequest): UpdateCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCatalogWithOptions(request, headers, runtime);
}

async function updateCatalogWithOptions(request: UpdateCatalogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCatalogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogInput)) {
    body['CatalogInput'] = request.catalogInput;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCatalog',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateCatalogSettingsRequest {
  catalogId?: string(name='CatalogId'),
  catalogSettings?: CatalogSettings(name='CatalogSettings'),
}

model UpdateCatalogSettingsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateCatalogSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCatalogSettingsResponseBody(name='body'),
}

async function updateCatalogSettings(request: UpdateCatalogSettingsRequest): UpdateCatalogSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCatalogSettingsWithOptions(request, headers, runtime);
}

async function updateCatalogSettingsWithOptions(request: UpdateCatalogSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCatalogSettingsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.catalogSettings)) {
    body['CatalogSettings'] = request.catalogSettings;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCatalogSettings',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/settings`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateDatabaseRequest {
  catalogId?: string(name='CatalogId'),
  databaseInput?: DatabaseInput(name='DatabaseInput'),
  name?: string(name='Name'),
}

model UpdateDatabaseResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDatabaseResponseBody(name='body'),
}

async function updateDatabase(request: UpdateDatabaseRequest): UpdateDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDatabaseWithOptions(request, headers, runtime);
}

async function updateDatabaseWithOptions(request: UpdateDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDatabaseResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseInput)) {
    body['DatabaseInput'] = request.databaseInput;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDatabase',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateFunctionRequest {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  functionInput?: FunctionInput(name='FunctionInput'),
  functionName?: string(name='FunctionName'),
}

model UpdateFunctionResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFunctionResponseBody(name='body'),
}

async function updateFunction(request: UpdateFunctionRequest): UpdateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFunctionWithOptions(request, headers, runtime);
}

async function updateFunctionWithOptions(request: UpdateFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.functionInput)) {
    body['FunctionInput'] = request.functionInput;
  }
  if (!Util.isUnset(request.functionName)) {
    body['FunctionName'] = request.functionName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFunction',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdatePartitionColumnStatisticsRequest {
  updateTablePartitionColumnStatisticsRequest?: UpdateTablePartitionColumnStatisticsRequest(name='UpdateTablePartitionColumnStatisticsRequest'),
}

model UpdatePartitionColumnStatisticsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdatePartitionColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePartitionColumnStatisticsResponseBody(name='body'),
}

async function updatePartitionColumnStatistics(request: UpdatePartitionColumnStatisticsRequest): UpdatePartitionColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePartitionColumnStatisticsWithOptions(request, headers, runtime);
}

async function updatePartitionColumnStatisticsWithOptions(request: UpdatePartitionColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePartitionColumnStatisticsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.updateTablePartitionColumnStatisticsRequest),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePartitionColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/columnstatistics`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdatePermissionsRequest {
  accesses?: [ string ](name='Accesses'),
  catalogId?: string(name='CatalogId'),
  delegateAccesses?: [ string ](name='DelegateAccesses'),
  metaResource?: MetaResource(name='MetaResource'),
  principal?: Principal(name='Principal'),
  type?: string(name='Type'),
}

model UpdatePermissionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdatePermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePermissionsResponseBody(name='body'),
}

async function updatePermissions(request: UpdatePermissionsRequest): UpdatePermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePermissionsWithOptions(request, headers, runtime);
}

async function updatePermissionsWithOptions(request: UpdatePermissionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePermissionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accesses)) {
    body['Accesses'] = request.accesses;
  }
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.delegateAccesses)) {
    body['DelegateAccesses'] = request.delegateAccesses;
  }
  if (!Util.isUnset(request.metaResource)) {
    body['MetaResource'] = request.metaResource;
  }
  if (!Util.isUnset(request.principal)) {
    body['Principal'] = request.principal;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateRoleRequest {
  roleInput?: RoleInput(name='RoleInput'),
  roleName?: string(name='RoleName'),
}

model UpdateRoleResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRoleResponseBody(name='body'),
}

async function updateRole(request: UpdateRoleRequest): UpdateRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRoleWithOptions(request, headers, runtime);
}

async function updateRoleWithOptions(request: UpdateRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRoleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.roleInput)) {
    body['RoleInput'] = request.roleInput;
  }
  if (!Util.isUnset(request.roleName)) {
    body['RoleName'] = request.roleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRole',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateRoleUsersRequest {
  roleName?: string(name='RoleName'),
  users?: [
Principal
](name='Users'),
}

model UpdateRoleUsersResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateRoleUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRoleUsersResponseBody(name='body'),
}

async function updateRoleUsers(request: UpdateRoleUsersRequest): UpdateRoleUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRoleUsersWithOptions(request, headers, runtime);
}

async function updateRoleUsersWithOptions(request: UpdateRoleUsersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRoleUsersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.roleName)) {
    body['RoleName'] = request.roleName;
  }
  if (!Util.isUnset(request.users)) {
    body['Users'] = request.users;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRoleUsers',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/updateroleusers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateTableRequest {
  allowPartitionKeyChange?: boolean(name='AllowPartitionKeyChange'),
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  isAsync?: boolean(name='IsAsync'),
  skipArchive?: boolean(name='SkipArchive'),
  tableInput?: TableInput(name='TableInput'),
  tableName?: string(name='TableName'),
}

model UpdateTableResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model UpdateTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTableResponseBody(name='body'),
}

async function updateTable(request: UpdateTableRequest): UpdateTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTableWithOptions(request, headers, runtime);
}

async function updateTableWithOptions(request: UpdateTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTableResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.allowPartitionKeyChange)) {
    body['AllowPartitionKeyChange'] = request.allowPartitionKeyChange;
  }
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.isAsync)) {
    body['IsAsync'] = request.isAsync;
  }
  if (!Util.isUnset(request.skipArchive)) {
    body['SkipArchive'] = request.skipArchive;
  }
  if (!Util.isUnset(request.tableInput)) {
    body['TableInput'] = request.tableInput;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateTableColumnStatisticsRequest {
  updateTablePartitionColumnStatisticsRequest?: UpdateTablePartitionColumnStatisticsRequest(name='UpdateTablePartitionColumnStatisticsRequest'),
}

model UpdateTableColumnStatisticsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateTableColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTableColumnStatisticsResponseBody(name='body'),
}

async function updateTableColumnStatistics(request: UpdateTableColumnStatisticsRequest): UpdateTableColumnStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTableColumnStatisticsWithOptions(request, headers, runtime);
}

async function updateTableColumnStatisticsWithOptions(request: UpdateTableColumnStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTableColumnStatisticsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.updateTablePartitionColumnStatisticsRequest),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTableColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/columnstatistics`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model TableExtendedPrivilegesRolePrivilegesValue = {
  createTime?: int32(name='CreateTime'),
  grantOption?: boolean(name='GrantOption'),
  grantor?: string(name='Grantor'),
  grantorType?: string(name='GrantorType'),
  privilege?: string(name='Privilege'),
}

model TableExtendedPrivilegesUserPrivilegesValue = {
  createTime?: int32(name='CreateTime'),
  grantOption?: boolean(name='GrantOption'),
  grantor?: string(name='Grantor'),
  grantorType?: string(name='GrantorType'),
  privilege?: string(name='Privilege'),
}

model TableExtendedPrivilegesGroupPrivilegesValue = {
  createTime?: int32(name='CreateTime'),
  grantOption?: boolean(name='GrantOption'),
  grantor?: string(name='Grantor'),
  grantorType?: string(name='GrantorType'),
  privilege?: string(name='Privilege'),
}

