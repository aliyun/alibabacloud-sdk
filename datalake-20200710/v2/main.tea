/**
 *
 */
import OpenApi;
import OpenApi.OpenApiUtil;

extends OpenApi;


init(config: OpenApiUtil.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    'ap-northeast-1' = 'datalake-daily.aliyuncs.com',
    'ap-northeast-2-pop' = 'datalake-daily.aliyuncs.com',
    'ap-south-1' = 'datalake-daily.aliyuncs.com',
    'ap-southeast-1' = 'datalake-daily.aliyuncs.com',
    'ap-southeast-2' = 'datalake-daily.aliyuncs.com',
    'ap-southeast-3' = 'datalake-daily.aliyuncs.com',
    'ap-southeast-5' = 'datalake-daily.aliyuncs.com',
    'cn-beijing' = 'dlf.cn-beijing.aliyuncs.com',
    'cn-beijing-finance-1' = 'datalake-daily.aliyuncs.com',
    'cn-beijing-finance-pop' = 'datalake-daily.aliyuncs.com',
    'cn-beijing-gov-1' = 'datalake-daily.aliyuncs.com',
    'cn-beijing-nu16-b01' = 'datalake-daily.aliyuncs.com',
    'cn-chengdu' = 'datalake-daily.aliyuncs.com',
    'cn-edge-1' = 'datalake-daily.aliyuncs.com',
    'cn-fujian' = 'datalake-daily.aliyuncs.com',
    'cn-haidian-cm12-c01' = 'datalake-daily.aliyuncs.com',
    'cn-hangzhou' = 'dlf.cn-hangzhou.aliyuncs.com',
    'cn-hangzhou-bj-b01' = 'datalake-daily.aliyuncs.com',
    'cn-hangzhou-finance' = 'datalake-daily.aliyuncs.com',
    'cn-hangzhou-internal-prod-1' = 'datalake-daily.aliyuncs.com',
    'cn-hangzhou-internal-test-1' = 'datalake-daily.aliyuncs.com',
    'cn-hangzhou-internal-test-2' = 'datalake-daily.aliyuncs.com',
    'cn-hangzhou-internal-test-3' = 'datalake-daily.aliyuncs.com',
    'cn-hangzhou-test-306' = 'datalake-daily.aliyuncs.com',
    'cn-hongkong' = 'datalake-daily.aliyuncs.com',
    'cn-hongkong-finance-pop' = 'datalake-daily.aliyuncs.com',
    'cn-huhehaote' = 'datalake-daily.aliyuncs.com',
    'cn-huhehaote-nebula-1' = 'datalake-daily.aliyuncs.com',
    'cn-north-2-gov-1' = 'datalake-daily.aliyuncs.com',
    'cn-qingdao' = 'datalake-daily.aliyuncs.com',
    'cn-qingdao-nebula' = 'datalake-daily.aliyuncs.com',
    'cn-shanghai' = 'dlf.cn-shanghai.aliyuncs.com',
    'cn-shanghai-et15-b01' = 'datalake-daily.aliyuncs.com',
    'cn-shanghai-et2-b01' = 'datalake-daily.aliyuncs.com',
    'cn-shanghai-finance-1' = 'datalake-daily.aliyuncs.com',
    'cn-shanghai-inner' = 'datalake-daily.aliyuncs.com',
    'cn-shanghai-internal-test-1' = 'datalake-daily.aliyuncs.com',
    'cn-shenzhen' = 'dlf.cn-shenzhen.aliyuncs.com',
    'cn-shenzhen-finance-1' = 'datalake-daily.aliyuncs.com',
    'cn-shenzhen-inner' = 'datalake-daily.aliyuncs.com',
    'cn-shenzhen-st4-d01' = 'datalake-daily.aliyuncs.com',
    'cn-shenzhen-su18-b01' = 'datalake-daily.aliyuncs.com',
    'cn-wuhan' = 'datalake-daily.aliyuncs.com',
    'cn-wulanchabu' = 'datalake-daily.aliyuncs.com',
    'cn-yushanfang' = 'datalake-daily.aliyuncs.com',
    'cn-zhangbei' = 'datalake-daily.aliyuncs.com',
    'cn-zhangbei-na61-b01' = 'datalake-daily.aliyuncs.com',
    'cn-zhangjiakou' = 'datalake-daily.aliyuncs.com',
    'cn-zhangjiakou-na62-a01' = 'datalake-daily.aliyuncs.com',
    'cn-zhengzhou-nebula-1' = 'datalake-daily.aliyuncs.com',
    'eu-central-1' = 'datalake-daily.aliyuncs.com',
    'eu-west-1' = 'datalake-daily.aliyuncs.com',
    'eu-west-1-oxs' = 'datalake-daily.aliyuncs.com',
    'me-east-1' = 'datalake-daily.aliyuncs.com',
    'rus-west-1-pop' = 'datalake-daily.aliyuncs.com',
    'us-east-1' = 'datalake-daily.aliyuncs.com',
    'us-west-1' = 'datalake-daily.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('datalake', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!$isNull(endpoint)) {
    return endpoint;
  }
  
  if (!$isNull(endpointMap) && !$isNull(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AccessRequest {
  catalogId?: string(name='CatalogId'),
  principal?: Principal(name='Principal'),
  privilegeResources?: [
PrivilegeResource
](name='PrivilegeResources'),
}

model Catalog {
  catalogId?: string(name='CatalogId'),
  catalogType?: string(name='CatalogType'),
  createTime?: long(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  defaultCatalog?: boolean(name='DefaultCatalog'),
  description?: string(name='Description'),
  jdbcEnabled?: boolean(name='JdbcEnabled'),
  locationUri?: string(name='LocationUri'),
  owner?: string(name='Owner'),
  status?: string(name='Status'),
  storageAccessConfig?: string(name='StorageAccessConfig'),
  thriftEnabled?: boolean(name='ThriftEnabled'),
  updateTime?: long(name='UpdateTime'),
}

model CatalogConnection {
  jdbcPassword?: string(name='JdbcPassword'),
  jdbcUri?: string(name='JdbcUri'),
  jdbcUserName?: string(name='JdbcUserName'),
  thriftUri?: string(name='ThriftUri'),
  vpcConnectionId?: string(name='VpcConnectionId', example='CONN-607A0053D874****'),
}

model CatalogInput {
  catalogId?: string(name='CatalogId', description='This parameter is required.'),
  catalogType?: string(name='CatalogType'),
  description?: string(name='Description'),
  jdbcEnabled?: boolean(name='JdbcEnabled'),
  locationUri?: string(name='LocationUri'),
  owner?: string(name='Owner'),
  storageAccessConfig?: string(name='StorageAccessConfig'),
  thriftEnabled?: boolean(name='ThriftEnabled'),
}

model CatalogResource {
  catalogId?: string(name='CatalogId'),
}

model CatalogSettings {
  config?: map[string]string(name='Config'),
}

model CatalogVpcConnection {
  catalogId?: string(name='CatalogId', example='catalog_test'),
  connectionName?: string(name='ConnectionName'),
  connectionStatus?: string(name='ConnectionStatus', example='CONNECTED'),
  creator?: long(name='Creator', example='120215474170****'),
  errorMessage?: string(name='ErrorMessage'),
  gmtCreate?: string(name='GmtCreate', example='2023-07-12 15:26:12'),
  gmtModified?: string(name='GmtModified', example='2023-07-17 17:51:04'),
  jdbcUri?: string(name='JdbcUri'),
  modifier?: long(name='Modifier', example='120215474170****'),
  owner?: long(name='Owner', example='120215474170****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  securityGroupIds?: [ string ](name='SecurityGroupIds'),
  thriftUri?: string(name='ThriftUri'),
  vpcConnectionId?: string(name='VpcConnectionId', example='CONN-607A0053D874****'),
  vpcId?: string(name='VpcId', example='vpc-2ze0c41hvmesel7pu****'),
  zones?: [ 
    {
      IP?: string(name='IP', example='192.168.XX.XX'),
      vSwitchId?: string(name='VSwitchId', example='vsw-hp3uf6045ljdhd5zr****'),
      zoneId?: string(name='ZoneId', example='cn-hangzhou-g'),
    }
  ](name='Zones'),
}

model CatalogVpcConnectionInput {
  connectionName?: string(name='ConnectionName'),
  securityGroupIds?: [ string ](name='SecurityGroupIds'),
  vpcId?: string(name='VpcId', example='vpc-hp356stwkxg3fn2xe****'),
  zones?: [ 
    {
      IP?: string(name='IP', example='192.168.XX.XX'),
      vSwitchId?: string(name='VSwitchId', example='vsw-hp3uf6045ljdhd5zr****'),
      zoneId?: string(name='ZoneId', example='cn-hangzhou-g'),
    }
  ](name='Zones'),
}

model ColumnResource {
  columnNames?: [ string ](name='ColumnNames'),
  databaseName?: string(name='DatabaseName', example='default'),
  tableName?: string(name='TableName', example='test'),
}

model ColumnStatistics {
  columnStatisticsDesc?: ColumnStatisticsDesc(name='ColumnStatisticsDesc'),
  columnStatisticsObjList?: [
    ColumnStatisticsObj
  ](name='ColumnStatisticsObjList'),
  engine?: string(name='Engine'),
  isStatsCompliant?: boolean(name='IsStatsCompliant'),
}

model ColumnStatisticsDesc {
  lastAnalyzedTime?: long(name='LastAnalyzedTime'),
  partitionName?: string(name='PartitionName'),
}

model ColumnStatisticsObj {
  columnName?: string(name='ColumnName'),
  columnStatisticsData?: {
    statisticsData?: string(name='StatisticsData'),
    statisticsType?: string(name='StatisticsType'),
  }(name='ColumnStatisticsData'),
  columnType?: string(name='ColumnType'),
}

model Database {
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  description?: string(name='Description'),
  locationUri?: string(name='LocationUri', example='oss://examplebuket/exampledb'),
  name?: string(name='Name'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  updateTime?: int32(name='UpdateTime'),
}

model DatabaseInput {
  createTime?: int32(name='CreateTime'),
  description?: string(name='Description'),
  locationUri?: string(name='LocationUri', example='oss://examplebuket/exampledb'),
  name?: string(name='Name'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
}

model DatabaseProfile {
  createTime?: string(name='CreateTime'),
  fileCnt?: long(name='FileCnt'),
  fileSize?: long(name='FileSize'),
  latestDate?: string(name='LatestDate'),
  location?: string(name='Location'),
  name?: string(name='Name'),
  objectCnt?: long(name='ObjectCnt'),
  objectSize?: long(name='ObjectSize'),
}

model DatabaseResource {
  databaseName?: string(name='DatabaseName', example='default'),
  databaseWildcard?: string(name='DatabaseWildcard'),
}

model DbStorageRank {
  dbName?: string(name='DbName'),
  quantity?: long(name='Quantity'),
}

model ErrorDetail {
  code?: string(name='Code'),
  message?: string(name='Message'),
}

model FieldSchema {
  comment?: string(name='Comment'),
  name?: string(name='Name'),
  parameters?: map[string]string(name='Parameters'),
  type?: string(name='Type'),
}

model FileCnt {
  large?: long(name='Large'),
  middle?: long(name='Middle'),
  small?: long(name='Small'),
  tiny?: long(name='Tiny'),
}

model Function {
  catalogId?: string(name='CatalogId'),
  className?: string(name='ClassName'),
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy', example='CreatedBy'),
  databaseName?: string(name='DatabaseName'),
  functionName?: string(name='FunctionName'),
  functionType?: string(name='FunctionType'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  resourceUri?: [
    ResourceUri
  ](name='ResourceUri'),
  updateTime?: int32(name='UpdateTime'),
}

model FunctionInput {
  className?: string(name='ClassName'),
  createTime?: int32(name='CreateTime'),
  functionName?: string(name='FunctionName'),
  functionType?: string(name='FunctionType'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  resourceUri?: [
    ResourceUri
  ](name='ResourceUri'),
}

model FunctionResource {
  databaseName?: string(name='DatabaseName', example='default'),
  functionName?: string(name='FunctionName', example='default'),
}

model GrantRevokeEntry {
  accesses?: [ string ](name='Accesses'),
  delegateAccesses?: [ string ](name='DelegateAccesses'),
  id?: string(name='Id'),
  metaResource?: MetaResource(name='MetaResource'),
  principal?: Principal(name='Principal'),
}

model GrantRevokeFailureEntry {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  grantRevokeEntry?: GrantRevokeEntry(name='GrantRevokeEntry'),
}

model HighLight {
  key?: string(name='Key', example='name'),
  value?: string(name='Value', example='<em>tab</em>2'),
}

model IndicatorStatistic {
  data?: long(name='Data'),
  date?: string(name='Date'),
}

model LifecycleResource {
  bizId?: string(name='BizId'),
  catalogId?: string(name='CatalogId'),
  database?: {
    createTime?: long(name='CreateTime'),
    description?: string(name='Description'),
    locationUri?: string(name='LocationUri'),
    name?: string(name='Name'),
    updateTime?: long(name='UpdateTime'),
  }(name='Database'),
  databaseName?: string(name='DatabaseName'),
  databaseProfile?: DatabaseProfile(name='DatabaseProfile'),
  gmtCreate?: string(name='GmtCreate'),
  lifecycleRuleBizId?: string(name='LifecycleRuleBizId'),
  owner?: long(name='Owner'),
  table?: {
    createTime?: long(name='CreateTime'),
    databaseName?: string(name='DatabaseName'),
    parameters?: map[string]string(name='Parameters'),
    sd?: {
      bucketCols?: [ string ](name='BucketCols'),
      inputFormat?: string(name='InputFormat'),
      location?: string(name='Location'),
      outputFormat?: string(name='OutputFormat'),
      parameters?: map[string]string(name='Parameters'),
      serDeInfo?: {
        name?: string(name='Name'),
        parameters?: map[string]string(name='Parameters'),
        serializationLib?: string(name='SerializationLib'),
      }(name='SerDeInfo'),
    }(name='Sd'),
    tableName?: string(name='TableName'),
    tableType?: string(name='TableType'),
  }(name='Table'),
  tableName?: string(name='TableName'),
  tableProfile?: TableProfile(name='TableProfile'),
}

model LifecycleRule {
  archiveDays?: int32(name='ArchiveDays'),
  bindCount?: int32(name='BindCount'),
  bizId?: string(name='BizId'),
  catalogId?: string(name='CatalogId'),
  coldArchiveDays?: int32(name='ColdArchiveDays'),
  config?: string(name='Config'),
  description?: string(name='Description'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  iaDays?: int32(name='IaDays'),
  name?: string(name='Name'),
  resourceType?: string(name='ResourceType'),
  ruleType?: string(name='RuleType'),
  scheduleStatus?: string(name='ScheduleStatus'),
  workflow?: Workflow(name='Workflow'),
  workflowId?: string(name='WorkflowId'),
  workflowInstance?: WorkflowInstance(name='WorkflowInstance'),
}

model LifecycleTask {
  bizId?: string(name='BizId'),
  lifecycleRule?: LifecycleRule(name='LifecycleRule'),
  name?: string(name='Name'),
  workflowInstance?: WorkflowInstance(name='WorkflowInstance'),
}

model LocationStorageRankDTO {
  fileCnt?: long(name='FileCnt'),
  location?: string(name='Location'),
  storage?: long(name='Storage'),
}

model LockObj {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  partitionName?: string(name='PartitionName'),
  tableName?: string(name='TableName'),
}

model LockStatus {
  lockId?: long(name='LockId'),
  lockState?: string(name='LockState'),
}

model LogInfo {
  bizTime?: string(name='BizTime'),
  gmtCreate?: string(name='GmtCreate'),
  instanceId?: string(name='InstanceId'),
  logContent?: string(name='LogContent'),
  logId?: string(name='LogId'),
  logSummary?: string(name='LogSummary'),
  logType?: string(name='LogType'),
}

model MetaResource {
  catalogResource?: CatalogResource(name='CatalogResource'),
  columnResource?: ColumnResource(name='ColumnResource'),
  databaseResource?: DatabaseResource(name='DatabaseResource'),
  functionResource?: FunctionResource(name='FunctionResource'),
  resourceType?: string(name='ResourceType', example='TABLE'),
  tableResource?: TableResource(name='TableResource'),
}

model Order {
  col?: string(name='Col'),
  order?: int32(name='Order'),
}

model Partition {
  createTime?: int32(name='CreateTime'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName'),
  values?: [ string ](name='Values'),
}

model PartitionError {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  partitionValues?: [ string ](name='PartitionValues'),
}

model PartitionInput {
  createTime?: int32(name='CreateTime'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName'),
  values?: [ string ](name='Values'),
}

model PartitionProfile {
  accessNum?: long(name='AccessNum', example='0'),
  accessNumMonthly?: long(name='AccessNumMonthly', example='0'),
  accessNumWeekly?: long(name='AccessNumWeekly', example='0'),
  archiveStatus?: string(name='ArchiveStatus', example='STANDARD'),
  createTime?: string(name='CreateTime', example='2023-08-16 18:02:22'),
  dataSourceType?: string(name='DataSourceType', example='OSS_HDFS'),
  databaseName?: string(name='DatabaseName', example='test_db'),
  fileCnt?: long(name='FileCnt', example='1'),
  fileSize?: long(name='FileSize', example='13'),
  lastAccessNumTime?: string(name='LastAccessNumTime'),
  lastAccessTime?: string(name='LastAccessTime', example='2023-08-22 12:14:42'),
  lastModifyTime?: string(name='LastModifyTime', example='2023-08-16 18:02:25'),
  location?: string(name='Location', example='oss://mybucket.cn-hangzhou.oss-dls.aliyuncs.com/test_tb/test_tbl/year=2023/month=1'),
  objectAccessNum?: long(name='ObjectAccessNum', example='0'),
  objectAccessNumMonthly?: long(name='ObjectAccessNumMonthly', example='4'),
  objectAccessNumWeekly?: long(name='ObjectAccessNumWeekly', example='4'),
  objectCnt?: long(name='ObjectCnt', example='1'),
  objectSize?: long(name='ObjectSize', example='13'),
  partitionName?: string(name='PartitionName', example='year=2023/month=1'),
  tableName?: string(name='TableName', example='test_tbl'),
}

model PartitionSpec {
  sharedSDPartitions?: [
    Partition
  ](name='SharedSDPartitions'),
  sharedStorageDescriptor?: {
    cols?: [
      FieldSchema
    ](name='Cols'),
    location?: string(name='Location', example='相对路径'),
  }(name='SharedStorageDescriptor'),
}

model Principal {
  principalArn?: string(name='PrincipalArn', example='acs:ram::[AliyunAccountId]:user/username_abc'),
}

model PrincipalPrivilegeSet {
  groupPrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='GroupPrivileges'),
  rolePrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='RolePrivileges'),
  userPrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='UserPrivileges'),
}

model PrincipalResourcePermissions {
  accesses?: [ string ](name='Accesses'),
  delegateAccesses?: [ string ](name='DelegateAccesses'),
  metaResource?: MetaResource(name='MetaResource', description='This parameter is required.'),
  principal?: Principal(name='Principal', description='This parameter is required.'),
}

model PrivilegeGrantInfo {
  createTime?: int32(name='CreateTime'),
  grantOption?: boolean(name='GrantOption'),
  grantor?: string(name='Grantor'),
  grantorType?: string(name='GrantorType'),
  privilege?: string(name='Privilege'),
}

model PrivilegeResource {
  access?: string(name='Access'),
  metaResource?: MetaResource(name='MetaResource'),
}

model ResourceUri {
  resourceType?: string(name='ResourceType'),
  uri?: string(name='Uri'),
}

model Role {
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  displayName?: string(name='DisplayName', example='显示名称，允许中文'),
  isPredefined?: int32(name='IsPredefined'),
  name?: string(name='Name'),
  principalArn?: string(name='PrincipalArn'),
  updateTime?: long(name='UpdateTime'),
  users?: [
Principal
](name='Users'),
}

model RoleInput {
  description?: string(name='Description'),
  displayName?: string(name='DisplayName', example='显示名称，允许中文'),
  name?: string(name='Name'),
}

model SerDeInfo {
  name?: string(name='Name'),
  parameters?: map[string]string(name='Parameters'),
  serializationLib?: string(name='SerializationLib'),
}

model SingleIndicatorDTO {
  dayIncrement?: long(name='DayIncrement'),
  dayOnDay?: double(name='DayOnDay'),
  monthIncrement?: long(name='MonthIncrement'),
  monthOnMonth?: double(name='MonthOnMonth'),
  total?: long(name='Total'),
}

model SkewedInfo {
  skewedColNames?: [ string ](name='SkewedColNames'),
  skewedColValueLocationMaps?: map[string]string(name='SkewedColValueLocationMaps'),
  skewedColValues?: [[ string ]  ](name='SkewedColValues'),
}

model SmallFileCntRank {
  dbName?: string(name='DbName'),
  location?: string(name='Location'),
  quantity?: long(name='Quantity'),
  tableName?: string(name='TableName'),
}

model SortCriterion {
  fieldName?: string(name='FieldName', example='name'),
  sort?: string(name='Sort', example='asc/desc'),
}

model StorageCollectTaskOperationResult {
  dlfCreated?: boolean(name='DlfCreated'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
}

model StorageDescriptor {
  bucketCols?: [ string ](name='BucketCols'),
  cols?: [
    FieldSchema
  ](name='Cols'),
  compressed?: boolean(name='Compressed'),
  inputFormat?: string(name='InputFormat'),
  location?: string(name='Location'),
  numBuckets?: int32(name='NumBuckets'),
  outputFormat?: string(name='OutputFormat'),
  parameters?: map[string]string(name='Parameters'),
  serDeInfo?: SerDeInfo(name='SerDeInfo'),
  skewedInfo?: SkewedInfo(name='SkewedInfo'),
  sortCols?: [
    Order
  ](name='SortCols'),
  storedAsSubDirectories?: boolean(name='StoredAsSubDirectories'),
}

model StorageFormat {
  avro?: long(name='Avro'),
  csv?: long(name='Csv'),
  delta?: long(name='Delta'),
  hudi?: long(name='Hudi'),
  iceberg?: long(name='Iceberg'),
  json?: long(name='Json'),
  orc?: long(name='Orc'),
  parquet?: long(name='Parquet'),
  uncategorized?: long(name='Uncategorized'),
}

model StorageLayer {
  archive?: long(name='Archive'),
  coldArchive?: long(name='ColdArchive'),
  infrequent?: long(name='Infrequent'),
  standard?: long(name='Standard'),
  unknown?: long(name='Unknown'),
}

model StorageRankDTO {
  dbStorageRank?: [
    DbStorageRank
  ](name='dbStorageRank'),
  smallFileCntRank?: [
    SmallFileCntRank
  ](name='smallFileCntRank'),
  tableStorageRank?: [
    TableStorageRank
  ](name='tableStorageRank'),
}

model StorageSummary {
  databaseNum?: int32(name='DatabaseNum'),
  partitionNum?: int32(name='PartitionNum'),
  tableNum?: int32(name='TableNum'),
}

model StrogeCollectTask {
  destinationBucketName?: string(name='DestinationBucketName'),
  destinationPrefix?: string(name='DestinationPrefix'),
  dlfCreated?: boolean(name='DlfCreated'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  id?: string(name='Id'),
  inventoryId?: string(name='InventoryId'),
  location?: string(name='Location'),
  status?: string(name='Status'),
  taskType?: string(name='TaskType'),
}

model Table {
  cascade?: boolean(name='Cascade'),
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  owner?: string(name='Owner'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  retention?: int32(name='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled'),
  sd?: StorageDescriptor(name='Sd'),
  tableId?: string(name='TableId', example='59c6c8fefeaa46d8b599c1f790c59a19'),
  tableName?: string(name='TableName'),
  tableType?: string(name='TableType'),
  tableVersion?: TableVersion(name='TableVersion'),
  temporary?: boolean(name='Temporary'),
  updateTime?: int32(name='UpdateTime'),
  viewExpandedText?: string(name='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText'),
}

model TableError {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  tableName?: string(name='TableName'),
}

model TableExtended {
  cascade?: boolean(name='Cascade'),
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  owner?: string(name='Owner'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: {
    rolePrivileges?: map[string][ TableExtendedPrivilegesRolePrivilegesValue     ](name='RolePrivileges'),
    userPrivileges?: map[string][ TableExtendedPrivilegesUserPrivilegesValue     ](name='UserPrivileges'),
    groupPrivileges?: map[string][ TableExtendedPrivilegesGroupPrivilegesValue     ](name='groupPrivileges'),
  }(name='Privileges'),
  retention?: int32(name='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled'),
  sd?: {
    bucketCols?: [ string ](name='BucketCols'),
    cols?: [
      FieldSchema
    ](name='Cols'),
    compressed?: boolean(name='Compressed'),
    inputFormat?: string(name='InputFormat'),
    location?: string(name='Location'),
    numBuckets?: int32(name='NumBuckets'),
    outputFormat?: string(name='OutputFormat'),
    parameters?: map[string]string(name='Parameters'),
    serDeInfo?: {
      name?: string(name='Name'),
      parameters?: map[string]string(name='Parameters'),
      serializationLib?: string(name='SerializationLib'),
    }(name='SerDeInfo'),
    skewedInfo?: {
      skewedColNames?: [ string ](name='SkewedColNames'),
      skewedColValueLocationMaps?: map[string]string(name='SkewedColValueLocationMaps'),
      skewedColValues?: [[ string ]      ](name='SkewedColValues'),
    }(name='SkewedInfo'),
    sortCols?: [
      Order
    ](name='SortCols'),
    storedAsSubDirectories?: boolean(name='StoredAsSubDirectories'),
  }(name='Sd'),
  tableFormat?: string(name='TableFormat'),
  tableName?: string(name='TableName'),
  tableType?: string(name='TableType'),
  temporary?: boolean(name='Temporary'),
  updateTime?: int32(name='UpdateTime'),
  viewExpandedText?: string(name='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText'),
}

model TableInput {
  cascade?: boolean(name='Cascade'),
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  owner?: string(name='Owner'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  retention?: int32(name='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName'),
  tableType?: string(name='TableType'),
  temporary?: boolean(name='Temporary'),
  viewExpandedText?: string(name='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText'),
}

model TableProfile {
  accessNum?: long(name='AccessNum', example='0'),
  accessNumMonthly?: long(name='AccessNumMonthly', example='0'),
  accessNumWeekly?: long(name='AccessNumWeekly', example='0'),
  createTime?: string(name='CreateTime', example='2023-08-14 10:44:13'),
  dataSourceType?: string(name='DataSourceType', example='OSS_HDFS'),
  databaseName?: string(name='DatabaseName', example='test_db'),
  fileCnt?: long(name='FileCnt', example='5'),
  fileSize?: long(name='FileSize', example='31'),
  isPartitioned?: boolean(name='IsPartitioned', example='true'),
  lastAccessNumTime?: string(name='LastAccessNumTime'),
  lastAccessTime?: string(name='LastAccessTime', example='2023-08-22 12:14:42'),
  lastDdlTime?: string(name='LastDdlTime', example='2023-08-16 18:02:24'),
  lastModifyTime?: string(name='LastModifyTime', example='2023-08-16 18:02:25'),
  latestAccessNumDate?: string(name='LatestAccessNumDate'),
  latestDate?: string(name='LatestDate', example='2023-08-30 19:16:10'),
  location?: string(name='Location', example='oss://mybucket.cn-hangzhou.oss-dls.aliyuncs.com/test_db/test_tbl/'),
  objectAccessNum?: long(name='ObjectAccessNum', example='0'),
  objectAccessNumMonthly?: long(name='ObjectAccessNumMonthly', example='18'),
  objectAccessNumWeekly?: long(name='ObjectAccessNumWeekly', example='18'),
  objectCnt?: long(name='ObjectCnt', example='5'),
  objectSize?: long(name='ObjectSize', example='31'),
  partitionCnt?: long(name='PartitionCnt', example='3'),
  recordCnt?: long(name='RecordCnt'),
  tableName?: string(name='TableName', example='test_tbl'),
}

model TableResource {
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
}

model TableStorageRank {
  dbName?: string(name='DbName'),
  quantity?: long(name='Quantity'),
  tableName?: string(name='TableName'),
}

model TableVersion {
  table?: Table(name='Table'),
  versionId?: int32(name='VersionId'),
}

model TaskStatus {
  message?: string(name='Message'),
  status?: string(name='Status'),
}

model UnarchiveDetail {
  apiCallTimes?: long(name='ApiCallTimes'),
  cost?: long(name='Cost'),
  storageSize?: long(name='StorageSize'),
  storageType?: string(name='StorageType'),
  unarchiveTaskStatus?: string(name='UnarchiveTaskStatus'),
}

model UpdateTablePartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId'),
  columnStatisticsList?: [
    ColumnStatistics
  ](name='ColumnStatisticsList'),
  databaseName?: string(name='DatabaseName'),
  engine?: string(name='Engine'),
  isStatsCompliant?: boolean(name='IsStatsCompliant'),
  tableName?: string(name='TableName'),
  validWriteIdList?: string(name='ValidWriteIdList'),
  writeId?: string(name='WriteId'),
}

model UserRole {
  grantTime?: long(name='GrantTime'),
  role?: Role(name='Role'),
  user?: Principal(name='User'),
}

model Workflow {
  latestEndTime?: string(name='LatestEndTime'),
  latestInstanceId?: string(name='LatestInstanceId'),
  latestInstanceStatus?: string(name='LatestInstanceStatus'),
  latestStartTime?: string(name='LatestStartTime'),
}

model WorkflowInstance {
  batchProgress?: int32(name='BatchProgress'),
  dlfWorkflowId?: string(name='DlfWorkflowId'),
  endTime?: long(name='EndTime'),
  externalInstanceId?: string(name='ExternalInstanceId'),
  runtimeLogs?: [
    LogInfo
  ](name='RuntimeLogs'),
  startTime?: long(name='StartTime'),
  status?: string(name='Status'),
}

model TableExtendedPrivilegesRolePrivilegesValue = {
  createTime?: int32(name='CreateTime'),
  grantOption?: boolean(name='GrantOption'),
  grantor?: string(name='Grantor'),
  grantorType?: string(name='GrantorType'),
  privilege?: string(name='Privilege'),
}

model TableExtendedPrivilegesUserPrivilegesValue = {
  createTime?: int32(name='CreateTime'),
  grantOption?: boolean(name='GrantOption'),
  grantor?: string(name='Grantor'),
  grantorType?: string(name='GrantorType'),
  privilege?: string(name='Privilege'),
}

model TableExtendedPrivilegesGroupPrivilegesValue = {
  createTime?: int32(name='CreateTime'),
  grantOption?: boolean(name='GrantOption'),
  grantor?: string(name='Grantor'),
  grantorType?: string(name='GrantorType'),
  privilege?: string(name='Privilege'),
}

model AbortLockRequest {
  lockId?: long(name='LockId', description='The lock ID.', example='16530'),
}

model AbortLockResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The returned message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='01D8DD6B-4929-5999-9BB3-950AA30E3BD0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false.', example='True'),
}

model AbortLockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AbortLockResponseBody(name='body'),
}

/**
 * @summary Aborts the specified metadata lock.
 *
 * @param request AbortLockRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AbortLockResponse
 */
@context("abortLockWithContext")
async function abortLockWithOptions(request: AbortLockRequest, headers: map[string]string, runtime: $RuntimeOptions): AbortLockResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.lockId)) {
    query['LockId'] = request.lockId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'AbortLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks/abort`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Aborts the specified metadata lock.
 *
 * @param request AbortLockRequest
 * @return AbortLockResponse
 */
async function abortLock(request: AbortLockRequest): AbortLockResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return abortLockWithOptions(request, headers, runtime);
}

model BatchCreatePartitionsRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  ifNotExists?: boolean(name='IfNotExists', description='Specifies whether to ignore errors if the name of the partition to be created already exists.', example='true'),
  needResult?: boolean(name='NeedResult', description='Specifies whether to return partition information. If the value is true, the partitions are returned.', example='true'),
  partitionInputs?: [
    PartitionInput
  ](name='PartitionInputs', description='The information about the partitions to be created.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model BatchCreatePartitionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='The returned errors.'),
  partitions?: [
    Partition
  ](name='Partitions', description='The partitions, which are returned if the NeedResult parameter is set to true.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchCreatePartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchCreatePartitionsResponseBody(name='body'),
}

/**
 * @summary Add multiple partitions to a data table in a data lake at a time.
 *
 * @param request BatchCreatePartitionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchCreatePartitionsResponse
 */
@context("batchCreatePartitionsWithContext")
async function batchCreatePartitionsWithOptions(request: BatchCreatePartitionsRequest, headers: map[string]string, runtime: $RuntimeOptions): BatchCreatePartitionsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.ifNotExists)) {
    body['IfNotExists'] = request.ifNotExists;
  }
  if (!$isNull(request.needResult)) {
    body['NeedResult'] = request.needResult;
  }
  if (!$isNull(request.partitionInputs)) {
    body['PartitionInputs'] = request.partitionInputs;
  }
  if (!$isNull(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchCreatePartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/batchcreate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Add multiple partitions to a data table in a data lake at a time.
 *
 * @param request BatchCreatePartitionsRequest
 * @return BatchCreatePartitionsResponse
 */
async function batchCreatePartitions(request: BatchCreatePartitionsRequest): BatchCreatePartitionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return batchCreatePartitionsWithOptions(request, headers, runtime);
}

model BatchCreateTablesRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  ifNotExists?: boolean(name='IfNotExists', description='Specifies whether to ignore errors if the table name already exists.', example='true'),
  tableInputs?: [
    TableInput
  ](name='TableInputs', description='The list of data tables.'),
}

model BatchCreateTablesResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='The list of errors occurred when you created the data table.', example='["ErrorDetail":{},"TableName":"test"]'),
}

model BatchCreateTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchCreateTablesResponseBody(name='body'),
}

/**
 * @summary Add data tables to a data lake at a time.
 *
 * @param request BatchCreateTablesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchCreateTablesResponse
 */
@context("batchCreateTablesWithContext")
async function batchCreateTablesWithOptions(request: BatchCreateTablesRequest, headers: map[string]string, runtime: $RuntimeOptions): BatchCreateTablesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.ifNotExists)) {
    body['IfNotExists'] = request.ifNotExists;
  }
  if (!$isNull(request.tableInputs)) {
    body['TableInputs'] = request.tableInputs;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchCreateTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/batchcreate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Add data tables to a data lake at a time.
 *
 * @param request BatchCreateTablesRequest
 * @return BatchCreateTablesResponse
 */
async function batchCreateTables(request: BatchCreateTablesRequest): BatchCreateTablesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return batchCreateTablesWithOptions(request, headers, runtime);
}

model BatchDeletePartitionsRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  ifExists?: boolean(name='IfExists', description='Specifies whether to ignore errors if the partition that you want to delete does not exist.', example='true'),
  partitionValueList?: [ 
  {
    values?: [ string ](name='Values'),
  }
](name='PartitionValueList', description='The partition key column values of the partitions to be deleted.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201225'),
}

model BatchDeletePartitionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='The returned errors.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchDeletePartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeletePartitionsResponseBody(name='body'),
}

/**
 * @summary Deletes multiple partitions of a data table in the data lake.
 *
 * @param request BatchDeletePartitionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDeletePartitionsResponse
 */
@context("batchDeletePartitionsWithContext")
async function batchDeletePartitionsWithOptions(request: BatchDeletePartitionsRequest, headers: map[string]string, runtime: $RuntimeOptions): BatchDeletePartitionsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.ifExists)) {
    body['IfExists'] = request.ifExists;
  }
  if (!$isNull(request.partitionValueList)) {
    body['PartitionValueList'] = request.partitionValueList;
  }
  if (!$isNull(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchDeletePartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/batchdelete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes multiple partitions of a data table in the data lake.
 *
 * @param request BatchDeletePartitionsRequest
 * @return BatchDeletePartitionsResponse
 */
async function batchDeletePartitions(request: BatchDeletePartitionsRequest): BatchDeletePartitionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return batchDeletePartitionsWithOptions(request, headers, runtime);
}

model BatchDeleteTableVersionsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
  versionIds?: [ int32 ](name='VersionIds', description='The list of version numbers.'),
}

model BatchDeleteTableVersionsResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchDeleteTableVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteTableVersionsResponseBody(name='body'),
}

/**
 * @summary Deletes a specified version of a data table in a data lake at a time.
 *
 * @param request BatchDeleteTableVersionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDeleteTableVersionsResponse
 */
@context("batchDeleteTableVersionsWithContext")
async function batchDeleteTableVersionsWithOptions(request: BatchDeleteTableVersionsRequest, headers: map[string]string, runtime: $RuntimeOptions): BatchDeleteTableVersionsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.tableName)) {
    body['TableName'] = request.tableName;
  }
  if (!$isNull(request.versionIds)) {
    body['VersionIds'] = request.versionIds;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchDeleteTableVersions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/versions/batchdelete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a specified version of a data table in a data lake at a time.
 *
 * @param request BatchDeleteTableVersionsRequest
 * @return BatchDeleteTableVersionsResponse
 */
async function batchDeleteTableVersions(request: BatchDeleteTableVersionsRequest): BatchDeleteTableVersionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return batchDeleteTableVersionsWithOptions(request, headers, runtime);
}

model BatchDeleteTablesRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  ifExists?: boolean(name='IfExists', description='Specifies whether to ignore errors if the partition with the specified name has been deleted.', example='true'),
  tableNames?: [ string ](name='TableNames', description='The list of data table names.'),
}

model BatchDeleteTablesResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false', example='true'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='The collection of error messages.'),
}

model BatchDeleteTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteTablesResponseBody(name='body'),
}

/**
 * @summary Deletes multiple data tables in a data lake by name.
 *
 * @param request BatchDeleteTablesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDeleteTablesResponse
 */
@context("batchDeleteTablesWithContext")
async function batchDeleteTablesWithOptions(request: BatchDeleteTablesRequest, headers: map[string]string, runtime: $RuntimeOptions): BatchDeleteTablesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.ifExists)) {
    body['IfExists'] = request.ifExists;
  }
  if (!$isNull(request.tableNames)) {
    body['TableNames'] = request.tableNames;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchDeleteTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/batchdelete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes multiple data tables in a data lake by name.
 *
 * @param request BatchDeleteTablesRequest
 * @return BatchDeleteTablesResponse
 */
async function batchDeleteTables(request: BatchDeleteTablesRequest): BatchDeleteTablesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return batchDeleteTablesWithOptions(request, headers, runtime);
}

model BatchGetPartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  columnNames?: [ string ](name='ColumnNames', description='The names of the columns in the data table.'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  partitionNames?: [ string ](name='PartitionNames', description='The names of the partitions in the data table.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model BatchGetPartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionStatisticsMap?: map[string][
    ColumnStatisticsObj
  ](name='PartitionStatisticsMap', description='The partition statistics.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchGetPartitionColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetPartitionColumnStatisticsResponseBody(name='body'),
}

/**
 * @summary Obtains the field statistics of data table partitions in a data lake at a time.
 *
 * @param request BatchGetPartitionColumnStatisticsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetPartitionColumnStatisticsResponse
 */
@context("batchGetPartitionColumnStatisticsWithContext")
async function batchGetPartitionColumnStatisticsWithOptions(request: BatchGetPartitionColumnStatisticsRequest, headers: map[string]string, runtime: $RuntimeOptions): BatchGetPartitionColumnStatisticsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.columnNames)) {
    body['ColumnNames'] = request.columnNames;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.partitionNames)) {
    body['PartitionNames'] = request.partitionNames;
  }
  if (!$isNull(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchGetPartitionColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/columnstatistics/batchget`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the field statistics of data table partitions in a data lake at a time.
 *
 * @param request BatchGetPartitionColumnStatisticsRequest
 * @return BatchGetPartitionColumnStatisticsResponse
 */
async function batchGetPartitionColumnStatistics(request: BatchGetPartitionColumnStatisticsRequest): BatchGetPartitionColumnStatisticsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGetPartitionColumnStatisticsWithOptions(request, headers, runtime);
}

model BatchGetPartitionsRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  isShareSd?: boolean(name='IsShareSd', description='Specifies whether to share the column information of SD in the partition.', example='true'),
  partitionValueList?: [ 
  {
    values?: [ string ](name='Values'),
  }
](name='PartitionValueList', description='The values of the partition key columns.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
}

model BatchGetPartitionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='The error messages.'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs', description='The list of partition specifications.'),
  partitions?: [
    Partition
  ](name='Partitions', description='The list of partitions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchGetPartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetPartitionsResponseBody(name='body'),
}

/**
 * @summary Obtains the details of database partitions in a data lake in batches.
 *
 * @param request BatchGetPartitionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetPartitionsResponse
 */
@context("batchGetPartitionsWithContext")
async function batchGetPartitionsWithOptions(request: BatchGetPartitionsRequest, headers: map[string]string, runtime: $RuntimeOptions): BatchGetPartitionsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.isShareSd)) {
    body['IsShareSd'] = request.isShareSd;
  }
  if (!$isNull(request.partitionValueList)) {
    body['PartitionValueList'] = request.partitionValueList;
  }
  if (!$isNull(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchGetPartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/batchget`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the details of database partitions in a data lake in batches.
 *
 * @param request BatchGetPartitionsRequest
 * @return BatchGetPartitionsResponse
 */
async function batchGetPartitions(request: BatchGetPartitionsRequest): BatchGetPartitionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGetPartitionsWithOptions(request, headers, runtime);
}

model BatchGetTablesRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  tableNames?: [ string ](name='TableNames', description='The name of the data table.'),
}

model BatchGetTablesResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false', example='true'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='The returned errors.'),
  tables?: [
    Table
  ](name='Tables', description='The returned data tables.'),
}

model BatchGetTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetTablesResponseBody(name='body'),
}

/**
 * @summary Obtain detailed information about data tables in the data lake in batches.
 *
 * @param request BatchGetTablesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetTablesResponse
 */
@context("batchGetTablesWithContext")
async function batchGetTablesWithOptions(request: BatchGetTablesRequest, headers: map[string]string, runtime: $RuntimeOptions): BatchGetTablesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.tableNames)) {
    body['TableNames'] = request.tableNames;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchGetTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/batchget`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtain detailed information about data tables in the data lake in batches.
 *
 * @param request BatchGetTablesRequest
 * @return BatchGetTablesResponse
 */
async function batchGetTables(request: BatchGetTablesRequest): BatchGetTablesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGetTablesWithOptions(request, headers, runtime);
}

model BatchGrantPermissionsRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  grantRevokeEntries?: [
    GrantRevokeEntry
  ](name='GrantRevokeEntries', description='The list of the items to be authorized.'),
  type?: string(name='Type', description='The authorization type. Only Hive is supported.

This parameter is required.', example='Hive'),
}

model BatchGrantPermissionsResponseBody = {
  batchGrantRevokeFailureResult?: [
  GrantRevokeFailureEntry
](name='BatchGrantRevokeFailureResult', description='The result returned when batch authorization failed.'),
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchGrantPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGrantPermissionsResponseBody(name='body'),
}

/**
 * @summary Grant the operation permissions on resources to a user or a data lake role at a time.
 *
 * @param request BatchGrantPermissionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGrantPermissionsResponse
 */
@context("batchGrantPermissionsWithContext")
async function batchGrantPermissionsWithOptions(request: BatchGrantPermissionsRequest, headers: map[string]string, runtime: $RuntimeOptions): BatchGrantPermissionsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.grantRevokeEntries)) {
    body['GrantRevokeEntries'] = request.grantRevokeEntries;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchGrantPermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/batchgrant`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Grant the operation permissions on resources to a user or a data lake role at a time.
 *
 * @param request BatchGrantPermissionsRequest
 * @return BatchGrantPermissionsResponse
 */
async function batchGrantPermissions(request: BatchGrantPermissionsRequest): BatchGrantPermissionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGrantPermissionsWithOptions(request, headers, runtime);
}

model BatchRevokePermissionsRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  grantRevokeEntries?: [
    GrantRevokeEntry
  ](name='GrantRevokeEntries', description='The permissions to be revoked.'),
  type?: string(name='Type', description='The authorization type. Set the value to Hive.

This parameter is required.', example='Hive'),
}

model BatchRevokePermissionsResponseBody = {
  batchGrantRevokeFailureResult?: [
  GrantRevokeFailureEntry
](name='BatchGrantRevokeFailureResult', description='The result returned when batch permission revocation failed.'),
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C9E535E1-F040-56F4-B4EE-592B555DAE19'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model BatchRevokePermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchRevokePermissionsResponseBody(name='body'),
}

/**
 * @summary You can call this operation to revoke permissions on resources from a user or data lake role at a time.
 *
 * @param request BatchRevokePermissionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchRevokePermissionsResponse
 */
@context("batchRevokePermissionsWithContext")
async function batchRevokePermissionsWithOptions(request: BatchRevokePermissionsRequest, headers: map[string]string, runtime: $RuntimeOptions): BatchRevokePermissionsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.grantRevokeEntries)) {
    body['GrantRevokeEntries'] = request.grantRevokeEntries;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchRevokePermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/batchrevoke`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call this operation to revoke permissions on resources from a user or data lake role at a time.
 *
 * @param request BatchRevokePermissionsRequest
 * @return BatchRevokePermissionsResponse
 */
async function batchRevokePermissions(request: BatchRevokePermissionsRequest): BatchRevokePermissionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return batchRevokePermissionsWithOptions(request, headers, runtime);
}

model BatchUpdatePartitionsRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  partitionInputs?: [
    PartitionInput
  ](name='PartitionInputs', description='The information about the partitions to be updated.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model BatchUpdatePartitionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='The returned errors.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchUpdatePartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchUpdatePartitionsResponseBody(name='body'),
}

/**
 * @summary Batch update multiple partitions for a data table in a data lake.
 *
 * @param request BatchUpdatePartitionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchUpdatePartitionsResponse
 */
@context("batchUpdatePartitionsWithContext")
async function batchUpdatePartitionsWithOptions(request: BatchUpdatePartitionsRequest, headers: map[string]string, runtime: $RuntimeOptions): BatchUpdatePartitionsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.partitionInputs)) {
    body['PartitionInputs'] = request.partitionInputs;
  }
  if (!$isNull(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchUpdatePartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/batchupdate`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Batch update multiple partitions for a data table in a data lake.
 *
 * @param request BatchUpdatePartitionsRequest
 * @return BatchUpdatePartitionsResponse
 */
async function batchUpdatePartitions(request: BatchUpdatePartitionsRequest): BatchUpdatePartitionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return batchUpdatePartitionsWithOptions(request, headers, runtime);
}

model BatchUpdateTablesRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  isAsync?: boolean(name='IsAsync', description='Specifies whether to asynchronously update the data table. Valid values:

*   true: The operation is asynchronously called. The update result is immediately returned. You can query the task status by taskid in the returned results.
*   false: The operation is synchronously called. The update result is returned after the background task is complete. If the execution of the background task requires an extended period of time, a timeout occurs.', example='true'),
  tableInputs?: [
    TableInput
  ](name='TableInputs', description='The details about the updated data table.'),
}

model BatchUpdateTablesResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='The returned errors.', example='{"ErrorDetails":{},"TableName":"test"}'),
  taskId?: string(name='TaskId', description='The ID of the asynchronous update task.', example='f8deec55f54ac566e7ec8944fbe01588'),
}

model BatchUpdateTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchUpdateTablesResponseBody(name='body'),
}

/**
 * @summary Update the details of data tables in the data lake in batches.
 *
 * @param request BatchUpdateTablesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchUpdateTablesResponse
 */
@context("batchUpdateTablesWithContext")
async function batchUpdateTablesWithOptions(request: BatchUpdateTablesRequest, headers: map[string]string, runtime: $RuntimeOptions): BatchUpdateTablesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.isAsync)) {
    body['IsAsync'] = request.isAsync;
  }
  if (!$isNull(request.tableInputs)) {
    body['TableInputs'] = request.tableInputs;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchUpdateTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/batchupdate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update the details of data tables in the data lake in batches.
 *
 * @param request BatchUpdateTablesRequest
 * @return BatchUpdateTablesResponse
 */
async function batchUpdateTables(request: BatchUpdateTablesRequest): BatchUpdateTablesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return batchUpdateTablesWithOptions(request, headers, runtime);
}

model CancelQueryRequest {
  queryId?: string(name='QueryId', description='The query ID.

>  You can call the SubmitQuery operation to query the query ID.', example='Q-BCA5E96CB84BB8B8'),
}

model CancelQueryResponseBody = {
  data?: string(name='Data', description='Query ID', example='Q-BCA5E96CB84BB8B8'),
  requestId?: string(name='RequestId', description='The request ID.', example='DB07AAE9-4B88-5DEA-8F1D-4D1A9A864A85'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model CancelQueryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelQueryResponseBody(name='body'),
}

/**
 * @summary Cancel a query request.
 *
 * @param request CancelQueryRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelQueryResponse
 */
@context("cancelQueryWithContext")
async function cancelQueryWithOptions(request: CancelQueryRequest, headers: map[string]string, runtime: $RuntimeOptions): CancelQueryResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.queryId)) {
    query['QueryId'] = request.queryId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CancelQuery',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/cancelQuery`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Cancel a query request.
 *
 * @param request CancelQueryRequest
 * @return CancelQueryResponse
 */
async function cancelQuery(request: CancelQueryRequest): CancelQueryResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelQueryWithOptions(request, headers, runtime);
}

model CheckPermissionsRequest {
  body?: AccessRequest(name='Body', description='The HTTP request body, in the JSON format.'),
}

model CheckPermissionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='81B90E1B-7514-5817-9D59-0EA9E2215876'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model CheckPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckPermissionsResponseBody(name='body'),
}

/**
 * @summary Verify user permissions.
 *
 * @param request CheckPermissionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckPermissionsResponse
 */
@context("checkPermissionsWithContext")
async function checkPermissionsWithOptions(request: CheckPermissionsRequest, headers: map[string]string, runtime: $RuntimeOptions): CheckPermissionsResponse {
  request.validate();
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CheckPermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/check`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Verify user permissions.
 *
 * @param request CheckPermissionsRequest
 * @return CheckPermissionsResponse
 */
async function checkPermissions(request: CheckPermissionsRequest): CheckPermissionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return checkPermissionsWithOptions(request, headers, runtime);
}

model CreateCatalogRequest {
  catalogInput?: CatalogInput(name='CatalogInput', description='The structure that is used to create or update the catalog.'),
}

model CreateCatalogResponseBody = {
  code?: string(name='Code', description='The status code returned.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='BA84F8D4-5160-5544-BE76-3A306CD3A7B0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model CreateCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCatalogResponseBody(name='body'),
}

/**
 * @summary Create a Data Catalog for Data Lake.
 *
 * @param request CreateCatalogRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCatalogResponse
 */
@context("createCatalogWithContext")
async function createCatalogWithOptions(request: CreateCatalogRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateCatalogResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogInput)) {
    body['CatalogInput'] = request.catalogInput;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateCatalog',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create a Data Catalog for Data Lake.
 *
 * @param request CreateCatalogRequest
 * @return CreateCatalogResponse
 */
async function createCatalog(request: CreateCatalogRequest): CreateCatalogResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createCatalogWithOptions(request, headers, runtime);
}

model CreateDatabaseRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseInput?: DatabaseInput(name='DatabaseInput', description='The database details.'),
}

model CreateDatabaseResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request is successful.
*   false: The request failed.', example='true'),
}

model CreateDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDatabaseResponseBody(name='body'),
}

/**
 * @summary Create a metadabase in the data lake metadata.
 *
 * @param request CreateDatabaseRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDatabaseResponse
 */
@context("createDatabaseWithContext")
async function createDatabaseWithOptions(request: CreateDatabaseRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateDatabaseResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseInput)) {
    body['DatabaseInput'] = request.databaseInput;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateDatabase',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create a metadabase in the data lake metadata.
 *
 * @param request CreateDatabaseRequest
 * @return CreateDatabaseResponse
 */
async function createDatabase(request: CreateDatabaseRequest): CreateDatabaseResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createDatabaseWithOptions(request, headers, runtime);
}

model CreateFunctionRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  functionInput?: FunctionInput(name='FunctionInput', description='The details about the function definition.'),
}

model CreateFunctionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model CreateFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFunctionResponseBody(name='body'),
}

/**
 * @summary Added user-defined functions for databases in the data lake.
 *
 * @param request CreateFunctionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFunctionResponse
 */
@context("createFunctionWithContext")
async function createFunctionWithOptions(request: CreateFunctionRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateFunctionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.functionInput)) {
    body['FunctionInput'] = request.functionInput;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateFunction',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Added user-defined functions for databases in the data lake.
 *
 * @param request CreateFunctionRequest
 * @return CreateFunctionResponse
 */
async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createFunctionWithOptions(request, headers, runtime);
}

model CreateLockRequest {
  lockObjList?: [
    LockObj
  ](name='LockObjList', description='The list of locks.', example='{"databaseName":"db","tableName":"test"}'),
}

model CreateLockResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  lockStatus?: LockStatus(name='LockStatus', description='The lock status.', example='{"lockId":12323,"lockStatus":"ACQUIRED"}'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='73201200-4C1A-4FEF-BD6B-C0DA7994FFA2'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false.', example='True'),
}

model CreateLockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLockResponseBody(name='body'),
}

/**
 * @summary Creates a specified metadata lock.
 *
 * @param request CreateLockRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLockResponse
 */
@context("createLockWithContext")
async function createLockWithOptions(request: CreateLockRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateLockResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.lockObjList)) {
    body['LockObjList'] = request.lockObjList;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a specified metadata lock.
 *
 * @param request CreateLockRequest
 * @return CreateLockResponse
 */
async function createLock(request: CreateLockRequest): CreateLockResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createLockWithOptions(request, headers, runtime);
}

model CreatePartitionRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  ifNotExists?: boolean(name='IfNotExists', description='Specifies whether to ignore errors if the name of the partition to be created already exists.', example='true'),
  needResult?: boolean(name='NeedResult', description='Specifies whether to return partition information. If this parameter is set to true, the Partition parameter is returned.', example='true'),
  partitionInput?: PartitionInput(name='PartitionInput', description='The information about the partition to be created.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model CreatePartitionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partition?: Partition(name='Partition', description='The partition information. This parameter is returned if the NeedResult parameter is set to true.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model CreatePartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePartitionResponseBody(name='body'),
}

/**
 * @summary Add a partition to the data table of the data lake.
 *
 * @param request CreatePartitionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePartitionResponse
 */
@context("createPartitionWithContext")
async function createPartitionWithOptions(request: CreatePartitionRequest, headers: map[string]string, runtime: $RuntimeOptions): CreatePartitionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.ifNotExists)) {
    body['IfNotExists'] = request.ifNotExists;
  }
  if (!$isNull(request.needResult)) {
    body['NeedResult'] = request.needResult;
  }
  if (!$isNull(request.partitionInput)) {
    body['PartitionInput'] = request.partitionInput;
  }
  if (!$isNull(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreatePartition',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Add a partition to the data table of the data lake.
 *
 * @param request CreatePartitionRequest
 * @return CreatePartitionResponse
 */
async function createPartition(request: CreatePartitionRequest): CreatePartitionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createPartitionWithOptions(request, headers, runtime);
}

model CreateRoleRequest {
  body?: RoleInput(name='body', description='The HTTP request body, in the JSON format.'),
}

model CreateRoleResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='77BC2016-BA80-570F-BD15-2FB80281FED6'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model CreateRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRoleResponseBody(name='body'),
}

/**
 * @summary In the Data Lake Permissions section, add a role.
 *
 * @param request CreateRoleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRoleResponse
 */
@context("createRoleWithContext")
async function createRoleWithOptions(request: CreateRoleRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateRoleResponse {
  request.validate();
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateRole',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary In the Data Lake Permissions section, add a role.
 *
 * @param request CreateRoleRequest
 * @return CreateRoleResponse
 */
async function createRole(request: CreateRoleRequest): CreateRoleResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createRoleWithOptions(request, headers, runtime);
}

model CreateTableRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  tableInput?: TableInput(name='TableInput', description='The details about the data table.'),
}

model CreateTableResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model CreateTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTableResponseBody(name='body'),
}

/**
 * @summary Add a data table for the data lake.
 *
 * @param request CreateTableRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTableResponse
 */
@context("createTableWithContext")
async function createTableWithOptions(request: CreateTableRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateTableResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.tableInput)) {
    body['TableInput'] = request.tableInput;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Add a data table for the data lake.
 *
 * @param request CreateTableRequest
 * @return CreateTableResponse
 */
async function createTable(request: CreateTableRequest): CreateTableResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createTableWithOptions(request, headers, runtime);
}

model DeleteCatalogRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.

This parameter is required.', example='catalog_test'),
  isAsync?: boolean(name='IsAsync', description='Whether asynchronous, synchronous by default.', example='true'),
}

model DeleteCatalogResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
  taskId?: string(name='TaskId', description='The ID of the task for asynchronously deleting a catalog.', example='c38206c3aca0c41332ffe49294243009'),
}

model DeleteCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCatalogResponseBody(name='body'),
}

/**
 * @summary Deletes a data directory.
 *
 * @param request DeleteCatalogRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCatalogResponse
 */
@context("deleteCatalogWithContext")
async function deleteCatalogWithOptions(request: DeleteCatalogRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteCatalogResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.isAsync)) {
    query['IsAsync'] = request.isAsync;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteCatalog',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a data directory.
 *
 * @param request DeleteCatalogRequest
 * @return DeleteCatalogResponse
 */
async function deleteCatalog(request: DeleteCatalogRequest): DeleteCatalogResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteCatalogWithOptions(request, headers, runtime);
}

model DeleteDatabaseRequest {
  async?: boolean(name='Async', description='Whether to asynchronously execute.', example='true'),
  cascade?: boolean(name='Cascade', description='Whether to cascade delete data. Valid values:

*   true: deletes a table from the database.
*   false: does not delete tables from the database. If a table still exists in the database, the deletion fails.', example='false'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  name?: string(name='Name', description='The name of a database.', example='database_test'),
}

model DeleteDatabaseResponseBody = {
  code?: string(name='Code', description='The description of the distribution status.', example='OK'),
  message?: string(name='Message', description='A related error message is displayed.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='73201200-4C1A-4FEF-BD6B-C0DA7994FFA2'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
  taskId?: string(name='TaskId', description='The ID of the task that is used to asynchronously delete a database.', example='c38206c3aca0c41332ffe49294243009'),
}

model DeleteDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDatabaseResponseBody(name='body'),
}

/**
 * @summary Deletes a database in the data lake by name.
 *
 * @param request DeleteDatabaseRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDatabaseResponse
 */
@context("deleteDatabaseWithContext")
async function deleteDatabaseWithOptions(request: DeleteDatabaseRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteDatabaseResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.async)) {
    query['Async'] = request.async;
  }
  if (!$isNull(request.cascade)) {
    query['Cascade'] = request.cascade;
  }
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteDatabase',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a database in the data lake by name.
 *
 * @param request DeleteDatabaseRequest
 * @return DeleteDatabaseResponse
 */
async function deleteDatabase(request: DeleteDatabaseRequest): DeleteDatabaseResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDatabaseWithOptions(request, headers, runtime);
}

model DeleteFunctionRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  functionName?: string(name='FunctionName', description='The function name.', example='func2'),
}

model DeleteFunctionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeleteFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFunctionResponseBody(name='body'),
}

/**
 * @summary Deletes a user-defined function for a database in the data lake by name.
 *
 * @param request DeleteFunctionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFunctionResponse
 */
@context("deleteFunctionWithContext")
async function deleteFunctionWithOptions(request: DeleteFunctionRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteFunctionResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteFunction',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a user-defined function for a database in the data lake by name.
 *
 * @param request DeleteFunctionRequest
 * @return DeleteFunctionResponse
 */
async function deleteFunction(request: DeleteFunctionRequest): DeleteFunctionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionWithOptions(request, headers, runtime);
}

model DeletePartitionRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  ifExists?: boolean(name='IfExists', description='Specifies whether to ignore errors if the partition that you want to delete does not exist. Valid values:

*   true: ignores errors and no error will be reported.
*   false: does not ignore errors and errors will be reported.', example='true'),
  partitionValues?: [ string ](name='PartitionValues', description='The values of the partition key columns.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201225'),
}

model DeletePartitionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeletePartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePartitionResponseBody(name='body'),
}

/**
 * @summary Deletes a specified partition from a data table in the data lake.
 *
 * @param request DeletePartitionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePartitionResponse
 */
@context("deletePartitionWithContext")
async function deletePartitionWithOptions(request: DeletePartitionRequest, headers: map[string]string, runtime: $RuntimeOptions): DeletePartitionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.ifExists)) {
    body['IfExists'] = request.ifExists;
  }
  if (!$isNull(request.partitionValues)) {
    body['PartitionValues'] = request.partitionValues;
  }
  if (!$isNull(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeletePartition',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a specified partition from a data table in the data lake.
 *
 * @param request DeletePartitionRequest
 * @return DeletePartitionResponse
 */
async function deletePartition(request: DeletePartitionRequest): DeletePartitionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePartitionWithOptions(request, headers, runtime);
}

model DeletePartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  columnNames?: [ string ](name='ColumnNames', description='The key columns of the partitions.'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  partitionNames?: [ string ](name='PartitionNames', description='The names of the partitions.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model DeletePartitionColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  columnNamesShrink?: string(name='ColumnNames', description='The key columns of the partitions.'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  partitionNamesShrink?: string(name='PartitionNames', description='The names of the partitions.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model DeletePartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeletePartitionColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePartitionColumnStatisticsResponseBody(name='body'),
}

/**
 * @summary Reclaim the field statistics of data table partitions in the data lake.
 *
 * @param tmpReq DeletePartitionColumnStatisticsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePartitionColumnStatisticsResponse
 */
@context("deletePartitionColumnStatisticsWithContext")
async function deletePartitionColumnStatisticsWithOptions(tmpReq: DeletePartitionColumnStatisticsRequest, headers: map[string]string, runtime: $RuntimeOptions): DeletePartitionColumnStatisticsResponse {
  tmpReq.validate();
  var request = new DeletePartitionColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  if (!$isNull(tmpReq.partitionNames)) {
    request.partitionNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.partitionNames, 'PartitionNames', 'json');
  }
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.columnNamesShrink)) {
    query['ColumnNames'] = request.columnNamesShrink;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.partitionNamesShrink)) {
    query['PartitionNames'] = request.partitionNamesShrink;
  }
  if (!$isNull(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeletePartitionColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/columnstatistics`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Reclaim the field statistics of data table partitions in the data lake.
 *
 * @param request DeletePartitionColumnStatisticsRequest
 * @return DeletePartitionColumnStatisticsResponse
 */
async function deletePartitionColumnStatistics(request: DeletePartitionColumnStatisticsRequest): DeletePartitionColumnStatisticsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePartitionColumnStatisticsWithOptions(request, headers, runtime);
}

model DeleteRoleRequest {
  roleName?: string(name='RoleName', description='The name of the role to be deleted.', example='roleId/roleName至少有一个是非空'),
}

model DeleteRoleResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeleteRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRoleResponseBody(name='body'),
}

/**
 * @summary Delete a role from Data Lake Permissions.
 *
 * @param request DeleteRoleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRoleResponse
 */
@context("deleteRoleWithContext")
async function deleteRoleWithOptions(request: DeleteRoleRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteRoleResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.roleName)) {
    query['RoleName'] = request.roleName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteRole',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete a role from Data Lake Permissions.
 *
 * @param request DeleteRoleRequest
 * @return DeleteRoleResponse
 */
async function deleteRole(request: DeleteRoleRequest): DeleteRoleResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRoleWithOptions(request, headers, runtime);
}

model DeleteTableRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model DeleteTableResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeleteTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTableResponseBody(name='body'),
}

/**
 * @summary Deletes a data table in a data lake by name.
 *
 * @param request DeleteTableRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTableResponse
 */
@context("deleteTableWithContext")
async function deleteTableWithOptions(request: DeleteTableRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteTableResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a data table in a data lake by name.
 *
 * @param request DeleteTableRequest
 * @return DeleteTableResponse
 */
async function deleteTable(request: DeleteTableRequest): DeleteTableResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTableWithOptions(request, headers, runtime);
}

model DeleteTableColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  columnNames?: [ string ](name='ColumnNames', description='The list of column names.'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model DeleteTableColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  columnNamesShrink?: string(name='ColumnNames', description='The list of column names.'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model DeleteTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeleteTableColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTableColumnStatisticsResponseBody(name='body'),
}

/**
 * @summary Recycle field statistics for data tables in the data lake.
 *
 * @param tmpReq DeleteTableColumnStatisticsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTableColumnStatisticsResponse
 */
@context("deleteTableColumnStatisticsWithContext")
async function deleteTableColumnStatisticsWithOptions(tmpReq: DeleteTableColumnStatisticsRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteTableColumnStatisticsResponse {
  tmpReq.validate();
  var request = new DeleteTableColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.columnNamesShrink)) {
    query['ColumnNames'] = request.columnNamesShrink;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteTableColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/columnstatistics`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Recycle field statistics for data tables in the data lake.
 *
 * @param request DeleteTableColumnStatisticsRequest
 * @return DeleteTableColumnStatisticsResponse
 */
async function deleteTableColumnStatistics(request: DeleteTableColumnStatisticsRequest): DeleteTableColumnStatisticsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTableColumnStatisticsWithOptions(request, headers, runtime);
}

model DeleteTableVersionRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
  versionId?: int32(name='VersionId', description='The version number.', example='1'),
}

model DeleteTableVersionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeleteTableVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTableVersionResponseBody(name='body'),
}

/**
 * @summary Deletes a specified version of a data table in the data lake.
 *
 * @param request DeleteTableVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTableVersionResponse
 */
@context("deleteTableVersionWithContext")
async function deleteTableVersionWithOptions(request: DeleteTableVersionRequest, headers: map[string]string, runtime: $RuntimeOptions): DeleteTableVersionResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  if (!$isNull(request.versionId)) {
    query['VersionId'] = request.versionId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteTableVersion',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/versions`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a specified version of a data table in the data lake.
 *
 * @param request DeleteTableVersionRequest
 * @return DeleteTableVersionResponse
 */
async function deleteTableVersion(request: DeleteTableVersionRequest): DeleteTableVersionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTableVersionWithOptions(request, headers, runtime);
}

model DeregisterLocationRequest {
  locationId?: string(name='LocationId', description='Location ID

>  You can call the RegisterLocation operation to obtain the Location ID.

This parameter is required.', example='LOC-AB8FBC17F95A4AF5'),
}

model DeregisterLocationResponseBody = {
  data?: {
    locationId?: string(name='LocationId', description='Location ID', example='LOC-AB8FBC17F95A4AF5'),
    storageCollectTaskOperationResultList?: [
      StorageCollectTaskOperationResult
    ](name='StorageCollectTaskOperationResultList', description='The list of the collection tasks that are disabled.'),
  }(name='Data', description='Response parameters'),
  requestId?: string(name='RequestId', description='The request ID.', example='E47920CD-BAE6-1305-88DF-FBDD3D300845'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true.
*   false: The request failed.', example='true'),
}

model DeregisterLocationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeregisterLocationResponseBody(name='body'),
}

/**
 * @summary Cancel Location registration.
 *
 * @param request DeregisterLocationRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeregisterLocationResponse
 */
@context("deregisterLocationWithContext")
async function deregisterLocationWithOptions(request: DeregisterLocationRequest, headers: map[string]string, runtime: $RuntimeOptions): DeregisterLocationResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.locationId)) {
    query['LocationId'] = request.locationId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeregisterLocation',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/locations`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Cancel Location registration.
 *
 * @param request DeregisterLocationRequest
 * @return DeregisterLocationResponse
 */
async function deregisterLocation(request: DeregisterLocationRequest): DeregisterLocationResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return deregisterLocationWithOptions(request, headers, runtime);
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      description?: string(name='Description', description='The description of the filtering table.'),
      name?: string(name='Name', description='The name of the data.', example='cn-hangzhou'),
      showName?: string(name='ShowName', description='The display name.'),
      type?: string(name='Type', description='The type.', example='region'),
    }
  ](name='Regions', description='The region list.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the test feature is enabled.', example='true'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @summary Obtains the list of open regions.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
@context("describeRegionsWithContext")
async function describeRegionsWithOptions(headers: map[string]string, runtime: $RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeRegions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/service/describeRegions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the list of open regions.
 *
 * @return DescribeRegionsResponse
 */
async function describeRegions(): DescribeRegionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(headers, runtime);
}

model GetAsyncTaskStatusRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  taskId?: string(name='TaskId', description='The result returned by the asynchronous task.', example='f546c761570e5efc8146a1986f7890d2'),
}

model GetAsyncTaskStatusResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The message that is returned.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  taskStatus?: TaskStatus(name='TaskStatus', description='The task status.', example='Success'),
}

model GetAsyncTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAsyncTaskStatusResponseBody(name='body'),
}

/**
 * @summary Used in metadata-related asynchronous APIs to check the status of asynchronous execution tasks.
 *
 * @param request GetAsyncTaskStatusRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAsyncTaskStatusResponse
 */
@context("getAsyncTaskStatusWithContext")
async function getAsyncTaskStatusWithOptions(request: GetAsyncTaskStatusRequest, headers: map[string]string, runtime: $RuntimeOptions): GetAsyncTaskStatusResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.taskId)) {
    query['TaskId'] = request.taskId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetAsyncTaskStatus',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Used in metadata-related asynchronous APIs to check the status of asynchronous execution tasks.
 *
 * @param request GetAsyncTaskStatusRequest
 * @return GetAsyncTaskStatusResponse
 */
async function getAsyncTaskStatus(request: GetAsyncTaskStatusRequest): GetAsyncTaskStatusResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getAsyncTaskStatusWithOptions(request, headers, runtime);
}

model GetCatalogRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='catalog_test'),
}

model GetCatalogResponseBody = {
  catalog?: Catalog(name='Catalog', description='The catalog details.'),
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The returned message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='DB07AAE9-4B88-5DEA-8F1D-4D1A9A864A85'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model GetCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCatalogResponseBody(name='body'),
}

/**
 * @summary Obtains the details of a data directory.
 *
 * @param request GetCatalogRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCatalogResponse
 */
@context("getCatalogWithContext")
async function getCatalogWithOptions(request: GetCatalogRequest, headers: map[string]string, runtime: $RuntimeOptions): GetCatalogResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetCatalog',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the details of a data directory.
 *
 * @param request GetCatalogRequest
 * @return GetCatalogResponse
 */
async function getCatalog(request: GetCatalogRequest): GetCatalogResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getCatalogWithOptions(request, headers, runtime);
}

model GetCatalogSettingsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
}

model GetCatalogSettingsResponseBody = {
  catalogSettings?: CatalogSettings(name='CatalogSettings', description='The data lake configurations.'),
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model GetCatalogSettingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCatalogSettingsResponseBody(name='body'),
}

/**
 * @summary To obtain the configurations of Data Lake Catalog, you must assume the admin role or above.
 *
 * @param request GetCatalogSettingsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCatalogSettingsResponse
 */
@context("getCatalogSettingsWithContext")
async function getCatalogSettingsWithOptions(request: GetCatalogSettingsRequest, headers: map[string]string, runtime: $RuntimeOptions): GetCatalogSettingsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetCatalogSettings',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/settings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary To obtain the configurations of Data Lake Catalog, you must assume the admin role or above.
 *
 * @param request GetCatalogSettingsRequest
 * @return GetCatalogSettingsResponse
 */
async function getCatalogSettings(request: GetCatalogSettingsRequest): GetCatalogSettingsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getCatalogSettingsWithOptions(request, headers, runtime);
}

model GetDatabaseRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  name?: string(name='Name', description='The name of a database.', example='database_test'),
}

model GetDatabaseResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  database?: Database(name='Database', description='The database object.', example='{"name":"test"}'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D659761F-29C3-409D-805A-0CF33A320128'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model GetDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDatabaseResponseBody(name='body'),
}

/**
 * @summary Obtains the details of a database in a data lake.
 *
 * @param request GetDatabaseRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDatabaseResponse
 */
@context("getDatabaseWithContext")
async function getDatabaseWithOptions(request: GetDatabaseRequest, headers: map[string]string, runtime: $RuntimeOptions): GetDatabaseResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDatabase',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the details of a database in a data lake.
 *
 * @param request GetDatabaseRequest
 * @return GetDatabaseResponse
 */
async function getDatabase(request: GetDatabaseRequest): GetDatabaseResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getDatabaseWithOptions(request, headers, runtime);
}

model GetDatabaseProfileRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory. By default, the ID of the primary account is entered.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of the metadatabase.

This parameter is required.', example='530_db'),
}

model GetDatabaseProfileResponseBody = {
  code?: string(name='Code', description='The error code.', example='200'),
  databaseProfile?: DatabaseProfile(name='DatabaseProfile', description='The data profile of the database.', example='{
	"FileCnt": 213,
	"FileSize": 34324
}'),
  message?: string(name='Message', description='The error message.', example='-'),
  requestId?: string(name='RequestId', description='The request ID.', example='AEA7DCC8-DBF5-561B-A7FD-0747D7D51FEB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model GetDatabaseProfileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDatabaseProfileResponseBody(name='body'),
}

/**
 * @summary Gets the details of the database data profile.
 *
 * @description To use a data profile, you must first host the OSS bucket of the database.
 *
 * @param request GetDatabaseProfileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDatabaseProfileResponse
 */
@context("getDatabaseProfileWithContext")
async function getDatabaseProfileWithOptions(request: GetDatabaseProfileRequest, headers: map[string]string, runtime: $RuntimeOptions): GetDatabaseProfileResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDatabaseProfile',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/metastorehouse/catalog/database/databaseprofile`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Gets the details of the database data profile.
 *
 * @description To use a data profile, you must first host the OSS bucket of the database.
 *
 * @param request GetDatabaseProfileRequest
 * @return GetDatabaseProfileResponse
 */
async function getDatabaseProfile(request: GetDatabaseProfileRequest): GetDatabaseProfileResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getDatabaseProfileWithOptions(request, headers, runtime);
}

model GetFunctionRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  functionName?: string(name='FunctionName', description='The name of the user-defined function.', example='func2'),
}

model GetFunctionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  function?: Function(name='Function', description='The details about the function.', example='{"FunctionName":test}'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GetFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionResponseBody(name='body'),
}

/**
 * @summary Obtain the user-defined function of the database in the data lake based on the function name.
 *
 * @param request GetFunctionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionResponse
 */
@context("getFunctionWithContext")
async function getFunctionWithOptions(request: GetFunctionRequest, headers: map[string]string, runtime: $RuntimeOptions): GetFunctionResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetFunction',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtain the user-defined function of the database in the data lake based on the function name.
 *
 * @param request GetFunctionRequest
 * @return GetFunctionResponse
 */
async function getFunction(request: GetFunctionRequest): GetFunctionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionWithOptions(request, headers, runtime);
}

model GetLifecycleRuleRequest {
  bizId?: string(name='BizId', description='The business ID.', example='LCRU-17E7192705C365C0'),
  resourceName?: string(name='ResourceName', description='The name of the resource, which is a string that consists of the data directory, database, and table.', example='demo_catalog_id.demo_db_name.demo_table_name'),
}

model GetLifecycleRuleResponseBody = {
  data?: LifecycleRule(name='Data', description='The information about the lifecycle rule.'),
  requestId?: string(name='RequestId', description='The request ID.', example='EDBC848F-7CC7-52E3-9FBF-924D09B5C27A'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false.', example='True'),
}

model GetLifecycleRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLifecycleRuleResponseBody(name='body'),
}

/**
 * @summary Obtains the lifecycle rules of a database and table.
 *
 * @param request GetLifecycleRuleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLifecycleRuleResponse
 */
@context("getLifecycleRuleWithContext")
async function getLifecycleRuleWithOptions(request: GetLifecycleRuleRequest, headers: map[string]string, runtime: $RuntimeOptions): GetLifecycleRuleResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!$isNull(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetLifecycleRule',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/metastorehouse/lifecycle/rule/getLifecycleRule`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the lifecycle rules of a database and table.
 *
 * @param request GetLifecycleRuleRequest
 * @return GetLifecycleRuleResponse
 */
async function getLifecycleRule(request: GetLifecycleRuleRequest): GetLifecycleRuleResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getLifecycleRuleWithOptions(request, headers, runtime);
}

model GetLockRequest {
  lockId?: long(name='LockId', description='The lock ID.', example='16533'),
}

model GetLockResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  lockStatus?: LockStatus(name='LockStatus', description='The lock status.', example='{"lockId":123,"lockStatus":"Acquired"}'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='558D764F-8C55-49CA-BF38-80EA532FC08F'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false.', example='True'),
}

model GetLockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLockResponseBody(name='body'),
}

/**
 * @summary Queries the specified metadata lock.
 *
 * @param request GetLockRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLockResponse
 */
@context("getLockWithContext")
async function getLockWithOptions(request: GetLockRequest, headers: map[string]string, runtime: $RuntimeOptions): GetLockResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.lockId)) {
    query['LockId'] = request.lockId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the specified metadata lock.
 *
 * @param request GetLockRequest
 * @return GetLockResponse
 */
async function getLock(request: GetLockRequest): GetLockResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getLockWithOptions(request, headers, runtime);
}

model GetPartitionRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  partitionValues?: [ string ](name='PartitionValues', description='The partitions.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
}

model GetPartitionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partition?: Partition(name='Partition', description='The partition details.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GetPartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPartitionResponseBody(name='body'),
}

/**
 * @summary Get details about the database partitions in the data lake.
 *
 * @param request GetPartitionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPartitionResponse
 */
@context("getPartitionWithContext")
async function getPartitionWithOptions(request: GetPartitionRequest, headers: map[string]string, runtime: $RuntimeOptions): GetPartitionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.partitionValues)) {
    body['PartitionValues'] = request.partitionValues;
  }
  if (!$isNull(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetPartition',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get details about the database partitions in the data lake.
 *
 * @param request GetPartitionRequest
 * @return GetPartitionResponse
 */
async function getPartition(request: GetPartitionRequest): GetPartitionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getPartitionWithOptions(request, headers, runtime);
}

model GetPartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  columnNames?: [ string ](name='ColumnNames', description='The names of the fields in the data table.'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  partitionNames?: [ string ](name='PartitionNames', description='The names of the partitions in the data table.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model GetPartitionColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  columnNamesShrink?: string(name='ColumnNames', description='The names of the fields in the data table.'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  partitionNamesShrink?: string(name='PartitionNames', description='The names of the partitions in the data table.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model GetPartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionStatisticsMap?: map[string][
    ColumnStatisticsObj
  ](name='PartitionStatisticsMap', description='The partition statistics.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GetPartitionColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPartitionColumnStatisticsResponseBody(name='body'),
}

/**
 * @summary Obtains the statistics of a specified field for a data partition in a data lake.
 *
 * @param tmpReq GetPartitionColumnStatisticsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPartitionColumnStatisticsResponse
 */
@context("getPartitionColumnStatisticsWithContext")
async function getPartitionColumnStatisticsWithOptions(tmpReq: GetPartitionColumnStatisticsRequest, headers: map[string]string, runtime: $RuntimeOptions): GetPartitionColumnStatisticsResponse {
  tmpReq.validate();
  var request = new GetPartitionColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  if (!$isNull(tmpReq.partitionNames)) {
    request.partitionNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.partitionNames, 'PartitionNames', 'json');
  }
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.columnNamesShrink)) {
    query['ColumnNames'] = request.columnNamesShrink;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.partitionNamesShrink)) {
    query['PartitionNames'] = request.partitionNamesShrink;
  }
  if (!$isNull(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetPartitionColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/columnstatistics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the statistics of a specified field for a data partition in a data lake.
 *
 * @param request GetPartitionColumnStatisticsRequest
 * @return GetPartitionColumnStatisticsResponse
 */
async function getPartitionColumnStatistics(request: GetPartitionColumnStatisticsRequest): GetPartitionColumnStatisticsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getPartitionColumnStatisticsWithOptions(request, headers, runtime);
}

model GetQueryResultRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum value is 1000.', example='100'),
  queryId?: string(name='QueryId', description='The query ID.

>  You can call the SubmitQuery operation to query the query ID.', example='Q-41676378709440CE'),
}

model GetQueryResultResponseBody = {
  duration?: long(name='Duration', description='up time in milliseconds.', example='8000'),
  endTime?: string(name='EndTime', description='The time when the query was completed.', example='2022-05-09 16:19:09'),
  errorMessage?: string(name='ErrorMessage', description='The error message of the query.', example='Table or view not found:'),
  gmtCreate?: string(name='GmtCreate', description='The time when the query was created.', example='2022-05-09 16:18:09'),
  gmtModified?: string(name='GmtModified', description='The time when the query result was updated.', example='2022-05-09 16:19:09'),
  id?: string(name='Id', description='The query ID.', example='Q-41676378709440CE'),
  jobCompleted?: boolean(name='JobCompleted', description='Whether the query has been completed. false indicates that you need to continue polling this interface.', example='true'),
  logs?: string(name='Logs', description='Run logs.', example='["this is log"]'),
  owner?: long(name='Owner', description='The uid of the primary account of the creator.', example='229167306180609***'),
  progress?: int32(name='Progress', description='The progress of the query. The value ranges from 0 to 100.', example='99'),
  regionId?: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='The request ID.', example='1D2BCFBA-7639-59A9-817B-944EC1339279'),
  resultTmpDb?: string(name='ResultTmpDb', description='The result temporary library is not available.', example='db'),
  resultTmpTable?: string(name='ResultTmpTable', description='The result temporary table, which is not available.', example='table'),
  rowCount?: int32(name='RowCount', description='The total number of rows in the result. This parameter is returned only when the status is AVAILABLE.', example='100'),
  rowCountOverLimit?: boolean(name='RowCountOverLimit', description='Whether the total number of rows in the result exceeds the maximum value.', example='false'),
  rows?: string(name='Rows', description='The returned result. This value is returned only when the status is AVAILABLE. The content is represented as a two-dimensional JSON array.', example='[[10,"Tom"],[11,"Jerry"]]'),
  schema?: string(name='Schema', description='The header field and type of the query result. This parameter is returned only when the status is AVAILABLE.', example='[{"name":"id","type":"INT"},{"name":"student_name","type":"VARCHAR"}]'),
  sql?: string(name='Sql', description='The original SQL statement.', example='select * from db.student'),
  startTime?: string(name='StartTime', description='The point in time when the query was initiated.', example='2022-05-09 16:18:09'),
  status?: string(name='Status', description='The query status.

Valid values:

*   AVAILABLE
*   CANCELLED: The has canceled.
*   RUNNING: The is running.
*   CANCELLING: The is being canceled.
*   WAITING: The is waiting for.
*   ERROR', example='AVAILABLE'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
  totalBytesProcessed?: long(name='TotalBytesProcessed', description='The total amount of data scanned. Unit: bytes.', example='1024'),
}

model GetQueryResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQueryResultResponseBody(name='body'),
}

/**
 * @summary Obtains the results of a data exploration query.
 *
 * @param request GetQueryResultRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetQueryResultResponse
 */
@context("getQueryResultWithContext")
async function getQueryResultWithOptions(request: GetQueryResultRequest, headers: map[string]string, runtime: $RuntimeOptions): GetQueryResultResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.queryId)) {
    query['QueryId'] = request.queryId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetQueryResult',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/getQueryResult`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the results of a data exploration query.
 *
 * @param request GetQueryResultRequest
 * @return GetQueryResultResponse
 */
async function getQueryResult(request: GetQueryResultRequest): GetQueryResultResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getQueryResultWithOptions(request, headers, runtime);
}

model GetRegionStatusRequest {
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
}

model GetRegionStatusResponseBody = {
  data?: {
    accountStatus?: string(name='AccountStatus', description='Account status enabled or disabled', example='enabled'),
    isDependencyReady?: boolean(name='IsDependencyReady', description='Whether the dependency is ready', example='true'),
    isDlfServiceOpen?: boolean(name='IsDlfServiceOpen', description='Whether the DLF service is activated', example='True'),
    regionId?: string(name='RegionId', description='region id', example='cn_hangzhou'),
    regionStatus?: string(name='RegionStatus', description='The status of the region. SERVICE_INVALID: The service is unavailable. UNITITIALIZED: Not initialized. READY: Normal.', example='READY'),
  }(name='Data', description='The returned data.', example='{\\\\"RegionId\\\\": \\\\"cn-shanghai\\\\", \\\\"RegionStatus\\\\": \\\\"SERVICE_INVALID\\\\", \\\\"AccountStatus\\\\": \\\\"\\\\", \\\\"IsDlfServiceOpen\\\\": False}'),
  requestId?: string(name='RequestId', description='The request ID.', example='CC58A776-0662-5C6D-B467-FFD4CF7F4C40'),
  success?: string(name='Success', description='Indicates whether the request is successful.', example='true'),
}

model GetRegionStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRegionStatusResponseBody(name='body'),
}

/**
 * @summary You can Data Lake Formation the activation status of the service in the specified region.
 *
 * @param request GetRegionStatusRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRegionStatusResponse
 */
@context("getRegionStatusWithContext")
async function getRegionStatusWithOptions(request: GetRegionStatusRequest, headers: map[string]string, runtime: $RuntimeOptions): GetRegionStatusResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetRegionStatus',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/service/getRegionStatus`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can Data Lake Formation the activation status of the service in the specified region.
 *
 * @param request GetRegionStatusRequest
 * @return GetRegionStatusResponse
 */
async function getRegionStatus(request: GetRegionStatusRequest): GetRegionStatusResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getRegionStatusWithOptions(request, headers, runtime);
}

model GetRoleRequest {
  roleName?: string(name='RoleName', description='The name of the role.', example='role_name'),
}

model GetRoleResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4316D7DA-9816-596D-A3D7-12676FA59BDA'),
  role?: Role(name='Role', description='The information about the role.'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GetRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRoleResponseBody(name='body'),
}

/**
 * @summary Obtain the role in Data Lake Permissions based on the role name.
 *
 * @param request GetRoleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRoleResponse
 */
@context("getRoleWithContext")
async function getRoleWithOptions(request: GetRoleRequest, headers: map[string]string, runtime: $RuntimeOptions): GetRoleResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.roleName)) {
    query['RoleName'] = request.roleName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetRole',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtain the role in Data Lake Permissions based on the role name.
 *
 * @param request GetRoleRequest
 * @return GetRoleResponse
 */
async function getRole(request: GetRoleRequest): GetRoleResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getRoleWithOptions(request, headers, runtime);
}

model GetServiceStatusRequest {
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
}

model GetServiceStatusResponseBody = {
  data?: {
    hasRamPermissions?: boolean(name='HasRamPermissions', description='Whether to complete RAM authorization', example='true'),
    isDlfServiceOpen?: boolean(name='IsDlfServiceOpen', description='Whether the DLF service is activated', example='true'),
    isOssOpen?: boolean(name='IsOssOpen', description='Whether the OSS service is enabled', example='true'),
  }(name='Data', description='Service status', example='{ 			"AccountStatus":"", 			"RegionStatus":"READY", 			"RegionId":"cn-shanghai", 			"IsDependencyReady":true, 			"IsDlfServiceOpen":true 		}'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the test feature is enabled.', example='true'),
}

model GetServiceStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetServiceStatusResponseBody(name='body'),
}

/**
 * @summary Obtains the service activation status of a Data Lake Formation user.
 *
 * @param request GetServiceStatusRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetServiceStatusResponse
 */
@context("getServiceStatusWithContext")
async function getServiceStatusWithOptions(request: GetServiceStatusRequest, headers: map[string]string, runtime: $RuntimeOptions): GetServiceStatusResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetServiceStatus',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/service/getServiceStatus`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the service activation status of a Data Lake Formation user.
 *
 * @param request GetServiceStatusRequest
 * @return GetServiceStatusResponse
 */
async function getServiceStatus(request: GetServiceStatusRequest): GetServiceStatusResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceStatusWithOptions(request, headers, runtime);
}

model GetTableRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
}

model GetTableResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
  table?: Table(name='Table', description='The details about the data table.'),
}

model GetTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTableResponseBody(name='body'),
}

/**
 * @summary Get detailed information about the data tables in the data lake.
 *
 * @param request GetTableRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTableResponse
 */
@context("getTableWithContext")
async function getTableWithOptions(request: GetTableRequest, headers: map[string]string, runtime: $RuntimeOptions): GetTableResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get detailed information about the data tables in the data lake.
 *
 * @param request GetTableRequest
 * @return GetTableResponse
 */
async function getTable(request: GetTableRequest): GetTableResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableWithOptions(request, headers, runtime);
}

model GetTableColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  columnNames?: [ string ](name='ColumnNames', description='The names of the columns in the data table.'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model GetTableColumnStatisticsShrinkRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  columnNamesShrink?: string(name='ColumnNames', description='The names of the columns in the data table.'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model GetTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  columnStatisticsObjList?: [
    ColumnStatisticsObj
  ](name='ColumnStatisticsObjList', description='The list of column statistics.', example='[]'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   true and
*   false', example='true'),
}

model GetTableColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTableColumnStatisticsResponseBody(name='body'),
}

/**
 * @summary You can call this operation to obtain statistics about a specified field in a data table in a data lake.
 *
 * @param tmpReq GetTableColumnStatisticsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTableColumnStatisticsResponse
 */
@context("getTableColumnStatisticsWithContext")
async function getTableColumnStatisticsWithOptions(tmpReq: GetTableColumnStatisticsRequest, headers: map[string]string, runtime: $RuntimeOptions): GetTableColumnStatisticsResponse {
  tmpReq.validate();
  var request = new GetTableColumnStatisticsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.columnNames)) {
    request.columnNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnNames, 'ColumnNames', 'json');
  }
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.columnNamesShrink)) {
    query['ColumnNames'] = request.columnNamesShrink;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetTableColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/columnstatistics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call this operation to obtain statistics about a specified field in a data table in a data lake.
 *
 * @param request GetTableColumnStatisticsRequest
 * @return GetTableColumnStatisticsResponse
 */
async function getTableColumnStatistics(request: GetTableColumnStatisticsRequest): GetTableColumnStatisticsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableColumnStatisticsWithOptions(request, headers, runtime);
}

model GetTableProfileRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory. By default, the ID of the primary account is entered.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of the metadatabase.

This parameter is required.', example='exp_table'),
  tableName?: string(name='TableName', description='The name of the metadata table.

This parameter is required.', example='admin_user'),
}

model GetTableProfileResponseBody = {
  code?: string(name='Code', description='The error code.', example='OK'),
  message?: string(name='Message', description='The error message.', example='None'),
  requestId?: string(name='RequestId', description='The request ID.', example='C742A04F-F304-5440-9ED8-AD58C36D1915'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
  tableProfile?: TableProfile(name='TableProfile', description='The data profile of the table.'),
}

model GetTableProfileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTableProfileResponseBody(name='body'),
}

/**
 * @summary Obtains the details of a table data profile.
 *
 * @description To use a data profile, you must first host the OSS bucket of the table.
 *
 * @param request GetTableProfileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTableProfileResponse
 */
@context("getTableProfileWithContext")
async function getTableProfileWithOptions(request: GetTableProfileRequest, headers: map[string]string, runtime: $RuntimeOptions): GetTableProfileResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetTableProfile',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/metastorehouse/catalog/database/tableprofile`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the details of a table data profile.
 *
 * @description To use a data profile, you must first host the OSS bucket of the table.
 *
 * @param request GetTableProfileRequest
 * @return GetTableProfileResponse
 */
async function getTableProfile(request: GetTableProfileRequest): GetTableProfileResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableProfileWithOptions(request, headers, runtime);
}

model GetTableVersionRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
  versionId?: int32(name='VersionId', description='The version number of the data table.', example='1'),
}

model GetTableVersionResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  tableVersion?: TableVersion(name='TableVersion', description='The information about the data table of the specified version.', example='{"VersionId":123,"Table":{}}'),
}

model GetTableVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTableVersionResponseBody(name='body'),
}

/**
 * @summary Gets a specified version of a data table in the data lake.
 *
 * @param request GetTableVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTableVersionResponse
 */
@context("getTableVersionWithContext")
async function getTableVersionWithOptions(request: GetTableVersionRequest, headers: map[string]string, runtime: $RuntimeOptions): GetTableVersionResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  if (!$isNull(request.versionId)) {
    query['VersionId'] = request.versionId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetTableVersion',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Gets a specified version of a data table in the data lake.
 *
 * @param request GetTableVersionRequest
 * @return GetTableVersionResponse
 */
async function getTableVersion(request: GetTableVersionRequest): GetTableVersionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableVersionWithOptions(request, headers, runtime);
}

model GrantPermissionsRequest {
  accesses?: [ string ](name='Accesses', description='The list of the access permissions to be granted.

This parameter is required.'),
  catalogId?: string(name='CatalogId', description='The catalog ID.'),
  delegateAccesses?: [ string ](name='DelegateAccesses', description='The list of the grantable access permissions to be granted.

This parameter is required.'),
  metaResource?: MetaResource(name='MetaResource', description='The metadata resource to be authorized.

This parameter is required.'),
  principal?: Principal(name='Principal', description='The users or roles to be authorized. Formats:

*   RAM user: acs:ram::[accountId]:user/[userName]
*   RAM role: acs:ram::[accountId]:role/[roleName]
*   Data lake role: acs:dlf::[accountId]:role/[roleName]

This parameter is required.'),
  type?: string(name='Type', description='The authorization type. Only Hive is supported.

This parameter is required.', example='Hive'),
}

model GrantPermissionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4912024D-2A06-5E9F-9667-35D9319917D7'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GrantPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GrantPermissionsResponseBody(name='body'),
}

/**
 * @summary Grant the operation permissions on resources to the User /Data Lake role.
 *
 * @param request GrantPermissionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantPermissionsResponse
 */
@context("grantPermissionsWithContext")
async function grantPermissionsWithOptions(request: GrantPermissionsRequest, headers: map[string]string, runtime: $RuntimeOptions): GrantPermissionsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.accesses)) {
    body['Accesses'] = request.accesses;
  }
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.delegateAccesses)) {
    body['DelegateAccesses'] = request.delegateAccesses;
  }
  if (!$isNull(request.metaResource)) {
    body['MetaResource'] = request.metaResource;
  }
  if (!$isNull(request.principal)) {
    body['Principal'] = request.principal;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GrantPermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/grant`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Grant the operation permissions on resources to the User /Data Lake role.
 *
 * @param request GrantPermissionsRequest
 * @return GrantPermissionsResponse
 */
async function grantPermissions(request: GrantPermissionsRequest): GrantPermissionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return grantPermissionsWithOptions(request, headers, runtime);
}

model GrantRoleToUsersRequest {
  roleName?: string(name='RoleName', description='The name of the role.', example='test_role_8'),
  users?: [
  Principal
](name='Users', description='The RAM users or roles to which you want to assign the role. Format:

*   RAM user: acs:ram::[accountId]:user/[userName].
*   RAM role: acs:ram::[accountId]:role/[roleName].'),
}

model GrantRoleToUsersResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4316D7DA-9816-596D-A3D7-12676FA59BDA'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GrantRoleToUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GrantRoleToUsersResponseBody(name='body'),
}

/**
 * @summary Grant a Data Lake role to multiple users.
 *
 * @param request GrantRoleToUsersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantRoleToUsersResponse
 */
@context("grantRoleToUsersWithContext")
async function grantRoleToUsersWithOptions(request: GrantRoleToUsersRequest, headers: map[string]string, runtime: $RuntimeOptions): GrantRoleToUsersResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.roleName)) {
    body['RoleName'] = request.roleName;
  }
  if (!$isNull(request.users)) {
    body['Users'] = request.users;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GrantRoleToUsers',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/grantusers`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Grant a Data Lake role to multiple users.
 *
 * @param request GrantRoleToUsersRequest
 * @return GrantRoleToUsersResponse
 */
async function grantRoleToUsers(request: GrantRoleToUsersRequest): GrantRoleToUsersResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return grantRoleToUsersWithOptions(request, headers, runtime);
}

model GrantRolesToUserRequest {
  roleNames?: [ string ](name='RoleNames', description='The roles to be assigned to the user.

This parameter is required.'),
  user?: Principal(name='User', description='The user to which you want to assign roles. Format:

*   RAM roles: acs:ram::[accountId]:role/[roleName].
*   RAM user: acs:ram::[accountId]:user/[userName].

This parameter is required.'),
}

model GrantRolesToUserResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='81B90E1B-7514-5817-9D59-0EA9E2215876'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GrantRolesToUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GrantRolesToUserResponseBody(name='body'),
}

/**
 * @summary Grant multiple roles to a single user.
 *
 * @param request GrantRolesToUserRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantRolesToUserResponse
 */
@context("grantRolesToUserWithContext")
async function grantRolesToUserWithOptions(request: GrantRolesToUserRequest, headers: map[string]string, runtime: $RuntimeOptions): GrantRolesToUserResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.roleNames)) {
    body['RoleNames'] = request.roleNames;
  }
  if (!$isNull(request.user)) {
    body['User'] = request.user;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GrantRolesToUser',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/grantroles`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Grant multiple roles to a single user.
 *
 * @param request GrantRolesToUserRequest
 * @return GrantRolesToUserResponse
 */
async function grantRolesToUser(request: GrantRolesToUserRequest): GrantRolesToUserResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return grantRolesToUserWithOptions(request, headers, runtime);
}

model ListCatalogsRequest {
  idPattern?: string(name='IdPattern', description='Regular matching of CatalogId', example='.*'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is returned from the returned result. If none is returned, an empty string or\\\\"\\\\"', example='‘’'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
}

model ListCatalogsResponseBody = {
  catalogs?: [
    Catalog
  ](name='Catalogs', description='The catalogs.', example='[{"CatalogId":"xx"}]'),
  code?: string(name='Code', description='Status Code Description', example='OK'),
  message?: string(name='Message', description='The error message that is returned.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='Page Flip token', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the test feature is enabled.', example='true'),
}

model ListCatalogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCatalogsResponseBody(name='body'),
}

/**
 * @summary You can call this operation to query the list of metabase namespaces (catalogs).
 *
 * @param request ListCatalogsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCatalogsResponse
 */
@context("listCatalogsWithContext")
async function listCatalogsWithOptions(request: ListCatalogsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListCatalogsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.idPattern)) {
    query['IdPattern'] = request.idPattern;
  }
  if (!$isNull(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListCatalogs',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call this operation to query the list of metabase namespaces (catalogs).
 *
 * @param request ListCatalogsRequest
 * @return ListCatalogsResponse
 */
async function listCatalogs(request: ListCatalogsRequest): ListCatalogsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listCatalogsWithOptions(request, headers, runtime);
}

model ListDatabasesRequest {
  catalogId?: string(name='CatalogId', description='The namespace of the database category. By default, the Uid of the primary account is entered.', example='1344371'),
  namePattern?: string(name='NamePattern', description='The regular expression used to match the database name. If all matches are specified, this parameter is specified. \\\\*', example='.*'),
  nextPageToken?: string(name='NextPageToken', description='The paging token, which is returned by the result. For example, you can specify "" for the first page.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa!'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
}

model ListDatabasesResponseBody = {
  code?: string(name='Code', description='Description', example='OK'),
  databases?: [
    Database
  ](name='Databases', description='The list of databases.', example='[{"name":"test"}]'),
  message?: string(name='Message', description='The error message that is returned.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='Page Flip token', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='558D764F-8C55-49CA-BF38-80EA532FC08F'),
  success?: boolean(name='Success', description='Indicates whether the test feature is enabled.', example='true'),
}

model ListDatabasesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDatabasesResponseBody(name='body'),
}

/**
 * @summary Obtains a list of databases in the data lake and queries them by page. You can match them based on the database name.
 *
 * @param request ListDatabasesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDatabasesResponse
 */
@context("listDatabasesWithContext")
async function listDatabasesWithOptions(request: ListDatabasesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListDatabasesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.namePattern)) {
    query['NamePattern'] = request.namePattern;
  }
  if (!$isNull(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListDatabases',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a list of databases in the data lake and queries them by page. You can match them based on the database name.
 *
 * @param request ListDatabasesRequest
 * @return ListDatabasesResponse
 */
async function listDatabases(request: ListDatabasesRequest): ListDatabasesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listDatabasesWithOptions(request, headers, runtime);
}

model ListFunctionNamesRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  functionNamePattern?: string(name='FunctionNamePattern', description='The regular expression that matches the function name.', example='.*'),
  nextPageToken?: string(name='NextPageToken', description='The pagination token, which is returned from the returned result. If none is returned, an empty string or \\\\"\\\\"is passed.', example='\\\\"\\\\"'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 1000.', example='10'),
}

model ListFunctionNamesResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  functionNames?: [ string ](name='FunctionNames', description='The list of function names.'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model ListFunctionNamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionNamesResponseBody(name='body'),
}

/**
 * @summary Paged query to obtain the list of function names of the database.
 *
 * @param request ListFunctionNamesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFunctionNamesResponse
 */
@context("listFunctionNamesWithContext")
async function listFunctionNamesWithOptions(request: ListFunctionNamesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListFunctionNamesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.functionNamePattern)) {
    query['FunctionNamePattern'] = request.functionNamePattern;
  }
  if (!$isNull(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListFunctionNames',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions/names`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Paged query to obtain the list of function names of the database.
 *
 * @param request ListFunctionNamesRequest
 * @return ListFunctionNamesResponse
 */
async function listFunctionNames(request: ListFunctionNamesRequest): ListFunctionNamesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionNamesWithOptions(request, headers, runtime);
}

model ListFunctionsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  functionNamePattern?: string(name='FunctionNamePattern', description='The regular match expression for the user-defined function name.', example='.*'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data. If not provided in the response result, a string ("") or empty string (") is empty string.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 1000.', example='10'),
}

model ListFunctionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  functions?: [
    Function
  ](name='Functions', description='The details of the functions.'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model ListFunctionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionsResponseBody(name='body'),
}

/**
 * @summary Obtains a list of user-defined functions for databases in the data lake in bulk.
 *
 * @param request ListFunctionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFunctionsResponse
 */
@context("listFunctionsWithContext")
async function listFunctionsWithOptions(request: ListFunctionsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListFunctionsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.functionNamePattern)) {
    query['FunctionNamePattern'] = request.functionNamePattern;
  }
  if (!$isNull(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListFunctions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a list of user-defined functions for databases in the data lake in bulk.
 *
 * @param request ListFunctionsRequest
 * @return ListFunctionsResponse
 */
async function listFunctions(request: ListFunctionsRequest): ListFunctionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionsWithOptions(request, headers, runtime);
}

model ListPartitionNamesRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  nextPageToken?: string(name='NextPageToken', description='The pagination token. The token is obtained in the returned results. If no pagination token is returned, set this parameter to an empty string.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 1000.', example='10'),
  partialPartValues?: [ string ](name='PartialPartValues', description='The values of the partition key columns. You can pass in only the values of specific partition key columns to query the names of all lower-level partitions.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
}

model ListPartitionNamesResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  partitionNames?: [ string ](name='PartitionNames', description='The list of partition names.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model ListPartitionNamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPartitionNamesResponseBody(name='body'),
}

/**
 * @summary You can call this operation to obtain a list of partition names of data tables in a data lake. This method is usually used for multi-level partitioning.
 *
 * @param request ListPartitionNamesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPartitionNamesResponse
 */
@context("listPartitionNamesWithContext")
async function listPartitionNamesWithOptions(request: ListPartitionNamesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListPartitionNamesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.nextPageToken)) {
    body['NextPageToken'] = request.nextPageToken;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.partialPartValues)) {
    body['PartialPartValues'] = request.partialPartValues;
  }
  if (!$isNull(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListPartitionNames',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/names`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call this operation to obtain a list of partition names of data tables in a data lake. This method is usually used for multi-level partitioning.
 *
 * @param request ListPartitionNamesRequest
 * @return ListPartitionNamesResponse
 */
async function listPartitionNames(request: ListPartitionNamesRequest): ListPartitionNamesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionNamesWithOptions(request, headers, runtime);
}

model ListPartitionsRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  isShareSd?: boolean(name='IsShareSd', description='Specifies whether to share the column information of SD in the partition. Valid values:

*   true: The column information of SD in the partition is shared. In this case, only one copy of data is returned for columns with the same name. This reduces the volume of transferred data and improves the performance of this API operation.
*   false: The column information of SD in the partition is not shared.', example='true'),
  nextPageToken?: string(name='NextPageToken', description='The pagination token. The token is obtained in the return results. If no pagination token is returned, set this parameter to an empty string.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 1000.', example='10'),
  partialPartValues?: [ string ](name='PartialPartValues', description='The list of partition values. You can pass in only the values of specific partitions to query the names of all lower-level partitions.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
}

model ListPartitionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs', description='The list of partition specifications.'),
  partitions?: [
    Partition
  ](name='Partitions', description='The list of partitions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model ListPartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPartitionsResponseBody(name='body'),
}

/**
 * @summary Obtains a list of database partition details in the data lake.
 *
 * @param request ListPartitionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPartitionsResponse
 */
@context("listPartitionsWithContext")
async function listPartitionsWithOptions(request: ListPartitionsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListPartitionsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.isShareSd)) {
    body['IsShareSd'] = request.isShareSd;
  }
  if (!$isNull(request.nextPageToken)) {
    body['NextPageToken'] = request.nextPageToken;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.partialPartValues)) {
    body['PartialPartValues'] = request.partialPartValues;
  }
  if (!$isNull(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListPartitions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a list of database partition details in the data lake.
 *
 * @param request ListPartitionsRequest
 * @return ListPartitionsResponse
 */
async function listPartitions(request: ListPartitionsRequest): ListPartitionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionsWithOptions(request, headers, runtime);
}

model ListPartitionsByExprResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Obtains a list of data table partitions in the data lake and queries them by condition.
 *
 * @description You cannot specify expr to filter partitions. Currently, you need to call the listpartitionsbyfilter to complete the corresponding function.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPartitionsByExprResponse
 */
@context("listPartitionsByExprWithContext")
async function listPartitionsByExprWithOptions(headers: map[string]string, runtime: $RuntimeOptions): ListPartitionsByExprResponse {
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApiUtil.Params{
    action = 'ListPartitionsByExpr',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/listbyexpr`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains a list of data table partitions in the data lake and queries them by condition.
 *
 * @description You cannot specify expr to filter partitions. Currently, you need to call the listpartitionsbyfilter to complete the corresponding function.
 *
 * @return ListPartitionsByExprResponse
 */
async function listPartitionsByExpr(): ListPartitionsByExprResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionsByExprWithOptions(headers, runtime);
}

model ListPartitionsByFilterRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  filter?: string(name='Filter', description='The expression of the query condition. The following operators are supported:

*   Comparison operators: =, <>, ! =, <, <=, >, >=. For example: ds > 20240101.
*   Logical operators: AND, OR, and NOT. Example: ds like \\\\"20240%\\\\".
*   BETWEEN operator: specifies a range. For example: ds BETWEEN 20240101 AND 20241201.
*   IN operator: Used to specify a specific set of values. Example: ds IN (20240101, 20240102).', example='ds>20201201'),
  isShareSd?: boolean(name='IsShareSd', description='Specifies whether to share the column information in the SD of the partition. Valid values:

*   true: shared
*   false: does not share the data.', example='true'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data. If not provided in the response result, a string ("") or empty string (") is empty string.', example='\\\\"\\\\"'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum size is 1000.', example='10'),
  tableName?: string(name='TableName', description='Indicates the name of the table.', example='test_table_20200715162543389'),
}

model ListPartitionsByFilterResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs', description='The partition specifications.'),
  partitions?: [
    Partition
  ](name='Partitions', description='The details about the partitions that are queried based on the filter condition.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model ListPartitionsByFilterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPartitionsByFilterResponseBody(name='body'),
}

/**
 * @summary Obtain the list of data table partitions in the data lake and query them by filter condition.
 *
 * @param request ListPartitionsByFilterRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPartitionsByFilterResponse
 */
@context("listPartitionsByFilterWithContext")
async function listPartitionsByFilterWithOptions(request: ListPartitionsByFilterRequest, headers: map[string]string, runtime: $RuntimeOptions): ListPartitionsByFilterResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.filter)) {
    body['Filter'] = request.filter;
  }
  if (!$isNull(request.isShareSd)) {
    body['IsShareSd'] = request.isShareSd;
  }
  if (!$isNull(request.nextPageToken)) {
    body['NextPageToken'] = request.nextPageToken;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListPartitionsByFilter',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/listbyfilter`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtain the list of data table partitions in the data lake and query them by filter condition.
 *
 * @param request ListPartitionsByFilterRequest
 * @return ListPartitionsByFilterResponse
 */
async function listPartitionsByFilter(request: ListPartitionsByFilterRequest): ListPartitionsByFilterResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionsByFilterWithOptions(request, headers, runtime);
}

model ListPartitionsProfileRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory. By default, the ID of the primary account is entered.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of the metadatabase.

This parameter is required.', example='test_db'),
  pageNumber?: int32(name='PageNumber', description='Page number', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  partitionNames?: [ string ](name='PartitionNames', description='The names of partitions.'),
  tableName?: string(name='TableName', description='The name of the metadata table.', example='test_tbl'),
}

model ListPartitionsProfileShrinkRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory. By default, the ID of the primary account is entered.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of the metadatabase.

This parameter is required.', example='test_db'),
  pageNumber?: int32(name='PageNumber', description='Page number', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  partitionNamesShrink?: string(name='PartitionNames', description='The names of partitions.'),
  tableName?: string(name='TableName', description='The name of the metadata table.', example='test_tbl'),
}

model ListPartitionsProfileResponseBody = {
  code?: string(name='Code', description='The error code.', example='-'),
  data?: [
    PartitionProfile
  ](name='Data', description='The partition data profiles.'),
  latestAccessNumDate?: string(name='LatestAccessNumDate', description='The time when the access frequency is updated. This parameter is obsolete.', example='-'),
  latestDate?: string(name='LatestDate', description='The time when the metadata warehouse was updated.', example='2023-08-30 19:16:10'),
  message?: string(name='Message', description='The error message.', example='-'),
  requestId?: string(name='RequestId', description='The request ID.', example='97434FA4-A6B2-1AE4-A174-76964F29C759'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
  total?: int32(name='Total', description='The total number of entries returned.', example='10'),
}

model ListPartitionsProfileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPartitionsProfileResponseBody(name='body'),
}

/**
 * @summary Obtains the details of a partition data profile.
 *
 * @description To use a data profile, you must first host the OSS bucket of the table.
 *
 * @param tmpReq ListPartitionsProfileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPartitionsProfileResponse
 */
@context("listPartitionsProfileWithContext")
async function listPartitionsProfileWithOptions(tmpReq: ListPartitionsProfileRequest, headers: map[string]string, runtime: $RuntimeOptions): ListPartitionsProfileResponse {
  tmpReq.validate();
  var request = new ListPartitionsProfileShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.partitionNames)) {
    request.partitionNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.partitionNames, 'PartitionNames', 'simple');
  }
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.partitionNamesShrink)) {
    query['PartitionNames'] = request.partitionNamesShrink;
  }
  if (!$isNull(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListPartitionsProfile',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/metastorehouse/catalog/database/tableprofile/partitionprofile/listPartitionsProfile`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the details of a partition data profile.
 *
 * @description To use a data profile, you must first host the OSS bucket of the table.
 *
 * @param request ListPartitionsProfileRequest
 * @return ListPartitionsProfileResponse
 */
async function listPartitionsProfile(request: ListPartitionsProfileRequest): ListPartitionsProfileResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartitionsProfileWithOptions(request, headers, runtime);
}

model ListPermissionsRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  isListUserRolePermissions?: boolean(name='IsListUserRolePermissions', description='Specifies whether to obtain the permissions of the role to which the user belongs. This parameter takes effect only when you specify a specific resource object.', example='false'),
  metaResource?: MetaResource(name='MetaResource', description='The resource based on which permission information is filtered.'),
  metaResourceType?: string(name='MetaResourceType', description='The type of the resource based on which permission information is filtered, such as database or table. If you do not specify this parameter, permission information is filtered based on both databases and tables.', example='DATABASE'),
  nextPageToken?: string(name='NextPageToken', description='A pagination token, which is used to obtain data on the next page. If no pagination token is returned in the response, set this parameter to an empty string ("") or an empty character (\\\\"\\\\").', example='token!'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 1000.', example='100'),
  principal?: Principal(name='Principal', description='The principle based on which permission information is filtered.'),
  type?: string(name='Type', description='The type of permission information to be obtained. Only Hive is supported.

This parameter is required.', example='Hive'),
}

model ListPermissionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='token!'),
  principalResourcePermissionsList?: [
  PrincipalResourcePermissions
](name='PrincipalResourcePermissionsList', description='The permissions.', example='[]'),
  requestId?: string(name='RequestId', description='The request ID.', example='745EAAE2-5010-5C9F-A95C-B8FC5C1B03BF'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.'),
}

model ListPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPermissionsResponseBody(name='body'),
}

/**
 * @summary Queries permissions.
 *
 * @param request ListPermissionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPermissionsResponse
 */
@context("listPermissionsWithContext")
async function listPermissionsWithOptions(request: ListPermissionsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListPermissionsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.isListUserRolePermissions)) {
    body['IsListUserRolePermissions'] = request.isListUserRolePermissions;
  }
  if (!$isNull(request.metaResource)) {
    body['MetaResource'] = request.metaResource;
  }
  if (!$isNull(request.metaResourceType)) {
    body['MetaResourceType'] = request.metaResourceType;
  }
  if (!$isNull(request.nextPageToken)) {
    body['NextPageToken'] = request.nextPageToken;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.principal)) {
    body['Principal'] = request.principal;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListPermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries permissions.
 *
 * @param request ListPermissionsRequest
 * @return ListPermissionsResponse
 */
async function listPermissions(request: ListPermissionsRequest): ListPermissionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listPermissionsWithOptions(request, headers, runtime);
}

model ListRoleUsersRequest {
  nextPageToken?: string(name='NextPageToken', description='The pagination token, which is returned from the returned result. If none is returned, an empty string or \\\\"\\\\"is passed.', example='token!'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum value is 1000.', example='-1/100'),
  roleName?: string(name='RoleName', description='The name of the role.', example='admin'),
  userNamePattern?: string(name='UserNamePattern', description='The regular expression that matches the user name.', example='.*user.*'),
}

model ListRoleUsersResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='token!'),
  requestId?: string(name='RequestId', description='The request ID.', example='558D764F-8C55-49CA-BF38-80EA532FC08F'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  userRoles?: [
  UserRole
](name='UserRoles', description='The roles assigned to the user.'),
}

model ListRoleUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRoleUsersResponseBody(name='body'),
}

/**
 * @summary Gets the list of users for a single role.
 *
 * @param request ListRoleUsersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRoleUsersResponse
 */
@context("listRoleUsersWithContext")
async function listRoleUsersWithOptions(request: ListRoleUsersRequest, headers: map[string]string, runtime: $RuntimeOptions): ListRoleUsersResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.roleName)) {
    query['RoleName'] = request.roleName;
  }
  if (!$isNull(request.userNamePattern)) {
    query['UserNamePattern'] = request.userNamePattern;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListRoleUsers',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/roleusers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Gets the list of users for a single role.
 *
 * @param request ListRoleUsersRequest
 * @return ListRoleUsersResponse
 */
async function listRoleUsers(request: ListRoleUsersRequest): ListRoleUsersResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listRoleUsersWithOptions(request, headers, runtime);
}

model ListRolesRequest {
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data. If not provided in the response result, a string ("") or empty string (") is empty string.', example='token!'),
  pageSize?: int32(name='PageSize', description='the number of entries returned on each page, the maximum value is 1000.', example='-1/100'),
  roleNamePattern?: string(name='RoleNamePattern', description='The regular expression that matches the role name. Fuzzy search is supported, such as.\\\\*test.\\\\*.', example='.*test.*'),
}

model ListRolesResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  roles?: [
  Role
](name='Roles', description='The list of the roles.', example='[
	{
		"Description":"reserved by the system",
		"DisplayName":"admin",
		"UpdateTime":0,
		"IsPredefined":1,
		"Name":"admin"
	}
]'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false.', example='True'),
}

model ListRolesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRolesResponseBody(name='body'),
}

/**
 * @summary You can query the list of data lake roles.
 *
 * @param request ListRolesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRolesResponse
 */
@context("listRolesWithContext")
async function listRolesWithOptions(request: ListRolesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListRolesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.roleNamePattern)) {
    query['RoleNamePattern'] = request.roleNamePattern;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListRoles',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can query the list of data lake roles.
 *
 * @param request ListRolesRequest
 * @return ListRolesResponse
 */
async function listRoles(request: ListRolesRequest): ListRolesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listRolesWithOptions(request, headers, runtime);
}

model ListTableNamesRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  nextPageToken?: string(name='NextPageToken', description='The pagination token, which is returned from the returned result. If none is returned, an empty string or \\\\"\\\\"is passed.', example='\\\\"\\\\"'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  tableNamePattern?: string(name='TableNamePattern', description='The data table name matches the regular expression.', example='.*'),
  tableType?: string(name='TableType', description='The type of the data table. Valid values:

MANAGED_TABLE: internal table

EXTERNAL_TABLE: foreign table

VIRTUAL_VIEW: virtual view

INDEX_TABLE: index table

MATERIALIZED_VIEW: materialized view.', example='MANAGED_TABLE'),
}

model ListTableNamesResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
  tableNames?: [ string ](name='TableNames', description='The names of the data tables.'),
}

model ListTableNamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTableNamesResponseBody(name='body'),
}

/**
 * @summary This function is used only to query the names of data tables in Data Lake.
 *
 * @param request ListTableNamesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTableNamesResponse
 */
@context("listTableNamesWithContext")
async function listTableNamesWithOptions(request: ListTableNamesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListTableNamesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.tableNamePattern)) {
    query['TableNamePattern'] = request.tableNamePattern;
  }
  if (!$isNull(request.tableType)) {
    query['TableType'] = request.tableType;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListTableNames',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/names`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary This function is used only to query the names of data tables in Data Lake.
 *
 * @param request ListTableNamesRequest
 * @return ListTableNamesResponse
 */
async function listTableNames(request: ListTableNamesRequest): ListTableNamesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listTableNamesWithOptions(request, headers, runtime);
}

model ListTableVersionsRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data. If not provided in the response result, a string ("") or empty string (") is empty string.', example='\\\\"\\\\"'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum value is 1000.', example='10'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
}

model ListTableVersionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
  tableVersions?: [
    TableVersion
  ](name='TableVersions', description='The data tables of multiple versions.'),
}

model ListTableVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTableVersionsResponseBody(name='body'),
}

/**
 * @summary Queries the list of specified versions of data tables in a data lake by page.
 *
 * @param request ListTableVersionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTableVersionsResponse
 */
@context("listTableVersionsWithContext")
async function listTableVersionsWithOptions(request: ListTableVersionsRequest, headers: map[string]string, runtime: $RuntimeOptions): ListTableVersionsResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.tableName)) {
    query['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListTableVersions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/versions/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the list of specified versions of data tables in a data lake by page.
 *
 * @param request ListTableVersionsRequest
 * @return ListTableVersionsResponse
 */
async function listTableVersions(request: ListTableVersionsRequest): ListTableVersionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listTableVersionsWithOptions(request, headers, runtime);
}

model ListTablesRequest {
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test'),
  nextPageToken?: string(name='NextPageToken', description='The pagination token, which is returned from the returned result. If none is returned, an empty string or \\\\"\\\\"is passed.', example='\\\\"\\\\"'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  tableNamePattern?: string(name='TableNamePattern', description='The name of the data table, which is matched by a regular expression.', example='.*'),
  tableType?: string(name='TableType', description='The type of the data table. Valid values:

*   MANAGED_TABLE: internal table
*   EXTERNAL_TABLE: foreign table
*   VIRTUAL_VIEW: virtual view
*   INDEX_TABLE: index table
*   MATERIALIZED_VIEW: materialized view.', example='MANAGED_TABLE'),
}

model ListTablesResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  tables?: [
    Table
  ](name='Tables', description='The list of data tables.', example='[{"TableName":"xx"}]'),
}

model ListTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTablesResponseBody(name='body'),
}

/**
 * @summary You can call this operation to obtain a list of data tables in the data lake.
 *
 * @param request ListTablesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTablesResponse
 */
@context("listTablesWithContext")
async function listTablesWithOptions(request: ListTablesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListTablesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.tableNamePattern)) {
    query['TableNamePattern'] = request.tableNamePattern;
  }
  if (!$isNull(request.tableType)) {
    query['TableType'] = request.tableType;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListTables',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/databases/tables/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call this operation to obtain a list of data tables in the data lake.
 *
 * @param request ListTablesRequest
 * @return ListTablesResponse
 */
async function listTables(request: ListTablesRequest): ListTablesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listTablesWithOptions(request, headers, runtime);
}

model ListUserRolesRequest {
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data. If not provided in the response result, a string ("") or empty string (") is empty string.', example='token!'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum value is 1000.', example='-1/100'),
  principalArn?: string(name='PrincipalArn', description='Used to uniquely identify a RAM user or RAM role. The OSS URL is in the following format:

*   RAM user: acs:ram::[accountId]:user/[userName].
*   RAM role: acs:ram::[accountId]:role/[roleName].', example='acs:ram::1111:user/userName'),
  roleNamePattern?: string(name='RoleNamePattern', description='The regular expression that matches the role name. Fuzzy search is supported.', example='.*test.*'),
}

model ListUserRolesResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  userRoles?: [
  UserRole
](name='UserRoles', description='The roles assigned to the user.'),
}

model ListUserRolesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserRolesResponseBody(name='body'),
}

/**
 * @summary Obtains the list of data lake roles for a single user.
 *
 * @param request ListUserRolesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUserRolesResponse
 */
@context("listUserRolesWithContext")
async function listUserRolesWithOptions(request: ListUserRolesRequest, headers: map[string]string, runtime: $RuntimeOptions): ListUserRolesResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.principalArn)) {
    query['PrincipalArn'] = request.principalArn;
  }
  if (!$isNull(request.roleNamePattern)) {
    query['RoleNamePattern'] = request.roleNamePattern;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListUserRoles',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/userroles`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the list of data lake roles for a single user.
 *
 * @param request ListUserRolesRequest
 * @return ListUserRolesResponse
 */
async function listUserRoles(request: ListUserRolesRequest): ListUserRolesResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return listUserRolesWithOptions(request, headers, runtime);
}

model RefreshLockRequest {
  lockId?: long(name='LockId', description='The lock ID.', example='12324'),
}

model RefreshLockResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The returned message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='81B90E1B-7514-5817-9D59-0EA9E2215876'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false.', example='True'),
}

model RefreshLockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RefreshLockResponseBody(name='body'),
}

/**
 * @summary Refreshes the specified metadata lock.
 *
 * @param request RefreshLockRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshLockResponse
 */
@context("refreshLockWithContext")
async function refreshLockWithOptions(request: RefreshLockRequest, headers: map[string]string, runtime: $RuntimeOptions): RefreshLockResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.lockId)) {
    query['LockId'] = request.lockId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'RefreshLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Refreshes the specified metadata lock.
 *
 * @param request RefreshLockRequest
 * @return RefreshLockResponse
 */
async function refreshLock(request: RefreshLockRequest): RefreshLockResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return refreshLockWithOptions(request, headers, runtime);
}

model RegisterLocationRequest {
  inventoryCollectEnabled?: boolean(name='InventoryCollectEnabled', description='Whether to enable OSS bucket inventory', example='true'),
  location?: string(name='Location', description='Registered OSS path

This parameter is required.', example='oss://mybucket/'),
  ossLogCollectEnabled?: boolean(name='OssLogCollectEnabled', description='Whether to enable OSS log storage', example='true'),
  roleName?: string(name='RoleName', description='RAM role name

>  Data Lake Formation read and write data in the OSS path. If you want to AliyunDLFWorkFlowDefaultRole a role, the role is automatically built in to the role. Alternatively, you can create a custom role, but you must manually ensure that the role has the read and write permissions on the corresponding path.

This parameter is required.', example='AliyunDLFWorkFlowDefaultRole'),
}

model RegisterLocationResponseBody = {
  data?: {
    locationId?: string(name='LocationId', description='Location ID', example='LOC-AB8FBC17F95A4AF5'),
    storageCollectTaskOperationResultList?: [
      StorageCollectTaskOperationResult
    ](name='StorageCollectTaskOperationResultList', description='The list of collection tasks that are enabled.'),
  }(name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='3C2678BA-3451-14C3-90E2-D4EF5B4E7A84'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true.
*   false: The request failed.', example='true'),
}

model RegisterLocationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RegisterLocationResponseBody(name='body'),
}

/**
 * @summary Register the OSS path to be managed by DLF.
 *
 * @param request RegisterLocationRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RegisterLocationResponse
 */
@context("registerLocationWithContext")
async function registerLocationWithOptions(request: RegisterLocationRequest, headers: map[string]string, runtime: $RuntimeOptions): RegisterLocationResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.inventoryCollectEnabled)) {
    body['InventoryCollectEnabled'] = request.inventoryCollectEnabled;
  }
  if (!$isNull(request.location)) {
    body['Location'] = request.location;
  }
  if (!$isNull(request.ossLogCollectEnabled)) {
    body['OssLogCollectEnabled'] = request.ossLogCollectEnabled;
  }
  if (!$isNull(request.roleName)) {
    body['RoleName'] = request.roleName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'RegisterLocation',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/locations`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Register the OSS path to be managed by DLF.
 *
 * @param request RegisterLocationRequest
 * @return RegisterLocationResponse
 */
async function registerLocation(request: RegisterLocationRequest): RegisterLocationResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return registerLocationWithOptions(request, headers, runtime);
}

model RenamePartitionRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  partitionInput?: PartitionInput(name='PartitionInput', description='The renamed partition information, which is the same as the partition information you specify for the CreatePartition operation.'),
  partitionValues?: [ string ](name='PartitionValues', description='The values of the partition key columns.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389'),
}

model RenamePartitionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model RenamePartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenamePartitionResponseBody(name='body'),
}

/**
 * @summary Update the partition name of the data table in the data lake.
 *
 * @param request RenamePartitionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RenamePartitionResponse
 */
@context("renamePartitionWithContext")
async function renamePartitionWithOptions(request: RenamePartitionRequest, headers: map[string]string, runtime: $RuntimeOptions): RenamePartitionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.partitionInput)) {
    body['PartitionInput'] = request.partitionInput;
  }
  if (!$isNull(request.partitionValues)) {
    body['PartitionValues'] = request.partitionValues;
  }
  if (!$isNull(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'RenamePartition',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/rename`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update the partition name of the data table in the data lake.
 *
 * @param request RenamePartitionRequest
 * @return RenamePartitionResponse
 */
async function renamePartition(request: RenamePartitionRequest): RenamePartitionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return renamePartitionWithOptions(request, headers, runtime);
}

model RenameTableRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  isAsync?: boolean(name='IsAsync', description='Specifies whether to asynchronously rename the data table. Valid values:

*   false (default): The operation is synchronously called. The update result is returned after the background task is complete. If the execution of the background task requires an extended period of time, a timeout occurs.
*   true: The operation is asynchronously called. The update result is immediately returned. You can query the task status by TaskId in the returned result.', example='false'),
  tableInput?: TableInput(name='TableInput', description='The data table object. You need only to specify the TableName parameter in this object.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model RenameTableResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request is successful.
*   false', example='true'),
  taskId?: string(name='TaskId', description='The ID of the asynchronous task.', example='c38206c3aca0c41332ffe49294243009'),
}

model RenameTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenameTableResponseBody(name='body'),
}

/**
 * @summary is used only to update the name of a data table in the data lake.
 *
 * @param request RenameTableRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RenameTableResponse
 */
@context("renameTableWithContext")
async function renameTableWithOptions(request: RenameTableRequest, headers: map[string]string, runtime: $RuntimeOptions): RenameTableResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.isAsync)) {
    body['IsAsync'] = request.isAsync;
  }
  if (!$isNull(request.tableInput)) {
    body['TableInput'] = request.tableInput;
  }
  if (!$isNull(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'RenameTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/rename`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary is used only to update the name of a data table in the data lake.
 *
 * @param request RenameTableRequest
 * @return RenameTableResponse
 */
async function renameTable(request: RenameTableRequest): RenameTableResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return renameTableWithOptions(request, headers, runtime);
}

model RevokePermissionsRequest {
  accesses?: [ string ](name='Accesses', description='The access permissions that need to be revoked.

This parameter is required.'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  delegateAccesses?: [ string ](name='DelegateAccesses', description='The grantable access permissions that need to be revoked. This parameter is unavailable.'),
  metaResource?: MetaResource(name='MetaResource', description='The metadata resource for which permissions need to be revoked.

This parameter is required.'),
  principal?: Principal(name='Principal', description='The user or role whose permissions need to be revoked. Formats:

*   RAM user: acs:ram::[accountId]:user/[userName]
*   RAM role: acs:ram::[accountId]:role/[roleName]
*   Data lake role: acs:dlf::[accountId]:role/[roleName]

This parameter is required.'),
  type?: string(name='Type', description='The permission revocation type. Only Hive is supported.

This parameter is required.', example='Hive'),
}

model RevokePermissionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The returned message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7CB5765C-F209-5B10-8792-D2BE9156ABE8'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model RevokePermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokePermissionsResponseBody(name='body'),
}

/**
 * @summary Cancels the operation permissions on resources granted to a User /Data Lake role.
 *
 * @param request RevokePermissionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokePermissionsResponse
 */
@context("revokePermissionsWithContext")
async function revokePermissionsWithOptions(request: RevokePermissionsRequest, headers: map[string]string, runtime: $RuntimeOptions): RevokePermissionsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.accesses)) {
    body['Accesses'] = request.accesses;
  }
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.delegateAccesses)) {
    body['DelegateAccesses'] = request.delegateAccesses;
  }
  if (!$isNull(request.metaResource)) {
    body['MetaResource'] = request.metaResource;
  }
  if (!$isNull(request.principal)) {
    body['Principal'] = request.principal;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'RevokePermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/revoke`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Cancels the operation permissions on resources granted to a User /Data Lake role.
 *
 * @param request RevokePermissionsRequest
 * @return RevokePermissionsResponse
 */
async function revokePermissions(request: RevokePermissionsRequest): RevokePermissionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return revokePermissionsWithOptions(request, headers, runtime);
}

model RevokeRoleFromUsersRequest {
  roleName?: string(name='RoleName', description='The role that you want to revoke from users.', example='test_role_3'),
  users?: [
  Principal
](name='Users', description='The RAM users or roles from which you want to revoke the role. Format:

*   RAM user: acs:ram::[accountId]:user/[userName].
*   RAM role: acs:ram::[accountId]:role/[roleName].'),
}

model RevokeRoleFromUsersResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model RevokeRoleFromUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokeRoleFromUsersResponseBody(name='body'),
}

/**
 * @summary Removes multiple users from a single data lake role.
 *
 * @param request RevokeRoleFromUsersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokeRoleFromUsersResponse
 */
@context("revokeRoleFromUsersWithContext")
async function revokeRoleFromUsersWithOptions(request: RevokeRoleFromUsersRequest, headers: map[string]string, runtime: $RuntimeOptions): RevokeRoleFromUsersResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.roleName)) {
    body['RoleName'] = request.roleName;
  }
  if (!$isNull(request.users)) {
    body['Users'] = request.users;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'RevokeRoleFromUsers',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/revokeusers`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Removes multiple users from a single data lake role.
 *
 * @param request RevokeRoleFromUsersRequest
 * @return RevokeRoleFromUsersResponse
 */
async function revokeRoleFromUsers(request: RevokeRoleFromUsersRequest): RevokeRoleFromUsersResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return revokeRoleFromUsersWithOptions(request, headers, runtime);
}

model RevokeRolesFromUserRequest {
  roleNames?: [ string ](name='RoleNames', description='The RAM roles to be revoked from the RAM user.

This parameter is required.'),
  user?: Principal(name='User', description='The RAM user from whom you want to revoke roles. Format:

*   RAM roles: acs:ram::[accountId]:role/[roleName].
*   RAM user: acs:ram::[accountId]:user/[userName].

This parameter is required.'),
}

model RevokeRolesFromUserResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model RevokeRolesFromUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokeRolesFromUserResponseBody(name='body'),
}

/**
 * @summary Removes multiple roles from a single user.
 *
 * @param request RevokeRolesFromUserRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokeRolesFromUserResponse
 */
@context("revokeRolesFromUserWithContext")
async function revokeRolesFromUserWithOptions(request: RevokeRolesFromUserRequest, headers: map[string]string, runtime: $RuntimeOptions): RevokeRolesFromUserResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.roleNames)) {
    body['RoleNames'] = request.roleNames;
  }
  if (!$isNull(request.user)) {
    body['User'] = request.user;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'RevokeRolesFromUser',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles/revokeroles`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Removes multiple roles from a single user.
 *
 * @param request RevokeRolesFromUserRequest
 * @return RevokeRolesFromUserResponse
 */
async function revokeRolesFromUser(request: RevokeRolesFromUserRequest): RevokeRolesFromUserResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return revokeRolesFromUserWithOptions(request, headers, runtime);
}

model RunMigrationWorkflowRequest {
  instanceId?: string(name='InstanceId', description='The ID of the migration instance.

This parameter is required.', example='M-EDD8BF959BB97345'),
}

model RunMigrationWorkflowResponseBody = {
  data?: string(name='Data', description='The returned data. The value is the ID of the workflow instance.', example='FI-7193B85809CAD95C'),
  requestId?: string(name='RequestId', description='The request ID.', example='A048EA8E-3519-5B18-B81E-EE3E0B6DBE0C'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model RunMigrationWorkflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RunMigrationWorkflowResponseBody(name='body'),
}

/**
 * @summary Runs a metadata migration task.
 *
 * @param request RunMigrationWorkflowRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RunMigrationWorkflowResponse
 */
@context("runMigrationWorkflowWithContext")
async function runMigrationWorkflowWithOptions(request: RunMigrationWorkflowRequest, headers: map[string]string, runtime: $RuntimeOptions): RunMigrationWorkflowResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'RunMigrationWorkflow',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/migration/workflow/run`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Runs a metadata migration task.
 *
 * @param request RunMigrationWorkflowRequest
 * @return RunMigrationWorkflowResponse
 */
async function runMigrationWorkflow(request: RunMigrationWorkflowRequest): RunMigrationWorkflowResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return runMigrationWorkflowWithOptions(request, headers, runtime);
}

model SearchRequest {
  catalogId?: string(name='CatalogId', description='catalogid', example='1344371'),
  pageNumber?: long(name='PageNumber', description='The page number.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='1000'),
  searchText?: string(name='SearchText', description='The search text.', example='tags:tag1 or comment:^iso and name=aliyun and (createTime > "20211111" and createTime < "20211117") and has category'),
  searchType?: string(name='SearchType', description='The search type.', example='TABLE/DATABASE/CATALOG'),
  sortCriteria?: [
    SortCriterion
  ](name='SortCriteria', description='The sorting rules.'),
}

model SearchResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  databaseResult?: {
    databases?: [ 
      {
        database?: Database(name='Database', description='The returned database.'),
        highLightList?: [
          HighLight
        ](name='HighLightList', description='The returned highlighted text.'),
      }
    ](name='Databases', description='The returned databases.'),
    totalCount?: long(name='TotalCount', description='Total number of databases that meet the match conditions', example='11000'),
  }(name='DatabaseResult', description='The returned database information.'),
  message?: string(name='Message', description='Response', example='""'),
  requestId?: string(name='RequestId', description='The request ID.', example='460C862F-BB91-5C04-BC3F-946EEF467862'),
  success?: boolean(name='Success', description='Indicates whether the information about the service was queried.', example='True'),
  tableResult?: {
    tables?: [ 
      {
        highLightList?: [
          HighLight
        ](name='HighLightList', description='The returned highlighted text.'),
        table?: Table(name='Table', description='The returned table.'),
      }
    ](name='Tables', description='The returned tables.'),
    totalCount?: long(name='TotalCount', description='The total number of tables that meet the match conditions.', example='1100'),
  }(name='TableResult', description='The returned table information.'),
}

model SearchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchResponseBody(name='body'),
}

/**
 * @summary Metadata retrieval.
 *
 * @description Metadata search
 *
 * @param request SearchRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchResponse
 */
@context("searchWithContext")
async function searchWithOptions(request: SearchRequest, headers: map[string]string, runtime: $RuntimeOptions): SearchResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.searchText)) {
    body['SearchText'] = request.searchText;
  }
  if (!$isNull(request.searchType)) {
    body['SearchType'] = request.searchType;
  }
  if (!$isNull(request.sortCriteria)) {
    body['SortCriteria'] = request.sortCriteria;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'Search',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Metadata retrieval.
 *
 * @description Metadata search
 *
 * @param request SearchRequest
 * @return SearchResponse
 */
async function search(request: SearchRequest): SearchResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return searchWithOptions(request, headers, runtime);
}

model SearchAcrossCatalogRequest {
  catalogIds?: [ string ](name='CatalogIds', description='The catalog IDs. If this parameter is empty, all catalogs are queried.'),
  pageNumber?: long(name='PageNumber', description='The page number of the queried page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries on the queried page.', example='1000'),
  searchText?: string(name='SearchText', description='The search text.', example='tags:tag1 or comment:^iso and name=aliyun and (createTime > "20211111" and createTime < "20211117") and has category'),
  searchTypes?: [ string ](name='SearchTypes', description='The search types. Valid values: ALL, CATALOG, DATABASE, and TABLE.'),
  sortCriteria?: [
    SortCriterion
  ](name='SortCriteria', description='The sorting rules.'),
}

model SearchAcrossCatalogResponseBody = {
  catalogResult?: {
    catalogs?: [ 
      {
        catalog?: Catalog(name='Catalog', description='The returned catalog.'),
        highLightList?: [
          HighLight
        ](name='HighLightList', description='The returned highlighted text.'),
      }
    ](name='Catalogs', description='The returned catalogs.'),
    totalCount?: long(name='TotalCount', description='Total number of catalogs that meet the match conditions', example='100'),
  }(name='CatalogResult', description='The returned catalog information.'),
  code?: string(name='Code', description='The response code.', example='OK'),
  databaseResult?: {
    databases?: [ 
      {
        database?: Database(name='Database', description='The returned database.'),
        highLightList?: [
          HighLight
        ](name='HighLightList', description='The returned highlighted text.'),
      }
    ](name='Databases', description='The returned databases.'),
    totalCount?: long(name='TotalCount', description='Total number of databases that meet the match conditions', example='11000'),
  }(name='DatabaseResult', description='The returned database information.'),
  message?: string(name='Message', description='Response', example='""'),
  requestId?: string(name='RequestId', description='The request ID.', example='460C862F-BB91-5C04-BC3F-946EEF467862'),
  success?: boolean(name='Success', description='Indicates whether the information about the service was queried.', example='True'),
  tableResult?: {
    tables?: [ 
      {
        highLightList?: [
          HighLight
        ](name='HighLightList', description='The returned highlighted text.'),
        table?: Table(name='Table', description='The returned table.'),
      }
    ](name='Tables', description='The returned tables.'),
    totalCount?: long(name='TotalCount', description='The total number of tables that meet the match conditions.', example='1100'),
  }(name='TableResult', description='The returned table information.'),
}

model SearchAcrossCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchAcrossCatalogResponseBody(name='body'),
}

/**
 * @summary Search across catalogs for content such as libraries, tables, and fields.
 *
 * @param request SearchAcrossCatalogRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchAcrossCatalogResponse
 */
@context("searchAcrossCatalogWithContext")
async function searchAcrossCatalogWithOptions(request: SearchAcrossCatalogRequest, headers: map[string]string, runtime: $RuntimeOptions): SearchAcrossCatalogResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogIds)) {
    body['CatalogIds'] = request.catalogIds;
  }
  if (!$isNull(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.searchText)) {
    body['SearchText'] = request.searchText;
  }
  if (!$isNull(request.searchTypes)) {
    body['SearchTypes'] = request.searchTypes;
  }
  if (!$isNull(request.sortCriteria)) {
    body['SortCriteria'] = request.sortCriteria;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'SearchAcrossCatalog',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/search/search-across-catalog`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Search across catalogs for content such as libraries, tables, and fields.
 *
 * @param request SearchAcrossCatalogRequest
 * @return SearchAcrossCatalogResponse
 */
async function searchAcrossCatalog(request: SearchAcrossCatalogRequest): SearchAcrossCatalogResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return searchAcrossCatalogWithOptions(request, headers, runtime);
}

model StopMigrationWorkflowRequest {
  instanceId?: string(name='InstanceId', description='The ID of the migration task instance.

This parameter is required.', example='M-6DCF5D8EF92E2195'),
}

model StopMigrationWorkflowResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the test feature is enabled.', example='true'),
}

model StopMigrationWorkflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopMigrationWorkflowResponseBody(name='body'),
}

/**
 * @summary Stop the metadata migration task.
 *
 * @param request StopMigrationWorkflowRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopMigrationWorkflowResponse
 */
@context("stopMigrationWorkflowWithContext")
async function stopMigrationWorkflowWithOptions(request: StopMigrationWorkflowRequest, headers: map[string]string, runtime: $RuntimeOptions): StopMigrationWorkflowResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'StopMigrationWorkflow',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/migration/workflow/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Stop the metadata migration task.
 *
 * @param request StopMigrationWorkflowRequest
 * @return StopMigrationWorkflowResponse
 */
async function stopMigrationWorkflow(request: StopMigrationWorkflowRequest): StopMigrationWorkflowResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return stopMigrationWorkflowWithOptions(request, headers, runtime);
}

model SubmitQueryRequest {
  catalogId?: string(name='catalogId', description='The ID of the data directory.', example='catalog1'),
  sql?: string(name='sql', description='The SQL statement.', example='show databases'),
  workspaceId?: string(name='workspaceId', description='The workspace ID.', example='WS-A129E61C4892D2B4'),
}

model SubmitQueryResponseBody = {
  data?: string(name='Data', description='The data returned', example='Q-14475CF9B51FCE5E'),
  requestId?: string(name='RequestId', description='The request ID.', example='279AA630-A8ED-5EA9-80A3-2E213D63548C'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model SubmitQueryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SubmitQueryResponseBody(name='body'),
}

/**
 * @summary Submit an SQL query task.
 *
 * @description *   Only suitable for submitting small and medium-sized queries. The execution time cannot exceed 1 hour.
 * *   A maximum of 10000 query results can be returned.
 * *   There are limits on concurrent execution under a single master account. If multiple queries are submitted at the same time, they will be queued.
 *
 * @param request SubmitQueryRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitQueryResponse
 */
@context("submitQueryWithContext")
async function submitQueryWithOptions(request: SubmitQueryRequest, headers: map[string]string, runtime: $RuntimeOptions): SubmitQueryResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['catalogId'] = request.catalogId;
  }
  if (!$isNull(request.sql)) {
    body['sql'] = request.sql;
  }
  if (!$isNull(request.workspaceId)) {
    body['workspaceId'] = request.workspaceId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'SubmitQuery',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/query/submitQueryRequestBody`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Submit an SQL query task.
 *
 * @description *   Only suitable for submitting small and medium-sized queries. The execution time cannot exceed 1 hour.
 * *   A maximum of 10000 query results can be returned.
 * *   There are limits on concurrent execution under a single master account. If multiple queries are submitted at the same time, they will be queued.
 *
 * @param request SubmitQueryRequest
 * @return SubmitQueryResponse
 */
async function submitQuery(request: SubmitQueryRequest): SubmitQueryResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return submitQueryWithOptions(request, headers, runtime);
}

model UnLockRequest {
  lockId?: long(name='LockId', description='The lock ID.', example='11709'),
}

model UnLockResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='37C8470A-5E6D-5E4E-AEF0-EA3EBE9C89EE'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model UnLockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnLockResponseBody(name='body'),
}

/**
 * @summary Unlocks the specified metadata lock.
 *
 * @param request UnLockRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnLockResponse
 */
@context("unLockWithContext")
async function unLockWithOptions(request: UnLockRequest, headers: map[string]string, runtime: $RuntimeOptions): UnLockResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.lockId)) {
    query['LockId'] = request.lockId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UnLock',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/locks`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Unlocks the specified metadata lock.
 *
 * @param request UnLockRequest
 * @return UnLockResponse
 */
async function unLock(request: UnLockRequest): UnLockResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return unLockWithOptions(request, headers, runtime);
}

model UpdateCatalogRequest {
  catalogInput?: CatalogInput(name='CatalogInput', description='The structure that is used to create or update the catalog.

This parameter is required.'),
}

model UpdateCatalogResponseBody = {
  code?: string(name='Code', description='Response encoding.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='64E46067-49EA-5A91-A7B1-E812E18FC243'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request is successful.
*   false: The request failed.', example='true'),
}

model UpdateCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCatalogResponseBody(name='body'),
}

/**
 * @summary Updates the contents of the Data Catalog.
 *
 * @param request UpdateCatalogRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCatalogResponse
 */
@context("updateCatalogWithContext")
async function updateCatalogWithOptions(request: UpdateCatalogRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateCatalogResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogInput)) {
    body['CatalogInput'] = request.catalogInput;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateCatalog',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the contents of the Data Catalog.
 *
 * @param request UpdateCatalogRequest
 * @return UpdateCatalogResponse
 */
async function updateCatalog(request: UpdateCatalogRequest): UpdateCatalogResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCatalogWithOptions(request, headers, runtime);
}

model UpdateCatalogSettingsRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  catalogSettings?: CatalogSettings(name='CatalogSettings', description='The catalog configuration.'),
}

model UpdateCatalogSettingsResponseBody = {
  code?: string(name='Code', description='The HTTP status code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='01D8DD6B-4929-5999-9BB3-950AA30E3BD0'),
  success?: boolean(name='Success', description='Whether the operation is successful. Valid values:

*   true: The request was successful.
*   false: The operation failed.', example='true'),
}

model UpdateCatalogSettingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCatalogSettingsResponseBody(name='body'),
}

/**
 * @summary To update the configurations of Data Lake Catalog, you must assume the admin role or more.
 *
 * @param request UpdateCatalogSettingsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCatalogSettingsResponse
 */
@context("updateCatalogSettingsWithContext")
async function updateCatalogSettingsWithOptions(request: UpdateCatalogSettingsRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateCatalogSettingsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.catalogSettings)) {
    body['CatalogSettings'] = request.catalogSettings;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateCatalogSettings',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/settings`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary To update the configurations of Data Lake Catalog, you must assume the admin role or more.
 *
 * @param request UpdateCatalogSettingsRequest
 * @return UpdateCatalogSettingsResponse
 */
async function updateCatalogSettings(request: UpdateCatalogSettingsRequest): UpdateCatalogSettingsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCatalogSettingsWithOptions(request, headers, runtime);
}

model UpdateDatabaseRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseInput?: DatabaseInput(name='DatabaseInput', description='The information about the updated database.'),
  name?: string(name='Name', description='The name of the database before the update. If the database name remains the same after the update, only other information in the DatabaseInput parameter is updated.', example='database_test'),
}

model UpdateDatabaseResponseBody = {
  code?: string(name='Code', description='The description of the distribution status.', example='OK'),
  message?: string(name='Message', description='A related error message is displayed.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='161F5EFC-E97E-43C0-AACF-FF18FAC912F0'),
  success?: boolean(name='Success', description='Indicates whether the operation was successful. Valid values:

*   true: The request is successful.
*   false: The request failed.', example='true'),
}

model UpdateDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDatabaseResponseBody(name='body'),
}

/**
 * @summary Update the details of a database in the data lake.
 *
 * @param request UpdateDatabaseRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDatabaseResponse
 */
@context("updateDatabaseWithContext")
async function updateDatabaseWithOptions(request: UpdateDatabaseRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateDatabaseResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseInput)) {
    body['DatabaseInput'] = request.databaseInput;
  }
  if (!$isNull(request.name)) {
    body['Name'] = request.name;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateDatabase',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update the details of a database in the data lake.
 *
 * @param request UpdateDatabaseRequest
 * @return UpdateDatabaseResponse
 */
async function updateDatabase(request: UpdateDatabaseRequest): UpdateDatabaseResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDatabaseWithOptions(request, headers, runtime);
}

model UpdateFunctionRequest {
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  functionInput?: FunctionInput(name='FunctionInput', description='The details about the function to be updated.'),
  functionName?: string(name='FunctionName', description='The function name.', example='func2'),
}

model UpdateFunctionResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model UpdateFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFunctionResponseBody(name='body'),
}

/**
 * @summary Updates the user-defined function information for a database in the data lake by name.
 *
 * @param request UpdateFunctionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFunctionResponse
 */
@context("updateFunctionWithContext")
async function updateFunctionWithOptions(request: UpdateFunctionRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateFunctionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.functionInput)) {
    body['FunctionInput'] = request.functionInput;
  }
  if (!$isNull(request.functionName)) {
    body['FunctionName'] = request.functionName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateFunction',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/functions`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the user-defined function information for a database in the data lake by name.
 *
 * @param request UpdateFunctionRequest
 * @return UpdateFunctionResponse
 */
async function updateFunction(request: UpdateFunctionRequest): UpdateFunctionResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFunctionWithOptions(request, headers, runtime);
}

model UpdatePartitionColumnStatisticsRequest {
  updateTablePartitionColumnStatisticsRequest?: UpdateTablePartitionColumnStatisticsRequest(name='UpdateTablePartitionColumnStatisticsRequest', description='The request to update partition column statistics in the data table.'),
}

model UpdatePartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model UpdatePartitionColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePartitionColumnStatisticsResponseBody(name='body'),
}

/**
 * @summary Creates or updates the field statistics of a data table partition.
 *
 * @param request UpdatePartitionColumnStatisticsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePartitionColumnStatisticsResponse
 */
@context("updatePartitionColumnStatisticsWithContext")
async function updatePartitionColumnStatisticsWithOptions(request: UpdatePartitionColumnStatisticsRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdatePartitionColumnStatisticsResponse {
  request.validate();
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.updateTablePartitionColumnStatisticsRequest),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdatePartitionColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/partitions/columnstatistics`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates or updates the field statistics of a data table partition.
 *
 * @param request UpdatePartitionColumnStatisticsRequest
 * @return UpdatePartitionColumnStatisticsResponse
 */
async function updatePartitionColumnStatistics(request: UpdatePartitionColumnStatisticsRequest): UpdatePartitionColumnStatisticsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePartitionColumnStatisticsWithOptions(request, headers, runtime);
}

model UpdatePermissionsRequest {
  accesses?: [ string ](name='Accesses', description='The list of access permissions to be authorized.

This parameter is required.'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  delegateAccesses?: [ string ](name='DelegateAccesses', description='The list of access permissions that can be delegated. This parameter is unavailable.

This parameter is required.'),
  metaResource?: MetaResource(name='MetaResource', description='The metadata resource to be authorized.

This parameter is required.'),
  principal?: Principal(name='Principal', description='The authorized users or roles. Formats:

*   RAM user: acs:ram::[accountId]:user/[userName]
*   RAM role: acs:ram::[accountId]:role/[roleName]
*   Data lake role: acs:dlf::[accountId]:role/[roleName]

This parameter is required.'),
  type?: string(name='Type', description='The type of the authorization. Only Hive is supported.

This parameter is required.', example='Hive'),
}

model UpdatePermissionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model UpdatePermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePermissionsResponseBody(name='body'),
}

/**
 * @summary Update the permissions of the User /Data Lake role.
 *
 * @param request UpdatePermissionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePermissionsResponse
 */
@context("updatePermissionsWithContext")
async function updatePermissionsWithOptions(request: UpdatePermissionsRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdatePermissionsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.accesses)) {
    body['Accesses'] = request.accesses;
  }
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.delegateAccesses)) {
    body['DelegateAccesses'] = request.delegateAccesses;
  }
  if (!$isNull(request.metaResource)) {
    body['MetaResource'] = request.metaResource;
  }
  if (!$isNull(request.principal)) {
    body['Principal'] = request.principal;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdatePermissions',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/permissions/`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update the permissions of the User /Data Lake role.
 *
 * @param request UpdatePermissionsRequest
 * @return UpdatePermissionsResponse
 */
async function updatePermissions(request: UpdatePermissionsRequest): UpdatePermissionsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePermissionsWithOptions(request, headers, runtime);
}

model UpdateRegisteredLocationRequest {
  inventoryCollectEnabled?: boolean(name='InventoryCollectEnabled', description='Whether to enable OSS bucket inventory', example='true'),
  locationId?: string(name='LocationId', description='Location ID

>  You can call the RegisterLocation operation to obtain the Location ID.

This parameter is required.', example='LOC-AB8FBC17F95A4AF5'),
  ossLogCollectEnabled?: boolean(name='OssLogCollectEnabled', description='Whether to enable OSS log storage', example='true'),
}

model UpdateRegisteredLocationResponseBody = {
  data?: {
    locationId?: string(name='LocationId', description='Location ID', example='LOC-AB8FBC17F95A4AF5'),
    storageCollectTaskOperationResultList?: [
      StorageCollectTaskOperationResult
    ](name='StorageCollectTaskOperationResultList', description='The list of collection tasks that are updated.'),
  }(name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='8030C902-C25B-1839-867D-E6F70A5B9810'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true.
*   false: The request failed.', example='true'),
}

model UpdateRegisteredLocationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRegisteredLocationResponseBody(name='body'),
}

/**
 * @summary Edit a Registered Location.
 *
 * @param request UpdateRegisteredLocationRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRegisteredLocationResponse
 */
@context("updateRegisteredLocationWithContext")
async function updateRegisteredLocationWithOptions(request: UpdateRegisteredLocationRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateRegisteredLocationResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.inventoryCollectEnabled)) {
    body['InventoryCollectEnabled'] = request.inventoryCollectEnabled;
  }
  if (!$isNull(request.locationId)) {
    body['LocationId'] = request.locationId;
  }
  if (!$isNull(request.ossLogCollectEnabled)) {
    body['OssLogCollectEnabled'] = request.ossLogCollectEnabled;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateRegisteredLocation',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/webapi/locations`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Edit a Registered Location.
 *
 * @param request UpdateRegisteredLocationRequest
 * @return UpdateRegisteredLocationResponse
 */
async function updateRegisteredLocation(request: UpdateRegisteredLocationRequest): UpdateRegisteredLocationResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRegisteredLocationWithOptions(request, headers, runtime);
}

model UpdateRoleRequest {
  roleInput?: RoleInput(name='RoleInput', description='The input information of the updated role.'),
  roleName?: string(name='RoleName', description='The role name.', example='原始名称'),
}

model UpdateRoleResponseBody = {
  code?: string(name='Code', description='The status of the request.', example='OK'),
  message?: string(name='Message', description='The returned message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='604E5919-C6FF-54CE-9C23-C5350E6F5415'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false', example='true'),
}

model UpdateRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRoleResponseBody(name='body'),
}

/**
 * @summary Updates a role that has the data lake permissions.
 *
 * @param request UpdateRoleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRoleResponse
 */
@context("updateRoleWithContext")
async function updateRoleWithOptions(request: UpdateRoleRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateRoleResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.roleInput)) {
    body['RoleInput'] = request.roleInput;
  }
  if (!$isNull(request.roleName)) {
    body['RoleName'] = request.roleName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateRole',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/roles`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a role that has the data lake permissions.
 *
 * @param request UpdateRoleRequest
 * @return UpdateRoleResponse
 */
async function updateRole(request: UpdateRoleRequest): UpdateRoleResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRoleWithOptions(request, headers, runtime);
}

model UpdateRoleUsersRequest {
  roleName?: string(name='RoleName', description='The name of the role.', example='test_role_8'),
  users?: [
  Principal
](name='Users', description='The list of users or roles. Format:

RAM user: acs:ram::[accountId]:user/[userName]

RAM role: acs:ram::[accountId]:role/[roleName]'),
}

model UpdateRoleUsersResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model UpdateRoleUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRoleUsersResponseBody(name='body'),
}

/**
 * @summary Update the user in the role to include ram user/ram role.
 *
 * @param request UpdateRoleUsersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRoleUsersResponse
 */
@context("updateRoleUsersWithContext")
async function updateRoleUsersWithOptions(request: UpdateRoleUsersRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateRoleUsersResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.roleName)) {
    body['RoleName'] = request.roleName;
  }
  if (!$isNull(request.users)) {
    body['Users'] = request.users;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateRoleUsers',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/auth/updateroleusers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update the user in the role to include ram user/ram role.
 *
 * @param request UpdateRoleUsersRequest
 * @return UpdateRoleUsersResponse
 */
async function updateRoleUsers(request: UpdateRoleUsersRequest): UpdateRoleUsersResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRoleUsersWithOptions(request, headers, runtime);
}

model UpdateTableRequest {
  allowPartitionKeyChange?: boolean(name='AllowPartitionKeyChange', description='Specifies whether the partition key can be updated.', example='false'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test'),
  isAsync?: boolean(name='IsAsync', description='Specifies whether to synchronously update the data table.', example='true'),
  skipArchive?: boolean(name='SkipArchive', description='By default, if a data table is updated, a backup version of the data table is created. However, if you set the skipArchive parameter to true, no backup version is created.', example='false'),
  tableInput?: TableInput(name='TableInput', description='The details about the updated data table.'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223'),
}

model UpdateTableResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
  taskId?: string(name='TaskId', description='The ID of the asynchronous task.', example='aa689782deb97265701f57324fc4ae42'),
}

model UpdateTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateTableResponseBody(name='body'),
}

/**
 * @summary Update the data table information in the data lake based on the name.
 *
 * @param request UpdateTableRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTableResponse
 */
@context("updateTableWithContext")
async function updateTableWithOptions(request: UpdateTableRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateTableResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.allowPartitionKeyChange)) {
    body['AllowPartitionKeyChange'] = request.allowPartitionKeyChange;
  }
  if (!$isNull(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!$isNull(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!$isNull(request.isAsync)) {
    body['IsAsync'] = request.isAsync;
  }
  if (!$isNull(request.skipArchive)) {
    body['SkipArchive'] = request.skipArchive;
  }
  if (!$isNull(request.tableInput)) {
    body['TableInput'] = request.tableInput;
  }
  if (!$isNull(request.tableName)) {
    body['TableName'] = request.tableName;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateTable',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update the data table information in the data lake based on the name.
 *
 * @param request UpdateTableRequest
 * @return UpdateTableResponse
 */
async function updateTable(request: UpdateTableRequest): UpdateTableResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTableWithOptions(request, headers, runtime);
}

model UpdateTableColumnStatisticsRequest {
  updateTablePartitionColumnStatisticsRequest?: UpdateTablePartitionColumnStatisticsRequest(name='UpdateTablePartitionColumnStatisticsRequest', description='The request to update statistics.'),
}

model UpdateTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The error message that is returned.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request is successful.
*   false: The request failed.', example='true'),
}

model UpdateTableColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateTableColumnStatisticsResponseBody(name='body'),
}

/**
 * @summary Creates or updates field statistics for a data table.
 *
 * @param request UpdateTableColumnStatisticsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTableColumnStatisticsResponse
 */
@context("updateTableColumnStatisticsWithContext")
async function updateTableColumnStatisticsWithOptions(request: UpdateTableColumnStatisticsRequest, headers: map[string]string, runtime: $RuntimeOptions): UpdateTableColumnStatisticsResponse {
  request.validate();
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.updateTablePartitionColumnStatisticsRequest),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateTableColumnStatistics',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = `/api/metastore/catalogs/databases/tables/columnstatistics`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates or updates field statistics for a data table.
 *
 * @param request UpdateTableColumnStatisticsRequest
 * @return UpdateTableColumnStatisticsResponse
 */
async function updateTableColumnStatistics(request: UpdateTableColumnStatisticsRequest): UpdateTableColumnStatisticsResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTableColumnStatisticsWithOptions(request, headers, runtime);
}

