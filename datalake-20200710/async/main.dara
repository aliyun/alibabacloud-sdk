/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'DataLake';
  @version = '2020-07-10';
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'datalake-daily.aliyuncs.com',
    ap-northeast-2-pop = 'datalake-daily.aliyuncs.com',
    ap-south-1 = 'datalake-daily.aliyuncs.com',
    ap-southeast-1 = 'datalake-daily.aliyuncs.com',
    ap-southeast-2 = 'datalake-daily.aliyuncs.com',
    ap-southeast-3 = 'datalake-daily.aliyuncs.com',
    ap-southeast-5 = 'datalake-daily.aliyuncs.com',
    cn-beijing = 'dlf.cn-beijing.aliyuncs.com',
    cn-beijing-finance-1 = 'datalake-daily.aliyuncs.com',
    cn-beijing-finance-pop = 'datalake-daily.aliyuncs.com',
    cn-beijing-gov-1 = 'datalake-daily.aliyuncs.com',
    cn-beijing-nu16-b01 = 'datalake-daily.aliyuncs.com',
    cn-chengdu = 'datalake-daily.aliyuncs.com',
    cn-edge-1 = 'datalake-daily.aliyuncs.com',
    cn-fujian = 'datalake-daily.aliyuncs.com',
    cn-haidian-cm12-c01 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou = 'dlf.cn-hangzhou.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-finance = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'datalake-daily.aliyuncs.com',
    cn-hangzhou-test-306 = 'datalake-daily.aliyuncs.com',
    cn-hongkong = 'datalake-daily.aliyuncs.com',
    cn-hongkong-finance-pop = 'datalake-daily.aliyuncs.com',
    cn-huhehaote = 'datalake-daily.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'datalake-daily.aliyuncs.com',
    cn-north-2-gov-1 = 'datalake-daily.aliyuncs.com',
    cn-qingdao = 'datalake-daily.aliyuncs.com',
    cn-qingdao-nebula = 'datalake-daily.aliyuncs.com',
    cn-shanghai = 'dlf.cn-shanghai.aliyuncs.com',
    cn-shanghai-et15-b01 = 'datalake-daily.aliyuncs.com',
    cn-shanghai-et2-b01 = 'datalake-daily.aliyuncs.com',
    cn-shanghai-finance-1 = 'datalake-daily.aliyuncs.com',
    cn-shanghai-inner = 'datalake-daily.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'datalake-daily.aliyuncs.com',
    cn-shenzhen = 'dlf.cn-shenzhen.aliyuncs.com',
    cn-shenzhen-finance-1 = 'datalake-daily.aliyuncs.com',
    cn-shenzhen-inner = 'datalake-daily.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'datalake-daily.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'datalake-daily.aliyuncs.com',
    cn-wuhan = 'datalake-daily.aliyuncs.com',
    cn-wulanchabu = 'datalake-daily.aliyuncs.com',
    cn-yushanfang = 'datalake-daily.aliyuncs.com',
    cn-zhangbei = 'datalake-daily.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'datalake-daily.aliyuncs.com',
    cn-zhangjiakou = 'datalake-daily.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'datalake-daily.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'datalake-daily.aliyuncs.com',
    eu-central-1 = 'datalake-daily.aliyuncs.com',
    eu-west-1 = 'datalake-daily.aliyuncs.com',
    eu-west-1-oxs = 'datalake-daily.aliyuncs.com',
    me-east-1 = 'datalake-daily.aliyuncs.com',
    rus-west-1-pop = 'datalake-daily.aliyuncs.com',
    us-east-1 = 'datalake-daily.aliyuncs.com',
    us-west-1 = 'datalake-daily.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model AccessRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  principal?: Principal(name='Principal'),
  privilegeResources?: [
PrivilegeResource
](name='PrivilegeResources'),
}

model Catalog {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  createTime?: long(name='CreateTime', description='创建时间'),
  createdBy?: string(name='CreatedBy', description='CreatedBy- 创建者 - principal格式'),
  description?: string(name='Description', description='Description'),
  locationUri?: string(name='LocationUri', description='LocationUri'),
  owner?: string(name='Owner', description='Owner - 负责人 - Principal格式'),
  status?: string(name='Status', description='Catalog状态'),
  updateTime?: long(name='UpdateTime', description='更新时间'),
}

model CatalogInput {
  catalogId: string(name='CatalogId', description='CatalogId'),
  description?: string(name='Description', description='Description'),
  locationUri?: string(name='LocationUri', description='LocationUri'),
  owner?: string(name='Owner', description='Owner - 负责人 - Principal格式'),
}

model CatalogResource {
  catalogId?: string(name='CatalogId', description='Catalog id'),
}

model CatalogSettings {
  config?: map[string]string(name='Config', description='配置'),
}

model ColumnResource {
  columnNames?: [ string ](name='ColumnNames', description='ColumnName'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  tableName?: string(name='TableName', description='TableName'),
}

model ColumnStatistics {
  columnStatisticsDesc?: ColumnStatisticsDesc(name='ColumnStatisticsDesc'),
  columnStatisticsObjList?: [
    ColumnStatisticsObj
  ](name='ColumnStatisticsObjList', description='ColumnStatisticsObjList'),
  engine?: string(name='Engine', description='Engine for hive3+'),
  isStatsCompliant?: boolean(name='IsStatsCompliant', description='IsStatsCompliant for hive3+'),
}

model ColumnStatisticsDesc {
  lastAnalyzedTime?: long(name='LastAnalyzedTime', description='optional'),
  partitionName?: string(name='PartitionName', description='required'),
}

model ColumnStatisticsObj {
  columnName?: string(name='ColumnName', description='ColumnName of the table'),
  columnStatisticsData?: {
    statisticsData?: string(name='StatisticsData', description='StatisticsData'),
    statisticsType?: string(name='StatisticsType', description='StatisticsType'),
  }(name='ColumnStatisticsData', description='ColumnStatisticsData'),
  columnType?: string(name='ColumnType', description='ColumnType'),
}

model Database {
  createTime?: int32(name='CreateTime', description='createTime'),
  createdBy?: string(name='CreatedBy', description='CreatedBy'),
  description?: string(name='Description', description='description'),
  locationUri?: string(name='LocationUri', description='locationUri'),
  name?: string(name='Name', description='name'),
  ownerName?: string(name='OwnerName', description='ownerName'),
  ownerType?: string(name='OwnerType', description='ownerType'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  updateTime?: int32(name='UpdateTime', description='updateTime'),
}

model DatabaseInput {
  createTime?: int32(name='CreateTime', description='createTime'),
  description?: string(name='Description', description='Description'),
  locationUri?: string(name='LocationUri', description='locationUri'),
  name?: string(name='Name', description='name'),
  ownerName?: string(name='OwnerName', description='ownerName'),
  ownerType?: string(name='OwnerType', description='ownerType'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
}

model DatabaseProfile {
  createTime?: string(name='CreateTime', description='创建时间'),
  fileCnt?: long(name='FileCnt', description='文件数量'),
  fileSize?: long(name='FileSize', description='文件大小'),
  location?: string(name='Location', description='存储位置'),
  name?: string(name='Name', description='库名称'),
}

model DatabaseResource {
  databaseName?: string(name='DatabaseName', description='Database name'),
  databaseWildcard?: string(name='DatabaseWildcard', description='A wildcard member representing every resource under a database'),
}

model DbStorageRank {
  dbName?: string(name='DbName', description='库名'),
  quantity?: long(name='Quantity', description='存储量'),
}

model ErrorDetail {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
}

model FieldSchema {
  comment?: string(name='Comment', description='Comment'),
  name?: string(name='Name', description='Name'),
  parameters?: map[string]string(name='Parameters'),
  type?: string(name='Type', description='Type'),
}

model FileCnt {
  large?: long(name='Large', description='大文件'),
  middle?: long(name='Middle', description='中文件'),
  small?: long(name='Small', description='小文件'),
  tiny?: long(name='Tiny', description='极小文件'),
}

model Function {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  className?: string(name='ClassName', description='ClassName'),
  createTime?: int32(name='CreateTime', description='CreateTime'),
  createdBy?: string(name='CreatedBy', description='CreatedBy'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  functionName?: string(name='FunctionName', description='FunctionName'),
  functionType?: string(name='FunctionType', description='FunctionType'),
  ownerName?: string(name='OwnerName', description='OwnerName'),
  ownerType?: string(name='OwnerType', description='OwnerType'),
  resourceUri?: [
    ResourceUri
  ](name='ResourceUri', description='ResourceUri'),
  updateTime?: int32(name='UpdateTime', description='UpdateTime'),
}

model FunctionInput {
  className?: string(name='ClassName', description='ClassName'),
  createTime?: int32(name='CreateTime', description='createTime'),
  functionName?: string(name='FunctionName', description='FunctionName'),
  functionType?: string(name='FunctionType', description='FunctionType'),
  ownerName?: string(name='OwnerName', description='OwnerName'),
  ownerType?: string(name='OwnerType', description='OwnerType'),
  resourceUri?: [
    ResourceUri
  ](name='ResourceUri', description='ResourceUri'),
}

model FunctionResource {
  databaseName?: string(name='DatabaseName', description='Database name'),
  functionName?: string(name='FunctionName', description='Function name'),
}

model GrantRevokeEntry {
  accesses?: [ string ](name='Accesses', description='授权的accesses列表'),
  delegateAccesses?: [ string ](name='DelegateAccesses', description='授权的grantable accesses列表'),
  id?: string(name='Id', description='identifier for this entry'),
  metaResource?: MetaResource(name='MetaResource', description='授权的资源'),
  principal?: Principal(name='Principal', description='授权的用户principal'),
}

model GrantRevokeFailureEntry {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  grantRevokeEntry?: GrantRevokeEntry(name='GrantRevokeEntry'),
}

model HighLight {
  key?: string(name='Key', description='高亮的key'),
  value?: string(name='Value', description='高亮的value'),
}

model IndicatorStatistic {
  data?: long(name='Data', description='指标数据'),
  date?: string(name='Date', description='指标日期'),
}

model LifecycleResource {
  bizId?: string(name='BizId', description='BizId'),
  database?: {
    createTime?: long(name='CreateTime', description='CreateTime'),
    description?: string(name='Description', description='Description'),
    locationUri?: string(name='LocationUri', description='LocationUri'),
    name?: string(name='Name', description='Name'),
    updateTime?: long(name='UpdateTime', description='UpdateTime'),
  }(name='Database', description='Database'),
  databaseName?: string(name='DatabaseName', description='数据库名称'),
  databaseProfile?: DatabaseProfile(name='DatabaseProfile', description='DatabaseProfile'),
  gmtCreate?: string(name='GmtCreate', description='创建时间'),
  lifecycleRuleBizId?: string(name='LifecycleRuleBizId', description='生命周期规则id'),
  owner?: long(name='Owner', description='Owner'),
  table?: {
    createTime?: long(name='CreateTime', description='CreateTime'),
    databaseName?: string(name='DatabaseName', description='DatabaseName'),
    parameters?: map[string]string(name='Parameters', description='Parameters'),
    sd?: {
      bucketCols?: [ string ](name='BucketCols', description='BucketCols'),
      inputFormat?: string(name='InputFormat', description='InputFormat'),
      location?: string(name='Location', description='Location'),
      outputFormat?: string(name='OutputFormat', description='OutputFormat'),
      parameters?: map[string]string(name='Parameters', description='Parameters'),
      serDeInfo?: {
        name?: string(name='Name', description='Name'),
        parameters?: map[string]string(name='Parameters', description='Parameters'),
        serializationLib?: string(name='SerializationLib', description='SerializationLib'),
      }(name='SerDeInfo', description='SerDeInfo'),
    }(name='Sd', description='Sd'),
    tableName?: string(name='TableName', description='TableName'),
    tableType?: string(name='TableType', description='TableType'),
  }(name='Table', description='Table'),
  tableName?: string(name='TableName', description='表名称'),
  tableProfile?: TableProfile(name='TableProfile'),
}

model LifecycleRule {
  archiveDays?: int32(name='ArchiveDays', description='archiveDays'),
  bindCount?: int32(name='BindCount', description='bindCount'),
  bizId?: string(name='BizId', description='bizId'),
  coldArchiveDays?: int32(name='ColdArchiveDays', description='coldArchiveDays'),
  config?: string(name='Config', description='Config'),
  description?: string(name='Description', description='description'),
  gmtCreate?: string(name='GmtCreate', description='创建时间'),
  gmtModified?: string(name='GmtModified', description='修改时间'),
  iaDays?: int32(name='IaDays', description='iaDays'),
  name?: string(name='Name', description='name'),
  resourceType?: string(name='ResourceType', description='resourceType'),
  ruleType?: string(name='RuleType', description='ruleType'),
  scheduleStatus?: string(name='ScheduleStatus', description='scheduleStatus'),
  workflow?: Workflow(name='Workflow', description='工作流'),
  workflowId?: string(name='WorkflowId', description='工作流id'),
  workflowInstance?: WorkflowInstance(name='WorkflowInstance', description='工作流实例'),
}

model LifecycleTask {
  bizId?: string(name='BizId', description='业务id'),
  lifecycleRule?: LifecycleRule(name='LifecycleRule'),
  name?: string(name='Name', description='名称'),
  workflowInstance?: WorkflowInstance(name='WorkflowInstance'),
}

model LockObj {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  partitionName?: string(name='PartitionName', description='PartitionName'),
  tableName?: string(name='TableName', description='TableName'),
}

model LockStatus {
  lockId?: long(name='LockId', description='LockId'),
  lockState?: string(name='LockState', description='ACQUIRED/NOT_ACQUIRED'),
}

model LogInfo {
  bizTime?: string(name='BizTime', description='业务运行时间'),
  gmtCreate?: string(name='GmtCreate', description='创建时间'),
  instanceId?: string(name='InstanceId', description='实例ID'),
  logContent?: string(name='LogContent', description='日志内容'),
  logId?: string(name='LogId', description='日志id'),
  logSummary?: string(name='LogSummary', description='日志概要'),
  logType?: string(name='LogType', description='日志级别'),
}

model MetaResource {
  catalogResource?: CatalogResource(name='CatalogResource', description='catalog resource'),
  columnResource?: ColumnResource(name='ColumnResource', description='column resource'),
  databaseResource?: DatabaseResource(name='DatabaseResource', description='database resource'),
  functionResource?: FunctionResource(name='FunctionResource', description='function resource'),
  resourceType?: string(name='ResourceType', description='CATALOG,DATABASE, TABLE, FUNCTION, COLUMN任选其一'),
  tableResource?: TableResource(name='TableResource', description='table resource'),
}

model Order {
  col?: string(name='Col', description='Col'),
  order?: int32(name='Order', description='Order'),
}

model Partition {
  createTime?: int32(name='CreateTime', description='CreateTime'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime', description='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime', description='LastAnalyzedTime'),
  parameters?: map[string]string(name='Parameters', description='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName', description='TableName'),
  values?: [ string ](name='Values', description='Values'),
}

model PartitionError {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  partitionValues?: [ string ](name='PartitionValues'),
}

model PartitionInput {
  createTime?: int32(name='CreateTime', description='createTime'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime', description='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime', description='LastAnalyzedTime'),
  parameters?: map[string]string(name='Parameters', description='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName', description='TableName'),
  values?: [ string ](name='Values', description='Values'),
}

model PartitionProfile {
  archiveStatus?: string(name='ArchiveStatus', description='oss存储类型'),
  createTime?: string(name='CreateTime', description='创建时间'),
  databaseName?: string(name='DatabaseName', description='库名称'),
  dmlTime?: string(name='DmlTime', description='dml时间'),
  location?: string(name='Location', description='存储位置'),
  partitionName?: string(name='PartitionName', description='分区名称'),
  tableName?: string(name='TableName', description='表名称'),
}

model PartitionSpec {
  sharedSDPartitions?: [
    Partition
  ](name='SharedSDPartitions', description='SharedSDPartitions'),
  sharedStorageDescriptor?: {
    cols?: [
      FieldSchema
    ](name='Cols', description='Cols'),
    location?: string(name='Location', description='Location'),
  }(name='SharedStorageDescriptor', description='SharedStorageDescriptor'),
}

model Principal {
  principalArn?: string(name='PrincipalArn', description='身份标识'),
}

model PrincipalPrivilegeSet {
  groupPrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='GroupPrivileges'),
  rolePrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='RolePrivileges'),
  userPrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='UserPrivileges'),
}

model PrincipalResourcePermissions {
  accesses?: [ string ](name='Accesses', description='权限'),
  delegateAccesses?: [ string ](name='DelegateAccesses', description='grantable权限'),
  metaResource: MetaResource(name='MetaResource', description='权限信息所属的Hive元数据资源'),
  principal: Principal(name='Principal', description='权限信息所属的Principal'),
}

model PrivilegeGrantInfo {
  createTime?: int32(name='CreateTime', description='createTime'),
  grantOption?: boolean(name='GrantOption', description='grantOption'),
  grantor?: string(name='Grantor', description='grantor'),
  grantorType?: string(name='GrantorType', description='grantorType'),
  privilege?: string(name='Privilege', description='privilege'),
}

model PrivilegeResource {
  access?: string(name='Access', description='Access type'),
  metaResource?: MetaResource(name='MetaResource', description='resource'),
}

model ResourceUri {
  resourceType?: string(name='ResourceType', description='ResourceType'),
  uri?: string(name='Uri', description='Uri'),
}

model Role {
  createTime?: long(name='CreateTime', description='CreateTime'),
  description?: string(name='Description', description='角色描述'),
  displayName?: string(name='DisplayName', description='DisplayName'),
  isPredefined?: int32(name='IsPredefined', description='IsPredefined'),
  name?: string(name='Name', description='name'),
  principalArn?: string(name='PrincipalArn', description='PrincipalArn'),
  updateTime?: long(name='UpdateTime', description='UpdateTime'),
  users?: [
Principal
](name='Users'),
}

model RoleInput {
  description?: string(name='Description', description='角色描述'),
  displayName?: string(name='DisplayName', description='DisplayName'),
  name?: string(name='Name', description='name'),
}

model SerDeInfo {
  name?: string(name='Name', description='Name'),
  parameters?: map[string]string(name='Parameters'),
  serializationLib?: string(name='SerializationLib', description='SerializationLib'),
}

model SingleIndicatorDTO {
  dayIncrement?: long(name='DayIncrement', description='日新增'),
  dayOnDay?: double(name='DayOnDay', description='日环比'),
  monthIncrement?: long(name='MonthIncrement', description='月新增'),
  monthOnMonth?: double(name='MonthOnMonth', description='月环比'),
  total?: long(name='Total', description='总量'),
}

model SkewedInfo {
  skewedColNames?: [ string ](name='SkewedColNames', description='SkewedColNames'),
  skewedColValueLocationMaps?: map[string]string(name='SkewedColValueLocationMaps', description='SkewedColValueLocationMaps'),
  skewedColValues?: [[ string ]  ](name='SkewedColValues', description='SkewedColValueLocationMaps'),
}

model SmallFileCntRank {
  dbName?: string(name='DbName', description='库名'),
  location?: string(name='Location', description='存储位置'),
  quantity?: long(name='Quantity', description='数量'),
  tableName?: string(name='TableName', description='表名'),
}

model SortCriterion {
  fieldName?: string(name='FieldName', description='排序字段'),
  sort?: string(name='Sort', description='排序方式'),
}

model StorageDescriptor {
  bucketCols?: [ string ](name='BucketCols'),
  cols?: [
    FieldSchema
  ](name='Cols', description='Cols'),
  compressed?: boolean(name='Compressed', description='Compressed'),
  inputFormat?: string(name='InputFormat', description='InputFormat'),
  location?: string(name='Location', description='Location'),
  numBuckets?: int32(name='NumBuckets', description='NumBuckets'),
  outputFormat?: string(name='OutputFormat', description='OutputFormat'),
  parameters?: map[string]string(name='Parameters', description='Parameters'),
  serDeInfo?: SerDeInfo(name='SerDeInfo'),
  skewedInfo?: SkewedInfo(name='SkewedInfo'),
  sortCols?: [
    Order
  ](name='SortCols', description='SortCols'),
  storedAsSubDirectories?: boolean(name='StoredAsSubDirectories', description='StoredAsSubDirectories'),
}

model StorageFormat {
  avro?: long(name='Avro', description='Avro'),
  csv?: long(name='Csv', description='Csv'),
  delta?: long(name='Delta', description='Delta'),
  hudi?: long(name='Hudi', description='Hudi'),
  iceberg?: long(name='Iceberg', description='Iceberg'),
  json?: long(name='Json', description='Json'),
  orc?: long(name='Orc', description='Orc'),
  parquet?: long(name='Parquet', description='Parquet'),
  uncategorized?: long(name='Uncategorized', description='Uncategorized'),
}

model StorageLayer {
  archive?: long(name='Archive', description='归档'),
  coldArchive?: long(name='ColdArchive', description='冷归档'),
  infrequent?: long(name='Infrequent', description='低频'),
  standard?: long(name='Standard', description='标准'),
}

model StorageRankDTO {
  dbStorageRank?: [
    DbStorageRank
  ](name='dbStorageRank', description='库存储排名'),
  smallFileCntRank?: [
    SmallFileCntRank
  ](name='smallFileCntRank', description='小文件数量排名'),
  tableStorageRank?: [
    TableStorageRank
  ](name='tableStorageRank', description='表存储排名'),
}

model StorageSummary {
  databaseNum?: int32(name='DatabaseNum', description='database num of this catalog'),
  partitionNum?: int32(name='PartitionNum', description='partition num of this catalog'),
  tableNum?: int32(name='TableNum', description='table num of this catalog'),
}

model Table {
  cascade?: boolean(name='Cascade', description='Cascade'),
  createTime?: int32(name='CreateTime', description='CreateTime'),
  createdBy?: string(name='CreatedBy', description='CreatedBy'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime', description='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime', description='LastAnalyzedTime'),
  owner?: string(name='Owner', description='Owner'),
  ownerType?: string(name='OwnerType', description='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  retention?: int32(name='Retention', description='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled', description='RewriteEnabled'),
  sd?: StorageDescriptor(name='Sd'),
  tableId?: string(name='TableId', description='TableId'),
  tableName?: string(name='TableName', description='TableName'),
  tableType?: string(name='TableType', description='TableType'),
  tableVersion?: TableVersion(name='TableVersion', description='TableVersion'),
  temporary?: boolean(name='Temporary', description='Temporary'),
  updateTime?: int32(name='UpdateTime', description='UpdateTime'),
  viewExpandedText?: string(name='ViewExpandedText', description='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText', description='ViewOriginalText'),
}

model TableError {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  tableName?: string(name='TableName', description='TableName'),
}

model TableExtended {
  cascade?: boolean(name='Cascade', description='Cascade'),
  createTime?: int32(name='CreateTime', description='CreateTime'),
  createdBy?: string(name='CreatedBy', description='CreatedBy'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime', description='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime', description='LastAnalyzedTime'),
  owner?: string(name='Owner', description='Owner'),
  ownerType?: string(name='OwnerType', description='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: {
    rolePrivileges?: map[string][ TableExtendedPrivilegesRolePrivilegesValue     ](name='RolePrivileges', description='rolePrivileges'),
    userPrivileges?: map[string][ TableExtendedPrivilegesUserPrivilegesValue     ](name='UserPrivileges', description='userPrivileges'),
    groupPrivileges?: map[string][ TableExtendedPrivilegesGroupPrivilegesValue     ](name='groupPrivileges', description='groupPrivileges'),
  }(name='Privileges', description='privileges'),
  retention?: int32(name='Retention', description='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled', description='RewriteEnabled'),
  sd?: {
    bucketCols?: [ string ](name='BucketCols', description='bucketCols'),
    cols?: [
      FieldSchema
    ](name='Cols', description='Cols'),
    compressed?: boolean(name='Compressed', description='Compressed'),
    inputFormat?: string(name='InputFormat', description='InputFormat'),
    location?: string(name='Location', description='Location'),
    numBuckets?: int32(name='NumBuckets', description='NumBuckets'),
    outputFormat?: string(name='OutputFormat', description='OutputFormat'),
    parameters?: map[string]string(name='Parameters', description='Parameters'),
    serDeInfo?: {
      name?: string(name='Name', description='Name'),
      parameters?: map[string]string(name='Parameters', description='Parameters'),
      serializationLib?: string(name='SerializationLib', description='SerializationLib'),
    }(name='SerDeInfo', description='SerDeInfo'),
    skewedInfo?: {
      skewedColNames?: [ string ](name='SkewedColNames', description='SkewedColNames'),
      skewedColValueLocationMaps?: map[string]string(name='SkewedColValueLocationMaps', description='SkewedColValueLocationMaps'),
      skewedColValues?: [[ string ]      ](name='SkewedColValues', description='SkewedColValues'),
    }(name='SkewedInfo', description='SkewedInfo'),
    sortCols?: [
      Order
    ](name='SortCols', description='SortCols'),
    storedAsSubDirectories?: boolean(name='StoredAsSubDirectories', description='StoredAsSubDirectories'),
  }(name='Sd', description='sd'),
  tableFormat?: string(name='TableFormat', description='TableFormat'),
  tableName?: string(name='TableName', description='TableName'),
  tableType?: string(name='TableType', description='TableType'),
  temporary?: boolean(name='Temporary', description='Temporary'),
  updateTime?: int32(name='UpdateTime', description='UpdateTime'),
  viewExpandedText?: string(name='ViewExpandedText', description='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText', description='ViewOriginalText'),
}

model TableInput {
  cascade?: boolean(name='Cascade', description='Cascade'),
  createTime?: int32(name='CreateTime', description='CreateTime'),
  createdBy?: string(name='CreatedBy', description='CreatedBy'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime', description='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime', description='LastAnalyzedTime'),
  owner?: string(name='Owner', description='Owner'),
  ownerType?: string(name='OwnerType', description='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  retention?: int32(name='Retention', description='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled', description='RewriteEnabled'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName', description='TableName'),
  tableType?: string(name='TableType', description='TableType'),
  temporary?: boolean(name='Temporary', description='Temporary'),
  viewExpandedText?: string(name='ViewExpandedText', description='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText', description='ViewOriginalText'),
}

model TableProfile {
  createTime?: string(name='CreateTime', description='创建时间'),
  databaseName?: string(name='DatabaseName', description='库名称'),
  fileCnt?: long(name='FileCnt', description='文件数量'),
  fileSize?: long(name='FileSize', description='文件大小'),
  isPartitioned?: boolean(name='IsPartitioned', description='是否分区表'),
  lastModifyTime?: string(name='LastModifyTime', description='最后跟新时间'),
  location?: string(name='Location', description='存储位置'),
  partitionCnt?: long(name='PartitionCnt', description='分区数量'),
  recordCnt?: long(name='RecordCnt', description='记录数'),
  tableName?: string(name='TableName', description='表名称'),
}

model TableResource {
  databaseName?: string(name='DatabaseName', description='database name'),
  tableName?: string(name='TableName', description='tablename'),
}

model TableStorageRank {
  dbName?: string(name='DbName', description='库名'),
  quantity?: long(name='Quantity', description='存储量'),
  tableName?: string(name='TableName', description='表名'),
}

model TableVersion {
  table?: Table(name='Table'),
  versionId?: int32(name='VersionId', description='table version'),
}

model TaskStatus {
  message?: string(name='Message', description='message of the task'),
  status?: string(name='Status', description='status of the task'),
}

model UnarchiveDetail {
  apiCallTimes?: long(name='ApiCallTimes', description='api调用次数'),
  cost?: long(name='Cost', description='成本'),
  storageSize?: long(name='StorageSize', description='存储大小'),
  storageType?: string(name='StorageType', description='存储类型'),
  unarchiveTaskStatus?: string(name='UnarchiveTaskStatus', description='解冻状态'),
}

model UpdateTablePartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId', description='CatalogId'),
  columnStatisticsList?: [
    ColumnStatistics
  ](name='ColumnStatisticsList', description='ColumnStatisticsList'),
  databaseName?: string(name='DatabaseName', description='DatabaseName'),
  engine?: string(name='Engine', description='Engine'),
  isStatsCompliant?: boolean(name='IsStatsCompliant', description='IsStatsCompliant'),
  tableName?: string(name='TableName', description='TableName'),
  validWriteIdList?: string(name='ValidWriteIdList', description='ValidWriteIdList, optional'),
  writeId?: string(name='WriteId', description='WriteId, optional'),
}

model UserRole {
  grantTime?: long(name='GrantTime', description='授权时间'),
  role?: Role(name='Role', description='授权的角色'),
  user?: Principal(name='User', description='授权的用户'),
}

model Workflow {
  latestEndTime?: string(name='LatestEndTime', description='最近运行的结束时间'),
  latestInstanceId?: string(name='LatestInstanceId', description='实例id'),
  latestInstanceStatus?: string(name='LatestInstanceStatus', description='最后运行实例的状态'),
  latestStartTime?: string(name='LatestStartTime', description='最后运行的开始时间'),
}

model WorkflowInstance {
  batchProgress?: int32(name='BatchProgress', description='执行进度'),
  dlfWorkflowId?: string(name='DlfWorkflowId', description='工作流id'),
  endTime?: long(name='EndTime', description='结束时间'),
  externalInstanceId?: string(name='ExternalInstanceId', description='业务流程实例id'),
  runtimeLogs?: [
    LogInfo
  ](name='RuntimeLogs', description='运行日志'),
  startTime?: long(name='StartTime', description='开始时间'),
  status?: string(name='Status', description='运行状态'),
}

model AbortLockRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  lockId?: long(name='LockId', description='LockId', position='Query'),
}

model AbortLockResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model AbortLockResponse = {
  headers: map[string]string(name='headers'),
  body: AbortLockResponseBody(name='body'),
}

async function abortLock(request: AbortLockRequest): AbortLockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AbortLock', 'DELETE', '/api/metastore/catalogs/databases/tables/locks/abort', 'json', false, 'json', request);
}

model BatchCreatePartitionsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  ifNotExists?: boolean(name='IfNotExists', description='IfNotExists', position='Body'),
  needResult?: boolean(name='NeedResult', description='NeedResult', position='Body'),
  partitionInputs?: [
    PartitionInput
  ](name='PartitionInputs', description='PartitionInputs', position='Body'),
  tableName?: string(name='TableName', description='TableName', position='Body'),
}

model BatchCreatePartitionsResponseBody = {
  code?: string(name='Code', description='响应代码'),
  message?: string(name='Message', description='响应消息'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='分区出错信息'),
  partitions?: [
    Partition
  ](name='Partitions', description='Partitions'),
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='是否成功'),
}

model BatchCreatePartitionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchCreatePartitionsResponseBody(name='body'),
}

async function batchCreatePartitions(request: BatchCreatePartitionsRequest): BatchCreatePartitionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchCreatePartitions', 'POST', '/api/metastore/catalogs/databases/tables/partitions/batchcreate', 'json', false, 'json', request);
}

model BatchCreateTablesRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  ifNotExists?: boolean(name='IfNotExists', description='IfNotExists', position='Body'),
  tableInputs?: [
    TableInput
  ](name='TableInputs', description='TableInputs', position='Body'),
}

model BatchCreateTablesResponseBody = {
  code?: string(name='Code', description='响应代码'),
  message?: string(name='Message', description='响应消息'),
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='是否成功'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='表出错信息'),
}

model BatchCreateTablesResponse = {
  headers: map[string]string(name='headers'),
  body: BatchCreateTablesResponseBody(name='body'),
}

async function batchCreateTables(request: BatchCreateTablesRequest): BatchCreateTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchCreateTables', 'POST', '/api/metastore/catalogs/databases/tables/batchcreate', 'json', false, 'json', request);
}

model BatchDeletePartitionsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  ifExists?: boolean(name='IfExists', description='IfExists', position='Body'),
  partitionValueList?: [ 
{
values?: [ string ](name='Values'),
}
](name='PartitionValueList', position='Body'),
  tableName?: string(name='TableName', description='TableName', position='Body'),
}

model BatchDeletePartitionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='PartitionErrors'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model BatchDeletePartitionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchDeletePartitionsResponseBody(name='body'),
}

async function batchDeletePartitions(request: BatchDeletePartitionsRequest): BatchDeletePartitionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchDeletePartitions', 'POST', '/api/metastore/catalogs/databases/tables/partitions/batchdelete', 'json', false, 'json', request);
}

model BatchDeleteTableVersionsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  tableName?: string(name='TableName', description='TableName', position='Body'),
  versionIds?: [ int32 ](name='VersionIds', description='Table versionIds', position='Body'),
}

model BatchDeleteTableVersionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model BatchDeleteTableVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchDeleteTableVersionsResponseBody(name='body'),
}

async function batchDeleteTableVersions(request: BatchDeleteTableVersionsRequest): BatchDeleteTableVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchDeleteTableVersions', 'POST', '/api/metastore/catalogs/databases/tables/versions/batchdelete', 'json', false, 'json', request);
}

model BatchDeleteTablesRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  ifExists?: boolean(name='IfExists', description='IfExists', position='Body'),
  tableNames?: [ string ](name='TableNames', description='TableName', position='Body'),
}

model BatchDeleteTablesResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='PartitionErrors'),
}

model BatchDeleteTablesResponse = {
  headers: map[string]string(name='headers'),
  body: BatchDeleteTablesResponseBody(name='body'),
}

async function batchDeleteTables(request: BatchDeleteTablesRequest): BatchDeleteTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchDeleteTables', 'POST', '/api/metastore/catalogs/databases/tables/batchdelete', 'json', false, 'json', request);
}

model BatchGetPartitionColumnStatisticsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  columnNames?: [ string ](name='ColumnNames', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  partitionNames?: [ string ](name='PartitionNames', position='Body'),
  tableName?: string(name='TableName', description='TableName', position='Body'),
}

model BatchGetPartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partitionStatisticsMap?: map[string][
    ColumnStatisticsObj
  ](name='PartitionStatisticsMap', description='PartitionStatisticsMap'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model BatchGetPartitionColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchGetPartitionColumnStatisticsResponseBody(name='body'),
}

async function batchGetPartitionColumnStatistics(request: BatchGetPartitionColumnStatisticsRequest): BatchGetPartitionColumnStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchGetPartitionColumnStatistics', 'POST', '/api/metastore/catalogs/databases/tables/partitions/columnstatistics/batchget', 'json', false, 'json', request);
}

model BatchGetPartitionsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  isShareSd?: boolean(name='IsShareSd', description='IsShareSd', position='Body'),
  partitionValueList?: [ 
{
values?: [ string ](name='Values'),
}
](name='PartitionValueList', position='Body'),
  tableName?: string(name='TableName', description='TableName', position='Body'),
}

model BatchGetPartitionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='PartitionErrors'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs', description='PartitionSpecs'),
  partitions?: [
    Partition
  ](name='Partitions', description='Partitions'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model BatchGetPartitionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchGetPartitionsResponseBody(name='body'),
}

async function batchGetPartitions(request: BatchGetPartitionsRequest): BatchGetPartitionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchGetPartitions', 'POST', '/api/metastore/catalogs/databases/tables/partitions/batchget', 'json', false, 'json', request);
}

model BatchGetTablesRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  tableNames?: [ string ](name='TableNames', position='Body'),
}

model BatchGetTablesResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='TableErrors'),
  tables?: [
    Table
  ](name='Tables', description='Tables'),
}

model BatchGetTablesResponse = {
  headers: map[string]string(name='headers'),
  body: BatchGetTablesResponseBody(name='body'),
}

async function batchGetTables(request: BatchGetTablesRequest): BatchGetTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchGetTables', 'POST', '/api/metastore/catalogs/databases/tables/batchget', 'json', false, 'json', request);
}

model BatchGrantPermissionsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='catalogId', position='Body'),
  grantRevokeEntries?: [
    GrantRevokeEntry
  ](name='GrantRevokeEntries', description='待授权列表', position='Body'),
  type: string(name='Type', description='授权的类型，目前仅支持hive', position='Body'),
}

model BatchGrantPermissionsResponseBody = {
  batchGrantRevokeFailureResult?: [
    GrantRevokeFailureEntry
  ](name='BatchGrantRevokeFailureResult', description='result'),
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Message Code'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model BatchGrantPermissionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchGrantPermissionsResponseBody(name='body'),
}

async function batchGrantPermissions(request: BatchGrantPermissionsRequest): BatchGrantPermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchGrantPermissions', 'POST', '/api/metastore/auth/permissions/batchgrant', 'json', false, 'json', request);
}

model BatchRevokePermissionsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='catalogId', position='Body'),
  grantRevokeEntries?: [
    GrantRevokeEntry
  ](name='GrantRevokeEntries', description='待授权列表', position='Body'),
  type: string(name='Type', description='授权的类型，目前仅支持hive', position='Body'),
}

model BatchRevokePermissionsResponseBody = {
  batchGrantRevokeFailureResult?: [
    GrantRevokeFailureEntry
  ](name='BatchGrantRevokeFailureResult', description='result'),
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Message Code'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model BatchRevokePermissionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchRevokePermissionsResponseBody(name='body'),
}

async function batchRevokePermissions(request: BatchRevokePermissionsRequest): BatchRevokePermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchRevokePermissions', 'POST', '/api/metastore/auth/permissions/batchrevoke', 'json', false, 'json', request);
}

model BatchUpdatePartitionsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  partitionInputs?: [
    PartitionInput
  ](name='PartitionInputs', description='PartitionInputs', position='Body'),
  tableName?: string(name='TableName', description='TableName', position='Body'),
}

model BatchUpdatePartitionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='PartitionErrors'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model BatchUpdatePartitionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchUpdatePartitionsResponseBody(name='body'),
}

async function batchUpdatePartitions(request: BatchUpdatePartitionsRequest): BatchUpdatePartitionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchUpdatePartitions', 'PUT', '/api/metastore/catalogs/databases/tables/partitions/batchupdate', 'json', false, 'json', request);
}

model BatchUpdateTablesRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  isAsync?: boolean(name='IsAsync', description='是否异步', position='Body'),
  tableInputs?: [
    TableInput
  ](name='TableInputs', description='TableInputs', position='Body'),
}

model BatchUpdateTablesResponseBody = {
  code?: string(name='Code', description='响应代码'),
  message?: string(name='Message', description='响应消息'),
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='是否成功'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='表出错信息'),
  taskId?: string(name='TaskId', description='异步更新 taskId'),
}

model BatchUpdateTablesResponse = {
  headers: map[string]string(name='headers'),
  body: BatchUpdateTablesResponseBody(name='body'),
}

async function batchUpdateTables(request: BatchUpdateTablesRequest): BatchUpdateTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchUpdateTables', 'POST', '/api/metastore/catalogs/databases/tables/batchupdate', 'json', false, 'json', request);
}

model CancelQueryRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  queryId?: string(name='QueryId', position='Query'),
}

model CancelQueryResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelQueryResponse = {
  headers: map[string]string(name='headers'),
  body: CancelQueryResponseBody(name='body'),
}

async function cancelQuery(request: CancelQueryRequest): CancelQueryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CancelQuery', 'POST', '/webapi/query/cancelQuery', 'json', false, 'json', request);
}

model CheckPermissionsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  body?: AccessRequest(name='Body', position='Body'),
}

model CheckPermissionsResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Message Code'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model CheckPermissionsResponse = {
  headers: map[string]string(name='headers'),
  body: CheckPermissionsResponseBody(name='body'),
}

async function checkPermissions(request: CheckPermissionsRequest): CheckPermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CheckPermissions', 'POST', '/api/metastore/auth/permissions/check', 'json', false, 'json', request);
}

model CreateCatalogRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogInput?: CatalogInput(name='CatalogInput', position='Body'),
}

model CreateCatalogResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Response Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model CreateCatalogResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCatalogResponseBody(name='body'),
}

async function createCatalog(request: CreateCatalogRequest): CreateCatalogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateCatalog', 'POST', '/api/metastore/catalogs', 'json', false, 'json', request);
}

model CreateDatabaseRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseInput?: DatabaseInput(name='DatabaseInput', position='Body'),
}

model CreateDatabaseResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Response Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model CreateDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDatabaseResponseBody(name='body'),
}

async function createDatabase(request: CreateDatabaseRequest): CreateDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateDatabase', 'POST', '/api/metastore/catalogs/databases', 'json', false, 'json', request);
}

model CreateFunctionRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  functionInput?: FunctionInput(name='FunctionInput', position='Body'),
}

model CreateFunctionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model CreateFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFunctionResponseBody(name='body'),
}

async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateFunction', 'POST', '/api/metastore/catalogs/databases/functions', 'json', false, 'json', request);
}

model CreateLockRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  lockObjList?: [
    LockObj
  ](name='LockObjList', description='LockObjList', position='Body'),
}

model CreateLockResponseBody = {
  code?: string(name='Code', description='Code'),
  lockStatus?: LockStatus(name='LockStatus'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model CreateLockResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLockResponseBody(name='body'),
}

async function createLock(request: CreateLockRequest): CreateLockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateLock', 'POST', '/api/metastore/catalogs/databases/tables/locks', 'json', false, 'json', request);
}

model CreatePartitionRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  ifNotExists?: boolean(name='IfNotExists', description='IfNotExists', position='Body'),
  needResult?: boolean(name='NeedResult', description='NeedResult', position='Body'),
  partitionInput?: PartitionInput(name='PartitionInput', position='Body'),
  tableName?: string(name='TableName', description='TableName', position='Body'),
}

model CreatePartitionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partition?: Partition(name='Partition'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model CreatePartitionResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePartitionResponseBody(name='body'),
}

async function createPartition(request: CreatePartitionRequest): CreatePartitionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreatePartition', 'POST', '/api/metastore/catalogs/databases/tables/partitions', 'json', false, 'json', request);
}

model CreateRoleRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  body?: RoleInput(name='body', position='Body'),
}

model CreateRoleResponseBody = {
  code?: string(name='Code', description='code'),
  message?: string(name='Message', description='message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='success'),
}

model CreateRoleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRoleResponseBody(name='body'),
}

async function createRole(request: CreateRoleRequest): CreateRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateRole', 'POST', '/api/metastore/auth/roles', 'json', false, 'json', request);
}

model CreateTableRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  tableInput?: TableInput(name='TableInput', position='Body'),
}

model CreateTableResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model CreateTableResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTableResponseBody(name='body'),
}

async function createTable(request: CreateTableRequest): CreateTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateTable', 'POST', '/api/metastore/catalogs/databases/tables', 'json', false, 'json', request);
}

model DeleteCatalogRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId: string(name='CatalogId', description='CatalogId', position='Query'),
  isAsync?: boolean(name='IsAsync', description='是否异步，默认同步', position='Query'),
}

model DeleteCatalogResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Response Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Request is success or not'),
  taskId?: string(name='TaskId', description='异步删除Catalog的taskId'),
}

model DeleteCatalogResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCatalogResponseBody(name='body'),
}

async function deleteCatalog(request: DeleteCatalogRequest): DeleteCatalogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteCatalog', 'DELETE', '/api/metastore/catalogs', 'json', false, 'json', request);
}

model DeleteDatabaseRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  cascade?: boolean(name='Cascade', description='Cascade', position='Query'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  name?: string(name='Name', description='Name', position='Query'),
}

model DeleteDatabaseResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Response Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Request is success or not'),
}

model DeleteDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDatabaseResponseBody(name='body'),
}

async function deleteDatabase(request: DeleteDatabaseRequest): DeleteDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteDatabase', 'DELETE', '/api/metastore/catalogs/databases', 'json', false, 'json', request);
}

model DeleteFunctionRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Query'),
  functionName?: string(name='FunctionName', description='FunctionName', position='Query'),
}

model DeleteFunctionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeleteFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFunctionResponseBody(name='body'),
}

async function deleteFunction(request: DeleteFunctionRequest): DeleteFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteFunction', 'DELETE', '/api/metastore/catalogs/databases/functions', 'json', false, 'json', request);
}

model DeletePartitionRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  ifExists?: boolean(name='IfExists', description='IfExists', position='Body'),
  partitionValues?: [ string ](name='PartitionValues', position='Body'),
  tableName?: string(name='TableName', description='TableName', position='Body'),
}

model DeletePartitionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeletePartitionResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePartitionResponseBody(name='body'),
}

async function deletePartition(request: DeletePartitionRequest): DeletePartitionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeletePartition', 'POST', '/api/metastore/catalogs/databases/tables/partitions/delete', 'json', false, 'json', request);
}

model DeletePartitionColumnStatisticsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  columnNames?: [ string ](name='ColumnNames', shrink='json', position='Query'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Query'),
  partitionNames?: [ string ](name='PartitionNames', shrink='json', position='Query'),
  tableName?: string(name='TableName', description='TableName', position='Query'),
}

model DeletePartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeletePartitionColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePartitionColumnStatisticsResponseBody(name='body'),
}

async function deletePartitionColumnStatistics(request: DeletePartitionColumnStatisticsRequest): DeletePartitionColumnStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeletePartitionColumnStatistics', 'DELETE', '/api/metastore/catalogs/databases/tables/partitions/columnstatistics', 'json', false, 'json', request);
}

model DeleteRoleRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  roleName?: string(name='RoleName', description='roleName', position='Query'),
}

model DeleteRoleResponseBody = {
  code?: string(name='Code', description='code'),
  message?: string(name='Message', description='message'),
  requestId?: string(name='RequestId', description='requestId'),
  success?: boolean(name='Success', description='success'),
}

model DeleteRoleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRoleResponseBody(name='body'),
}

async function deleteRole(request: DeleteRoleRequest): DeleteRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteRole', 'DELETE', '/api/metastore/auth/roles', 'json', false, 'json', request);
}

model DeleteTableRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Query'),
  tableName?: string(name='TableName', description='TableName', position='Query'),
}

model DeleteTableResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeleteTableResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTableResponseBody(name='body'),
}

async function deleteTable(request: DeleteTableRequest): DeleteTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteTable', 'DELETE', '/api/metastore/catalogs/databases/tables', 'json', false, 'json', request);
}

model DeleteTableColumnStatisticsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  columnNames?: [ string ](name='ColumnNames', shrink='json', position='Query'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Query'),
  tableName?: string(name='TableName', description='TableName', position='Query'),
}

model DeleteTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeleteTableColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTableColumnStatisticsResponseBody(name='body'),
}

async function deleteTableColumnStatistics(request: DeleteTableColumnStatisticsRequest): DeleteTableColumnStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteTableColumnStatistics', 'DELETE', '/api/metastore/catalogs/databases/tables/columnstatistics', 'json', false, 'json', request);
}

model DeleteTableVersionRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Query'),
  tableName?: string(name='TableName', description='TableName', position='Query'),
  versionId?: int32(name='VersionId', description='table version id', position='Query'),
}

model DeleteTableVersionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model DeleteTableVersionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTableVersionResponseBody(name='body'),
}

async function deleteTableVersion(request: DeleteTableVersionRequest): DeleteTableVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteTableVersion', 'DELETE', '/api/metastore/catalogs/databases/tables/versions', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      showName?: string(name='ShowName'),
      type?: string(name='Type'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeRegions', 'GET', '/webapi/service/describeRegions', 'json', false, 'json', request);
}

model GetAsyncTaskStatusRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  taskId?: string(name='TaskId', description='TaskId', position='Query'),
}

model GetAsyncTaskStatusResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  taskStatus?: TaskStatus(name='TaskStatus'),
}

model GetAsyncTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetAsyncTaskStatusResponseBody(name='body'),
}

async function getAsyncTaskStatus(request: GetAsyncTaskStatusRequest): GetAsyncTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetAsyncTaskStatus', 'GET', '/api/metastore/catalogs/tasks', 'json', false, 'json', request);
}

model GetCatalogRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='catalogId', position='Query'),
}

model GetCatalogResponseBody = {
  catalog?: Catalog(name='Catalog'),
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GetCatalogResponse = {
  headers: map[string]string(name='headers'),
  body: GetCatalogResponseBody(name='body'),
}

async function getCatalog(request: GetCatalogRequest): GetCatalogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetCatalog', 'GET', '/api/metastore/catalogs', 'json', false, 'json', request);
}

model GetCatalogSettingsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', position='Query'),
}

model GetCatalogSettingsResponseBody = {
  catalogSettings?: CatalogSettings(name='CatalogSettings'),
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GetCatalogSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: GetCatalogSettingsResponseBody(name='body'),
}

async function getCatalogSettings(request: GetCatalogSettingsRequest): GetCatalogSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetCatalogSettings', 'GET', '/api/metastore/catalogs/settings', 'json', false, 'json', request);
}

model GetDatabaseRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  name?: string(name='Name', description='The name of the database to query.', position='Query'),
}

model GetDatabaseResponseBody = {
  code?: string(name='Code', description='Response Code'),
  database?: Database(name='Database'),
  message?: string(name='Message', description='Response Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='API is success or not'),
}

model GetDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: GetDatabaseResponseBody(name='body'),
}

async function getDatabase(request: GetDatabaseRequest): GetDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetDatabase', 'GET', '/api/metastore/catalogs/databases', 'json', false, 'json', request);
}

model GetFunctionRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Query'),
  functionName?: string(name='FunctionName', description='FunctionName', position='Query'),
}

model GetFunctionResponseBody = {
  code?: string(name='Code', description='Code'),
  function?: Function(name='Function'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GetFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: GetFunctionResponseBody(name='body'),
}

async function getFunction(request: GetFunctionRequest): GetFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunction', 'GET', '/api/metastore/catalogs/databases/functions', 'json', false, 'json', request);
}

model GetLockRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  lockId?: long(name='LockId', description='LockId', position='Query'),
}

model GetLockResponseBody = {
  code?: string(name='Code', description='Code'),
  lockStatus?: LockStatus(name='LockStatus'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GetLockResponse = {
  headers: map[string]string(name='headers'),
  body: GetLockResponseBody(name='body'),
}

async function getLock(request: GetLockRequest): GetLockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLock', 'GET', '/api/metastore/catalogs/databases/tables/locks', 'json', false, 'json', request);
}

model GetPartitionRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  partitionValues?: [ string ](name='PartitionValues', position='Body'),
  tableName?: string(name='TableName', description='TableName', position='Body'),
}

model GetPartitionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partition?: Partition(name='Partition'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GetPartitionResponse = {
  headers: map[string]string(name='headers'),
  body: GetPartitionResponseBody(name='body'),
}

async function getPartition(request: GetPartitionRequest): GetPartitionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetPartition', 'POST', '/api/metastore/catalogs/databases/tables/partitions/get', 'json', false, 'json', request);
}

model GetPartitionColumnStatisticsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  columnNames?: [ string ](name='ColumnNames', shrink='json', position='Query'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Query'),
  partitionNames?: [ string ](name='PartitionNames', shrink='json', position='Query'),
  tableName?: string(name='TableName', description='TableName', position='Query'),
}

model GetPartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  partitionStatisticsMap?: map[string][
    ColumnStatisticsObj
  ](name='PartitionStatisticsMap', description='PartitionStatisticsMap'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GetPartitionColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: GetPartitionColumnStatisticsResponseBody(name='body'),
}

async function getPartitionColumnStatistics(request: GetPartitionColumnStatisticsRequest): GetPartitionColumnStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetPartitionColumnStatistics', 'GET', '/api/metastore/catalogs/databases/tables/partitions/columnstatistics', 'json', false, 'json', request);
}

model GetQueryResultRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  queryId?: string(name='QueryId', position='Query'),
}

model GetQueryResultResponseBody = {
  duration?: long(name='Duration'),
  endTime?: string(name='EndTime'),
  errorMessage?: string(name='ErrorMessage'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  id?: string(name='Id'),
  jobCompleted?: boolean(name='JobCompleted'),
  logs?: string(name='Logs'),
  owner?: long(name='Owner'),
  progress?: int32(name='Progress'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resultTmpDb?: string(name='ResultTmpDb'),
  resultTmpTable?: string(name='ResultTmpTable'),
  rowCount?: int32(name='RowCount'),
  rowCountOverLimit?: boolean(name='RowCountOverLimit'),
  rows?: string(name='Rows'),
  schema?: string(name='Schema'),
  sql?: string(name='Sql'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
  success?: boolean(name='Success'),
  totalBytesProcessed?: long(name='TotalBytesProcessed'),
}

model GetQueryResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetQueryResultResponseBody(name='body'),
}

async function getQueryResult(request: GetQueryResultRequest): GetQueryResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetQueryResult', 'GET', '/webapi/query/getQueryResult', 'json', false, 'json', request);
}

model GetRegionStatusRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host,Query'),
}

model GetRegionStatusResponseBody = {
  data?: {
    accountStatus?: string(name='AccountStatus'),
    isDependencyReady?: boolean(name='IsDependencyReady'),
    isDlfServiceOpen?: boolean(name='IsDlfServiceOpen'),
    regionId?: string(name='RegionId'),
    regionStatus?: string(name='RegionStatus'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetRegionStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetRegionStatusResponseBody(name='body'),
}

async function getRegionStatus(request: GetRegionStatusRequest): GetRegionStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetRegionStatus', 'GET', '/webapi/service/getRegionStatus', 'json', false, 'json', request);
}

model GetRoleRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  roleName?: string(name='RoleName', description='roleName', position='Query'),
}

model GetRoleResponseBody = {
  code?: string(name='Code', description='code'),
  message?: string(name='Message', description='message'),
  requestId?: string(name='RequestId', description='requestId'),
  role?: Role(name='Role', description='role'),
  success?: boolean(name='Success', description='success'),
}

model GetRoleResponse = {
  headers: map[string]string(name='headers'),
  body: GetRoleResponseBody(name='body'),
}

async function getRole(request: GetRoleRequest): GetRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetRole', 'GET', '/api/metastore/auth/roles', 'json', false, 'json', request);
}

model GetServiceStatusRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host,Query'),
}

model GetServiceStatusResponseBody = {
  data?: {
    hasRamPermissions?: boolean(name='HasRamPermissions'),
    isDlfServiceOpen?: boolean(name='IsDlfServiceOpen'),
    isOssOpen?: boolean(name='IsOssOpen'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceStatusResponseBody(name='body'),
}

async function getServiceStatus(request: GetServiceStatusRequest): GetServiceStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetServiceStatus', 'GET', '/webapi/service/getServiceStatus', 'json', false, 'json', request);
}

model GetTableRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Query'),
  tableName?: string(name='TableName', description='TableName', position='Query'),
}

model GetTableResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  table?: Table(name='Table'),
}

model GetTableResponse = {
  headers: map[string]string(name='headers'),
  body: GetTableResponseBody(name='body'),
}

async function getTable(request: GetTableRequest): GetTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTable', 'GET', '/api/metastore/catalogs/databases/tables', 'json', false, 'json', request);
}

model GetTableColumnStatisticsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  columnNames?: [ string ](name='ColumnNames', shrink='json', position='Query'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Query'),
  tableName?: string(name='TableName', description='TableName', position='Query'),
}

model GetTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  columnStatisticsObjList?: [
    ColumnStatisticsObj
  ](name='ColumnStatisticsObjList', description='ColumnStatisticsObjList'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GetTableColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: GetTableColumnStatisticsResponseBody(name='body'),
}

async function getTableColumnStatistics(request: GetTableColumnStatisticsRequest): GetTableColumnStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTableColumnStatistics', 'GET', '/api/metastore/catalogs/databases/tables/columnstatistics', 'json', false, 'json', request);
}

model GetTableProfileRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  databaseName: string(name='DatabaseName', description='DatabaseName', position='Query'),
  tableName: string(name='TableName', description='TableName', position='Query'),
}

model GetTableProfileResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tableProfile?: TableProfile(name='TableProfile'),
}

model GetTableProfileResponse = {
  headers: map[string]string(name='headers'),
  body: GetTableProfileResponseBody(name='body'),
}

async function getTableProfile(request: GetTableProfileRequest): GetTableProfileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTableProfile', 'GET', '/webapi/metastorehouse/catalog/database/tableprofile', 'json', false, 'json', request);
}

model GetTableVersionRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Query'),
  tableName?: string(name='TableName', description='TableName', position='Query'),
  versionId?: int32(name='VersionId', description='Table Version', position='Query'),
}

model GetTableVersionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tableVersion?: TableVersion(name='TableVersion'),
}

model GetTableVersionResponse = {
  headers: map[string]string(name='headers'),
  body: GetTableVersionResponseBody(name='body'),
}

async function getTableVersion(request: GetTableVersionRequest): GetTableVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTableVersion', 'GET', '/api/metastore/catalogs/databases/tables/versions', 'json', false, 'json', request);
}

model GrantPermissionsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  accesses: [ string ](name='Accesses', description='授权的accesses列表', position='Body'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  delegateAccesses: [ string ](name='DelegateAccesses', description='授权的grantable accesses列表', position='Body'),
  metaResource: MetaResource(name='MetaResource', description='授权meta资源', position='Body'),
  principal: Principal(name='Principal', description='授权的用户/角色principal', position='Body'),
  type: string(name='Type', description='授权的类型，目前仅支持hive', position='Body'),
}

model GrantPermissionsResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Message Code'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GrantPermissionsResponse = {
  headers: map[string]string(name='headers'),
  body: GrantPermissionsResponseBody(name='body'),
}

async function grantPermissions(request: GrantPermissionsRequest): GrantPermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GrantPermissions', 'POST', '/api/metastore/auth/permissions/grant', 'json', false, 'json', request);
}

model GrantRoleToUsersRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  roleName?: string(name='RoleName', description='RoleName', position='Body'),
  users?: [
Principal
](name='Users', position='Body'),
}

model GrantRoleToUsersResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GrantRoleToUsersResponse = {
  headers: map[string]string(name='headers'),
  body: GrantRoleToUsersResponseBody(name='body'),
}

async function grantRoleToUsers(request: GrantRoleToUsersRequest): GrantRoleToUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GrantRoleToUsers', 'PUT', '/api/metastore/auth/roles/grantusers', 'json', false, 'json', request);
}

model GrantRolesToUserRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  roleNames: [ string ](name='RoleNames', description='待授权的角色名列表', position='Body'),
  user: Principal(name='User', position='Body'),
}

model GrantRolesToUserResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model GrantRolesToUserResponse = {
  headers: map[string]string(name='headers'),
  body: GrantRolesToUserResponseBody(name='body'),
}

async function grantRolesToUser(request: GrantRolesToUserRequest): GrantRolesToUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GrantRolesToUser', 'POST', '/api/metastore/auth/roles/grantroles', 'json', false, 'json', request);
}

model ListCatalogsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  idPattern?: string(name='IdPattern', description='catalogId', position='Query'),
  nextPageToken?: string(name='NextPageToken', description='namePattern', position='Query'),
  pageSize?: int32(name='PageSize', description='pageSize', minimum=-2, maximum=1000000, position='Query'),
}

model ListCatalogsResponseBody = {
  catalogs?: [
    Catalog
  ](name='Catalogs', description='Catalogs'),
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListCatalogsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCatalogsResponseBody(name='body'),
}

async function listCatalogs(request: ListCatalogsRequest): ListCatalogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListCatalogs', 'GET', '/api/metastore/catalogs/list', 'json', false, 'json', request);
}

model ListDatabasesRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='catalogId', position='Query'),
  namePattern?: string(name='NamePattern', description='namePattern', position='Query'),
  nextPageToken?: string(name='NextPageToken', description='namePattern', position='Query'),
  pageSize?: int32(name='PageSize', description='pageSize', minimum=-2, maximum=1000000, position='Query'),
}

model ListDatabasesResponseBody = {
  code?: string(name='Code', description='Code'),
  databases?: [
    Database
  ](name='Databases', description='Database List'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListDatabasesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDatabasesResponseBody(name='body'),
}

async function listDatabases(request: ListDatabasesRequest): ListDatabasesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDatabases', 'GET', '/api/metastore/catalogs/databases/list', 'json', false, 'json', request);
}

model ListFunctionNamesRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Query'),
  functionNamePattern?: string(name='FunctionNamePattern', description='FunctionNamePattern', position='Query'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken', position='Query'),
  pageSize?: int32(name='PageSize', description='PageSize', minimum=-1, maximum=1000000, position='Query'),
}

model ListFunctionNamesResponseBody = {
  code?: string(name='Code', description='Code'),
  functionNames?: [ string ](name='FunctionNames', description='FunctionNames'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListFunctionNamesResponse = {
  headers: map[string]string(name='headers'),
  body: ListFunctionNamesResponseBody(name='body'),
}

async function listFunctionNames(request: ListFunctionNamesRequest): ListFunctionNamesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFunctionNames', 'GET', '/api/metastore/catalogs/databases/functions/names', 'json', false, 'json', request);
}

model ListFunctionsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Query'),
  functionNamePattern?: string(name='FunctionNamePattern', description='FunctionNamePattern', position='Query'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken', position='Query'),
  pageSize?: int32(name='PageSize', description='PageSize', minimum=-1, maximum=1000000, position='Query'),
}

model ListFunctionsResponseBody = {
  code?: string(name='Code', description='Code'),
  functions?: [
    Function
  ](name='Functions', description='Functions'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListFunctionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFunctionsResponseBody(name='body'),
}

async function listFunctions(request: ListFunctionsRequest): ListFunctionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFunctions', 'GET', '/api/metastore/catalogs/databases/functions/list', 'json', false, 'json', request);
}

model ListPartitionNamesRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken', position='Body'),
  pageSize?: int32(name='PageSize', description='PageSize', position='Body'),
  partialPartValues?: [ string ](name='PartialPartValues', position='Body'),
  tableName?: string(name='TableName', description='TableName', position='Body'),
}

model ListPartitionNamesResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  partitionNames?: [ string ](name='PartitionNames', description='PartitionNames'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListPartitionNamesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPartitionNamesResponseBody(name='body'),
}

async function listPartitionNames(request: ListPartitionNamesRequest): ListPartitionNamesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPartitionNames', 'POST', '/api/metastore/catalogs/databases/tables/partitions/names', 'json', false, 'json', request);
}

model ListPartitionsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  isShareSd?: boolean(name='IsShareSd', description='IsShareSd', position='Body'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken', position='Body'),
  pageSize?: int32(name='PageSize', description='PageSize', position='Body'),
  partialPartValues?: [ string ](name='PartialPartValues', position='Body'),
  tableName?: string(name='TableName', description='TableName', position='Body'),
}

model ListPartitionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs', description='PartitionSpecs'),
  partitions?: [
    Partition
  ](name='Partitions', description='Partitions'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListPartitionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListPartitionsResponseBody(name='body'),
}

async function listPartitions(request: ListPartitionsRequest): ListPartitionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPartitions', 'POST', '/api/metastore/catalogs/databases/tables/partitions/list', 'json', false, 'json', request);
}

model ListPartitionsByExprRequest {
  regionId?: string(name='RegionId', position='Host'),
}

model ListPartitionsByExprResponse = {
  headers: map[string]string(name='headers'),
}

async function listPartitionsByExpr(request: ListPartitionsByExprRequest): ListPartitionsByExprResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPartitionsByExpr', 'POST', '/api/metastore/catalogs/databases/tables/partitions/listbyexpr', 'none', false, 'json', request);
}

model ListPartitionsByFilterRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  filter?: string(name='Filter', description='Filter', position='Body'),
  isShareSd?: boolean(name='IsShareSd', description='IsShareSd', position='Body'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken', position='Body'),
  pageSize?: int32(name='PageSize', description='PageSize', position='Body'),
  tableName?: string(name='TableName', description='TableName', position='Body'),
}

model ListPartitionsByFilterResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs', description='PartitionSpecs'),
  partitions?: [
    Partition
  ](name='Partitions', description='Partitions'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model ListPartitionsByFilterResponse = {
  headers: map[string]string(name='headers'),
  body: ListPartitionsByFilterResponseBody(name='body'),
}

async function listPartitionsByFilter(request: ListPartitionsByFilterRequest): ListPartitionsByFilterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPartitionsByFilter', 'POST', '/api/metastore/catalogs/databases/tables/partitions/listbyfilter', 'json', false, 'json', request);
}

model ListPermissionsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  isListUserRolePermissions?: boolean(name='IsListUserRolePermissions', description='是否获取用户所属角色的权限', position='Body'),
  metaResource?: MetaResource(name='MetaResource', description='基于资源对权限信息进行过滤', position='Body'),
  metaResourceType?: string(name='MetaResourceType', description='基于Resource Type进行过滤', position='Body'),
  nextPageToken?: string(name='NextPageToken', description='分页Token', position='Body'),
  pageSize?: int32(name='PageSize', description='分页大小', position='Body'),
  principal?: Principal(name='Principal', description='基于Principal对权限信息进行过滤', position='Body'),
  type: string(name='Type', description='获取权限信息的类型，目前仅支持hive', position='Body'),
}

model ListPermissionsResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Message Code'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  principalResourcePermissionsList?: [
    PrincipalResourcePermissions
  ](name='PrincipalResourcePermissionsList'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  totalCount?: long(name='TotalCount', description='TotalCount'),
}

model ListPermissionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListPermissionsResponseBody(name='body'),
}

async function listPermissions(request: ListPermissionsRequest): ListPermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPermissions', 'POST', '/api/metastore/auth/permissions/list', 'json', false, 'json', request);
}

model ListRoleUsersRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken', position='Query'),
  pageSize?: int32(name='PageSize', description='PageSize', position='Query'),
  roleName?: string(name='RoleName', position='Query'),
  userNamePattern?: string(name='UserNamePattern', description='use name pattern filter', position='Query'),
}

model ListRoleUsersResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success'),
  userRoles?: [
    UserRole
  ](name='UserRoles', description='user roles'),
}

model ListRoleUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListRoleUsersResponseBody(name='body'),
}

async function listRoleUsers(request: ListRoleUsersRequest): ListRoleUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListRoleUsers', 'GET', '/api/metastore/auth/roles/roleusers', 'json', false, 'json', request);
}

model ListRolesRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  nextPageToken?: string(name='NextPageToken', description='Next PageToken', position='Query'),
  pageSize?: int32(name='PageSize', description='PageSize', position='Query'),
  roleNamePattern?: string(name='RoleNamePattern', position='Query'),
}

model ListRolesResponseBody = {
  code?: string(name='Code', description='code'),
  message?: string(name='Message', description='message'),
  nextPageToken?: string(name='NextPageToken', description='data'),
  requestId?: string(name='RequestId', description='requestId'),
  roles?: [
    Role
  ](name='Roles', description='role list data'),
  success?: boolean(name='Success', description='success'),
}

model ListRolesResponse = {
  headers: map[string]string(name='headers'),
  body: ListRolesResponseBody(name='body'),
}

async function listRoles(request: ListRolesRequest): ListRolesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListRoles', 'GET', '/api/metastore/auth/roles/list', 'json', false, 'json', request);
}

model ListTableNamesRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Query'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken', position='Query'),
  pageSize?: int32(name='PageSize', description='PageSize', minimum=-1, maximum=1000000, position='Query'),
  tableNamePattern?: string(name='TableNamePattern', description='TableNamePattern', position='Query'),
  tableType?: string(name='TableType', description='TableType filter', position='Query'),
}

model ListTableNamesResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tableNames?: [ string ](name='TableNames', description='TableNames'),
}

model ListTableNamesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTableNamesResponseBody(name='body'),
}

async function listTableNames(request: ListTableNamesRequest): ListTableNamesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTableNames', 'GET', '/api/metastore/catalogs/databases/tables/names', 'json', false, 'json', request);
}

model ListTableVersionsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Query'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken', position='Query'),
  pageSize?: int32(name='PageSize', description='max result of this query', position='Query'),
  tableName?: string(name='TableName', description='TableName', position='Query'),
}

model ListTableVersionsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  tableVersions?: [
    TableVersion
  ](name='TableVersions', description='table versions'),
}

model ListTableVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTableVersionsResponseBody(name='body'),
}

async function listTableVersions(request: ListTableVersionsRequest): ListTableVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTableVersions', 'GET', '/api/metastore/catalogs/databases/tables/versions/list', 'json', false, 'json', request);
}

model ListTablesRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Query'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Query'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken', position='Query'),
  pageSize?: int32(name='PageSize', description='PageSize', minimum=-1, maximum=1000000, position='Query'),
  tableNamePattern?: string(name='TableNamePattern', description='TableNamePattern', position='Query'),
  tableType?: string(name='TableType', description='TableType filter', position='Query'),
}

model ListTablesResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description=' RequestId'),
  success?: boolean(name='Success', description='Success'),
  tables?: [
    Table
  ](name='Tables', description='Tables'),
}

model ListTablesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTablesResponseBody(name='body'),
}

async function listTables(request: ListTablesRequest): ListTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTables', 'GET', '/api/metastore/databases/tables/list', 'json', false, 'json', request);
}

model ListUserRolesRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  nextPageToken?: string(name='NextPageToken', position='Query'),
  pageSize?: int32(name='PageSize', description='PageSize', position='Query'),
  principalArn?: string(name='PrincipalArn', position='Query'),
  roleNamePattern?: string(name='RoleNamePattern', description='role name pattern filter', position='Query'),
}

model ListUserRolesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nextPageToken?: string(name='NextPageToken', description='NextPageToken'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success'),
  userRoles?: [
    UserRole
  ](name='UserRoles', description='Data'),
}

model ListUserRolesResponse = {
  headers: map[string]string(name='headers'),
  body: ListUserRolesResponseBody(name='body'),
}

async function listUserRoles(request: ListUserRolesRequest): ListUserRolesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListUserRoles', 'GET', '/api/metastore/auth/roles/userroles', 'json', false, 'json', request);
}

model RefreshLockRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  lockId?: long(name='LockId', description='LockId', position='Query'),
}

model RefreshLockResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model RefreshLockResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshLockResponseBody(name='body'),
}

async function refreshLock(request: RefreshLockRequest): RefreshLockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RefreshLock', 'PUT', '/api/metastore/catalogs/databases/tables/locks', 'json', false, 'json', request);
}

model RenamePartitionRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  partitionInput?: PartitionInput(name='PartitionInput', position='Body'),
  partitionValues?: [ string ](name='PartitionValues', position='Body'),
  tableName?: string(name='TableName', description='TableName', position='Body'),
}

model RenamePartitionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model RenamePartitionResponse = {
  headers: map[string]string(name='headers'),
  body: RenamePartitionResponseBody(name='body'),
}

async function renamePartition(request: RenamePartitionRequest): RenamePartitionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RenamePartition', 'POST', '/api/metastore/catalogs/databases/tables/partitions/rename', 'json', false, 'json', request);
}

model RenameTableRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  isAsync?: boolean(name='IsAsync', description='IsAsync', position='Body'),
  tableInput?: TableInput(name='TableInput', position='Body'),
  tableName?: string(name='TableName', description='TableName', position='Body'),
}

model RenameTableResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  taskId?: string(name='TaskId', description='Async task Id'),
}

model RenameTableResponse = {
  headers: map[string]string(name='headers'),
  body: RenameTableResponseBody(name='body'),
}

async function renameTable(request: RenameTableRequest): RenameTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RenameTable', 'PUT', '/api/metastore/catalogs/databases/tables/rename', 'json', false, 'json', request);
}

model RevokePermissionsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  accesses: [ string ](name='Accesses', description='取消授权的accesses列表', position='Body'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  delegateAccesses?: [ string ](name='DelegateAccesses', description='取消授权的grantable accesses列表', position='Body'),
  metaResource: MetaResource(name='MetaResource', description='取消授权meta资源', position='Body'),
  principal: Principal(name='Principal', description='取消授权的用户/角色principal', position='Body'),
  type: string(name='Type', description='取消授权的类型，目前仅支持hive', position='Body'),
}

model RevokePermissionsResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Message Code'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model RevokePermissionsResponse = {
  headers: map[string]string(name='headers'),
  body: RevokePermissionsResponseBody(name='body'),
}

async function revokePermissions(request: RevokePermissionsRequest): RevokePermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RevokePermissions', 'POST', '/api/metastore/auth/permissions/revoke', 'json', false, 'json', request);
}

model RevokeRoleFromUsersRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  roleName?: string(name='RoleName', description='待revoke的角色', position='Body'),
  users?: [
Principal
](name='Users', description='待revoke的用户列表', position='Body'),
}

model RevokeRoleFromUsersResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model RevokeRoleFromUsersResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeRoleFromUsersResponseBody(name='body'),
}

async function revokeRoleFromUsers(request: RevokeRoleFromUsersRequest): RevokeRoleFromUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RevokeRoleFromUsers', 'PUT', '/api/metastore/auth/roles/revokeusers', 'json', false, 'json', request);
}

model RevokeRolesFromUserRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  roleNames: [ string ](name='RoleNames', description='待删除的角色列表', position='Body'),
  user: Principal(name='User', description='针对该用户进行revoke', position='Body'),
}

model RevokeRolesFromUserResponseBody = {
  code?: string(name='Code', description='code'),
  message?: string(name='Message', description='message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='success'),
}

model RevokeRolesFromUserResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeRolesFromUserResponseBody(name='body'),
}

async function revokeRolesFromUser(request: RevokeRolesFromUserRequest): RevokeRolesFromUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RevokeRolesFromUser', 'POST', '/api/metastore/auth/roles/revokeroles', 'json', false, 'json', request);
}

model RunMigrationWorkflowRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
}

model RunMigrationWorkflowResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RunMigrationWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: RunMigrationWorkflowResponseBody(name='body'),
}

async function runMigrationWorkflow(request: RunMigrationWorkflowRequest): RunMigrationWorkflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RunMigrationWorkflow', 'POST', '/webapi/migration/workflow/run', 'json', false, 'json', request);
}

model SearchRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='catalogid', position='Body'),
  pageNumber?: long(name='PageNumber', description='当前查询的页号', position='Body'),
  pageSize?: long(name='PageSize', description='当前查询的页大小', position='Body'),
  searchText?: string(name='SearchText', description='搜索问题', position='Body'),
  searchType?: string(name='SearchType', position='Body'),
  sortCriteria?: [
    SortCriterion
  ](name='SortCriteria', description='排序结构', position='Body'),
}

model SearchResponseBody = {
  code?: string(name='Code', description='响应代码'),
  databaseResult?: {
    databases?: [ 
      {
        database?: Database(name='Database', description='返回的Database'),
        highLightList?: [
          HighLight
        ](name='HighLightList', description='返回高亮文本'),
      }
    ](name='Databases', description='返回的DatabaseList'),
    totalCount?: long(name='TotalCount', description='满足匹配条件的总的Database个数'),
  }(name='DatabaseResult', description='返回的db结果'),
  message?: string(name='Message', description='响应消息'),
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='是否成功'),
  tableResult?: {
    tables?: [ 
      {
        highLightList?: [
          HighLight
        ](name='HighLightList', description='返回的高亮文本'),
        table?: Table(name='Table', description='返回的Table'),
      }
    ](name='Tables', description='返回的TableList'),
    totalCount?: long(name='TotalCount', description='满足匹配条件的总的Table个数'),
  }(name='TableResult', description='返回的table result'),
}

model SearchResponse = {
  headers: map[string]string(name='headers'),
  body: SearchResponseBody(name='body'),
}

async function search(request: SearchRequest): SearchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'Search', 'POST', '/api/metastore/catalogs/search', 'json', false, 'json', request);
}

model SearchAcrossCatalogRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogIds?: [ string ](name='CatalogIds', description='CatalogId数组，为空则搜索所有Catalog', position='Body'),
  pageNumber?: long(name='PageNumber', description='当前查询的页号', position='Body'),
  pageSize?: long(name='PageSize', description='当前查询的页大小', position='Body'),
  searchText?: string(name='SearchText', description='搜索问题', position='Body'),
  searchTypes?: [ string ](name='SearchTypes', description='SearchTypes数组，可选值为ALL/CATALOG/DATABASE/TABLE', position='Body'),
  sortCriteria?: [
    SortCriterion
  ](name='SortCriteria', description='排序结构', position='Body'),
}

model SearchAcrossCatalogResponseBody = {
  catalogResult?: {
    catalogs?: [ 
      {
        catalog?: Catalog(name='Catalog'),
        highLightList?: [
          HighLight
        ](name='HighLightList'),
      }
    ](name='Catalogs'),
    totalCount?: long(name='TotalCount', description='满足匹配条件的总的Catalog个数'),
  }(name='CatalogResult', description='返回的Catalog result'),
  code?: string(name='Code', description='响应代码'),
  databaseResult?: {
    databases?: [ 
      {
        database?: Database(name='Database', description='返回的Database'),
        highLightList?: [
          HighLight
        ](name='HighLightList', description='返回高亮文本'),
      }
    ](name='Databases', description='返回的DatabaseList'),
    totalCount?: long(name='TotalCount', description='满足匹配条件的总的Database个数'),
  }(name='DatabaseResult', description='返回的db结果'),
  message?: string(name='Message', description='响应消息'),
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='是否成功'),
  tableResult?: {
    tables?: [ 
      {
        highLightList?: [
          HighLight
        ](name='HighLightList', description='返回的高亮文本'),
        table?: Table(name='Table', description='返回的Table'),
      }
    ](name='Tables', description='返回的TableList'),
    totalCount?: long(name='TotalCount', description='满足匹配条件的总的Table个数'),
  }(name='TableResult', description='返回的table result'),
}

model SearchAcrossCatalogResponse = {
  headers: map[string]string(name='headers'),
  body: SearchAcrossCatalogResponseBody(name='body'),
}

async function searchAcrossCatalog(request: SearchAcrossCatalogRequest): SearchAcrossCatalogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'SearchAcrossCatalog', 'POST', '/api/metastore/catalogs/search/search-across-catalog', 'json', false, 'json', request);
}

model StopMigrationWorkflowRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
}

model StopMigrationWorkflowResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StopMigrationWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: StopMigrationWorkflowResponseBody(name='body'),
}

async function stopMigrationWorkflow(request: StopMigrationWorkflowRequest): StopMigrationWorkflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StopMigrationWorkflow', 'PUT', '/webapi/migration/workflow/stop', 'json', false, 'json', request);
}

model SubmitQueryRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='catalogId', position='Body'),
  sql?: string(name='sql', position='Body'),
  workspaceId?: string(name='workspaceId', position='Body'),
}

model SubmitQueryResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubmitQueryResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitQueryResponseBody(name='body'),
}

async function submitQuery(request: SubmitQueryRequest): SubmitQueryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'SubmitQuery', 'POST', '/webapi/query/submitQueryRequestBody', 'json', false, 'json', request);
}

model UnLockRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  lockId?: long(name='LockId', description='LockId', position='Query'),
}

model UnLockResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model UnLockResponse = {
  headers: map[string]string(name='headers'),
  body: UnLockResponseBody(name='body'),
}

async function unLock(request: UnLockRequest): UnLockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UnLock', 'DELETE', '/api/metastore/catalogs/databases/tables/locks', 'json', false, 'json', request);
}

model UpdateCatalogRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogInput: CatalogInput(name='CatalogInput', position='Body'),
}

model UpdateCatalogResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Response Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Request is success or not'),
}

model UpdateCatalogResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCatalogResponseBody(name='body'),
}

async function updateCatalog(request: UpdateCatalogRequest): UpdateCatalogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateCatalog', 'PUT', '/api/metastore/catalogs', 'json', false, 'json', request);
}

model UpdateCatalogSettingsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  catalogSettings?: CatalogSettings(name='CatalogSettings', position='Body'),
}

model UpdateCatalogSettingsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model UpdateCatalogSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCatalogSettingsResponseBody(name='body'),
}

async function updateCatalogSettings(request: UpdateCatalogSettingsRequest): UpdateCatalogSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateCatalogSettings', 'POST', '/api/metastore/catalogs/settings', 'json', false, 'json', request);
}

model UpdateDatabaseRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseInput?: DatabaseInput(name='DatabaseInput', position='Body'),
  name?: string(name='Name', description='Name', position='Body'),
}

model UpdateDatabaseResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Response Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Request is success or not'),
}

model UpdateDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDatabaseResponseBody(name='body'),
}

async function updateDatabase(request: UpdateDatabaseRequest): UpdateDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateDatabase', 'PUT', '/api/metastore/catalogs/databases', 'json', false, 'json', request);
}

model UpdateFunctionRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', position='Body'),
  functionInput?: FunctionInput(name='FunctionInput', position='Body'),
  functionName?: string(name='FunctionName', position='Body'),
}

model UpdateFunctionResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model UpdateFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFunctionResponseBody(name='body'),
}

async function updateFunction(request: UpdateFunctionRequest): UpdateFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateFunction', 'PUT', '/api/metastore/catalogs/databases/functions', 'json', false, 'json', request);
}

model UpdatePartitionColumnStatisticsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  updateTablePartitionColumnStatisticsRequest?: UpdateTablePartitionColumnStatisticsRequest(name='UpdateTablePartitionColumnStatisticsRequest', position='Body'),
}

model UpdatePartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model UpdatePartitionColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePartitionColumnStatisticsResponseBody(name='body'),
}

async function updatePartitionColumnStatistics(request: UpdatePartitionColumnStatisticsRequest): UpdatePartitionColumnStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdatePartitionColumnStatistics', 'PUT', '/api/metastore/catalogs/databases/tables/partitions/columnstatistics', 'json', false, 'json', request);
}

model UpdatePermissionsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  accesses: [ string ](name='Accesses', description='授权的accesses列表', position='Body'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  delegateAccesses: [ string ](name='DelegateAccesses', description='授权的grantable accesses列表', position='Body'),
  metaResource: MetaResource(name='MetaResource', description='授权meta资源', position='Body'),
  principal: Principal(name='Principal', description='授权的用户/角色principal', position='Body'),
  type: string(name='Type', description='授权的类型，目前仅支持hive', position='Body'),
}

model UpdatePermissionsResponseBody = {
  code?: string(name='Code', description='Response Code'),
  message?: string(name='Message', description='Message Code'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model UpdatePermissionsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePermissionsResponseBody(name='body'),
}

async function updatePermissions(request: UpdatePermissionsRequest): UpdatePermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdatePermissions', 'PUT', '/api/metastore/auth/permissions/', 'json', false, 'json', request);
}

model UpdateRoleRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  roleInput?: RoleInput(name='RoleInput', position='Body'),
  roleName?: string(name='RoleName', description='RoleName', position='Body'),
}

model UpdateRoleResponseBody = {
  code?: string(name='Code', description='code'),
  message?: string(name='Message', description='message'),
  requestId?: string(name='RequestId', description='requestId'),
  success?: boolean(name='Success', description='success'),
}

model UpdateRoleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRoleResponseBody(name='body'),
}

async function updateRole(request: UpdateRoleRequest): UpdateRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateRole', 'PUT', '/api/metastore/auth/roles', 'json', false, 'json', request);
}

model UpdateRoleUsersRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  roleName?: string(name='RoleName', description='Role名称', position='Body'),
  users?: [
Principal
](name='Users', position='Body'),
}

model UpdateRoleUsersResponseBody = {
  code?: string(name='Code', description='code'),
  message?: string(name='Message', description='message'),
  requestId?: string(name='RequestId', description='requestId'),
  success?: boolean(name='Success', description='success'),
}

model UpdateRoleUsersResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRoleUsersResponseBody(name='body'),
}

async function updateRoleUsers(request: UpdateRoleUsersRequest): UpdateRoleUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateRoleUsers', 'POST', '/api/metastore/auth/updateroleusers', 'json', false, 'json', request);
}

model UpdateTableRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  allowPartitionKeyChange?: boolean(name='AllowPartitionKeyChange', description='AllowPartitionKeyChange', position='Body'),
  catalogId?: string(name='CatalogId', description='CatalogId', position='Body'),
  databaseName?: string(name='DatabaseName', description='DatabaseName', position='Body'),
  isAsync?: boolean(name='IsAsync', description='IsAsync', position='Body'),
  skipArchive?: boolean(name='SkipArchive', description='SkipArchive', position='Body'),
  tableInput?: TableInput(name='TableInput', position='Body'),
  tableName?: string(name='TableName', description='TableName', position='Body'),
}

model UpdateTableResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
  taskId?: string(name='TaskId', description='Async task Id'),
}

model UpdateTableResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTableResponseBody(name='body'),
}

async function updateTable(request: UpdateTableRequest): UpdateTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateTable', 'PUT', '/api/metastore/catalogs/databases/tables', 'json', false, 'json', request);
}

model UpdateTableColumnStatisticsRequest {
  regionId?: string(name='RegionId', description='RegionId', position='Host'),
  updateTablePartitionColumnStatisticsRequest?: UpdateTablePartitionColumnStatisticsRequest(name='UpdateTablePartitionColumnStatisticsRequest', position='Body'),
}

model UpdateTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  requestId?: string(name='RequestId', description='RequestId'),
  success?: boolean(name='Success', description='Success'),
}

model UpdateTableColumnStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTableColumnStatisticsResponseBody(name='body'),
}

async function updateTableColumnStatistics(request: UpdateTableColumnStatisticsRequest): UpdateTableColumnStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateTableColumnStatistics', 'PUT', '/api/metastore/catalogs/databases/tables/columnstatistics', 'json', false, 'json', request);
}

model TableExtendedPrivilegesRolePrivilegesValue = {
  createTime?: int32(name='CreateTime', description='CreateTime'),
  grantOption?: boolean(name='GrantOption', description='GrantOption'),
  grantor?: string(name='Grantor', description='Grantor'),
  grantorType?: string(name='GrantorType', description='GrantorType'),
  privilege?: string(name='Privilege', description='Privilege'),
}

model TableExtendedPrivilegesUserPrivilegesValue = {
  createTime?: int32(name='CreateTime', description='CreateTime'),
  grantOption?: boolean(name='GrantOption', description='GrantOption'),
  grantor?: string(name='Grantor', description='Grantor'),
  grantorType?: string(name='GrantorType', description='GrantorType'),
  privilege?: string(name='Privilege', description='Privilege'),
}

model TableExtendedPrivilegesGroupPrivilegesValue = {
  createTime?: int32(name='CreateTime', description='CreateTime'),
  grantOption?: boolean(name='GrantOption', description='GrantOption'),
  grantor?: string(name='Grantor', description='Grantor'),
  grantorType?: string(name='GrantorType', description='GrantorType'),
  privilege?: string(name='Privilege', description='Privilege'),
}

