/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'DataLake';
  @version = '2020-07-10';
  @endpointRule = 'regional';
  @endpointMap = {
    'ap-northeast-1' = 'datalake-daily.aliyuncs.com',
    'ap-northeast-2-pop' = 'datalake-daily.aliyuncs.com',
    'ap-south-1' = 'datalake-daily.aliyuncs.com',
    'ap-southeast-1' = 'datalake-daily.aliyuncs.com',
    'ap-southeast-2' = 'datalake-daily.aliyuncs.com',
    'ap-southeast-3' = 'datalake-daily.aliyuncs.com',
    'ap-southeast-5' = 'datalake-daily.aliyuncs.com',
    'cn-beijing' = 'dlf.cn-beijing.aliyuncs.com',
    'cn-beijing-finance-1' = 'datalake-daily.aliyuncs.com',
    'cn-beijing-finance-pop' = 'datalake-daily.aliyuncs.com',
    'cn-beijing-gov-1' = 'datalake-daily.aliyuncs.com',
    'cn-beijing-nu16-b01' = 'datalake-daily.aliyuncs.com',
    'cn-chengdu' = 'datalake-daily.aliyuncs.com',
    'cn-edge-1' = 'datalake-daily.aliyuncs.com',
    'cn-fujian' = 'datalake-daily.aliyuncs.com',
    'cn-haidian-cm12-c01' = 'datalake-daily.aliyuncs.com',
    'cn-hangzhou' = 'dlf.cn-hangzhou.aliyuncs.com',
    'cn-hangzhou-bj-b01' = 'datalake-daily.aliyuncs.com',
    'cn-hangzhou-finance' = 'datalake-daily.aliyuncs.com',
    'cn-hangzhou-internal-prod-1' = 'datalake-daily.aliyuncs.com',
    'cn-hangzhou-internal-test-1' = 'datalake-daily.aliyuncs.com',
    'cn-hangzhou-internal-test-2' = 'datalake-daily.aliyuncs.com',
    'cn-hangzhou-internal-test-3' = 'datalake-daily.aliyuncs.com',
    'cn-hangzhou-test-306' = 'datalake-daily.aliyuncs.com',
    'cn-hongkong' = 'datalake-daily.aliyuncs.com',
    'cn-hongkong-finance-pop' = 'datalake-daily.aliyuncs.com',
    'cn-huhehaote' = 'datalake-daily.aliyuncs.com',
    'cn-huhehaote-nebula-1' = 'datalake-daily.aliyuncs.com',
    'cn-north-2-gov-1' = 'datalake-daily.aliyuncs.com',
    'cn-qingdao' = 'datalake-daily.aliyuncs.com',
    'cn-qingdao-nebula' = 'datalake-daily.aliyuncs.com',
    'cn-shanghai' = 'dlf.cn-shanghai.aliyuncs.com',
    'cn-shanghai-et15-b01' = 'datalake-daily.aliyuncs.com',
    'cn-shanghai-et2-b01' = 'datalake-daily.aliyuncs.com',
    'cn-shanghai-finance-1' = 'datalake-daily.aliyuncs.com',
    'cn-shanghai-inner' = 'datalake-daily.aliyuncs.com',
    'cn-shanghai-internal-test-1' = 'datalake-daily.aliyuncs.com',
    'cn-shenzhen' = 'dlf.cn-shenzhen.aliyuncs.com',
    'cn-shenzhen-finance-1' = 'datalake-daily.aliyuncs.com',
    'cn-shenzhen-inner' = 'datalake-daily.aliyuncs.com',
    'cn-shenzhen-st4-d01' = 'datalake-daily.aliyuncs.com',
    'cn-shenzhen-su18-b01' = 'datalake-daily.aliyuncs.com',
    'cn-wuhan' = 'datalake-daily.aliyuncs.com',
    'cn-wulanchabu' = 'datalake-daily.aliyuncs.com',
    'cn-yushanfang' = 'datalake-daily.aliyuncs.com',
    'cn-zhangbei' = 'datalake-daily.aliyuncs.com',
    'cn-zhangbei-na61-b01' = 'datalake-daily.aliyuncs.com',
    'cn-zhangjiakou' = 'datalake-daily.aliyuncs.com',
    'cn-zhangjiakou-na62-a01' = 'datalake-daily.aliyuncs.com',
    'cn-zhengzhou-nebula-1' = 'datalake-daily.aliyuncs.com',
    'eu-central-1' = 'datalake-daily.aliyuncs.com',
    'eu-west-1' = 'datalake-daily.aliyuncs.com',
    'eu-west-1-oxs' = 'datalake-daily.aliyuncs.com',
    'me-east-1' = 'datalake-daily.aliyuncs.com',
    'rus-west-1-pop' = 'datalake-daily.aliyuncs.com',
    'us-east-1' = 'datalake-daily.aliyuncs.com',
    'us-west-1' = 'datalake-daily.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model AccessRequest {
  catalogId?: string(name='CatalogId'),
  principal?: Principal(name='Principal'),
  privilegeResources?: [
PrivilegeResource
](name='PrivilegeResources'),
}

model Catalog {
  catalogId?: string(name='CatalogId'),
  catalogType?: string(name='CatalogType'),
  createTime?: long(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  defaultCatalog?: boolean(name='DefaultCatalog'),
  description?: string(name='Description'),
  jdbcEnabled?: boolean(name='JdbcEnabled'),
  locationUri?: string(name='LocationUri'),
  owner?: string(name='Owner'),
  status?: string(name='Status'),
  storageAccessConfig?: string(name='StorageAccessConfig'),
  thriftEnabled?: boolean(name='ThriftEnabled'),
  updateTime?: long(name='UpdateTime'),
}

model CatalogConnection {
  jdbcPassword?: string(name='JdbcPassword'),
  jdbcUri?: string(name='JdbcUri'),
  jdbcUserName?: string(name='JdbcUserName'),
  thriftUri?: string(name='ThriftUri'),
  vpcConnectionId?: string(name='VpcConnectionId', example='CONN-607A0053D874****'),
}

model CatalogInput {
  catalogId: string(name='CatalogId', description='This parameter is required.'),
  catalogType?: string(name='CatalogType'),
  description?: string(name='Description'),
  jdbcEnabled?: boolean(name='JdbcEnabled'),
  locationUri?: string(name='LocationUri'),
  owner?: string(name='Owner'),
  storageAccessConfig?: string(name='StorageAccessConfig'),
  thriftEnabled?: boolean(name='ThriftEnabled'),
}

model CatalogResource {
  catalogId?: string(name='CatalogId'),
}

model CatalogSettings {
  config?: map[string]string(name='Config'),
}

model CatalogVpcConnection {
  catalogId?: string(name='CatalogId', example='catalog_test'),
  connectionName?: string(name='ConnectionName'),
  connectionStatus?: string(name='ConnectionStatus', example='CONNECTED'),
  creator?: long(name='Creator', example='120215474170****'),
  errorMessage?: string(name='ErrorMessage'),
  gmtCreate?: string(name='GmtCreate', example='2023-07-12 15:26:12'),
  gmtModified?: string(name='GmtModified', example='2023-07-17 17:51:04'),
  jdbcUri?: string(name='JdbcUri'),
  modifier?: long(name='Modifier', example='120215474170****'),
  owner?: long(name='Owner', example='120215474170****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  securityGroupIds?: [ string ](name='SecurityGroupIds'),
  thriftUri?: string(name='ThriftUri'),
  vpcConnectionId?: string(name='VpcConnectionId', example='CONN-607A0053D874****'),
  vpcId?: string(name='VpcId', example='vpc-2ze0c41hvmesel7pu****'),
  zones?: [ 
    {
      ip?: string(name='IP', example='192.168.XX.XX'),
      vSwitchId?: string(name='VSwitchId', example='vsw-hp3uf6045ljdhd5zr****'),
      zoneId?: string(name='ZoneId', example='cn-hangzhou-g'),
    }
  ](name='Zones'),
}

model CatalogVpcConnectionInput {
  connectionName?: string(name='ConnectionName'),
  securityGroupIds?: [ string ](name='SecurityGroupIds'),
  vpcId?: string(name='VpcId', example='vpc-hp356stwkxg3fn2xe****'),
  zones?: [ 
    {
      ip?: string(name='IP', example='192.168.XX.XX'),
      vSwitchId?: string(name='VSwitchId', example='vsw-hp3uf6045ljdhd5zr****'),
      zoneId?: string(name='ZoneId', example='cn-hangzhou-g'),
    }
  ](name='Zones'),
}

model ColumnResource {
  columnNames?: [ string ](name='ColumnNames'),
  databaseName?: string(name='DatabaseName', example='default'),
  tableName?: string(name='TableName', example='test'),
}

model ColumnStatistics {
  columnStatisticsDesc?: ColumnStatisticsDesc(name='ColumnStatisticsDesc'),
  columnStatisticsObjList?: [
    ColumnStatisticsObj
  ](name='ColumnStatisticsObjList'),
  engine?: string(name='Engine'),
  isStatsCompliant?: boolean(name='IsStatsCompliant'),
}

model ColumnStatisticsDesc {
  lastAnalyzedTime?: long(name='LastAnalyzedTime'),
  partitionName?: string(name='PartitionName'),
}

model ColumnStatisticsObj {
  columnName?: string(name='ColumnName'),
  columnStatisticsData?: {
    statisticsData?: string(name='StatisticsData'),
    statisticsType?: string(name='StatisticsType'),
  }(name='ColumnStatisticsData'),
  columnType?: string(name='ColumnType'),
}

model Database {
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  description?: string(name='Description'),
  locationUri?: string(name='LocationUri', example='oss://examplebuket/exampledb'),
  name?: string(name='Name'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  updateTime?: int32(name='UpdateTime'),
}

model DatabaseInput {
  createTime?: int32(name='CreateTime'),
  description?: string(name='Description'),
  locationUri?: string(name='LocationUri', example='oss://examplebuket/exampledb'),
  name?: string(name='Name'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
}

model DatabaseProfile {
  createTime?: string(name='CreateTime'),
  fileCnt?: long(name='FileCnt'),
  fileSize?: long(name='FileSize'),
  latestDate?: string(name='LatestDate'),
  location?: string(name='Location'),
  name?: string(name='Name'),
  objectCnt?: long(name='ObjectCnt'),
  objectSize?: long(name='ObjectSize'),
}

model DatabaseResource {
  databaseName?: string(name='DatabaseName', example='default'),
  databaseWildcard?: string(name='DatabaseWildcard'),
}

model DbStorageRank {
  dbName?: string(name='DbName'),
  quantity?: long(name='Quantity'),
}

model ErrorDetail {
  code?: string(name='Code'),
  message?: string(name='Message'),
}

model FieldSchema {
  comment?: string(name='Comment'),
  name?: string(name='Name'),
  parameters?: map[string]string(name='Parameters'),
  type?: string(name='Type'),
}

model FileCnt {
  large?: long(name='Large'),
  middle?: long(name='Middle'),
  small?: long(name='Small'),
  tiny?: long(name='Tiny'),
}

model Function {
  catalogId?: string(name='CatalogId'),
  className?: string(name='ClassName'),
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy', example='CreatedBy'),
  databaseName?: string(name='DatabaseName'),
  functionName?: string(name='FunctionName'),
  functionType?: string(name='FunctionType'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  resourceUri?: [
    ResourceUri
  ](name='ResourceUri'),
  updateTime?: int32(name='UpdateTime'),
}

model FunctionInput {
  className?: string(name='ClassName'),
  createTime?: int32(name='CreateTime'),
  functionName?: string(name='FunctionName'),
  functionType?: string(name='FunctionType'),
  ownerName?: string(name='OwnerName'),
  ownerType?: string(name='OwnerType'),
  resourceUri?: [
    ResourceUri
  ](name='ResourceUri'),
}

model FunctionResource {
  databaseName?: string(name='DatabaseName', example='default'),
  functionName?: string(name='FunctionName', example='default'),
}

model GrantRevokeEntry {
  accesses?: [ string ](name='Accesses'),
  delegateAccesses?: [ string ](name='DelegateAccesses'),
  id?: string(name='Id'),
  metaResource?: MetaResource(name='MetaResource'),
  principal?: Principal(name='Principal'),
}

model GrantRevokeFailureEntry {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  grantRevokeEntry?: GrantRevokeEntry(name='GrantRevokeEntry'),
}

model HighLight {
  key?: string(name='Key', example='name'),
  value?: string(name='Value', example='<em>tab</em>2'),
}

model IndicatorStatistic {
  data?: long(name='Data'),
  date?: string(name='Date'),
}

model LifecycleResource {
  bizId?: string(name='BizId'),
  catalogId?: string(name='CatalogId'),
  database?: {
    createTime?: long(name='CreateTime'),
    description?: string(name='Description'),
    locationUri?: string(name='LocationUri'),
    name?: string(name='Name'),
    updateTime?: long(name='UpdateTime'),
  }(name='Database'),
  databaseName?: string(name='DatabaseName'),
  databaseProfile?: DatabaseProfile(name='DatabaseProfile'),
  gmtCreate?: string(name='GmtCreate'),
  lifecycleRuleBizId?: string(name='LifecycleRuleBizId'),
  owner?: long(name='Owner'),
  table?: {
    createTime?: long(name='CreateTime'),
    databaseName?: string(name='DatabaseName'),
    parameters?: map[string]string(name='Parameters'),
    sd?: {
      bucketCols?: [ string ](name='BucketCols'),
      inputFormat?: string(name='InputFormat'),
      location?: string(name='Location'),
      outputFormat?: string(name='OutputFormat'),
      parameters?: map[string]string(name='Parameters'),
      serDeInfo?: {
        name?: string(name='Name'),
        parameters?: map[string]string(name='Parameters'),
        serializationLib?: string(name='SerializationLib'),
      }(name='SerDeInfo'),
    }(name='Sd'),
    tableName?: string(name='TableName'),
    tableType?: string(name='TableType'),
  }(name='Table'),
  tableName?: string(name='TableName'),
  tableProfile?: TableProfile(name='TableProfile'),
}

model LifecycleRule {
  archiveDays?: int32(name='ArchiveDays'),
  bindCount?: int32(name='BindCount'),
  bizId?: string(name='BizId'),
  catalogId?: string(name='CatalogId'),
  coldArchiveDays?: int32(name='ColdArchiveDays'),
  config?: string(name='Config'),
  description?: string(name='Description'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  iaDays?: int32(name='IaDays'),
  name?: string(name='Name'),
  resourceType?: string(name='ResourceType'),
  ruleType?: string(name='RuleType'),
  scheduleStatus?: string(name='ScheduleStatus'),
  workflow?: Workflow(name='Workflow'),
  workflowId?: string(name='WorkflowId'),
  workflowInstance?: WorkflowInstance(name='WorkflowInstance'),
}

model LifecycleTask {
  bizId?: string(name='BizId'),
  lifecycleRule?: LifecycleRule(name='LifecycleRule'),
  name?: string(name='Name'),
  workflowInstance?: WorkflowInstance(name='WorkflowInstance'),
}

model LocationStorageRankDTO {
  fileCnt?: long(name='FileCnt'),
  location?: string(name='Location'),
  storage?: long(name='Storage'),
}

model LockObj {
  catalogId?: string(name='CatalogId'),
  databaseName?: string(name='DatabaseName'),
  partitionName?: string(name='PartitionName'),
  tableName?: string(name='TableName'),
}

model LockStatus {
  lockId?: long(name='LockId'),
  lockState?: string(name='LockState'),
}

model LogInfo {
  bizTime?: string(name='BizTime'),
  gmtCreate?: string(name='GmtCreate'),
  instanceId?: string(name='InstanceId'),
  logContent?: string(name='LogContent'),
  logId?: string(name='LogId'),
  logSummary?: string(name='LogSummary'),
  logType?: string(name='LogType'),
}

model MetaResource {
  catalogResource?: CatalogResource(name='CatalogResource'),
  columnResource?: ColumnResource(name='ColumnResource'),
  databaseResource?: DatabaseResource(name='DatabaseResource'),
  functionResource?: FunctionResource(name='FunctionResource'),
  resourceType?: string(name='ResourceType', example='TABLE'),
  tableResource?: TableResource(name='TableResource'),
}

model Order {
  col?: string(name='Col'),
  order?: int32(name='Order'),
}

model Partition {
  createTime?: int32(name='CreateTime'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName'),
  values?: [ string ](name='Values'),
}

model PartitionError {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  partitionValues?: [ string ](name='PartitionValues'),
}

model PartitionInput {
  createTime?: int32(name='CreateTime'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  parameters?: map[string]string(name='Parameters'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName'),
  values?: [ string ](name='Values'),
}

model PartitionProfile {
  accessNum?: long(name='AccessNum', example='0'),
  accessNumMonthly?: long(name='AccessNumMonthly', example='0'),
  accessNumWeekly?: long(name='AccessNumWeekly', example='0'),
  archiveStatus?: string(name='ArchiveStatus', example='STANDARD'),
  createTime?: string(name='CreateTime', example='2023-08-16 18:02:22'),
  dataSourceType?: string(name='DataSourceType', example='OSS_HDFS'),
  databaseName?: string(name='DatabaseName', example='test_db'),
  fileCnt?: long(name='FileCnt', example='1'),
  fileSize?: long(name='FileSize', example='13'),
  lastAccessNumTime?: string(name='LastAccessNumTime'),
  lastAccessTime?: string(name='LastAccessTime', example='2023-08-22 12:14:42'),
  lastModifyTime?: string(name='LastModifyTime', example='2023-08-16 18:02:25'),
  location?: string(name='Location', example='oss://mybucket.cn-hangzhou.oss-dls.aliyuncs.com/test_tb/test_tbl/year=2023/month=1'),
  objectAccessNum?: long(name='ObjectAccessNum', example='0'),
  objectAccessNumMonthly?: long(name='ObjectAccessNumMonthly', example='4'),
  objectAccessNumWeekly?: long(name='ObjectAccessNumWeekly', example='4'),
  objectCnt?: long(name='ObjectCnt', example='1'),
  objectSize?: long(name='ObjectSize', example='13'),
  partitionName?: string(name='PartitionName', example='year=2023/month=1'),
  tableName?: string(name='TableName', example='test_tbl'),
}

model PartitionSpec {
  sharedSDPartitions?: [
    Partition
  ](name='SharedSDPartitions'),
  sharedStorageDescriptor?: {
    cols?: [
      FieldSchema
    ](name='Cols'),
    location?: string(name='Location', example='相对路径'),
  }(name='SharedStorageDescriptor'),
}

model Principal {
  principalArn?: string(name='PrincipalArn', example='acs:ram::[AliyunAccountId]:user/username_abc'),
}

model PrincipalPrivilegeSet {
  groupPrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='GroupPrivileges'),
  rolePrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='RolePrivileges'),
  userPrivileges?: map[string][
    PrivilegeGrantInfo
  ](name='UserPrivileges'),
}

model PrincipalResourcePermissions {
  accesses?: [ string ](name='Accesses'),
  delegateAccesses?: [ string ](name='DelegateAccesses'),
  metaResource: MetaResource(name='MetaResource', description='This parameter is required.'),
  principal: Principal(name='Principal', description='This parameter is required.'),
}

model PrivilegeGrantInfo {
  createTime?: int32(name='CreateTime'),
  grantOption?: boolean(name='GrantOption'),
  grantor?: string(name='Grantor'),
  grantorType?: string(name='GrantorType'),
  privilege?: string(name='Privilege'),
}

model PrivilegeResource {
  access?: string(name='Access'),
  metaResource?: MetaResource(name='MetaResource'),
}

model ResourceUri {
  resourceType?: string(name='ResourceType'),
  uri?: string(name='Uri'),
}

model Role {
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  displayName?: string(name='DisplayName', example='显示名称，允许中文'),
  isPredefined?: int32(name='IsPredefined'),
  name?: string(name='Name'),
  principalArn?: string(name='PrincipalArn'),
  updateTime?: long(name='UpdateTime'),
  users?: [
Principal
](name='Users'),
}

model RoleInput {
  description?: string(name='Description'),
  displayName?: string(name='DisplayName', example='显示名称，允许中文'),
  name?: string(name='Name'),
}

model SerDeInfo {
  name?: string(name='Name'),
  parameters?: map[string]string(name='Parameters'),
  serializationLib?: string(name='SerializationLib'),
}

model SingleIndicatorDTO {
  dayIncrement?: long(name='DayIncrement'),
  dayOnDay?: double(name='DayOnDay'),
  monthIncrement?: long(name='MonthIncrement'),
  monthOnMonth?: double(name='MonthOnMonth'),
  total?: long(name='Total'),
}

model SkewedInfo {
  skewedColNames?: [ string ](name='SkewedColNames'),
  skewedColValueLocationMaps?: map[string]string(name='SkewedColValueLocationMaps'),
  skewedColValues?: [[ string ]  ](name='SkewedColValues'),
}

model SmallFileCntRank {
  dbName?: string(name='DbName'),
  location?: string(name='Location'),
  quantity?: long(name='Quantity'),
  tableName?: string(name='TableName'),
}

model SortCriterion {
  fieldName?: string(name='FieldName', example='name'),
  sort?: string(name='Sort', example='asc/desc'),
}

model StorageCollectTaskOperationResult {
  dlfCreated?: boolean(name='DlfCreated'),
  errCode?: string(name='ErrCode'),
  errMessage?: string(name='ErrMessage'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
}

model StorageDescriptor {
  bucketCols?: [ string ](name='BucketCols'),
  cols?: [
    FieldSchema
  ](name='Cols'),
  compressed?: boolean(name='Compressed'),
  inputFormat?: string(name='InputFormat'),
  location?: string(name='Location'),
  numBuckets?: int32(name='NumBuckets'),
  outputFormat?: string(name='OutputFormat'),
  parameters?: map[string]string(name='Parameters'),
  serDeInfo?: SerDeInfo(name='SerDeInfo'),
  skewedInfo?: SkewedInfo(name='SkewedInfo'),
  sortCols?: [
    Order
  ](name='SortCols'),
  storedAsSubDirectories?: boolean(name='StoredAsSubDirectories'),
}

model StorageFormat {
  avro?: long(name='Avro'),
  csv?: long(name='Csv'),
  delta?: long(name='Delta'),
  hudi?: long(name='Hudi'),
  iceberg?: long(name='Iceberg'),
  json?: long(name='Json'),
  orc?: long(name='Orc'),
  parquet?: long(name='Parquet'),
  uncategorized?: long(name='Uncategorized'),
}

model StorageLayer {
  archive?: long(name='Archive'),
  coldArchive?: long(name='ColdArchive'),
  infrequent?: long(name='Infrequent'),
  standard?: long(name='Standard'),
  unknown?: long(name='Unknown'),
}

model StorageRankDTO {
  dbStorageRank?: [
    DbStorageRank
  ](name='dbStorageRank'),
  smallFileCntRank?: [
    SmallFileCntRank
  ](name='smallFileCntRank'),
  tableStorageRank?: [
    TableStorageRank
  ](name='tableStorageRank'),
}

model StorageSummary {
  databaseNum?: int32(name='DatabaseNum'),
  partitionNum?: int32(name='PartitionNum'),
  tableNum?: int32(name='TableNum'),
}

model StrogeCollectTask {
  destinationBucketName?: string(name='DestinationBucketName'),
  destinationPrefix?: string(name='DestinationPrefix'),
  dlfCreated?: boolean(name='DlfCreated'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  id?: string(name='Id'),
  inventoryId?: string(name='InventoryId'),
  location?: string(name='Location'),
  status?: string(name='Status'),
  taskType?: string(name='TaskType'),
}

model Table {
  cascade?: boolean(name='Cascade'),
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  owner?: string(name='Owner'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  retention?: int32(name='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled'),
  sd?: StorageDescriptor(name='Sd'),
  tableId?: string(name='TableId', example='59c6c8fefeaa46d8b599c1f790c59a19'),
  tableName?: string(name='TableName'),
  tableType?: string(name='TableType'),
  tableVersion?: TableVersion(name='TableVersion'),
  temporary?: boolean(name='Temporary'),
  updateTime?: int32(name='UpdateTime'),
  viewExpandedText?: string(name='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText'),
}

model TableError {
  errorDetail?: ErrorDetail(name='ErrorDetail'),
  tableName?: string(name='TableName'),
}

model TableExtended {
  cascade?: boolean(name='Cascade'),
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  owner?: string(name='Owner'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: {
    rolePrivileges?: map[string][ TableExtendedPrivilegesRolePrivilegesValue     ](name='RolePrivileges'),
    userPrivileges?: map[string][ TableExtendedPrivilegesUserPrivilegesValue     ](name='UserPrivileges'),
    groupPrivileges?: map[string][ TableExtendedPrivilegesGroupPrivilegesValue     ](name='groupPrivileges'),
  }(name='Privileges'),
  retention?: int32(name='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled'),
  sd?: {
    bucketCols?: [ string ](name='BucketCols'),
    cols?: [
      FieldSchema
    ](name='Cols'),
    compressed?: boolean(name='Compressed'),
    inputFormat?: string(name='InputFormat'),
    location?: string(name='Location'),
    numBuckets?: int32(name='NumBuckets'),
    outputFormat?: string(name='OutputFormat'),
    parameters?: map[string]string(name='Parameters'),
    serDeInfo?: {
      name?: string(name='Name'),
      parameters?: map[string]string(name='Parameters'),
      serializationLib?: string(name='SerializationLib'),
    }(name='SerDeInfo'),
    skewedInfo?: {
      skewedColNames?: [ string ](name='SkewedColNames'),
      skewedColValueLocationMaps?: map[string]string(name='SkewedColValueLocationMaps'),
      skewedColValues?: [[ string ]      ](name='SkewedColValues'),
    }(name='SkewedInfo'),
    sortCols?: [
      Order
    ](name='SortCols'),
    storedAsSubDirectories?: boolean(name='StoredAsSubDirectories'),
  }(name='Sd'),
  tableFormat?: string(name='TableFormat'),
  tableName?: string(name='TableName'),
  tableType?: string(name='TableType'),
  temporary?: boolean(name='Temporary'),
  updateTime?: int32(name='UpdateTime'),
  viewExpandedText?: string(name='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText'),
}

model TableInput {
  cascade?: boolean(name='Cascade'),
  createTime?: int32(name='CreateTime'),
  createdBy?: string(name='CreatedBy'),
  databaseName?: string(name='DatabaseName'),
  lastAccessTime?: int32(name='LastAccessTime'),
  lastAnalyzedTime?: int32(name='LastAnalyzedTime'),
  owner?: string(name='Owner'),
  ownerType?: string(name='OwnerType'),
  parameters?: map[string]string(name='Parameters'),
  partitionKeys?: [
FieldSchema
](name='PartitionKeys'),
  privileges?: PrincipalPrivilegeSet(name='Privileges'),
  retention?: int32(name='Retention'),
  rewriteEnabled?: boolean(name='RewriteEnabled'),
  sd?: StorageDescriptor(name='Sd'),
  tableName?: string(name='TableName'),
  tableType?: string(name='TableType'),
  temporary?: boolean(name='Temporary'),
  viewExpandedText?: string(name='ViewExpandedText'),
  viewOriginalText?: string(name='ViewOriginalText'),
}

model TableProfile {
  accessNum?: long(name='AccessNum', example='0'),
  accessNumMonthly?: long(name='AccessNumMonthly', example='0'),
  accessNumWeekly?: long(name='AccessNumWeekly', example='0'),
  createTime?: string(name='CreateTime', example='2023-08-14 10:44:13'),
  dataSourceType?: string(name='DataSourceType', example='OSS_HDFS'),
  databaseName?: string(name='DatabaseName', example='test_db'),
  fileCnt?: long(name='FileCnt', example='5'),
  fileSize?: long(name='FileSize', example='31'),
  isPartitioned?: boolean(name='IsPartitioned', example='true'),
  lastAccessNumTime?: string(name='LastAccessNumTime'),
  lastAccessTime?: string(name='LastAccessTime', example='2023-08-22 12:14:42'),
  lastDdlTime?: string(name='LastDdlTime', example='2023-08-16 18:02:24'),
  lastModifyTime?: string(name='LastModifyTime', example='2023-08-16 18:02:25'),
  latestAccessNumDate?: string(name='LatestAccessNumDate'),
  latestDate?: string(name='LatestDate', example='2023-08-30 19:16:10'),
  location?: string(name='Location', example='oss://mybucket.cn-hangzhou.oss-dls.aliyuncs.com/test_db/test_tbl/'),
  objectAccessNum?: long(name='ObjectAccessNum', example='0'),
  objectAccessNumMonthly?: long(name='ObjectAccessNumMonthly', example='18'),
  objectAccessNumWeekly?: long(name='ObjectAccessNumWeekly', example='18'),
  objectCnt?: long(name='ObjectCnt', example='5'),
  objectSize?: long(name='ObjectSize', example='31'),
  partitionCnt?: long(name='PartitionCnt', example='3'),
  recordCnt?: long(name='RecordCnt'),
  tableName?: string(name='TableName', example='test_tbl'),
}

model TableResource {
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
}

model TableStorageRank {
  dbName?: string(name='DbName'),
  quantity?: long(name='Quantity'),
  tableName?: string(name='TableName'),
}

model TableVersion {
  table?: Table(name='Table'),
  versionId?: int32(name='VersionId'),
}

model TaskStatus {
  message?: string(name='Message'),
  status?: string(name='Status'),
}

model UnarchiveDetail {
  apiCallTimes?: long(name='ApiCallTimes'),
  cost?: long(name='Cost'),
  storageSize?: long(name='StorageSize'),
  storageType?: string(name='StorageType'),
  unarchiveTaskStatus?: string(name='UnarchiveTaskStatus'),
}

model UpdateTablePartitionColumnStatisticsRequest {
  catalogId?: string(name='CatalogId'),
  columnStatisticsList?: [
    ColumnStatistics
  ](name='ColumnStatisticsList'),
  databaseName?: string(name='DatabaseName'),
  engine?: string(name='Engine'),
  isStatsCompliant?: boolean(name='IsStatsCompliant'),
  tableName?: string(name='TableName'),
  validWriteIdList?: string(name='ValidWriteIdList'),
  writeId?: string(name='WriteId'),
}

model UserRole {
  grantTime?: long(name='GrantTime'),
  role?: Role(name='Role'),
  user?: Principal(name='User'),
}

model Workflow {
  latestEndTime?: string(name='LatestEndTime'),
  latestInstanceId?: string(name='LatestInstanceId'),
  latestInstanceStatus?: string(name='LatestInstanceStatus'),
  latestStartTime?: string(name='LatestStartTime'),
}

model WorkflowInstance {
  batchProgress?: int32(name='BatchProgress'),
  dlfWorkflowId?: string(name='DlfWorkflowId'),
  endTime?: long(name='EndTime'),
  externalInstanceId?: string(name='ExternalInstanceId'),
  runtimeLogs?: [
    LogInfo
  ](name='RuntimeLogs'),
  startTime?: long(name='StartTime'),
  status?: string(name='Status'),
}

model AbortLockRequest {
  regionId?: string(name='RegionId', position='Host'),
  lockId?: long(name='LockId', description='The lock ID.', example='16530', position='Query'),
}

model AbortLockResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The returned message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='01D8DD6B-4929-5999-9BB3-950AA30E3BD0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false.', example='True'),
}

model AbortLockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AbortLockResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AbortLock  AbortLockRequest
  * @return AbortLockResponse
 */
async function abortLock(request: AbortLockRequest): AbortLockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AbortLock', 'DELETE', '/api/metastore/catalogs/databases/tables/locks/abort', 'json', false, 'json', request);
}

model BatchCreatePartitionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  ifNotExists?: boolean(name='IfNotExists', description='Specifies whether to ignore errors if the name of the partition to be created already exists.', example='true', position='Body'),
  needResult?: boolean(name='NeedResult', description='Specifies whether to return partition information. If the value is true, the partitions are returned.', example='true', position='Body'),
  partitionInputs?: [
    PartitionInput
  ](name='PartitionInputs', description='The information about the partitions to be created.', position='Body'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223', position='Body'),
}

model BatchCreatePartitionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='The returned errors.'),
  partitions?: [
    Partition
  ](name='Partitions', description='The partitions, which are returned if the NeedResult parameter is set to true.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchCreatePartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchCreatePartitionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchCreatePartitions  BatchCreatePartitionsRequest
  * @return BatchCreatePartitionsResponse
 */
async function batchCreatePartitions(request: BatchCreatePartitionsRequest): BatchCreatePartitionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchCreatePartitions', 'POST', '/api/metastore/catalogs/databases/tables/partitions/batchcreate', 'json', false, 'json', request);
}

model BatchCreateTablesRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  ifNotExists?: boolean(name='IfNotExists', description='Specifies whether to ignore errors if the table name already exists.', example='true', position='Body'),
  tableInputs?: [
    TableInput
  ](name='TableInputs', description='The list of data tables.', position='Body'),
}

model BatchCreateTablesResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='The list of errors occurred when you created the data table.', example='["ErrorDetail":{},"TableName":"test"]'),
}

model BatchCreateTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchCreateTablesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchCreateTables  BatchCreateTablesRequest
  * @return BatchCreateTablesResponse
 */
async function batchCreateTables(request: BatchCreateTablesRequest): BatchCreateTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchCreateTables', 'POST', '/api/metastore/catalogs/databases/tables/batchcreate', 'json', false, 'json', request);
}

model BatchDeletePartitionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  ifExists?: boolean(name='IfExists', description='Specifies whether to ignore errors if the partition that you want to delete does not exist.', example='true', position='Body'),
  partitionValueList?: [ 
{
values?: [ string ](name='Values'),
}
](name='PartitionValueList', description='The partition key column values of the partitions to be deleted.', position='Body'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201225', position='Body'),
}

model BatchDeletePartitionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='The returned errors.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchDeletePartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeletePartitionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchDeletePartitions  BatchDeletePartitionsRequest
  * @return BatchDeletePartitionsResponse
 */
async function batchDeletePartitions(request: BatchDeletePartitionsRequest): BatchDeletePartitionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchDeletePartitions', 'POST', '/api/metastore/catalogs/databases/tables/partitions/batchdelete', 'json', false, 'json', request);
}

model BatchDeleteTableVersionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Body'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389', position='Body'),
  versionIds?: [ int32 ](name='VersionIds', description='The list of version numbers.', position='Body'),
}

model BatchDeleteTableVersionsResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchDeleteTableVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteTableVersionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchDeleteTableVersions  BatchDeleteTableVersionsRequest
  * @return BatchDeleteTableVersionsResponse
 */
async function batchDeleteTableVersions(request: BatchDeleteTableVersionsRequest): BatchDeleteTableVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchDeleteTableVersions', 'POST', '/api/metastore/catalogs/databases/tables/versions/batchdelete', 'json', false, 'json', request);
}

model BatchDeleteTablesRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Body'),
  ifExists?: boolean(name='IfExists', description='Specifies whether to ignore errors if the partition with the specified name has been deleted.', example='true', position='Body'),
  tableNames?: [ string ](name='TableNames', description='The list of data table names.', position='Body'),
}

model BatchDeleteTablesResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false', example='true'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='The collection of error messages.'),
}

model BatchDeleteTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteTablesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchDeleteTables  BatchDeleteTablesRequest
  * @return BatchDeleteTablesResponse
 */
async function batchDeleteTables(request: BatchDeleteTablesRequest): BatchDeleteTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchDeleteTables', 'POST', '/api/metastore/catalogs/databases/tables/batchdelete', 'json', false, 'json', request);
}

model BatchGetPartitionColumnStatisticsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  columnNames?: [ string ](name='ColumnNames', description='The names of the columns in the data table.', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  partitionNames?: [ string ](name='PartitionNames', description='The names of the partitions in the data table.', position='Body'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223', position='Body'),
}

model BatchGetPartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionStatisticsMap?: map[string][
    ColumnStatisticsObj
  ](name='PartitionStatisticsMap', description='The partition statistics.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchGetPartitionColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetPartitionColumnStatisticsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchGetPartitionColumnStatistics  BatchGetPartitionColumnStatisticsRequest
  * @return BatchGetPartitionColumnStatisticsResponse
 */
async function batchGetPartitionColumnStatistics(request: BatchGetPartitionColumnStatisticsRequest): BatchGetPartitionColumnStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchGetPartitionColumnStatistics', 'POST', '/api/metastore/catalogs/databases/tables/partitions/columnstatistics/batchget', 'json', false, 'json', request);
}

model BatchGetPartitionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  isShareSd?: boolean(name='IsShareSd', description='Specifies whether to share the column information of SD in the partition.', example='true', position='Body'),
  partitionValueList?: [ 
{
values?: [ string ](name='Values'),
}
](name='PartitionValueList', description='The values of the partition key columns.', position='Body'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389', position='Body'),
}

model BatchGetPartitionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='The error messages.'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs', description='The list of partition specifications.'),
  partitions?: [
    Partition
  ](name='Partitions', description='The list of partitions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchGetPartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetPartitionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchGetPartitions  BatchGetPartitionsRequest
  * @return BatchGetPartitionsResponse
 */
async function batchGetPartitions(request: BatchGetPartitionsRequest): BatchGetPartitionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchGetPartitions', 'POST', '/api/metastore/catalogs/databases/tables/partitions/batchget', 'json', false, 'json', request);
}

model BatchGetTablesRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  tableNames?: [ string ](name='TableNames', description='The name of the data table.', position='Body'),
}

model BatchGetTablesResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false', example='true'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='The returned errors.'),
  tables?: [
    Table
  ](name='Tables', description='The returned data tables.'),
}

model BatchGetTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetTablesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchGetTables  BatchGetTablesRequest
  * @return BatchGetTablesResponse
 */
async function batchGetTables(request: BatchGetTablesRequest): BatchGetTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchGetTables', 'POST', '/api/metastore/catalogs/databases/tables/batchget', 'json', false, 'json', request);
}

model BatchGrantPermissionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  grantRevokeEntries?: [
    GrantRevokeEntry
  ](name='GrantRevokeEntries', description='The list of the items to be authorized.', position='Body'),
  type: string(name='Type', description='The authorization type. Only Hive is supported.

This parameter is required.', example='Hive', position='Body'),
}

model BatchGrantPermissionsResponseBody = {
  batchGrantRevokeFailureResult?: [
    GrantRevokeFailureEntry
  ](name='BatchGrantRevokeFailureResult', description='The result returned when batch authorization failed.'),
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchGrantPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGrantPermissionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchGrantPermissions  BatchGrantPermissionsRequest
  * @return BatchGrantPermissionsResponse
 */
async function batchGrantPermissions(request: BatchGrantPermissionsRequest): BatchGrantPermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchGrantPermissions', 'POST', '/api/metastore/auth/permissions/batchgrant', 'json', false, 'json', request);
}

model BatchRevokePermissionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  grantRevokeEntries?: [
    GrantRevokeEntry
  ](name='GrantRevokeEntries', description='The permissions to be revoked.', position='Body'),
  type: string(name='Type', description='The authorization type. Set the value to Hive.

This parameter is required.', example='Hive', position='Body'),
}

model BatchRevokePermissionsResponseBody = {
  batchGrantRevokeFailureResult?: [
    GrantRevokeFailureEntry
  ](name='BatchGrantRevokeFailureResult', description='The result returned when batch permission revocation failed.'),
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C9E535E1-F040-56F4-B4EE-592B555DAE19'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model BatchRevokePermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchRevokePermissionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchRevokePermissions  BatchRevokePermissionsRequest
  * @return BatchRevokePermissionsResponse
 */
async function batchRevokePermissions(request: BatchRevokePermissionsRequest): BatchRevokePermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchRevokePermissions', 'POST', '/api/metastore/auth/permissions/batchrevoke', 'json', false, 'json', request);
}

model BatchUpdatePartitionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  partitionInputs?: [
    PartitionInput
  ](name='PartitionInputs', description='The information about the partitions to be updated.', position='Body'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223', position='Body'),
}

model BatchUpdatePartitionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionErrors?: [
    PartitionError
  ](name='PartitionErrors', description='The returned errors.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model BatchUpdatePartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchUpdatePartitionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchUpdatePartitions  BatchUpdatePartitionsRequest
  * @return BatchUpdatePartitionsResponse
 */
async function batchUpdatePartitions(request: BatchUpdatePartitionsRequest): BatchUpdatePartitionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchUpdatePartitions', 'PUT', '/api/metastore/catalogs/databases/tables/partitions/batchupdate', 'json', false, 'json', request);
}

model BatchUpdateTablesRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  isAsync?: boolean(name='IsAsync', description='Specifies whether to asynchronously update the data table. Valid values:

*   true: The operation is asynchronously called. The update result is immediately returned. You can query the task status by taskid in the returned results.
*   false: The operation is synchronously called. The update result is returned after the background task is complete. If the execution of the background task requires an extended period of time, a timeout occurs.', example='true', position='Body'),
  tableInputs?: [
    TableInput
  ](name='TableInputs', description='The details about the updated data table.', position='Body'),
}

model BatchUpdateTablesResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  tableErrors?: [
    TableError
  ](name='TableErrors', description='The returned errors.', example='{"ErrorDetails":{},"TableName":"test"}'),
  taskId?: string(name='TaskId', description='The ID of the asynchronous update task.', example='f8deec55f54ac566e7ec8944fbe01588'),
}

model BatchUpdateTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchUpdateTablesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchUpdateTables  BatchUpdateTablesRequest
  * @return BatchUpdateTablesResponse
 */
async function batchUpdateTables(request: BatchUpdateTablesRequest): BatchUpdateTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchUpdateTables', 'POST', '/api/metastore/catalogs/databases/tables/batchupdate', 'json', false, 'json', request);
}

model CancelQueryRequest {
  regionId?: string(name='RegionId', position='Host'),
  queryId?: string(name='QueryId', description='The query ID.

>  You can call the SubmitQuery operation to query the query ID.', example='Q-BCA5E96CB84BB8B8', position='Query'),
}

model CancelQueryResponseBody = {
  data?: string(name='Data', description='Query ID', example='Q-BCA5E96CB84BB8B8'),
  requestId?: string(name='RequestId', description='The request ID.', example='DB07AAE9-4B88-5DEA-8F1D-4D1A9A864A85'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model CancelQueryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelQueryResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CancelQuery  CancelQueryRequest
  * @return CancelQueryResponse
 */
async function cancelQuery(request: CancelQueryRequest): CancelQueryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CancelQuery', 'POST', '/webapi/query/cancelQuery', 'json', false, 'json', request);
}

model CheckPermissionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  body?: AccessRequest(name='Body', description='The HTTP request body, in the JSON format.', position='Body'),
}

model CheckPermissionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='81B90E1B-7514-5817-9D59-0EA9E2215876'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model CheckPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckPermissionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CheckPermissions  CheckPermissionsRequest
  * @return CheckPermissionsResponse
 */
async function checkPermissions(request: CheckPermissionsRequest): CheckPermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CheckPermissions', 'POST', '/api/metastore/auth/permissions/check', 'json', false, 'json', request);
}

model CreateCatalogRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogInput?: CatalogInput(name='CatalogInput', description='The structure that is used to create or update the catalog.', position='Body'),
}

model CreateCatalogResponseBody = {
  code?: string(name='Code', description='The status code returned.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='BA84F8D4-5160-5544-BE76-3A306CD3A7B0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model CreateCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCatalogResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateCatalog  CreateCatalogRequest
  * @return CreateCatalogResponse
 */
async function createCatalog(request: CreateCatalogRequest): CreateCatalogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateCatalog', 'POST', '/api/metastore/catalogs', 'json', false, 'json', request);
}

model CreateDatabaseRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseInput?: DatabaseInput(name='DatabaseInput', description='The database details.', position='Body'),
}

model CreateDatabaseResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request is successful.
*   false: The request failed.', example='true'),
}

model CreateDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDatabaseResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateDatabase  CreateDatabaseRequest
  * @return CreateDatabaseResponse
 */
async function createDatabase(request: CreateDatabaseRequest): CreateDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateDatabase', 'POST', '/api/metastore/catalogs/databases', 'json', false, 'json', request);
}

model CreateFunctionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  functionInput?: FunctionInput(name='FunctionInput', description='The details about the function definition.', position='Body'),
}

model CreateFunctionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model CreateFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFunctionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateFunction  CreateFunctionRequest
  * @return CreateFunctionResponse
 */
async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateFunction', 'POST', '/api/metastore/catalogs/databases/functions', 'json', false, 'json', request);
}

model CreateLockRequest {
  regionId?: string(name='RegionId', position='Host'),
  lockObjList?: [
    LockObj
  ](name='LockObjList', description='The list of locks.', example='{"databaseName":"db","tableName":"test"}', position='Body'),
}

model CreateLockResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  lockStatus?: LockStatus(name='LockStatus', description='The lock status.', example='{"lockId":12323,"lockStatus":"ACQUIRED"}'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='73201200-4C1A-4FEF-BD6B-C0DA7994FFA2'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false.', example='True'),
}

model CreateLockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLockResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateLock  CreateLockRequest
  * @return CreateLockResponse
 */
async function createLock(request: CreateLockRequest): CreateLockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateLock', 'POST', '/api/metastore/catalogs/databases/tables/locks', 'json', false, 'json', request);
}

model CreatePartitionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  ifNotExists?: boolean(name='IfNotExists', description='Specifies whether to ignore errors if the name of the partition to be created already exists.', example='true', position='Body'),
  needResult?: boolean(name='NeedResult', description='Specifies whether to return partition information. If this parameter is set to true, the Partition parameter is returned.', example='true', position='Body'),
  partitionInput?: PartitionInput(name='PartitionInput', description='The information about the partition to be created.', position='Body'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223', position='Body'),
}

model CreatePartitionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partition?: Partition(name='Partition', description='The partition information. This parameter is returned if the NeedResult parameter is set to true.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model CreatePartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePartitionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreatePartition  CreatePartitionRequest
  * @return CreatePartitionResponse
 */
async function createPartition(request: CreatePartitionRequest): CreatePartitionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreatePartition', 'POST', '/api/metastore/catalogs/databases/tables/partitions', 'json', false, 'json', request);
}

model CreateRoleRequest {
  regionId?: string(name='RegionId', position='Host'),
  body?: RoleInput(name='body', description='The HTTP request body, in the JSON format.', position='Body'),
}

model CreateRoleResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='77BC2016-BA80-570F-BD15-2FB80281FED6'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model CreateRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRoleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateRole  CreateRoleRequest
  * @return CreateRoleResponse
 */
async function createRole(request: CreateRoleRequest): CreateRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateRole', 'POST', '/api/metastore/auth/roles', 'json', false, 'json', request);
}

model CreateTableRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  tableInput?: TableInput(name='TableInput', description='The details about the data table.', position='Body'),
}

model CreateTableResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model CreateTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTableResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateTable  CreateTableRequest
  * @return CreateTableResponse
 */
async function createTable(request: CreateTableRequest): CreateTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateTable', 'POST', '/api/metastore/catalogs/databases/tables', 'json', false, 'json', request);
}

model DeleteCatalogRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId: string(name='CatalogId', description='The ID of the data directory.

This parameter is required.', example='catalog_test', position='Query'),
  isAsync?: boolean(name='IsAsync', description='Whether asynchronous, synchronous by default.', example='true', position='Query'),
}

model DeleteCatalogResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
  taskId?: string(name='TaskId', description='The ID of the task for asynchronously deleting a catalog.', example='c38206c3aca0c41332ffe49294243009'),
}

model DeleteCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCatalogResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteCatalog  DeleteCatalogRequest
  * @return DeleteCatalogResponse
 */
async function deleteCatalog(request: DeleteCatalogRequest): DeleteCatalogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteCatalog', 'DELETE', '/api/metastore/catalogs', 'json', false, 'json', request);
}

model DeleteDatabaseRequest {
  regionId?: string(name='RegionId', position='Host'),
  async?: boolean(name='Async', description='Whether to asynchronously execute.', example='true', position='Query'),
  cascade?: boolean(name='Cascade', description='Whether to cascade delete data. Valid values:

*   true: deletes a table from the database.
*   false: does not delete tables from the database. If a table still exists in the database, the deletion fails.', example='false', position='Query'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  name?: string(name='Name', description='The name of a database.', example='database_test', position='Query'),
}

model DeleteDatabaseResponseBody = {
  code?: string(name='Code', description='The description of the distribution status.', example='OK'),
  message?: string(name='Message', description='A related error message is displayed.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='73201200-4C1A-4FEF-BD6B-C0DA7994FFA2'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
  taskId?: string(name='TaskId', description='The ID of the task that is used to asynchronously delete a database.', example='c38206c3aca0c41332ffe49294243009'),
}

model DeleteDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDatabaseResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteDatabase  DeleteDatabaseRequest
  * @return DeleteDatabaseResponse
 */
async function deleteDatabase(request: DeleteDatabaseRequest): DeleteDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteDatabase', 'DELETE', '/api/metastore/catalogs/databases', 'json', false, 'json', request);
}

model DeleteFunctionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Query'),
  functionName?: string(name='FunctionName', description='The function name.', example='func2', position='Query'),
}

model DeleteFunctionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeleteFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFunctionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteFunction  DeleteFunctionRequest
  * @return DeleteFunctionResponse
 */
async function deleteFunction(request: DeleteFunctionRequest): DeleteFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteFunction', 'DELETE', '/api/metastore/catalogs/databases/functions', 'json', false, 'json', request);
}

model DeletePartitionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  ifExists?: boolean(name='IfExists', description='Specifies whether to ignore errors if the partition that you want to delete does not exist. Valid values:

*   true: ignores errors and no error will be reported.
*   false: does not ignore errors and errors will be reported.', example='true', position='Body'),
  partitionValues?: [ string ](name='PartitionValues', description='The values of the partition key columns.', position='Body'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201225', position='Body'),
}

model DeletePartitionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeletePartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePartitionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeletePartition  DeletePartitionRequest
  * @return DeletePartitionResponse
 */
async function deletePartition(request: DeletePartitionRequest): DeletePartitionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeletePartition', 'POST', '/api/metastore/catalogs/databases/tables/partitions/delete', 'json', false, 'json', request);
}

model DeletePartitionColumnStatisticsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  columnNames?: [ string ](name='ColumnNames', description='The key columns of the partitions.', shrink='json', position='Query'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Query'),
  partitionNames?: [ string ](name='PartitionNames', description='The names of the partitions.', shrink='json', position='Query'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223', position='Query'),
}

model DeletePartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeletePartitionColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePartitionColumnStatisticsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeletePartitionColumnStatistics  DeletePartitionColumnStatisticsRequest
  * @return DeletePartitionColumnStatisticsResponse
 */
async function deletePartitionColumnStatistics(request: DeletePartitionColumnStatisticsRequest): DeletePartitionColumnStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeletePartitionColumnStatistics', 'DELETE', '/api/metastore/catalogs/databases/tables/partitions/columnstatistics', 'json', false, 'json', request);
}

model DeleteRoleRequest {
  regionId?: string(name='RegionId', position='Host'),
  roleName?: string(name='RoleName', description='The name of the role to be deleted.', example='roleId/roleName至少有一个是非空', position='Query'),
}

model DeleteRoleResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeleteRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRoleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteRole  DeleteRoleRequest
  * @return DeleteRoleResponse
 */
async function deleteRole(request: DeleteRoleRequest): DeleteRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteRole', 'DELETE', '/api/metastore/auth/roles', 'json', false, 'json', request);
}

model DeleteTableRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Query'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223', position='Query'),
}

model DeleteTableResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeleteTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTableResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteTable  DeleteTableRequest
  * @return DeleteTableResponse
 */
async function deleteTable(request: DeleteTableRequest): DeleteTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteTable', 'DELETE', '/api/metastore/catalogs/databases/tables', 'json', false, 'json', request);
}

model DeleteTableColumnStatisticsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  columnNames?: [ string ](name='ColumnNames', description='The list of column names.', shrink='json', position='Query'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Query'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223', position='Query'),
}

model DeleteTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeleteTableColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTableColumnStatisticsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteTableColumnStatistics  DeleteTableColumnStatisticsRequest
  * @return DeleteTableColumnStatisticsResponse
 */
async function deleteTableColumnStatistics(request: DeleteTableColumnStatisticsRequest): DeleteTableColumnStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteTableColumnStatistics', 'DELETE', '/api/metastore/catalogs/databases/tables/columnstatistics', 'json', false, 'json', request);
}

model DeleteTableVersionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Query'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389', position='Query'),
  versionId?: int32(name='VersionId', description='The version number.', example='1', position='Query'),
}

model DeleteTableVersionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model DeleteTableVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTableVersionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteTableVersion  DeleteTableVersionRequest
  * @return DeleteTableVersionResponse
 */
async function deleteTableVersion(request: DeleteTableVersionRequest): DeleteTableVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteTableVersion', 'DELETE', '/api/metastore/catalogs/databases/tables/versions', 'json', false, 'json', request);
}

model DeregisterLocationRequest {
  regionId?: string(name='RegionId', position='Host'),
  locationId: string(name='LocationId', description='Location ID

>  You can call the RegisterLocation operation to obtain the Location ID.

This parameter is required.', example='LOC-AB8FBC17F95A4AF5', position='Query'),
}

model DeregisterLocationResponseBody = {
  data?: {
    locationId?: string(name='LocationId', description='Location ID', example='LOC-AB8FBC17F95A4AF5'),
    storageCollectTaskOperationResultList?: [
      StorageCollectTaskOperationResult
    ](name='StorageCollectTaskOperationResultList', description='The list of the collection tasks that are disabled.'),
  }(name='Data', description='Response parameters'),
  requestId?: string(name='RequestId', description='The request ID.', example='E47920CD-BAE6-1305-88DF-FBDD3D300845'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true.
*   false: The request failed.', example='true'),
}

model DeregisterLocationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeregisterLocationResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeregisterLocation  DeregisterLocationRequest
  * @return DeregisterLocationResponse
 */
async function deregisterLocation(request: DeregisterLocationRequest): DeregisterLocationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeregisterLocation', 'DELETE', '/webapi/locations', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  regionId?: string(name='RegionId', position='Host'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      description?: string(name='Description', description='The description of the filtering table.'),
      name?: string(name='Name', description='The name of the data.', example='cn-hangzhou'),
      showName?: string(name='ShowName', description='The display name.'),
      type?: string(name='Type', description='The type.', example='region'),
    }
  ](name='Regions', description='The region list.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the test feature is enabled.', example='true'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeRegions  DescribeRegionsRequest
  * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeRegions', 'GET', '/webapi/service/describeRegions', 'json', false, 'json', request);
}

model GetAsyncTaskStatusRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  taskId?: string(name='TaskId', description='The result returned by the asynchronous task.', example='f546c761570e5efc8146a1986f7890d2', position='Query'),
}

model GetAsyncTaskStatusResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The message that is returned.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  taskStatus?: TaskStatus(name='TaskStatus', description='The task status.', example='Success'),
}

model GetAsyncTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAsyncTaskStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetAsyncTaskStatus  GetAsyncTaskStatusRequest
  * @return GetAsyncTaskStatusResponse
 */
async function getAsyncTaskStatus(request: GetAsyncTaskStatusRequest): GetAsyncTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetAsyncTaskStatus', 'GET', '/api/metastore/catalogs/tasks', 'json', false, 'json', request);
}

model GetCatalogRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='catalog_test', position='Query'),
}

model GetCatalogResponseBody = {
  catalog?: Catalog(name='Catalog', description='The catalog details.'),
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The returned message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='DB07AAE9-4B88-5DEA-8F1D-4D1A9A864A85'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model GetCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCatalogResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetCatalog  GetCatalogRequest
  * @return GetCatalogResponse
 */
async function getCatalog(request: GetCatalogRequest): GetCatalogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetCatalog', 'GET', '/api/metastore/catalogs', 'json', false, 'json', request);
}

model GetCatalogSettingsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
}

model GetCatalogSettingsResponseBody = {
  catalogSettings?: CatalogSettings(name='CatalogSettings', description='The data lake configurations.'),
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model GetCatalogSettingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCatalogSettingsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetCatalogSettings  GetCatalogSettingsRequest
  * @return GetCatalogSettingsResponse
 */
async function getCatalogSettings(request: GetCatalogSettingsRequest): GetCatalogSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetCatalogSettings', 'GET', '/api/metastore/catalogs/settings', 'json', false, 'json', request);
}

model GetDatabaseRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  name?: string(name='Name', description='The name of a database.', example='database_test', position='Query'),
}

model GetDatabaseResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  database?: Database(name='Database', description='The database object.', example='{"name":"test"}'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D659761F-29C3-409D-805A-0CF33A320128'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model GetDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDatabaseResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetDatabase  GetDatabaseRequest
  * @return GetDatabaseResponse
 */
async function getDatabase(request: GetDatabaseRequest): GetDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetDatabase', 'GET', '/api/metastore/catalogs/databases', 'json', false, 'json', request);
}

model GetDatabaseProfileRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory. By default, the ID of the primary account is entered.', example='1344371', position='Query'),
  databaseName: string(name='DatabaseName', description='The name of the metadatabase.

This parameter is required.', example='530_db', position='Query'),
}

model GetDatabaseProfileResponseBody = {
  code?: string(name='Code', description='The error code.', example='200'),
  databaseProfile?: DatabaseProfile(name='DatabaseProfile', description='The data profile of the database.', example='{
	"FileCnt": 213,
	"FileSize": 34324
}'),
  message?: string(name='Message', description='The error message.', example='-'),
  requestId?: string(name='RequestId', description='The request ID.', example='AEA7DCC8-DBF5-561B-A7FD-0747D7D51FEB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model GetDatabaseProfileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDatabaseProfileResponseBody(name='body'),
}

/**
  * @description To use a data profile, you must first host the OSS bucket of the database.
  * @param request  the request parameters of GetDatabaseProfile  GetDatabaseProfileRequest
  * @return GetDatabaseProfileResponse
 */
async function getDatabaseProfile(request: GetDatabaseProfileRequest): GetDatabaseProfileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetDatabaseProfile', 'GET', '/webapi/metastorehouse/catalog/database/databaseprofile', 'json', false, 'json', request);
}

model GetFunctionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Query'),
  functionName?: string(name='FunctionName', description='The name of the user-defined function.', example='func2', position='Query'),
}

model GetFunctionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  function?: Function(name='Function', description='The details about the function.', example='{"FunctionName":test}'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GetFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFunctionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetFunction  GetFunctionRequest
  * @return GetFunctionResponse
 */
async function getFunction(request: GetFunctionRequest): GetFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunction', 'GET', '/api/metastore/catalogs/databases/functions', 'json', false, 'json', request);
}

model GetLifecycleRuleRequest {
  regionId?: string(name='RegionId', position='Host'),
  bizId?: string(name='BizId', description='The business ID.', example='LCRU-17E7192705C365C0', position='Query'),
  resourceName?: string(name='ResourceName', description='The name of the resource, which is a string that consists of the data directory, database, and table.', example='demo_catalog_id.demo_db_name.demo_table_name', position='Query'),
}

model GetLifecycleRuleResponseBody = {
  data?: LifecycleRule(name='Data', description='The information about the lifecycle rule.'),
  requestId?: string(name='RequestId', description='The request ID.', example='EDBC848F-7CC7-52E3-9FBF-924D09B5C27A'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false.', example='True'),
}

model GetLifecycleRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLifecycleRuleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetLifecycleRule  GetLifecycleRuleRequest
  * @return GetLifecycleRuleResponse
 */
async function getLifecycleRule(request: GetLifecycleRuleRequest): GetLifecycleRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLifecycleRule', 'GET', '/webapi/metastorehouse/lifecycle/rule/getLifecycleRule', 'json', false, 'json', request);
}

model GetLockRequest {
  regionId?: string(name='RegionId', position='Host'),
  lockId?: long(name='LockId', description='The lock ID.', example='16533', position='Query'),
}

model GetLockResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  lockStatus?: LockStatus(name='LockStatus', description='The lock status.', example='{"lockId":123,"lockStatus":"Acquired"}'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='558D764F-8C55-49CA-BF38-80EA532FC08F'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false.', example='True'),
}

model GetLockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLockResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetLock  GetLockRequest
  * @return GetLockResponse
 */
async function getLock(request: GetLockRequest): GetLockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLock', 'GET', '/api/metastore/catalogs/databases/tables/locks', 'json', false, 'json', request);
}

model GetPartitionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  partitionValues?: [ string ](name='PartitionValues', description='The partitions.', position='Body'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389', position='Body'),
}

model GetPartitionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partition?: Partition(name='Partition', description='The partition details.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GetPartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPartitionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetPartition  GetPartitionRequest
  * @return GetPartitionResponse
 */
async function getPartition(request: GetPartitionRequest): GetPartitionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetPartition', 'POST', '/api/metastore/catalogs/databases/tables/partitions/get', 'json', false, 'json', request);
}

model GetPartitionColumnStatisticsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  columnNames?: [ string ](name='ColumnNames', description='The names of the fields in the data table.', shrink='json', position='Query'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Query'),
  partitionNames?: [ string ](name='PartitionNames', description='The names of the partitions in the data table.', shrink='json', position='Query'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223', position='Query'),
}

model GetPartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  partitionStatisticsMap?: map[string][
    ColumnStatisticsObj
  ](name='PartitionStatisticsMap', description='The partition statistics.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GetPartitionColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPartitionColumnStatisticsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetPartitionColumnStatistics  GetPartitionColumnStatisticsRequest
  * @return GetPartitionColumnStatisticsResponse
 */
async function getPartitionColumnStatistics(request: GetPartitionColumnStatisticsRequest): GetPartitionColumnStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetPartitionColumnStatistics', 'GET', '/api/metastore/catalogs/databases/tables/partitions/columnstatistics', 'json', false, 'json', request);
}

model GetQueryResultRequest {
  regionId?: string(name='RegionId', position='Host'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum value is 1000.', example='100', position='Query'),
  queryId?: string(name='QueryId', description='The query ID.

>  You can call the SubmitQuery operation to query the query ID.', example='Q-41676378709440CE', position='Query'),
}

model GetQueryResultResponseBody = {
  duration?: long(name='Duration', description='up time in milliseconds.', example='8000'),
  endTime?: string(name='EndTime', description='The time when the query was completed.', example='2022-05-09 16:19:09'),
  errorMessage?: string(name='ErrorMessage', description='The error message of the query.', example='Table or view not found:'),
  gmtCreate?: string(name='GmtCreate', description='The time when the query was created.', example='2022-05-09 16:18:09'),
  gmtModified?: string(name='GmtModified', description='The time when the query result was updated.', example='2022-05-09 16:19:09'),
  id?: string(name='Id', description='The query ID.', example='Q-41676378709440CE'),
  jobCompleted?: boolean(name='JobCompleted', description='Whether the query has been completed. false indicates that you need to continue polling this interface.', example='true'),
  logs?: string(name='Logs', description='Run logs.', example='["this is log"]'),
  owner?: long(name='Owner', description='The uid of the primary account of the creator.', example='229167306180609***'),
  progress?: int32(name='Progress', description='The progress of the query. The value ranges from 0 to 100.', example='99'),
  regionId?: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='The request ID.', example='1D2BCFBA-7639-59A9-817B-944EC1339279'),
  resultTmpDb?: string(name='ResultTmpDb', description='The result temporary library is not available.', example='db'),
  resultTmpTable?: string(name='ResultTmpTable', description='The result temporary table, which is not available.', example='table'),
  rowCount?: int32(name='RowCount', description='The total number of rows in the result. This parameter is returned only when the status is AVAILABLE.', example='100'),
  rowCountOverLimit?: boolean(name='RowCountOverLimit', description='Whether the total number of rows in the result exceeds the maximum value.', example='false'),
  rows?: string(name='Rows', description='The returned result. This value is returned only when the status is AVAILABLE. The content is represented as a two-dimensional JSON array.', example='[[10,"Tom"],[11,"Jerry"]]'),
  schema?: string(name='Schema', description='The header field and type of the query result. This parameter is returned only when the status is AVAILABLE.', example='[{"name":"id","type":"INT"},{"name":"student_name","type":"VARCHAR"}]'),
  sql?: string(name='Sql', description='The original SQL statement.', example='select * from db.student'),
  startTime?: string(name='StartTime', description='The point in time when the query was initiated.', example='2022-05-09 16:18:09'),
  status?: string(name='Status', description='The query status.

Valid values:

*   AVAILABLE
*   CANCELLED: The has canceled.
*   RUNNING: The is running.
*   CANCELLING: The is being canceled.
*   WAITING: The is waiting for.
*   ERROR', example='AVAILABLE'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
  totalBytesProcessed?: long(name='TotalBytesProcessed', description='The total amount of data scanned. Unit: bytes.', example='1024'),
}

model GetQueryResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQueryResultResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetQueryResult  GetQueryResultRequest
  * @return GetQueryResultResponse
 */
async function getQueryResult(request: GetQueryResultRequest): GetQueryResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetQueryResult', 'GET', '/webapi/query/getQueryResult', 'json', false, 'json', request);
}

model GetRegionStatusRequest {
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou', position='Query'),
}

model GetRegionStatusResponseBody = {
  data?: {
    accountStatus?: string(name='AccountStatus', description='Account status enabled or disabled', example='enabled'),
    isDependencyReady?: boolean(name='IsDependencyReady', description='Whether the dependency is ready', example='true'),
    isDlfServiceOpen?: boolean(name='IsDlfServiceOpen', description='Whether the DLF service is activated', example='True'),
    regionId?: string(name='RegionId', description='region id', example='cn_hangzhou'),
    regionStatus?: string(name='RegionStatus', description='The status of the region. SERVICE_INVALID: The service is unavailable. UNITITIALIZED: Not initialized. READY: Normal.', example='READY'),
  }(name='Data', description='The returned data.', example='{\\"RegionId\\": \\"cn-shanghai\\", \\"RegionStatus\\": \\"SERVICE_INVALID\\", \\"AccountStatus\\": \\"\\", \\"IsDlfServiceOpen\\": False}'),
  requestId?: string(name='RequestId', description='The request ID.', example='CC58A776-0662-5C6D-B467-FFD4CF7F4C40'),
  success?: string(name='Success', description='Indicates whether the request is successful.', example='true'),
}

model GetRegionStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRegionStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetRegionStatus  GetRegionStatusRequest
  * @return GetRegionStatusResponse
 */
async function getRegionStatus(request: GetRegionStatusRequest): GetRegionStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetRegionStatus', 'GET', '/webapi/service/getRegionStatus', 'json', false, 'json', request);
}

model GetRoleRequest {
  regionId?: string(name='RegionId', position='Host'),
  roleName?: string(name='RoleName', description='The name of the role.', example='role_name', position='Query'),
}

model GetRoleResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4316D7DA-9816-596D-A3D7-12676FA59BDA'),
  role?: Role(name='Role', description='The information about the role.'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GetRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRoleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetRole  GetRoleRequest
  * @return GetRoleResponse
 */
async function getRole(request: GetRoleRequest): GetRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetRole', 'GET', '/api/metastore/auth/roles', 'json', false, 'json', request);
}

model GetServiceStatusRequest {
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou', position='Query'),
}

model GetServiceStatusResponseBody = {
  data?: {
    hasRamPermissions?: boolean(name='HasRamPermissions', description='Whether to complete RAM authorization', example='true'),
    isDlfServiceOpen?: boolean(name='IsDlfServiceOpen', description='Whether the DLF service is activated', example='true'),
    isOssOpen?: boolean(name='IsOssOpen', description='Whether the OSS service is enabled', example='true'),
  }(name='Data', description='Service status', example='{ 			"AccountStatus":"", 			"RegionStatus":"READY", 			"RegionId":"cn-shanghai", 			"IsDependencyReady":true, 			"IsDlfServiceOpen":true 		}'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the test feature is enabled.', example='true'),
}

model GetServiceStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetServiceStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetServiceStatus  GetServiceStatusRequest
  * @return GetServiceStatusResponse
 */
async function getServiceStatus(request: GetServiceStatusRequest): GetServiceStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetServiceStatus', 'GET', '/webapi/service/getServiceStatus', 'json', false, 'json', request);
}

model GetTableRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Query'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389', position='Query'),
}

model GetTableResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
  table?: Table(name='Table', description='The details about the data table.'),
}

model GetTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTableResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetTable  GetTableRequest
  * @return GetTableResponse
 */
async function getTable(request: GetTableRequest): GetTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTable', 'GET', '/api/metastore/catalogs/databases/tables', 'json', false, 'json', request);
}

model GetTableColumnStatisticsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  columnNames?: [ string ](name='ColumnNames', description='The names of the columns in the data table.', shrink='json', position='Query'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Query'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223', position='Query'),
}

model GetTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  columnStatisticsObjList?: [
    ColumnStatisticsObj
  ](name='ColumnStatisticsObjList', description='The list of column statistics.', example='[]'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   true and
*   false', example='true'),
}

model GetTableColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTableColumnStatisticsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetTableColumnStatistics  GetTableColumnStatisticsRequest
  * @return GetTableColumnStatisticsResponse
 */
async function getTableColumnStatistics(request: GetTableColumnStatisticsRequest): GetTableColumnStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTableColumnStatistics', 'GET', '/api/metastore/catalogs/databases/tables/columnstatistics', 'json', false, 'json', request);
}

model GetTableProfileRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory. By default, the ID of the primary account is entered.', example='1344371', position='Query'),
  databaseName: string(name='DatabaseName', description='The name of the metadatabase.

This parameter is required.', example='exp_table', position='Query'),
  tableName: string(name='TableName', description='The name of the metadata table.

This parameter is required.', example='admin_user', position='Query'),
}

model GetTableProfileResponseBody = {
  code?: string(name='Code', description='The error code.', example='OK'),
  message?: string(name='Message', description='The error message.', example='None'),
  requestId?: string(name='RequestId', description='The request ID.', example='C742A04F-F304-5440-9ED8-AD58C36D1915'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
  tableProfile?: TableProfile(name='TableProfile', description='The data profile of the table.'),
}

model GetTableProfileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTableProfileResponseBody(name='body'),
}

/**
  * @description To use a data profile, you must first host the OSS bucket of the table.
  * @param request  the request parameters of GetTableProfile  GetTableProfileRequest
  * @return GetTableProfileResponse
 */
async function getTableProfile(request: GetTableProfileRequest): GetTableProfileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTableProfile', 'GET', '/webapi/metastorehouse/catalog/database/tableprofile', 'json', false, 'json', request);
}

model GetTableVersionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Query'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389', position='Query'),
  versionId?: int32(name='VersionId', description='The version number of the data table.', example='1', position='Query'),
}

model GetTableVersionResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  tableVersion?: TableVersion(name='TableVersion', description='The information about the data table of the specified version.', example='{"VersionId":123,"Table":{}}'),
}

model GetTableVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTableVersionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetTableVersion  GetTableVersionRequest
  * @return GetTableVersionResponse
 */
async function getTableVersion(request: GetTableVersionRequest): GetTableVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTableVersion', 'GET', '/api/metastore/catalogs/databases/tables/versions', 'json', false, 'json', request);
}

model GrantPermissionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  accesses: [ string ](name='Accesses', description='The list of the access permissions to be granted.

This parameter is required.', position='Body'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', position='Body'),
  delegateAccesses: [ string ](name='DelegateAccesses', description='The list of the grantable access permissions to be granted.

This parameter is required.', position='Body'),
  metaResource: MetaResource(name='MetaResource', description='The metadata resource to be authorized.

This parameter is required.', position='Body'),
  principal: Principal(name='Principal', description='The users or roles to be authorized. Formats:

*   RAM user: acs:ram::[accountId]:user/[userName]
*   RAM role: acs:ram::[accountId]:role/[roleName]
*   Data lake role: acs:dlf::[accountId]:role/[roleName]

This parameter is required.', position='Body'),
  type: string(name='Type', description='The authorization type. Only Hive is supported.

This parameter is required.', example='Hive', position='Body'),
}

model GrantPermissionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4912024D-2A06-5E9F-9667-35D9319917D7'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GrantPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GrantPermissionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GrantPermissions  GrantPermissionsRequest
  * @return GrantPermissionsResponse
 */
async function grantPermissions(request: GrantPermissionsRequest): GrantPermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GrantPermissions', 'POST', '/api/metastore/auth/permissions/grant', 'json', false, 'json', request);
}

model GrantRoleToUsersRequest {
  regionId?: string(name='RegionId', position='Host'),
  roleName?: string(name='RoleName', description='The name of the role.', example='test_role_8', position='Body'),
  users?: [
Principal
](name='Users', description='The RAM users or roles to which you want to assign the role. Format:

*   RAM user: acs:ram::[accountId]:user/[userName].
*   RAM role: acs:ram::[accountId]:role/[roleName].', position='Body'),
}

model GrantRoleToUsersResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4316D7DA-9816-596D-A3D7-12676FA59BDA'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GrantRoleToUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GrantRoleToUsersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GrantRoleToUsers  GrantRoleToUsersRequest
  * @return GrantRoleToUsersResponse
 */
async function grantRoleToUsers(request: GrantRoleToUsersRequest): GrantRoleToUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GrantRoleToUsers', 'PUT', '/api/metastore/auth/roles/grantusers', 'json', false, 'json', request);
}

model GrantRolesToUserRequest {
  regionId?: string(name='RegionId', position='Host'),
  roleNames: [ string ](name='RoleNames', description='The roles to be assigned to the user.

This parameter is required.', position='Body'),
  user: Principal(name='User', description='The user to which you want to assign roles. Format:

*   RAM roles: acs:ram::[accountId]:role/[roleName].
*   RAM user: acs:ram::[accountId]:user/[userName].

This parameter is required.', position='Body'),
}

model GrantRolesToUserResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='81B90E1B-7514-5817-9D59-0EA9E2215876'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model GrantRolesToUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GrantRolesToUserResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GrantRolesToUser  GrantRolesToUserRequest
  * @return GrantRolesToUserResponse
 */
async function grantRolesToUser(request: GrantRolesToUserRequest): GrantRolesToUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GrantRolesToUser', 'POST', '/api/metastore/auth/roles/grantroles', 'json', false, 'json', request);
}

model ListCatalogsRequest {
  regionId?: string(name='RegionId', position='Host'),
  idPattern?: string(name='IdPattern', description='Regular matching of CatalogId', example='.*', position='Query'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is returned from the returned result. If none is returned, an empty string or\\"\\"', example='‘’', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10', minimum=-2, maximum=1000000, position='Query'),
}

model ListCatalogsResponseBody = {
  catalogs?: [
    Catalog
  ](name='Catalogs', description='The catalogs.', example='[{"CatalogId":"xx"}]'),
  code?: string(name='Code', description='Status Code Description', example='OK'),
  message?: string(name='Message', description='The error message that is returned.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='Page Flip token', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the test feature is enabled.', example='true'),
}

model ListCatalogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCatalogsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListCatalogs  ListCatalogsRequest
  * @return ListCatalogsResponse
 */
async function listCatalogs(request: ListCatalogsRequest): ListCatalogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListCatalogs', 'GET', '/api/metastore/catalogs/list', 'json', false, 'json', request);
}

model ListDatabasesRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The namespace of the database category. By default, the Uid of the primary account is entered.', example='1344371', position='Query'),
  namePattern?: string(name='NamePattern', description='The regular expression used to match the database name. If all matches are specified, this parameter is specified. \\*', example='.*', position='Query'),
  nextPageToken?: string(name='NextPageToken', description='The paging token, which is returned by the result. For example, you can specify "" for the first page.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa!', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10', minimum=-2, maximum=1000000, position='Query'),
}

model ListDatabasesResponseBody = {
  code?: string(name='Code', description='Description', example='OK'),
  databases?: [
    Database
  ](name='Databases', description='The list of databases.', example='[{"name":"test"}]'),
  message?: string(name='Message', description='The error message that is returned.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='Page Flip token', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='558D764F-8C55-49CA-BF38-80EA532FC08F'),
  success?: boolean(name='Success', description='Indicates whether the test feature is enabled.', example='true'),
}

model ListDatabasesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDatabasesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListDatabases  ListDatabasesRequest
  * @return ListDatabasesResponse
 */
async function listDatabases(request: ListDatabasesRequest): ListDatabasesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDatabases', 'GET', '/api/metastore/catalogs/databases/list', 'json', false, 'json', request);
}

model ListFunctionNamesRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Query'),
  functionNamePattern?: string(name='FunctionNamePattern', description='The regular expression that matches the function name.', example='.*', position='Query'),
  nextPageToken?: string(name='NextPageToken', description='The pagination token, which is returned from the returned result. If none is returned, an empty string or \\"\\"is passed.', example='\\"\\"', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 1000.', example='10', minimum=-1, maximum=1000000, position='Query'),
}

model ListFunctionNamesResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  functionNames?: [ string ](name='FunctionNames', description='The list of function names.'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model ListFunctionNamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionNamesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListFunctionNames  ListFunctionNamesRequest
  * @return ListFunctionNamesResponse
 */
async function listFunctionNames(request: ListFunctionNamesRequest): ListFunctionNamesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFunctionNames', 'GET', '/api/metastore/catalogs/databases/functions/names', 'json', false, 'json', request);
}

model ListFunctionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Query'),
  functionNamePattern?: string(name='FunctionNamePattern', description='The regular match expression for the user-defined function name.', example='.*', position='Query'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data. If not provided in the response result, a string ("") or empty string (") is empty string.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 1000.', example='10', minimum=-1, maximum=1000000, position='Query'),
}

model ListFunctionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  functions?: [
    Function
  ](name='Functions', description='The details of the functions.'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model ListFunctionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFunctionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListFunctions  ListFunctionsRequest
  * @return ListFunctionsResponse
 */
async function listFunctions(request: ListFunctionsRequest): ListFunctionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFunctions', 'GET', '/api/metastore/catalogs/databases/functions/list', 'json', false, 'json', request);
}

model ListPartitionNamesRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  nextPageToken?: string(name='NextPageToken', description='The pagination token. The token is obtained in the returned results. If no pagination token is returned, set this parameter to an empty string.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa', position='Body'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 1000.', example='10', position='Body'),
  partialPartValues?: [ string ](name='PartialPartValues', description='The values of the partition key columns. You can pass in only the values of specific partition key columns to query the names of all lower-level partitions.', position='Body'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389', position='Body'),
}

model ListPartitionNamesResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  partitionNames?: [ string ](name='PartitionNames', description='The list of partition names.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model ListPartitionNamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPartitionNamesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListPartitionNames  ListPartitionNamesRequest
  * @return ListPartitionNamesResponse
 */
async function listPartitionNames(request: ListPartitionNamesRequest): ListPartitionNamesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPartitionNames', 'POST', '/api/metastore/catalogs/databases/tables/partitions/names', 'json', false, 'json', request);
}

model ListPartitionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  isShareSd?: boolean(name='IsShareSd', description='Specifies whether to share the column information of SD in the partition. Valid values:

*   true: The column information of SD in the partition is shared. In this case, only one copy of data is returned for columns with the same name. This reduces the volume of transferred data and improves the performance of this API operation.
*   false: The column information of SD in the partition is not shared.', example='true', position='Body'),
  nextPageToken?: string(name='NextPageToken', description='The pagination token. The token is obtained in the return results. If no pagination token is returned, set this parameter to an empty string.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa', position='Body'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 1000.', example='10', position='Body'),
  partialPartValues?: [ string ](name='PartialPartValues', description='The list of partition values. You can pass in only the values of specific partitions to query the names of all lower-level partitions.', position='Body'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389', position='Body'),
}

model ListPartitionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs', description='The list of partition specifications.'),
  partitions?: [
    Partition
  ](name='Partitions', description='The list of partitions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model ListPartitionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPartitionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListPartitions  ListPartitionsRequest
  * @return ListPartitionsResponse
 */
async function listPartitions(request: ListPartitionsRequest): ListPartitionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPartitions', 'POST', '/api/metastore/catalogs/databases/tables/partitions/list', 'json', false, 'json', request);
}

model ListPartitionsByExprRequest {
  regionId?: string(name='RegionId', position='Host'),
}

model ListPartitionsByExprResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @description You cannot specify expr to filter partitions. Currently, you need to call the listpartitionsbyfilter to complete the corresponding function.
  * @param request  the request parameters of ListPartitionsByExpr  ListPartitionsByExprRequest
  * @return ListPartitionsByExprResponse
 */
async function listPartitionsByExpr(request: ListPartitionsByExprRequest): ListPartitionsByExprResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPartitionsByExpr', 'POST', '/api/metastore/catalogs/databases/tables/partitions/listbyexpr', 'none', false, 'json', request);
}

model ListPartitionsByFilterRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Body'),
  filter?: string(name='Filter', description='The expression of the query condition. The following operators are supported:

*   Comparison operators: =, <>, ! =, <, <=, >, >=. For example: ds > 20240101.
*   Logical operators: AND, OR, and NOT. Example: ds like \\"20240%\\".
*   BETWEEN operator: specifies a range. For example: ds BETWEEN 20240101 AND 20241201.
*   IN operator: Used to specify a specific set of values. Example: ds IN (20240101, 20240102).', example='ds>20201201', position='Body'),
  isShareSd?: boolean(name='IsShareSd', description='Specifies whether to share the column information in the SD of the partition. Valid values:

*   true: shared
*   false: does not share the data.', example='true', position='Body'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data. If not provided in the response result, a string ("") or empty string (") is empty string.', example='\\"\\"', position='Body'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum size is 1000.', example='10', position='Body'),
  tableName?: string(name='TableName', description='Indicates the name of the table.', example='test_table_20200715162543389', position='Body'),
}

model ListPartitionsByFilterResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  partitionSpecs?: [
    PartitionSpec
  ](name='PartitionSpecs', description='The partition specifications.'),
  partitions?: [
    Partition
  ](name='Partitions', description='The details about the partitions that are queried based on the filter condition.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
}

model ListPartitionsByFilterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPartitionsByFilterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListPartitionsByFilter  ListPartitionsByFilterRequest
  * @return ListPartitionsByFilterResponse
 */
async function listPartitionsByFilter(request: ListPartitionsByFilterRequest): ListPartitionsByFilterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPartitionsByFilter', 'POST', '/api/metastore/catalogs/databases/tables/partitions/listbyfilter', 'json', false, 'json', request);
}

model ListPartitionsProfileRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory. By default, the ID of the primary account is entered.', example='1344371', position='Query'),
  databaseName: string(name='DatabaseName', description='The name of the metadatabase.

This parameter is required.', example='test_db', position='Query'),
  pageNumber?: int32(name='PageNumber', description='Page number', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20', position='Query'),
  partitionNames?: [ string ](name='PartitionNames', description='The names of partitions.', shrink='simple', position='Query'),
  tableName?: string(name='TableName', description='The name of the metadata table.', example='test_tbl', position='Query'),
}

model ListPartitionsProfileResponseBody = {
  code?: string(name='Code', description='The error code.', example='-'),
  data?: [
    PartitionProfile
  ](name='Data', description='The partition data profiles.'),
  latestAccessNumDate?: string(name='LatestAccessNumDate', description='The time when the access frequency is updated. This parameter is obsolete.', example='-'),
  latestDate?: string(name='LatestDate', description='The time when the metadata warehouse was updated.', example='2023-08-30 19:16:10'),
  message?: string(name='Message', description='The error message.', example='-'),
  requestId?: string(name='RequestId', description='The request ID.', example='97434FA4-A6B2-1AE4-A174-76964F29C759'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
  total?: int32(name='Total', description='The total number of entries returned.', example='10'),
}

model ListPartitionsProfileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPartitionsProfileResponseBody(name='body'),
}

/**
  * @description To use a data profile, you must first host the OSS bucket of the table.
  * @param request  the request parameters of ListPartitionsProfile  ListPartitionsProfileRequest
  * @return ListPartitionsProfileResponse
 */
async function listPartitionsProfile(request: ListPartitionsProfileRequest): ListPartitionsProfileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPartitionsProfile', 'GET', '/webapi/metastorehouse/catalog/database/tableprofile/partitionprofile/listPartitionsProfile', 'json', false, 'json', request);
}

model ListPermissionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  isListUserRolePermissions?: boolean(name='IsListUserRolePermissions', description='Specifies whether to obtain the permissions of the role to which the user belongs. This parameter takes effect only when you specify a specific resource object.', example='false', position='Body'),
  metaResource?: MetaResource(name='MetaResource', description='The resource based on which permission information is filtered.', position='Body'),
  metaResourceType?: string(name='MetaResourceType', description='The type of the resource based on which permission information is filtered, such as database or table. If you do not specify this parameter, permission information is filtered based on both databases and tables.', example='DATABASE', position='Body'),
  nextPageToken?: string(name='NextPageToken', description='A pagination token, which is used to obtain data on the next page. If no pagination token is returned in the response, set this parameter to an empty string ("") or an empty character (\\"\\").', example='token!', position='Body'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 1000.', example='100', position='Body'),
  principal?: Principal(name='Principal', description='The principle based on which permission information is filtered.', position='Body'),
  type: string(name='Type', description='The type of permission information to be obtained. Only Hive is supported.

This parameter is required.', example='Hive', position='Body'),
}

model ListPermissionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='token!'),
  principalResourcePermissionsList?: [
    PrincipalResourcePermissions
  ](name='PrincipalResourcePermissionsList', description='The permissions.', example='[]'),
  requestId?: string(name='RequestId', description='The request ID.', example='745EAAE2-5010-5C9F-A95C-B8FC5C1B03BF'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.'),
}

model ListPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPermissionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListPermissions  ListPermissionsRequest
  * @return ListPermissionsResponse
 */
async function listPermissions(request: ListPermissionsRequest): ListPermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPermissions', 'POST', '/api/metastore/auth/permissions/list', 'json', false, 'json', request);
}

model ListRoleUsersRequest {
  regionId?: string(name='RegionId', position='Host'),
  nextPageToken?: string(name='NextPageToken', description='The pagination token, which is returned from the returned result. If none is returned, an empty string or \\"\\"is passed.', example='token!', position='Query'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum value is 1000.', example='-1/100', position='Query'),
  roleName?: string(name='RoleName', description='The name of the role.', example='admin', position='Query'),
  userNamePattern?: string(name='UserNamePattern', description='The regular expression that matches the user name.', example='.*user.*', position='Query'),
}

model ListRoleUsersResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='token!'),
  requestId?: string(name='RequestId', description='The request ID.', example='558D764F-8C55-49CA-BF38-80EA532FC08F'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  userRoles?: [
    UserRole
  ](name='UserRoles', description='The roles assigned to the user.'),
}

model ListRoleUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRoleUsersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListRoleUsers  ListRoleUsersRequest
  * @return ListRoleUsersResponse
 */
async function listRoleUsers(request: ListRoleUsersRequest): ListRoleUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListRoleUsers', 'GET', '/api/metastore/auth/roles/roleusers', 'json', false, 'json', request);
}

model ListRolesRequest {
  regionId?: string(name='RegionId', position='Host'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data. If not provided in the response result, a string ("") or empty string (") is empty string.', example='token!', position='Query'),
  pageSize?: int32(name='PageSize', description='the number of entries returned on each page, the maximum value is 1000.', example='-1/100', position='Query'),
  roleNamePattern?: string(name='RoleNamePattern', description='The regular expression that matches the role name. Fuzzy search is supported, such as.\\*test.\\*.', example='.*test.*', position='Query'),
}

model ListRolesResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  roles?: [
    Role
  ](name='Roles', description='The list of the roles.', example='[
	{
		"Description":"reserved by the system",
		"DisplayName":"admin",
		"UpdateTime":0,
		"IsPredefined":1,
		"Name":"admin"
	}
]'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false.', example='True'),
}

model ListRolesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRolesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListRoles  ListRolesRequest
  * @return ListRolesResponse
 */
async function listRoles(request: ListRolesRequest): ListRolesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListRoles', 'GET', '/api/metastore/auth/roles/list', 'json', false, 'json', request);
}

model ListTableNamesRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Query'),
  nextPageToken?: string(name='NextPageToken', description='The pagination token, which is returned from the returned result. If none is returned, an empty string or \\"\\"is passed.', example='\\"\\"', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10', minimum=-1, maximum=1000000, position='Query'),
  tableNamePattern?: string(name='TableNamePattern', description='The data table name matches the regular expression.', example='.*', position='Query'),
  tableType?: string(name='TableType', description='The type of the data table. Valid values:

MANAGED_TABLE: internal table

EXTERNAL_TABLE: foreign table

VIRTUAL_VIEW: virtual view

INDEX_TABLE: index table

MATERIALIZED_VIEW: materialized view.', example='MANAGED_TABLE', position='Query'),
}

model ListTableNamesResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
  tableNames?: [ string ](name='TableNames', description='The names of the data tables.'),
}

model ListTableNamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTableNamesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListTableNames  ListTableNamesRequest
  * @return ListTableNamesResponse
 */
async function listTableNames(request: ListTableNamesRequest): ListTableNamesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTableNames', 'GET', '/api/metastore/catalogs/databases/tables/names', 'json', false, 'json', request);
}

model ListTableVersionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Query'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data. If not provided in the response result, a string ("") or empty string (") is empty string.', example='\\"\\"', position='Query'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum value is 1000.', example='10', position='Query'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389', position='Query'),
}

model ListTableVersionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
  tableVersions?: [
    TableVersion
  ](name='TableVersions', description='The data tables of multiple versions.'),
}

model ListTableVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTableVersionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListTableVersions  ListTableVersionsRequest
  * @return ListTableVersionsResponse
 */
async function listTableVersions(request: ListTableVersionsRequest): ListTableVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTableVersions', 'GET', '/api/metastore/catalogs/databases/tables/versions/list', 'json', false, 'json', request);
}

model ListTablesRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The ID of the data directory.', example='1344371', position='Query'),
  databaseName?: string(name='DatabaseName', description='The name of a database.', example='database_test', position='Query'),
  nextPageToken?: string(name='NextPageToken', description='The pagination token, which is returned from the returned result. If none is returned, an empty string or \\"\\"is passed.', example='\\"\\"', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10', minimum=-1, maximum=1000000, position='Query'),
  tableNamePattern?: string(name='TableNamePattern', description='The name of the data table, which is matched by a regular expression.', example='.*', position='Query'),
  tableType?: string(name='TableType', description='The type of the data table. Valid values:

*   MANAGED_TABLE: internal table
*   EXTERNAL_TABLE: foreign table
*   VIRTUAL_VIEW: virtual view
*   INDEX_TABLE: index table
*   MATERIALIZED_VIEW: materialized view.', example='MANAGED_TABLE', position='Query'),
}

model ListTablesResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The paging token.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  tables?: [
    Table
  ](name='Tables', description='The list of data tables.', example='[{"TableName":"xx"}]'),
}

model ListTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTablesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListTables  ListTablesRequest
  * @return ListTablesResponse
 */
async function listTables(request: ListTablesRequest): ListTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTables', 'GET', '/api/metastore/databases/tables/list', 'json', false, 'json', request);
}

model ListUserRolesRequest {
  regionId?: string(name='RegionId', position='Host'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data. If not provided in the response result, a string ("") or empty string (") is empty string.', example='token!', position='Query'),
  pageSize?: int32(name='PageSize', description='The size of each page. The maximum value is 1000.', example='-1/100', position='Query'),
  principalArn?: string(name='PrincipalArn', description='Used to uniquely identify a RAM user or RAM role. The OSS URL is in the following format:

*   RAM user: acs:ram::[accountId]:user/[userName].
*   RAM role: acs:ram::[accountId]:role/[roleName].', example='acs:ram::1111:user/userName', position='Query'),
  roleNamePattern?: string(name='RoleNamePattern', description='The regular expression that matches the role name. Fuzzy search is supported.', example='.*test.*', position='Query'),
}

model ListUserRolesResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  nextPageToken?: string(name='NextPageToken', description='The page turning token, which is used to obtain the next page of data.', example='2cb472ec1bf84f8d92f9c4baa0d21c19aa'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
  userRoles?: [
    UserRole
  ](name='UserRoles', description='The roles assigned to the user.'),
}

model ListUserRolesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserRolesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListUserRoles  ListUserRolesRequest
  * @return ListUserRolesResponse
 */
async function listUserRoles(request: ListUserRolesRequest): ListUserRolesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListUserRoles', 'GET', '/api/metastore/auth/roles/userroles', 'json', false, 'json', request);
}

model RefreshLockRequest {
  regionId?: string(name='RegionId', position='Host'),
  lockId?: long(name='LockId', description='The lock ID.', example='12324', position='Query'),
}

model RefreshLockResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The returned message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='81B90E1B-7514-5817-9D59-0EA9E2215876'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false.', example='True'),
}

model RefreshLockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RefreshLockResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RefreshLock  RefreshLockRequest
  * @return RefreshLockResponse
 */
async function refreshLock(request: RefreshLockRequest): RefreshLockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RefreshLock', 'PUT', '/api/metastore/catalogs/databases/tables/locks', 'json', false, 'json', request);
}

model RegisterLocationRequest {
  regionId?: string(name='RegionId', position='Host'),
  inventoryCollectEnabled?: boolean(name='InventoryCollectEnabled', description='Whether to enable OSS bucket inventory', example='true', position='Body'),
  location: string(name='Location', description='Registered OSS path

This parameter is required.', example='oss://mybucket/', position='Body'),
  ossLogCollectEnabled?: boolean(name='OssLogCollectEnabled', description='Whether to enable OSS log storage', example='true', position='Body'),
  roleName: string(name='RoleName', description='RAM role name

>  Data Lake Formation read and write data in the OSS path. If you want to AliyunDLFWorkFlowDefaultRole a role, the role is automatically built in to the role. Alternatively, you can create a custom role, but you must manually ensure that the role has the read and write permissions on the corresponding path.

This parameter is required.', example='AliyunDLFWorkFlowDefaultRole', position='Body'),
}

model RegisterLocationResponseBody = {
  data?: {
    locationId?: string(name='LocationId', description='Location ID', example='LOC-AB8FBC17F95A4AF5'),
    storageCollectTaskOperationResultList?: [
      StorageCollectTaskOperationResult
    ](name='StorageCollectTaskOperationResultList', description='The list of collection tasks that are enabled.'),
  }(name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='3C2678BA-3451-14C3-90E2-D4EF5B4E7A84'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true.
*   false: The request failed.', example='true'),
}

model RegisterLocationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RegisterLocationResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RegisterLocation  RegisterLocationRequest
  * @return RegisterLocationResponse
 */
async function registerLocation(request: RegisterLocationRequest): RegisterLocationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RegisterLocation', 'POST', '/webapi/locations', 'json', false, 'json', request);
}

model RenamePartitionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  partitionInput?: PartitionInput(name='PartitionInput', description='The renamed partition information, which is the same as the partition information you specify for the CreatePartition operation.', position='Body'),
  partitionValues?: [ string ](name='PartitionValues', description='The values of the partition key columns.', position='Body'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20200715162543389', position='Body'),
}

model RenamePartitionResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model RenamePartitionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenamePartitionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RenamePartition  RenamePartitionRequest
  * @return RenamePartitionResponse
 */
async function renamePartition(request: RenamePartitionRequest): RenamePartitionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RenamePartition', 'POST', '/api/metastore/catalogs/databases/tables/partitions/rename', 'json', false, 'json', request);
}

model RenameTableRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  isAsync?: boolean(name='IsAsync', description='Specifies whether to asynchronously rename the data table. Valid values:

*   false (default): The operation is synchronously called. The update result is returned after the background task is complete. If the execution of the background task requires an extended period of time, a timeout occurs.
*   true: The operation is asynchronously called. The update result is immediately returned. You can query the task status by TaskId in the returned result.', example='false', position='Body'),
  tableInput?: TableInput(name='TableInput', description='The data table object. You need only to specify the TableName parameter in this object.', position='Body'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223', position='Body'),
}

model RenameTableResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request is successful.
*   false', example='true'),
  taskId?: string(name='TaskId', description='The ID of the asynchronous task.', example='c38206c3aca0c41332ffe49294243009'),
}

model RenameTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenameTableResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RenameTable  RenameTableRequest
  * @return RenameTableResponse
 */
async function renameTable(request: RenameTableRequest): RenameTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RenameTable', 'PUT', '/api/metastore/catalogs/databases/tables/rename', 'json', false, 'json', request);
}

model RevokePermissionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  accesses: [ string ](name='Accesses', description='The access permissions that need to be revoked.

This parameter is required.', position='Body'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  delegateAccesses?: [ string ](name='DelegateAccesses', description='The grantable access permissions that need to be revoked. This parameter is unavailable.', position='Body'),
  metaResource: MetaResource(name='MetaResource', description='The metadata resource for which permissions need to be revoked.

This parameter is required.', position='Body'),
  principal: Principal(name='Principal', description='The user or role whose permissions need to be revoked. Formats:

*   RAM user: acs:ram::[accountId]:user/[userName]
*   RAM role: acs:ram::[accountId]:role/[roleName]
*   Data lake role: acs:dlf::[accountId]:role/[roleName]

This parameter is required.', position='Body'),
  type: string(name='Type', description='The permission revocation type. Only Hive is supported.

This parameter is required.', example='Hive', position='Body'),
}

model RevokePermissionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The returned message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7CB5765C-F209-5B10-8792-D2BE9156ABE8'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model RevokePermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokePermissionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RevokePermissions  RevokePermissionsRequest
  * @return RevokePermissionsResponse
 */
async function revokePermissions(request: RevokePermissionsRequest): RevokePermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RevokePermissions', 'POST', '/api/metastore/auth/permissions/revoke', 'json', false, 'json', request);
}

model RevokeRoleFromUsersRequest {
  regionId?: string(name='RegionId', position='Host'),
  roleName?: string(name='RoleName', description='The role that you want to revoke from users.', example='test_role_3', position='Body'),
  users?: [
Principal
](name='Users', description='The RAM users or roles from which you want to revoke the role. Format:

*   RAM user: acs:ram::[accountId]:user/[userName].
*   RAM role: acs:ram::[accountId]:role/[roleName].', position='Body'),
}

model RevokeRoleFromUsersResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model RevokeRoleFromUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokeRoleFromUsersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RevokeRoleFromUsers  RevokeRoleFromUsersRequest
  * @return RevokeRoleFromUsersResponse
 */
async function revokeRoleFromUsers(request: RevokeRoleFromUsersRequest): RevokeRoleFromUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RevokeRoleFromUsers', 'PUT', '/api/metastore/auth/roles/revokeusers', 'json', false, 'json', request);
}

model RevokeRolesFromUserRequest {
  regionId?: string(name='RegionId', position='Host'),
  roleNames: [ string ](name='RoleNames', description='The RAM roles to be revoked from the RAM user.

This parameter is required.', position='Body'),
  user: Principal(name='User', description='The RAM user from whom you want to revoke roles. Format:

*   RAM roles: acs:ram::[accountId]:role/[roleName].
*   RAM user: acs:ram::[accountId]:user/[userName].

This parameter is required.', position='Body'),
}

model RevokeRolesFromUserResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model RevokeRolesFromUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokeRolesFromUserResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RevokeRolesFromUser  RevokeRolesFromUserRequest
  * @return RevokeRolesFromUserResponse
 */
async function revokeRolesFromUser(request: RevokeRolesFromUserRequest): RevokeRolesFromUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RevokeRolesFromUser', 'POST', '/api/metastore/auth/roles/revokeroles', 'json', false, 'json', request);
}

model RunMigrationWorkflowRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the migration instance.

This parameter is required.', example='M-EDD8BF959BB97345', position='Query'),
}

model RunMigrationWorkflowResponseBody = {
  data?: string(name='Data', description='The returned data. The value is the ID of the workflow instance.', example='FI-7193B85809CAD95C'),
  requestId?: string(name='RequestId', description='The request ID.', example='A048EA8E-3519-5B18-B81E-EE3E0B6DBE0C'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model RunMigrationWorkflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RunMigrationWorkflowResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RunMigrationWorkflow  RunMigrationWorkflowRequest
  * @return RunMigrationWorkflowResponse
 */
async function runMigrationWorkflow(request: RunMigrationWorkflowRequest): RunMigrationWorkflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RunMigrationWorkflow', 'POST', '/webapi/migration/workflow/run', 'json', false, 'json', request);
}

model SearchRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='catalogid', example='1344371', position='Body'),
  pageNumber?: long(name='PageNumber', description='The page number.', example='1', position='Body'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='1000', position='Body'),
  searchText?: string(name='SearchText', description='The search text.', example='tags:tag1 or comment:^iso and name=aliyun and (createTime > "20211111" and createTime < "20211117") and has category', position='Body'),
  searchType?: string(name='SearchType', description='The search type.', example='TABLE/DATABASE/CATALOG', position='Body'),
  sortCriteria?: [
    SortCriterion
  ](name='SortCriteria', description='The sorting rules.', position='Body'),
}

model SearchResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  databaseResult?: {
    databases?: [ 
      {
        database?: Database(name='Database', description='The returned database.'),
        highLightList?: [
          HighLight
        ](name='HighLightList', description='The returned highlighted text.'),
      }
    ](name='Databases', description='The returned databases.'),
    totalCount?: long(name='TotalCount', description='Total number of databases that meet the match conditions', example='11000'),
  }(name='DatabaseResult', description='The returned database information.'),
  message?: string(name='Message', description='Response', example='""'),
  requestId?: string(name='RequestId', description='The request ID.', example='460C862F-BB91-5C04-BC3F-946EEF467862'),
  success?: boolean(name='Success', description='Indicates whether the information about the service was queried.', example='True'),
  tableResult?: {
    tables?: [ 
      {
        highLightList?: [
          HighLight
        ](name='HighLightList', description='The returned highlighted text.'),
        table?: Table(name='Table', description='The returned table.'),
      }
    ](name='Tables', description='The returned tables.'),
    totalCount?: long(name='TotalCount', description='The total number of tables that meet the match conditions.', example='1100'),
  }(name='TableResult', description='The returned table information.'),
}

model SearchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchResponseBody(name='body'),
}

/**
  * @description Metadata search
  * @param request  the request parameters of Search  SearchRequest
  * @return SearchResponse
 */
async function search(request: SearchRequest): SearchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'Search', 'POST', '/api/metastore/catalogs/search', 'json', false, 'json', request);
}

model SearchAcrossCatalogRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogIds?: [ string ](name='CatalogIds', description='The catalog IDs. If this parameter is empty, all catalogs are queried.', position='Body'),
  pageNumber?: long(name='PageNumber', description='The page number of the queried page.', example='1', position='Body'),
  pageSize?: long(name='PageSize', description='The number of entries on the queried page.', example='1000', position='Body'),
  searchText?: string(name='SearchText', description='The search text.', example='tags:tag1 or comment:^iso and name=aliyun and (createTime > "20211111" and createTime < "20211117") and has category', position='Body'),
  searchTypes?: [ string ](name='SearchTypes', description='The search types. Valid values: ALL, CATALOG, DATABASE, and TABLE.', position='Body'),
  sortCriteria?: [
    SortCriterion
  ](name='SortCriteria', description='The sorting rules.', position='Body'),
}

model SearchAcrossCatalogResponseBody = {
  catalogResult?: {
    catalogs?: [ 
      {
        catalog?: Catalog(name='Catalog', description='The returned catalog.'),
        highLightList?: [
          HighLight
        ](name='HighLightList', description='The returned highlighted text.'),
      }
    ](name='Catalogs', description='The returned catalogs.'),
    totalCount?: long(name='TotalCount', description='Total number of catalogs that meet the match conditions', example='100'),
  }(name='CatalogResult', description='The returned catalog information.'),
  code?: string(name='Code', description='The response code.', example='OK'),
  databaseResult?: {
    databases?: [ 
      {
        database?: Database(name='Database', description='The returned database.'),
        highLightList?: [
          HighLight
        ](name='HighLightList', description='The returned highlighted text.'),
      }
    ](name='Databases', description='The returned databases.'),
    totalCount?: long(name='TotalCount', description='Total number of databases that meet the match conditions', example='11000'),
  }(name='DatabaseResult', description='The returned database information.'),
  message?: string(name='Message', description='Response', example='""'),
  requestId?: string(name='RequestId', description='The request ID.', example='460C862F-BB91-5C04-BC3F-946EEF467862'),
  success?: boolean(name='Success', description='Indicates whether the information about the service was queried.', example='True'),
  tableResult?: {
    tables?: [ 
      {
        highLightList?: [
          HighLight
        ](name='HighLightList', description='The returned highlighted text.'),
        table?: Table(name='Table', description='The returned table.'),
      }
    ](name='Tables', description='The returned tables.'),
    totalCount?: long(name='TotalCount', description='The total number of tables that meet the match conditions.', example='1100'),
  }(name='TableResult', description='The returned table information.'),
}

model SearchAcrossCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchAcrossCatalogResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SearchAcrossCatalog  SearchAcrossCatalogRequest
  * @return SearchAcrossCatalogResponse
 */
async function searchAcrossCatalog(request: SearchAcrossCatalogRequest): SearchAcrossCatalogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'SearchAcrossCatalog', 'POST', '/api/metastore/catalogs/search/search-across-catalog', 'json', false, 'json', request);
}

model StopMigrationWorkflowRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the migration task instance.

This parameter is required.', example='M-6DCF5D8EF92E2195', position='Query'),
}

model StopMigrationWorkflowResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the test feature is enabled.', example='true'),
}

model StopMigrationWorkflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopMigrationWorkflowResponseBody(name='body'),
}

/**
  * @param request  the request parameters of StopMigrationWorkflow  StopMigrationWorkflowRequest
  * @return StopMigrationWorkflowResponse
 */
async function stopMigrationWorkflow(request: StopMigrationWorkflowRequest): StopMigrationWorkflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StopMigrationWorkflow', 'PUT', '/webapi/migration/workflow/stop', 'json', false, 'json', request);
}

model SubmitQueryRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='catalogId', description='The ID of the data directory.', example='catalog1', position='Body'),
  sql?: string(name='sql', description='The SQL statement.', example='show databases', position='Body'),
  workspaceId?: string(name='workspaceId', description='The workspace ID.', example='WS-A129E61C4892D2B4', position='Body'),
}

model SubmitQueryResponseBody = {
  data?: string(name='Data', description='The data returned', example='Q-14475CF9B51FCE5E'),
  requestId?: string(name='RequestId', description='The request ID.', example='279AA630-A8ED-5EA9-80A3-2E213D63548C'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model SubmitQueryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SubmitQueryResponseBody(name='body'),
}

/**
  * @description *   Only suitable for submitting small and medium-sized queries. The execution time cannot exceed 1 hour.
  * *   A maximum of 10000 query results can be returned.
  * *   There are limits on concurrent execution under a single master account. If multiple queries are submitted at the same time, they will be queued.
  * @param request  the request parameters of SubmitQuery  SubmitQueryRequest
  * @return SubmitQueryResponse
 */
async function submitQuery(request: SubmitQueryRequest): SubmitQueryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'SubmitQuery', 'POST', '/webapi/query/submitQueryRequestBody', 'json', false, 'json', request);
}

model UnLockRequest {
  regionId?: string(name='RegionId', position='Host'),
  lockId?: long(name='LockId', description='The lock ID.', example='11709', position='Query'),
}

model UnLockResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='37C8470A-5E6D-5E4E-AEF0-EA3EBE9C89EE'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model UnLockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnLockResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UnLock  UnLockRequest
  * @return UnLockResponse
 */
async function unLock(request: UnLockRequest): UnLockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UnLock', 'DELETE', '/api/metastore/catalogs/databases/tables/locks', 'json', false, 'json', request);
}

model UpdateCatalogRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogInput: CatalogInput(name='CatalogInput', description='The structure that is used to create or update the catalog.

This parameter is required.', position='Body'),
}

model UpdateCatalogResponseBody = {
  code?: string(name='Code', description='Response encoding.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='64E46067-49EA-5A91-A7B1-E812E18FC243'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request is successful.
*   false: The request failed.', example='true'),
}

model UpdateCatalogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCatalogResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCatalog  UpdateCatalogRequest
  * @return UpdateCatalogResponse
 */
async function updateCatalog(request: UpdateCatalogRequest): UpdateCatalogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateCatalog', 'PUT', '/api/metastore/catalogs', 'json', false, 'json', request);
}

model UpdateCatalogSettingsRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  catalogSettings?: CatalogSettings(name='CatalogSettings', description='The catalog configuration.', position='Body'),
}

model UpdateCatalogSettingsResponseBody = {
  code?: string(name='Code', description='The HTTP status code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='01D8DD6B-4929-5999-9BB3-950AA30E3BD0'),
  success?: boolean(name='Success', description='Whether the operation is successful. Valid values:

*   true: The request was successful.
*   false: The operation failed.', example='true'),
}

model UpdateCatalogSettingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCatalogSettingsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCatalogSettings  UpdateCatalogSettingsRequest
  * @return UpdateCatalogSettingsResponse
 */
async function updateCatalogSettings(request: UpdateCatalogSettingsRequest): UpdateCatalogSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateCatalogSettings', 'POST', '/api/metastore/catalogs/settings', 'json', false, 'json', request);
}

model UpdateDatabaseRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseInput?: DatabaseInput(name='DatabaseInput', description='The information about the updated database.', position='Body'),
  name?: string(name='Name', description='The name of the database before the update. If the database name remains the same after the update, only other information in the DatabaseInput parameter is updated.', example='database_test', position='Body'),
}

model UpdateDatabaseResponseBody = {
  code?: string(name='Code', description='The description of the distribution status.', example='OK'),
  message?: string(name='Message', description='A related error message is displayed.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='161F5EFC-E97E-43C0-AACF-FF18FAC912F0'),
  success?: boolean(name='Success', description='Indicates whether the operation was successful. Valid values:

*   true: The request is successful.
*   false: The request failed.', example='true'),
}

model UpdateDatabaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDatabaseResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateDatabase  UpdateDatabaseRequest
  * @return UpdateDatabaseResponse
 */
async function updateDatabase(request: UpdateDatabaseRequest): UpdateDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateDatabase', 'PUT', '/api/metastore/catalogs/databases', 'json', false, 'json', request);
}

model UpdateFunctionRequest {
  regionId?: string(name='RegionId', position='Host'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  functionInput?: FunctionInput(name='FunctionInput', description='The details about the function to be updated.', position='Body'),
  functionName?: string(name='FunctionName', description='The function name.', example='func2', position='Body'),
}

model UpdateFunctionResponseBody = {
  code?: string(name='Code', description='The response code.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model UpdateFunctionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFunctionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateFunction  UpdateFunctionRequest
  * @return UpdateFunctionResponse
 */
async function updateFunction(request: UpdateFunctionRequest): UpdateFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateFunction', 'PUT', '/api/metastore/catalogs/databases/functions', 'json', false, 'json', request);
}

model UpdatePartitionColumnStatisticsRequest {
  regionId?: string(name='RegionId', position='Host'),
  updateTablePartitionColumnStatisticsRequest?: UpdateTablePartitionColumnStatisticsRequest(name='UpdateTablePartitionColumnStatisticsRequest', description='The request to update partition column statistics in the data table.', position='Body'),
}

model UpdatePartitionColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model UpdatePartitionColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePartitionColumnStatisticsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdatePartitionColumnStatistics  UpdatePartitionColumnStatisticsRequest
  * @return UpdatePartitionColumnStatisticsResponse
 */
async function updatePartitionColumnStatistics(request: UpdatePartitionColumnStatisticsRequest): UpdatePartitionColumnStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdatePartitionColumnStatistics', 'PUT', '/api/metastore/catalogs/databases/tables/partitions/columnstatistics', 'json', false, 'json', request);
}

model UpdatePermissionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  accesses: [ string ](name='Accesses', description='The list of access permissions to be authorized.

This parameter is required.', position='Body'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  delegateAccesses: [ string ](name='DelegateAccesses', description='The list of access permissions that can be delegated. This parameter is unavailable.

This parameter is required.', position='Body'),
  metaResource: MetaResource(name='MetaResource', description='The metadata resource to be authorized.

This parameter is required.', position='Body'),
  principal: Principal(name='Principal', description='The authorized users or roles. Formats:

*   RAM user: acs:ram::[accountId]:user/[userName]
*   RAM role: acs:ram::[accountId]:role/[roleName]
*   Data lake role: acs:dlf::[accountId]:role/[roleName]

This parameter is required.', position='Body'),
  type: string(name='Type', description='The type of the authorization. Only Hive is supported.

This parameter is required.', example='Hive', position='Body'),
}

model UpdatePermissionsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model UpdatePermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePermissionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdatePermissions  UpdatePermissionsRequest
  * @return UpdatePermissionsResponse
 */
async function updatePermissions(request: UpdatePermissionsRequest): UpdatePermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdatePermissions', 'PUT', '/api/metastore/auth/permissions/', 'json', false, 'json', request);
}

model UpdateRegisteredLocationRequest {
  regionId?: string(name='RegionId', position='Host'),
  inventoryCollectEnabled?: boolean(name='InventoryCollectEnabled', description='Whether to enable OSS bucket inventory', example='true', position='Body'),
  locationId: string(name='LocationId', description='Location ID

>  You can call the RegisterLocation operation to obtain the Location ID.

This parameter is required.', example='LOC-AB8FBC17F95A4AF5', position='Body'),
  ossLogCollectEnabled?: boolean(name='OssLogCollectEnabled', description='Whether to enable OSS log storage', example='true', position='Body'),
}

model UpdateRegisteredLocationResponseBody = {
  data?: {
    locationId?: string(name='LocationId', description='Location ID', example='LOC-AB8FBC17F95A4AF5'),
    storageCollectTaskOperationResultList?: [
      StorageCollectTaskOperationResult
    ](name='StorageCollectTaskOperationResultList', description='The list of collection tasks that are updated.'),
  }(name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='8030C902-C25B-1839-867D-E6F70A5B9810'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true.
*   false: The request failed.', example='true'),
}

model UpdateRegisteredLocationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRegisteredLocationResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateRegisteredLocation  UpdateRegisteredLocationRequest
  * @return UpdateRegisteredLocationResponse
 */
async function updateRegisteredLocation(request: UpdateRegisteredLocationRequest): UpdateRegisteredLocationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateRegisteredLocation', 'PUT', '/webapi/locations', 'json', false, 'json', request);
}

model UpdateRoleRequest {
  regionId?: string(name='RegionId', position='Host'),
  roleInput?: RoleInput(name='RoleInput', description='The input information of the updated role.', position='Body'),
  roleName?: string(name='RoleName', description='The role name.', example='原始名称', position='Body'),
}

model UpdateRoleResponseBody = {
  code?: string(name='Code', description='The status of the request.', example='OK'),
  message?: string(name='Message', description='The returned message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='604E5919-C6FF-54CE-9C23-C5350E6F5415'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false', example='true'),
}

model UpdateRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRoleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateRole  UpdateRoleRequest
  * @return UpdateRoleResponse
 */
async function updateRole(request: UpdateRoleRequest): UpdateRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateRole', 'PUT', '/api/metastore/auth/roles', 'json', false, 'json', request);
}

model UpdateRoleUsersRequest {
  regionId?: string(name='RegionId', position='Host'),
  roleName?: string(name='RoleName', description='The name of the role.', example='test_role_8', position='Body'),
  users?: [
Principal
](name='Users', description='The list of users or roles. Format:

RAM user: acs:ram::[accountId]:user/[userName]

RAM role: acs:ram::[accountId]:role/[roleName]', position='Body'),
}

model UpdateRoleUsersResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request was successful.
*   false', example='true'),
}

model UpdateRoleUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRoleUsersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateRoleUsers  UpdateRoleUsersRequest
  * @return UpdateRoleUsersResponse
 */
async function updateRoleUsers(request: UpdateRoleUsersRequest): UpdateRoleUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateRoleUsers', 'POST', '/api/metastore/auth/updateroleusers', 'json', false, 'json', request);
}

model UpdateTableRequest {
  regionId?: string(name='RegionId', position='Host'),
  allowPartitionKeyChange?: boolean(name='AllowPartitionKeyChange', description='Specifies whether the partition key can be updated.', example='false', position='Body'),
  catalogId?: string(name='CatalogId', description='The catalog ID.', example='1344371', position='Body'),
  databaseName?: string(name='DatabaseName', description='The database name.', example='database_test', position='Body'),
  isAsync?: boolean(name='IsAsync', description='Specifies whether to synchronously update the data table.', example='true', position='Body'),
  skipArchive?: boolean(name='SkipArchive', description='By default, if a data table is updated, a backup version of the data table is created. However, if you set the skipArchive parameter to true, no backup version is created.', example='false', position='Body'),
  tableInput?: TableInput(name='TableInput', description='The details about the updated data table.', position='Body'),
  tableName?: string(name='TableName', description='The name of the data table.', example='test_table_20201223', position='Body'),
}

model UpdateTableResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The response message.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true
*   false', example='true'),
  taskId?: string(name='TaskId', description='The ID of the asynchronous task.', example='aa689782deb97265701f57324fc4ae42'),
}

model UpdateTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateTableResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateTable  UpdateTableRequest
  * @return UpdateTableResponse
 */
async function updateTable(request: UpdateTableRequest): UpdateTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateTable', 'PUT', '/api/metastore/catalogs/databases/tables', 'json', false, 'json', request);
}

model UpdateTableColumnStatisticsRequest {
  regionId?: string(name='RegionId', position='Host'),
  updateTablePartitionColumnStatisticsRequest?: UpdateTablePartitionColumnStatisticsRequest(name='UpdateTablePartitionColumnStatisticsRequest', description='The request to update statistics.', position='Body'),
}

model UpdateTableColumnStatisticsResponseBody = {
  code?: string(name='Code', description='The returned message.', example='OK'),
  message?: string(name='Message', description='The error message that is returned.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7F4B621-E41E-4C84-B97F-42B5380A32BB'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values: Valid values:

*   true: The request is successful.
*   false: The request failed.', example='true'),
}

model UpdateTableColumnStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateTableColumnStatisticsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateTableColumnStatistics  UpdateTableColumnStatisticsRequest
  * @return UpdateTableColumnStatisticsResponse
 */
async function updateTableColumnStatistics(request: UpdateTableColumnStatisticsRequest): UpdateTableColumnStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateTableColumnStatistics', 'PUT', '/api/metastore/catalogs/databases/tables/columnstatistics', 'json', false, 'json', request);
}

model TableExtendedPrivilegesRolePrivilegesValue = {
  createTime?: int32(name='CreateTime'),
  grantOption?: boolean(name='GrantOption'),
  grantor?: string(name='Grantor'),
  grantorType?: string(name='GrantorType'),
  privilege?: string(name='Privilege'),
}

model TableExtendedPrivilegesUserPrivilegesValue = {
  createTime?: int32(name='CreateTime'),
  grantOption?: boolean(name='GrantOption'),
  grantor?: string(name='Grantor'),
  grantorType?: string(name='GrantorType'),
  privilege?: string(name='Privilege'),
}

model TableExtendedPrivilegesGroupPrivilegesValue = {
  createTime?: int32(name='CreateTime'),
  grantOption?: boolean(name='GrantOption'),
  grantor?: string(name='Grantor'),
  grantorType?: string(name='GrantorType'),
  privilege?: string(name='Privilege'),
}

