/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('iovcc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddUploadedFunctionFileInfoRequest {
  fileName?: string(name='FileName'),
  objectKey?: string(name='ObjectKey'),
  projectId?: string(name='ProjectId'),
}

model AddUploadedFunctionFileInfoResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddUploadedFunctionFileInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddUploadedFunctionFileInfoResponseBody(name='body'),
}

async function addUploadedFunctionFileInfoWithOptions(request: AddUploadedFunctionFileInfoRequest, runtime: Util.RuntimeOptions): AddUploadedFunctionFileInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.objectKey)) {
    query['ObjectKey'] = request.objectKey;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddUploadedFunctionFileInfo',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addUploadedFunctionFileInfo(request: AddUploadedFunctionFileInfoRequest): AddUploadedFunctionFileInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUploadedFunctionFileInfoWithOptions(request, runtime);
}

model AddVersionBlackDevicesRequest {
  deviceIdType?: string(name='DeviceIdType'),
  deviceIds?: string(name='DeviceIds'),
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model AddVersionBlackDevicesResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddVersionBlackDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddVersionBlackDevicesResponseBody(name='body'),
}

async function addVersionBlackDevicesWithOptions(request: AddVersionBlackDevicesRequest, runtime: Util.RuntimeOptions): AddVersionBlackDevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceIdType)) {
    query['DeviceIdType'] = request.deviceIdType;
  }
  if (!Util.isUnset(request.deviceIds)) {
    query['DeviceIds'] = request.deviceIds;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddVersionBlackDevices',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addVersionBlackDevices(request: AddVersionBlackDevicesRequest): AddVersionBlackDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVersionBlackDevicesWithOptions(request, runtime);
}

model AddVersionGroupDevicesRequest {
  deviceGroupId?: string(name='DeviceGroupId'),
  deviceIdType?: string(name='DeviceIdType'),
  deviceIds?: string(name='DeviceIds'),
  projectId?: string(name='ProjectId'),
}

model AddVersionGroupDevicesResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddVersionGroupDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddVersionGroupDevicesResponseBody(name='body'),
}

async function addVersionGroupDevicesWithOptions(request: AddVersionGroupDevicesRequest, runtime: Util.RuntimeOptions): AddVersionGroupDevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceGroupId)) {
    query['DeviceGroupId'] = request.deviceGroupId;
  }
  if (!Util.isUnset(request.deviceIdType)) {
    query['DeviceIdType'] = request.deviceIdType;
  }
  if (!Util.isUnset(request.deviceIds)) {
    query['DeviceIds'] = request.deviceIds;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddVersionGroupDevices',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addVersionGroupDevices(request: AddVersionGroupDevicesRequest): AddVersionGroupDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVersionGroupDevicesWithOptions(request, runtime);
}

model AddVersionWhiteDevicesRequest {
  deviceIdType?: string(name='DeviceIdType'),
  deviceIds?: string(name='DeviceIds'),
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model AddVersionWhiteDevicesResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddVersionWhiteDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddVersionWhiteDevicesResponseBody(name='body'),
}

async function addVersionWhiteDevicesWithOptions(request: AddVersionWhiteDevicesRequest, runtime: Util.RuntimeOptions): AddVersionWhiteDevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceIdType)) {
    query['DeviceIdType'] = request.deviceIdType;
  }
  if (!Util.isUnset(request.deviceIds)) {
    query['DeviceIds'] = request.deviceIds;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddVersionWhiteDevices',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addVersionWhiteDevices(request: AddVersionWhiteDevicesRequest): AddVersionWhiteDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVersionWhiteDevicesWithOptions(request, runtime);
}

model AddVersionWhiteDevicesByDeviceGroupsRequest {
  groupIds?: string(name='GroupIds'),
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model AddVersionWhiteDevicesByDeviceGroupsResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model AddVersionWhiteDevicesByDeviceGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddVersionWhiteDevicesByDeviceGroupsResponseBody(name='body'),
}

async function addVersionWhiteDevicesByDeviceGroupsWithOptions(request: AddVersionWhiteDevicesByDeviceGroupsRequest, runtime: Util.RuntimeOptions): AddVersionWhiteDevicesByDeviceGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupIds)) {
    query['GroupIds'] = request.groupIds;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddVersionWhiteDevicesByDeviceGroups',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addVersionWhiteDevicesByDeviceGroups(request: AddVersionWhiteDevicesByDeviceGroupsRequest): AddVersionWhiteDevicesByDeviceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVersionWhiteDevicesByDeviceGroupsWithOptions(request, runtime);
}

model ConnectAssistDeviceRequest {
  allowCommandExtension?: boolean(name='AllowCommandExtension'),
  deviceId?: string(name='DeviceId'),
  hardwareId?: string(name='HardwareId'),
  projectId?: string(name='ProjectId'),
  serialNumber?: string(name='SerialNumber'),
  UUID?: string(name='UUID'),
  VIN?: string(name='VIN'),
}

model ConnectAssistDeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConnectAssistDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConnectAssistDeviceResponseBody(name='body'),
}

async function connectAssistDeviceWithOptions(request: ConnectAssistDeviceRequest, runtime: Util.RuntimeOptions): ConnectAssistDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.allowCommandExtension)) {
    body['AllowCommandExtension'] = request.allowCommandExtension;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.hardwareId)) {
    body['HardwareId'] = request.hardwareId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.serialNumber)) {
    body['SerialNumber'] = request.serialNumber;
  }
  if (!Util.isUnset(request.UUID)) {
    body['UUID'] = request.UUID;
  }
  if (!Util.isUnset(request.VIN)) {
    body['VIN'] = request.VIN;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ConnectAssistDevice',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function connectAssistDevice(request: ConnectAssistDeviceRequest): ConnectAssistDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return connectAssistDeviceWithOptions(request, runtime);
}

model CountActivatedOrNewRegistrationDeviceRequest {
  deviceBrand?: string(name='DeviceBrand'),
  deviceBrandId?: string(name='DeviceBrandId'),
  deviceCountStatType?: string(name='DeviceCountStatType'),
  deviceModel?: string(name='DeviceModel'),
  deviceModelId?: string(name='DeviceModelId'),
  deviceType?: string(name='DeviceType'),
  endTime?: string(name='EndTime'),
  isQueryNewRegistrationDevice?: string(name='IsQueryNewRegistrationDevice'),
  isQueryYearlyActivate?: string(name='IsQueryYearlyActivate'),
  projectId?: string(name='ProjectId'),
  startTime?: string(name='StartTime'),
}

model CountActivatedOrNewRegistrationDeviceResponseBody = {
  requestId?: string(name='RequestId'),
  statistics?: {
    categories?: [ string ](name='Categories'),
    series?: [ 
      {
        data?: [ string ](name='Data'),
        name?: string(name='Name'),
      }
    ](name='Series'),
  }(name='Statistics'),
}

model CountActivatedOrNewRegistrationDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CountActivatedOrNewRegistrationDeviceResponseBody(name='body'),
}

async function countActivatedOrNewRegistrationDeviceWithOptions(request: CountActivatedOrNewRegistrationDeviceRequest, runtime: Util.RuntimeOptions): CountActivatedOrNewRegistrationDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceBrand)) {
    query['DeviceBrand'] = request.deviceBrand;
  }
  if (!Util.isUnset(request.deviceBrandId)) {
    query['DeviceBrandId'] = request.deviceBrandId;
  }
  if (!Util.isUnset(request.deviceCountStatType)) {
    query['DeviceCountStatType'] = request.deviceCountStatType;
  }
  if (!Util.isUnset(request.deviceModel)) {
    query['DeviceModel'] = request.deviceModel;
  }
  if (!Util.isUnset(request.deviceModelId)) {
    query['DeviceModelId'] = request.deviceModelId;
  }
  if (!Util.isUnset(request.deviceType)) {
    query['DeviceType'] = request.deviceType;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.isQueryNewRegistrationDevice)) {
    query['IsQueryNewRegistrationDevice'] = request.isQueryNewRegistrationDevice;
  }
  if (!Util.isUnset(request.isQueryYearlyActivate)) {
    query['IsQueryYearlyActivate'] = request.isQueryYearlyActivate;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CountActivatedOrNewRegistrationDevice',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function countActivatedOrNewRegistrationDevice(request: CountActivatedOrNewRegistrationDeviceRequest): CountActivatedOrNewRegistrationDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return countActivatedOrNewRegistrationDeviceWithOptions(request, runtime);
}

model CountDeviceBrandsRequest {
  deviceBrand?: string(name='DeviceBrand'),
  deviceBrandId?: long(name='DeviceBrandId'),
  projectId?: string(name='ProjectId'),
}

model CountDeviceBrandsResponseBody = {
  brandCount?: int32(name='BrandCount'),
  requestId?: string(name='RequestId'),
}

model CountDeviceBrandsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CountDeviceBrandsResponseBody(name='body'),
}

async function countDeviceBrandsWithOptions(request: CountDeviceBrandsRequest, runtime: Util.RuntimeOptions): CountDeviceBrandsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CountDeviceBrands',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function countDeviceBrands(request: CountDeviceBrandsRequest): CountDeviceBrandsResponse {
  var runtime = new Util.RuntimeOptions{};
  return countDeviceBrandsWithOptions(request, runtime);
}

model CountDeviceModelsRequest {
  deviceBrand?: string(name='DeviceBrand'),
  deviceModel?: string(name='DeviceModel'),
  deviceModelId?: int32(name='DeviceModelId'),
  projectId?: string(name='ProjectId'),
}

model CountDeviceModelsResponseBody = {
  modelCount?: int32(name='ModelCount'),
  requestId?: string(name='RequestId'),
}

model CountDeviceModelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CountDeviceModelsResponseBody(name='body'),
}

async function countDeviceModelsWithOptions(request: CountDeviceModelsRequest, runtime: Util.RuntimeOptions): CountDeviceModelsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CountDeviceModels',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function countDeviceModels(request: CountDeviceModelsRequest): CountDeviceModelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return countDeviceModelsWithOptions(request, runtime);
}

model CountDevicesRequest {
  deviceModel?: string(name='DeviceModel'),
  deviceModelId?: int32(name='DeviceModelId'),
  projectId?: string(name='ProjectId'),
}

model CountDevicesResponseBody = {
  deviceCount?: int32(name='DeviceCount'),
  requestId?: string(name='RequestId'),
}

model CountDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CountDevicesResponseBody(name='body'),
}

async function countDevicesWithOptions(request: CountDevicesRequest, runtime: Util.RuntimeOptions): CountDevicesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CountDevices',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function countDevices(request: CountDevicesRequest): CountDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return countDevicesWithOptions(request, runtime);
}

model CountYunIdInfoResponseBody = {
  requestId?: string(name='RequestId'),
  yunIdInfo?: [ 
    {
      totalBrandCount?: long(name='TotalBrandCount'),
      totalDeviceCount?: long(name='TotalDeviceCount'),
      totalDeviceModelCount?: long(name='TotalDeviceModelCount'),
    }
  ](name='YunIdInfo'),
}

model CountYunIdInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CountYunIdInfoResponseBody(name='body'),
}

async function countYunIdInfoWithOptions(runtime: Util.RuntimeOptions): CountYunIdInfoResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'CountYunIdInfo',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function countYunIdInfo(): CountYunIdInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return countYunIdInfoWithOptions(runtime);
}

model CreateAppVersionRequest {
  apkMd5?: string(name='ApkMd5'),
  appId?: string(name='AppId'),
  appVersion?: string(name='AppVersion'),
  blackVersionList?: string(name='BlackVersionList'),
  deviceAdapterList?: string(name='DeviceAdapterList'),
  installType?: string(name='InstallType'),
  isAllowNewInstall?: string(name='IsAllowNewInstall'),
  isForceUpgrade?: string(name='IsForceUpgrade'),
  isNeedRestart?: string(name='IsNeedRestart'),
  isSilentUpgrade?: string(name='IsSilentUpgrade'),
  packageUrl?: string(name='PackageUrl'),
  projectId?: string(name='ProjectId'),
  releaseNote?: string(name='ReleaseNote'),
  remark?: string(name='Remark'),
  restartAppParam?: string(name='RestartAppParam'),
  restartAppType?: string(name='RestartAppType'),
  restartType?: string(name='RestartType'),
  versionCode?: string(name='VersionCode'),
  whiteVersionList?: string(name='WhiteVersionList'),
}

model CreateAppVersionResponseBody = {
  requestId?: string(name='RequestId'),
  versionId?: string(name='VersionId'),
}

model CreateAppVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAppVersionResponseBody(name='body'),
}

async function createAppVersionWithOptions(request: CreateAppVersionRequest, runtime: Util.RuntimeOptions): CreateAppVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apkMd5)) {
    query['ApkMd5'] = request.apkMd5;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.blackVersionList)) {
    query['BlackVersionList'] = request.blackVersionList;
  }
  if (!Util.isUnset(request.deviceAdapterList)) {
    query['DeviceAdapterList'] = request.deviceAdapterList;
  }
  if (!Util.isUnset(request.installType)) {
    query['InstallType'] = request.installType;
  }
  if (!Util.isUnset(request.isAllowNewInstall)) {
    query['IsAllowNewInstall'] = request.isAllowNewInstall;
  }
  if (!Util.isUnset(request.isForceUpgrade)) {
    query['IsForceUpgrade'] = request.isForceUpgrade;
  }
  if (!Util.isUnset(request.isNeedRestart)) {
    query['IsNeedRestart'] = request.isNeedRestart;
  }
  if (!Util.isUnset(request.isSilentUpgrade)) {
    query['IsSilentUpgrade'] = request.isSilentUpgrade;
  }
  if (!Util.isUnset(request.packageUrl)) {
    query['PackageUrl'] = request.packageUrl;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.releaseNote)) {
    query['ReleaseNote'] = request.releaseNote;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.restartAppParam)) {
    query['RestartAppParam'] = request.restartAppParam;
  }
  if (!Util.isUnset(request.restartAppType)) {
    query['RestartAppType'] = request.restartAppType;
  }
  if (!Util.isUnset(request.restartType)) {
    query['RestartType'] = request.restartType;
  }
  if (!Util.isUnset(request.versionCode)) {
    query['VersionCode'] = request.versionCode;
  }
  if (!Util.isUnset(request.whiteVersionList)) {
    query['WhiteVersionList'] = request.whiteVersionList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAppVersion',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAppVersion(request: CreateAppVersionRequest): CreateAppVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAppVersionWithOptions(request, runtime);
}

model CreateCustomizedFilterRequest {
  blackWhiteType?: string(name='BlackWhiteType'),
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
  value?: string(name='Value'),
  valueCompareType?: string(name='ValueCompareType'),
  valueType?: string(name='ValueType'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model CreateCustomizedFilterResponseBody = {
  customizedFilterId?: string(name='CustomizedFilterId'),
  requestId?: string(name='RequestId'),
}

model CreateCustomizedFilterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCustomizedFilterResponseBody(name='body'),
}

async function createCustomizedFilterWithOptions(request: CreateCustomizedFilterRequest, runtime: Util.RuntimeOptions): CreateCustomizedFilterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blackWhiteType)) {
    query['BlackWhiteType'] = request.blackWhiteType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  if (!Util.isUnset(request.valueCompareType)) {
    query['ValueCompareType'] = request.valueCompareType;
  }
  if (!Util.isUnset(request.valueType)) {
    query['ValueType'] = request.valueType;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCustomizedFilter',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCustomizedFilter(request: CreateCustomizedFilterRequest): CreateCustomizedFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCustomizedFilterWithOptions(request, runtime);
}

model CreateCustomizedPropertyRequest {
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
  value?: string(name='Value'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model CreateCustomizedPropertyResponseBody = {
  customizedPropertyId?: string(name='CustomizedPropertyId'),
  requestId?: string(name='RequestId'),
}

model CreateCustomizedPropertyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCustomizedPropertyResponseBody(name='body'),
}

async function createCustomizedPropertyWithOptions(request: CreateCustomizedPropertyRequest, runtime: Util.RuntimeOptions): CreateCustomizedPropertyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCustomizedProperty',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCustomizedProperty(request: CreateCustomizedPropertyRequest): CreateCustomizedPropertyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCustomizedPropertyWithOptions(request, runtime);
}

model CreateDeviceBrandRequest {
  brandName?: string(name='BrandName'),
  description?: string(name='Description'),
  manufacture?: string(name='Manufacture'),
  projectId?: string(name='ProjectId'),
}

model CreateDeviceBrandResponseBody = {
  brandId?: long(name='BrandId'),
  requestId?: string(name='RequestId'),
}

model CreateDeviceBrandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDeviceBrandResponseBody(name='body'),
}

async function createDeviceBrandWithOptions(request: CreateDeviceBrandRequest, runtime: Util.RuntimeOptions): CreateDeviceBrandResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.brandName)) {
    query['BrandName'] = request.brandName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.manufacture)) {
    query['Manufacture'] = request.manufacture;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDeviceBrand',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDeviceBrand(request: CreateDeviceBrandRequest): CreateDeviceBrandResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDeviceBrandWithOptions(request, runtime);
}

model CreateDeviceModelRequest {
  brandName?: string(name='BrandName'),
  canCreateDeviceId?: string(name='CanCreateDeviceId'),
  description?: string(name='Description'),
  deviceName?: string(name='DeviceName'),
  deviceType?: string(name='DeviceType'),
  hardwareType?: string(name='HardwareType'),
  initUsageType?: string(name='InitUsageType'),
  modelName?: string(name='ModelName'),
  objectKey?: string(name='ObjectKey'),
  osPlatform?: string(name='OsPlatform'),
  projectId?: string(name='ProjectId'),
  securityChip?: string(name='SecurityChip'),
}

model CreateDeviceModelResponseBody = {
  deviceModelId?: long(name='DeviceModelId'),
  requestId?: string(name='RequestId'),
}

model CreateDeviceModelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDeviceModelResponseBody(name='body'),
}

async function createDeviceModelWithOptions(request: CreateDeviceModelRequest, runtime: Util.RuntimeOptions): CreateDeviceModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.brandName)) {
    query['BrandName'] = request.brandName;
  }
  if (!Util.isUnset(request.canCreateDeviceId)) {
    query['CanCreateDeviceId'] = request.canCreateDeviceId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.deviceType)) {
    query['DeviceType'] = request.deviceType;
  }
  if (!Util.isUnset(request.hardwareType)) {
    query['HardwareType'] = request.hardwareType;
  }
  if (!Util.isUnset(request.initUsageType)) {
    query['InitUsageType'] = request.initUsageType;
  }
  if (!Util.isUnset(request.modelName)) {
    query['ModelName'] = request.modelName;
  }
  if (!Util.isUnset(request.objectKey)) {
    query['ObjectKey'] = request.objectKey;
  }
  if (!Util.isUnset(request.osPlatform)) {
    query['OsPlatform'] = request.osPlatform;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.securityChip)) {
    query['SecurityChip'] = request.securityChip;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDeviceModel',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDeviceModel(request: CreateDeviceModelRequest): CreateDeviceModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDeviceModelWithOptions(request, runtime);
}

model CreateNamespaceRequest {
  authType?: string(name='AuthType'),
  desc?: string(name='Desc'),
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
}

model CreateNamespaceResponseBody = {
  namespace?: string(name='Namespace'),
  requestId?: string(name='RequestId'),
}

model CreateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNamespaceResponseBody(name='body'),
}

async function createNamespaceWithOptions(request: CreateNamespaceRequest, runtime: Util.RuntimeOptions): CreateNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authType)) {
    query['AuthType'] = request.authType;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNamespace',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNamespace(request: CreateNamespaceRequest): CreateNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNamespaceWithOptions(request, runtime);
}

model CreateOsVersionRequest {
  blackVersionList?: string(name='BlackVersionList'),
  deviceModelId?: string(name='DeviceModelId'),
  enableMobileDownload?: string(name='EnableMobileDownload'),
  isForceNightUpgrade?: string(name='IsForceNightUpgrade'),
  isForceUpgrade?: string(name='IsForceUpgrade'),
  isMilestone?: string(name='IsMilestone'),
  maxClientVersion?: string(name='MaxClientVersion'),
  minClientVersion?: string(name='MinClientVersion'),
  mobileDownloadMaxSize?: string(name='MobileDownloadMaxSize'),
  nightUpgradeDownloadType?: string(name='NightUpgradeDownloadType'),
  nightUpgradeIsAllowedCancel?: string(name='NightUpgradeIsAllowedCancel'),
  nightUpgradeIsShowTip?: string(name='NightUpgradeIsShowTip'),
  projectId?: string(name='ProjectId'),
  releaseNote?: string(name='ReleaseNote'),
  remark?: string(name='Remark'),
  romList?: string(name='RomList'),
  systemVersion?: string(name='SystemVersion'),
  whiteVersionList?: string(name='WhiteVersionList'),
}

model CreateOsVersionResponseBody = {
  requestId?: string(name='RequestId'),
  versionId?: string(name='VersionId'),
}

model CreateOsVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOsVersionResponseBody(name='body'),
}

async function createOsVersionWithOptions(request: CreateOsVersionRequest, runtime: Util.RuntimeOptions): CreateOsVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blackVersionList)) {
    query['BlackVersionList'] = request.blackVersionList;
  }
  if (!Util.isUnset(request.deviceModelId)) {
    query['DeviceModelId'] = request.deviceModelId;
  }
  if (!Util.isUnset(request.enableMobileDownload)) {
    query['EnableMobileDownload'] = request.enableMobileDownload;
  }
  if (!Util.isUnset(request.isForceNightUpgrade)) {
    query['IsForceNightUpgrade'] = request.isForceNightUpgrade;
  }
  if (!Util.isUnset(request.isForceUpgrade)) {
    query['IsForceUpgrade'] = request.isForceUpgrade;
  }
  if (!Util.isUnset(request.isMilestone)) {
    query['IsMilestone'] = request.isMilestone;
  }
  if (!Util.isUnset(request.maxClientVersion)) {
    query['MaxClientVersion'] = request.maxClientVersion;
  }
  if (!Util.isUnset(request.minClientVersion)) {
    query['MinClientVersion'] = request.minClientVersion;
  }
  if (!Util.isUnset(request.mobileDownloadMaxSize)) {
    query['MobileDownloadMaxSize'] = request.mobileDownloadMaxSize;
  }
  if (!Util.isUnset(request.nightUpgradeDownloadType)) {
    query['NightUpgradeDownloadType'] = request.nightUpgradeDownloadType;
  }
  if (!Util.isUnset(request.nightUpgradeIsAllowedCancel)) {
    query['NightUpgradeIsAllowedCancel'] = request.nightUpgradeIsAllowedCancel;
  }
  if (!Util.isUnset(request.nightUpgradeIsShowTip)) {
    query['NightUpgradeIsShowTip'] = request.nightUpgradeIsShowTip;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.releaseNote)) {
    query['ReleaseNote'] = request.releaseNote;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.romList)) {
    query['RomList'] = request.romList;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  if (!Util.isUnset(request.whiteVersionList)) {
    query['WhiteVersionList'] = request.whiteVersionList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOsVersion',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOsVersion(request: CreateOsVersionRequest): CreateOsVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOsVersionWithOptions(request, runtime);
}

model CreateProjectRequest {
  projectDesc?: string(name='ProjectDesc'),
  projectName?: string(name='ProjectName'),
}

model CreateProjectResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProjectResponseBody(name='body'),
}

async function createProjectWithOptions(request: CreateProjectRequest, runtime: Util.RuntimeOptions): CreateProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectDesc)) {
    query['ProjectDesc'] = request.projectDesc;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateProject',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProjectWithOptions(request, runtime);
}

model CreateProjectAppRequest {
  appName?: string(name='AppName'),
  appPkgName?: string(name='AppPkgName'),
  osType?: int32(name='OsType'),
  projectId?: string(name='ProjectId'),
}

model CreateProjectAppResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateProjectAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProjectAppResponseBody(name='body'),
}

async function createProjectAppWithOptions(request: CreateProjectAppRequest, runtime: Util.RuntimeOptions): CreateProjectAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.appPkgName)) {
    query['AppPkgName'] = request.appPkgName;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateProjectApp',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createProjectApp(request: CreateProjectAppRequest): CreateProjectAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProjectAppWithOptions(request, runtime);
}

model CreateRpcServiceRequest {
  appKey?: string(name='AppKey'),
  groupName?: string(name='GroupName'),
  interfaceName?: string(name='InterfaceName'),
  invokeType?: string(name='InvokeType'),
  methodName?: string(name='MethodName'),
  params?: string(name='Params'),
  projectId?: string(name='ProjectId'),
  versionCode?: string(name='VersionCode'),
}

model CreateRpcServiceResponseBody = {
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateRpcServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRpcServiceResponseBody(name='body'),
}

async function createRpcServiceWithOptions(request: CreateRpcServiceRequest, runtime: Util.RuntimeOptions): CreateRpcServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appKey)) {
    query['AppKey'] = request.appKey;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.interfaceName)) {
    query['InterfaceName'] = request.interfaceName;
  }
  if (!Util.isUnset(request.invokeType)) {
    query['InvokeType'] = request.invokeType;
  }
  if (!Util.isUnset(request.methodName)) {
    query['MethodName'] = request.methodName;
  }
  if (!Util.isUnset(request.params)) {
    query['Params'] = request.params;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionCode)) {
    query['VersionCode'] = request.versionCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRpcService',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRpcService(request: CreateRpcServiceRequest): CreateRpcServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRpcServiceWithOptions(request, runtime);
}

model CreateSchemaSubscribeRequest {
  deviceModel?: string(name='DeviceModel'),
  projectId?: string(name='ProjectId'),
  schemaVersion?: string(name='SchemaVersion'),
  subscribeList?: string(name='SubscribeList'),
}

model CreateSchemaSubscribeResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateSchemaSubscribeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSchemaSubscribeResponseBody(name='body'),
}

async function createSchemaSubscribeWithOptions(request: CreateSchemaSubscribeRequest, runtime: Util.RuntimeOptions): CreateSchemaSubscribeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceModel)) {
    query['DeviceModel'] = request.deviceModel;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.subscribeList)) {
    query['SubscribeList'] = request.subscribeList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSchemaSubscribe',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSchemaSubscribe(request: CreateSchemaSubscribeRequest): CreateSchemaSubscribeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSchemaSubscribeWithOptions(request, runtime);
}

model CreateShadowSchemaRequest {
  authType?: string(name='AuthType'),
  deviceModelId?: string(name='DeviceModelId'),
  namespace?: string(name='Namespace'),
  projectId?: string(name='ProjectId'),
  schema?: string(name='Schema'),
}

model CreateShadowSchemaResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateShadowSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateShadowSchemaResponseBody(name='body'),
}

async function createShadowSchemaWithOptions(request: CreateShadowSchemaRequest, runtime: Util.RuntimeOptions): CreateShadowSchemaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authType)) {
    query['AuthType'] = request.authType;
  }
  if (!Util.isUnset(request.deviceModelId)) {
    query['DeviceModelId'] = request.deviceModelId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.schema)) {
    query['Schema'] = request.schema;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateShadowSchema',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createShadowSchema(request: CreateShadowSchemaRequest): CreateShadowSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return createShadowSchemaWithOptions(request, runtime);
}

model CreateTriggerRequest {
  fileIds?: string(name='FileIds'),
  functionIds?: string(name='FunctionIds'),
  invocationMode?: int32(name='InvocationMode'),
  namespace?: string(name='Namespace'),
  production?: int32(name='Production'),
  projectId?: string(name='ProjectId'),
  sandbox?: int32(name='Sandbox'),
  source?: string(name='Source'),
}

model CreateTriggerResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTriggerResponseBody(name='body'),
}

async function createTriggerWithOptions(request: CreateTriggerRequest, runtime: Util.RuntimeOptions): CreateTriggerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileIds)) {
    query['FileIds'] = request.fileIds;
  }
  if (!Util.isUnset(request.functionIds)) {
    query['FunctionIds'] = request.functionIds;
  }
  if (!Util.isUnset(request.invocationMode)) {
    query['InvocationMode'] = request.invocationMode;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.production)) {
    query['Production'] = request.production;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.sandbox)) {
    query['Sandbox'] = request.sandbox;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTrigger',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTrigger(request: CreateTriggerRequest): CreateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTriggerWithOptions(request, runtime);
}

model CreateUpstreamAppKeyRelationRequest {
  appKey?: string(name='AppKey'),
  PAppKey?: string(name='PAppKey'),
  projectId?: string(name='ProjectId'),
}

model CreateUpstreamAppKeyRelationResponseBody = {
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateUpstreamAppKeyRelationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUpstreamAppKeyRelationResponseBody(name='body'),
}

async function createUpstreamAppKeyRelationWithOptions(request: CreateUpstreamAppKeyRelationRequest, runtime: Util.RuntimeOptions): CreateUpstreamAppKeyRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appKey)) {
    query['AppKey'] = request.appKey;
  }
  if (!Util.isUnset(request.PAppKey)) {
    query['PAppKey'] = request.PAppKey;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUpstreamAppKeyRelation',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUpstreamAppKeyRelation(request: CreateUpstreamAppKeyRelationRequest): CreateUpstreamAppKeyRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUpstreamAppKeyRelationWithOptions(request, runtime);
}

model CreateUpstreamAppKeyRelationsRequest {
  appKeys?: string(name='AppKeys'),
  appServerId?: string(name='AppServerId'),
  projectId?: string(name='ProjectId'),
}

model CreateUpstreamAppKeyRelationsResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateUpstreamAppKeyRelationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUpstreamAppKeyRelationsResponseBody(name='body'),
}

async function createUpstreamAppKeyRelationsWithOptions(request: CreateUpstreamAppKeyRelationsRequest, runtime: Util.RuntimeOptions): CreateUpstreamAppKeyRelationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appKeys)) {
    query['AppKeys'] = request.appKeys;
  }
  if (!Util.isUnset(request.appServerId)) {
    query['AppServerId'] = request.appServerId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUpstreamAppKeyRelations',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUpstreamAppKeyRelations(request: CreateUpstreamAppKeyRelationsRequest): CreateUpstreamAppKeyRelationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUpstreamAppKeyRelationsWithOptions(request, runtime);
}

model CreateUpstreamAppServerRequest {
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
  tags?: string(name='Tags'),
}

model CreateUpstreamAppServerResponseBody = {
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateUpstreamAppServerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUpstreamAppServerResponseBody(name='body'),
}

async function createUpstreamAppServerWithOptions(request: CreateUpstreamAppServerRequest, runtime: Util.RuntimeOptions): CreateUpstreamAppServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUpstreamAppServer',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUpstreamAppServer(request: CreateUpstreamAppServerRequest): CreateUpstreamAppServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUpstreamAppServerWithOptions(request, runtime);
}

model CreateVersionDeviceGroupRequest {
  description?: string(name='Description'),
  maxCount?: string(name='MaxCount'),
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
}

model CreateVersionDeviceGroupResponseBody = {
  deviceGroupId?: string(name='DeviceGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateVersionDeviceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVersionDeviceGroupResponseBody(name='body'),
}

async function createVersionDeviceGroupWithOptions(request: CreateVersionDeviceGroupRequest, runtime: Util.RuntimeOptions): CreateVersionDeviceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.maxCount)) {
    query['MaxCount'] = request.maxCount;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVersionDeviceGroup',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVersionDeviceGroup(request: CreateVersionDeviceGroupRequest): CreateVersionDeviceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVersionDeviceGroupWithOptions(request, runtime);
}

model CreateVersionPrepublishRequest {
  barrierCount?: string(name='BarrierCount'),
  isTotalPrepublish?: string(name='IsTotalPrepublish'),
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model CreateVersionPrepublishResponseBody = {
  prepublishId?: string(name='PrepublishId'),
  requestId?: string(name='RequestId'),
}

model CreateVersionPrepublishResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVersionPrepublishResponseBody(name='body'),
}

async function createVersionPrepublishWithOptions(request: CreateVersionPrepublishRequest, runtime: Util.RuntimeOptions): CreateVersionPrepublishResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.barrierCount)) {
    query['BarrierCount'] = request.barrierCount;
  }
  if (!Util.isUnset(request.isTotalPrepublish)) {
    query['IsTotalPrepublish'] = request.isTotalPrepublish;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVersionPrepublish',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVersionPrepublish(request: CreateVersionPrepublishRequest): CreateVersionPrepublishResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVersionPrepublishWithOptions(request, runtime);
}

model CreateVersionTestRequest {
  description?: string(name='Description'),
  deviceGroupId?: string(name='DeviceGroupId'),
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model CreateVersionTestResponseBody = {
  requestId?: string(name='RequestId'),
  testId?: string(name='TestId'),
}

model CreateVersionTestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVersionTestResponseBody(name='body'),
}

async function createVersionTestWithOptions(request: CreateVersionTestRequest, runtime: Util.RuntimeOptions): CreateVersionTestResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.deviceGroupId)) {
    query['DeviceGroupId'] = request.deviceGroupId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVersionTest',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVersionTest(request: CreateVersionTestRequest): CreateVersionTestResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVersionTestWithOptions(request, runtime);
}

model DelayPublishOsVersionRequest {
  description?: string(name='Description'),
  downTime?: long(name='DownTime'),
  email?: string(name='Email'),
  prepubTime?: long(name='PrepubTime'),
  prepublishCount?: string(name='PrepublishCount'),
  projectId?: string(name='ProjectId'),
  publishTime?: long(name='PublishTime'),
  sendMessage?: string(name='SendMessage'),
  versionId?: string(name='VersionId'),
}

model DelayPublishOsVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DelayPublishOsVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DelayPublishOsVersionResponseBody(name='body'),
}

async function delayPublishOsVersionWithOptions(request: DelayPublishOsVersionRequest, runtime: Util.RuntimeOptions): DelayPublishOsVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.downTime)) {
    query['DownTime'] = request.downTime;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.prepubTime)) {
    query['PrepubTime'] = request.prepubTime;
  }
  if (!Util.isUnset(request.prepublishCount)) {
    query['PrepublishCount'] = request.prepublishCount;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.publishTime)) {
    query['PublishTime'] = request.publishTime;
  }
  if (!Util.isUnset(request.sendMessage)) {
    query['SendMessage'] = request.sendMessage;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DelayPublishOsVersion',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function delayPublishOsVersion(request: DelayPublishOsVersionRequest): DelayPublishOsVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return delayPublishOsVersionWithOptions(request, runtime);
}

model DeleteAllCustomizedFiltersRequest {
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model DeleteAllCustomizedFiltersResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAllCustomizedFiltersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAllCustomizedFiltersResponseBody(name='body'),
}

async function deleteAllCustomizedFiltersWithOptions(request: DeleteAllCustomizedFiltersRequest, runtime: Util.RuntimeOptions): DeleteAllCustomizedFiltersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAllCustomizedFilters',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAllCustomizedFilters(request: DeleteAllCustomizedFiltersRequest): DeleteAllCustomizedFiltersResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAllCustomizedFiltersWithOptions(request, runtime);
}

model DeleteAllVersionGroupDevicesRequest {
  deviceGroupId?: string(name='DeviceGroupId'),
  projectId?: string(name='ProjectId'),
}

model DeleteAllVersionGroupDevicesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAllVersionGroupDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAllVersionGroupDevicesResponseBody(name='body'),
}

async function deleteAllVersionGroupDevicesWithOptions(request: DeleteAllVersionGroupDevicesRequest, runtime: Util.RuntimeOptions): DeleteAllVersionGroupDevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceGroupId)) {
    query['DeviceGroupId'] = request.deviceGroupId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAllVersionGroupDevices',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAllVersionGroupDevices(request: DeleteAllVersionGroupDevicesRequest): DeleteAllVersionGroupDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAllVersionGroupDevicesWithOptions(request, runtime);
}

model DeleteCustomizedFilterRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
}

model DeleteCustomizedFilterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCustomizedFilterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCustomizedFilterResponseBody(name='body'),
}

async function deleteCustomizedFilterWithOptions(request: DeleteCustomizedFilterRequest, runtime: Util.RuntimeOptions): DeleteCustomizedFilterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomizedFilter',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCustomizedFilter(request: DeleteCustomizedFilterRequest): DeleteCustomizedFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomizedFilterWithOptions(request, runtime);
}

model DeleteCustomizedPropertyRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
}

model DeleteCustomizedPropertyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCustomizedPropertyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCustomizedPropertyResponseBody(name='body'),
}

async function deleteCustomizedPropertyWithOptions(request: DeleteCustomizedPropertyRequest, runtime: Util.RuntimeOptions): DeleteCustomizedPropertyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomizedProperty',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCustomizedProperty(request: DeleteCustomizedPropertyRequest): DeleteCustomizedPropertyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomizedPropertyWithOptions(request, runtime);
}

model DeleteDeviceRequest {
  deviceId?: string(name='DeviceId'),
  projectId?: string(name='ProjectId'),
}

model DeleteDeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDeviceResponseBody(name='body'),
}

async function deleteDeviceWithOptions(request: DeleteDeviceRequest, runtime: Util.RuntimeOptions): DeleteDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceId)) {
    query['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDevice',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDevice(request: DeleteDeviceRequest): DeleteDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeviceWithOptions(request, runtime);
}

model DeleteFunctionFileRequest {
  fileName?: string(name='FileName'),
  fileType?: int32(name='FileType'),
  projectId?: string(name='ProjectId'),
}

model DeleteFunctionFileResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFunctionFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFunctionFileResponseBody(name='body'),
}

async function deleteFunctionFileWithOptions(request: DeleteFunctionFileRequest, runtime: Util.RuntimeOptions): DeleteFunctionFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.fileType)) {
    query['FileType'] = request.fileType;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunctionFile',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFunctionFile(request: DeleteFunctionFileRequest): DeleteFunctionFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFunctionFileWithOptions(request, runtime);
}

model DeleteNamespaceRequest {
  namespace?: string(name='Namespace'),
  projectId?: string(name='ProjectId'),
}

model DeleteNamespaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNamespaceResponseBody(name='body'),
}

async function deleteNamespaceWithOptions(request: DeleteNamespaceRequest, runtime: Util.RuntimeOptions): DeleteNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNamespace',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNamespace(request: DeleteNamespaceRequest): DeleteNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNamespaceWithOptions(request, runtime);
}

model DeleteOpenAccountRequest {
  identityId?: string(name='IdentityId'),
  projectId?: string(name='ProjectId'),
}

model DeleteOpenAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteOpenAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteOpenAccountResponseBody(name='body'),
}

async function deleteOpenAccountWithOptions(request: DeleteOpenAccountRequest, runtime: Util.RuntimeOptions): DeleteOpenAccountResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteOpenAccount',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteOpenAccount(request: DeleteOpenAccountRequest): DeleteOpenAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteOpenAccountWithOptions(request, runtime);
}

model DeleteProjectAppRequest {
  appId?: string(name='AppId'),
  projectId?: string(name='ProjectId'),
}

model DeleteProjectAppResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteProjectAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProjectAppResponseBody(name='body'),
}

async function deleteProjectAppWithOptions(request: DeleteProjectAppRequest, runtime: Util.RuntimeOptions): DeleteProjectAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProjectApp',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProjectApp(request: DeleteProjectAppRequest): DeleteProjectAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProjectAppWithOptions(request, runtime);
}

model DeleteRpcServiceRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
}

model DeleteRpcServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRpcServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRpcServiceResponseBody(name='body'),
}

async function deleteRpcServiceWithOptions(request: DeleteRpcServiceRequest, runtime: Util.RuntimeOptions): DeleteRpcServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRpcService',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRpcService(request: DeleteRpcServiceRequest): DeleteRpcServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRpcServiceWithOptions(request, runtime);
}

model DeleteSchemaSubscribeRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
}

model DeleteSchemaSubscribeResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSchemaSubscribeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSchemaSubscribeResponseBody(name='body'),
}

async function deleteSchemaSubscribeWithOptions(request: DeleteSchemaSubscribeRequest, runtime: Util.RuntimeOptions): DeleteSchemaSubscribeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSchemaSubscribe',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSchemaSubscribe(request: DeleteSchemaSubscribeRequest): DeleteSchemaSubscribeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSchemaSubscribeWithOptions(request, runtime);
}

model DeleteShadowSchemaRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
}

model DeleteShadowSchemaResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteShadowSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteShadowSchemaResponseBody(name='body'),
}

async function deleteShadowSchemaWithOptions(request: DeleteShadowSchemaRequest, runtime: Util.RuntimeOptions): DeleteShadowSchemaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteShadowSchema',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteShadowSchema(request: DeleteShadowSchemaRequest): DeleteShadowSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteShadowSchemaWithOptions(request, runtime);
}

model DeleteTriggerRequest {
  id?: long(name='Id'),
  projectId?: string(name='ProjectId'),
}

model DeleteTriggerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTriggerResponseBody(name='body'),
}

async function deleteTriggerWithOptions(request: DeleteTriggerRequest, runtime: Util.RuntimeOptions): DeleteTriggerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTrigger',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTrigger(request: DeleteTriggerRequest): DeleteTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTriggerWithOptions(request, runtime);
}

model DeleteUpstreamAppKeyRelationRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
}

model DeleteUpstreamAppKeyRelationResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUpstreamAppKeyRelationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUpstreamAppKeyRelationResponseBody(name='body'),
}

async function deleteUpstreamAppKeyRelationWithOptions(request: DeleteUpstreamAppKeyRelationRequest, runtime: Util.RuntimeOptions): DeleteUpstreamAppKeyRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUpstreamAppKeyRelation',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUpstreamAppKeyRelation(request: DeleteUpstreamAppKeyRelationRequest): DeleteUpstreamAppKeyRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUpstreamAppKeyRelationWithOptions(request, runtime);
}

model DeleteUpstreamAppServerRequest {
  id?: long(name='Id'),
  projectId?: string(name='ProjectId'),
}

model DeleteUpstreamAppServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUpstreamAppServerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUpstreamAppServerResponseBody(name='body'),
}

async function deleteUpstreamAppServerWithOptions(request: DeleteUpstreamAppServerRequest, runtime: Util.RuntimeOptions): DeleteUpstreamAppServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUpstreamAppServer',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUpstreamAppServer(request: DeleteUpstreamAppServerRequest): DeleteUpstreamAppServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUpstreamAppServerWithOptions(request, runtime);
}

model DeleteVersionAllBlackDevicesRequest {
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model DeleteVersionAllBlackDevicesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVersionAllBlackDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVersionAllBlackDevicesResponseBody(name='body'),
}

async function deleteVersionAllBlackDevicesWithOptions(request: DeleteVersionAllBlackDevicesRequest, runtime: Util.RuntimeOptions): DeleteVersionAllBlackDevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVersionAllBlackDevices',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVersionAllBlackDevices(request: DeleteVersionAllBlackDevicesRequest): DeleteVersionAllBlackDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVersionAllBlackDevicesWithOptions(request, runtime);
}

model DeleteVersionAllWhiteDevicesRequest {
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model DeleteVersionAllWhiteDevicesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVersionAllWhiteDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVersionAllWhiteDevicesResponseBody(name='body'),
}

async function deleteVersionAllWhiteDevicesWithOptions(request: DeleteVersionAllWhiteDevicesRequest, runtime: Util.RuntimeOptions): DeleteVersionAllWhiteDevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVersionAllWhiteDevices',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVersionAllWhiteDevices(request: DeleteVersionAllWhiteDevicesRequest): DeleteVersionAllWhiteDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVersionAllWhiteDevicesWithOptions(request, runtime);
}

model DeleteVersionBlackDevicesRequest {
  deviceIdType?: string(name='DeviceIdType'),
  deviceIds?: string(name='DeviceIds'),
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model DeleteVersionBlackDevicesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVersionBlackDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVersionBlackDevicesResponseBody(name='body'),
}

async function deleteVersionBlackDevicesWithOptions(request: DeleteVersionBlackDevicesRequest, runtime: Util.RuntimeOptions): DeleteVersionBlackDevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceIdType)) {
    query['DeviceIdType'] = request.deviceIdType;
  }
  if (!Util.isUnset(request.deviceIds)) {
    query['DeviceIds'] = request.deviceIds;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVersionBlackDevices',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVersionBlackDevices(request: DeleteVersionBlackDevicesRequest): DeleteVersionBlackDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVersionBlackDevicesWithOptions(request, runtime);
}

model DeleteVersionBlackDevicesByIdRequest {
  ids?: string(name='Ids'),
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model DeleteVersionBlackDevicesByIdResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVersionBlackDevicesByIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVersionBlackDevicesByIdResponseBody(name='body'),
}

async function deleteVersionBlackDevicesByIdWithOptions(request: DeleteVersionBlackDevicesByIdRequest, runtime: Util.RuntimeOptions): DeleteVersionBlackDevicesByIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVersionBlackDevicesById',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVersionBlackDevicesById(request: DeleteVersionBlackDevicesByIdRequest): DeleteVersionBlackDevicesByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVersionBlackDevicesByIdWithOptions(request, runtime);
}

model DeleteVersionDeviceGroupRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
}

model DeleteVersionDeviceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVersionDeviceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVersionDeviceGroupResponseBody(name='body'),
}

async function deleteVersionDeviceGroupWithOptions(request: DeleteVersionDeviceGroupRequest, runtime: Util.RuntimeOptions): DeleteVersionDeviceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVersionDeviceGroup',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVersionDeviceGroup(request: DeleteVersionDeviceGroupRequest): DeleteVersionDeviceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVersionDeviceGroupWithOptions(request, runtime);
}

model DeleteVersionGroupDeviceRequest {
  deviceGroupId?: string(name='DeviceGroupId'),
  deviceIdType?: string(name='DeviceIdType'),
  deviceIds?: string(name='DeviceIds'),
  projectId?: string(name='ProjectId'),
}

model DeleteVersionGroupDeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVersionGroupDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVersionGroupDeviceResponseBody(name='body'),
}

async function deleteVersionGroupDeviceWithOptions(request: DeleteVersionGroupDeviceRequest, runtime: Util.RuntimeOptions): DeleteVersionGroupDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceGroupId)) {
    query['DeviceGroupId'] = request.deviceGroupId;
  }
  if (!Util.isUnset(request.deviceIdType)) {
    query['DeviceIdType'] = request.deviceIdType;
  }
  if (!Util.isUnset(request.deviceIds)) {
    query['DeviceIds'] = request.deviceIds;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVersionGroupDevice',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVersionGroupDevice(request: DeleteVersionGroupDeviceRequest): DeleteVersionGroupDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVersionGroupDeviceWithOptions(request, runtime);
}

model DeleteVersionGroupDeviceByIdRequest {
  deviceGroupId?: string(name='DeviceGroupId'),
  ids?: string(name='Ids'),
  projectId?: string(name='ProjectId'),
}

model DeleteVersionGroupDeviceByIdResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVersionGroupDeviceByIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVersionGroupDeviceByIdResponseBody(name='body'),
}

async function deleteVersionGroupDeviceByIdWithOptions(request: DeleteVersionGroupDeviceByIdRequest, runtime: Util.RuntimeOptions): DeleteVersionGroupDeviceByIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceGroupId)) {
    query['DeviceGroupId'] = request.deviceGroupId;
  }
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVersionGroupDeviceById',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVersionGroupDeviceById(request: DeleteVersionGroupDeviceByIdRequest): DeleteVersionGroupDeviceByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVersionGroupDeviceByIdWithOptions(request, runtime);
}

model DeleteVersionTestRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
}

model DeleteVersionTestResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVersionTestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVersionTestResponseBody(name='body'),
}

async function deleteVersionTestWithOptions(request: DeleteVersionTestRequest, runtime: Util.RuntimeOptions): DeleteVersionTestResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVersionTest',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVersionTest(request: DeleteVersionTestRequest): DeleteVersionTestResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVersionTestWithOptions(request, runtime);
}

model DeleteVersionWhiteDevicesRequest {
  deviceIdType?: string(name='DeviceIdType'),
  deviceIds?: string(name='DeviceIds'),
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model DeleteVersionWhiteDevicesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVersionWhiteDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVersionWhiteDevicesResponseBody(name='body'),
}

async function deleteVersionWhiteDevicesWithOptions(request: DeleteVersionWhiteDevicesRequest, runtime: Util.RuntimeOptions): DeleteVersionWhiteDevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceIdType)) {
    query['DeviceIdType'] = request.deviceIdType;
  }
  if (!Util.isUnset(request.deviceIds)) {
    query['DeviceIds'] = request.deviceIds;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVersionWhiteDevices',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVersionWhiteDevices(request: DeleteVersionWhiteDevicesRequest): DeleteVersionWhiteDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVersionWhiteDevicesWithOptions(request, runtime);
}

model DeleteVersionWhiteDevicesByIdRequest {
  ids?: string(name='Ids'),
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model DeleteVersionWhiteDevicesByIdResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVersionWhiteDevicesByIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVersionWhiteDevicesByIdResponseBody(name='body'),
}

async function deleteVersionWhiteDevicesByIdWithOptions(request: DeleteVersionWhiteDevicesByIdRequest, runtime: Util.RuntimeOptions): DeleteVersionWhiteDevicesByIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVersionWhiteDevicesById',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVersionWhiteDevicesById(request: DeleteVersionWhiteDevicesByIdRequest): DeleteVersionWhiteDevicesByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVersionWhiteDevicesByIdWithOptions(request, runtime);
}

model DeployFunctionFileRequest {
  deployEnv?: int32(name='DeployEnv'),
  fileId?: string(name='FileId'),
  projectId?: string(name='ProjectId'),
}

model DeployFunctionFileResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeployFunctionFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeployFunctionFileResponseBody(name='body'),
}

async function deployFunctionFileWithOptions(request: DeployFunctionFileRequest, runtime: Util.RuntimeOptions): DeployFunctionFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deployEnv)) {
    query['DeployEnv'] = request.deployEnv;
  }
  if (!Util.isUnset(request.fileId)) {
    query['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeployFunctionFile',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deployFunctionFile(request: DeployFunctionFileRequest): DeployFunctionFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deployFunctionFileWithOptions(request, runtime);
}

model DescribeApiGatewayAppSecurityRequest {
  gatewayAppId?: string(name='GatewayAppId'),
  projectId?: string(name='ProjectId'),
}

model DescribeApiGatewayAppSecurityResponseBody = {
  apiGatewayAppSecurity?: {
    gatewayAppId?: string(name='GatewayAppId'),
    gatewayAppKey?: string(name='GatewayAppKey'),
    gatewayAppSecret?: string(name='GatewayAppSecret'),
    gmtCreate?: long(name='GmtCreate'),
    gmtModified?: long(name='GmtModified'),
  }(name='ApiGatewayAppSecurity'),
  requestId?: string(name='RequestId'),
}

model DescribeApiGatewayAppSecurityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeApiGatewayAppSecurityResponseBody(name='body'),
}

async function describeApiGatewayAppSecurityWithOptions(request: DescribeApiGatewayAppSecurityRequest, runtime: Util.RuntimeOptions): DescribeApiGatewayAppSecurityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.gatewayAppId)) {
    query['GatewayAppId'] = request.gatewayAppId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApiGatewayAppSecurity',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeApiGatewayAppSecurity(request: DescribeApiGatewayAppSecurityRequest): DescribeApiGatewayAppSecurityResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeApiGatewayAppSecurityWithOptions(request, runtime);
}

model DescribeAppVersionRequest {
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
}

model DescribeAppVersionResponseBody = {
  appVersion?: {
    adapters?: [ 
      {
        deviceModelId?: string(name='DeviceModelId'),
        deviceModelName?: string(name='DeviceModelName'),
        id?: long(name='Id'),
        maxOsVersion?: string(name='MaxOsVersion'),
        minOsVersion?: string(name='MinOsVersion'),
        versionId?: long(name='VersionId'),
      }
    ](name='Adapters'),
    apkMd5?: string(name='ApkMd5'),
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appVersion?: string(name='AppVersion'),
    blackVersionList?: string(name='BlackVersionList'),
    downloadUrl?: string(name='DownloadUrl'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModify?: string(name='GmtModify'),
    id?: long(name='Id'),
    installType?: string(name='InstallType'),
    isAllowNewInstall?: string(name='IsAllowNewInstall'),
    isForceUpgrade?: string(name='IsForceUpgrade'),
    isNeedRestart?: string(name='IsNeedRestart'),
    isSilentUpgrade?: string(name='IsSilentUpgrade'),
    md5?: string(name='Md5'),
    originalUrl?: string(name='OriginalUrl'),
    packageName?: string(name='PackageName'),
    releaseNote?: string(name='ReleaseNote'),
    remark?: string(name='Remark'),
    restartAppParam?: string(name='RestartAppParam'),
    restartAppType?: string(name='RestartAppType'),
    restartType?: string(name='RestartType'),
    size?: string(name='Size'),
    status?: string(name='Status'),
    statusName?: string(name='StatusName'),
    versionCode?: long(name='VersionCode'),
    whiteVersionList?: string(name='WhiteVersionList'),
  }(name='AppVersion'),
  requestId?: string(name='RequestId'),
}

model DescribeAppVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAppVersionResponseBody(name='body'),
}

async function describeAppVersionWithOptions(request: DescribeAppVersionRequest, runtime: Util.RuntimeOptions): DescribeAppVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAppVersion',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAppVersion(request: DescribeAppVersionRequest): DescribeAppVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAppVersionWithOptions(request, runtime);
}

model DescribeAssistRTMPServerAddressRequest {
  deviceId?: string(name='DeviceId'),
  projectId?: string(name='ProjectId'),
}

model DescribeAssistRTMPServerAddressResponseBody = {
  OTP?: string(name='OTP'),
  RTMPServer?: string(name='RTMPServer'),
  requestId?: string(name='RequestId'),
}

model DescribeAssistRTMPServerAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAssistRTMPServerAddressResponseBody(name='body'),
}

async function describeAssistRTMPServerAddressWithOptions(request: DescribeAssistRTMPServerAddressRequest, runtime: Util.RuntimeOptions): DescribeAssistRTMPServerAddressResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAssistRTMPServerAddress',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAssistRTMPServerAddress(request: DescribeAssistRTMPServerAddressRequest): DescribeAssistRTMPServerAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAssistRTMPServerAddressWithOptions(request, runtime);
}

model DescribeAssistReportRequest {
  assistId?: string(name='AssistId'),
  projectId?: string(name='ProjectId'),
}

model DescribeAssistReportResponseBody = {
  assistDescription?: string(name='AssistDescription'),
  assistId?: string(name='AssistId'),
  assistReason?: string(name='AssistReason'),
  assistResult?: string(name='AssistResult'),
  assistTag?: string(name='AssistTag'),
  requestId?: string(name='RequestId'),
}

model DescribeAssistReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAssistReportResponseBody(name='body'),
}

async function describeAssistReportWithOptions(request: DescribeAssistReportRequest, runtime: Util.RuntimeOptions): DescribeAssistReportResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAssistReport',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAssistReport(request: DescribeAssistReportRequest): DescribeAssistReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAssistReportWithOptions(request, runtime);
}

model DescribeAssistWSServerAddressRequest {
  deviceId?: string(name='DeviceId'),
  projectId?: string(name='ProjectId'),
}

model DescribeAssistWSServerAddressResponseBody = {
  OTP?: string(name='OTP'),
  requestId?: string(name='RequestId'),
  wsServer?: string(name='WsServer'),
}

model DescribeAssistWSServerAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAssistWSServerAddressResponseBody(name='body'),
}

async function describeAssistWSServerAddressWithOptions(request: DescribeAssistWSServerAddressRequest, runtime: Util.RuntimeOptions): DescribeAssistWSServerAddressResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAssistWSServerAddress',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAssistWSServerAddress(request: DescribeAssistWSServerAddressRequest): DescribeAssistWSServerAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAssistWSServerAddressWithOptions(request, runtime);
}

model DescribeCustomizedFilterRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
}

model DescribeCustomizedFilterResponseBody = {
  customizedFilter?: {
    blackWhiteType?: string(name='BlackWhiteType'),
    gmtCreate?: string(name='GmtCreate'),
    gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
    gmtModify?: string(name='GmtModify'),
    gmtModifyTimestamp?: long(name='GmtModifyTimestamp'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    value?: string(name='Value'),
    valueCompareType?: string(name='ValueCompareType'),
    valueType?: string(name='ValueType'),
    versionId?: long(name='VersionId'),
    versionType?: string(name='VersionType'),
  }(name='CustomizedFilter'),
  requestId?: string(name='RequestId'),
}

model DescribeCustomizedFilterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCustomizedFilterResponseBody(name='body'),
}

async function describeCustomizedFilterWithOptions(request: DescribeCustomizedFilterRequest, runtime: Util.RuntimeOptions): DescribeCustomizedFilterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomizedFilter',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCustomizedFilter(request: DescribeCustomizedFilterRequest): DescribeCustomizedFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomizedFilterWithOptions(request, runtime);
}

model DescribeDefaultSchemaRequest {
  deviceModelId?: string(name='DeviceModelId'),
  projectId?: string(name='ProjectId'),
}

model DescribeDefaultSchemaResponseBody = {
  requestId?: string(name='RequestId'),
  schema?: string(name='Schema'),
}

model DescribeDefaultSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDefaultSchemaResponseBody(name='body'),
}

async function describeDefaultSchemaWithOptions(request: DescribeDefaultSchemaRequest, runtime: Util.RuntimeOptions): DescribeDefaultSchemaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceModelId)) {
    query['DeviceModelId'] = request.deviceModelId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDefaultSchema',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDefaultSchema(request: DescribeDefaultSchemaRequest): DescribeDefaultSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDefaultSchemaWithOptions(request, runtime);
}

model DescribeDeviceBrandRequest {
  deviceBrand?: string(name='DeviceBrand'),
  deviceBrandId?: long(name='DeviceBrandId'),
  length?: string(name='Length'),
  projectId?: string(name='ProjectId'),
  start?: string(name='Start'),
}

model DescribeDeviceBrandResponseBody = {
  deviceBrand?: {
    description?: string(name='Description'),
    deviceBrand?: string(name='DeviceBrand'),
    deviceBrandId?: long(name='DeviceBrandId'),
    manufacture?: string(name='Manufacture'),
    projectId?: string(name='ProjectId'),
  }(name='DeviceBrand'),
  requestId?: string(name='RequestId'),
}

model DescribeDeviceBrandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDeviceBrandResponseBody(name='body'),
}

async function describeDeviceBrandWithOptions(request: DescribeDeviceBrandRequest, runtime: Util.RuntimeOptions): DescribeDeviceBrandResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDeviceBrand',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDeviceBrand(request: DescribeDeviceBrandRequest): DescribeDeviceBrandResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDeviceBrandWithOptions(request, runtime);
}

model DescribeDeviceIdByOuterInfoRequest {
  projectId?: string(name='ProjectId'),
  queryType?: string(name='QueryType'),
  queryValue?: string(name='QueryValue'),
}

model DescribeDeviceIdByOuterInfoResponseBody = {
  deviceId?: string(name='DeviceId'),
  requestId?: string(name='RequestId'),
}

model DescribeDeviceIdByOuterInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDeviceIdByOuterInfoResponseBody(name='body'),
}

async function describeDeviceIdByOuterInfoWithOptions(request: DescribeDeviceIdByOuterInfoRequest, runtime: Util.RuntimeOptions): DescribeDeviceIdByOuterInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDeviceIdByOuterInfo',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDeviceIdByOuterInfo(request: DescribeDeviceIdByOuterInfoRequest): DescribeDeviceIdByOuterInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDeviceIdByOuterInfoWithOptions(request, runtime);
}

model DescribeDeviceInfoRequest {
  deviceId?: string(name='DeviceId'),
  deviceToken?: string(name='DeviceToken'),
  projectId?: string(name='ProjectId'),
}

model DescribeDeviceInfoResponseBody = {
  deviceInfo?: {
    deviceBrand?: string(name='DeviceBrand'),
    deviceId?: string(name='DeviceId'),
    deviceModel?: string(name='DeviceModel'),
    deviceModelId?: long(name='DeviceModelId'),
    deviceType?: string(name='DeviceType'),
    hardwareId?: string(name='HardwareId'),
    macAddress?: string(name='MacAddress'),
    name?: string(name='Name'),
    projectId?: string(name='ProjectId'),
    region?: string(name='Region'),
    serialNumber?: string(name='SerialNumber'),
    softwareId?: string(name='SoftwareId'),
    status?: string(name='Status'),
    usageType?: int32(name='UsageType'),
    usageTypeDesc?: string(name='UsageTypeDesc'),
    uuid?: string(name='Uuid'),
    vin?: string(name='Vin'),
  }(name='DeviceInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeDeviceInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDeviceInfoResponseBody(name='body'),
}

async function describeDeviceInfoWithOptions(request: DescribeDeviceInfoRequest, runtime: Util.RuntimeOptions): DescribeDeviceInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDeviceInfo',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDeviceInfo(request: DescribeDeviceInfoRequest): DescribeDeviceInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDeviceInfoWithOptions(request, runtime);
}

model DescribeDeviceModelRequest {
  deviceModel?: string(name='DeviceModel'),
  deviceModelId?: int32(name='DeviceModelId'),
  projectId?: string(name='ProjectId'),
}

model DescribeDeviceModelResponseBody = {
  deviceModel?: {
    canCreateDeviceId?: int32(name='CanCreateDeviceId'),
    description?: string(name='Description'),
    deviceBrand?: string(name='DeviceBrand'),
    deviceLogoUrl?: string(name='DeviceLogoUrl'),
    deviceModel?: string(name='DeviceModel'),
    deviceModelId?: long(name='DeviceModelId'),
    deviceName?: string(name='DeviceName'),
    deviceType?: string(name='DeviceType'),
    hardwareType?: string(name='HardwareType'),
    initUsageType?: int32(name='InitUsageType'),
    initUsageTypeDesc?: string(name='InitUsageTypeDesc'),
    objectKey?: string(name='ObjectKey'),
    osPlatform?: string(name='OsPlatform'),
    projectId?: string(name='ProjectId'),
    securityChip?: string(name='SecurityChip'),
  }(name='DeviceModel'),
  requestId?: string(name='RequestId'),
}

model DescribeDeviceModelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDeviceModelResponseBody(name='body'),
}

async function describeDeviceModelWithOptions(request: DescribeDeviceModelRequest, runtime: Util.RuntimeOptions): DescribeDeviceModelResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDeviceModel',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDeviceModel(request: DescribeDeviceModelRequest): DescribeDeviceModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDeviceModelWithOptions(request, runtime);
}

model DescribeDeviceOnlineInfoRequest {
  projectId?: string(name='ProjectId'),
  type?: string(name='Type'),
  value?: string(name='Value'),
}

model DescribeDeviceOnlineInfoResponseBody = {
  devices?: [ 
    {
      clientVersion?: string(name='ClientVersion'),
      deviceId?: string(name='DeviceId'),
      iasId?: string(name='IasId'),
      loginTime?: long(name='LoginTime'),
      online?: int32(name='Online'),
      projectId?: string(name='ProjectId'),
      systemVersion?: string(name='SystemVersion'),
      terminal?: string(name='Terminal'),
    }
  ](name='Devices'),
  requestId?: string(name='RequestId'),
}

model DescribeDeviceOnlineInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDeviceOnlineInfoResponseBody(name='body'),
}

async function describeDeviceOnlineInfoWithOptions(request: DescribeDeviceOnlineInfoRequest, runtime: Util.RuntimeOptions): DescribeDeviceOnlineInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDeviceOnlineInfo',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDeviceOnlineInfo(request: DescribeDeviceOnlineInfoRequest): DescribeDeviceOnlineInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDeviceOnlineInfoWithOptions(request, runtime);
}

model DescribeDeviceShadowRequest {
  deviceId?: string(name='DeviceId'),
  deviceModel?: string(name='DeviceModel'),
  path?: string(name='Path'),
  projectId?: string(name='ProjectId'),
  viewSubscribed?: boolean(name='ViewSubscribed'),
}

model DescribeDeviceShadowResponseBody = {
  deviceShadow?: {
    deviceInfo?: string(name='DeviceInfo'),
    deviceShadow?: string(name='DeviceShadow'),
  }(name='DeviceShadow'),
  requestId?: string(name='RequestId'),
}

model DescribeDeviceShadowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDeviceShadowResponseBody(name='body'),
}

async function describeDeviceShadowWithOptions(request: DescribeDeviceShadowRequest, runtime: Util.RuntimeOptions): DescribeDeviceShadowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceId)) {
    query['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.deviceModel)) {
    query['DeviceModel'] = request.deviceModel;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.viewSubscribed)) {
    query['ViewSubscribed'] = request.viewSubscribed;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDeviceShadow',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDeviceShadow(request: DescribeDeviceShadowRequest): DescribeDeviceShadowResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDeviceShadowWithOptions(request, runtime);
}

model DescribeDeviceValiditySchemaRequest {
  deviceModel?: string(name='DeviceModel'),
  projectId?: string(name='ProjectId'),
  schemaVersion?: string(name='SchemaVersion'),
}

model DescribeDeviceValiditySchemaResponseBody = {
  itemList?: [ 
    {
      description?: string(name='Description'),
      enumListStr?: string(name='EnumListStr'),
      exclusiveMaximum?: boolean(name='ExclusiveMaximum'),
      exclusiveMinimum?: boolean(name='ExclusiveMinimum'),
      itemType?: string(name='ItemType'),
      maxLength?: int32(name='MaxLength'),
      maximum?: float(name='Maximum'),
      minLength?: int32(name='MinLength'),
      minimum?: float(name='Minimum'),
      path?: string(name='Path'),
      required?: string(name='Required'),
      type?: string(name='Type'),
    }
  ](name='ItemList'),
  requestId?: string(name='RequestId'),
}

model DescribeDeviceValiditySchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDeviceValiditySchemaResponseBody(name='body'),
}

async function describeDeviceValiditySchemaWithOptions(request: DescribeDeviceValiditySchemaRequest, runtime: Util.RuntimeOptions): DescribeDeviceValiditySchemaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceModel)) {
    query['DeviceModel'] = request.deviceModel;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDeviceValiditySchema',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDeviceValiditySchema(request: DescribeDeviceValiditySchemaRequest): DescribeDeviceValiditySchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDeviceValiditySchemaWithOptions(request, runtime);
}

model DescribeMessageRequest {
  messageId?: long(name='MessageId'),
  projectId?: string(name='ProjectId'),
}

model DescribeMessageResponseBody = {
  message?: {
    ackCnt?: int32(name='AckCnt'),
    action?: string(name='Action'),
    appKey?: string(name='AppKey'),
    appName?: string(name='AppName'),
    audit?: int32(name='Audit'),
    auditMsg?: string(name='AuditMsg'),
    desc?: string(name='Desc'),
    exipiredTime?: long(name='ExipiredTime'),
    gmtCreateTime?: long(name='GmtCreateTime'),
    id?: long(name='Id'),
    parameter?: string(name='Parameter'),
    predictSendCnt?: int32(name='PredictSendCnt'),
    projectId?: string(name='ProjectId'),
    sendStatus?: int32(name='SendStatus'),
    title?: string(name='Title'),
    type?: int32(name='Type'),
    uri?: string(name='Uri'),
  }(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeMessageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMessageResponseBody(name='body'),
}

async function describeMessageWithOptions(request: DescribeMessageRequest, runtime: Util.RuntimeOptions): DescribeMessageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.messageId)) {
    query['MessageId'] = request.messageId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMessage',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMessage(request: DescribeMessageRequest): DescribeMessageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMessageWithOptions(request, runtime);
}

model DescribeOpenAccountRequest {
  idToken?: string(name='IdToken'),
  identityId?: string(name='IdentityId'),
  idp?: string(name='Idp'),
  openId?: string(name='OpenId'),
  projectId?: string(name='ProjectId'),
}

model DescribeOpenAccountResponseBody = {
  openAccount?: {
    aliyunId?: string(name='AliyunId'),
    createAccessKey?: string(name='CreateAccessKey'),
    displayName?: string(name='DisplayName'),
    identityId?: string(name='IdentityId'),
    idp?: string(name='Idp'),
    loginId?: string(name='LoginId'),
    mobile?: string(name='Mobile'),
    openId?: string(name='OpenId'),
    region?: string(name='Region'),
    status?: int32(name='Status'),
    type?: int32(name='Type'),
  }(name='OpenAccount'),
  requestId?: string(name='RequestId'),
}

model DescribeOpenAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeOpenAccountResponseBody(name='body'),
}

async function describeOpenAccountWithOptions(request: DescribeOpenAccountRequest, runtime: Util.RuntimeOptions): DescribeOpenAccountResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOpenAccount',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeOpenAccount(request: DescribeOpenAccountRequest): DescribeOpenAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOpenAccountWithOptions(request, runtime);
}

model DescribeOsVersionRequest {
  projectId?: string(name='ProjectId'),
  versionId?: long(name='VersionId'),
}

model DescribeOsVersionResponseBody = {
  osVersion?: {
    blackVersionList?: string(name='BlackVersionList'),
    deviceModelId?: string(name='DeviceModelId'),
    deviceModelName?: string(name='DeviceModelName'),
    enableMobileDownload?: string(name='EnableMobileDownload'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModify?: string(name='GmtModify'),
    id?: long(name='Id'),
    isForceNightUpgrade?: string(name='IsForceNightUpgrade'),
    isForceUpgrade?: string(name='IsForceUpgrade'),
    isMilestone?: string(name='IsMilestone'),
    maxClientVersion?: string(name='MaxClientVersion'),
    minClientVersion?: string(name='MinClientVersion'),
    mobileDownloadMaxSize?: string(name='MobileDownloadMaxSize'),
    nightUpgradeOption?: {
      downloadType?: string(name='DownloadType'),
      isAllowedCancel?: string(name='IsAllowedCancel'),
      isShowTip?: string(name='IsShowTip'),
    }(name='NightUpgradeOption'),
    releaseNote?: string(name='ReleaseNote'),
    remark?: string(name='Remark'),
    romList?: [ 
      {
        baseVersion?: string(name='BaseVersion'),
        downloadUrl?: string(name='DownloadUrl'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModify?: string(name='GmtModify'),
        id?: long(name='Id'),
        md5?: string(name='Md5'),
        originalUrl?: string(name='OriginalUrl'),
        size?: string(name='Size'),
        splitNum?: string(name='SplitNum'),
        versionId?: long(name='VersionId'),
      }
    ](name='RomList'),
    status?: string(name='Status'),
    statusName?: string(name='StatusName'),
    systemVersion?: string(name='SystemVersion'),
    whiteVersionList?: string(name='WhiteVersionList'),
  }(name='OsVersion'),
  requestId?: string(name='RequestId'),
}

model DescribeOsVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeOsVersionResponseBody(name='body'),
}

async function describeOsVersionWithOptions(request: DescribeOsVersionRequest, runtime: Util.RuntimeOptions): DescribeOsVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOsVersion',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeOsVersion(request: DescribeOsVersionRequest): DescribeOsVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOsVersionWithOptions(request, runtime);
}

model DescribeProjectRequest {
  projectId?: string(name='ProjectId'),
}

model DescribeProjectResponseBody = {
  project?: {
    creator?: string(name='Creator'),
    description?: string(name='Description'),
    gmtCreate?: long(name='GmtCreate'),
    gmtModified?: long(name='GmtModified'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    projectId?: string(name='ProjectId'),
    status?: int32(name='Status'),
    userId?: string(name='UserId'),
    vehicleCommunicationProtocol?: string(name='VehicleCommunicationProtocol'),
  }(name='Project'),
  requestId?: string(name='RequestId'),
}

model DescribeProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeProjectResponseBody(name='body'),
}

async function describeProjectWithOptions(request: DescribeProjectRequest, runtime: Util.RuntimeOptions): DescribeProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeProject',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeProject(request: DescribeProjectRequest): DescribeProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeProjectWithOptions(request, runtime);
}

model DescribeProjectAppSecurityRequest {
  appId?: string(name='AppId'),
  projectId?: string(name='ProjectId'),
}

model DescribeProjectAppSecurityResponseBody = {
  projectAppSecurity?: {
    appId?: string(name='AppId'),
    appKey?: string(name='AppKey'),
    appSecret?: string(name='AppSecret'),
    gmtCreate?: long(name='GmtCreate'),
    gmtModified?: long(name='GmtModified'),
    id?: long(name='Id'),
  }(name='ProjectAppSecurity'),
  requestId?: string(name='RequestId'),
}

model DescribeProjectAppSecurityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeProjectAppSecurityResponseBody(name='body'),
}

async function describeProjectAppSecurityWithOptions(request: DescribeProjectAppSecurityRequest, runtime: Util.RuntimeOptions): DescribeProjectAppSecurityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeProjectAppSecurity',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeProjectAppSecurity(request: DescribeProjectAppSecurityRequest): DescribeProjectAppSecurityResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeProjectAppSecurityWithOptions(request, runtime);
}

model DescribeShadowSchemaRequest {
  deviceModel?: string(name='DeviceModel'),
  isSimple?: boolean(name='IsSimple'),
  projectId?: string(name='ProjectId'),
}

model DescribeShadowSchemaResponseBody = {
  requestId?: string(name='RequestId'),
  schema?: string(name='Schema'),
}

model DescribeShadowSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeShadowSchemaResponseBody(name='body'),
}

async function describeShadowSchemaWithOptions(request: DescribeShadowSchemaRequest, runtime: Util.RuntimeOptions): DescribeShadowSchemaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceModel)) {
    query['DeviceModel'] = request.deviceModel;
  }
  if (!Util.isUnset(request.isSimple)) {
    query['IsSimple'] = request.isSimple;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeShadowSchema',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeShadowSchema(request: DescribeShadowSchemaRequest): DescribeShadowSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeShadowSchemaWithOptions(request, runtime);
}

model DescribeVersionDeviceGroupRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
}

model DescribeVersionDeviceGroupResponseBody = {
  deviceGroup?: {
    description?: string(name='Description'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModify?: string(name='GmtModify'),
    id?: long(name='Id'),
    maxCount?: string(name='MaxCount'),
    name?: string(name='Name'),
  }(name='DeviceGroup'),
  requestId?: string(name='RequestId'),
}

model DescribeVersionDeviceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVersionDeviceGroupResponseBody(name='body'),
}

async function describeVersionDeviceGroupWithOptions(request: DescribeVersionDeviceGroupRequest, runtime: Util.RuntimeOptions): DescribeVersionDeviceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVersionDeviceGroup',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVersionDeviceGroup(request: DescribeVersionDeviceGroupRequest): DescribeVersionDeviceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVersionDeviceGroupWithOptions(request, runtime);
}

model DiagnosisVersionRequest {
  diagnoseStyle?: string(name='DiagnoseStyle'),
  endTime?: string(name='EndTime'),
  idType?: string(name='IdType'),
  originalId?: string(name='OriginalId'),
  projectId?: string(name='ProjectId'),
  startTime?: string(name='StartTime'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model DiagnosisVersionResponseBody = {
  diagnosisResult?: string(name='DiagnosisResult'),
  requestId?: string(name='RequestId'),
}

model DiagnosisVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DiagnosisVersionResponseBody(name='body'),
}

async function diagnosisVersionWithOptions(request: DiagnosisVersionRequest, runtime: Util.RuntimeOptions): DiagnosisVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.diagnoseStyle)) {
    query['DiagnoseStyle'] = request.diagnoseStyle;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.idType)) {
    query['IdType'] = request.idType;
  }
  if (!Util.isUnset(request.originalId)) {
    query['OriginalId'] = request.originalId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DiagnosisVersion',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function diagnosisVersion(request: DiagnosisVersionRequest): DiagnosisVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return diagnosisVersionWithOptions(request, runtime);
}

model FindAppVersionsRequest {
  appId?: string(name='AppId'),
  deviceModelId?: string(name='DeviceModelId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  remark?: string(name='Remark'),
  status?: string(name='Status'),
  versionId?: string(name='VersionId'),
}

model FindAppVersionsResponseBody = {
  appVersionList?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
        appPackageName?: string(name='AppPackageName'),
        appVersion?: string(name='AppVersion'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        gmtModify?: string(name='GmtModify'),
        gmtModifyTimestamp?: long(name='GmtModifyTimestamp'),
        id?: long(name='Id'),
        installType?: string(name='InstallType'),
        isAllowNewInstall?: string(name='IsAllowNewInstall'),
        isForceUpgrade?: string(name='IsForceUpgrade'),
        isNeedRestart?: string(name='IsNeedRestart'),
        isSilentUpgrade?: string(name='IsSilentUpgrade'),
        restartAppParam?: string(name='RestartAppParam'),
        restartAppType?: string(name='RestartAppType'),
        restartType?: string(name='RestartType'),
        status?: string(name='Status'),
        statusName?: string(name='StatusName'),
        versionCode?: string(name='VersionCode'),
      }
    ](name='Items'),
    totalCount?: int32(name='TotalCount'),
  }(name='AppVersionList'),
  requestId?: string(name='RequestId'),
}

model FindAppVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FindAppVersionsResponseBody(name='body'),
}

async function findAppVersionsWithOptions(request: FindAppVersionsRequest, runtime: Util.RuntimeOptions): FindAppVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.deviceModelId)) {
    query['DeviceModelId'] = request.deviceModelId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindAppVersions',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findAppVersions(request: FindAppVersionsRequest): FindAppVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return findAppVersionsWithOptions(request, runtime);
}

model FindCustomizedFiltersRequest {
  name?: string(name='Name'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model FindCustomizedFiltersResponseBody = {
  customizedFilterList?: {
    items?: [ 
      {
        blackWhiteType?: string(name='BlackWhiteType'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        gmtModify?: string(name='GmtModify'),
        gmtModifyTimestamp?: long(name='GmtModifyTimestamp'),
        id?: long(name='Id'),
        name?: string(name='Name'),
        value?: string(name='Value'),
        valueCompareType?: string(name='ValueCompareType'),
      }
    ](name='Items'),
    totalCount?: int32(name='TotalCount'),
  }(name='CustomizedFilterList'),
  requestId?: string(name='RequestId'),
}

model FindCustomizedFiltersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FindCustomizedFiltersResponseBody(name='body'),
}

async function findCustomizedFiltersWithOptions(request: FindCustomizedFiltersRequest, runtime: Util.RuntimeOptions): FindCustomizedFiltersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindCustomizedFilters',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findCustomizedFilters(request: FindCustomizedFiltersRequest): FindCustomizedFiltersResponse {
  var runtime = new Util.RuntimeOptions{};
  return findCustomizedFiltersWithOptions(request, runtime);
}

model FindCustomizedPropertiesRequest {
  name?: string(name='Name'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model FindCustomizedPropertiesResponseBody = {
  customizedPropertyList?: {
    items?: [ 
      {
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        id?: long(name='Id'),
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Items'),
    totalCount?: int32(name='TotalCount'),
  }(name='CustomizedPropertyList'),
  requestId?: string(name='RequestId'),
}

model FindCustomizedPropertiesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FindCustomizedPropertiesResponseBody(name='body'),
}

async function findCustomizedPropertiesWithOptions(request: FindCustomizedPropertiesRequest, runtime: Util.RuntimeOptions): FindCustomizedPropertiesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindCustomizedProperties',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findCustomizedProperties(request: FindCustomizedPropertiesRequest): FindCustomizedPropertiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return findCustomizedPropertiesWithOptions(request, runtime);
}

model FindOsVersionsRequest {
  deviceModelId?: string(name='DeviceModelId'),
  isMilestone?: string(name='IsMilestone'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  remark?: string(name='Remark'),
  status?: string(name='Status'),
  systemVersion?: string(name='SystemVersion'),
  versionId?: string(name='VersionId'),
}

model FindOsVersionsResponseBody = {
  osVersionList?: {
    items?: [ 
      {
        deviceModelId?: string(name='DeviceModelId'),
        deviceModelName?: string(name='DeviceModelName'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        gmtModify?: string(name='GmtModify'),
        gmtModifyTimestamp?: long(name='GmtModifyTimestamp'),
        id?: long(name='Id'),
        isForceNightUpgrade?: string(name='IsForceNightUpgrade'),
        isForceReboot?: string(name='IsForceReboot'),
        isForceUpgrade?: string(name='IsForceUpgrade'),
        isMilestone?: string(name='IsMilestone'),
        isSilentUpgrade?: string(name='IsSilentUpgrade'),
        remark?: string(name='Remark'),
        status?: string(name='Status'),
        statusName?: string(name='StatusName'),
        systemVersion?: string(name='SystemVersion'),
      }
    ](name='Items'),
    totalCount?: int32(name='TotalCount'),
  }(name='OsVersionList'),
  requestId?: string(name='RequestId'),
}

model FindOsVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FindOsVersionsResponseBody(name='body'),
}

async function findOsVersionsWithOptions(request: FindOsVersionsRequest, runtime: Util.RuntimeOptions): FindOsVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceModelId)) {
    query['DeviceModelId'] = request.deviceModelId;
  }
  if (!Util.isUnset(request.isMilestone)) {
    query['IsMilestone'] = request.isMilestone;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindOsVersions',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findOsVersions(request: FindOsVersionsRequest): FindOsVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return findOsVersionsWithOptions(request, runtime);
}

model FindPrepublishPassedDevicesRequest {
  deviceId?: string(name='DeviceId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  prepublishId?: string(name='PrepublishId'),
  projectId?: string(name='ProjectId'),
}

model FindPrepublishPassedDevicesResponseBody = {
  deviceList?: {
    items?: [ 
      {
        deviceId?: string(name='DeviceId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
      }
    ](name='Items'),
    totalCount?: int32(name='TotalCount'),
  }(name='DeviceList'),
  requestId?: string(name='RequestId'),
}

model FindPrepublishPassedDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FindPrepublishPassedDevicesResponseBody(name='body'),
}

async function findPrepublishPassedDevicesWithOptions(request: FindPrepublishPassedDevicesRequest, runtime: Util.RuntimeOptions): FindPrepublishPassedDevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceId)) {
    query['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.prepublishId)) {
    query['PrepublishId'] = request.prepublishId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindPrepublishPassedDevices',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findPrepublishPassedDevices(request: FindPrepublishPassedDevicesRequest): FindPrepublishPassedDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return findPrepublishPassedDevicesWithOptions(request, runtime);
}

model FindPrepublishesByParentIdRequest {
  parentId?: int32(name='ParentId'),
  projectId?: string(name='ProjectId'),
}

model FindPrepublishesByParentIdResponseBody = {
  prepublishList?: {
    items?: [ 
      {
        barrierCount?: string(name='BarrierCount'),
        deviceModelId?: string(name='DeviceModelId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        gmtModify?: string(name='GmtModify'),
        gmtModifyTimestamp?: long(name='GmtModifyTimestamp'),
        id?: long(name='Id'),
        isActive?: string(name='IsActive'),
        isTotalPrepublish?: string(name='IsTotalPrepublish'),
        name?: string(name='Name'),
        parentId?: string(name='ParentId'),
        versionId?: string(name='VersionId'),
        versionType?: string(name='VersionType'),
      }
    ](name='Items'),
    totalCount?: int32(name='TotalCount'),
  }(name='PrepublishList'),
  requestId?: string(name='RequestId'),
}

model FindPrepublishesByParentIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FindPrepublishesByParentIdResponseBody(name='body'),
}

async function findPrepublishesByParentIdWithOptions(request: FindPrepublishesByParentIdRequest, runtime: Util.RuntimeOptions): FindPrepublishesByParentIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.parentId)) {
    query['ParentId'] = request.parentId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindPrepublishesByParentId',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findPrepublishesByParentId(request: FindPrepublishesByParentIdRequest): FindPrepublishesByParentIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return findPrepublishesByParentIdWithOptions(request, runtime);
}

model FindPrepublishesByVersionIdRequest {
  projectId?: string(name='ProjectId'),
  versionId?: int32(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model FindPrepublishesByVersionIdResponseBody = {
  prepublishList?: [ 
    {
      barrierCount?: string(name='BarrierCount'),
      deviceModelId?: string(name='DeviceModelId'),
      deviceModelName?: string(name='DeviceModelName'),
      gmtCreate?: string(name='GmtCreate'),
      gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
      gmtModify?: string(name='GmtModify'),
      gmtModifyTimestamp?: long(name='GmtModifyTimestamp'),
      id?: string(name='Id'),
      isActive?: string(name='IsActive'),
      isTotalPrepublish?: string(name='IsTotalPrepublish'),
      name?: string(name='Name'),
      parentId?: string(name='ParentId'),
      passedCount?: string(name='PassedCount'),
      versionId?: string(name='VersionId'),
      versionType?: string(name='VersionType'),
    }
  ](name='PrepublishList'),
  requestId?: string(name='RequestId'),
}

model FindPrepublishesByVersionIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FindPrepublishesByVersionIdResponseBody(name='body'),
}

async function findPrepublishesByVersionIdWithOptions(request: FindPrepublishesByVersionIdRequest, runtime: Util.RuntimeOptions): FindPrepublishesByVersionIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindPrepublishesByVersionId',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findPrepublishesByVersionId(request: FindPrepublishesByVersionIdRequest): FindPrepublishesByVersionIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return findPrepublishesByVersionIdWithOptions(request, runtime);
}

model FindVersionBlackDevicesRequest {
  deviceId?: string(name='DeviceId'),
  originalId?: string(name='OriginalId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model FindVersionBlackDevicesResponseBody = {
  deviceList?: {
    items?: [ 
      {
        deviceId?: string(name='DeviceId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        id?: long(name='Id'),
        idType?: string(name='IdType'),
        originalId?: string(name='OriginalId'),
      }
    ](name='Items'),
    totalCount?: int32(name='TotalCount'),
  }(name='DeviceList'),
  requestId?: string(name='RequestId'),
}

model FindVersionBlackDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FindVersionBlackDevicesResponseBody(name='body'),
}

async function findVersionBlackDevicesWithOptions(request: FindVersionBlackDevicesRequest, runtime: Util.RuntimeOptions): FindVersionBlackDevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceId)) {
    query['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.originalId)) {
    query['OriginalId'] = request.originalId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindVersionBlackDevices',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findVersionBlackDevices(request: FindVersionBlackDevicesRequest): FindVersionBlackDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return findVersionBlackDevicesWithOptions(request, runtime);
}

model FindVersionDeviceGroupsRequest {
  deviceId?: string(name='DeviceId'),
  name?: string(name='Name'),
  originalId?: string(name='OriginalId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
}

model FindVersionDeviceGroupsResponseBody = {
  deviceGroupList?: {
    items?: [ 
      {
        description?: string(name='Description'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        gmtModify?: string(name='GmtModify'),
        gmtModifyTimestamp?: long(name='GmtModifyTimestamp'),
        id?: long(name='Id'),
        maxCount?: string(name='MaxCount'),
        name?: string(name='Name'),
      }
    ](name='Items'),
    totalCount?: int32(name='TotalCount'),
  }(name='DeviceGroupList'),
  requestId?: string(name='RequestId'),
}

model FindVersionDeviceGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FindVersionDeviceGroupsResponseBody(name='body'),
}

async function findVersionDeviceGroupsWithOptions(request: FindVersionDeviceGroupsRequest, runtime: Util.RuntimeOptions): FindVersionDeviceGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceId)) {
    query['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.originalId)) {
    query['OriginalId'] = request.originalId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindVersionDeviceGroups',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findVersionDeviceGroups(request: FindVersionDeviceGroupsRequest): FindVersionDeviceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return findVersionDeviceGroupsWithOptions(request, runtime);
}

model FindVersionGroupDevicesRequest {
  deviceGroupId?: string(name='DeviceGroupId'),
  deviceId?: string(name='DeviceId'),
  originalId?: string(name='OriginalId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
}

model FindVersionGroupDevicesResponseBody = {
  groupDeviceList?: {
    items?: [ 
      {
        deviceId?: string(name='DeviceId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        id?: string(name='Id'),
        idType?: string(name='IdType'),
        originalId?: string(name='OriginalId'),
      }
    ](name='Items'),
    totalCount?: int32(name='TotalCount'),
  }(name='GroupDeviceList'),
  requestId?: string(name='RequestId'),
}

model FindVersionGroupDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FindVersionGroupDevicesResponseBody(name='body'),
}

async function findVersionGroupDevicesWithOptions(request: FindVersionGroupDevicesRequest, runtime: Util.RuntimeOptions): FindVersionGroupDevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceGroupId)) {
    query['DeviceGroupId'] = request.deviceGroupId;
  }
  if (!Util.isUnset(request.deviceId)) {
    query['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.originalId)) {
    query['OriginalId'] = request.originalId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindVersionGroupDevices',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findVersionGroupDevices(request: FindVersionGroupDevicesRequest): FindVersionGroupDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return findVersionGroupDevicesWithOptions(request, runtime);
}

model FindVersionMessageSendRecordsRequest {
  messageType?: string(name='MessageType'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model FindVersionMessageSendRecordsResponseBody = {
  messageSendRecordList?: {
    items?: [ 
      {
        failedCount?: string(name='FailedCount'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        id?: long(name='Id'),
        messageType?: string(name='MessageType'),
        result?: string(name='Result'),
        resultDesc?: string(name='ResultDesc'),
        skippedCount?: string(name='SkippedCount'),
        succeededCount?: string(name='SucceededCount'),
        targetId?: string(name='TargetId'),
        versionId?: string(name='VersionId'),
      }
    ](name='Items'),
    totalCount?: int32(name='TotalCount'),
  }(name='MessageSendRecordList'),
  requestId?: string(name='RequestId'),
}

model FindVersionMessageSendRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FindVersionMessageSendRecordsResponseBody(name='body'),
}

async function findVersionMessageSendRecordsWithOptions(request: FindVersionMessageSendRecordsRequest, runtime: Util.RuntimeOptions): FindVersionMessageSendRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.messageType)) {
    query['MessageType'] = request.messageType;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindVersionMessageSendRecords',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findVersionMessageSendRecords(request: FindVersionMessageSendRecordsRequest): FindVersionMessageSendRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return findVersionMessageSendRecordsWithOptions(request, runtime);
}

model FindVersionMessagesRequest {
  deviceId?: string(name='DeviceId'),
  messageType?: string(name='MessageType'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  sendRecordId?: string(name='SendRecordId'),
  testId?: string(name='TestId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model FindVersionMessagesResponseBody = {
  messageList?: {
    items?: [ 
      {
        deviceId?: string(name='DeviceId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        gmtModify?: string(name='GmtModify'),
        gmtModifyTimestamp?: long(name='GmtModifyTimestamp'),
        id?: long(name='Id'),
        messageId?: string(name='MessageId'),
        status?: string(name='Status'),
        statusDesc?: string(name='StatusDesc'),
        testId?: string(name='TestId'),
        versionId?: string(name='VersionId'),
      }
    ](name='Items'),
    totalCount?: int32(name='TotalCount'),
  }(name='MessageList'),
  requestId?: string(name='RequestId'),
}

model FindVersionMessagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FindVersionMessagesResponseBody(name='body'),
}

async function findVersionMessagesWithOptions(request: FindVersionMessagesRequest, runtime: Util.RuntimeOptions): FindVersionMessagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceId)) {
    query['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.messageType)) {
    query['MessageType'] = request.messageType;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.sendRecordId)) {
    query['SendRecordId'] = request.sendRecordId;
  }
  if (!Util.isUnset(request.testId)) {
    query['TestId'] = request.testId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindVersionMessages',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findVersionMessages(request: FindVersionMessagesRequest): FindVersionMessagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return findVersionMessagesWithOptions(request, runtime);
}

model FindVersionTestsRequest {
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model FindVersionTestsResponseBody = {
  requestId?: string(name='RequestId'),
  versionTestList?: {
    items?: [ 
      {
        description?: string(name='Description'),
        deviceGroupId?: string(name='DeviceGroupId'),
        deviceGroupName?: string(name='DeviceGroupName'),
        failedCount?: string(name='FailedCount'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        gmtModify?: string(name='GmtModify'),
        gmtModifyTimestamp?: long(name='GmtModifyTimestamp'),
        id?: long(name='Id'),
        name?: string(name='Name'),
        skippedCount?: string(name='SkippedCount'),
        succeededCount?: string(name='SucceededCount'),
        versionId?: string(name='VersionId'),
        versionType?: string(name='VersionType'),
      }
    ](name='Items'),
    totalCount?: int32(name='TotalCount'),
  }(name='VersionTestList'),
}

model FindVersionTestsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FindVersionTestsResponseBody(name='body'),
}

async function findVersionTestsWithOptions(request: FindVersionTestsRequest, runtime: Util.RuntimeOptions): FindVersionTestsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindVersionTests',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findVersionTests(request: FindVersionTestsRequest): FindVersionTestsResponse {
  var runtime = new Util.RuntimeOptions{};
  return findVersionTestsWithOptions(request, runtime);
}

model FindVersionWhiteDevicesRequest {
  deviceId?: string(name='DeviceId'),
  originalId?: string(name='OriginalId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model FindVersionWhiteDevicesResponseBody = {
  deviceList?: {
    items?: [ 
      {
        deviceId?: string(name='DeviceId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        id?: long(name='Id'),
        idType?: string(name='IdType'),
        originalId?: string(name='OriginalId'),
      }
    ](name='Items'),
    totalCount?: int32(name='TotalCount'),
  }(name='DeviceList'),
  requestId?: string(name='RequestId'),
}

model FindVersionWhiteDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FindVersionWhiteDevicesResponseBody(name='body'),
}

async function findVersionWhiteDevicesWithOptions(request: FindVersionWhiteDevicesRequest, runtime: Util.RuntimeOptions): FindVersionWhiteDevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceId)) {
    query['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.originalId)) {
    query['OriginalId'] = request.originalId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindVersionWhiteDevices',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findVersionWhiteDevices(request: FindVersionWhiteDevicesRequest): FindVersionWhiteDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return findVersionWhiteDevicesWithOptions(request, runtime);
}

model GenerateFunctionFileUploadMetaRequest {
  fileName?: string(name='FileName'),
  projectId?: string(name='ProjectId'),
}

model GenerateFunctionFileUploadMetaResponseBody = {
  requestId?: string(name='RequestId'),
  uploadMeta?: {
    objectKey?: string(name='ObjectKey'),
    postObjectPolicy?: {
      accessId?: string(name='AccessId'),
      expire?: string(name='Expire'),
      host?: string(name='Host'),
      policy?: string(name='Policy'),
      signature?: string(name='Signature'),
    }(name='PostObjectPolicy'),
    securityToken?: string(name='SecurityToken'),
  }(name='UploadMeta'),
}

model GenerateFunctionFileUploadMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateFunctionFileUploadMetaResponseBody(name='body'),
}

async function generateFunctionFileUploadMetaWithOptions(request: GenerateFunctionFileUploadMetaRequest, runtime: Util.RuntimeOptions): GenerateFunctionFileUploadMetaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateFunctionFileUploadMeta',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateFunctionFileUploadMeta(request: GenerateFunctionFileUploadMetaRequest): GenerateFunctionFileUploadMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateFunctionFileUploadMetaWithOptions(request, runtime);
}

model GenerateOssPostPolicyRequest {
  accessId?: string(name='AccessId'),
  accessKey?: string(name='AccessKey'),
  ext?: string(name='Ext'),
  projectId?: string(name='ProjectId'),
}

model GenerateOssPostPolicyResponseBody = {
  ossPostPolicy?: {
    accessId?: string(name='AccessId'),
    expire?: string(name='Expire'),
    host?: string(name='Host'),
    policy?: string(name='Policy'),
    signature?: string(name='Signature'),
  }(name='OssPostPolicy'),
  requestId?: string(name='RequestId'),
}

model GenerateOssPostPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateOssPostPolicyResponseBody(name='body'),
}

async function generateOssPostPolicyWithOptions(request: GenerateOssPostPolicyRequest, runtime: Util.RuntimeOptions): GenerateOssPostPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessId)) {
    query['AccessId'] = request.accessId;
  }
  if (!Util.isUnset(request.accessKey)) {
    query['AccessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.ext)) {
    query['Ext'] = request.ext;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateOssPostPolicy',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateOssPostPolicy(request: GenerateOssPostPolicyRequest): GenerateOssPostPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateOssPostPolicyWithOptions(request, runtime);
}

model GenerateOssUploadMetaRequest {
  ext?: string(name='Ext'),
  projectId?: string(name='ProjectId'),
}

model GenerateOssUploadMetaResponseBody = {
  ossUploadMeta?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    bucket?: string(name='Bucket'),
    objectKey?: string(name='ObjectKey'),
    securityToken?: string(name='SecurityToken'),
  }(name='OssUploadMeta'),
  requestId?: string(name='RequestId'),
}

model GenerateOssUploadMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateOssUploadMetaResponseBody(name='body'),
}

async function generateOssUploadMetaWithOptions(request: GenerateOssUploadMetaRequest, runtime: Util.RuntimeOptions): GenerateOssUploadMetaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ext)) {
    query['Ext'] = request.ext;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateOssUploadMeta',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateOssUploadMeta(request: GenerateOssUploadMetaRequest): GenerateOssUploadMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateOssUploadMetaWithOptions(request, runtime);
}

model GenerateSdkDownloadInfoRequest {
  appId?: string(name='AppId'),
  certFileObjectKey?: string(name='CertFileObjectKey'),
  osType?: int32(name='OsType'),
  pkgName?: string(name='PkgName'),
  projectId?: string(name='ProjectId'),
  sdks?: string(name='Sdks'),
}

model GenerateSdkDownloadInfoResponseBody = {
  requestId?: string(name='RequestId'),
  sdkDownloadInfo?: {
    url?: string(name='Url'),
  }(name='SdkDownloadInfo'),
}

model GenerateSdkDownloadInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateSdkDownloadInfoResponseBody(name='body'),
}

async function generateSdkDownloadInfoWithOptions(request: GenerateSdkDownloadInfoRequest, runtime: Util.RuntimeOptions): GenerateSdkDownloadInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.certFileObjectKey)) {
    query['CertFileObjectKey'] = request.certFileObjectKey;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.pkgName)) {
    query['PkgName'] = request.pkgName;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.sdks)) {
    query['Sdks'] = request.sdks;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateSdkDownloadInfo',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateSdkDownloadInfo(request: GenerateSdkDownloadInfoRequest): GenerateSdkDownloadInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateSdkDownloadInfoWithOptions(request, runtime);
}

model GenerateSysAppDownloadInfoRequest {
  certFileObjectKey?: string(name='CertFileObjectKey'),
  osType?: int32(name='OsType'),
  pkgName?: string(name='PkgName'),
  plugins?: string(name='Plugins'),
  projectId?: string(name='ProjectId'),
  signMode?: string(name='SignMode'),
}

model GenerateSysAppDownloadInfoResponseBody = {
  requestId?: string(name='RequestId'),
  sysAppDownloadInfo?: {
    url?: string(name='Url'),
  }(name='SysAppDownloadInfo'),
}

model GenerateSysAppDownloadInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateSysAppDownloadInfoResponseBody(name='body'),
}

async function generateSysAppDownloadInfoWithOptions(request: GenerateSysAppDownloadInfoRequest, runtime: Util.RuntimeOptions): GenerateSysAppDownloadInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certFileObjectKey)) {
    query['CertFileObjectKey'] = request.certFileObjectKey;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.pkgName)) {
    query['PkgName'] = request.pkgName;
  }
  if (!Util.isUnset(request.plugins)) {
    query['Plugins'] = request.plugins;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.signMode)) {
    query['SignMode'] = request.signMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateSysAppDownloadInfo',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateSysAppDownloadInfo(request: GenerateSysAppDownloadInfoRequest): GenerateSysAppDownloadInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateSysAppDownloadInfoWithOptions(request, runtime);
}

model GetDeviceAppUpdateFunnelEventsRequest {
  idType?: string(name='IdType'),
  originalId?: string(name='OriginalId'),
  packageName?: string(name='PackageName'),
  projectId?: string(name='ProjectId'),
  targetVersionCode?: string(name='TargetVersionCode'),
}

model GetDeviceAppUpdateFunnelEventsResponseBody = {
  eventList?: [ 
    {
      deviceId?: string(name='DeviceId'),
      event?: string(name='Event'),
      packageName?: string(name='PackageName'),
      reportTime?: string(name='ReportTime'),
      reportTimestamp?: long(name='ReportTimestamp'),
      targetVersionCode?: string(name='TargetVersionCode'),
      tenantId?: string(name='TenantId'),
    }
  ](name='EventList'),
  requestId?: string(name='RequestId'),
}

model GetDeviceAppUpdateFunnelEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceAppUpdateFunnelEventsResponseBody(name='body'),
}

async function getDeviceAppUpdateFunnelEventsWithOptions(request: GetDeviceAppUpdateFunnelEventsRequest, runtime: Util.RuntimeOptions): GetDeviceAppUpdateFunnelEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.idType)) {
    query['IdType'] = request.idType;
  }
  if (!Util.isUnset(request.originalId)) {
    query['OriginalId'] = request.originalId;
  }
  if (!Util.isUnset(request.packageName)) {
    query['PackageName'] = request.packageName;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.targetVersionCode)) {
    query['TargetVersionCode'] = request.targetVersionCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceAppUpdateFunnelEvents',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceAppUpdateFunnelEvents(request: GetDeviceAppUpdateFunnelEventsRequest): GetDeviceAppUpdateFunnelEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceAppUpdateFunnelEventsWithOptions(request, runtime);
}

model GetDeviceSystemUpdateFunnelEventsRequest {
  idType?: string(name='IdType'),
  originalId?: string(name='OriginalId'),
  projectId?: string(name='ProjectId'),
  targetVersion?: string(name='TargetVersion'),
}

model GetDeviceSystemUpdateFunnelEventsResponseBody = {
  eventList?: [ 
    {
      deviceId?: string(name='DeviceId'),
      event?: string(name='Event'),
      reportTime?: string(name='ReportTime'),
      reportTimestamp?: long(name='ReportTimestamp'),
      targetVersion?: string(name='TargetVersion'),
      tenantId?: string(name='TenantId'),
    }
  ](name='EventList'),
  requestId?: string(name='RequestId'),
}

model GetDeviceSystemUpdateFunnelEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceSystemUpdateFunnelEventsResponseBody(name='body'),
}

async function getDeviceSystemUpdateFunnelEventsWithOptions(request: GetDeviceSystemUpdateFunnelEventsRequest, runtime: Util.RuntimeOptions): GetDeviceSystemUpdateFunnelEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.idType)) {
    query['IdType'] = request.idType;
  }
  if (!Util.isUnset(request.originalId)) {
    query['OriginalId'] = request.originalId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.targetVersion)) {
    query['TargetVersion'] = request.targetVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceSystemUpdateFunnelEvents',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceSystemUpdateFunnelEvents(request: GetDeviceSystemUpdateFunnelEventsRequest): GetDeviceSystemUpdateFunnelEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceSystemUpdateFunnelEventsWithOptions(request, runtime);
}

model GetNamespaceDataRequest {
  accountId?: string(name='AccountId'),
  accountType?: string(name='AccountType'),
  authType?: string(name='AuthType'),
  deviceId?: string(name='DeviceId'),
  deviceIdType?: string(name='DeviceIdType'),
  namespace?: string(name='Namespace'),
  projectId?: string(name='ProjectId'),
}

model GetNamespaceDataResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetNamespaceDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNamespaceDataResponseBody(name='body'),
}

async function getNamespaceDataWithOptions(request: GetNamespaceDataRequest, runtime: Util.RuntimeOptions): GetNamespaceDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountId)) {
    query['AccountId'] = request.accountId;
  }
  if (!Util.isUnset(request.accountType)) {
    query['AccountType'] = request.accountType;
  }
  if (!Util.isUnset(request.authType)) {
    query['AuthType'] = request.authType;
  }
  if (!Util.isUnset(request.deviceId)) {
    query['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.deviceIdType)) {
    query['DeviceIdType'] = request.deviceIdType;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNamespaceData',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNamespaceData(request: GetNamespaceDataRequest): GetNamespaceDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNamespaceDataWithOptions(request, runtime);
}

model GetNamespaceStatisticsDataRequest {
  dimensionType?: string(name='DimensionType'),
  endTime?: string(name='EndTime'),
  namespace?: string(name='Namespace'),
  projectId?: string(name='ProjectId'),
  startTime?: string(name='StartTime'),
}

model GetNamespaceStatisticsDataResponseBody = {
  requestId?: string(name='RequestId'),
  statistics?: {
    categories?: [ long ](name='Categories'),
    series?: [ 
      {
        data?: [ long ](name='Data'),
        name?: string(name='Name'),
      }
    ](name='Series'),
  }(name='Statistics'),
}

model GetNamespaceStatisticsDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNamespaceStatisticsDataResponseBody(name='body'),
}

async function getNamespaceStatisticsDataWithOptions(request: GetNamespaceStatisticsDataRequest, runtime: Util.RuntimeOptions): GetNamespaceStatisticsDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dimensionType)) {
    query['DimensionType'] = request.dimensionType;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNamespaceStatisticsData',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNamespaceStatisticsData(request: GetNamespaceStatisticsDataRequest): GetNamespaceStatisticsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNamespaceStatisticsDataWithOptions(request, runtime);
}

model GetOssUploadMetaRequest {
  ext?: string(name='Ext'),
  projectId?: string(name='ProjectId'),
}

model GetOssUploadMetaResponseBody = {
  ossUploadMeta?: {
    accessKey?: string(name='AccessKey'),
    host?: string(name='Host'),
    objectKey?: string(name='ObjectKey'),
    policy?: string(name='Policy'),
    securityToken?: string(name='SecurityToken'),
    signature?: string(name='Signature'),
  }(name='OssUploadMeta'),
  requestId?: string(name='RequestId'),
}

model GetOssUploadMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOssUploadMetaResponseBody(name='body'),
}

async function getOssUploadMetaWithOptions(request: GetOssUploadMetaRequest, runtime: Util.RuntimeOptions): GetOssUploadMetaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ext)) {
    query['Ext'] = request.ext;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOssUploadMeta',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOssUploadMeta(request: GetOssUploadMetaRequest): GetOssUploadMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOssUploadMetaWithOptions(request, runtime);
}

model InvokeFunctionRequest {
  env?: int32(name='Env'),
  fileId?: long(name='FileId'),
  functionName?: string(name='FunctionName'),
  parameters?: string(name='Parameters'),
  projectId?: string(name='ProjectId'),
}

model InvokeFunctionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    backEndRequestId?: string(name='BackEndRequestId'),
    output?: string(name='Output'),
  }(name='Result'),
}

model InvokeFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InvokeFunctionResponseBody(name='body'),
}

async function invokeFunctionWithOptions(request: InvokeFunctionRequest, runtime: Util.RuntimeOptions): InvokeFunctionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.env)) {
    query['Env'] = request.env;
  }
  if (!Util.isUnset(request.fileId)) {
    query['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InvokeFunction',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function invokeFunction(request: InvokeFunctionRequest): InvokeFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  return invokeFunctionWithOptions(request, runtime);
}

model ListApiGatewayAppsRequest {
  projectId?: string(name='ProjectId'),
}

model ListApiGatewayAppsResponseBody = {
  apiGatewayApps?: [ 
    {
      gatewayAppId?: string(name='GatewayAppId'),
      gatewayAppKey?: string(name='GatewayAppKey'),
      gatewayAppSecret?: string(name='GatewayAppSecret'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      id?: long(name='Id'),
      projectId?: string(name='ProjectId'),
      status?: int32(name='Status'),
      userId?: string(name='UserId'),
    }
  ](name='ApiGatewayApps'),
  requestId?: string(name='RequestId'),
}

model ListApiGatewayAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListApiGatewayAppsResponseBody(name='body'),
}

async function listApiGatewayAppsWithOptions(request: ListApiGatewayAppsRequest, runtime: Util.RuntimeOptions): ListApiGatewayAppsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListApiGatewayApps',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listApiGatewayApps(request: ListApiGatewayAppsRequest): ListApiGatewayAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApiGatewayAppsWithOptions(request, runtime);
}

model ListAppsRequest {
  projectId?: string(name='ProjectId'),
}

model ListAppsResponseBody = {
  apps?: [ 
    {
      appKey?: string(name='AppKey'),
      appName?: string(name='AppName'),
      appPackage?: string(name='AppPackage'),
      osType?: int32(name='OsType'),
    }
  ](name='Apps'),
  requestId?: string(name='RequestId'),
}

model ListAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAppsResponseBody(name='body'),
}

async function listAppsWithOptions(request: ListAppsRequest, runtime: Util.RuntimeOptions): ListAppsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListApps',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listApps(request: ListAppsRequest): ListAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppsWithOptions(request, runtime);
}

model ListAssistActionDetailsRequest {
  actionTimestamp?: string(name='ActionTimestamp'),
  projectId?: string(name='ProjectId'),
}

model ListAssistActionDetailsResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      action?: string(name='Action'),
      createdAt?: long(name='CreatedAt'),
      data?: string(name='Data'),
      deviceId?: string(name='DeviceId'),
      ID?: string(name='ID'),
      timestamp?: string(name='Timestamp'),
      type?: string(name='Type'),
      updatedAt?: long(name='UpdatedAt'),
    }
  ](name='Results'),
}

model ListAssistActionDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAssistActionDetailsResponseBody(name='body'),
}

async function listAssistActionDetailsWithOptions(request: ListAssistActionDetailsRequest, runtime: Util.RuntimeOptions): ListAssistActionDetailsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAssistActionDetails',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAssistActionDetails(request: ListAssistActionDetailsRequest): ListAssistActionDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAssistActionDetailsWithOptions(request, runtime);
}

model ListAssistDevicesRequest {
  condition?: string(name='Condition'),
  pageIndex?: int32(name='PageIndex'),
  perPage?: int32(name='PerPage'),
  projectId?: string(name='ProjectId'),
}

model ListAssistDevicesResponseBody = {
  devices?: [ 
    {
      accessTime?: long(name='AccessTime'),
      deviceId?: string(name='DeviceId'),
      deviceName?: string(name='DeviceName'),
      hardwareId?: string(name='HardwareId'),
      serialNumber?: string(name='SerialNumber'),
      UUID?: string(name='UUID'),
      VIN?: string(name='VIN'),
    }
  ](name='Devices'),
  pageIndex?: int32(name='PageIndex'),
  perPage?: int32(name='PerPage'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAssistDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAssistDevicesResponseBody(name='body'),
}

async function listAssistDevicesWithOptions(request: ListAssistDevicesRequest, runtime: Util.RuntimeOptions): ListAssistDevicesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAssistDevices',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAssistDevices(request: ListAssistDevicesRequest): ListAssistDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAssistDevicesWithOptions(request, runtime);
}

model ListAssistHistoriesRequest {
  condition?: string(name='Condition'),
  pageIndex?: int32(name='PageIndex'),
  perPage?: int32(name='PerPage'),
  projectId?: string(name='ProjectId'),
}

model ListAssistHistoriesResponseBody = {
  histories?: [ 
    {
      deviceId?: string(name='DeviceId'),
      deviceName?: string(name='DeviceName'),
      endTime?: long(name='EndTime'),
      hardwareId?: string(name='HardwareId'),
      ID?: string(name='ID'),
      serialNumber?: string(name='SerialNumber'),
      startTime?: long(name='StartTime'),
      UID?: string(name='UID'),
      UNAME?: string(name='UNAME'),
      UUID?: string(name='UUID'),
      VIN?: string(name='VIN'),
    }
  ](name='Histories'),
  pageIndex?: int32(name='PageIndex'),
  perPage?: int32(name='PerPage'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAssistHistoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAssistHistoriesResponseBody(name='body'),
}

async function listAssistHistoriesWithOptions(request: ListAssistHistoriesRequest, runtime: Util.RuntimeOptions): ListAssistHistoriesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAssistHistories',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAssistHistories(request: ListAssistHistoriesRequest): ListAssistHistoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAssistHistoriesWithOptions(request, runtime);
}

model ListAssistHistoryDetailsRequest {
  assistId?: string(name='AssistId'),
  projectId?: string(name='ProjectId'),
}

model ListAssistHistoryDetailsResponseBody = {
  actions?: [ 
    {
      action?: string(name='Action'),
      assistId?: string(name='AssistId'),
      createdAt?: long(name='CreatedAt'),
      ID?: string(name='ID'),
      timestamp?: string(name='Timestamp'),
      updatedAt?: long(name='UpdatedAt'),
    }
  ](name='Actions'),
  requestId?: string(name='RequestId'),
}

model ListAssistHistoryDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAssistHistoryDetailsResponseBody(name='body'),
}

async function listAssistHistoryDetailsWithOptions(request: ListAssistHistoryDetailsRequest, runtime: Util.RuntimeOptions): ListAssistHistoryDetailsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAssistHistoryDetails',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAssistHistoryDetails(request: ListAssistHistoryDetailsRequest): ListAssistHistoryDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAssistHistoryDetailsWithOptions(request, runtime);
}

model ListClientPluginVersionsRequest {
  osType?: string(name='OsType'),
  pkgName?: string(name='PkgName'),
}

model ListClientPluginVersionsResponseBody = {
  clientPluginVersions?: [ 
    {
      downloadUrl?: string(name='DownloadUrl'),
      id?: long(name='Id'),
      pkgName?: string(name='PkgName'),
      size?: long(name='Size'),
      version?: string(name='Version'),
      versionCode?: long(name='VersionCode'),
    }
  ](name='ClientPluginVersions'),
  requestId?: string(name='RequestId'),
}

model ListClientPluginVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClientPluginVersionsResponseBody(name='body'),
}

async function listClientPluginVersionsWithOptions(request: ListClientPluginVersionsRequest, runtime: Util.RuntimeOptions): ListClientPluginVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.pkgName)) {
    query['PkgName'] = request.pkgName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClientPluginVersions',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClientPluginVersions(request: ListClientPluginVersionsRequest): ListClientPluginVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClientPluginVersionsWithOptions(request, runtime);
}

model ListClientPluginsRequest {
  osType?: string(name='OsType'),
}

model ListClientPluginsResponseBody = {
  clientPlugins?: [ 
    {
      name?: string(name='Name'),
      pkgName?: string(name='PkgName'),
    }
  ](name='ClientPlugins'),
  requestId?: string(name='RequestId'),
}

model ListClientPluginsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClientPluginsResponseBody(name='body'),
}

async function listClientPluginsWithOptions(request: ListClientPluginsRequest, runtime: Util.RuntimeOptions): ListClientPluginsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClientPlugins',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClientPlugins(request: ListClientPluginsRequest): ListClientPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClientPluginsWithOptions(request, runtime);
}

model ListClientSdksRequest {
  osType?: string(name='OsType'),
}

model ListClientSdksResponseBody = {
  clientSdks?: [ 
    {
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      osType?: int32(name='OsType'),
      pkgName?: string(name='PkgName'),
      pkgType?: int32(name='PkgType'),
    }
  ](name='ClientSdks'),
  requestId?: string(name='RequestId'),
}

model ListClientSdksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClientSdksResponseBody(name='body'),
}

async function listClientSdksWithOptions(request: ListClientSdksRequest, runtime: Util.RuntimeOptions): ListClientSdksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClientSdks',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClientSdks(request: ListClientSdksRequest): ListClientSdksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClientSdksWithOptions(request, runtime);
}

model ListConnectLogsRequest {
  deviceId?: string(name='DeviceId'),
  endTime?: int32(name='EndTime'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  startTime?: int32(name='StartTime'),
}

model ListConnectLogsResponseBody = {
  logs?: {
    list?: [ 
      {
        deviceId?: string(name='DeviceId'),
        ip?: string(name='Ip'),
        netWorking?: string(name='NetWorking'),
        sid?: string(name='Sid'),
        status?: string(name='Status'),
        systemVersion?: string(name='SystemVersion'),
        terminal?: string(name='Terminal'),
        time?: long(name='Time'),
      }
    ](name='List'),
    pagination?: {
      pageIndex?: int32(name='PageIndex'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
      totalPageCount?: int32(name='TotalPageCount'),
    }(name='Pagination'),
  }(name='Logs'),
  requestId?: string(name='RequestId'),
}

model ListConnectLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConnectLogsResponseBody(name='body'),
}

async function listConnectLogsWithOptions(request: ListConnectLogsRequest, runtime: Util.RuntimeOptions): ListConnectLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceId)) {
    query['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConnectLogs',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listConnectLogs(request: ListConnectLogsRequest): ListConnectLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConnectLogsWithOptions(request, runtime);
}

model ListDeployedFunctionsRequest {
  fileId?: long(name='FileId'),
  projectId?: string(name='ProjectId'),
}

model ListDeployedFunctionsResponseBody = {
  functions?: [ 
    {
      fileId?: long(name='FileId'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      projectId?: string(name='ProjectId'),
    }
  ](name='Functions'),
  requestId?: string(name='RequestId'),
}

model ListDeployedFunctionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeployedFunctionsResponseBody(name='body'),
}

async function listDeployedFunctionsWithOptions(request: ListDeployedFunctionsRequest, runtime: Util.RuntimeOptions): ListDeployedFunctionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileId)) {
    query['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeployedFunctions',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDeployedFunctions(request: ListDeployedFunctionsRequest): ListDeployedFunctionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDeployedFunctionsWithOptions(request, runtime);
}

model ListDeviceBrandsRequest {
  deviceBrand?: string(name='DeviceBrand'),
  deviceBrandId?: long(name='DeviceBrandId'),
  length?: string(name='Length'),
  projectId?: string(name='ProjectId'),
  start?: string(name='Start'),
}

model ListDeviceBrandsResponseBody = {
  deviceBrands?: [ 
    {
      description?: string(name='Description'),
      deviceBrand?: string(name='DeviceBrand'),
      deviceBrandId?: long(name='DeviceBrandId'),
      manufacture?: string(name='Manufacture'),
      projectId?: string(name='ProjectId'),
    }
  ](name='DeviceBrands'),
  requestId?: string(name='RequestId'),
}

model ListDeviceBrandsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeviceBrandsResponseBody(name='body'),
}

async function listDeviceBrandsWithOptions(request: ListDeviceBrandsRequest, runtime: Util.RuntimeOptions): ListDeviceBrandsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeviceBrands',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDeviceBrands(request: ListDeviceBrandsRequest): ListDeviceBrandsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDeviceBrandsWithOptions(request, runtime);
}

model ListDeviceModelsRequest {
  deviceBrand?: string(name='DeviceBrand'),
  deviceBrandId?: long(name='DeviceBrandId'),
  deviceModel?: string(name='DeviceModel'),
  deviceModelId?: int32(name='DeviceModelId'),
  length?: string(name='Length'),
  projectId?: string(name='ProjectId'),
  start?: string(name='Start'),
}

model ListDeviceModelsResponseBody = {
  deviceModels?: [ 
    {
      canCreateDeviceId?: int32(name='CanCreateDeviceId'),
      description?: string(name='Description'),
      deviceBrand?: string(name='DeviceBrand'),
      deviceLogoUrl?: string(name='DeviceLogoUrl'),
      deviceModel?: string(name='DeviceModel'),
      deviceModelId?: long(name='DeviceModelId'),
      deviceName?: string(name='DeviceName'),
      deviceType?: string(name='DeviceType'),
      hardwareType?: string(name='HardwareType'),
      initUsageType?: int32(name='InitUsageType'),
      initUsageTypeDesc?: string(name='InitUsageTypeDesc'),
      objectKey?: string(name='ObjectKey'),
      osPlatform?: string(name='OsPlatform'),
      projectId?: string(name='ProjectId'),
      securityChip?: string(name='SecurityChip'),
    }
  ](name='DeviceModels'),
  requestId?: string(name='RequestId'),
}

model ListDeviceModelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeviceModelsResponseBody(name='body'),
}

async function listDeviceModelsWithOptions(request: ListDeviceModelsRequest, runtime: Util.RuntimeOptions): ListDeviceModelsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeviceModels',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDeviceModels(request: ListDeviceModelsRequest): ListDeviceModelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDeviceModelsWithOptions(request, runtime);
}

model ListDeviceTypesRequest {
  projectId?: string(name='ProjectId'),
}

model ListDeviceTypesResponseBody = {
  deviceTypes?: [ 
    {
      deviceType?: string(name='DeviceType'),
      name?: string(name='Name'),
    }
  ](name='DeviceTypes'),
  requestId?: string(name='RequestId'),
}

model ListDeviceTypesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeviceTypesResponseBody(name='body'),
}

async function listDeviceTypesWithOptions(request: ListDeviceTypesRequest, runtime: Util.RuntimeOptions): ListDeviceTypesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeviceTypes',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDeviceTypes(request: ListDeviceTypesRequest): ListDeviceTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDeviceTypesWithOptions(request, runtime);
}

model ListDevicesRequest {
  deviceModel?: string(name='DeviceModel'),
  deviceModelId?: int32(name='DeviceModelId'),
  length?: string(name='Length'),
  projectId?: string(name='ProjectId'),
  start?: string(name='Start'),
}

model ListDevicesResponseBody = {
  devices?: [ 
    {
      deviceBrand?: string(name='DeviceBrand'),
      deviceId?: string(name='DeviceId'),
      deviceModel?: string(name='DeviceModel'),
      deviceModelId?: long(name='DeviceModelId'),
      deviceType?: string(name='DeviceType'),
      hardwareId?: string(name='HardwareId'),
      macAddress?: string(name='MacAddress'),
      name?: string(name='Name'),
      projectId?: string(name='ProjectId'),
      region?: string(name='Region'),
      serialNumber?: string(name='SerialNumber'),
      softwareId?: string(name='SoftwareId'),
      status?: string(name='Status'),
      usageType?: int32(name='UsageType'),
      usageTypeDesc?: string(name='UsageTypeDesc'),
      uuid?: string(name='Uuid'),
      vin?: string(name='Vin'),
    }
  ](name='Devices'),
  requestId?: string(name='RequestId'),
}

model ListDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDevicesResponseBody(name='body'),
}

async function listDevicesWithOptions(request: ListDevicesRequest, runtime: Util.RuntimeOptions): ListDevicesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDevices',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDevices(request: ListDevicesRequest): ListDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDevicesWithOptions(request, runtime);
}

model ListFunctionExecuteLogRequest {
  env?: int32(name='Env'),
  fileId?: long(name='FileId'),
  functionName?: string(name='FunctionName'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
}

model ListFunctionExecuteLogResponseBody = {
  logList?: {
    logs?: [ 
      {
        backEndRequestId?: string(name='BackEndRequestId'),
        message?: string(name='Message'),
      }
    ](name='Logs'),
    pagination?: {
      hasNextPage?: boolean(name='HasNextPage'),
      pageIndex?: int32(name='PageIndex'),
      pageSize?: int32(name='PageSize'),
    }(name='Pagination'),
  }(name='LogList'),
  requestId?: string(name='RequestId'),
}

model ListFunctionExecuteLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFunctionExecuteLogResponseBody(name='body'),
}

async function listFunctionExecuteLogWithOptions(request: ListFunctionExecuteLogRequest, runtime: Util.RuntimeOptions): ListFunctionExecuteLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.env)) {
    query['Env'] = request.env;
  }
  if (!Util.isUnset(request.fileId)) {
    query['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctionExecuteLog',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFunctionExecuteLog(request: ListFunctionExecuteLogRequest): ListFunctionExecuteLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFunctionExecuteLogWithOptions(request, runtime);
}

model ListFunctionFilesRequest {
  fileType?: int32(name='FileType'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
}

model ListFunctionFilesResponseBody = {
  fileList?: {
    files?: [ 
      {
        contentId?: long(name='ContentId'),
        description?: string(name='Description'),
        gmtCreate?: long(name='GmtCreate'),
        gmtModified?: long(name='GmtModified'),
        id?: long(name='Id'),
        name?: string(name='Name'),
        productionDeployStatus?: int32(name='ProductionDeployStatus'),
        productionDeployTime?: long(name='ProductionDeployTime'),
        sandboxDeployStatus?: int32(name='SandboxDeployStatus'),
        sandboxDeployTime?: long(name='SandboxDeployTime'),
        status?: int32(name='Status'),
      }
    ](name='Files'),
    pagination?: {
      pageIndex?: int32(name='PageIndex'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
      totalPageCount?: int32(name='TotalPageCount'),
    }(name='Pagination'),
  }(name='FileList'),
  requestId?: string(name='RequestId'),
}

model ListFunctionFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFunctionFilesResponseBody(name='body'),
}

async function listFunctionFilesWithOptions(request: ListFunctionFilesRequest, runtime: Util.RuntimeOptions): ListFunctionFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileType)) {
    query['FileType'] = request.fileType;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctionFiles',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFunctionFiles(request: ListFunctionFilesRequest): ListFunctionFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFunctionFilesWithOptions(request, runtime);
}

model ListFunctionFilesByProjectIdRequest {
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
}

model ListFunctionFilesByProjectIdResponseBody = {
  files?: [ 
    {
      contentId?: long(name='ContentId'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      status?: int32(name='Status'),
      type?: int32(name='Type'),
    }
  ](name='Files'),
  requestId?: string(name='RequestId'),
}

model ListFunctionFilesByProjectIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFunctionFilesByProjectIdResponseBody(name='body'),
}

async function listFunctionFilesByProjectIdWithOptions(request: ListFunctionFilesByProjectIdRequest, runtime: Util.RuntimeOptions): ListFunctionFilesByProjectIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctionFilesByProjectId',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFunctionFilesByProjectId(request: ListFunctionFilesByProjectIdRequest): ListFunctionFilesByProjectIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFunctionFilesByProjectIdWithOptions(request, runtime);
}

model ListMessageAcksRequest {
  deviceId?: string(name='DeviceId'),
  messageId?: long(name='MessageId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
}

model ListMessageAcksResponseBody = {
  messageAcks?: {
    list?: [ 
      {
        ackTime?: long(name='AckTime'),
        deviceId?: string(name='DeviceId'),
        mid?: long(name='Mid'),
      }
    ](name='List'),
    pagination?: {
      pageIndex?: int32(name='PageIndex'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
      totalPageCount?: int32(name='TotalPageCount'),
    }(name='Pagination'),
  }(name='MessageAcks'),
  requestId?: string(name='RequestId'),
}

model ListMessageAcksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMessageAcksResponseBody(name='body'),
}

async function listMessageAcksWithOptions(request: ListMessageAcksRequest, runtime: Util.RuntimeOptions): ListMessageAcksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceId)) {
    query['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.messageId)) {
    query['MessageId'] = request.messageId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMessageAcks',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMessageAcks(request: ListMessageAcksRequest): ListMessageAcksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMessageAcksWithOptions(request, runtime);
}

model ListMessageReceiversRequest {
  messageId?: string(name='MessageId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
}

model ListMessageReceiversResponseBody = {
  messageReceivers?: {
    list?: [ 
      {
        mid?: long(name='Mid'),
        type?: string(name='Type'),
        value?: string(name='Value'),
      }
    ](name='List'),
    pagination?: {
      pageIndex?: int32(name='PageIndex'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
      totalPageCount?: int32(name='TotalPageCount'),
    }(name='Pagination'),
  }(name='MessageReceivers'),
  requestId?: string(name='RequestId'),
}

model ListMessageReceiversResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMessageReceiversResponseBody(name='body'),
}

async function listMessageReceiversWithOptions(request: ListMessageReceiversRequest, runtime: Util.RuntimeOptions): ListMessageReceiversResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.messageId)) {
    query['MessageId'] = request.messageId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMessageReceivers',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMessageReceivers(request: ListMessageReceiversRequest): ListMessageReceiversResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMessageReceiversWithOptions(request, runtime);
}

model ListNamespacesRequest {
  authType?: string(name='AuthType'),
  projectId?: string(name='ProjectId'),
}

model ListNamespacesResponseBody = {
  namespaces?: [ 
    {
      authType?: int32(name='AuthType'),
      description?: string(name='Description'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      projectId?: string(name='ProjectId'),
      userId?: string(name='UserId'),
    }
  ](name='Namespaces'),
  requestId?: string(name='RequestId'),
}

model ListNamespacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNamespacesResponseBody(name='body'),
}

async function listNamespacesWithOptions(request: ListNamespacesRequest, runtime: Util.RuntimeOptions): ListNamespacesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authType)) {
    query['AuthType'] = request.authType;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNamespaces',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNamespaces(request: ListNamespacesRequest): ListNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNamespacesWithOptions(request, runtime);
}

model ListOfflineMessagesRequest {
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  type?: string(name='Type'),
  value?: string(name='Value'),
}

model ListOfflineMessagesResponseBody = {
  offlineMessages?: {
    list?: [ 
      {
        expiredTime?: long(name='ExpiredTime'),
        gmtCreate?: long(name='GmtCreate'),
        mid?: long(name='Mid'),
      }
    ](name='List'),
    pagination?: {
      pageIndex?: int32(name='PageIndex'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
      totalPageCount?: int32(name='TotalPageCount'),
    }(name='Pagination'),
  }(name='OfflineMessages'),
  requestId?: string(name='RequestId'),
}

model ListOfflineMessagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOfflineMessagesResponseBody(name='body'),
}

async function listOfflineMessagesWithOptions(request: ListOfflineMessagesRequest, runtime: Util.RuntimeOptions): ListOfflineMessagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOfflineMessages',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOfflineMessages(request: ListOfflineMessagesRequest): ListOfflineMessagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOfflineMessagesWithOptions(request, runtime);
}

model ListOpenAccountLinksRequest {
  identityId?: string(name='IdentityId'),
  idp?: string(name='Idp'),
  openId?: string(name='OpenId'),
  projectId?: string(name='ProjectId'),
}

model ListOpenAccountLinksResponseBody = {
  openAccounts?: [ 
    {
      aliyunId?: string(name='AliyunId'),
      createAccessKey?: string(name='CreateAccessKey'),
      displayName?: string(name='DisplayName'),
      identityId?: string(name='IdentityId'),
      idp?: string(name='Idp'),
      loginId?: string(name='LoginId'),
      mobile?: string(name='Mobile'),
      openId?: string(name='OpenId'),
      region?: string(name='Region'),
      status?: int32(name='Status'),
      type?: int32(name='Type'),
    }
  ](name='OpenAccounts'),
  requestId?: string(name='RequestId'),
}

model ListOpenAccountLinksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOpenAccountLinksResponseBody(name='body'),
}

async function listOpenAccountLinksWithOptions(request: ListOpenAccountLinksRequest, runtime: Util.RuntimeOptions): ListOpenAccountLinksResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOpenAccountLinks',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOpenAccountLinks(request: ListOpenAccountLinksRequest): ListOpenAccountLinksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOpenAccountLinksWithOptions(request, runtime);
}

model ListOpenAccountsRequest {
  displayName?: string(name='DisplayName'),
  email?: string(name='Email'),
  length?: int32(name='Length'),
  mobile?: string(name='Mobile'),
  projectId?: string(name='ProjectId'),
  start?: int32(name='Start'),
}

model ListOpenAccountsResponseBody = {
  openAccounts?: [ 
    {
      aliyunId?: string(name='AliyunId'),
      createAccessKey?: string(name='CreateAccessKey'),
      displayName?: string(name='DisplayName'),
      identityId?: string(name='IdentityId'),
      idp?: string(name='Idp'),
      loginId?: string(name='LoginId'),
      mobile?: string(name='Mobile'),
      openId?: string(name='OpenId'),
      region?: string(name='Region'),
      status?: int32(name='Status'),
      type?: int32(name='Type'),
    }
  ](name='OpenAccounts'),
  requestId?: string(name='RequestId'),
}

model ListOpenAccountsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOpenAccountsResponseBody(name='body'),
}

async function listOpenAccountsWithOptions(request: ListOpenAccountsRequest, runtime: Util.RuntimeOptions): ListOpenAccountsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOpenAccounts',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOpenAccounts(request: ListOpenAccountsRequest): ListOpenAccountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOpenAccountsWithOptions(request, runtime);
}

model ListPreChecksResponseBody = {
  preChecks?: [ 
    {
      key?: string(name='Key'),
      link?: string(name='Link'),
      price?: string(name='Price'),
      state?: string(name='State'),
    }
  ](name='PreChecks'),
  requestId?: string(name='RequestId'),
}

model ListPreChecksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPreChecksResponseBody(name='body'),
}

async function listPreChecksWithOptions(runtime: Util.RuntimeOptions): ListPreChecksResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListPreChecks',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPreChecks(): ListPreChecksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPreChecksWithOptions(runtime);
}

model ListProjectAppsRequest {
  keywords?: string(name='Keywords'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
}

model ListProjectAppsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    projectApps?: [ 
      {
        appId?: string(name='AppId'),
        appKey?: string(name='AppKey'),
        appName?: string(name='AppName'),
        appPkgName?: string(name='AppPkgName'),
        appSecret?: string(name='AppSecret'),
        gmtCreate?: long(name='GmtCreate'),
        gmtModified?: long(name='GmtModified'),
        id?: long(name='Id'),
        osType?: int32(name='OsType'),
        projectId?: string(name='ProjectId'),
        status?: int32(name='Status'),
        userId?: string(name='UserId'),
      }
    ](name='ProjectApps'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Result'),
}

model ListProjectAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProjectAppsResponseBody(name='body'),
}

async function listProjectAppsWithOptions(request: ListProjectAppsRequest, runtime: Util.RuntimeOptions): ListProjectAppsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keywords)) {
    query['Keywords'] = request.keywords;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProjectApps',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProjectApps(request: ListProjectAppsRequest): ListProjectAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectAppsWithOptions(request, runtime);
}

model ListProjectsResponseBody = {
  projects?: [ 
    {
      creator?: string(name='Creator'),
      description?: string(name='Description'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      projectId?: string(name='ProjectId'),
      status?: int32(name='Status'),
      userId?: string(name='UserId'),
    }
  ](name='Projects'),
  requestId?: string(name='RequestId'),
}

model ListProjectsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProjectsResponseBody(name='body'),
}

async function listProjectsWithOptions(runtime: Util.RuntimeOptions): ListProjectsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListProjects',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProjects(): ListProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectsWithOptions(runtime);
}

model ListRpcServicesRequest {
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
}

model ListRpcServicesResponseBody = {
  requestId?: string(name='RequestId'),
  rpcServices?: {
    list?: [ 
      {
        appKey?: string(name='AppKey'),
        gmtCreate?: long(name='GmtCreate'),
        gmtModified?: long(name='GmtModified'),
        groupName?: string(name='GroupName'),
        id?: long(name='Id'),
        interfaceName?: string(name='InterfaceName'),
        isDelete?: string(name='IsDelete'),
        methodName?: string(name='MethodName'),
        params?: string(name='Params'),
        type?: string(name='Type'),
        versionCode?: string(name='VersionCode'),
      }
    ](name='List'),
    pagination?: {
      pageIndex?: int32(name='PageIndex'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
      totalPageCount?: int32(name='TotalPageCount'),
    }(name='Pagination'),
  }(name='RpcServices'),
}

model ListRpcServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRpcServicesResponseBody(name='body'),
}

async function listRpcServicesWithOptions(request: ListRpcServicesRequest, runtime: Util.RuntimeOptions): ListRpcServicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRpcServices',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRpcServices(request: ListRpcServicesRequest): ListRpcServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRpcServicesWithOptions(request, runtime);
}

model ListSchemaSubscribesRequest {
  deviceModel?: string(name='DeviceModel'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
}

model ListSchemaSubscribesResponseBody = {
  pageList?: [ 
    {
      list?: [ 
        {
          deviceModel?: string(name='DeviceModel'),
          deviceModelId?: long(name='DeviceModelId'),
          gmtCreate?: long(name='GmtCreate'),
          gmtModified?: long(name='GmtModified'),
          id?: long(name='Id'),
          namespace?: string(name='Namespace'),
          projectId?: string(name='ProjectId'),
          validitySchema?: string(name='ValiditySchema'),
          version?: string(name='Version'),
        }
      ](name='List'),
      pagination?: {
        hasNextPage?: boolean(name='HasNextPage'),
        pageIndex?: int32(name='PageIndex'),
        pageSize?: int32(name='PageSize'),
        simpleSign?: boolean(name='SimpleSign'),
        totalCount?: int32(name='TotalCount'),
        totalPageCount?: int32(name='TotalPageCount'),
      }(name='Pagination'),
    }
  ](name='PageList'),
  requestId?: string(name='RequestId'),
}

model ListSchemaSubscribesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSchemaSubscribesResponseBody(name='body'),
}

async function listSchemaSubscribesWithOptions(request: ListSchemaSubscribesRequest, runtime: Util.RuntimeOptions): ListSchemaSubscribesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSchemaSubscribes',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSchemaSubscribes(request: ListSchemaSubscribesRequest): ListSchemaSubscribesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSchemaSubscribesWithOptions(request, runtime);
}

model ListServicesResponseBody = {
  requestId?: string(name='RequestId'),
  serviceList?: [ string ](name='ServiceList'),
}

model ListServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServicesResponseBody(name='body'),
}

async function listServicesWithOptions(runtime: Util.RuntimeOptions): ListServicesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListServices',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServices(): ListServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServicesWithOptions(runtime);
}

model ListShadowSchemaDeviceModelsRequest {
  projectId?: string(name='ProjectId'),
}

model ListShadowSchemaDeviceModelsResponseBody = {
  modelList?: [ 
    {
      canCreateDeviceId?: int32(name='CanCreateDeviceId'),
      description?: string(name='Description'),
      deviceBrand?: string(name='DeviceBrand'),
      deviceModel?: string(name='DeviceModel'),
      deviceModelId?: long(name='DeviceModelId'),
      deviceType?: string(name='DeviceType'),
      hardwareType?: string(name='HardwareType'),
      initUsageType?: int32(name='InitUsageType'),
      initUsageTypeDesc?: string(name='InitUsageTypeDesc'),
      osPlatform?: string(name='OsPlatform'),
      projectId?: string(name='ProjectId'),
      securityChip?: int32(name='SecurityChip'),
    }
  ](name='ModelList'),
  requestId?: string(name='RequestId'),
}

model ListShadowSchemaDeviceModelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListShadowSchemaDeviceModelsResponseBody(name='body'),
}

async function listShadowSchemaDeviceModelsWithOptions(request: ListShadowSchemaDeviceModelsRequest, runtime: Util.RuntimeOptions): ListShadowSchemaDeviceModelsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListShadowSchemaDeviceModels',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listShadowSchemaDeviceModels(request: ListShadowSchemaDeviceModelsRequest): ListShadowSchemaDeviceModelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listShadowSchemaDeviceModelsWithOptions(request, runtime);
}

model ListShadowSchemasRequest {
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  queryType?: string(name='QueryType'),
  queryValue?: string(name='QueryValue'),
}

model ListShadowSchemasResponseBody = {
  pageList?: {
    list?: [ 
      {
        authType?: int32(name='AuthType'),
        authTypeDesc?: string(name='AuthTypeDesc'),
        deviceModel?: string(name='DeviceModel'),
        deviceModelId?: long(name='DeviceModelId'),
        gmtCreate?: long(name='GmtCreate'),
        gmtModified?: long(name='GmtModified'),
        id?: long(name='Id'),
        moduleSchema?: string(name='ModuleSchema'),
        namespace?: string(name='Namespace'),
        projectId?: string(name='ProjectId'),
      }
    ](name='List'),
    pagination?: {
      hasNextPage?: boolean(name='HasNextPage'),
      pageIndex?: int32(name='PageIndex'),
      pageSize?: int32(name='PageSize'),
      simpleSign?: boolean(name='SimpleSign'),
      totalCount?: int32(name='TotalCount'),
      totalPageCount?: int32(name='TotalPageCount'),
    }(name='Pagination'),
  }(name='PageList'),
  requestId?: string(name='RequestId'),
}

model ListShadowSchemasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListShadowSchemasResponseBody(name='body'),
}

async function listShadowSchemasWithOptions(request: ListShadowSchemasRequest, runtime: Util.RuntimeOptions): ListShadowSchemasResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.queryType)) {
    query['QueryType'] = request.queryType;
  }
  if (!Util.isUnset(request.queryValue)) {
    query['QueryValue'] = request.queryValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListShadowSchemas',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listShadowSchemas(request: ListShadowSchemasRequest): ListShadowSchemasResponse {
  var runtime = new Util.RuntimeOptions{};
  return listShadowSchemasWithOptions(request, runtime);
}

model ListSupportFeaturesResponseBody = {
  requestId?: string(name='RequestId'),
  supportFeatures?: [ 
    {
      name?: string(name='Name'),
    }
  ](name='SupportFeatures'),
}

model ListSupportFeaturesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSupportFeaturesResponseBody(name='body'),
}

async function listSupportFeaturesWithOptions(runtime: Util.RuntimeOptions): ListSupportFeaturesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListSupportFeatures',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSupportFeatures(): ListSupportFeaturesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSupportFeaturesWithOptions(runtime);
}

model ListTriggersRequest {
  namespace?: string(name='Namespace'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
}

model ListTriggersResponseBody = {
  requestId?: string(name='RequestId'),
  triggerList?: {
    pagination?: {
      pageIndex?: int32(name='PageIndex'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
      totalPageCount?: int32(name='TotalPageCount'),
    }(name='Pagination'),
    triggers?: [ 
      {
        chainedFunctionIds?: string(name='ChainedFunctionIds'),
        functions?: [ 
          {
            fileId?: long(name='FileId'),
            fileName?: string(name='FileName'),
            gmtCreate?: long(name='GmtCreate'),
            gmtModified?: long(name='GmtModified'),
            id?: long(name='Id'),
            name?: string(name='Name'),
          }
        ](name='Functions'),
        gmtCreate?: long(name='GmtCreate'),
        gmtModified?: long(name='GmtModified'),
        id?: long(name='Id'),
        invocationMode?: int32(name='InvocationMode'),
        namespace?: string(name='Namespace'),
        production?: int32(name='Production'),
        sandbox?: int32(name='Sandbox'),
        source?: string(name='Source'),
        status?: int32(name='Status'),
        type?: int32(name='Type'),
      }
    ](name='Triggers'),
  }(name='TriggerList'),
}

model ListTriggersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTriggersResponseBody(name='body'),
}

async function listTriggersWithOptions(request: ListTriggersRequest, runtime: Util.RuntimeOptions): ListTriggersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTriggers',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTriggers(request: ListTriggersRequest): ListTriggersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTriggersWithOptions(request, runtime);
}

model ListUpstreamAppKeyRelationsRequest {
  appServerId?: long(name='AppServerId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
}

model ListUpstreamAppKeyRelationsResponseBody = {
  relationList?: {
    list?: [ 
      {
        appKey?: string(name='AppKey'),
        appName?: string(name='AppName'),
        appPackage?: string(name='AppPackage'),
        gmtCreate?: long(name='GmtCreate'),
        id?: long(name='Id'),
        PAppKey?: string(name='PAppKey'),
        projectId?: string(name='ProjectId'),
      }
    ](name='List'),
    pagination?: {
      pageIndex?: int32(name='PageIndex'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
      totalPageCount?: int32(name='TotalPageCount'),
    }(name='Pagination'),
  }(name='RelationList'),
  requestId?: string(name='RequestId'),
}

model ListUpstreamAppKeyRelationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUpstreamAppKeyRelationsResponseBody(name='body'),
}

async function listUpstreamAppKeyRelationsWithOptions(request: ListUpstreamAppKeyRelationsRequest, runtime: Util.RuntimeOptions): ListUpstreamAppKeyRelationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appServerId)) {
    query['AppServerId'] = request.appServerId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUpstreamAppKeyRelations',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUpstreamAppKeyRelations(request: ListUpstreamAppKeyRelationsRequest): ListUpstreamAppKeyRelationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUpstreamAppKeyRelationsWithOptions(request, runtime);
}

model ListUpstreamAppServersRequest {
  pageIndex?: string(name='PageIndex'),
  pageSize?: string(name='PageSize'),
  projectId?: string(name='ProjectId'),
}

model ListUpstreamAppServersResponseBody = {
  appServers?: {
    list?: [ 
      {
        gmtCreate?: long(name='GmtCreate'),
        gmtModified?: long(name='GmtModified'),
        id?: long(name='Id'),
        name?: string(name='Name'),
        PAppKey?: string(name='PAppKey'),
        projectId?: string(name='ProjectId'),
        queueNameList?: string(name='QueueNameList'),
        tags?: string(name='Tags'),
      }
    ](name='List'),
    pagination?: {
      pageIndex?: int32(name='PageIndex'),
      pageSize?: int32(name='PageSize'),
      totalCount?: int32(name='TotalCount'),
      totalPageCount?: int32(name='TotalPageCount'),
    }(name='Pagination'),
  }(name='AppServers'),
  requestId?: string(name='RequestId'),
}

model ListUpstreamAppServersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUpstreamAppServersResponseBody(name='body'),
}

async function listUpstreamAppServersWithOptions(request: ListUpstreamAppServersRequest, runtime: Util.RuntimeOptions): ListUpstreamAppServersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUpstreamAppServers',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUpstreamAppServers(request: ListUpstreamAppServersRequest): ListUpstreamAppServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUpstreamAppServersWithOptions(request, runtime);
}

model ListVersionDeviceGroupsRequest {
  projectId?: string(name='ProjectId'),
}

model ListVersionDeviceGroupsResponseBody = {
  deviceGroupList?: [ 
    {
      description?: string(name='Description'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModify?: string(name='GmtModify'),
      id?: string(name='Id'),
      name?: string(name='Name'),
    }
  ](name='DeviceGroupList'),
  requestId?: string(name='RequestId'),
}

model ListVersionDeviceGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVersionDeviceGroupsResponseBody(name='body'),
}

async function listVersionDeviceGroupsWithOptions(request: ListVersionDeviceGroupsRequest, runtime: Util.RuntimeOptions): ListVersionDeviceGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVersionDeviceGroups',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVersionDeviceGroups(request: ListVersionDeviceGroupsRequest): ListVersionDeviceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVersionDeviceGroupsWithOptions(request, runtime);
}

model PublishAppVersionRequest {
  projectId?: string(name='ProjectId'),
  sendMessage?: boolean(name='SendMessage'),
  versionId?: string(name='VersionId'),
}

model PublishAppVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model PublishAppVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishAppVersionResponseBody(name='body'),
}

async function publishAppVersionWithOptions(request: PublishAppVersionRequest, runtime: Util.RuntimeOptions): PublishAppVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.sendMessage)) {
    query['SendMessage'] = request.sendMessage;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublishAppVersion',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function publishAppVersion(request: PublishAppVersionRequest): PublishAppVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishAppVersionWithOptions(request, runtime);
}

model PublishOsVersionRequest {
  projectId?: string(name='ProjectId'),
  sendMessage?: boolean(name='SendMessage'),
  versionId?: string(name='VersionId'),
}

model PublishOsVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model PublishOsVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishOsVersionResponseBody(name='body'),
}

async function publishOsVersionWithOptions(request: PublishOsVersionRequest, runtime: Util.RuntimeOptions): PublishOsVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.sendMessage)) {
    query['SendMessage'] = request.sendMessage;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublishOsVersion',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function publishOsVersion(request: PublishOsVersionRequest): PublishOsVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishOsVersionWithOptions(request, runtime);
}

model PushMessageRequest {
  act?: string(name='Act'),
  appKey?: string(name='AppKey'),
  appPackage?: string(name='AppPackage'),
  customContent?: string(name='CustomContent'),
  desc?: string(name='Desc'),
  expiredTime?: long(name='ExpiredTime'),
  pkgContent?: string(name='PkgContent'),
  projectId?: string(name='ProjectId'),
  receiverType?: string(name='ReceiverType'),
  receiverValues?: string(name='ReceiverValues'),
  title?: string(name='Title'),
  type?: int32(name='Type'),
  uri?: string(name='Uri'),
}

model PushMessageResponseBody = {
  mid?: long(name='Mid'),
  requestId?: string(name='RequestId'),
}

model PushMessageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PushMessageResponseBody(name='body'),
}

async function pushMessageWithOptions(request: PushMessageRequest, runtime: Util.RuntimeOptions): PushMessageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.act)) {
    query['Act'] = request.act;
  }
  if (!Util.isUnset(request.appKey)) {
    query['AppKey'] = request.appKey;
  }
  if (!Util.isUnset(request.appPackage)) {
    query['AppPackage'] = request.appPackage;
  }
  if (!Util.isUnset(request.customContent)) {
    query['CustomContent'] = request.customContent;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.expiredTime)) {
    query['ExpiredTime'] = request.expiredTime;
  }
  if (!Util.isUnset(request.pkgContent)) {
    query['PkgContent'] = request.pkgContent;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.receiverType)) {
    query['ReceiverType'] = request.receiverType;
  }
  if (!Util.isUnset(request.receiverValues)) {
    query['ReceiverValues'] = request.receiverValues;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uri)) {
    query['Uri'] = request.uri;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PushMessage',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pushMessage(request: PushMessageRequest): PushMessageResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushMessageWithOptions(request, runtime);
}

model PushVersionMessageRequest {
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  versionType?: string(name='VersionType'),
}

model PushVersionMessageResponseBody = {
  requestId?: string(name='RequestId'),
}

model PushVersionMessageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PushVersionMessageResponseBody(name='body'),
}

async function pushVersionMessageWithOptions(request: PushVersionMessageRequest, runtime: Util.RuntimeOptions): PushVersionMessageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.versionType)) {
    query['VersionType'] = request.versionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PushVersionMessage',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pushVersionMessage(request: PushVersionMessageRequest): PushVersionMessageResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushVersionMessageWithOptions(request, runtime);
}

model QueryPrepublishPassedDeviceCountRequest {
  prepublishId?: string(name='PrepublishId'),
  projectId?: string(name='ProjectId'),
}

model QueryPrepublishPassedDeviceCountResponseBody = {
  count?: int32(name='Count'),
  requestId?: string(name='RequestId'),
}

model QueryPrepublishPassedDeviceCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryPrepublishPassedDeviceCountResponseBody(name='body'),
}

async function queryPrepublishPassedDeviceCountWithOptions(request: QueryPrepublishPassedDeviceCountRequest, runtime: Util.RuntimeOptions): QueryPrepublishPassedDeviceCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.prepublishId)) {
    query['PrepublishId'] = request.prepublishId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryPrepublishPassedDeviceCount',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryPrepublishPassedDeviceCount(request: QueryPrepublishPassedDeviceCountRequest): QueryPrepublishPassedDeviceCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPrepublishPassedDeviceCountWithOptions(request, runtime);
}

model SubmitAssistReportRequest {
  assistDescription?: string(name='AssistDescription'),
  assistId?: string(name='AssistId'),
  assistReason?: string(name='AssistReason'),
  assistResult?: string(name='AssistResult'),
  assistTag?: string(name='AssistTag'),
  deviceModel?: string(name='DeviceModel'),
  projectId?: string(name='ProjectId'),
}

model SubmitAssistReportResponseBody = {
  requestId?: string(name='RequestId'),
}

model SubmitAssistReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitAssistReportResponseBody(name='body'),
}

async function submitAssistReportWithOptions(request: SubmitAssistReportRequest, runtime: Util.RuntimeOptions): SubmitAssistReportResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.assistDescription)) {
    body['AssistDescription'] = request.assistDescription;
  }
  if (!Util.isUnset(request.assistId)) {
    body['AssistId'] = request.assistId;
  }
  if (!Util.isUnset(request.assistReason)) {
    body['AssistReason'] = request.assistReason;
  }
  if (!Util.isUnset(request.assistResult)) {
    body['AssistResult'] = request.assistResult;
  }
  if (!Util.isUnset(request.assistTag)) {
    body['AssistTag'] = request.assistTag;
  }
  if (!Util.isUnset(request.deviceModel)) {
    body['DeviceModel'] = request.deviceModel;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SubmitAssistReport',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitAssistReport(request: SubmitAssistReportRequest): SubmitAssistReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAssistReportWithOptions(request, runtime);
}

model UpdateApiGatewayAppStatusRequest {
  gatewayAppId?: string(name='GatewayAppId'),
  projectId?: string(name='ProjectId'),
  status?: int32(name='Status'),
}

model UpdateApiGatewayAppStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateApiGatewayAppStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateApiGatewayAppStatusResponseBody(name='body'),
}

async function updateApiGatewayAppStatusWithOptions(request: UpdateApiGatewayAppStatusRequest, runtime: Util.RuntimeOptions): UpdateApiGatewayAppStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.gatewayAppId)) {
    query['GatewayAppId'] = request.gatewayAppId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApiGatewayAppStatus',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateApiGatewayAppStatus(request: UpdateApiGatewayAppStatusRequest): UpdateApiGatewayAppStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateApiGatewayAppStatusWithOptions(request, runtime);
}

model UpdateAppBlackWhiteVersionsRequest {
  blackAppVersions?: string(name='BlackAppVersions'),
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  whiteAppVersions?: string(name='WhiteAppVersions'),
}

model UpdateAppBlackWhiteVersionsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAppBlackWhiteVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppBlackWhiteVersionsResponseBody(name='body'),
}

async function updateAppBlackWhiteVersionsWithOptions(request: UpdateAppBlackWhiteVersionsRequest, runtime: Util.RuntimeOptions): UpdateAppBlackWhiteVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blackAppVersions)) {
    query['BlackAppVersions'] = request.blackAppVersions;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.whiteAppVersions)) {
    query['WhiteAppVersions'] = request.whiteAppVersions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppBlackWhiteVersions',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAppBlackWhiteVersions(request: UpdateAppBlackWhiteVersionsRequest): UpdateAppBlackWhiteVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppBlackWhiteVersionsWithOptions(request, runtime);
}

model UpdateAppVersionRequest {
  apkMd5?: string(name='ApkMd5'),
  appId?: string(name='AppId'),
  appVersion?: string(name='AppVersion'),
  blackVersionList?: string(name='BlackVersionList'),
  deviceAdapterList?: string(name='DeviceAdapterList'),
  installType?: string(name='InstallType'),
  isAllowNewInstall?: string(name='IsAllowNewInstall'),
  isForceUpgrade?: string(name='IsForceUpgrade'),
  isNeedRestart?: string(name='IsNeedRestart'),
  isSilentUpgrade?: string(name='IsSilentUpgrade'),
  packageUrl?: string(name='PackageUrl'),
  projectId?: string(name='ProjectId'),
  releaseNote?: string(name='ReleaseNote'),
  remark?: string(name='Remark'),
  restartAppParam?: string(name='RestartAppParam'),
  restartAppType?: string(name='RestartAppType'),
  restartType?: string(name='RestartType'),
  versionCode?: string(name='VersionCode'),
  versionId?: string(name='VersionId'),
  whiteVersionList?: string(name='WhiteVersionList'),
}

model UpdateAppVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAppVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppVersionResponseBody(name='body'),
}

async function updateAppVersionWithOptions(request: UpdateAppVersionRequest, runtime: Util.RuntimeOptions): UpdateAppVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apkMd5)) {
    query['ApkMd5'] = request.apkMd5;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.blackVersionList)) {
    query['BlackVersionList'] = request.blackVersionList;
  }
  if (!Util.isUnset(request.deviceAdapterList)) {
    query['DeviceAdapterList'] = request.deviceAdapterList;
  }
  if (!Util.isUnset(request.installType)) {
    query['InstallType'] = request.installType;
  }
  if (!Util.isUnset(request.isAllowNewInstall)) {
    query['IsAllowNewInstall'] = request.isAllowNewInstall;
  }
  if (!Util.isUnset(request.isForceUpgrade)) {
    query['IsForceUpgrade'] = request.isForceUpgrade;
  }
  if (!Util.isUnset(request.isNeedRestart)) {
    query['IsNeedRestart'] = request.isNeedRestart;
  }
  if (!Util.isUnset(request.isSilentUpgrade)) {
    query['IsSilentUpgrade'] = request.isSilentUpgrade;
  }
  if (!Util.isUnset(request.packageUrl)) {
    query['PackageUrl'] = request.packageUrl;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.releaseNote)) {
    query['ReleaseNote'] = request.releaseNote;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.restartAppParam)) {
    query['RestartAppParam'] = request.restartAppParam;
  }
  if (!Util.isUnset(request.restartAppType)) {
    query['RestartAppType'] = request.restartAppType;
  }
  if (!Util.isUnset(request.restartType)) {
    query['RestartType'] = request.restartType;
  }
  if (!Util.isUnset(request.versionCode)) {
    query['VersionCode'] = request.versionCode;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.whiteVersionList)) {
    query['WhiteVersionList'] = request.whiteVersionList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppVersion',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAppVersion(request: UpdateAppVersionRequest): UpdateAppVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppVersionWithOptions(request, runtime);
}

model UpdateAppVersionReleaseNoteRequest {
  projectId?: string(name='ProjectId'),
  releaseNote?: string(name='ReleaseNote'),
  versionId?: string(name='VersionId'),
}

model UpdateAppVersionReleaseNoteResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAppVersionReleaseNoteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppVersionReleaseNoteResponseBody(name='body'),
}

async function updateAppVersionReleaseNoteWithOptions(request: UpdateAppVersionReleaseNoteRequest, runtime: Util.RuntimeOptions): UpdateAppVersionReleaseNoteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.releaseNote)) {
    query['ReleaseNote'] = request.releaseNote;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppVersionReleaseNote',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAppVersionReleaseNote(request: UpdateAppVersionReleaseNoteRequest): UpdateAppVersionReleaseNoteResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppVersionReleaseNoteWithOptions(request, runtime);
}

model UpdateAppVersionRemarkRequest {
  projectId?: string(name='ProjectId'),
  remark?: string(name='Remark'),
  versionId?: string(name='VersionId'),
}

model UpdateAppVersionRemarkResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAppVersionRemarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppVersionRemarkResponseBody(name='body'),
}

async function updateAppVersionRemarkWithOptions(request: UpdateAppVersionRemarkRequest, runtime: Util.RuntimeOptions): UpdateAppVersionRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppVersionRemark',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAppVersionRemark(request: UpdateAppVersionRemarkRequest): UpdateAppVersionRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppVersionRemarkWithOptions(request, runtime);
}

model UpdateAppVersionStatusRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
  status?: string(name='Status'),
}

model UpdateAppVersionStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAppVersionStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppVersionStatusResponseBody(name='body'),
}

async function updateAppVersionStatusWithOptions(request: UpdateAppVersionStatusRequest, runtime: Util.RuntimeOptions): UpdateAppVersionStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppVersionStatus',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAppVersionStatus(request: UpdateAppVersionStatusRequest): UpdateAppVersionStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppVersionStatusWithOptions(request, runtime);
}

model UpdateCustomizedFilterRequest {
  blackWhiteType?: string(name='BlackWhiteType'),
  id?: long(name='Id'),
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
  value?: string(name='Value'),
  valueCompareType?: string(name='ValueCompareType'),
  valueType?: string(name='ValueType'),
}

model UpdateCustomizedFilterResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateCustomizedFilterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCustomizedFilterResponseBody(name='body'),
}

async function updateCustomizedFilterWithOptions(request: UpdateCustomizedFilterRequest, runtime: Util.RuntimeOptions): UpdateCustomizedFilterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blackWhiteType)) {
    query['BlackWhiteType'] = request.blackWhiteType;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  if (!Util.isUnset(request.valueCompareType)) {
    query['ValueCompareType'] = request.valueCompareType;
  }
  if (!Util.isUnset(request.valueType)) {
    query['ValueType'] = request.valueType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCustomizedFilter',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCustomizedFilter(request: UpdateCustomizedFilterRequest): UpdateCustomizedFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCustomizedFilterWithOptions(request, runtime);
}

model UpdateDeviceModelRequest {
  brandName?: string(name='BrandName'),
  canCreateDeviceId?: string(name='CanCreateDeviceId'),
  description?: string(name='Description'),
  deviceName?: string(name='DeviceName'),
  deviceType?: string(name='DeviceType'),
  hardwareType?: string(name='HardwareType'),
  id?: string(name='Id'),
  initUsageType?: string(name='InitUsageType'),
  modelName?: string(name='ModelName'),
  objectKey?: string(name='ObjectKey'),
  osPlatform?: string(name='OsPlatform'),
  projectId?: string(name='ProjectId'),
  securityChip?: string(name='SecurityChip'),
}

model UpdateDeviceModelResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDeviceModelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDeviceModelResponseBody(name='body'),
}

async function updateDeviceModelWithOptions(request: UpdateDeviceModelRequest, runtime: Util.RuntimeOptions): UpdateDeviceModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.brandName)) {
    query['BrandName'] = request.brandName;
  }
  if (!Util.isUnset(request.canCreateDeviceId)) {
    query['CanCreateDeviceId'] = request.canCreateDeviceId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.deviceType)) {
    query['DeviceType'] = request.deviceType;
  }
  if (!Util.isUnset(request.hardwareType)) {
    query['HardwareType'] = request.hardwareType;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.initUsageType)) {
    query['InitUsageType'] = request.initUsageType;
  }
  if (!Util.isUnset(request.modelName)) {
    query['ModelName'] = request.modelName;
  }
  if (!Util.isUnset(request.objectKey)) {
    query['ObjectKey'] = request.objectKey;
  }
  if (!Util.isUnset(request.osPlatform)) {
    query['OsPlatform'] = request.osPlatform;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.securityChip)) {
    query['SecurityChip'] = request.securityChip;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDeviceModel',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDeviceModel(request: UpdateDeviceModelRequest): UpdateDeviceModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDeviceModelWithOptions(request, runtime);
}

model UpdateNamespaceDataRequest {
  accountId?: string(name='AccountId'),
  accountType?: string(name='AccountType'),
  authType?: string(name='AuthType'),
  deviceId?: string(name='DeviceId'),
  deviceIdType?: string(name='DeviceIdType'),
  namespace?: string(name='Namespace'),
  newData?: string(name='NewData'),
  oldData?: string(name='OldData'),
  path?: string(name='Path'),
  projectId?: string(name='ProjectId'),
}

model UpdateNamespaceDataResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateNamespaceDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateNamespaceDataResponseBody(name='body'),
}

async function updateNamespaceDataWithOptions(request: UpdateNamespaceDataRequest, runtime: Util.RuntimeOptions): UpdateNamespaceDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountId)) {
    query['AccountId'] = request.accountId;
  }
  if (!Util.isUnset(request.accountType)) {
    query['AccountType'] = request.accountType;
  }
  if (!Util.isUnset(request.authType)) {
    query['AuthType'] = request.authType;
  }
  if (!Util.isUnset(request.deviceId)) {
    query['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.deviceIdType)) {
    query['DeviceIdType'] = request.deviceIdType;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.newData)) {
    query['NewData'] = request.newData;
  }
  if (!Util.isUnset(request.oldData)) {
    query['OldData'] = request.oldData;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNamespaceData',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateNamespaceData(request: UpdateNamespaceDataRequest): UpdateNamespaceDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNamespaceDataWithOptions(request, runtime);
}

model UpdateOsBlackWhiteVersionsRequest {
  blackVersions?: string(name='BlackVersions'),
  projectId?: string(name='ProjectId'),
  versionId?: string(name='VersionId'),
  whiteVersions?: string(name='WhiteVersions'),
}

model UpdateOsBlackWhiteVersionsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateOsBlackWhiteVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateOsBlackWhiteVersionsResponseBody(name='body'),
}

async function updateOsBlackWhiteVersionsWithOptions(request: UpdateOsBlackWhiteVersionsRequest, runtime: Util.RuntimeOptions): UpdateOsBlackWhiteVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blackVersions)) {
    query['BlackVersions'] = request.blackVersions;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.whiteVersions)) {
    query['WhiteVersions'] = request.whiteVersions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOsBlackWhiteVersions',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateOsBlackWhiteVersions(request: UpdateOsBlackWhiteVersionsRequest): UpdateOsBlackWhiteVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateOsBlackWhiteVersionsWithOptions(request, runtime);
}

model UpdateOsVersionRequest {
  blackVersionList?: string(name='BlackVersionList'),
  deviceModelId?: string(name='DeviceModelId'),
  enableMobileDownload?: string(name='EnableMobileDownload'),
  id?: string(name='Id'),
  isForceNightUpgrade?: string(name='IsForceNightUpgrade'),
  isForceUpgrade?: string(name='IsForceUpgrade'),
  isMilestone?: string(name='IsMilestone'),
  maxClientVersion?: string(name='MaxClientVersion'),
  minClientVersion?: string(name='MinClientVersion'),
  mobileDownloadMaxSize?: string(name='MobileDownloadMaxSize'),
  nightUpgradeDownloadType?: string(name='NightUpgradeDownloadType'),
  nightUpgradeIsAllowedCancel?: string(name='NightUpgradeIsAllowedCancel'),
  nightUpgradeIsShowTip?: string(name='NightUpgradeIsShowTip'),
  projectId?: string(name='ProjectId'),
  releaseNote?: string(name='ReleaseNote'),
  remark?: string(name='Remark'),
  romList?: string(name='RomList'),
  systemVersion?: string(name='SystemVersion'),
  whiteVersionList?: string(name='WhiteVersionList'),
}

model UpdateOsVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateOsVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateOsVersionResponseBody(name='body'),
}

async function updateOsVersionWithOptions(request: UpdateOsVersionRequest, runtime: Util.RuntimeOptions): UpdateOsVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blackVersionList)) {
    query['BlackVersionList'] = request.blackVersionList;
  }
  if (!Util.isUnset(request.deviceModelId)) {
    query['DeviceModelId'] = request.deviceModelId;
  }
  if (!Util.isUnset(request.enableMobileDownload)) {
    query['EnableMobileDownload'] = request.enableMobileDownload;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.isForceNightUpgrade)) {
    query['IsForceNightUpgrade'] = request.isForceNightUpgrade;
  }
  if (!Util.isUnset(request.isForceUpgrade)) {
    query['IsForceUpgrade'] = request.isForceUpgrade;
  }
  if (!Util.isUnset(request.isMilestone)) {
    query['IsMilestone'] = request.isMilestone;
  }
  if (!Util.isUnset(request.maxClientVersion)) {
    query['MaxClientVersion'] = request.maxClientVersion;
  }
  if (!Util.isUnset(request.minClientVersion)) {
    query['MinClientVersion'] = request.minClientVersion;
  }
  if (!Util.isUnset(request.mobileDownloadMaxSize)) {
    query['MobileDownloadMaxSize'] = request.mobileDownloadMaxSize;
  }
  if (!Util.isUnset(request.nightUpgradeDownloadType)) {
    query['NightUpgradeDownloadType'] = request.nightUpgradeDownloadType;
  }
  if (!Util.isUnset(request.nightUpgradeIsAllowedCancel)) {
    query['NightUpgradeIsAllowedCancel'] = request.nightUpgradeIsAllowedCancel;
  }
  if (!Util.isUnset(request.nightUpgradeIsShowTip)) {
    query['NightUpgradeIsShowTip'] = request.nightUpgradeIsShowTip;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.releaseNote)) {
    query['ReleaseNote'] = request.releaseNote;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.romList)) {
    query['RomList'] = request.romList;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  if (!Util.isUnset(request.whiteVersionList)) {
    query['WhiteVersionList'] = request.whiteVersionList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOsVersion',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateOsVersion(request: UpdateOsVersionRequest): UpdateOsVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateOsVersionWithOptions(request, runtime);
}

model UpdateOsVersionReleaseNoteRequest {
  projectId?: string(name='ProjectId'),
  releaseNote?: string(name='ReleaseNote'),
  versionId?: string(name='VersionId'),
}

model UpdateOsVersionReleaseNoteResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateOsVersionReleaseNoteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateOsVersionReleaseNoteResponseBody(name='body'),
}

async function updateOsVersionReleaseNoteWithOptions(request: UpdateOsVersionReleaseNoteRequest, runtime: Util.RuntimeOptions): UpdateOsVersionReleaseNoteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.releaseNote)) {
    query['ReleaseNote'] = request.releaseNote;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOsVersionReleaseNote',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateOsVersionReleaseNote(request: UpdateOsVersionReleaseNoteRequest): UpdateOsVersionReleaseNoteResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateOsVersionReleaseNoteWithOptions(request, runtime);
}

model UpdateOsVersionRemarkRequest {
  projectId?: string(name='ProjectId'),
  remark?: string(name='Remark'),
  versionId?: string(name='VersionId'),
}

model UpdateOsVersionRemarkResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateOsVersionRemarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateOsVersionRemarkResponseBody(name='body'),
}

async function updateOsVersionRemarkWithOptions(request: UpdateOsVersionRemarkRequest, runtime: Util.RuntimeOptions): UpdateOsVersionRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOsVersionRemark',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateOsVersionRemark(request: UpdateOsVersionRemarkRequest): UpdateOsVersionRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateOsVersionRemarkWithOptions(request, runtime);
}

model UpdateOsVersionStatusRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
  status?: string(name='Status'),
}

model UpdateOsVersionStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateOsVersionStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateOsVersionStatusResponseBody(name='body'),
}

async function updateOsVersionStatusWithOptions(request: UpdateOsVersionStatusRequest, runtime: Util.RuntimeOptions): UpdateOsVersionStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOsVersionStatus',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateOsVersionStatus(request: UpdateOsVersionStatusRequest): UpdateOsVersionStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateOsVersionStatusWithOptions(request, runtime);
}

model UpdateProjectRequest {
  description?: string(name='Description'),
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
}

model UpdateProjectResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProjectResponseBody(name='body'),
}

async function updateProjectWithOptions(request: UpdateProjectRequest, runtime: Util.RuntimeOptions): UpdateProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProject',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateProject(request: UpdateProjectRequest): UpdateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProjectWithOptions(request, runtime);
}

model UpdateSchemaSubscribeRequest {
  deviceModel?: string(name='DeviceModel'),
  projectId?: string(name='ProjectId'),
  schemaVersion?: string(name='SchemaVersion'),
  subscribeList?: string(name='SubscribeList'),
}

model UpdateSchemaSubscribeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateSchemaSubscribeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSchemaSubscribeResponseBody(name='body'),
}

async function updateSchemaSubscribeWithOptions(request: UpdateSchemaSubscribeRequest, runtime: Util.RuntimeOptions): UpdateSchemaSubscribeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceModel)) {
    query['DeviceModel'] = request.deviceModel;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.subscribeList)) {
    query['SubscribeList'] = request.subscribeList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSchemaSubscribe',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSchemaSubscribe(request: UpdateSchemaSubscribeRequest): UpdateSchemaSubscribeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSchemaSubscribeWithOptions(request, runtime);
}

model UpdateShadowSchemaRequest {
  authType?: string(name='AuthType'),
  deviceModelId?: string(name='DeviceModelId'),
  id?: string(name='Id'),
  namespace?: string(name='Namespace'),
  projectId?: string(name='ProjectId'),
  schema?: string(name='Schema'),
}

model UpdateShadowSchemaResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateShadowSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateShadowSchemaResponseBody(name='body'),
}

async function updateShadowSchemaWithOptions(request: UpdateShadowSchemaRequest, runtime: Util.RuntimeOptions): UpdateShadowSchemaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authType)) {
    query['AuthType'] = request.authType;
  }
  if (!Util.isUnset(request.deviceModelId)) {
    query['DeviceModelId'] = request.deviceModelId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.schema)) {
    query['Schema'] = request.schema;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateShadowSchema',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateShadowSchema(request: UpdateShadowSchemaRequest): UpdateShadowSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateShadowSchemaWithOptions(request, runtime);
}

model UpdateTriggerRequest {
  id?: long(name='Id'),
  production?: int32(name='Production'),
  projectId?: string(name='ProjectId'),
  sandbox?: int32(name='Sandbox'),
}

model UpdateTriggerResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTriggerResponseBody(name='body'),
}

async function updateTriggerWithOptions(request: UpdateTriggerRequest, runtime: Util.RuntimeOptions): UpdateTriggerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.production)) {
    query['Production'] = request.production;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.sandbox)) {
    query['Sandbox'] = request.sandbox;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTrigger',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTrigger(request: UpdateTriggerRequest): UpdateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTriggerWithOptions(request, runtime);
}

model UpdateUpstreamAppServerRequest {
  id?: long(name='Id'),
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
  tags?: string(name='Tags'),
}

model UpdateUpstreamAppServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateUpstreamAppServerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateUpstreamAppServerResponseBody(name='body'),
}

async function updateUpstreamAppServerWithOptions(request: UpdateUpstreamAppServerRequest, runtime: Util.RuntimeOptions): UpdateUpstreamAppServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUpstreamAppServer',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUpstreamAppServer(request: UpdateUpstreamAppServerRequest): UpdateUpstreamAppServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUpstreamAppServerWithOptions(request, runtime);
}

model UpdateVersionDeviceGroupRequest {
  description?: string(name='Description'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
}

model UpdateVersionDeviceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateVersionDeviceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateVersionDeviceGroupResponseBody(name='body'),
}

async function updateVersionDeviceGroupWithOptions(request: UpdateVersionDeviceGroupRequest, runtime: Util.RuntimeOptions): UpdateVersionDeviceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateVersionDeviceGroup',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateVersionDeviceGroup(request: UpdateVersionDeviceGroupRequest): UpdateVersionDeviceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVersionDeviceGroupWithOptions(request, runtime);
}

model UpdateVersionPrepublishActiveStatusRequest {
  isActive?: string(name='IsActive'),
  prepublishId?: string(name='PrepublishId'),
  projectId?: string(name='ProjectId'),
}

model UpdateVersionPrepublishActiveStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateVersionPrepublishActiveStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateVersionPrepublishActiveStatusResponseBody(name='body'),
}

async function updateVersionPrepublishActiveStatusWithOptions(request: UpdateVersionPrepublishActiveStatusRequest, runtime: Util.RuntimeOptions): UpdateVersionPrepublishActiveStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.isActive)) {
    query['IsActive'] = request.isActive;
  }
  if (!Util.isUnset(request.prepublishId)) {
    query['PrepublishId'] = request.prepublishId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateVersionPrepublishActiveStatus',
    version = '2018-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateVersionPrepublishActiveStatus(request: UpdateVersionPrepublishActiveStatusRequest): UpdateVersionPrepublishActiveStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVersionPrepublishActiveStatusWithOptions(request, runtime);
}

