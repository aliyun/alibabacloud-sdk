/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'arms.aliyuncs.com',
    cn-beijing-finance-1 = 'arms.aliyuncs.com',
    cn-beijing-finance-pop = 'arms.aliyuncs.com',
    cn-beijing-gov-1 = 'arms.aliyuncs.com',
    cn-beijing-nu16-b01 = 'arms.aliyuncs.com',
    cn-edge-1 = 'arms.aliyuncs.com',
    cn-fujian = 'arms.aliyuncs.com',
    cn-haidian-cm12-c01 = 'arms.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'arms.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'arms.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'arms.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'arms.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'arms.aliyuncs.com',
    cn-hangzhou-test-306 = 'arms.aliyuncs.com',
    cn-hongkong-finance-pop = 'arms.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'arms.aliyuncs.com',
    cn-qingdao-nebula = 'arms.aliyuncs.com',
    cn-shanghai-et15-b01 = 'arms.aliyuncs.com',
    cn-shanghai-et2-b01 = 'arms.aliyuncs.com',
    cn-shanghai-inner = 'arms.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'arms.aliyuncs.com',
    cn-shenzhen-inner = 'arms.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'arms.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'arms.aliyuncs.com',
    cn-wuhan = 'arms.aliyuncs.com',
    cn-yushanfang = 'arms.aliyuncs.com',
    cn-zhangbei = 'arms.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'arms.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'arms.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'arms.aliyuncs.com',
    eu-west-1-oxs = 'arms.aliyuncs.com',
    me-east-1 = 'arms.aliyuncs.com',
    rus-west-1-pop = 'arms.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('arms', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ARMSQueryDataSetRequest {
  datasetId?: long(name='DatasetId'),
  dateStr?: string(name='DateStr'),
  dimensions?: [ 
    {
      key?: string(name='Key'),
      type?: string(name='Type'),
      value?: string(name='Value'),
    }
  ](name='Dimensions'),
  hungryMode?: boolean(name='HungryMode'),
  intervalInSec?: int32(name='IntervalInSec'),
  isDrillDown?: boolean(name='IsDrillDown'),
  limit?: int32(name='Limit'),
  maxTime?: long(name='MaxTime'),
  measures?: [ string ](name='Measures'),
  minTime?: long(name='MinTime'),
  optionalDims?: [ 
    {
      key?: string(name='Key'),
      type?: string(name='Type'),
      value?: string(name='Value'),
    }
  ](name='OptionalDims'),
  orderByKey?: string(name='OrderByKey'),
  reduceTail?: boolean(name='ReduceTail'),
  requiredDims?: [ 
    {
      key?: string(name='Key'),
      type?: string(name='Type'),
      value?: string(name='Value'),
    }
  ](name='RequiredDims'),
  securityToken?: string(name='SecurityToken'),
}

model ARMSQueryDataSetResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model ARMSQueryDataSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ARMSQueryDataSetResponseBody(name='body'),
}

async function aRMSQueryDataSetWithOptions(request: ARMSQueryDataSetRequest, runtime: Util.RuntimeOptions): ARMSQueryDataSetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetId)) {
    query['DatasetId'] = request.datasetId;
  }
  if (!Util.isUnset(request.dateStr)) {
    query['DateStr'] = request.dateStr;
  }
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.hungryMode)) {
    query['HungryMode'] = request.hungryMode;
  }
  if (!Util.isUnset(request.intervalInSec)) {
    query['IntervalInSec'] = request.intervalInSec;
  }
  if (!Util.isUnset(request.isDrillDown)) {
    query['IsDrillDown'] = request.isDrillDown;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.maxTime)) {
    query['MaxTime'] = request.maxTime;
  }
  if (!Util.isUnset(request.measures)) {
    query['Measures'] = request.measures;
  }
  if (!Util.isUnset(request.minTime)) {
    query['MinTime'] = request.minTime;
  }
  if (!Util.isUnset(request.optionalDims)) {
    query['OptionalDims'] = request.optionalDims;
  }
  if (!Util.isUnset(request.orderByKey)) {
    query['OrderByKey'] = request.orderByKey;
  }
  if (!Util.isUnset(request.reduceTail)) {
    query['ReduceTail'] = request.reduceTail;
  }
  if (!Util.isUnset(request.requiredDims)) {
    query['RequiredDims'] = request.requiredDims;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ARMSQueryDataSet',
    version = '2018-12-19',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function aRMSQueryDataSet(request: ARMSQueryDataSetRequest): ARMSQueryDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return aRMSQueryDataSetWithOptions(request, runtime);
}

model GetServicesRequest {
  appType?: string(name='AppType'),
  regionId?: string(name='RegionId'),
}

model GetServicesResponseBody = {
  data?: {
    details?: {
      details?: [ 
      {
        pid?: string(name='Pid'),
        regionId?: string(name='RegionId'),
        serviceName?: string(name='ServiceName'),
      }
    ](name='Details')
    }(name='Details'),
    services?: {
      services?: [ string ](name='Services')
    }(name='Services'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServicesResponseBody(name='body'),
}

async function getServicesWithOptions(request: GetServicesRequest, runtime: Util.RuntimeOptions): GetServicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appType)) {
    query['AppType'] = request.appType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetServices',
    version = '2018-12-19',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getServices(request: GetServicesRequest): GetServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServicesWithOptions(request, runtime);
}

model GetTraceRequest {
  appType?: string(name='AppType'),
  regionId?: string(name='RegionId'),
  traceID?: string(name='TraceID'),
}

model GetTraceResponseBody = {
  data?: {
    callChainInfo?: [ 
    {
      duration?: int32(name='Duration'),
      haveStack?: boolean(name='HaveStack'),
      logEventList?: {
        logEvent?: [ 
        {
          tagEntryList?: {
            tagEntry?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
            }
          ](name='TagEntry')
          }(name='TagEntryList'),
          timestamp?: long(name='Timestamp'),
        }
      ](name='LogEvent')
      }(name='LogEventList'),
      operationName?: string(name='OperationName'),
      resultCode?: string(name='ResultCode'),
      rpcId?: string(name='RpcId'),
      serviceIp?: string(name='ServiceIp'),
      serviceName?: string(name='ServiceName'),
      tagEntryList?: {
        tagEntry?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='TagEntry')
      }(name='TagEntryList'),
      timestamp?: long(name='Timestamp'),
      traceID?: string(name='TraceID'),
    }
  ](name='CallChainInfo')
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetTraceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTraceResponseBody(name='body'),
}

async function getTraceWithOptions(request: GetTraceRequest, runtime: Util.RuntimeOptions): GetTraceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appType)) {
    query['AppType'] = request.appType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.traceID)) {
    query['TraceID'] = request.traceID;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTrace',
    version = '2018-12-19',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTrace(request: GetTraceRequest): GetTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTraceWithOptions(request, runtime);
}

model MetricQueryRequest {
  dimensions?: [ string ](name='Dimensions'),
  endTime?: long(name='EndTime'),
  filters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filters'),
  iintervalInSec?: int32(name='IintervalInSec'),
  limit?: int32(name='Limit'),
  measures?: [ string ](name='Measures'),
  metric?: string(name='Metric'),
  order?: string(name='Order'),
  orderBy?: string(name='OrderBy'),
  securityToken?: string(name='SecurityToken'),
  startTime?: long(name='StartTime'),
}

model MetricQueryResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model MetricQueryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MetricQueryResponseBody(name='body'),
}

async function metricQueryWithOptions(request: MetricQueryRequest, runtime: Util.RuntimeOptions): MetricQueryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!Util.isUnset(request.iintervalInSec)) {
    query['IintervalInSec'] = request.iintervalInSec;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.measures)) {
    query['Measures'] = request.measures;
  }
  if (!Util.isUnset(request.metric)) {
    query['Metric'] = request.metric;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MetricQuery',
    version = '2018-12-19',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function metricQuery(request: MetricQueryRequest): MetricQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  return metricQueryWithOptions(request, runtime);
}

model SearchTracesRequest {
  appType?: string(name='AppType'),
  endTime?: long(name='EndTime'),
  minDuration?: long(name='MinDuration'),
  operationName?: string(name='OperationName'),
  regionId?: string(name='RegionId'),
  serviceName?: string(name='ServiceName'),
  startTime?: long(name='StartTime'),
  tag1?: string(name='Tag1'),
  tag2?: string(name='Tag2'),
}

model SearchTracesResponseBody = {
  data?: {
    traceInfo?: [ 
    {
      duration?: int32(name='Duration'),
      operationName?: string(name='OperationName'),
      serviceIp?: string(name='ServiceIp'),
      serviceName?: string(name='ServiceName'),
      timestamp?: long(name='Timestamp'),
      traceID?: string(name='TraceID'),
    }
  ](name='TraceInfo')
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model SearchTracesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchTracesResponseBody(name='body'),
}

async function searchTracesWithOptions(request: SearchTracesRequest, runtime: Util.RuntimeOptions): SearchTracesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appType)) {
    query['AppType'] = request.appType;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.minDuration)) {
    query['MinDuration'] = request.minDuration;
  }
  if (!Util.isUnset(request.operationName)) {
    query['OperationName'] = request.operationName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tag1)) {
    query['Tag1'] = request.tag1;
  }
  if (!Util.isUnset(request.tag2)) {
    query['Tag2'] = request.tag2;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchTraces',
    version = '2018-12-19',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchTraces(request: SearchTracesRequest): SearchTracesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTracesWithOptions(request, runtime);
}

