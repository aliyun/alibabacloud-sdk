/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('outboundbot', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ApplyNumberDistrictInfoParsingResultRequest {
  versionId?: string(name='VersionId'),
}

model ApplyNumberDistrictInfoParsingResultResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ApplyNumberDistrictInfoParsingResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyNumberDistrictInfoParsingResultResponseBody(name='body'),
}

async function applyNumberDistrictInfoParsingResultWithOptions(request: ApplyNumberDistrictInfoParsingResultRequest, runtime: Util.RuntimeOptions): ApplyNumberDistrictInfoParsingResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyNumberDistrictInfoParsingResult',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyNumberDistrictInfoParsingResult(request: ApplyNumberDistrictInfoParsingResultRequest): ApplyNumberDistrictInfoParsingResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyNumberDistrictInfoParsingResultWithOptions(request, runtime);
}

model AssignJobsRequest {
  callingNumber?: [ string ](name='CallingNumber'),
  instanceId?: string(name='InstanceId'),
  isAsynchrony?: boolean(name='IsAsynchrony'),
  jobDataParsingTaskId?: string(name='JobDataParsingTaskId'),
  jobGroupId?: string(name='JobGroupId'),
  jobsJson?: [ string ](name='JobsJson'),
  rosterType?: string(name='RosterType'),
  strategyJson?: string(name='StrategyJson'),
}

model AssignJobsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  jobGroupId?: string(name='JobGroupId'),
  jobsId?: [ string ](name='JobsId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AssignJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssignJobsResponseBody(name='body'),
}

async function assignJobsWithOptions(request: AssignJobsRequest, runtime: Util.RuntimeOptions): AssignJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.callingNumber)) {
    query['CallingNumber'] = request.callingNumber;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.isAsynchrony)) {
    query['IsAsynchrony'] = request.isAsynchrony;
  }
  if (!Util.isUnset(request.jobDataParsingTaskId)) {
    query['JobDataParsingTaskId'] = request.jobDataParsingTaskId;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  if (!Util.isUnset(request.jobsJson)) {
    query['JobsJson'] = request.jobsJson;
  }
  if (!Util.isUnset(request.rosterType)) {
    query['RosterType'] = request.rosterType;
  }
  if (!Util.isUnset(request.strategyJson)) {
    query['StrategyJson'] = request.strategyJson;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssignJobs',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function assignJobs(request: AssignJobsRequest): AssignJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return assignJobsWithOptions(request, runtime);
}

model CancelJobsRequest {
  all?: boolean(name='All'),
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
  jobId?: [ string ](name='JobId'),
  jobReferenceId?: [ string ](name='JobReferenceId'),
  scenarioId?: string(name='ScenarioId'),
}

model CancelJobsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelJobsResponseBody(name='body'),
}

async function cancelJobsWithOptions(request: CancelJobsRequest, runtime: Util.RuntimeOptions): CancelJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.jobReferenceId)) {
    query['JobReferenceId'] = request.jobReferenceId;
  }
  if (!Util.isUnset(request.scenarioId)) {
    query['ScenarioId'] = request.scenarioId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelJobs',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelJobs(request: CancelJobsRequest): CancelJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelJobsWithOptions(request, runtime);
}

model ChangeResourceGroupRequest {
  newResourceGroupId?: string(name='NewResourceGroupId'),
  resourceId?: string(name='ResourceId'),
}

model ChangeResourceGroupResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ChangeResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeResourceGroupResponseBody(name='body'),
}

async function changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, runtime: Util.RuntimeOptions): ChangeResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeResourceGroup',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeResourceGroupWithOptions(request, runtime);
}

model CreateBatchJobsRequest {
  batchJobDescription?: string(name='BatchJobDescription'),
  batchJobName?: string(name='BatchJobName'),
  callingNumber?: [ string ](name='CallingNumber'),
  instanceId?: string(name='InstanceId'),
  jobFilePath?: string(name='JobFilePath'),
  scenarioId?: string(name='ScenarioId'),
  scriptId?: string(name='ScriptId'),
  strategyJson?: string(name='StrategyJson'),
  submitted?: boolean(name='Submitted'),
}

model CreateBatchJobsResponseBody = {
  batchJob?: {
    batchJobId?: string(name='BatchJobId'),
    callingNumbers?: [ string ](name='CallingNumbers'),
    creationTime?: long(name='CreationTime'),
    jobFilePath?: string(name='JobFilePath'),
    jobGroupDescription?: string(name='JobGroupDescription'),
    jobGroupName?: string(name='JobGroupName'),
    scenarioId?: string(name='ScenarioId'),
    strategy?: {
      customized?: string(name='Customized'),
      endTime?: long(name='EndTime'),
      followUpStrategy?: string(name='FollowUpStrategy'),
      isTemplate?: boolean(name='IsTemplate'),
      maxAttemptsPerDay?: int32(name='MaxAttemptsPerDay'),
      minAttemptInterval?: int32(name='MinAttemptInterval'),
      repeatBy?: string(name='RepeatBy'),
      repeatDays?: [ string ](name='RepeatDays'),
      routingStrategy?: string(name='RoutingStrategy'),
      startTime?: long(name='StartTime'),
      strategyDescription?: string(name='StrategyDescription'),
      strategyId?: string(name='StrategyId'),
      strategyName?: string(name='StrategyName'),
      type?: string(name='Type'),
      workingTime?: [ 
        {
          beginTime?: string(name='BeginTime'),
          endTime?: string(name='EndTime'),
        }
      ](name='WorkingTime'),
    }(name='Strategy'),
  }(name='BatchJob'),
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateBatchJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBatchJobsResponseBody(name='body'),
}

async function createBatchJobsWithOptions(request: CreateBatchJobsRequest, runtime: Util.RuntimeOptions): CreateBatchJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.batchJobDescription)) {
    query['BatchJobDescription'] = request.batchJobDescription;
  }
  if (!Util.isUnset(request.batchJobName)) {
    query['BatchJobName'] = request.batchJobName;
  }
  if (!Util.isUnset(request.callingNumber)) {
    query['CallingNumber'] = request.callingNumber;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobFilePath)) {
    query['JobFilePath'] = request.jobFilePath;
  }
  if (!Util.isUnset(request.scenarioId)) {
    query['ScenarioId'] = request.scenarioId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  if (!Util.isUnset(request.strategyJson)) {
    query['StrategyJson'] = request.strategyJson;
  }
  if (!Util.isUnset(request.submitted)) {
    query['Submitted'] = request.submitted;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBatchJobs',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBatchJobs(request: CreateBatchJobsRequest): CreateBatchJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBatchJobsWithOptions(request, runtime);
}

model CreateBatchRepeatJobRequest {
  callingNumber?: [ string ](name='CallingNumber'),
  description?: string(name='Description'),
  filterStatus?: string(name='FilterStatus'),
  instanceId?: string(name='InstanceId'),
  minConcurrency?: long(name='MinConcurrency'),
  name?: string(name='Name'),
  priority?: string(name='Priority'),
  recallStrategyJson?: string(name='RecallStrategyJson'),
  ringingDuration?: long(name='RingingDuration'),
  scriptId?: string(name='ScriptId'),
  sourceGroupId?: string(name='SourceGroupId'),
  strategyJson?: string(name='StrategyJson'),
}

model CreateBatchRepeatJobResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  jobGroup?: {
    id?: string(name='Id'),
    minConcurrency?: long(name='MinConcurrency'),
    priority?: string(name='Priority'),
    ringingDuration?: long(name='RingingDuration'),
  }(name='JobGroup'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateBatchRepeatJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBatchRepeatJobResponseBody(name='body'),
}

async function createBatchRepeatJobWithOptions(request: CreateBatchRepeatJobRequest, runtime: Util.RuntimeOptions): CreateBatchRepeatJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.callingNumber)) {
    query['CallingNumber'] = request.callingNumber;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.filterStatus)) {
    query['FilterStatus'] = request.filterStatus;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.minConcurrency)) {
    query['MinConcurrency'] = request.minConcurrency;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.recallStrategyJson)) {
    query['RecallStrategyJson'] = request.recallStrategyJson;
  }
  if (!Util.isUnset(request.ringingDuration)) {
    query['RingingDuration'] = request.ringingDuration;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  if (!Util.isUnset(request.sourceGroupId)) {
    query['SourceGroupId'] = request.sourceGroupId;
  }
  if (!Util.isUnset(request.strategyJson)) {
    query['StrategyJson'] = request.strategyJson;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBatchRepeatJob',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBatchRepeatJob(request: CreateBatchRepeatJobRequest): CreateBatchRepeatJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBatchRepeatJobWithOptions(request, runtime);
}

model CreateDialogueFlowRequest {
  dialogueFlowType?: string(name='DialogueFlowType'),
  dialogueName?: string(name='DialogueName'),
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
}

model CreateDialogueFlowResponseBody = {
  code?: string(name='Code'),
  dialogueFlowId?: string(name='DialogueFlowId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDialogueFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDialogueFlowResponseBody(name='body'),
}

async function createDialogueFlowWithOptions(request: CreateDialogueFlowRequest, runtime: Util.RuntimeOptions): CreateDialogueFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dialogueFlowType)) {
    query['DialogueFlowType'] = request.dialogueFlowType;
  }
  if (!Util.isUnset(request.dialogueName)) {
    query['DialogueName'] = request.dialogueName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDialogueFlow',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDialogueFlow(request: CreateDialogueFlowRequest): CreateDialogueFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDialogueFlowWithOptions(request, runtime);
}

model CreateDownloadUrlRequest {
  downloadTaskId?: string(name='DownloadTaskId'),
  fileId?: string(name='FileId'),
}

model CreateDownloadUrlResponseBody = {
  code?: string(name='Code'),
  fileHttpUrl?: string(name='FileHttpUrl'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDownloadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDownloadUrlResponseBody(name='body'),
}

async function createDownloadUrlWithOptions(request: CreateDownloadUrlRequest, runtime: Util.RuntimeOptions): CreateDownloadUrlResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDownloadUrl',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDownloadUrl(request: CreateDownloadUrlRequest): CreateDownloadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDownloadUrlWithOptions(request, runtime);
}

model CreateGlobalQuestionRequest {
  answers?: string(name='Answers'),
  globalQuestionName?: string(name='GlobalQuestionName'),
  globalQuestionType?: string(name='GlobalQuestionType'),
  instanceId?: string(name='InstanceId'),
  questions?: string(name='Questions'),
  scriptId?: string(name='ScriptId'),
}

model CreateGlobalQuestionResponseBody = {
  code?: string(name='Code'),
  globalQuestionId?: string(name='GlobalQuestionId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateGlobalQuestionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGlobalQuestionResponseBody(name='body'),
}

async function createGlobalQuestionWithOptions(request: CreateGlobalQuestionRequest, runtime: Util.RuntimeOptions): CreateGlobalQuestionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.answers)) {
    query['Answers'] = request.answers;
  }
  if (!Util.isUnset(request.globalQuestionName)) {
    query['GlobalQuestionName'] = request.globalQuestionName;
  }
  if (!Util.isUnset(request.globalQuestionType)) {
    query['GlobalQuestionType'] = request.globalQuestionType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.questions)) {
    query['Questions'] = request.questions;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGlobalQuestion',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGlobalQuestion(request: CreateGlobalQuestionRequest): CreateGlobalQuestionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGlobalQuestionWithOptions(request, runtime);
}

model CreateInstanceRequest {
  callingNumber?: [ string ](name='CallingNumber'),
  instanceDescription?: string(name='InstanceDescription'),
  instanceName?: string(name='InstanceName'),
  maxConcurrentConversation?: int32(name='MaxConcurrentConversation'),
  nluServiceType?: string(name='NluServiceType'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateInstanceResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  instance?: {
    creationTime?: long(name='CreationTime'),
    creatorId?: long(name='CreatorId'),
    creatorName?: string(name='CreatorName'),
    instanceDescription?: string(name='InstanceDescription'),
    instanceId?: string(name='InstanceId'),
    instanceName?: string(name='InstanceName'),
    maxConcurrentConversation?: int32(name='MaxConcurrentConversation'),
    ownerName?: string(name='OwnerName'),
    resourceGroupId?: string(name='ResourceGroupId'),
  }(name='Instance'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateInstanceResponseBody(name='body'),
}

async function createInstanceWithOptions(request: CreateInstanceRequest, runtime: Util.RuntimeOptions): CreateInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.callingNumber)) {
    query['CallingNumber'] = request.callingNumber;
  }
  if (!Util.isUnset(request.instanceDescription)) {
    query['InstanceDescription'] = request.instanceDescription;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.maxConcurrentConversation)) {
    query['MaxConcurrentConversation'] = request.maxConcurrentConversation;
  }
  if (!Util.isUnset(request.nluServiceType)) {
    query['NluServiceType'] = request.nluServiceType;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateInstance',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInstanceWithOptions(request, runtime);
}

model CreateInstanceBindNumberRequest {
  instanceList?: string(name='InstanceList'),
  number?: string(name='Number'),
}

model CreateInstanceBindNumberResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: [ 
      {
        instanceId?: string(name='InstanceId'),
        success?: boolean(name='Success'),
      }
    ](name='List'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateInstanceBindNumberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateInstanceBindNumberResponseBody(name='body'),
}

async function createInstanceBindNumberWithOptions(request: CreateInstanceBindNumberRequest, runtime: Util.RuntimeOptions): CreateInstanceBindNumberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceList)) {
    query['InstanceList'] = request.instanceList;
  }
  if (!Util.isUnset(request.number)) {
    query['Number'] = request.number;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateInstanceBindNumber',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createInstanceBindNumber(request: CreateInstanceBindNumberRequest): CreateInstanceBindNumberResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInstanceBindNumberWithOptions(request, runtime);
}

model CreateIntentRequest {
  instanceId?: string(name='InstanceId'),
  intentDescription?: string(name='IntentDescription'),
  intentName?: string(name='IntentName'),
  keywords?: string(name='Keywords'),
  scriptId?: string(name='ScriptId'),
  utterances?: string(name='Utterances'),
}

model CreateIntentResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  intentId?: string(name='IntentId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateIntentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIntentResponseBody(name='body'),
}

async function createIntentWithOptions(request: CreateIntentRequest, runtime: Util.RuntimeOptions): CreateIntentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.intentDescription)) {
    query['IntentDescription'] = request.intentDescription;
  }
  if (!Util.isUnset(request.intentName)) {
    query['IntentName'] = request.intentName;
  }
  if (!Util.isUnset(request.keywords)) {
    query['Keywords'] = request.keywords;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  if (!Util.isUnset(request.utterances)) {
    query['Utterances'] = request.utterances;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateIntent',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIntent(request: CreateIntentRequest): CreateIntentResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIntentWithOptions(request, runtime);
}

model CreateJobDataParsingTaskRequest {
  instanceId?: string(name='InstanceId'),
  jobFilePath?: string(name='JobFilePath'),
}

model CreateJobDataParsingTaskResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  jobDataParsingTaskId?: string(name='JobDataParsingTaskId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateJobDataParsingTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateJobDataParsingTaskResponseBody(name='body'),
}

async function createJobDataParsingTaskWithOptions(request: CreateJobDataParsingTaskRequest, runtime: Util.RuntimeOptions): CreateJobDataParsingTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobFilePath)) {
    query['JobFilePath'] = request.jobFilePath;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateJobDataParsingTask',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createJobDataParsingTask(request: CreateJobDataParsingTaskRequest): CreateJobDataParsingTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobDataParsingTaskWithOptions(request, runtime);
}

model CreateJobGroupRequest {
  callingNumber?: [ string ](name='CallingNumber'),
  instanceId?: string(name='InstanceId'),
  jobGroupDescription?: string(name='JobGroupDescription'),
  jobGroupName?: string(name='JobGroupName'),
  minConcurrency?: long(name='MinConcurrency'),
  priority?: string(name='Priority'),
  recallStrategyJson?: string(name='RecallStrategyJson'),
  ringingDuration?: long(name='RingingDuration'),
  scenarioId?: string(name='ScenarioId'),
  scriptId?: string(name='ScriptId'),
  strategyJson?: string(name='StrategyJson'),
}

model CreateJobGroupResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  jobGroup?: {
    callingNumbers?: [ string ](name='CallingNumbers'),
    creationTime?: long(name='CreationTime'),
    exportProgress?: {
      fileHttpUrl?: string(name='FileHttpUrl'),
      progress?: string(name='Progress'),
      status?: string(name='Status'),
    }(name='ExportProgress'),
    jobDataParsingTaskId?: string(name='JobDataParsingTaskId'),
    jobFilePath?: string(name='JobFilePath'),
    jobGroupDescription?: string(name='JobGroupDescription'),
    jobGroupId?: string(name='JobGroupId'),
    jobGroupName?: string(name='JobGroupName'),
    minConcurrency?: long(name='MinConcurrency'),
    modifyTime?: string(name='ModifyTime'),
    priority?: string(name='Priority'),
    recallStrategy?: {
      emptyNumberIgnore?: boolean(name='EmptyNumberIgnore'),
      inArrearsIgnore?: boolean(name='InArrearsIgnore'),
      outOfServiceIgnore?: boolean(name='OutOfServiceIgnore'),
    }(name='RecallStrategy'),
    ringingDuration?: long(name='RingingDuration'),
    scenarioId?: string(name='ScenarioId'),
    scriptName?: string(name='ScriptName'),
    scriptVersion?: string(name='ScriptVersion'),
    status?: string(name='Status'),
    strategy?: {
      customized?: string(name='Customized'),
      endTime?: long(name='EndTime'),
      followUpStrategy?: string(name='FollowUpStrategy'),
      isTemplate?: boolean(name='IsTemplate'),
      maxAttemptsPerDay?: int32(name='MaxAttemptsPerDay'),
      minAttemptInterval?: int32(name='MinAttemptInterval'),
      repeatBy?: string(name='RepeatBy'),
      repeatDays?: [ string ](name='RepeatDays'),
      routingStrategy?: string(name='RoutingStrategy'),
      startTime?: long(name='StartTime'),
      strategyDescription?: string(name='StrategyDescription'),
      strategyId?: string(name='StrategyId'),
      strategyName?: string(name='StrategyName'),
      type?: string(name='Type'),
      workingTime?: [ 
        {
          beginTime?: string(name='BeginTime'),
          endTime?: string(name='EndTime'),
        }
      ](name='WorkingTime'),
    }(name='Strategy'),
  }(name='JobGroup'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateJobGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateJobGroupResponseBody(name='body'),
}

async function createJobGroupWithOptions(request: CreateJobGroupRequest, runtime: Util.RuntimeOptions): CreateJobGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.callingNumber)) {
    query['CallingNumber'] = request.callingNumber;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupDescription)) {
    query['JobGroupDescription'] = request.jobGroupDescription;
  }
  if (!Util.isUnset(request.jobGroupName)) {
    query['JobGroupName'] = request.jobGroupName;
  }
  if (!Util.isUnset(request.minConcurrency)) {
    query['MinConcurrency'] = request.minConcurrency;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.recallStrategyJson)) {
    query['RecallStrategyJson'] = request.recallStrategyJson;
  }
  if (!Util.isUnset(request.ringingDuration)) {
    query['RingingDuration'] = request.ringingDuration;
  }
  if (!Util.isUnset(request.scenarioId)) {
    query['ScenarioId'] = request.scenarioId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  if (!Util.isUnset(request.strategyJson)) {
    query['StrategyJson'] = request.strategyJson;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateJobGroup',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createJobGroup(request: CreateJobGroupRequest): CreateJobGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobGroupWithOptions(request, runtime);
}

model CreateJobGroupExportTaskRequest {
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
  option?: [ string ](name='Option'),
}

model CreateJobGroupExportTaskResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model CreateJobGroupExportTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateJobGroupExportTaskResponseBody(name='body'),
}

async function createJobGroupExportTaskWithOptions(request: CreateJobGroupExportTaskRequest, runtime: Util.RuntimeOptions): CreateJobGroupExportTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  if (!Util.isUnset(request.option)) {
    query['Option'] = request.option;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateJobGroupExportTask',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createJobGroupExportTask(request: CreateJobGroupExportTaskRequest): CreateJobGroupExportTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobGroupExportTaskWithOptions(request, runtime);
}

model CreateNumberDistrictInfoDownloadUrlRequest {
  versionId?: string(name='VersionId'),
}

model CreateNumberDistrictInfoDownloadUrlResponseBody = {
  code?: string(name='Code'),
  fileHttpUrl?: string(name='FileHttpUrl'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateNumberDistrictInfoDownloadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNumberDistrictInfoDownloadUrlResponseBody(name='body'),
}

async function createNumberDistrictInfoDownloadUrlWithOptions(request: CreateNumberDistrictInfoDownloadUrlRequest, runtime: Util.RuntimeOptions): CreateNumberDistrictInfoDownloadUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNumberDistrictInfoDownloadUrl',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNumberDistrictInfoDownloadUrl(request: CreateNumberDistrictInfoDownloadUrlRequest): CreateNumberDistrictInfoDownloadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNumberDistrictInfoDownloadUrlWithOptions(request, runtime);
}

model CreateNumberDistrictInfoParsingTaskRequest {
  filePath?: string(name='FilePath'),
  fileSize?: long(name='FileSize'),
}

model CreateNumberDistrictInfoParsingTaskResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateNumberDistrictInfoParsingTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNumberDistrictInfoParsingTaskResponseBody(name='body'),
}

async function createNumberDistrictInfoParsingTaskWithOptions(request: CreateNumberDistrictInfoParsingTaskRequest, runtime: Util.RuntimeOptions): CreateNumberDistrictInfoParsingTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filePath)) {
    query['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.fileSize)) {
    query['FileSize'] = request.fileSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNumberDistrictInfoParsingTask',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNumberDistrictInfoParsingTask(request: CreateNumberDistrictInfoParsingTaskRequest): CreateNumberDistrictInfoParsingTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNumberDistrictInfoParsingTaskWithOptions(request, runtime);
}

model CreateOutboundCallNumberRequest {
  instanceId?: string(name='InstanceId'),
  number?: string(name='Number'),
  rateLimitCount?: int32(name='RateLimitCount'),
  rateLimitPeriod?: int32(name='RateLimitPeriod'),
}

model CreateOutboundCallNumberResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  outboundCallNumberId?: string(name='OutboundCallNumberId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateOutboundCallNumberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOutboundCallNumberResponseBody(name='body'),
}

async function createOutboundCallNumberWithOptions(request: CreateOutboundCallNumberRequest, runtime: Util.RuntimeOptions): CreateOutboundCallNumberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.number)) {
    query['Number'] = request.number;
  }
  if (!Util.isUnset(request.rateLimitCount)) {
    query['RateLimitCount'] = request.rateLimitCount;
  }
  if (!Util.isUnset(request.rateLimitPeriod)) {
    query['RateLimitPeriod'] = request.rateLimitPeriod;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOutboundCallNumber',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOutboundCallNumber(request: CreateOutboundCallNumberRequest): CreateOutboundCallNumberResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOutboundCallNumberWithOptions(request, runtime);
}

model CreateScriptRequest {
  asrConfig?: string(name='AsrConfig'),
  chatbotId?: string(name='ChatbotId'),
  industry?: string(name='Industry'),
  instanceId?: string(name='InstanceId'),
  longWaitEnable?: boolean(name='LongWaitEnable'),
  miniPlaybackConfigListJsonString?: string(name='MiniPlaybackConfigListJsonString'),
  miniPlaybackEnable?: boolean(name='MiniPlaybackEnable'),
  newBargeInEnable?: boolean(name='NewBargeInEnable'),
  scene?: string(name='Scene'),
  scriptContent?: [ string ](name='ScriptContent'),
  scriptDescription?: string(name='ScriptDescription'),
  scriptName?: string(name='ScriptName'),
  scriptWaveform?: [ string ](name='ScriptWaveform'),
  ttsConfig?: string(name='TtsConfig'),
}

model CreateScriptResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  script?: {
    debugStatus?: string(name='DebugStatus'),
    industry?: string(name='Industry'),
    isDebugDrafted?: boolean(name='IsDebugDrafted'),
    isDrafted?: boolean(name='IsDrafted'),
    scene?: string(name='Scene'),
    scriptDescription?: string(name='ScriptDescription'),
    scriptId?: string(name='ScriptId'),
    scriptName?: string(name='ScriptName'),
    status?: string(name='Status'),
    updateTime?: long(name='UpdateTime'),
  }(name='Script'),
  success?: boolean(name='Success'),
}

model CreateScriptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateScriptResponseBody(name='body'),
}

async function createScriptWithOptions(request: CreateScriptRequest, runtime: Util.RuntimeOptions): CreateScriptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asrConfig)) {
    query['AsrConfig'] = request.asrConfig;
  }
  if (!Util.isUnset(request.chatbotId)) {
    query['ChatbotId'] = request.chatbotId;
  }
  if (!Util.isUnset(request.industry)) {
    query['Industry'] = request.industry;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.longWaitEnable)) {
    query['LongWaitEnable'] = request.longWaitEnable;
  }
  if (!Util.isUnset(request.miniPlaybackConfigListJsonString)) {
    query['MiniPlaybackConfigListJsonString'] = request.miniPlaybackConfigListJsonString;
  }
  if (!Util.isUnset(request.miniPlaybackEnable)) {
    query['MiniPlaybackEnable'] = request.miniPlaybackEnable;
  }
  if (!Util.isUnset(request.newBargeInEnable)) {
    query['NewBargeInEnable'] = request.newBargeInEnable;
  }
  if (!Util.isUnset(request.scene)) {
    query['Scene'] = request.scene;
  }
  if (!Util.isUnset(request.scriptContent)) {
    query['ScriptContent'] = request.scriptContent;
  }
  if (!Util.isUnset(request.scriptDescription)) {
    query['ScriptDescription'] = request.scriptDescription;
  }
  if (!Util.isUnset(request.scriptName)) {
    query['ScriptName'] = request.scriptName;
  }
  if (!Util.isUnset(request.scriptWaveform)) {
    query['ScriptWaveform'] = request.scriptWaveform;
  }
  if (!Util.isUnset(request.ttsConfig)) {
    query['TtsConfig'] = request.ttsConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateScript',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createScript(request: CreateScriptRequest): CreateScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  return createScriptWithOptions(request, runtime);
}

model CreateScriptWaveformRequest {
  fileId?: string(name='FileId'),
  fileName?: string(name='FileName'),
  instanceId?: string(name='InstanceId'),
  scriptContent?: string(name='ScriptContent'),
  scriptId?: string(name='ScriptId'),
}

model CreateScriptWaveformResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  scriptWaveformId?: string(name='ScriptWaveformId'),
  success?: boolean(name='Success'),
}

model CreateScriptWaveformResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateScriptWaveformResponseBody(name='body'),
}

async function createScriptWaveformWithOptions(request: CreateScriptWaveformRequest, runtime: Util.RuntimeOptions): CreateScriptWaveformResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileId)) {
    query['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptContent)) {
    query['ScriptContent'] = request.scriptContent;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateScriptWaveform',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createScriptWaveform(request: CreateScriptWaveformRequest): CreateScriptWaveformResponse {
  var runtime = new Util.RuntimeOptions{};
  return createScriptWaveformWithOptions(request, runtime);
}

model CreateTagRequest {
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
  tagGroup?: string(name='TagGroup'),
  tagName?: string(name='TagName'),
}

model CreateTagResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tagId?: string(name='TagId'),
}

model CreateTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTagResponseBody(name='body'),
}

async function createTagWithOptions(request: CreateTagRequest, runtime: Util.RuntimeOptions): CreateTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  if (!Util.isUnset(request.tagGroup)) {
    query['TagGroup'] = request.tagGroup;
  }
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTag',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTag(request: CreateTagRequest): CreateTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTagWithOptions(request, runtime);
}

model CreateTaskExportTaskRequest {
  actualTimeGte?: long(name='ActualTimeGte'),
  actualTimeLte?: long(name='ActualTimeLte'),
  callDurationGte?: long(name='CallDurationGte'),
  callDurationLte?: long(name='CallDurationLte'),
  calledNumber?: string(name='CalledNumber'),
  hasAnswered?: boolean(name='HasAnswered'),
  hasHangUpByRejection?: boolean(name='HasHangUpByRejection'),
  hasReachedEndOfFlow?: boolean(name='HasReachedEndOfFlow'),
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
  jobGroupNameQuery?: string(name='JobGroupNameQuery'),
  jobId?: string(name='JobId'),
  jobStatusStringList?: string(name='JobStatusStringList'),
  otherId?: string(name='OtherId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  recordingDurationGte?: long(name='RecordingDurationGte'),
  recordingDurationLte?: long(name='RecordingDurationLte'),
  scriptNameQuery?: string(name='ScriptNameQuery'),
  sortBy?: string(name='SortBy'),
  sortOrder?: string(name='SortOrder'),
  taskCreateTimeGte?: long(name='TaskCreateTimeGte'),
  taskCreateTimeLte?: long(name='TaskCreateTimeLte'),
  taskId?: string(name='TaskId'),
  taskStatusStringList?: string(name='TaskStatusStringList'),
  userIdMatch?: string(name='UserIdMatch'),
}

model CreateTaskExportTaskResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model CreateTaskExportTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTaskExportTaskResponseBody(name='body'),
}

async function createTaskExportTaskWithOptions(request: CreateTaskExportTaskRequest, runtime: Util.RuntimeOptions): CreateTaskExportTaskResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTaskExportTask',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTaskExportTask(request: CreateTaskExportTaskRequest): CreateTaskExportTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTaskExportTaskWithOptions(request, runtime);
}

model DeleteAllNumberDistrictInfoResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteAllNumberDistrictInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAllNumberDistrictInfoResponseBody(name='body'),
}

async function deleteAllNumberDistrictInfoWithOptions(runtime: Util.RuntimeOptions): DeleteAllNumberDistrictInfoResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DeleteAllNumberDistrictInfo',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAllNumberDistrictInfo(): DeleteAllNumberDistrictInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAllNumberDistrictInfoWithOptions(runtime);
}

model DeleteContactBlockListRequest {
  contactBlockListId?: string(name='ContactBlockListId'),
  instanceId?: string(name='InstanceId'),
  operator?: string(name='Operator'),
}

model DeleteContactBlockListResponseBody = {
  affectedRows?: int32(name='AffectedRows'),
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteContactBlockListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteContactBlockListResponseBody(name='body'),
}

async function deleteContactBlockListWithOptions(request: DeleteContactBlockListRequest, runtime: Util.RuntimeOptions): DeleteContactBlockListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactBlockListId)) {
    query['ContactBlockListId'] = request.contactBlockListId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteContactBlockList',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteContactBlockList(request: DeleteContactBlockListRequest): DeleteContactBlockListResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContactBlockListWithOptions(request, runtime);
}

model DeleteContactWhiteListRequest {
  contactWhiteListId?: string(name='ContactWhiteListId'),
  instanceId?: string(name='InstanceId'),
  operator?: string(name='Operator'),
}

model DeleteContactWhiteListResponseBody = {
  affectedRows?: int32(name='AffectedRows'),
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteContactWhiteListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteContactWhiteListResponseBody(name='body'),
}

async function deleteContactWhiteListWithOptions(request: DeleteContactWhiteListRequest, runtime: Util.RuntimeOptions): DeleteContactWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactWhiteListId)) {
    query['ContactWhiteListId'] = request.contactWhiteListId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteContactWhiteList',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteContactWhiteList(request: DeleteContactWhiteListRequest): DeleteContactWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContactWhiteListWithOptions(request, runtime);
}

model DeleteDialogueFlowRequest {
  dialogueFlowId?: string(name='DialogueFlowId'),
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
}

model DeleteDialogueFlowResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDialogueFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDialogueFlowResponseBody(name='body'),
}

async function deleteDialogueFlowWithOptions(request: DeleteDialogueFlowRequest, runtime: Util.RuntimeOptions): DeleteDialogueFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dialogueFlowId)) {
    query['DialogueFlowId'] = request.dialogueFlowId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDialogueFlow',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDialogueFlow(request: DeleteDialogueFlowRequest): DeleteDialogueFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDialogueFlowWithOptions(request, runtime);
}

model DeleteGlobalQuestionRequest {
  globalQuestionId?: string(name='GlobalQuestionId'),
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
}

model DeleteGlobalQuestionResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteGlobalQuestionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGlobalQuestionResponseBody(name='body'),
}

async function deleteGlobalQuestionWithOptions(request: DeleteGlobalQuestionRequest, runtime: Util.RuntimeOptions): DeleteGlobalQuestionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalQuestionId)) {
    query['GlobalQuestionId'] = request.globalQuestionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGlobalQuestion',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGlobalQuestion(request: DeleteGlobalQuestionRequest): DeleteGlobalQuestionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGlobalQuestionWithOptions(request, runtime);
}

model DeleteInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model DeleteInstanceResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstanceWithOptions(request: DeleteInstanceRequest, runtime: Util.RuntimeOptions): DeleteInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstance',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInstance(request: DeleteInstanceRequest): DeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstanceWithOptions(request, runtime);
}

model DeleteIntentRequest {
  instanceId?: string(name='InstanceId'),
  intentId?: string(name='IntentId'),
  scriptId?: string(name='ScriptId'),
}

model DeleteIntentResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteIntentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIntentResponseBody(name='body'),
}

async function deleteIntentWithOptions(request: DeleteIntentRequest, runtime: Util.RuntimeOptions): DeleteIntentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.intentId)) {
    query['IntentId'] = request.intentId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIntent',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIntent(request: DeleteIntentRequest): DeleteIntentResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIntentWithOptions(request, runtime);
}

model DeleteJobGroupRequest {
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
}

model DeleteJobGroupResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteJobGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteJobGroupResponseBody(name='body'),
}

async function deleteJobGroupWithOptions(request: DeleteJobGroupRequest, runtime: Util.RuntimeOptions): DeleteJobGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteJobGroup',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteJobGroup(request: DeleteJobGroupRequest): DeleteJobGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteJobGroupWithOptions(request, runtime);
}

model DeleteOutboundCallNumberRequest {
  instanceId?: string(name='InstanceId'),
  outboundCallNumberId?: string(name='OutboundCallNumberId'),
}

model DeleteOutboundCallNumberResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteOutboundCallNumberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteOutboundCallNumberResponseBody(name='body'),
}

async function deleteOutboundCallNumberWithOptions(request: DeleteOutboundCallNumberRequest, runtime: Util.RuntimeOptions): DeleteOutboundCallNumberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.outboundCallNumberId)) {
    query['OutboundCallNumberId'] = request.outboundCallNumberId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteOutboundCallNumber',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteOutboundCallNumber(request: DeleteOutboundCallNumberRequest): DeleteOutboundCallNumberResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteOutboundCallNumberWithOptions(request, runtime);
}

model DeleteScriptRequest {
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
}

model DeleteScriptResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteScriptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteScriptResponseBody(name='body'),
}

async function deleteScriptWithOptions(request: DeleteScriptRequest, runtime: Util.RuntimeOptions): DeleteScriptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteScript',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteScript(request: DeleteScriptRequest): DeleteScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteScriptWithOptions(request, runtime);
}

model DeleteScriptWaveformRequest {
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
  scriptWaveformId?: string(name='ScriptWaveformId'),
}

model DeleteScriptWaveformResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteScriptWaveformResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteScriptWaveformResponseBody(name='body'),
}

async function deleteScriptWaveformWithOptions(request: DeleteScriptWaveformRequest, runtime: Util.RuntimeOptions): DeleteScriptWaveformResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  if (!Util.isUnset(request.scriptWaveformId)) {
    query['ScriptWaveformId'] = request.scriptWaveformId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteScriptWaveform',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteScriptWaveform(request: DeleteScriptWaveformRequest): DeleteScriptWaveformResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteScriptWaveformWithOptions(request, runtime);
}

model DescribeDialogueNodeStatisticsRequest {
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
  limit?: int32(name='Limit'),
}

model DescribeDialogueNodeStatisticsResponseBody = {
  code?: string(name='Code'),
  groupId?: string(name='GroupId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  instanceId?: string(name='InstanceId'),
  message?: string(name='Message'),
  noAnswerDialogueNodes?: [ 
    {
      groupId?: string(name='GroupId'),
      hangUpNum?: int32(name='HangUpNum'),
      hitNum?: int32(name='HitNum'),
      id?: string(name='Id'),
      instanceId?: string(name='InstanceId'),
      noAnswerNum?: int32(name='NoAnswerNum'),
      nodeId?: string(name='NodeId'),
      nodeName?: string(name='NodeName'),
    }
  ](name='NoAnswerDialogueNodes'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCompleted?: int32(name='TotalCompleted'),
}

model DescribeDialogueNodeStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDialogueNodeStatisticsResponseBody(name='body'),
}

async function describeDialogueNodeStatisticsWithOptions(request: DescribeDialogueNodeStatisticsRequest, runtime: Util.RuntimeOptions): DescribeDialogueNodeStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDialogueNodeStatistics',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDialogueNodeStatistics(request: DescribeDialogueNodeStatisticsRequest): DescribeDialogueNodeStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDialogueNodeStatisticsWithOptions(request, runtime);
}

model DescribeDsReportsRequest {
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
}

model DescribeDsReportsResponseBody = {
  code?: string(name='Code'),
  dsReports?: string(name='DsReports'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeDsReportsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDsReportsResponseBody(name='body'),
}

async function describeDsReportsWithOptions(request: DescribeDsReportsRequest, runtime: Util.RuntimeOptions): DescribeDsReportsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDsReports',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDsReports(request: DescribeDsReportsRequest): DescribeDsReportsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDsReportsWithOptions(request, runtime);
}

model DescribeGlobalQuestionRequest {
  globalQuestionId?: string(name='GlobalQuestionId'),
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
}

model DescribeGlobalQuestionResponseBody = {
  code?: string(name='Code'),
  globalQuestion?: {
    answers?: string(name='Answers'),
    globalQuestionId?: string(name='GlobalQuestionId'),
    globalQuestionName?: string(name='GlobalQuestionName'),
    globalQuestionType?: string(name='GlobalQuestionType'),
    questions?: string(name='Questions'),
    scriptId?: string(name='ScriptId'),
  }(name='GlobalQuestion'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeGlobalQuestionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGlobalQuestionResponseBody(name='body'),
}

async function describeGlobalQuestionWithOptions(request: DescribeGlobalQuestionRequest, runtime: Util.RuntimeOptions): DescribeGlobalQuestionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalQuestionId)) {
    query['GlobalQuestionId'] = request.globalQuestionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGlobalQuestion',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGlobalQuestion(request: DescribeGlobalQuestionRequest): DescribeGlobalQuestionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGlobalQuestionWithOptions(request, runtime);
}

model DescribeGroupExecutingInfoRequest {
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
}

model DescribeGroupExecutingInfoResponseBody = {
  code?: string(name='Code'),
  executingInfo?: {
    callFailedNum?: int32(name='CallFailedNum'),
    callNum?: int32(name='CallNum'),
    creatorName?: string(name='CreatorName'),
    endTime?: long(name='EndTime'),
    finishedNum?: int32(name='FinishedNum'),
    hangUpByClientNum?: int32(name='HangUpByClientNum'),
    jobsProgress?: {
      cancelledNum?: int32(name='CancelledNum'),
      executingNum?: int32(name='ExecutingNum'),
      failedNum?: int32(name='FailedNum'),
      pausedNum?: int32(name='PausedNum'),
      schedulingNum?: int32(name='SchedulingNum'),
      totalCompletedNum?: int32(name='TotalCompletedNum'),
      totalJobs?: int32(name='TotalJobs'),
      totalNotAnsweredNum?: int32(name='TotalNotAnsweredNum'),
    }(name='JobsProgress'),
    startTime?: long(name='StartTime'),
    transferByIntentNum?: int32(name='TransferByIntentNum'),
    transferByNoAnswer?: int32(name='TransferByNoAnswer'),
  }(name='ExecutingInfo'),
  groupId?: string(name='GroupId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  instanceId?: string(name='InstanceId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeGroupExecutingInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGroupExecutingInfoResponseBody(name='body'),
}

async function describeGroupExecutingInfoWithOptions(request: DescribeGroupExecutingInfoRequest, runtime: Util.RuntimeOptions): DescribeGroupExecutingInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroupExecutingInfo',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGroupExecutingInfo(request: DescribeGroupExecutingInfoRequest): DescribeGroupExecutingInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupExecutingInfoWithOptions(request, runtime);
}

model DescribeInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model DescribeInstanceResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  instance?: {
    creationTime?: long(name='CreationTime'),
    creatorId?: long(name='CreatorId'),
    creatorName?: string(name='CreatorName'),
    instanceDescription?: string(name='InstanceDescription'),
    instanceId?: string(name='InstanceId'),
    instanceName?: string(name='InstanceName'),
    maxConcurrentConversation?: int32(name='MaxConcurrentConversation'),
    ownerName?: string(name='OwnerName'),
    resourceGroupId?: string(name='ResourceGroupId'),
  }(name='Instance'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceResponseBody(name='body'),
}

async function describeInstanceWithOptions(request: DescribeInstanceRequest, runtime: Util.RuntimeOptions): DescribeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstance',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstance(request: DescribeInstanceRequest): DescribeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceWithOptions(request, runtime);
}

model DescribeIntentRequest {
  instanceId?: string(name='InstanceId'),
  intentId?: string(name='IntentId'),
  scriptId?: string(name='ScriptId'),
}

model DescribeIntentResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  intent?: {
    createTime?: long(name='CreateTime'),
    intentDescription?: string(name='IntentDescription'),
    intentId?: string(name='IntentId'),
    intentName?: string(name='IntentName'),
    keywords?: string(name='Keywords'),
    scriptId?: string(name='ScriptId'),
    updateTime?: long(name='UpdateTime'),
    utterances?: string(name='Utterances'),
  }(name='Intent'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeIntentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIntentResponseBody(name='body'),
}

async function describeIntentWithOptions(request: DescribeIntentRequest, runtime: Util.RuntimeOptions): DescribeIntentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.intentId)) {
    query['IntentId'] = request.intentId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIntent',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIntent(request: DescribeIntentRequest): DescribeIntentResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIntentWithOptions(request, runtime);
}

model DescribeIntentStatisticsRequest {
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
  limit?: int32(name='Limit'),
}

model DescribeIntentStatisticsResponseBody = {
  code?: string(name='Code'),
  globalIntentNum?: int32(name='GlobalIntentNum'),
  globalIntents?: [ 
    {
      groupId?: string(name='GroupId'),
      hitAfterNoAnswer?: int32(name='HitAfterNoAnswer'),
      hitNum?: int32(name='HitNum'),
      instanceId?: string(name='InstanceId'),
      intentId?: string(name='IntentId'),
      intentName?: string(name='IntentName'),
      type?: string(name='Type'),
    }
  ](name='GlobalIntents'),
  groupId?: string(name='GroupId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  instanceId?: string(name='InstanceId'),
  intentsAfterNoAnswer?: [ 
    {
      instanceId?: string(name='InstanceId'),
    }
  ](name='IntentsAfterNoAnswer'),
  message?: string(name='Message'),
  processIntentNum?: int32(name='ProcessIntentNum'),
  processIntents?: [ 
    {
      groupId?: string(name='GroupId'),
      hitAfterNoAnswer?: int32(name='HitAfterNoAnswer'),
      hitNum?: int32(name='HitNum'),
      instanceId?: string(name='InstanceId'),
      intentId?: string(name='IntentId'),
      intentName?: string(name='IntentName'),
      type?: string(name='Type'),
    }
  ](name='ProcessIntents'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeIntentStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIntentStatisticsResponseBody(name='body'),
}

async function describeIntentStatisticsWithOptions(request: DescribeIntentStatisticsRequest, runtime: Util.RuntimeOptions): DescribeIntentStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIntentStatistics',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIntentStatistics(request: DescribeIntentStatisticsRequest): DescribeIntentStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIntentStatisticsWithOptions(request, runtime);
}

model DescribeJobRequest {
  instanceId?: string(name='InstanceId'),
  jobId?: string(name='JobId'),
  withScript?: boolean(name='WithScript'),
}

model DescribeJobResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  job?: {
    actualTime?: long(name='ActualTime'),
    calledNumber?: string(name='CalledNumber'),
    callingNumbers?: [ string ](name='CallingNumbers'),
    contacts?: [ 
      {
        contactId?: string(name='ContactId'),
        contactName?: string(name='ContactName'),
        honorific?: string(name='Honorific'),
        jobId?: string(name='JobId'),
        phoneNumber?: string(name='PhoneNumber'),
        referenceId?: string(name='ReferenceId'),
        role?: string(name='Role'),
        state?: string(name='State'),
      }
    ](name='Contacts'),
    dsReport?: string(name='DsReport'),
    endReason?: int32(name='EndReason'),
    extras?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='Extras'),
    failureReason?: string(name='FailureReason'),
    instanceId?: string(name='InstanceId'),
    jobGroupId?: string(name='JobGroupId'),
    jobId?: string(name='JobId'),
    nextExecutionTime?: long(name='NextExecutionTime'),
    priority?: int32(name='Priority'),
    referenceId?: string(name='ReferenceId'),
    scenarioId?: string(name='ScenarioId'),
    script?: {
      asrConfig?: string(name='AsrConfig'),
      chatbotId?: string(name='ChatbotId'),
      debugStatus?: string(name='DebugStatus'),
      industry?: string(name='Industry'),
      isDebugDrafted?: boolean(name='IsDebugDrafted'),
      isDrafted?: boolean(name='IsDrafted'),
      miniPlaybackConfigEnabled?: boolean(name='MiniPlaybackConfigEnabled'),
      name?: string(name='Name'),
      scene?: string(name='Scene'),
      scriptDescription?: string(name='ScriptDescription'),
      scriptId?: string(name='ScriptId'),
      status?: string(name='Status'),
      ttsConfig?: string(name='TtsConfig'),
      updateTime?: long(name='UpdateTime'),
    }(name='Script'),
    status?: string(name='Status'),
    strategyId?: string(name='StrategyId'),
    summary?: [ 
      {
        category?: string(name='Category'),
        content?: string(name='Content'),
        summaryName?: string(name='SummaryName'),
      }
    ](name='Summary'),
    systemPriority?: int32(name='SystemPriority'),
    tasks?: [ 
      {
        actualTime?: long(name='ActualTime'),
        brief?: string(name='Brief'),
        callId?: string(name='CallId'),
        calledNumber?: string(name='CalledNumber'),
        callingNumber?: string(name='CallingNumber'),
        chatbotId?: string(name='ChatbotId'),
        contact?: {
          contactId?: string(name='ContactId'),
          contactName?: string(name='ContactName'),
          honorific?: string(name='Honorific'),
          jobId?: string(name='JobId'),
          phoneNumber?: string(name='PhoneNumber'),
          referenceId?: string(name='ReferenceId'),
          role?: string(name='Role'),
          state?: string(name='State'),
        }(name='Contact'),
        conversation?: [ 
          {
            action?: string(name='Action'),
            actionParams?: string(name='ActionParams'),
            script?: string(name='Script'),
            sequenceId?: string(name='SequenceId'),
            speaker?: string(name='Speaker'),
            summary?: [ 
              {
                category?: string(name='Category'),
                content?: string(name='Content'),
                summaryName?: string(name='SummaryName'),
              }
            ](name='Summary'),
            timestamp?: long(name='Timestamp'),
          }
        ](name='Conversation'),
        duration?: int32(name='Duration'),
        endReason?: string(name='EndReason'),
        endTime?: long(name='EndTime'),
        hangUpDirection?: string(name='HangUpDirection'),
        jobId?: string(name='JobId'),
        planedTime?: long(name='PlanedTime'),
        ringingDuration?: long(name='RingingDuration'),
        scenarioId?: string(name='ScenarioId'),
        status?: string(name='Status'),
        taskId?: string(name='TaskId'),
      }
    ](name='Tasks'),
  }(name='Job'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeJobResponseBody(name='body'),
}

async function describeJobWithOptions(request: DescribeJobRequest, runtime: Util.RuntimeOptions): DescribeJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.withScript)) {
    query['WithScript'] = request.withScript;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeJob',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeJob(request: DescribeJobRequest): DescribeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJobWithOptions(request, runtime);
}

model DescribeJobDataParsingTaskProgressRequest {
  instanceId?: string(name='InstanceId'),
  jobDataParsingTaskId?: string(name='JobDataParsingTaskId'),
}

model DescribeJobDataParsingTaskProgressResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  progress?: {
    failErrorCode?: string(name='FailErrorCode'),
    failReason?: string(name='FailReason'),
    feedbackUrl?: string(name='FeedbackUrl'),
    handledJobCount?: int32(name='HandledJobCount'),
    status?: string(name='Status'),
    totalJobCount?: int32(name='TotalJobCount'),
  }(name='Progress'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeJobDataParsingTaskProgressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeJobDataParsingTaskProgressResponseBody(name='body'),
}

async function describeJobDataParsingTaskProgressWithOptions(request: DescribeJobDataParsingTaskProgressRequest, runtime: Util.RuntimeOptions): DescribeJobDataParsingTaskProgressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobDataParsingTaskId)) {
    query['JobDataParsingTaskId'] = request.jobDataParsingTaskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeJobDataParsingTaskProgress',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeJobDataParsingTaskProgress(request: DescribeJobDataParsingTaskProgressRequest): DescribeJobDataParsingTaskProgressResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJobDataParsingTaskProgressWithOptions(request, runtime);
}

model DescribeJobGroupRequest {
  briefTypes?: [ string ](name='BriefTypes'),
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
}

model DescribeJobGroupResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  jobGroup?: {
    callingNumbers?: [ string ](name='CallingNumbers'),
    creationTime?: long(name='CreationTime'),
    exportProgress?: {
      fileHttpUrl?: string(name='FileHttpUrl'),
      progress?: string(name='Progress'),
      status?: string(name='Status'),
    }(name='ExportProgress'),
    jobDataParsingTaskId?: string(name='JobDataParsingTaskId'),
    jobFilePath?: string(name='JobFilePath'),
    jobGroupDescription?: string(name='JobGroupDescription'),
    jobGroupId?: string(name='JobGroupId'),
    jobGroupName?: string(name='JobGroupName'),
    minConcurrency?: long(name='MinConcurrency'),
    modifyTime?: string(name='ModifyTime'),
    priority?: string(name='Priority'),
    progress?: {
      briefs?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Briefs'),
      cancelled?: int32(name='Cancelled'),
      categories?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Categories'),
      duration?: int32(name='Duration'),
      executing?: int32(name='Executing'),
      failed?: int32(name='Failed'),
      paused?: int32(name='Paused'),
      scheduling?: int32(name='Scheduling'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      totalCompleted?: int32(name='TotalCompleted'),
      totalJobs?: int32(name='TotalJobs'),
      totalNotAnswered?: int32(name='TotalNotAnswered'),
    }(name='Progress'),
    recallStrategy?: {
      emptyNumberIgnore?: boolean(name='EmptyNumberIgnore'),
      inArrearsIgnore?: boolean(name='InArrearsIgnore'),
      outOfServiceIgnore?: boolean(name='OutOfServiceIgnore'),
    }(name='RecallStrategy'),
    result?: {
      clientHangupNum?: int32(name='ClientHangupNum'),
      finishedNum?: int32(name='FinishedNum'),
      noInteractNum?: int32(name='NoInteractNum'),
      timeoutHangupNum?: int32(name='TimeoutHangupNum'),
      unrecognizedNum?: int32(name='UnrecognizedNum'),
    }(name='Result'),
    ringingDuration?: long(name='RingingDuration'),
    scenarioId?: string(name='ScenarioId'),
    scriptId?: string(name='ScriptId'),
    scriptName?: string(name='ScriptName'),
    scriptVersion?: string(name='ScriptVersion'),
    status?: string(name='Status'),
    strategy?: {
      customized?: string(name='Customized'),
      endTime?: long(name='EndTime'),
      followUpStrategy?: string(name='FollowUpStrategy'),
      isTemplate?: boolean(name='IsTemplate'),
      maxAttemptsPerDay?: int32(name='MaxAttemptsPerDay'),
      minAttemptInterval?: int32(name='MinAttemptInterval'),
      repeatBy?: string(name='RepeatBy'),
      repeatDays?: [ string ](name='RepeatDays'),
      routingStrategy?: string(name='RoutingStrategy'),
      startTime?: long(name='StartTime'),
      strategyDescription?: string(name='StrategyDescription'),
      strategyId?: string(name='StrategyId'),
      strategyName?: string(name='StrategyName'),
      type?: string(name='Type'),
      workingTime?: [ 
        {
          beginTime?: string(name='BeginTime'),
          endTime?: string(name='EndTime'),
        }
      ](name='WorkingTime'),
    }(name='Strategy'),
  }(name='JobGroup'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeJobGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeJobGroupResponseBody(name='body'),
}

async function describeJobGroupWithOptions(request: DescribeJobGroupRequest, runtime: Util.RuntimeOptions): DescribeJobGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.briefTypes)) {
    query['BriefTypes'] = request.briefTypes;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeJobGroup',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeJobGroup(request: DescribeJobGroupRequest): DescribeJobGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJobGroupWithOptions(request, runtime);
}

model DescribeJobGroupExportTaskProgressRequest {
  instanceId?: string(name='InstanceId'),
  taskId?: string(name='TaskId'),
}

model DescribeJobGroupExportTaskProgressResponseBody = {
  code?: string(name='Code'),
  fileHttpUrl?: string(name='FileHttpUrl'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  progress?: float(name='Progress'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeJobGroupExportTaskProgressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeJobGroupExportTaskProgressResponseBody(name='body'),
}

async function describeJobGroupExportTaskProgressWithOptions(request: DescribeJobGroupExportTaskProgressRequest, runtime: Util.RuntimeOptions): DescribeJobGroupExportTaskProgressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeJobGroupExportTaskProgress',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeJobGroupExportTaskProgress(request: DescribeJobGroupExportTaskProgressRequest): DescribeJobGroupExportTaskProgressResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJobGroupExportTaskProgressWithOptions(request, runtime);
}

model DescribeNumberDistrictInfoStatusResponseBody = {
  appliedVersion?: {
    fileName?: string(name='FileName'),
    fileSize?: long(name='FileSize'),
    versionId?: string(name='VersionId'),
  }(name='AppliedVersion'),
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  parsingVersion?: {
    fileName?: string(name='FileName'),
    fileSize?: long(name='FileSize'),
    parseProgress?: long(name='ParseProgress'),
    versionId?: string(name='VersionId'),
  }(name='ParsingVersion'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  success?: boolean(name='Success'),
}

model DescribeNumberDistrictInfoStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNumberDistrictInfoStatusResponseBody(name='body'),
}

async function describeNumberDistrictInfoStatusWithOptions(runtime: Util.RuntimeOptions): DescribeNumberDistrictInfoStatusResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeNumberDistrictInfoStatus',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNumberDistrictInfoStatus(): DescribeNumberDistrictInfoStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNumberDistrictInfoStatusWithOptions(runtime);
}

model DescribeScriptRequest {
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
}

model DescribeScriptResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  nlsConfig?: string(name='NlsConfig'),
  requestId?: string(name='RequestId'),
  script?: {
    asrConfig?: string(name='AsrConfig'),
    chatbotId?: string(name='ChatbotId'),
    debugStatus?: string(name='DebugStatus'),
    industry?: string(name='Industry'),
    isDebugDrafted?: boolean(name='IsDebugDrafted'),
    isDrafted?: boolean(name='IsDrafted'),
    longWaitEnable?: boolean(name='LongWaitEnable'),
    miniPlaybackEnable?: boolean(name='MiniPlaybackEnable'),
    newBargeInEnable?: boolean(name='NewBargeInEnable'),
    scene?: string(name='Scene'),
    scriptDescription?: string(name='ScriptDescription'),
    scriptId?: string(name='ScriptId'),
    scriptName?: string(name='ScriptName'),
    status?: string(name='Status'),
    ttsConfig?: string(name='TtsConfig'),
    updateTime?: long(name='UpdateTime'),
  }(name='Script'),
  success?: boolean(name='Success'),
}

model DescribeScriptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeScriptResponseBody(name='body'),
}

async function describeScriptWithOptions(request: DescribeScriptRequest, runtime: Util.RuntimeOptions): DescribeScriptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScript',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeScript(request: DescribeScriptRequest): DescribeScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScriptWithOptions(request, runtime);
}

model DescribeScriptVoiceConfigRequest {
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
  scriptVoiceConfigId?: string(name='ScriptVoiceConfigId'),
}

model DescribeScriptVoiceConfigResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  scriptVoiceConfig?: {
    instanceId?: string(name='InstanceId'),
    scriptContent?: string(name='ScriptContent'),
    scriptId?: string(name='ScriptId'),
    scriptVoiceConfigId?: string(name='ScriptVoiceConfigId'),
    scriptWaveformRelation?: string(name='ScriptWaveformRelation'),
    source?: string(name='Source'),
    type?: string(name='Type'),
  }(name='ScriptVoiceConfig'),
  success?: boolean(name='Success'),
}

model DescribeScriptVoiceConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeScriptVoiceConfigResponseBody(name='body'),
}

async function describeScriptVoiceConfigWithOptions(request: DescribeScriptVoiceConfigRequest, runtime: Util.RuntimeOptions): DescribeScriptVoiceConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  if (!Util.isUnset(request.scriptVoiceConfigId)) {
    query['ScriptVoiceConfigId'] = request.scriptVoiceConfigId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScriptVoiceConfig',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeScriptVoiceConfig(request: DescribeScriptVoiceConfigRequest): DescribeScriptVoiceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScriptVoiceConfigWithOptions(request, runtime);
}

model DescribeTTSConfigRequest {
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
}

model DescribeTTSConfigResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  TTSConfig?: {
    appKey?: string(name='AppKey'),
    instanceId?: string(name='InstanceId'),
    nlsServiceType?: string(name='NlsServiceType'),
    speechRate?: string(name='SpeechRate'),
    voice?: string(name='Voice'),
    volume?: string(name='Volume'),
  }(name='TTSConfig'),
}

model DescribeTTSConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTTSConfigResponseBody(name='body'),
}

async function describeTTSConfigWithOptions(request: DescribeTTSConfigRequest, runtime: Util.RuntimeOptions): DescribeTTSConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTTSConfig',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTTSConfig(request: DescribeTTSConfigRequest): DescribeTTSConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTTSConfigWithOptions(request, runtime);
}

model DescribeTTSDemoRequest {
  instanceId?: string(name='InstanceId'),
  pitchRate?: int32(name='PitchRate'),
  scriptId?: string(name='ScriptId'),
  speechRate?: int32(name='SpeechRate'),
  text?: string(name='Text'),
  voice?: string(name='Voice'),
  volume?: int32(name='Volume'),
}

model DescribeTTSDemoResponseBody = {
  auditionUrl?: string(name='AuditionUrl'),
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeTTSDemoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTTSDemoResponseBody(name='body'),
}

async function describeTTSDemoWithOptions(request: DescribeTTSDemoRequest, runtime: Util.RuntimeOptions): DescribeTTSDemoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pitchRate)) {
    query['PitchRate'] = request.pitchRate;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  if (!Util.isUnset(request.speechRate)) {
    query['SpeechRate'] = request.speechRate;
  }
  if (!Util.isUnset(request.text)) {
    query['Text'] = request.text;
  }
  if (!Util.isUnset(request.voice)) {
    query['Voice'] = request.voice;
  }
  if (!Util.isUnset(request.volume)) {
    query['Volume'] = request.volume;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTTSDemo',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTTSDemo(request: DescribeTTSDemoRequest): DescribeTTSDemoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTTSDemoWithOptions(request, runtime);
}

model DescribeTagHitsSummaryRequest {
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
}

model DescribeTagHitsSummaryResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tagGroups?: [ 
    {
      id?: string(name='Id'),
      scriptId?: string(name='ScriptId'),
      tagGroup?: string(name='TagGroup'),
      tagGroupIndex?: int32(name='TagGroupIndex'),
    }
  ](name='TagGroups'),
  tagHitsList?: [ 
    {
      hitCount?: int32(name='HitCount'),
      tagGroup?: string(name='TagGroup'),
      tagName?: string(name='TagName'),
    }
  ](name='TagHitsList'),
}

model DescribeTagHitsSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTagHitsSummaryResponseBody(name='body'),
}

async function describeTagHitsSummaryWithOptions(request: DescribeTagHitsSummaryRequest, runtime: Util.RuntimeOptions): DescribeTagHitsSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTagHitsSummary',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTagHitsSummary(request: DescribeTagHitsSummaryRequest): DescribeTagHitsSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagHitsSummaryWithOptions(request, runtime);
}

model DescribeTenantBindNumberRequest {
  number?: string(name='Number'),
}

model DescribeTenantBindNumberResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: [ 
      {
        instanceId?: string(name='InstanceId'),
        instanceName?: string(name='InstanceName'),
        isBinding?: boolean(name='IsBinding'),
      }
    ](name='List'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeTenantBindNumberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTenantBindNumberResponseBody(name='body'),
}

async function describeTenantBindNumberWithOptions(request: DescribeTenantBindNumberRequest, runtime: Util.RuntimeOptions): DescribeTenantBindNumberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.number)) {
    query['Number'] = request.number;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTenantBindNumber',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTenantBindNumber(request: DescribeTenantBindNumberRequest): DescribeTenantBindNumberResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTenantBindNumberWithOptions(request, runtime);
}

model DialogueRequest {
  actionKey?: string(name='ActionKey'),
  actionParams?: string(name='ActionParams'),
  callId?: string(name='CallId'),
  callType?: string(name='CallType'),
  calledNumber?: string(name='CalledNumber'),
  callingNumber?: string(name='CallingNumber'),
  instanceId?: string(name='InstanceId'),
  scenarioId?: string(name='ScenarioId'),
  scriptId?: string(name='ScriptId'),
  taskId?: string(name='TaskId'),
  utterance?: string(name='Utterance'),
}

model DialogueResponseBody = {
  code?: string(name='Code'),
  feedback?: {
    action?: string(name='Action'),
    actionParams?: string(name='ActionParams'),
    content?: string(name='Content'),
    interruptible?: boolean(name='Interruptible'),
  }(name='Feedback'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DialogueResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DialogueResponseBody(name='body'),
}

async function dialogueWithOptions(request: DialogueRequest, runtime: Util.RuntimeOptions): DialogueResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionKey)) {
    query['ActionKey'] = request.actionKey;
  }
  if (!Util.isUnset(request.actionParams)) {
    query['ActionParams'] = request.actionParams;
  }
  if (!Util.isUnset(request.callId)) {
    query['CallId'] = request.callId;
  }
  if (!Util.isUnset(request.callType)) {
    query['CallType'] = request.callType;
  }
  if (!Util.isUnset(request.calledNumber)) {
    query['CalledNumber'] = request.calledNumber;
  }
  if (!Util.isUnset(request.callingNumber)) {
    query['CallingNumber'] = request.callingNumber;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scenarioId)) {
    query['ScenarioId'] = request.scenarioId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.utterance)) {
    query['Utterance'] = request.utterance;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Dialogue',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function dialogue(request: DialogueRequest): DialogueResponse {
  var runtime = new Util.RuntimeOptions{};
  return dialogueWithOptions(request, runtime);
}

model DismissNumberDistrictInfoParsingResultRequest {
  versionId?: string(name='VersionId'),
}

model DismissNumberDistrictInfoParsingResultResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DismissNumberDistrictInfoParsingResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DismissNumberDistrictInfoParsingResultResponseBody(name='body'),
}

async function dismissNumberDistrictInfoParsingResultWithOptions(request: DismissNumberDistrictInfoParsingResultRequest, runtime: Util.RuntimeOptions): DismissNumberDistrictInfoParsingResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DismissNumberDistrictInfoParsingResult',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function dismissNumberDistrictInfoParsingResult(request: DismissNumberDistrictInfoParsingResultRequest): DismissNumberDistrictInfoParsingResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return dismissNumberDistrictInfoParsingResultWithOptions(request, runtime);
}

model DownloadRecordingRequest {
  instanceId?: string(name='InstanceId'),
  needVoiceSliceRecording?: boolean(name='NeedVoiceSliceRecording'),
  taskId?: string(name='TaskId'),
}

model DownloadRecordingResponseBody = {
  code?: string(name='Code'),
  downloadParams?: {
    fileName?: string(name='FileName'),
    signatureUrl?: string(name='SignatureUrl'),
    voiceSliceRecordingListJson?: string(name='VoiceSliceRecordingListJson'),
  }(name='DownloadParams'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DownloadRecordingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DownloadRecordingResponseBody(name='body'),
}

async function downloadRecordingWithOptions(request: DownloadRecordingRequest, runtime: Util.RuntimeOptions): DownloadRecordingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.needVoiceSliceRecording)) {
    query['NeedVoiceSliceRecording'] = request.needVoiceSliceRecording;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DownloadRecording',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function downloadRecording(request: DownloadRecordingRequest): DownloadRecordingResponse {
  var runtime = new Util.RuntimeOptions{};
  return downloadRecordingWithOptions(request, runtime);
}

model DuplicateScriptRequest {
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
  sourceScriptId?: string(name='SourceScriptId'),
}

model DuplicateScriptResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  scriptId?: string(name='ScriptId'),
  success?: boolean(name='Success'),
}

model DuplicateScriptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DuplicateScriptResponseBody(name='body'),
}

async function duplicateScriptWithOptions(request: DuplicateScriptRequest, runtime: Util.RuntimeOptions): DuplicateScriptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.sourceScriptId)) {
    query['SourceScriptId'] = request.sourceScriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DuplicateScript',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function duplicateScript(request: DuplicateScriptRequest): DuplicateScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  return duplicateScriptWithOptions(request, runtime);
}

model ExportScriptRequest {
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
}

model ExportScriptResponseBody = {
  code?: string(name='Code'),
  downloadParams?: {
    signatureUrl?: string(name='SignatureUrl'),
  }(name='DownloadParams'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExportScriptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExportScriptResponseBody(name='body'),
}

async function exportScriptWithOptions(request: ExportScriptRequest, runtime: Util.RuntimeOptions): ExportScriptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportScript',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportScript(request: ExportScriptRequest): ExportScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportScriptWithOptions(request, runtime);
}

model GenerateUploadUrlRequest {
  fileName?: string(name='FileName'),
  key?: string(name='Key'),
}

model GenerateUploadUrlResponseBody = {
  code?: string(name='Code'),
  data?: {
    accessId?: string(name='AccessId'),
    expire?: int32(name='Expire'),
    folder?: string(name='Folder'),
    host?: string(name='Host'),
    message?: string(name='Message'),
    policy?: string(name='Policy'),
    signature?: string(name='Signature'),
    success?: boolean(name='Success'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GenerateUploadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateUploadUrlResponseBody(name='body'),
}

async function generateUploadUrlWithOptions(request: GenerateUploadUrlRequest, runtime: Util.RuntimeOptions): GenerateUploadUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateUploadUrl',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateUploadUrl(request: GenerateUploadUrlRequest): GenerateUploadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateUploadUrlWithOptions(request, runtime);
}

model GetAfterAnswerDelayPlaybackRequest {
  entryId?: string(name='EntryId'),
  strategyLevel?: int32(name='StrategyLevel'),
}

model GetAfterAnswerDelayPlaybackResponseBody = {
  afterAnswerDelayPlayback?: int32(name='AfterAnswerDelayPlayback'),
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAfterAnswerDelayPlaybackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAfterAnswerDelayPlaybackResponseBody(name='body'),
}

async function getAfterAnswerDelayPlaybackWithOptions(request: GetAfterAnswerDelayPlaybackRequest, runtime: Util.RuntimeOptions): GetAfterAnswerDelayPlaybackResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.entryId)) {
    query['EntryId'] = request.entryId;
  }
  if (!Util.isUnset(request.strategyLevel)) {
    query['StrategyLevel'] = request.strategyLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAfterAnswerDelayPlayback',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAfterAnswerDelayPlayback(request: GetAfterAnswerDelayPlaybackRequest): GetAfterAnswerDelayPlaybackResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAfterAnswerDelayPlaybackWithOptions(request, runtime);
}

model GetAsrServerInfoRequest {
  entryId?: string(name='EntryId'),
  strategyLevel?: int32(name='StrategyLevel'),
}

model GetAsrServerInfoResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAsrServerInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAsrServerInfoResponseBody(name='body'),
}

async function getAsrServerInfoWithOptions(request: GetAsrServerInfoRequest, runtime: Util.RuntimeOptions): GetAsrServerInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.entryId)) {
    query['EntryId'] = request.entryId;
  }
  if (!Util.isUnset(request.strategyLevel)) {
    query['StrategyLevel'] = request.strategyLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAsrServerInfo',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAsrServerInfo(request: GetAsrServerInfoRequest): GetAsrServerInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAsrServerInfoWithOptions(request, runtime);
}

model GetBaseStrategyPeriodRequest {
  entryId?: string(name='EntryId'),
  strategyLevel?: int32(name='StrategyLevel'),
}

model GetBaseStrategyPeriodResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  onlyWeekdays?: boolean(name='OnlyWeekdays'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  workingTime?: [ 
    {
      beginTime?: string(name='BeginTime'),
      beginTimeMillis?: long(name='BeginTimeMillis'),
      endTime?: string(name='EndTime'),
      endTimeMillis?: long(name='EndTimeMillis'),
    }
  ](name='WorkingTime'),
}

model GetBaseStrategyPeriodResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBaseStrategyPeriodResponseBody(name='body'),
}

async function getBaseStrategyPeriodWithOptions(request: GetBaseStrategyPeriodRequest, runtime: Util.RuntimeOptions): GetBaseStrategyPeriodResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.entryId)) {
    query['EntryId'] = request.entryId;
  }
  if (!Util.isUnset(request.strategyLevel)) {
    query['StrategyLevel'] = request.strategyLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetBaseStrategyPeriod',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBaseStrategyPeriod(request: GetBaseStrategyPeriodRequest): GetBaseStrategyPeriodResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBaseStrategyPeriodWithOptions(request, runtime);
}

model GetConcurrentConversationQuotaResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  maxConcurrent?: int32(name='MaxConcurrent'),
  message?: string(name='Message'),
  remainingConcurrent?: int32(name='RemainingConcurrent'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetConcurrentConversationQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConcurrentConversationQuotaResponseBody(name='body'),
}

async function getConcurrentConversationQuotaWithOptions(runtime: Util.RuntimeOptions): GetConcurrentConversationQuotaResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetConcurrentConversationQuota',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConcurrentConversationQuota(): GetConcurrentConversationQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConcurrentConversationQuotaWithOptions(runtime);
}

model GetContactBlockListRequest {
  countTotalRow?: boolean(name='CountTotalRow'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model GetContactBlockListResponseBody = {
  code?: string(name='Code'),
  contactBlocklistList?: {
    list?: [ 
      {
        contactBlockListId?: string(name='ContactBlockListId'),
        creationTime?: long(name='CreationTime'),
        creator?: string(name='Creator'),
        instanceId?: string(name='InstanceId'),
        name?: string(name='Name'),
        operator?: string(name='Operator'),
        phoneNumber?: string(name='PhoneNumber'),
        remark?: string(name='Remark'),
      }
    ](name='List'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='ContactBlocklistList'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetContactBlockListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetContactBlockListResponseBody(name='body'),
}

async function getContactBlockListWithOptions(request: GetContactBlockListRequest, runtime: Util.RuntimeOptions): GetContactBlockListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.countTotalRow)) {
    query['CountTotalRow'] = request.countTotalRow;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetContactBlockList',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getContactBlockList(request: GetContactBlockListRequest): GetContactBlockListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getContactBlockListWithOptions(request, runtime);
}

model GetContactWhiteListRequest {
  countTotalRow?: boolean(name='CountTotalRow'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model GetContactWhiteListResponseBody = {
  code?: string(name='Code'),
  contactWhitelistList?: {
    list?: [ 
      {
        contactWhiteListId?: string(name='ContactWhiteListId'),
        creationTime?: long(name='CreationTime'),
        creator?: string(name='Creator'),
        instanceId?: string(name='InstanceId'),
        name?: string(name='Name'),
        operator?: string(name='Operator'),
        phoneNumber?: string(name='PhoneNumber'),
        remark?: string(name='Remark'),
      }
    ](name='List'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='ContactWhitelistList'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetContactWhiteListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetContactWhiteListResponseBody(name='body'),
}

async function getContactWhiteListWithOptions(request: GetContactWhiteListRequest, runtime: Util.RuntimeOptions): GetContactWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.countTotalRow)) {
    query['CountTotalRow'] = request.countTotalRow;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetContactWhiteList',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getContactWhiteList(request: GetContactWhiteListRequest): GetContactWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getContactWhiteListWithOptions(request, runtime);
}

model GetCurrentConcurrencyRequest {
  instanceId?: string(name='InstanceId'),
}

model GetCurrentConcurrencyResponseBody = {
  code?: string(name='Code'),
  currentConcurrency?: int32(name='CurrentConcurrency'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  instanceId?: string(name='InstanceId'),
  maxConcurrentConversation?: int32(name='MaxConcurrentConversation'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetCurrentConcurrencyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCurrentConcurrencyResponseBody(name='body'),
}

async function getCurrentConcurrencyWithOptions(request: GetCurrentConcurrencyRequest, runtime: Util.RuntimeOptions): GetCurrentConcurrencyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCurrentConcurrency',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCurrentConcurrency(request: GetCurrentConcurrencyRequest): GetCurrentConcurrencyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCurrentConcurrencyWithOptions(request, runtime);
}

model GetEffectiveDaysRequest {
  entryId?: string(name='EntryId'),
  strategyLevel?: int32(name='StrategyLevel'),
}

model GetEffectiveDaysResponseBody = {
  code?: string(name='Code'),
  effectiveDays?: int32(name='EffectiveDays'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetEffectiveDaysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEffectiveDaysResponseBody(name='body'),
}

async function getEffectiveDaysWithOptions(request: GetEffectiveDaysRequest, runtime: Util.RuntimeOptions): GetEffectiveDaysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.entryId)) {
    query['EntryId'] = request.entryId;
  }
  if (!Util.isUnset(request.strategyLevel)) {
    query['StrategyLevel'] = request.strategyLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEffectiveDays',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEffectiveDays(request: GetEffectiveDaysRequest): GetEffectiveDaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEffectiveDaysWithOptions(request, runtime);
}

model GetEmptyNumberNoMoreCallsInfoRequest {
  entryId?: string(name='EntryId'),
  strategyLevel?: int32(name='StrategyLevel'),
}

model GetEmptyNumberNoMoreCallsInfoResponseBody = {
  code?: string(name='Code'),
  emptyNumberNoMoreCalls?: boolean(name='EmptyNumberNoMoreCalls'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetEmptyNumberNoMoreCallsInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEmptyNumberNoMoreCallsInfoResponseBody(name='body'),
}

async function getEmptyNumberNoMoreCallsInfoWithOptions(request: GetEmptyNumberNoMoreCallsInfoRequest, runtime: Util.RuntimeOptions): GetEmptyNumberNoMoreCallsInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.entryId)) {
    query['EntryId'] = request.entryId;
  }
  if (!Util.isUnset(request.strategyLevel)) {
    query['StrategyLevel'] = request.strategyLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEmptyNumberNoMoreCallsInfo',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEmptyNumberNoMoreCallsInfo(request: GetEmptyNumberNoMoreCallsInfoRequest): GetEmptyNumberNoMoreCallsInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEmptyNumberNoMoreCallsInfoWithOptions(request, runtime);
}

model GetMaxAttemptsPerDayRequest {
  entryId?: string(name='EntryId'),
  strategyLevel?: int32(name='StrategyLevel'),
}

model GetMaxAttemptsPerDayResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  maxAttemptsPerDay?: int32(name='MaxAttemptsPerDay'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMaxAttemptsPerDayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMaxAttemptsPerDayResponseBody(name='body'),
}

async function getMaxAttemptsPerDayWithOptions(request: GetMaxAttemptsPerDayRequest, runtime: Util.RuntimeOptions): GetMaxAttemptsPerDayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.entryId)) {
    query['EntryId'] = request.entryId;
  }
  if (!Util.isUnset(request.strategyLevel)) {
    query['StrategyLevel'] = request.strategyLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMaxAttemptsPerDay',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMaxAttemptsPerDay(request: GetMaxAttemptsPerDayRequest): GetMaxAttemptsPerDayResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMaxAttemptsPerDayWithOptions(request, runtime);
}

model GetNumberDistrictInfoTemplateDownloadUrlResponseBody = {
  code?: string(name='Code'),
  fileHttpUrl?: string(name='FileHttpUrl'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetNumberDistrictInfoTemplateDownloadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNumberDistrictInfoTemplateDownloadUrlResponseBody(name='body'),
}

async function getNumberDistrictInfoTemplateDownloadUrlWithOptions(runtime: Util.RuntimeOptions): GetNumberDistrictInfoTemplateDownloadUrlResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetNumberDistrictInfoTemplateDownloadUrl',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNumberDistrictInfoTemplateDownloadUrl(): GetNumberDistrictInfoTemplateDownloadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNumberDistrictInfoTemplateDownloadUrlWithOptions(runtime);
}

model GetSummaryInfoRequest {
  instanceIdList?: [ string ](name='InstanceIdList'),
}

model GetSummaryInfoResponseBody = {
  agentBotInstanceSummaryList?: [ 
    {
      instanceId?: string(name='InstanceId'),
      totalCallCount?: long(name='TotalCallCount'),
      totalCallTime?: long(name='TotalCallTime'),
      usedRecordingStorageSpace?: int32(name='UsedRecordingStorageSpace'),
    }
  ](name='AgentBotInstanceSummaryList'),
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSummaryInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSummaryInfoResponseBody(name='body'),
}

async function getSummaryInfoWithOptions(request: GetSummaryInfoRequest, runtime: Util.RuntimeOptions): GetSummaryInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIdList)) {
    query['InstanceIdList'] = request.instanceIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSummaryInfo',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSummaryInfo(request: GetSummaryInfoRequest): GetSummaryInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSummaryInfoWithOptions(request, runtime);
}

model GetTaskByUuidRequest {
  instanceId?: string(name='InstanceId'),
  taskId?: string(name='TaskId'),
  withConversations?: boolean(name='WithConversations'),
}

model GetTaskByUuidResponseBody = {
  requestId?: string(name='RequestId'),
  task?: {
    actualTime?: long(name='ActualTime'),
    callId?: string(name='CallId'),
    calledNumber?: string(name='CalledNumber'),
    callingNumber?: string(name='CallingNumber'),
    endReason?: int32(name='EndReason'),
    endTime?: long(name='EndTime'),
    id?: string(name='Id'),
    instanceId?: string(name='InstanceId'),
    jobGroupId?: string(name='JobGroupId'),
    jobId?: string(name='JobId'),
    plannedTime?: long(name='PlannedTime'),
  }(name='Task'),
}

model GetTaskByUuidResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskByUuidResponseBody(name='body'),
}

async function getTaskByUuidWithOptions(request: GetTaskByUuidRequest, runtime: Util.RuntimeOptions): GetTaskByUuidResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskByUuid',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTaskByUuid(request: GetTaskByUuidRequest): GetTaskByUuidResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskByUuidWithOptions(request, runtime);
}

model GetVersionResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  version?: string(name='Version'),
}

model GetVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVersionResponseBody(name='body'),
}

async function getVersionWithOptions(runtime: Util.RuntimeOptions): GetVersionResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetVersion',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVersion(): GetVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVersionWithOptions(runtime);
}

model ImportScriptRequest {
  instanceId?: string(name='InstanceId'),
  signatureUrl?: string(name='SignatureUrl'),
}

model ImportScriptResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  scriptId?: string(name='ScriptId'),
  success?: boolean(name='Success'),
}

model ImportScriptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ImportScriptResponseBody(name='body'),
}

async function importScriptWithOptions(request: ImportScriptRequest, runtime: Util.RuntimeOptions): ImportScriptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.signatureUrl)) {
    query['SignatureUrl'] = request.signatureUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportScript',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importScript(request: ImportScriptRequest): ImportScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  return importScriptWithOptions(request, runtime);
}

model InflightTaskTimeoutRequest {
  instanceId?: string(name='InstanceId'),
  instanceOwnerId?: long(name='InstanceOwnerId'),
  taskId?: string(name='TaskId'),
}

model InflightTaskTimeoutResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InflightTaskTimeoutResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InflightTaskTimeoutResponseBody(name='body'),
}

async function inflightTaskTimeoutWithOptions(request: InflightTaskTimeoutRequest, runtime: Util.RuntimeOptions): InflightTaskTimeoutResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceOwnerId)) {
    query['InstanceOwnerId'] = request.instanceOwnerId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InflightTaskTimeout',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function inflightTaskTimeout(request: InflightTaskTimeoutRequest): InflightTaskTimeoutResponse {
  var runtime = new Util.RuntimeOptions{};
  return inflightTaskTimeoutWithOptions(request, runtime);
}

model ListAllTenantBindNumberBindingResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: [ 
      {
        billingType?: string(name='BillingType'),
        bindingId?: string(name='BindingId'),
        instanceNameList?: [ string ](name='InstanceNameList'),
        number?: string(name='Number'),
        serializedParams?: string(name='SerializedParams'),
        trunkName?: string(name='TrunkName'),
      }
    ](name='List'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAllTenantBindNumberBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAllTenantBindNumberBindingResponseBody(name='body'),
}

async function listAllTenantBindNumberBindingWithOptions(runtime: Util.RuntimeOptions): ListAllTenantBindNumberBindingResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListAllTenantBindNumberBinding',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAllTenantBindNumberBinding(): ListAllTenantBindNumberBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAllTenantBindNumberBindingWithOptions(runtime);
}

model ListChatbotInstancesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListChatbotInstancesResponseBody = {
  bots?: [ 
    {
      avatar?: string(name='Avatar'),
      createTime?: string(name='CreateTime'),
      instanceId?: string(name='InstanceId'),
      introduction?: string(name='Introduction'),
      languageCode?: string(name='LanguageCode'),
      name?: string(name='Name'),
      timeZone?: string(name='TimeZone'),
    }
  ](name='Bots'),
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListChatbotInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListChatbotInstancesResponseBody(name='body'),
}

async function listChatbotInstancesWithOptions(request: ListChatbotInstancesRequest, runtime: Util.RuntimeOptions): ListChatbotInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListChatbotInstances',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listChatbotInstances(request: ListChatbotInstancesRequest): ListChatbotInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listChatbotInstancesWithOptions(request, runtime);
}

model ListDialogueFlowsRequest {
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
}

model ListDialogueFlowsResponseBody = {
  code?: string(name='Code'),
  dialogueFlows?: [ 
    {
      dialogueFlowDefinition?: string(name='DialogueFlowDefinition'),
      dialogueFlowId?: string(name='DialogueFlowId'),
      dialogueFlowName?: string(name='DialogueFlowName'),
      dialogueFlowType?: string(name='DialogueFlowType'),
      scriptId?: string(name='ScriptId'),
      scriptVersion?: string(name='ScriptVersion'),
    }
  ](name='DialogueFlows'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDialogueFlowsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDialogueFlowsResponseBody(name='body'),
}

async function listDialogueFlowsWithOptions(request: ListDialogueFlowsRequest, runtime: Util.RuntimeOptions): ListDialogueFlowsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDialogueFlows',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDialogueFlows(request: ListDialogueFlowsRequest): ListDialogueFlowsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDialogueFlowsWithOptions(request, runtime);
}

model ListDownloadTasksRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListDownloadTasksResponseBody = {
  code?: string(name='Code'),
  downloadTasks?: {
    list?: [ 
      {
        downloadTaskFiles?: [ 
          {
            fileId?: string(name='FileId'),
            progress?: int32(name='Progress'),
            status?: string(name='Status'),
            title?: string(name='Title'),
          }
        ](name='DownloadTaskFiles'),
        expireTime?: long(name='ExpireTime'),
        status?: string(name='Status'),
        taskId?: string(name='TaskId'),
        title?: string(name='Title'),
      }
    ](name='List'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='DownloadTasks'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDownloadTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDownloadTasksResponseBody(name='body'),
}

async function listDownloadTasksWithOptions(request: ListDownloadTasksRequest, runtime: Util.RuntimeOptions): ListDownloadTasksResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDownloadTasks',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDownloadTasks(request: ListDownloadTasksRequest): ListDownloadTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDownloadTasksWithOptions(request, runtime);
}

model ListGlobalQuestionsRequest {
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  scriptId?: string(name='ScriptId'),
}

model ListGlobalQuestionsResponseBody = {
  code?: string(name='Code'),
  globalQuestions?: {
    list?: [ 
      {
        answers?: string(name='Answers'),
        globalQuestionId?: string(name='GlobalQuestionId'),
        globalQuestionName?: string(name='GlobalQuestionName'),
        globalQuestionType?: string(name='GlobalQuestionType'),
        questions?: string(name='Questions'),
        scriptId?: string(name='ScriptId'),
      }
    ](name='List'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='GlobalQuestions'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListGlobalQuestionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGlobalQuestionsResponseBody(name='body'),
}

async function listGlobalQuestionsWithOptions(request: ListGlobalQuestionsRequest, runtime: Util.RuntimeOptions): ListGlobalQuestionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGlobalQuestions',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGlobalQuestions(request: ListGlobalQuestionsRequest): ListGlobalQuestionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGlobalQuestionsWithOptions(request, runtime);
}

model ListInstancesRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListInstancesResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  instances?: [ 
    {
      creationTime?: long(name='CreationTime'),
      creatorId?: long(name='CreatorId'),
      creatorName?: string(name='CreatorName'),
      instanceDescription?: string(name='InstanceDescription'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      maxConcurrentConversation?: int32(name='MaxConcurrentConversation'),
      ownerName?: string(name='OwnerName'),
      resourceGroupId?: string(name='ResourceGroupId'),
      resourceTags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='ResourceTags'),
    }
  ](name='Instances'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstancesWithOptions(request: ListInstancesRequest, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstancesWithOptions(request, runtime);
}

model ListIntentsRequest {
  instanceId?: string(name='InstanceId'),
  keyword?: string(name='Keyword'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  scriptId?: string(name='ScriptId'),
}

model ListIntentsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  intents?: {
    list?: [ 
      {
        createTime?: long(name='CreateTime'),
        intentDescription?: string(name='IntentDescription'),
        intentId?: string(name='IntentId'),
        intentName?: string(name='IntentName'),
        keywords?: string(name='Keywords'),
        scriptId?: string(name='ScriptId'),
        updateTime?: long(name='UpdateTime'),
        utterances?: string(name='Utterances'),
      }
    ](name='List'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Intents'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListIntentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIntentsResponseBody(name='body'),
}

async function listIntentsWithOptions(request: ListIntentsRequest, runtime: Util.RuntimeOptions): ListIntentsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIntents',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listIntents(request: ListIntentsRequest): ListIntentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIntentsWithOptions(request, runtime);
}

model ListJobGroupsRequest {
  asyncQuery?: boolean(name='AsyncQuery'),
  endTime?: long(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  jobGroupStatusFilter?: string(name='JobGroupStatusFilter'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  searchText?: string(name='SearchText'),
  startTime?: long(name='StartTime'),
}

model ListJobGroupsResponseBody = {
  asyncTaskId?: string(name='AsyncTaskId'),
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  jobGroups?: {
    list?: [ 
      {
        creationTime?: long(name='CreationTime'),
        exportProgress?: {
          fileHttpUrl?: string(name='FileHttpUrl'),
          progress?: string(name='Progress'),
          status?: string(name='Status'),
        }(name='ExportProgress'),
        jobDataParsingTaskId?: string(name='JobDataParsingTaskId'),
        jobGroupDescription?: string(name='JobGroupDescription'),
        jobGroupId?: string(name='JobGroupId'),
        jobGroupName?: string(name='JobGroupName'),
        modifyTime?: string(name='ModifyTime'),
        progress?: {
          cancelledNum?: int32(name='CancelledNum'),
          duration?: int32(name='Duration'),
          executingNum?: int32(name='ExecutingNum'),
          failedNum?: int32(name='FailedNum'),
          pausedNum?: int32(name='PausedNum'),
          scheduling?: int32(name='Scheduling'),
          startTime?: long(name='StartTime'),
          status?: string(name='Status'),
          totalCompleted?: int32(name='TotalCompleted'),
          totalJobs?: int32(name='TotalJobs'),
          totalNotAnswered?: int32(name='TotalNotAnswered'),
        }(name='Progress'),
        scriptId?: string(name='ScriptId'),
        scriptName?: string(name='ScriptName'),
        scriptVersion?: string(name='ScriptVersion'),
        status?: string(name='Status'),
        strategy?: {
          endTime?: long(name='EndTime'),
          startTime?: long(name='StartTime'),
        }(name='Strategy'),
        totalCallNum?: int32(name='TotalCallNum'),
      }
    ](name='List'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='JobGroups'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListJobGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobGroupsResponseBody(name='body'),
}

async function listJobGroupsWithOptions(request: ListJobGroupsRequest, runtime: Util.RuntimeOptions): ListJobGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asyncQuery)) {
    query['AsyncQuery'] = request.asyncQuery;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupStatusFilter)) {
    query['JobGroupStatusFilter'] = request.jobGroupStatusFilter;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchText)) {
    query['SearchText'] = request.searchText;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobGroups',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJobGroups(request: ListJobGroupsRequest): ListJobGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobGroupsWithOptions(request, runtime);
}

model ListJobGroupsAsyncRequest {
  asyncTaskId?: string(name='AsyncTaskId'),
}

model ListJobGroupsAsyncResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  jobGroups?: [ 
    {
      creationTime?: long(name='CreationTime'),
      exportProgress?: {
        fileHttpUrl?: string(name='FileHttpUrl'),
        progress?: string(name='Progress'),
        status?: string(name='Status'),
      }(name='ExportProgress'),
      jobDataParsingTaskId?: string(name='JobDataParsingTaskId'),
      jobGroupDescription?: string(name='JobGroupDescription'),
      jobGroupId?: string(name='JobGroupId'),
      jobGroupName?: string(name='JobGroupName'),
      modifyTime?: string(name='ModifyTime'),
      progress?: {
        cancelledNum?: int32(name='CancelledNum'),
        duration?: int32(name='Duration'),
        executingNum?: int32(name='ExecutingNum'),
        failedNum?: int32(name='FailedNum'),
        pausedNum?: int32(name='PausedNum'),
        scheduling?: int32(name='Scheduling'),
        startTime?: long(name='StartTime'),
        status?: string(name='Status'),
        totalCompleted?: int32(name='TotalCompleted'),
        totalJobs?: int32(name='TotalJobs'),
        totalNotAnswered?: int32(name='TotalNotAnswered'),
      }(name='Progress'),
      scriptId?: string(name='ScriptId'),
      scriptName?: string(name='ScriptName'),
      scriptVersion?: string(name='ScriptVersion'),
      status?: string(name='Status'),
      strategy?: {
        endTime?: long(name='EndTime'),
        startTime?: long(name='StartTime'),
      }(name='Strategy'),
      totalCallNum?: int32(name='TotalCallNum'),
    }
  ](name='JobGroups'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  timeout?: boolean(name='Timeout'),
  totalCount?: int32(name='TotalCount'),
  vaild?: boolean(name='Vaild'),
}

model ListJobGroupsAsyncResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobGroupsAsyncResponseBody(name='body'),
}

async function listJobGroupsAsyncWithOptions(request: ListJobGroupsAsyncRequest, runtime: Util.RuntimeOptions): ListJobGroupsAsyncResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobGroupsAsync',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJobGroupsAsync(request: ListJobGroupsAsyncRequest): ListJobGroupsAsyncResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobGroupsAsyncWithOptions(request, runtime);
}

model ListJobsRequest {
  instanceId?: string(name='InstanceId'),
  jobId?: [ string ](name='JobId'),
}

model ListJobsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  jobs?: [ 
    {
      callingNumbers?: [ string ](name='CallingNumbers'),
      contacts?: [ 
        {
          contactId?: string(name='ContactId'),
          contactName?: string(name='ContactName'),
          honorific?: string(name='Honorific'),
          jobId?: string(name='JobId'),
          phoneNumber?: string(name='PhoneNumber'),
          referenceId?: string(name='ReferenceId'),
          role?: string(name='Role'),
          state?: string(name='State'),
        }
      ](name='Contacts'),
      extras?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Extras'),
      failureReason?: string(name='FailureReason'),
      jobGroupId?: string(name='JobGroupId'),
      jobId?: string(name='JobId'),
      priority?: int32(name='Priority'),
      referenceId?: string(name='ReferenceId'),
      scenarioId?: string(name='ScenarioId'),
      status?: string(name='Status'),
      strategyId?: string(name='StrategyId'),
      summary?: [ 
        {
          category?: string(name='Category'),
          content?: string(name='Content'),
          summaryName?: string(name='SummaryName'),
        }
      ](name='Summary'),
      systemPriority?: int32(name='SystemPriority'),
      tasks?: [ 
        {
          actualTime?: long(name='ActualTime'),
          brief?: string(name='Brief'),
          callId?: string(name='CallId'),
          calledNumber?: string(name='CalledNumber'),
          callingNumber?: string(name='CallingNumber'),
          chatbotId?: string(name='ChatbotId'),
          contact?: {
            contactId?: string(name='ContactId'),
            contactName?: string(name='ContactName'),
            honorific?: string(name='Honorific'),
            jobId?: string(name='JobId'),
            phoneNumber?: string(name='PhoneNumber'),
            referenceId?: string(name='ReferenceId'),
            role?: string(name='Role'),
            state?: string(name='State'),
          }(name='Contact'),
          conversation?: [ 
            {
              script?: string(name='Script'),
              speaker?: string(name='Speaker'),
              summary?: [ 
                {
                  category?: string(name='Category'),
                  content?: string(name='Content'),
                  summaryName?: string(name='SummaryName'),
                }
              ](name='Summary'),
              timestamp?: long(name='Timestamp'),
            }
          ](name='Conversation'),
          duration?: int32(name='Duration'),
          jobId?: string(name='JobId'),
          planedTime?: long(name='PlanedTime'),
          scenarioId?: string(name='ScenarioId'),
          status?: string(name='Status'),
          taskId?: string(name='TaskId'),
        }
      ](name='Tasks'),
    }
  ](name='Jobs'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobsWithOptions(request: ListJobsRequest, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobs',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJobs(request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobsWithOptions(request, runtime);
}

model ListJobsByGroupRequest {
  instanceId?: string(name='InstanceId'),
  jobFailureReason?: string(name='JobFailureReason'),
  jobGroupId?: string(name='JobGroupId'),
  jobStatus?: string(name='JobStatus'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListJobsByGroupResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  jobs?: {
    list?: [ 
      {
        callingNumbers?: [ string ](name='CallingNumbers'),
        contacts?: [ 
          {
            contactId?: string(name='ContactId'),
            contactName?: string(name='ContactName'),
            honorific?: string(name='Honorific'),
            jobId?: string(name='JobId'),
            phoneNumber?: string(name='PhoneNumber'),
            referenceId?: string(name='ReferenceId'),
            role?: string(name='Role'),
            state?: string(name='State'),
          }
        ](name='Contacts'),
        extras?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Extras'),
        failureReason?: string(name='FailureReason'),
        jobGroupId?: string(name='JobGroupId'),
        jobId?: string(name='JobId'),
        priority?: int32(name='Priority'),
        referenceId?: string(name='ReferenceId'),
        scenarioId?: string(name='ScenarioId'),
        status?: string(name='Status'),
        strategyId?: string(name='StrategyId'),
        summary?: [ 
          {
            category?: string(name='Category'),
            content?: string(name='Content'),
            conversationDetailId?: string(name='ConversationDetailId'),
            jobGroupId?: string(name='JobGroupId'),
            jobId?: string(name='JobId'),
            summaryId?: string(name='SummaryId'),
            summaryName?: string(name='SummaryName'),
            taskId?: string(name='TaskId'),
          }
        ](name='Summary'),
        systemPriority?: int32(name='SystemPriority'),
      }
    ](name='List'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Jobs'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListJobsByGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobsByGroupResponseBody(name='body'),
}

async function listJobsByGroupWithOptions(request: ListJobsByGroupRequest, runtime: Util.RuntimeOptions): ListJobsByGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobFailureReason)) {
    query['JobFailureReason'] = request.jobFailureReason;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  if (!Util.isUnset(request.jobStatus)) {
    query['JobStatus'] = request.jobStatus;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobsByGroup',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJobsByGroup(request: ListJobsByGroupRequest): ListJobsByGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobsByGroupWithOptions(request, runtime);
}

model ListOutboundCallNumbersRequest {
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListOutboundCallNumbersResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  outboundCallNumbers?: {
    list?: [ 
      {
        number?: string(name='Number'),
        outboundCallNumberId?: string(name='OutboundCallNumberId'),
        rateLimitCount?: string(name='RateLimitCount'),
        rateLimitPeriod?: string(name='RateLimitPeriod'),
      }
    ](name='List'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='OutboundCallNumbers'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListOutboundCallNumbersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOutboundCallNumbersResponseBody(name='body'),
}

async function listOutboundCallNumbersWithOptions(request: ListOutboundCallNumbersRequest, runtime: Util.RuntimeOptions): ListOutboundCallNumbersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOutboundCallNumbers',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOutboundCallNumbers(request: ListOutboundCallNumbersRequest): ListOutboundCallNumbersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOutboundCallNumbersWithOptions(request, runtime);
}

model ListResourceTagsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceType?: string(name='ResourceType'),
}

model ListResourceTagsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resourceTags?: {
    list?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='List'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='ResourceTags'),
  success?: boolean(name='Success'),
}

model ListResourceTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceTagsResponseBody(name='body'),
}

async function listResourceTagsWithOptions(request: ListResourceTagsRequest, runtime: Util.RuntimeOptions): ListResourceTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceTags',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceTags(request: ListResourceTagsRequest): ListResourceTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceTagsWithOptions(request, runtime);
}

model ListSchedulerInstancesRequest {
  instanceOwnerId?: long(name='InstanceOwnerId'),
}

model ListSchedulerInstancesResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  schedulerInstances?: [ 
    {
      baseStrategy?: string(name='BaseStrategy'),
      business?: string(name='Business'),
      instanceId?: string(name='InstanceId'),
      maxConcurrency?: int32(name='MaxConcurrency'),
      ownerId?: string(name='OwnerId'),
    }
  ](name='SchedulerInstances'),
  success?: boolean(name='Success'),
}

model ListSchedulerInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSchedulerInstancesResponseBody(name='body'),
}

async function listSchedulerInstancesWithOptions(request: ListSchedulerInstancesRequest, runtime: Util.RuntimeOptions): ListSchedulerInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceOwnerId)) {
    query['InstanceOwnerId'] = request.instanceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSchedulerInstances',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSchedulerInstances(request: ListSchedulerInstancesRequest): ListSchedulerInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSchedulerInstancesWithOptions(request, runtime);
}

model ListScriptPublishHistoriesRequest {
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  scriptId?: string(name='ScriptId'),
}

model ListScriptPublishHistoriesResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  scriptPublishHistories?: {
    list?: [ 
      {
        description?: string(name='Description'),
        instanceId?: string(name='InstanceId'),
        publishTime?: long(name='PublishTime'),
        scriptId?: string(name='ScriptId'),
        scriptVersion?: string(name='ScriptVersion'),
      }
    ](name='List'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='ScriptPublishHistories'),
  success?: boolean(name='Success'),
}

model ListScriptPublishHistoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListScriptPublishHistoriesResponseBody(name='body'),
}

async function listScriptPublishHistoriesWithOptions(request: ListScriptPublishHistoriesRequest, runtime: Util.RuntimeOptions): ListScriptPublishHistoriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListScriptPublishHistories',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listScriptPublishHistories(request: ListScriptPublishHistoriesRequest): ListScriptPublishHistoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listScriptPublishHistoriesWithOptions(request, runtime);
}

model ListScriptVoiceConfigsRequest {
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  scriptId?: string(name='ScriptId'),
}

model ListScriptVoiceConfigsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  scriptVoiceConfigs?: {
    list?: [ 
      {
        instanceId?: string(name='InstanceId'),
        scriptContent?: string(name='ScriptContent'),
        scriptId?: string(name='ScriptId'),
        scriptVoiceConfigId?: string(name='ScriptVoiceConfigId'),
        scriptWaveformRelation?: string(name='ScriptWaveformRelation'),
        source?: string(name='Source'),
        type?: string(name='Type'),
      }
    ](name='List'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='ScriptVoiceConfigs'),
  success?: boolean(name='Success'),
}

model ListScriptVoiceConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListScriptVoiceConfigsResponseBody(name='body'),
}

async function listScriptVoiceConfigsWithOptions(request: ListScriptVoiceConfigsRequest, runtime: Util.RuntimeOptions): ListScriptVoiceConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListScriptVoiceConfigs',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listScriptVoiceConfigs(request: ListScriptVoiceConfigsRequest): ListScriptVoiceConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listScriptVoiceConfigsWithOptions(request, runtime);
}

model ListScriptsRequest {
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListScriptsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  scripts?: {
    list?: [ 
      {
        debugStatus?: string(name='DebugStatus'),
        industry?: string(name='Industry'),
        isDebugDrafted?: boolean(name='IsDebugDrafted'),
        isDrafted?: boolean(name='IsDrafted'),
        longWaitEnable?: boolean(name='LongWaitEnable'),
        miniPlaybackEnable?: boolean(name='MiniPlaybackEnable'),
        newBargeInEnable?: boolean(name='NewBargeInEnable'),
        rejectReason?: string(name='RejectReason'),
        scene?: string(name='Scene'),
        scriptDescription?: string(name='ScriptDescription'),
        scriptId?: string(name='ScriptId'),
        scriptName?: string(name='ScriptName'),
        status?: string(name='Status'),
        updateTime?: long(name='UpdateTime'),
      }
    ](name='List'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Scripts'),
  success?: boolean(name='Success'),
}

model ListScriptsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListScriptsResponseBody(name='body'),
}

async function listScriptsWithOptions(request: ListScriptsRequest, runtime: Util.RuntimeOptions): ListScriptsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListScripts',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listScripts(request: ListScriptsRequest): ListScriptsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listScriptsWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListTagsRequest {
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
}

model ListTagsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tagGroups?: [ 
    {
      scriptId?: string(name='ScriptId'),
      tagGroup?: string(name='TagGroup'),
      tagGroupId?: string(name='TagGroupId'),
      tagGroupIndex?: int32(name='TagGroupIndex'),
    }
  ](name='TagGroups'),
  tags?: [ 
    {
      scriptId?: string(name='ScriptId'),
      tagGroup?: string(name='TagGroup'),
      tagId?: string(name='TagId'),
      tagIndex?: int32(name='TagIndex'),
      tagName?: string(name='TagName'),
    }
  ](name='Tags'),
}

model ListTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagsResponseBody(name='body'),
}

async function listTagsWithOptions(request: ListTagsRequest, runtime: Util.RuntimeOptions): ListTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTags',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTags(request: ListTagsRequest): ListTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagsWithOptions(request, runtime);
}

model ModifyBatchJobsRequest {
  batchJobName?: string(name='BatchJobName'),
  callingNumber?: [ string ](name='CallingNumber'),
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  jobFilePath?: string(name='JobFilePath'),
  jobGroupId?: string(name='JobGroupId'),
  scenarioId?: string(name='ScenarioId'),
  scriptId?: string(name='ScriptId'),
  strategyJson?: string(name='StrategyJson'),
  submitted?: boolean(name='Submitted'),
}

model ModifyBatchJobsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  jobGroup?: {
    callingNumbers?: [ string ](name='CallingNumbers'),
    creationTime?: long(name='CreationTime'),
    jobFilePath?: string(name='JobFilePath'),
    jobGroupDescription?: string(name='JobGroupDescription'),
    jobGroupId?: string(name='JobGroupId'),
    jobGroupName?: string(name='JobGroupName'),
    scenarioId?: string(name='ScenarioId'),
    strategy?: {
      customized?: string(name='Customized'),
      endTime?: long(name='EndTime'),
      followUpStrategy?: string(name='FollowUpStrategy'),
      isTemplate?: boolean(name='IsTemplate'),
      maxAttemptsPerDay?: int32(name='MaxAttemptsPerDay'),
      minAttemptInterval?: int32(name='MinAttemptInterval'),
      repeatBy?: string(name='RepeatBy'),
      repeatDays?: [ string ](name='RepeatDays'),
      routingStrategy?: string(name='RoutingStrategy'),
      startTime?: long(name='StartTime'),
      strategyDescription?: string(name='StrategyDescription'),
      strategyId?: string(name='StrategyId'),
      strategyName?: string(name='StrategyName'),
      type?: string(name='Type'),
      workingTime?: [ 
        {
          beginTime?: string(name='BeginTime'),
          endTime?: string(name='EndTime'),
        }
      ](name='WorkingTime'),
    }(name='Strategy'),
  }(name='JobGroup'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyBatchJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyBatchJobsResponseBody(name='body'),
}

async function modifyBatchJobsWithOptions(request: ModifyBatchJobsRequest, runtime: Util.RuntimeOptions): ModifyBatchJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.batchJobName)) {
    query['BatchJobName'] = request.batchJobName;
  }
  if (!Util.isUnset(request.callingNumber)) {
    query['CallingNumber'] = request.callingNumber;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobFilePath)) {
    query['JobFilePath'] = request.jobFilePath;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  if (!Util.isUnset(request.scenarioId)) {
    query['ScenarioId'] = request.scenarioId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  if (!Util.isUnset(request.strategyJson)) {
    query['StrategyJson'] = request.strategyJson;
  }
  if (!Util.isUnset(request.submitted)) {
    query['Submitted'] = request.submitted;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBatchJobs',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyBatchJobs(request: ModifyBatchJobsRequest): ModifyBatchJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBatchJobsWithOptions(request, runtime);
}

model ModifyDialogueFlowRequest {
  dialogueFlowDefinition?: string(name='DialogueFlowDefinition'),
  dialogueFlowId?: string(name='DialogueFlowId'),
  instanceId?: string(name='InstanceId'),
  isDrafted?: boolean(name='IsDrafted'),
  scriptId?: string(name='ScriptId'),
}

model ModifyDialogueFlowResponseBody = {
  code?: string(name='Code'),
  dialogueFlowDefinition?: string(name='DialogueFlowDefinition'),
  dialogueFlowId?: string(name='DialogueFlowId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyDialogueFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDialogueFlowResponseBody(name='body'),
}

async function modifyDialogueFlowWithOptions(request: ModifyDialogueFlowRequest, runtime: Util.RuntimeOptions): ModifyDialogueFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dialogueFlowDefinition)) {
    query['DialogueFlowDefinition'] = request.dialogueFlowDefinition;
  }
  if (!Util.isUnset(request.dialogueFlowId)) {
    query['DialogueFlowId'] = request.dialogueFlowId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.isDrafted)) {
    query['IsDrafted'] = request.isDrafted;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDialogueFlow',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDialogueFlow(request: ModifyDialogueFlowRequest): ModifyDialogueFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDialogueFlowWithOptions(request, runtime);
}

model ModifyEmptyNumberNoMoreCallsInfoRequest {
  emptyNumberNoMoreCalls?: boolean(name='EmptyNumberNoMoreCalls'),
  entryId?: string(name='EntryId'),
  strategyLevel?: int32(name='StrategyLevel'),
}

model ModifyEmptyNumberNoMoreCallsInfoResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyEmptyNumberNoMoreCallsInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyEmptyNumberNoMoreCallsInfoResponseBody(name='body'),
}

async function modifyEmptyNumberNoMoreCallsInfoWithOptions(request: ModifyEmptyNumberNoMoreCallsInfoRequest, runtime: Util.RuntimeOptions): ModifyEmptyNumberNoMoreCallsInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.emptyNumberNoMoreCalls)) {
    query['EmptyNumberNoMoreCalls'] = request.emptyNumberNoMoreCalls;
  }
  if (!Util.isUnset(request.entryId)) {
    query['EntryId'] = request.entryId;
  }
  if (!Util.isUnset(request.strategyLevel)) {
    query['StrategyLevel'] = request.strategyLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyEmptyNumberNoMoreCallsInfo',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyEmptyNumberNoMoreCallsInfo(request: ModifyEmptyNumberNoMoreCallsInfoRequest): ModifyEmptyNumberNoMoreCallsInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyEmptyNumberNoMoreCallsInfoWithOptions(request, runtime);
}

model ModifyGlobalQuestionRequest {
  answers?: string(name='Answers'),
  globalQuestionId?: string(name='GlobalQuestionId'),
  globalQuestionName?: string(name='GlobalQuestionName'),
  globalQuestionType?: string(name='GlobalQuestionType'),
  instanceId?: string(name='InstanceId'),
  questions?: string(name='Questions'),
  scriptId?: string(name='ScriptId'),
}

model ModifyGlobalQuestionResponseBody = {
  code?: string(name='Code'),
  dialogueQuestionId?: string(name='DialogueQuestionId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyGlobalQuestionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyGlobalQuestionResponseBody(name='body'),
}

async function modifyGlobalQuestionWithOptions(request: ModifyGlobalQuestionRequest, runtime: Util.RuntimeOptions): ModifyGlobalQuestionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.answers)) {
    query['Answers'] = request.answers;
  }
  if (!Util.isUnset(request.globalQuestionId)) {
    query['GlobalQuestionId'] = request.globalQuestionId;
  }
  if (!Util.isUnset(request.globalQuestionName)) {
    query['GlobalQuestionName'] = request.globalQuestionName;
  }
  if (!Util.isUnset(request.globalQuestionType)) {
    query['GlobalQuestionType'] = request.globalQuestionType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.questions)) {
    query['Questions'] = request.questions;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGlobalQuestion',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyGlobalQuestion(request: ModifyGlobalQuestionRequest): ModifyGlobalQuestionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalQuestionWithOptions(request, runtime);
}

model ModifyInstanceRequest {
  callingNumber?: [ string ](name='CallingNumber'),
  instanceDescription?: string(name='InstanceDescription'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  maxConcurrentConversation?: int32(name='MaxConcurrentConversation'),
}

model ModifyInstanceResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  instance?: {
    creationTime?: long(name='CreationTime'),
    creatorId?: long(name='CreatorId'),
    creatorName?: string(name='CreatorName'),
    instanceDescription?: string(name='InstanceDescription'),
    instanceId?: string(name='InstanceId'),
    instanceName?: string(name='InstanceName'),
    maxConcurrentConversation?: int32(name='MaxConcurrentConversation'),
    ownerName?: string(name='OwnerName'),
  }(name='Instance'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceResponseBody(name='body'),
}

async function modifyInstanceWithOptions(request: ModifyInstanceRequest, runtime: Util.RuntimeOptions): ModifyInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.callingNumber)) {
    query['CallingNumber'] = request.callingNumber;
  }
  if (!Util.isUnset(request.instanceDescription)) {
    query['InstanceDescription'] = request.instanceDescription;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.maxConcurrentConversation)) {
    query['MaxConcurrentConversation'] = request.maxConcurrentConversation;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstance',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstance(request: ModifyInstanceRequest): ModifyInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceWithOptions(request, runtime);
}

model ModifyIntentRequest {
  instanceId?: string(name='InstanceId'),
  intentDescription?: string(name='IntentDescription'),
  intentId?: string(name='IntentId'),
  intentName?: string(name='IntentName'),
  keywords?: string(name='Keywords'),
  scriptId?: string(name='ScriptId'),
  utterances?: string(name='Utterances'),
}

model ModifyIntentResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  intentId?: string(name='IntentId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyIntentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyIntentResponseBody(name='body'),
}

async function modifyIntentWithOptions(request: ModifyIntentRequest, runtime: Util.RuntimeOptions): ModifyIntentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.intentDescription)) {
    query['IntentDescription'] = request.intentDescription;
  }
  if (!Util.isUnset(request.intentId)) {
    query['IntentId'] = request.intentId;
  }
  if (!Util.isUnset(request.intentName)) {
    query['IntentName'] = request.intentName;
  }
  if (!Util.isUnset(request.keywords)) {
    query['Keywords'] = request.keywords;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  if (!Util.isUnset(request.utterances)) {
    query['Utterances'] = request.utterances;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIntent',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyIntent(request: ModifyIntentRequest): ModifyIntentResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIntentWithOptions(request, runtime);
}

model ModifyJobGroupRequest {
  callingNumber?: [ string ](name='CallingNumber'),
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
  jobGroupStatus?: string(name='JobGroupStatus'),
  minConcurrency?: long(name='MinConcurrency'),
  name?: string(name='Name'),
  priority?: string(name='Priority'),
  recallStrategyJson?: string(name='RecallStrategyJson'),
  ringingDuration?: long(name='RingingDuration'),
  scenarioId?: string(name='ScenarioId'),
  scriptId?: string(name='ScriptId'),
  strategyJson?: string(name='StrategyJson'),
}

model ModifyJobGroupResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  jobGroup?: {
    callingNumbers?: [ string ](name='CallingNumbers'),
    creationTime?: long(name='CreationTime'),
    exportProgress?: {
      fileHttpUrl?: string(name='FileHttpUrl'),
      progress?: string(name='Progress'),
      status?: string(name='Status'),
    }(name='ExportProgress'),
    jobDataParsingTaskId?: string(name='JobDataParsingTaskId'),
    jobFilePath?: string(name='JobFilePath'),
    jobGroupDescription?: string(name='JobGroupDescription'),
    jobGroupId?: string(name='JobGroupId'),
    jobGroupName?: string(name='JobGroupName'),
    minConcurrency?: long(name='MinConcurrency'),
    modifyTime?: string(name='ModifyTime'),
    priority?: string(name='Priority'),
    recallStrategy?: {
      emptyNumberIgnore?: boolean(name='EmptyNumberIgnore'),
      inArrearsIgnore?: boolean(name='InArrearsIgnore'),
      outOfServiceIgnore?: boolean(name='OutOfServiceIgnore'),
    }(name='RecallStrategy'),
    ringingDuration?: long(name='RingingDuration'),
    scenarioId?: string(name='ScenarioId'),
    scriptName?: string(name='ScriptName'),
    scriptVersion?: string(name='ScriptVersion'),
    status?: string(name='Status'),
    strategy?: {
      customized?: string(name='Customized'),
      endTime?: long(name='EndTime'),
      followUpStrategy?: string(name='FollowUpStrategy'),
      isTemplate?: boolean(name='IsTemplate'),
      maxAttemptsPerDay?: int32(name='MaxAttemptsPerDay'),
      minAttemptInterval?: int32(name='MinAttemptInterval'),
      repeatBy?: string(name='RepeatBy'),
      repeatDays?: [ string ](name='RepeatDays'),
      routingStrategy?: string(name='RoutingStrategy'),
      startTime?: long(name='StartTime'),
      strategyDescription?: string(name='StrategyDescription'),
      strategyId?: string(name='StrategyId'),
      strategyName?: string(name='StrategyName'),
      type?: string(name='Type'),
      workingTime?: [ 
        {
          beginTime?: string(name='BeginTime'),
          endTime?: string(name='EndTime'),
        }
      ](name='WorkingTime'),
    }(name='Strategy'),
  }(name='JobGroup'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyJobGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyJobGroupResponseBody(name='body'),
}

async function modifyJobGroupWithOptions(request: ModifyJobGroupRequest, runtime: Util.RuntimeOptions): ModifyJobGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.callingNumber)) {
    query['CallingNumber'] = request.callingNumber;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  if (!Util.isUnset(request.jobGroupStatus)) {
    query['JobGroupStatus'] = request.jobGroupStatus;
  }
  if (!Util.isUnset(request.minConcurrency)) {
    query['MinConcurrency'] = request.minConcurrency;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.recallStrategyJson)) {
    query['RecallStrategyJson'] = request.recallStrategyJson;
  }
  if (!Util.isUnset(request.ringingDuration)) {
    query['RingingDuration'] = request.ringingDuration;
  }
  if (!Util.isUnset(request.scenarioId)) {
    query['ScenarioId'] = request.scenarioId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  if (!Util.isUnset(request.strategyJson)) {
    query['StrategyJson'] = request.strategyJson;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyJobGroup',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyJobGroup(request: ModifyJobGroupRequest): ModifyJobGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyJobGroupWithOptions(request, runtime);
}

model ModifyOutboundCallNumberRequest {
  instanceId?: string(name='InstanceId'),
  number?: string(name='Number'),
  outboundCallNumberId?: string(name='OutboundCallNumberId'),
  rateLimitCount?: int32(name='RateLimitCount'),
  rateLimitPeriod?: int32(name='RateLimitPeriod'),
}

model ModifyOutboundCallNumberResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  outboundCallNumber?: {
    number?: string(name='Number'),
    outboundCallNumberId?: string(name='OutboundCallNumberId'),
    rateLimitCount?: string(name='RateLimitCount'),
    rateLimitPeriod?: string(name='RateLimitPeriod'),
  }(name='OutboundCallNumber'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyOutboundCallNumberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyOutboundCallNumberResponseBody(name='body'),
}

async function modifyOutboundCallNumberWithOptions(request: ModifyOutboundCallNumberRequest, runtime: Util.RuntimeOptions): ModifyOutboundCallNumberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.number)) {
    query['Number'] = request.number;
  }
  if (!Util.isUnset(request.outboundCallNumberId)) {
    query['OutboundCallNumberId'] = request.outboundCallNumberId;
  }
  if (!Util.isUnset(request.rateLimitCount)) {
    query['RateLimitCount'] = request.rateLimitCount;
  }
  if (!Util.isUnset(request.rateLimitPeriod)) {
    query['RateLimitPeriod'] = request.rateLimitPeriod;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyOutboundCallNumber',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyOutboundCallNumber(request: ModifyOutboundCallNumberRequest): ModifyOutboundCallNumberResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyOutboundCallNumberWithOptions(request, runtime);
}

model ModifyScriptRequest {
  asrConfig?: string(name='AsrConfig'),
  chatbotId?: string(name='ChatbotId'),
  industry?: string(name='Industry'),
  instanceId?: string(name='InstanceId'),
  longWaitEnable?: boolean(name='LongWaitEnable'),
  miniPlaybackConfigListJsonString?: string(name='MiniPlaybackConfigListJsonString'),
  miniPlaybackEnable?: boolean(name='MiniPlaybackEnable'),
  newBargeInEnable?: boolean(name='NewBargeInEnable'),
  nlsConfig?: string(name='NlsConfig'),
  scene?: string(name='Scene'),
  scriptContent?: [ string ](name='ScriptContent'),
  scriptDescription?: string(name='ScriptDescription'),
  scriptId?: string(name='ScriptId'),
  scriptName?: string(name='ScriptName'),
  scriptWaveform?: [ string ](name='ScriptWaveform'),
  ttsConfig?: string(name='TtsConfig'),
}

model ModifyScriptResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  script?: {
    debugStatus?: string(name='DebugStatus'),
    industry?: string(name='Industry'),
    isDebugDrafted?: boolean(name='IsDebugDrafted'),
    isDrafted?: boolean(name='IsDrafted'),
    scene?: string(name='Scene'),
    scriptDescription?: string(name='ScriptDescription'),
    scriptId?: string(name='ScriptId'),
    scriptName?: string(name='ScriptName'),
    status?: string(name='Status'),
    updateTime?: long(name='UpdateTime'),
  }(name='Script'),
  success?: boolean(name='Success'),
}

model ModifyScriptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyScriptResponseBody(name='body'),
}

async function modifyScriptWithOptions(request: ModifyScriptRequest, runtime: Util.RuntimeOptions): ModifyScriptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asrConfig)) {
    query['AsrConfig'] = request.asrConfig;
  }
  if (!Util.isUnset(request.chatbotId)) {
    query['ChatbotId'] = request.chatbotId;
  }
  if (!Util.isUnset(request.industry)) {
    query['Industry'] = request.industry;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.longWaitEnable)) {
    query['LongWaitEnable'] = request.longWaitEnable;
  }
  if (!Util.isUnset(request.miniPlaybackConfigListJsonString)) {
    query['MiniPlaybackConfigListJsonString'] = request.miniPlaybackConfigListJsonString;
  }
  if (!Util.isUnset(request.miniPlaybackEnable)) {
    query['MiniPlaybackEnable'] = request.miniPlaybackEnable;
  }
  if (!Util.isUnset(request.newBargeInEnable)) {
    query['NewBargeInEnable'] = request.newBargeInEnable;
  }
  if (!Util.isUnset(request.nlsConfig)) {
    query['NlsConfig'] = request.nlsConfig;
  }
  if (!Util.isUnset(request.scene)) {
    query['Scene'] = request.scene;
  }
  if (!Util.isUnset(request.scriptContent)) {
    query['ScriptContent'] = request.scriptContent;
  }
  if (!Util.isUnset(request.scriptDescription)) {
    query['ScriptDescription'] = request.scriptDescription;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  if (!Util.isUnset(request.scriptName)) {
    query['ScriptName'] = request.scriptName;
  }
  if (!Util.isUnset(request.scriptWaveform)) {
    query['ScriptWaveform'] = request.scriptWaveform;
  }
  if (!Util.isUnset(request.ttsConfig)) {
    query['TtsConfig'] = request.ttsConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyScript',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyScript(request: ModifyScriptRequest): ModifyScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyScriptWithOptions(request, runtime);
}

model ModifyScriptVoiceConfigRequest {
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
  scriptVoiceConfigId?: string(name='ScriptVoiceConfigId'),
  scriptWaveformRelation?: string(name='ScriptWaveformRelation'),
  type?: string(name='Type'),
}

model ModifyScriptVoiceConfigResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  scriptVoiceConfig?: {
    instanceId?: string(name='InstanceId'),
    scriptContent?: string(name='ScriptContent'),
    scriptId?: string(name='ScriptId'),
    scriptVoiceConfigId?: string(name='ScriptVoiceConfigId'),
    scriptWaveformRelation?: string(name='ScriptWaveformRelation'),
    source?: string(name='Source'),
    type?: string(name='Type'),
  }(name='ScriptVoiceConfig'),
  success?: boolean(name='Success'),
}

model ModifyScriptVoiceConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyScriptVoiceConfigResponseBody(name='body'),
}

async function modifyScriptVoiceConfigWithOptions(request: ModifyScriptVoiceConfigRequest, runtime: Util.RuntimeOptions): ModifyScriptVoiceConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  if (!Util.isUnset(request.scriptVoiceConfigId)) {
    query['ScriptVoiceConfigId'] = request.scriptVoiceConfigId;
  }
  if (!Util.isUnset(request.scriptWaveformRelation)) {
    query['ScriptWaveformRelation'] = request.scriptWaveformRelation;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyScriptVoiceConfig',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyScriptVoiceConfig(request: ModifyScriptVoiceConfigRequest): ModifyScriptVoiceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyScriptVoiceConfigWithOptions(request, runtime);
}

model ModifyTTSConfigRequest {
  appKey?: string(name='AppKey'),
  instanceId?: string(name='InstanceId'),
  nlsServiceType?: string(name='NlsServiceType'),
  scriptId?: string(name='ScriptId'),
  speechRate?: string(name='SpeechRate'),
  voice?: string(name='Voice'),
  volume?: string(name='Volume'),
}

model ModifyTTSConfigResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  TTSConfig?: {
    instanceId?: string(name='InstanceId'),
    scriptId?: string(name='ScriptId'),
    speechRate?: string(name='SpeechRate'),
    TTSConfigId?: string(name='TTSConfigId'),
    voice?: string(name='Voice'),
    volume?: string(name='Volume'),
  }(name='TTSConfig'),
}

model ModifyTTSConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyTTSConfigResponseBody(name='body'),
}

async function modifyTTSConfigWithOptions(request: ModifyTTSConfigRequest, runtime: Util.RuntimeOptions): ModifyTTSConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appKey)) {
    query['AppKey'] = request.appKey;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.nlsServiceType)) {
    query['NlsServiceType'] = request.nlsServiceType;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  if (!Util.isUnset(request.speechRate)) {
    query['SpeechRate'] = request.speechRate;
  }
  if (!Util.isUnset(request.voice)) {
    query['Voice'] = request.voice;
  }
  if (!Util.isUnset(request.volume)) {
    query['Volume'] = request.volume;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyTTSConfig',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyTTSConfig(request: ModifyTTSConfigRequest): ModifyTTSConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTTSConfigWithOptions(request, runtime);
}

model ModifyTagGroupsRequest {
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
  tagGroups?: string(name='TagGroups'),
  tags?: string(name='Tags'),
}

model ModifyTagGroupsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tagGroups?: [ 
    {
      scriptId?: string(name='ScriptId'),
      tagGroup?: string(name='TagGroup'),
      tagGroupId?: string(name='TagGroupId'),
      tagGroupIndex?: int32(name='TagGroupIndex'),
    }
  ](name='TagGroups'),
  tags?: [ 
    {
      scriptId?: string(name='ScriptId'),
      tagGroup?: string(name='TagGroup'),
      tagId?: string(name='TagId'),
      tagIndex?: int32(name='TagIndex'),
      tagName?: string(name='TagName'),
    }
  ](name='Tags'),
}

model ModifyTagGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyTagGroupsResponseBody(name='body'),
}

async function modifyTagGroupsWithOptions(request: ModifyTagGroupsRequest, runtime: Util.RuntimeOptions): ModifyTagGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  if (!Util.isUnset(request.tagGroups)) {
    query['TagGroups'] = request.tagGroups;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyTagGroups',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyTagGroups(request: ModifyTagGroupsRequest): ModifyTagGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTagGroupsWithOptions(request, runtime);
}

model PublishScriptRequest {
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
}

model PublishScriptResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PublishScriptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishScriptResponseBody(name='body'),
}

async function publishScriptWithOptions(request: PublishScriptRequest, runtime: Util.RuntimeOptions): PublishScriptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublishScript',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function publishScript(request: PublishScriptRequest): PublishScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishScriptWithOptions(request, runtime);
}

model PublishScriptForDebugRequest {
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
}

model PublishScriptForDebugResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PublishScriptForDebugResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishScriptForDebugResponseBody(name='body'),
}

async function publishScriptForDebugWithOptions(request: PublishScriptForDebugRequest, runtime: Util.RuntimeOptions): PublishScriptForDebugResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublishScriptForDebug',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function publishScriptForDebug(request: PublishScriptForDebugRequest): PublishScriptForDebugResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishScriptForDebugWithOptions(request, runtime);
}

model QueryJobsRequest {
  contactName?: string(name='ContactName'),
  endTime?: long(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  phoneNumber?: string(name='PhoneNumber'),
  scenarioId?: string(name='ScenarioId'),
  startTime?: long(name='StartTime'),
  timeAlignment?: string(name='TimeAlignment'),
}

model QueryJobsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  jobs?: {
    list?: [ 
      {
        callingNumbers?: [ string ](name='CallingNumbers'),
        contacts?: [ 
          {
            contactId?: string(name='ContactId'),
            contactName?: string(name='ContactName'),
            honorific?: string(name='Honorific'),
            jobId?: string(name='JobId'),
            phoneNumber?: string(name='PhoneNumber'),
            referenceId?: string(name='ReferenceId'),
            role?: string(name='Role'),
            state?: string(name='State'),
          }
        ](name='Contacts'),
        extras?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Extras'),
        failureReason?: string(name='FailureReason'),
        jobGroupId?: string(name='JobGroupId'),
        jobId?: string(name='JobId'),
        priority?: int32(name='Priority'),
        referenceId?: string(name='ReferenceId'),
        scenarioId?: string(name='ScenarioId'),
        status?: string(name='Status'),
        strategyId?: string(name='StrategyId'),
        summary?: [ 
          {
            category?: string(name='Category'),
            content?: string(name='Content'),
            conversationDetailId?: string(name='ConversationDetailId'),
            groupId?: string(name='GroupId'),
            jobId?: string(name='JobId'),
            summaryId?: string(name='SummaryId'),
            summaryName?: string(name='SummaryName'),
            taskId?: string(name='TaskId'),
          }
        ](name='Summary'),
        tasks?: [ 
          {
            actualTime?: long(name='ActualTime'),
            brief?: string(name='Brief'),
            callId?: string(name='CallId'),
            calledNumber?: string(name='CalledNumber'),
            callingNumber?: string(name='CallingNumber'),
            chatbotId?: string(name='ChatbotId'),
            contact?: {
              contactId?: string(name='ContactId'),
              contactName?: string(name='ContactName'),
              honorific?: string(name='Honorific'),
              jobId?: string(name='JobId'),
              phoneNumber?: string(name='PhoneNumber'),
              referenceId?: string(name='ReferenceId'),
              role?: string(name='Role'),
              state?: string(name='State'),
            }(name='Contact'),
            duration?: int32(name='Duration'),
            jobId?: string(name='JobId'),
            planedTime?: long(name='PlanedTime'),
            scenarioId?: string(name='ScenarioId'),
            status?: string(name='Status'),
            taskId?: string(name='TaskId'),
          }
        ](name='Tasks'),
      }
    ](name='List'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Jobs'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryJobsResponseBody(name='body'),
}

async function queryJobsWithOptions(request: QueryJobsRequest, runtime: Util.RuntimeOptions): QueryJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.phoneNumber)) {
    query['PhoneNumber'] = request.phoneNumber;
  }
  if (!Util.isUnset(request.scenarioId)) {
    query['ScenarioId'] = request.scenarioId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.timeAlignment)) {
    query['TimeAlignment'] = request.timeAlignment;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryJobs',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryJobs(request: QueryJobsRequest): QueryJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryJobsWithOptions(request, runtime);
}

model QueryJobsWithResultRequest {
  hasAnsweredFilter?: boolean(name='HasAnsweredFilter'),
  hasHangUpByRejectionFilter?: boolean(name='HasHangUpByRejectionFilter'),
  hasReachedEndOfFlowFilter?: boolean(name='HasReachedEndOfFlowFilter'),
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
  jobStatusFilter?: string(name='JobStatusFilter'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  queryText?: string(name='QueryText'),
}

model QueryJobsWithResultResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  jobs?: {
    list?: [ 
      {
        id?: string(name='Id'),
        jobFailureReason?: string(name='JobFailureReason'),
        latestTask?: {
          callDuration?: int32(name='CallDuration'),
          callDurationDisplay?: string(name='CallDurationDisplay'),
          callTime?: long(name='CallTime'),
          contact?: {
            honorific?: string(name='Honorific'),
            id?: string(name='Id'),
            jobUuid?: string(name='JobUuid'),
            name?: string(name='Name'),
            phoneNumber?: string(name='PhoneNumber'),
            preferredPhoneNumber?: string(name='PreferredPhoneNumber'),
            referenceId?: string(name='ReferenceId'),
            role?: string(name='Role'),
            round?: int32(name='Round'),
            state?: string(name='State'),
          }(name='Contact'),
          dialExceptionCodes?: [ 
            {
              code?: string(name='Code'),
              hint?: string(name='Hint'),
            }
          ](name='DialExceptionCodes'),
          extras?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
            }
          ](name='Extras'),
          hasAnswered?: boolean(name='HasAnswered'),
          hasHangUpByRejection?: boolean(name='HasHangUpByRejection'),
          hasLastPlaybackCompleted?: boolean(name='HasLastPlaybackCompleted'),
          hasReachedEndOfFlow?: boolean(name='HasReachedEndOfFlow'),
          status?: string(name='Status'),
          statusName?: string(name='StatusName'),
          tagHits?: [ 
            {
              tagGroup?: string(name='TagGroup'),
              tagName?: string(name='TagName'),
            }
          ](name='TagHits'),
          taskEndReason?: string(name='TaskEndReason'),
        }(name='LatestTask'),
        status?: string(name='Status'),
        statusName?: string(name='StatusName'),
      }
    ](name='List'),
    pageCount?: int32(name='PageCount'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    rowCount?: int32(name='RowCount'),
  }(name='Jobs'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  variableNames?: [ string ](name='VariableNames'),
}

model QueryJobsWithResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryJobsWithResultResponseBody(name='body'),
}

async function queryJobsWithResultWithOptions(request: QueryJobsWithResultRequest, runtime: Util.RuntimeOptions): QueryJobsWithResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hasAnsweredFilter)) {
    query['HasAnsweredFilter'] = request.hasAnsweredFilter;
  }
  if (!Util.isUnset(request.hasHangUpByRejectionFilter)) {
    query['HasHangUpByRejectionFilter'] = request.hasHangUpByRejectionFilter;
  }
  if (!Util.isUnset(request.hasReachedEndOfFlowFilter)) {
    query['HasReachedEndOfFlowFilter'] = request.hasReachedEndOfFlowFilter;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  if (!Util.isUnset(request.jobStatusFilter)) {
    query['JobStatusFilter'] = request.jobStatusFilter;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryText)) {
    query['QueryText'] = request.queryText;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryJobsWithResult',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryJobsWithResult(request: QueryJobsWithResultRequest): QueryJobsWithResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryJobsWithResultWithOptions(request, runtime);
}

model QueryScriptWaveformsRequest {
  instanceId?: string(name='InstanceId'),
  scriptContent?: string(name='ScriptContent'),
  scriptId?: string(name='ScriptId'),
}

model QueryScriptWaveformsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  scriptWaveforms?: [ 
    {
      fileId?: string(name='FileId'),
      fileName?: string(name='FileName'),
      scriptContent?: string(name='ScriptContent'),
      scriptId?: string(name='ScriptId'),
      scriptWaveformId?: string(name='ScriptWaveformId'),
    }
  ](name='ScriptWaveforms'),
  success?: boolean(name='Success'),
}

model QueryScriptWaveformsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryScriptWaveformsResponseBody(name='body'),
}

async function queryScriptWaveformsWithOptions(request: QueryScriptWaveformsRequest, runtime: Util.RuntimeOptions): QueryScriptWaveformsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptContent)) {
    query['ScriptContent'] = request.scriptContent;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryScriptWaveforms',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryScriptWaveforms(request: QueryScriptWaveformsRequest): QueryScriptWaveformsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryScriptWaveformsWithOptions(request, runtime);
}

model QueryScriptsByStatusRequest {
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  statusList?: [ string ](name='StatusList'),
}

model QueryScriptsByStatusResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  scripts?: {
    list?: [ 
      {
        appliedVersion?: string(name='AppliedVersion'),
        debugStatus?: string(name='DebugStatus'),
        debugVersion?: string(name='DebugVersion'),
        industry?: string(name='Industry'),
        isDebugDrafted?: boolean(name='IsDebugDrafted'),
        isDrafted?: boolean(name='IsDrafted'),
        scene?: string(name='Scene'),
        scriptDescription?: string(name='ScriptDescription'),
        scriptId?: string(name='ScriptId'),
        scriptName?: string(name='ScriptName'),
        status?: string(name='Status'),
        updateTime?: long(name='UpdateTime'),
      }
    ](name='List'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Scripts'),
  success?: boolean(name='Success'),
}

model QueryScriptsByStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryScriptsByStatusResponseBody(name='body'),
}

async function queryScriptsByStatusWithOptions(request: QueryScriptsByStatusRequest, runtime: Util.RuntimeOptions): QueryScriptsByStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryScriptsByStatus',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryScriptsByStatus(request: QueryScriptsByStatusRequest): QueryScriptsByStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryScriptsByStatusWithOptions(request, runtime);
}

model RecordFailureRequest {
  actualTime?: long(name='ActualTime'),
  callId?: string(name='CallId'),
  calledNumber?: string(name='CalledNumber'),
  callingNumber?: string(name='CallingNumber'),
  dispositionCode?: string(name='DispositionCode'),
  exceptionCodes?: string(name='ExceptionCodes'),
  instanceId?: string(name='InstanceId'),
  taskId?: string(name='TaskId'),
}

model RecordFailureResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RecordFailureResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecordFailureResponseBody(name='body'),
}

async function recordFailureWithOptions(request: RecordFailureRequest, runtime: Util.RuntimeOptions): RecordFailureResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actualTime)) {
    query['ActualTime'] = request.actualTime;
  }
  if (!Util.isUnset(request.callId)) {
    query['CallId'] = request.callId;
  }
  if (!Util.isUnset(request.calledNumber)) {
    query['CalledNumber'] = request.calledNumber;
  }
  if (!Util.isUnset(request.callingNumber)) {
    query['CallingNumber'] = request.callingNumber;
  }
  if (!Util.isUnset(request.dispositionCode)) {
    query['DispositionCode'] = request.dispositionCode;
  }
  if (!Util.isUnset(request.exceptionCodes)) {
    query['ExceptionCodes'] = request.exceptionCodes;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RecordFailure',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recordFailure(request: RecordFailureRequest): RecordFailureResponse {
  var runtime = new Util.RuntimeOptions{};
  return recordFailureWithOptions(request, runtime);
}

model ResumeJobsRequest {
  all?: boolean(name='All'),
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
  jobId?: [ string ](name='JobId'),
  jobReferenceId?: [ string ](name='JobReferenceId'),
  scenarioId?: string(name='ScenarioId'),
}

model ResumeJobsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ResumeJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResumeJobsResponseBody(name='body'),
}

async function resumeJobsWithOptions(request: ResumeJobsRequest, runtime: Util.RuntimeOptions): ResumeJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.jobReferenceId)) {
    query['JobReferenceId'] = request.jobReferenceId;
  }
  if (!Util.isUnset(request.scenarioId)) {
    query['ScenarioId'] = request.scenarioId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResumeJobs',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resumeJobs(request: ResumeJobsRequest): ResumeJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumeJobsWithOptions(request, runtime);
}

model RollbackScriptRequest {
  instanceId?: string(name='InstanceId'),
  rollbackVersion?: string(name='RollbackVersion'),
  scriptId?: string(name='ScriptId'),
}

model RollbackScriptResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RollbackScriptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RollbackScriptResponseBody(name='body'),
}

async function rollbackScriptWithOptions(request: RollbackScriptRequest, runtime: Util.RuntimeOptions): RollbackScriptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.rollbackVersion)) {
    query['RollbackVersion'] = request.rollbackVersion;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RollbackScript',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rollbackScript(request: RollbackScriptRequest): RollbackScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  return rollbackScriptWithOptions(request, runtime);
}

model SaveAfterAnswerDelayPlaybackRequest {
  afterAnswerDelayPlayback?: int32(name='AfterAnswerDelayPlayback'),
  entryId?: string(name='EntryId'),
  strategyLevel?: int32(name='StrategyLevel'),
}

model SaveAfterAnswerDelayPlaybackResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveAfterAnswerDelayPlaybackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveAfterAnswerDelayPlaybackResponseBody(name='body'),
}

async function saveAfterAnswerDelayPlaybackWithOptions(request: SaveAfterAnswerDelayPlaybackRequest, runtime: Util.RuntimeOptions): SaveAfterAnswerDelayPlaybackResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.afterAnswerDelayPlayback)) {
    query['AfterAnswerDelayPlayback'] = request.afterAnswerDelayPlayback;
  }
  if (!Util.isUnset(request.entryId)) {
    query['EntryId'] = request.entryId;
  }
  if (!Util.isUnset(request.strategyLevel)) {
    query['StrategyLevel'] = request.strategyLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveAfterAnswerDelayPlayback',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveAfterAnswerDelayPlayback(request: SaveAfterAnswerDelayPlaybackRequest): SaveAfterAnswerDelayPlaybackResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveAfterAnswerDelayPlaybackWithOptions(request, runtime);
}

model SaveBaseStrategyPeriodRequest {
  entryId?: string(name='EntryId'),
  onlyWeekdays?: boolean(name='OnlyWeekdays'),
  strategyLevel?: int32(name='StrategyLevel'),
  workingTime?: [ string ](name='WorkingTime'),
  workingTimeFramesJson?: string(name='WorkingTimeFramesJson'),
}

model SaveBaseStrategyPeriodResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveBaseStrategyPeriodResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBaseStrategyPeriodResponseBody(name='body'),
}

async function saveBaseStrategyPeriodWithOptions(request: SaveBaseStrategyPeriodRequest, runtime: Util.RuntimeOptions): SaveBaseStrategyPeriodResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.entryId)) {
    query['EntryId'] = request.entryId;
  }
  if (!Util.isUnset(request.onlyWeekdays)) {
    query['OnlyWeekdays'] = request.onlyWeekdays;
  }
  if (!Util.isUnset(request.strategyLevel)) {
    query['StrategyLevel'] = request.strategyLevel;
  }
  if (!Util.isUnset(request.workingTime)) {
    query['WorkingTime'] = request.workingTime;
  }
  if (!Util.isUnset(request.workingTimeFramesJson)) {
    query['WorkingTimeFramesJson'] = request.workingTimeFramesJson;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveBaseStrategyPeriod',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveBaseStrategyPeriod(request: SaveBaseStrategyPeriodRequest): SaveBaseStrategyPeriodResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBaseStrategyPeriodWithOptions(request, runtime);
}

model SaveContactBlockListRequest {
  contactBlockListList?: [ string ](name='ContactBlockListList'),
  contactBlockListsJson?: string(name='ContactBlockListsJson'),
  instanceId?: string(name='InstanceId'),
}

model SaveContactBlockListResponseBody = {
  affectedRows?: int32(name='AffectedRows'),
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveContactBlockListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveContactBlockListResponseBody(name='body'),
}

async function saveContactBlockListWithOptions(request: SaveContactBlockListRequest, runtime: Util.RuntimeOptions): SaveContactBlockListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactBlockListList)) {
    query['ContactBlockListList'] = request.contactBlockListList;
  }
  if (!Util.isUnset(request.contactBlockListsJson)) {
    query['ContactBlockListsJson'] = request.contactBlockListsJson;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveContactBlockList',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveContactBlockList(request: SaveContactBlockListRequest): SaveContactBlockListResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveContactBlockListWithOptions(request, runtime);
}

model SaveContactWhiteListRequest {
  contactWhiteListList?: [ string ](name='ContactWhiteListList'),
  contactWhiteListsJson?: string(name='ContactWhiteListsJson'),
  instanceId?: string(name='InstanceId'),
}

model SaveContactWhiteListResponseBody = {
  affectedRows?: int32(name='AffectedRows'),
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveContactWhiteListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveContactWhiteListResponseBody(name='body'),
}

async function saveContactWhiteListWithOptions(request: SaveContactWhiteListRequest, runtime: Util.RuntimeOptions): SaveContactWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactWhiteListList)) {
    query['ContactWhiteListList'] = request.contactWhiteListList;
  }
  if (!Util.isUnset(request.contactWhiteListsJson)) {
    query['ContactWhiteListsJson'] = request.contactWhiteListsJson;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveContactWhiteList',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveContactWhiteList(request: SaveContactWhiteListRequest): SaveContactWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveContactWhiteListWithOptions(request, runtime);
}

model SaveEffectiveDaysRequest {
  effectiveDays?: int32(name='EffectiveDays'),
  entryId?: string(name='EntryId'),
  strategyLevel?: int32(name='StrategyLevel'),
}

model SaveEffectiveDaysResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveEffectiveDaysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveEffectiveDaysResponseBody(name='body'),
}

async function saveEffectiveDaysWithOptions(request: SaveEffectiveDaysRequest, runtime: Util.RuntimeOptions): SaveEffectiveDaysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.effectiveDays)) {
    query['EffectiveDays'] = request.effectiveDays;
  }
  if (!Util.isUnset(request.entryId)) {
    query['EntryId'] = request.entryId;
  }
  if (!Util.isUnset(request.strategyLevel)) {
    query['StrategyLevel'] = request.strategyLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveEffectiveDays',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveEffectiveDays(request: SaveEffectiveDaysRequest): SaveEffectiveDaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveEffectiveDaysWithOptions(request, runtime);
}

model SaveMaxAttemptsPerDayRequest {
  entryId?: string(name='EntryId'),
  maxAttemptsPerDay?: int32(name='MaxAttemptsPerDay'),
  strategyLevel?: int32(name='StrategyLevel'),
}

model SaveMaxAttemptsPerDayResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveMaxAttemptsPerDayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveMaxAttemptsPerDayResponseBody(name='body'),
}

async function saveMaxAttemptsPerDayWithOptions(request: SaveMaxAttemptsPerDayRequest, runtime: Util.RuntimeOptions): SaveMaxAttemptsPerDayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.entryId)) {
    query['EntryId'] = request.entryId;
  }
  if (!Util.isUnset(request.maxAttemptsPerDay)) {
    query['MaxAttemptsPerDay'] = request.maxAttemptsPerDay;
  }
  if (!Util.isUnset(request.strategyLevel)) {
    query['StrategyLevel'] = request.strategyLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveMaxAttemptsPerDay',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveMaxAttemptsPerDay(request: SaveMaxAttemptsPerDayRequest): SaveMaxAttemptsPerDayResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveMaxAttemptsPerDayWithOptions(request, runtime);
}

model SearchTaskRequest {
  actualTimeGte?: long(name='ActualTimeGte'),
  actualTimeLte?: long(name='ActualTimeLte'),
  callDurationGte?: long(name='CallDurationGte'),
  callDurationLte?: long(name='CallDurationLte'),
  calledNumber?: string(name='CalledNumber'),
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
  jobGroupNameQuery?: string(name='JobGroupNameQuery'),
  jobId?: string(name='JobId'),
  jobStatusStringList?: string(name='JobStatusStringList'),
  otherId?: string(name='OtherId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  recordingDurationGte?: long(name='RecordingDurationGte'),
  recordingDurationLte?: long(name='RecordingDurationLte'),
  scriptNameQuery?: string(name='ScriptNameQuery'),
  sortBy?: string(name='SortBy'),
  sortOrder?: string(name='SortOrder'),
  taskCreateTimeGte?: long(name='TaskCreateTimeGte'),
  taskCreateTimeLte?: long(name='TaskCreateTimeLte'),
  taskId?: string(name='TaskId'),
  taskStatusStringList?: string(name='TaskStatusStringList'),
  userIdMatch?: string(name='UserIdMatch'),
}

model SearchTaskResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  searchTaskInfoList?: [ 
    {
      actualTime?: long(name='ActualTime'),
      callDuration?: int32(name='CallDuration'),
      callDurationDisplay?: string(name='CallDurationDisplay'),
      calledNumber?: string(name='CalledNumber'),
      dialException?: string(name='DialException'),
      dialExceptionCodes?: [ string ](name='DialExceptionCodes'),
      dialExceptionOld?: string(name='DialExceptionOld'),
      hasAnswered?: boolean(name='HasAnswered'),
      hasHangUpByRejection?: boolean(name='HasHangUpByRejection'),
      hasLastPlaybackCompleted?: boolean(name='HasLastPlaybackCompleted'),
      hasReachedEndOfFlow?: boolean(name='HasReachedEndOfFlow'),
      instanceId?: string(name='InstanceId'),
      jobGroupId?: string(name='JobGroupId'),
      jobGroupName?: string(name='JobGroupName'),
      jobId?: string(name='JobId'),
      jobStatus?: int32(name='JobStatus'),
      jobStatusName?: string(name='JobStatusName'),
      jobStatusString?: string(name='JobStatusString'),
      recordingDuration?: int32(name='RecordingDuration'),
      scriptName?: string(name='ScriptName'),
      taskCreateTime?: long(name='TaskCreateTime'),
      taskEndReason?: int32(name='TaskEndReason'),
      taskId?: string(name='TaskId'),
      taskStatus?: int32(name='TaskStatus'),
      taskStatusName?: string(name='TaskStatusName'),
      taskStatusString?: string(name='TaskStatusString'),
      userId?: string(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='SearchTaskInfoList'),
  success?: boolean(name='Success'),
  total?: long(name='Total'),
}

model SearchTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchTaskResponseBody(name='body'),
}

async function searchTaskWithOptions(request: SearchTaskRequest, runtime: Util.RuntimeOptions): SearchTaskResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchTask',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchTask(request: SearchTaskRequest): SearchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTaskWithOptions(request, runtime);
}

model StartJobRequest {
  callingNumber?: [ string ](name='CallingNumber'),
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
  jobJson?: string(name='JobJson'),
  scenarioId?: string(name='ScenarioId'),
  scriptId?: string(name='ScriptId'),
}

model StartJobResponseBody = {
  callIds?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='CallIds'),
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskIds?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='TaskIds'),
}

model StartJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartJobResponseBody(name='body'),
}

async function startJobWithOptions(request: StartJobRequest, runtime: Util.RuntimeOptions): StartJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.callingNumber)) {
    query['CallingNumber'] = request.callingNumber;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  if (!Util.isUnset(request.jobJson)) {
    query['JobJson'] = request.jobJson;
  }
  if (!Util.isUnset(request.scenarioId)) {
    query['ScenarioId'] = request.scenarioId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartJob',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startJob(request: StartJobRequest): StartJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return startJobWithOptions(request, runtime);
}

model SubmitBatchJobsRequest {
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
}

model SubmitBatchJobsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubmitBatchJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitBatchJobsResponseBody(name='body'),
}

async function submitBatchJobsWithOptions(request: SubmitBatchJobsRequest, runtime: Util.RuntimeOptions): SubmitBatchJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitBatchJobs',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitBatchJobs(request: SubmitBatchJobsRequest): SubmitBatchJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitBatchJobsWithOptions(request, runtime);
}

model SubmitRecordingRequest {
  instanceId?: string(name='InstanceId'),
  mergedRecording?: string(name='MergedRecording'),
  resourceRecording?: string(name='ResourceRecording'),
  taskId?: string(name='TaskId'),
}

model SubmitRecordingResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubmitRecordingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitRecordingResponseBody(name='body'),
}

async function submitRecordingWithOptions(request: SubmitRecordingRequest, runtime: Util.RuntimeOptions): SubmitRecordingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.mergedRecording)) {
    query['MergedRecording'] = request.mergedRecording;
  }
  if (!Util.isUnset(request.resourceRecording)) {
    query['ResourceRecording'] = request.resourceRecording;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitRecording',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitRecording(request: SubmitRecordingRequest): SubmitRecordingResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitRecordingWithOptions(request, runtime);
}

model SubmitScriptReviewRequest {
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
}

model SubmitScriptReviewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubmitScriptReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitScriptReviewResponseBody(name='body'),
}

async function submitScriptReviewWithOptions(request: SubmitScriptReviewRequest, runtime: Util.RuntimeOptions): SubmitScriptReviewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitScriptReview',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitScriptReview(request: SubmitScriptReviewRequest): SubmitScriptReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitScriptReviewWithOptions(request, runtime);
}

model SuspendCallRequest {
  calledNumbers?: [ string ](name='CalledNumbers'),
  groupId?: string(name='GroupId'),
  instanceId?: string(name='InstanceId'),
}

model SuspendCallResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SuspendCallResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SuspendCallResponseBody(name='body'),
}

async function suspendCallWithOptions(request: SuspendCallRequest, runtime: Util.RuntimeOptions): SuspendCallResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.calledNumbers)) {
    query['CalledNumbers'] = request.calledNumbers;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SuspendCall',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function suspendCall(request: SuspendCallRequest): SuspendCallResponse {
  var runtime = new Util.RuntimeOptions{};
  return suspendCallWithOptions(request, runtime);
}

model SuspendCallWithFileRequest {
  filePath?: string(name='FilePath'),
  groupId?: string(name='GroupId'),
  instanceId?: string(name='InstanceId'),
}

model SuspendCallWithFileResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SuspendCallWithFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SuspendCallWithFileResponseBody(name='body'),
}

async function suspendCallWithFileWithOptions(request: SuspendCallWithFileRequest, runtime: Util.RuntimeOptions): SuspendCallWithFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filePath)) {
    query['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SuspendCallWithFile',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function suspendCallWithFile(request: SuspendCallWithFileRequest): SuspendCallWithFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return suspendCallWithFileWithOptions(request, runtime);
}

model SuspendJobsRequest {
  all?: boolean(name='All'),
  instanceId?: string(name='InstanceId'),
  jobGroupId?: string(name='JobGroupId'),
  jobId?: [ string ](name='JobId'),
  jobReferenceId?: [ string ](name='JobReferenceId'),
  scenarioId?: string(name='ScenarioId'),
}

model SuspendJobsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SuspendJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SuspendJobsResponseBody(name='body'),
}

async function suspendJobsWithOptions(request: SuspendJobsRequest, runtime: Util.RuntimeOptions): SuspendJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobGroupId)) {
    query['JobGroupId'] = request.jobGroupId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.jobReferenceId)) {
    query['JobReferenceId'] = request.jobReferenceId;
  }
  if (!Util.isUnset(request.scenarioId)) {
    query['ScenarioId'] = request.scenarioId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SuspendJobs',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function suspendJobs(request: SuspendJobsRequest): SuspendJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return suspendJobsWithOptions(request, runtime);
}

model TagResourcesRequest {
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model TaskPreparingRequest {
  instanceId?: string(name='InstanceId'),
  instanceOwnerId?: long(name='InstanceOwnerId'),
  jobId?: string(name='JobId'),
}

model TaskPreparingResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model TaskPreparingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TaskPreparingResponseBody(name='body'),
}

async function taskPreparingWithOptions(request: TaskPreparingRequest, runtime: Util.RuntimeOptions): TaskPreparingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceOwnerId)) {
    query['InstanceOwnerId'] = request.instanceOwnerId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TaskPreparing',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function taskPreparing(request: TaskPreparingRequest): TaskPreparingResponse {
  var runtime = new Util.RuntimeOptions{};
  return taskPreparingWithOptions(request, runtime);
}

model TerminateCallRequest {
  callId?: string(name='CallId'),
  instanceId?: string(name='InstanceId'),
}

model TerminateCallResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model TerminateCallResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TerminateCallResponseBody(name='body'),
}

async function terminateCallWithOptions(request: TerminateCallRequest, runtime: Util.RuntimeOptions): TerminateCallResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.callId)) {
    query['CallId'] = request.callId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TerminateCall',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function terminateCall(request: TerminateCallRequest): TerminateCallResponse {
  var runtime = new Util.RuntimeOptions{};
  return terminateCallWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model WithdrawScriptReviewRequest {
  instanceId?: string(name='InstanceId'),
  scriptId?: string(name='ScriptId'),
}

model WithdrawScriptReviewResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  script?: {
    debugStatus?: string(name='DebugStatus'),
    industry?: string(name='Industry'),
    isDebugDrafted?: boolean(name='IsDebugDrafted'),
    isDrafted?: boolean(name='IsDrafted'),
    scene?: string(name='Scene'),
    scriptDescription?: string(name='ScriptDescription'),
    scriptId?: string(name='ScriptId'),
    scriptName?: string(name='ScriptName'),
    status?: string(name='Status'),
    updateTime?: long(name='UpdateTime'),
  }(name='Script'),
  success?: boolean(name='Success'),
}

model WithdrawScriptReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: WithdrawScriptReviewResponseBody(name='body'),
}

async function withdrawScriptReviewWithOptions(request: WithdrawScriptReviewRequest, runtime: Util.RuntimeOptions): WithdrawScriptReviewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.scriptId)) {
    query['ScriptId'] = request.scriptId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'WithdrawScriptReview',
    version = '2019-12-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function withdrawScriptReview(request: WithdrawScriptReviewRequest): WithdrawScriptReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return withdrawScriptReviewWithOptions(request, runtime);
}

