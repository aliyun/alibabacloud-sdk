/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('oceanbasepro', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateDatabaseRequest {
  clientToken?: string(name='ClientToken'),
  collation?: string(name='Collation'),
  databaseName?: string(name='DatabaseName'),
  description?: string(name='Description'),
  encoding?: string(name='Encoding'),
  instanceId?: string(name='InstanceId'),
  tenantId?: string(name='TenantId'),
}

model CreateDatabaseResponseBody = {
  databaseName?: string(name='DatabaseName'),
  requestId?: string(name='RequestId'),
}

model CreateDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDatabaseResponseBody(name='body'),
}

async function createDatabaseWithOptions(request: CreateDatabaseRequest, runtime: Util.RuntimeOptions): CreateDatabaseResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.collation)) {
    body['Collation'] = request.collation;
  }
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.encoding)) {
    body['Encoding'] = request.encoding;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDatabase',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDatabase(request: CreateDatabaseRequest): CreateDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDatabaseWithOptions(request, runtime);
}

model CreateInstanceRequest {
  autoRenew?: boolean(name='AutoRenew'),
  autoRenewPeriod?: long(name='AutoRenewPeriod'),
  chargeType?: string(name='ChargeType'),
  diskSize?: long(name='DiskSize'),
  diskType?: string(name='DiskType'),
  instanceClass?: string(name='InstanceClass'),
  instanceName?: string(name='InstanceName'),
  obVersion?: string(name='ObVersion'),
  period?: long(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  resourceGroupId?: string(name='ResourceGroupId'),
  series?: string(name='Series'),
  zones?: string(name='Zones'),
}

model CreateInstanceResponseBody = {
  data?: {
    instanceId?: string(name='InstanceId'),
    orderId?: string(name='OrderId'),
    resourceGroupId?: string(name='ResourceGroupId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateInstanceResponseBody(name='body'),
}

async function createInstanceWithOptions(request: CreateInstanceRequest, runtime: Util.RuntimeOptions): CreateInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoRenew)) {
    body['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.autoRenewPeriod)) {
    body['AutoRenewPeriod'] = request.autoRenewPeriod;
  }
  if (!Util.isUnset(request.chargeType)) {
    body['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.diskSize)) {
    body['DiskSize'] = request.diskSize;
  }
  if (!Util.isUnset(request.diskType)) {
    body['DiskType'] = request.diskType;
  }
  if (!Util.isUnset(request.instanceClass)) {
    body['InstanceClass'] = request.instanceClass;
  }
  if (!Util.isUnset(request.instanceName)) {
    body['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.obVersion)) {
    body['ObVersion'] = request.obVersion;
  }
  if (!Util.isUnset(request.period)) {
    body['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    body['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.series)) {
    body['Series'] = request.series;
  }
  if (!Util.isUnset(request.zones)) {
    body['Zones'] = request.zones;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateInstance',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInstanceWithOptions(request, runtime);
}

model CreateOmsMysqlDataSourceRequest {
  description?: string(name='Description'),
  dgDatabaseId?: string(name='DgDatabaseId'),
  instanceId?: string(name='InstanceId'),
  ip?: string(name='Ip'),
  name?: string(name='Name'),
  password?: string(name='Password'),
  port?: string(name='Port'),
  schema?: string(name='Schema'),
  type?: string(name='Type'),
  username?: string(name='Username'),
  vpcId?: string(name='VpcId'),
}

model CreateOmsMysqlDataSourceResponseBody = {
  data?: {
    endpointId?: string(name='EndpointId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateOmsMysqlDataSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOmsMysqlDataSourceResponseBody(name='body'),
}

async function createOmsMysqlDataSourceWithOptions(request: CreateOmsMysqlDataSourceRequest, runtime: Util.RuntimeOptions): CreateOmsMysqlDataSourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.dgDatabaseId)) {
    body['DgDatabaseId'] = request.dgDatabaseId;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ip)) {
    body['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.port)) {
    body['Port'] = request.port;
  }
  if (!Util.isUnset(request.schema)) {
    body['Schema'] = request.schema;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  if (!Util.isUnset(request.username)) {
    body['Username'] = request.username;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOmsMysqlDataSource',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOmsMysqlDataSource(request: CreateOmsMysqlDataSourceRequest): CreateOmsMysqlDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOmsMysqlDataSourceWithOptions(request, runtime);
}

model CreateOmsOpenAPIProjectRequest {
  businessName?: string(name='BusinessName'),
  destConfig?: {
    enableMsgTrace?: boolean(name='EnableMsgTrace'),
    endpointId?: string(name='EndpointId'),
    endpointType?: string(name='EndpointType'),
    msgTags?: string(name='MsgTags'),
    partition?: int32(name='Partition'),
    partitionMode?: string(name='PartitionMode'),
    producerGroup?: string(name='ProducerGroup'),
    sendMsgTimeout?: long(name='SendMsgTimeout'),
    sequenceEnable?: boolean(name='SequenceEnable'),
    sequenceStartTimestamp?: long(name='SequenceStartTimestamp'),
    serializerType?: string(name='SerializerType'),
    topicType?: string(name='TopicType'),
  }(name='DestConfig'),
  labelIds?: [ string ](name='LabelIds'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectName?: string(name='ProjectName'),
  sourceConfig?: {
    enableMsgTrace?: boolean(name='EnableMsgTrace'),
    endpointId?: string(name='EndpointId'),
    endpointType?: string(name='EndpointType'),
    msgTags?: string(name='MsgTags'),
    partition?: int32(name='Partition'),
    partitionMode?: string(name='PartitionMode'),
    producerGroup?: string(name='ProducerGroup'),
    sendMsgTimeout?: long(name='SendMsgTimeout'),
    sequenceEnable?: boolean(name='SequenceEnable'),
    sequenceStartTimestamp?: long(name='SequenceStartTimestamp'),
    serializerType?: string(name='SerializerType'),
    topicType?: string(name='TopicType'),
  }(name='SourceConfig'),
  transferMapping?: {
    databases?: [ 
      {
        databaseId?: string(name='DatabaseId'),
        databaseName?: string(name='DatabaseName'),
        mappedName?: string(name='MappedName'),
        tables?: [ 
          {
            adbTableSchema?: {
              distributedKeys?: [ string ](name='DistributedKeys'),
              partitionLifeCycle?: int32(name='PartitionLifeCycle'),
              partitionStatement?: string(name='PartitionStatement'),
              primaryKeys?: [ string ](name='PrimaryKeys'),
            }(name='AdbTableSchema'),
            filterColumns?: [ string ](name='FilterColumns'),
            mappedName?: string(name='MappedName'),
            shardColumns?: [ string ](name='ShardColumns'),
            tableId?: string(name='TableId'),
            tableName?: string(name='TableName'),
            type?: string(name='Type'),
            whereClause?: string(name='WhereClause'),
          }
        ](name='Tables'),
        tenantName?: string(name='TenantName'),
        type?: string(name='Type'),
      }
    ](name='Databases'),
    mode?: string(name='Mode'),
  }(name='TransferMapping'),
  transferStepConfig?: {
    enableFullSync?: boolean(name='EnableFullSync'),
    enableIncrSync?: boolean(name='EnableIncrSync'),
    enableStructSync?: boolean(name='EnableStructSync'),
    incrSyncStepTransferConfig?: {
      recordTypeList?: [ string ](name='RecordTypeList'),
      startTimestamp?: long(name='StartTimestamp'),
      storeLogKeptHour?: long(name='StoreLogKeptHour'),
      storeTransactionEnabled?: boolean(name='StoreTransactionEnabled'),
      transferStepType?: string(name='TransferStepType'),
    }(name='IncrSyncStepTransferConfig'),
  }(name='TransferStepConfig'),
  workerGradeId?: string(name='WorkerGradeId'),
}

model CreateOmsOpenAPIProjectShrinkRequest {
  businessName?: string(name='BusinessName'),
  destConfigShrink?: string(name='DestConfig'),
  labelIdsShrink?: string(name='LabelIds'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectName?: string(name='ProjectName'),
  sourceConfigShrink?: string(name='SourceConfig'),
  transferMappingShrink?: string(name='TransferMapping'),
  transferStepConfigShrink?: string(name='TransferStepConfig'),
  workerGradeId?: string(name='WorkerGradeId'),
}

model CreateOmsOpenAPIProjectResponseBody = {
  advice?: string(name='Advice'),
  code?: string(name='Code'),
  cost?: string(name='Cost'),
  data?: string(name='Data'),
  errorDetail?: {
    code?: string(name='Code'),
    level?: string(name='Level'),
    message?: string(name='Message'),
    proposal?: string(name='Proposal'),
  }(name='ErrorDetail'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model CreateOmsOpenAPIProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOmsOpenAPIProjectResponseBody(name='body'),
}

async function createOmsOpenAPIProjectWithOptions(tmpReq: CreateOmsOpenAPIProjectRequest, runtime: Util.RuntimeOptions): CreateOmsOpenAPIProjectResponse {
  Util.validateModel(tmpReq);
  var request = new CreateOmsOpenAPIProjectShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.destConfig)) {
    request.destConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.destConfig, 'DestConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.labelIds)) {
    request.labelIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labelIds, 'LabelIds', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceConfig)) {
    request.sourceConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceConfig, 'SourceConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.transferMapping)) {
    request.transferMappingShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.transferMapping, 'TransferMapping', 'json');
  }
  if (!Util.isUnset(tmpReq.transferStepConfig)) {
    request.transferStepConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.transferStepConfig, 'TransferStepConfig', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.businessName)) {
    body['BusinessName'] = request.businessName;
  }
  if (!Util.isUnset(request.destConfigShrink)) {
    body['DestConfig'] = request.destConfigShrink;
  }
  if (!Util.isUnset(request.labelIdsShrink)) {
    body['LabelIds'] = request.labelIdsShrink;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.sourceConfigShrink)) {
    body['SourceConfig'] = request.sourceConfigShrink;
  }
  if (!Util.isUnset(request.transferMappingShrink)) {
    body['TransferMapping'] = request.transferMappingShrink;
  }
  if (!Util.isUnset(request.transferStepConfigShrink)) {
    body['TransferStepConfig'] = request.transferStepConfigShrink;
  }
  if (!Util.isUnset(request.workerGradeId)) {
    body['WorkerGradeId'] = request.workerGradeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOmsOpenAPIProject',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOmsOpenAPIProject(request: CreateOmsOpenAPIProjectRequest): CreateOmsOpenAPIProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOmsOpenAPIProjectWithOptions(request, runtime);
}

model CreateSecurityIpGroupRequest {
  instanceId?: string(name='InstanceId'),
  securityIpGroupName?: string(name='SecurityIpGroupName'),
  securityIps?: string(name='SecurityIps'),
}

model CreateSecurityIpGroupResponseBody = {
  requestId?: string(name='RequestId'),
  securityIpGroup?: {
    instanceId?: string(name='InstanceId'),
    securityIpGroupName?: string(name='SecurityIpGroupName'),
    securityIps?: string(name='SecurityIps'),
  }(name='SecurityIpGroup'),
}

model CreateSecurityIpGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSecurityIpGroupResponseBody(name='body'),
}

async function createSecurityIpGroupWithOptions(request: CreateSecurityIpGroupRequest, runtime: Util.RuntimeOptions): CreateSecurityIpGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.securityIpGroupName)) {
    body['SecurityIpGroupName'] = request.securityIpGroupName;
  }
  if (!Util.isUnset(request.securityIps)) {
    body['SecurityIps'] = request.securityIps;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSecurityIpGroup',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSecurityIpGroup(request: CreateSecurityIpGroupRequest): CreateSecurityIpGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSecurityIpGroupWithOptions(request, runtime);
}

model CreateTenantRequest {
  charset?: string(name='Charset'),
  cpu?: int32(name='Cpu'),
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  memory?: int32(name='Memory'),
  primaryZone?: string(name='PrimaryZone'),
  tenantMode?: string(name='TenantMode'),
  tenantName?: string(name='TenantName'),
  timeZone?: string(name='TimeZone'),
  unitNum?: int32(name='UnitNum'),
  userVSwitchId?: string(name='UserVSwitchId'),
  userVpcId?: string(name='UserVpcId'),
}

model CreateTenantResponseBody = {
  requestId?: string(name='RequestId'),
  tenantId?: string(name='TenantId'),
}

model CreateTenantResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTenantResponseBody(name='body'),
}

async function createTenantWithOptions(request: CreateTenantRequest, runtime: Util.RuntimeOptions): CreateTenantResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.charset)) {
    body['Charset'] = request.charset;
  }
  if (!Util.isUnset(request.cpu)) {
    body['Cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.memory)) {
    body['Memory'] = request.memory;
  }
  if (!Util.isUnset(request.primaryZone)) {
    body['PrimaryZone'] = request.primaryZone;
  }
  if (!Util.isUnset(request.tenantMode)) {
    body['TenantMode'] = request.tenantMode;
  }
  if (!Util.isUnset(request.tenantName)) {
    body['TenantName'] = request.tenantName;
  }
  if (!Util.isUnset(request.timeZone)) {
    body['TimeZone'] = request.timeZone;
  }
  if (!Util.isUnset(request.unitNum)) {
    body['UnitNum'] = request.unitNum;
  }
  if (!Util.isUnset(request.userVSwitchId)) {
    body['UserVSwitchId'] = request.userVSwitchId;
  }
  if (!Util.isUnset(request.userVpcId)) {
    body['UserVpcId'] = request.userVpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTenant',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTenant(request: CreateTenantRequest): CreateTenantResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTenantWithOptions(request, runtime);
}

model CreateTenantReadOnlyConnectionRequest {
  instanceId?: string(name='InstanceId'),
  tenantId?: string(name='TenantId'),
  zoneId?: string(name='ZoneId'),
}

model CreateTenantReadOnlyConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateTenantReadOnlyConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTenantReadOnlyConnectionResponseBody(name='body'),
}

async function createTenantReadOnlyConnectionWithOptions(request: CreateTenantReadOnlyConnectionRequest, runtime: Util.RuntimeOptions): CreateTenantReadOnlyConnectionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.zoneId)) {
    body['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTenantReadOnlyConnection',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTenantReadOnlyConnection(request: CreateTenantReadOnlyConnectionRequest): CreateTenantReadOnlyConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTenantReadOnlyConnectionWithOptions(request, runtime);
}

model CreateTenantUserRequest {
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  roles?: string(name='Roles'),
  tenantId?: string(name='TenantId'),
  userName?: string(name='UserName'),
  userPassword?: string(name='UserPassword'),
  userType?: string(name='UserType'),
}

model CreateTenantUserResponseBody = {
  requestId?: string(name='RequestId'),
  tenantUser?: [ 
    {
      roles?: [ 
        {
          database?: string(name='Database'),
          role?: string(name='Role'),
        }
      ](name='Roles'),
      userName?: string(name='UserName'),
      userStatus?: string(name='UserStatus'),
      userType?: string(name='UserType'),
    }
  ](name='TenantUser'),
}

model CreateTenantUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTenantUserResponseBody(name='body'),
}

async function createTenantUserWithOptions(request: CreateTenantUserRequest, runtime: Util.RuntimeOptions): CreateTenantUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.roles)) {
    body['Roles'] = request.roles;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.userPassword)) {
    body['UserPassword'] = request.userPassword;
  }
  if (!Util.isUnset(request.userType)) {
    body['UserType'] = request.userType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTenantUser',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTenantUser(request: CreateTenantUserRequest): CreateTenantUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTenantUserWithOptions(request, runtime);
}

model DeleteDatabasesRequest {
  databaseNames?: string(name='DatabaseNames'),
  instanceId?: string(name='InstanceId'),
  tenantId?: string(name='TenantId'),
}

model DeleteDatabasesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDatabasesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDatabasesResponseBody(name='body'),
}

async function deleteDatabasesWithOptions(request: DeleteDatabasesRequest, runtime: Util.RuntimeOptions): DeleteDatabasesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.databaseNames)) {
    body['DatabaseNames'] = request.databaseNames;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDatabases',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDatabases(request: DeleteDatabasesRequest): DeleteDatabasesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDatabasesWithOptions(request, runtime);
}

model DeleteInstancesRequest {
  backupRetainMode?: string(name='BackupRetainMode'),
  instanceIds?: string(name='InstanceIds'),
}

model DeleteInstancesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstancesResponseBody(name='body'),
}

async function deleteInstancesWithOptions(request: DeleteInstancesRequest, runtime: Util.RuntimeOptions): DeleteInstancesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.backupRetainMode)) {
    body['BackupRetainMode'] = request.backupRetainMode;
  }
  if (!Util.isUnset(request.instanceIds)) {
    body['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstances',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInstances(request: DeleteInstancesRequest): DeleteInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstancesWithOptions(request, runtime);
}

model DeleteOmsOpenAPIProjectRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  workerGradeId?: string(name='WorkerGradeId'),
}

model DeleteOmsOpenAPIProjectResponseBody = {
  advice?: string(name='Advice'),
  code?: string(name='Code'),
  cost?: string(name='Cost'),
  data?: boolean(name='Data'),
  errorDetail?: {
    code?: string(name='Code'),
    level?: string(name='Level'),
    message?: string(name='Message'),
    proposal?: string(name='Proposal'),
  }(name='ErrorDetail'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model DeleteOmsOpenAPIProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteOmsOpenAPIProjectResponseBody(name='body'),
}

async function deleteOmsOpenAPIProjectWithOptions(request: DeleteOmsOpenAPIProjectRequest, runtime: Util.RuntimeOptions): DeleteOmsOpenAPIProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.workerGradeId)) {
    body['WorkerGradeId'] = request.workerGradeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteOmsOpenAPIProject',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteOmsOpenAPIProject(request: DeleteOmsOpenAPIProjectRequest): DeleteOmsOpenAPIProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteOmsOpenAPIProjectWithOptions(request, runtime);
}

model DeleteSecurityIpGroupRequest {
  instanceId?: string(name='InstanceId'),
  securityIpGroupName?: string(name='SecurityIpGroupName'),
}

model DeleteSecurityIpGroupResponseBody = {
  requestId?: string(name='RequestId'),
  securityIpGroup?: {
    instanceId?: string(name='InstanceId'),
    securityIpGroupName?: string(name='SecurityIpGroupName'),
  }(name='SecurityIpGroup'),
}

model DeleteSecurityIpGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSecurityIpGroupResponseBody(name='body'),
}

async function deleteSecurityIpGroupWithOptions(request: DeleteSecurityIpGroupRequest, runtime: Util.RuntimeOptions): DeleteSecurityIpGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.securityIpGroupName)) {
    body['SecurityIpGroupName'] = request.securityIpGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSecurityIpGroup',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSecurityIpGroup(request: DeleteSecurityIpGroupRequest): DeleteSecurityIpGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecurityIpGroupWithOptions(request, runtime);
}

model DeleteTenantUsersRequest {
  instanceId?: string(name='InstanceId'),
  tenantId?: string(name='TenantId'),
  users?: string(name='Users'),
}

model DeleteTenantUsersResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTenantUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTenantUsersResponseBody(name='body'),
}

async function deleteTenantUsersWithOptions(request: DeleteTenantUsersRequest, runtime: Util.RuntimeOptions): DeleteTenantUsersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.users)) {
    body['Users'] = request.users;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTenantUsers',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTenantUsers(request: DeleteTenantUsersRequest): DeleteTenantUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTenantUsersWithOptions(request, runtime);
}

model DeleteTenantsRequest {
  instanceId?: string(name='InstanceId'),
  tenantIds?: string(name='TenantIds'),
}

model DeleteTenantsResponseBody = {
  requestId?: string(name='RequestId'),
  tenantIds?: [ string ](name='TenantIds'),
}

model DeleteTenantsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTenantsResponseBody(name='body'),
}

async function deleteTenantsWithOptions(request: DeleteTenantsRequest, runtime: Util.RuntimeOptions): DeleteTenantsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tenantIds)) {
    body['TenantIds'] = request.tenantIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTenants',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTenants(request: DeleteTenantsRequest): DeleteTenantsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTenantsWithOptions(request, runtime);
}

model DescribeAnomalySQLListRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  dbName?: string(name='DbName'),
  endTime?: string(name='EndTime'),
  filterCondition?: map[string]any(name='FilterCondition'),
  nodeIp?: string(name='NodeIp'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  SQLId?: string(name='SQLId'),
  searchKeyWord?: string(name='SearchKeyWord'),
  searchParameter?: string(name='SearchParameter'),
  searchRule?: string(name='SearchRule'),
  searchValue?: string(name='SearchValue'),
  sortColumn?: string(name='SortColumn'),
  sortOrder?: string(name='SortOrder'),
  startTime?: string(name='StartTime'),
  tenantId?: string(name='TenantId'),
}

model DescribeAnomalySQLListShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  dbName?: string(name='DbName'),
  endTime?: string(name='EndTime'),
  filterConditionShrink?: string(name='FilterCondition'),
  nodeIp?: string(name='NodeIp'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  SQLId?: string(name='SQLId'),
  searchKeyWord?: string(name='SearchKeyWord'),
  searchParameter?: string(name='SearchParameter'),
  searchRule?: string(name='SearchRule'),
  searchValue?: string(name='SearchValue'),
  sortColumn?: string(name='SortColumn'),
  sortOrder?: string(name='SortOrder'),
  startTime?: string(name='StartTime'),
  tenantId?: string(name='TenantId'),
}

model DescribeAnomalySQLListResponseBody = {
  anomalySQLList?: [ 
    {
      cpuTime?: float(name='CpuTime'),
      dbName?: string(name='DbName'),
      diagnosis?: string(name='Diagnosis'),
      diagnosisRule?: string(name='DiagnosisRule'),
      executions?: long(name='Executions'),
      key?: long(name='Key'),
      requestTime?: float(name='RequestTime'),
      requestTimeUTCString?: string(name='RequestTimeUTCString'),
      SQLId?: string(name='SQLId'),
      SQLText?: string(name='SQLText'),
      suggestion?: string(name='Suggestion'),
      userName?: string(name='UserName'),
    }
  ](name='AnomalySQLList'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeAnomalySQLListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAnomalySQLListResponseBody(name='body'),
}

async function describeAnomalySQLListWithOptions(tmpReq: DescribeAnomalySQLListRequest, runtime: Util.RuntimeOptions): DescribeAnomalySQLListResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeAnomalySQLListShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.filterCondition)) {
    request.filterConditionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterCondition, 'FilterCondition', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    body['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.dbName)) {
    body['DbName'] = request.dbName;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.filterConditionShrink)) {
    body['FilterCondition'] = request.filterConditionShrink;
  }
  if (!Util.isUnset(request.nodeIp)) {
    body['NodeIp'] = request.nodeIp;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.SQLId)) {
    body['SQLId'] = request.SQLId;
  }
  if (!Util.isUnset(request.searchKeyWord)) {
    body['SearchKeyWord'] = request.searchKeyWord;
  }
  if (!Util.isUnset(request.searchParameter)) {
    body['SearchParameter'] = request.searchParameter;
  }
  if (!Util.isUnset(request.searchRule)) {
    body['SearchRule'] = request.searchRule;
  }
  if (!Util.isUnset(request.searchValue)) {
    body['SearchValue'] = request.searchValue;
  }
  if (!Util.isUnset(request.sortColumn)) {
    body['SortColumn'] = request.sortColumn;
  }
  if (!Util.isUnset(request.sortOrder)) {
    body['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAnomalySQLList',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAnomalySQLList(request: DescribeAnomalySQLListRequest): DescribeAnomalySQLListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAnomalySQLListWithOptions(request, runtime);
}

model DescribeAvailableCpuResourceRequest {
  instanceId?: string(name='InstanceId'),
  modifyType?: string(name='ModifyType'),
  tenantId?: string(name='TenantId'),
}

model DescribeAvailableCpuResourceResponseBody = {
  data?: [ 
    {
      maxCpu?: long(name='MaxCpu'),
      minCpu?: long(name='MinCpu'),
      unitNum?: long(name='UnitNum'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableCpuResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAvailableCpuResourceResponseBody(name='body'),
}

async function describeAvailableCpuResourceWithOptions(request: DescribeAvailableCpuResourceRequest, runtime: Util.RuntimeOptions): DescribeAvailableCpuResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.modifyType)) {
    body['ModifyType'] = request.modifyType;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAvailableCpuResource',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAvailableCpuResource(request: DescribeAvailableCpuResourceRequest): DescribeAvailableCpuResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableCpuResourceWithOptions(request, runtime);
}

model DescribeAvailableMemResourceRequest {
  cpuNum?: long(name='CpuNum'),
  instanceId?: string(name='InstanceId'),
  tenantId?: string(name='TenantId'),
  unitNum?: long(name='UnitNum'),
}

model DescribeAvailableMemResourceResponseBody = {
  data?: {
    maxMem?: long(name='MaxMem'),
    minMem?: long(name='MinMem'),
    usedMem?: long(name='UsedMem'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableMemResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAvailableMemResourceResponseBody(name='body'),
}

async function describeAvailableMemResourceWithOptions(request: DescribeAvailableMemResourceRequest, runtime: Util.RuntimeOptions): DescribeAvailableMemResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.cpuNum)) {
    body['CpuNum'] = request.cpuNum;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.unitNum)) {
    body['UnitNum'] = request.unitNum;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAvailableMemResource',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAvailableMemResource(request: DescribeAvailableMemResourceRequest): DescribeAvailableMemResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableMemResourceWithOptions(request, runtime);
}

model DescribeCharsetRequest {
  tenantMode?: string(name='TenantMode'),
}

model DescribeCharsetResponseBody = {
  charset?: [ 
    {
      charset?: string(name='Charset'),
      collations?: [ string ](name='Collations'),
    }
  ](name='Charset'),
  requestId?: string(name='RequestId'),
}

model DescribeCharsetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCharsetResponseBody(name='body'),
}

async function describeCharsetWithOptions(request: DescribeCharsetRequest, runtime: Util.RuntimeOptions): DescribeCharsetResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.tenantMode)) {
    body['TenantMode'] = request.tenantMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCharset',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCharset(request: DescribeCharsetRequest): DescribeCharsetResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCharsetWithOptions(request, runtime);
}

model DescribeDatabasesRequest {
  databaseName?: string(name='DatabaseName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  searchKey?: string(name='SearchKey'),
  tenantId?: string(name='TenantId'),
  withTables?: boolean(name='WithTables'),
}

model DescribeDatabasesResponseBody = {
  databases?: [ 
    {
      collation?: string(name='Collation'),
      createTime?: string(name='CreateTime'),
      dataSize?: double(name='DataSize'),
      databaseName?: string(name='DatabaseName'),
      dbType?: string(name='DbType'),
      description?: string(name='Description'),
      encoding?: string(name='Encoding'),
      requiredSize?: double(name='RequiredSize'),
      status?: string(name='Status'),
      tables?: [ 
        {
          tableName?: string(name='TableName'),
        }
      ](name='Tables'),
      tenantId?: string(name='TenantId'),
      users?: [ 
        {
          role?: string(name='Role'),
          userName?: string(name='UserName'),
          userType?: string(name='UserType'),
        }
      ](name='Users'),
    }
  ](name='Databases'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDatabasesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDatabasesResponseBody(name='body'),
}

async function describeDatabasesWithOptions(request: DescribeDatabasesRequest, runtime: Util.RuntimeOptions): DescribeDatabasesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchKey)) {
    body['SearchKey'] = request.searchKey;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.withTables)) {
    body['WithTables'] = request.withTables;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDatabases',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDatabases(request: DescribeDatabasesRequest): DescribeDatabasesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDatabasesWithOptions(request, runtime);
}

model DescribeInstanceRequest {
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeInstanceResponseBody = {
  instance?: {
    autoRenewal?: boolean(name='AutoRenewal'),
    autoUpgradeObVersion?: boolean(name='AutoUpgradeObVersion'),
    availableZones?: [ string ](name='AvailableZones'),
    createTime?: string(name='CreateTime'),
    dataMergeTime?: string(name='DataMergeTime'),
    deployMode?: string(name='DeployMode'),
    deployType?: string(name='DeployType'),
    diskType?: string(name='DiskType'),
    enableUpgradeLogDisk?: boolean(name='EnableUpgradeLogDisk'),
    expireTime?: string(name='ExpireTime'),
    instanceClass?: string(name='InstanceClass'),
    instanceId?: string(name='InstanceId'),
    instanceName?: string(name='InstanceName'),
    isLatestObVersion?: boolean(name='IsLatestObVersion'),
    isTrustEcs?: boolean(name='IsTrustEcs'),
    maintainTime?: string(name='MaintainTime'),
    obRpmVersion?: string(name='ObRpmVersion'),
    payType?: string(name='PayType'),
    resource?: {
      cpu?: {
        totalCpu?: long(name='TotalCpu'),
        unitCpu?: long(name='UnitCpu'),
        usedCpu?: long(name='UsedCpu'),
      }(name='Cpu'),
      diskSize?: {
        dataUsedSize?: double(name='DataUsedSize'),
        maxDiskUsedObServer?: [ string ](name='MaxDiskUsedObServer'),
        maxDiskUsedPercent?: double(name='MaxDiskUsedPercent'),
        totalDiskSize?: long(name='TotalDiskSize'),
        unitDiskSize?: long(name='UnitDiskSize'),
        usedDiskSize?: long(name='UsedDiskSize'),
      }(name='DiskSize'),
      logDiskSize?: {
        totalDiskSize?: long(name='TotalDiskSize'),
        unitDiskSize?: long(name='UnitDiskSize'),
      }(name='LogDiskSize'),
      memory?: {
        totalMemory?: long(name='TotalMemory'),
        unitMemory?: long(name='UnitMemory'),
        usedMemory?: long(name='UsedMemory'),
      }(name='Memory'),
      unitCount?: long(name='UnitCount'),
    }(name='Resource'),
    series?: string(name='Series'),
    status?: string(name='Status'),
    version?: string(name='Version'),
  }(name='Instance'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceResponseBody(name='body'),
}

async function describeInstanceWithOptions(request: DescribeInstanceRequest, runtime: Util.RuntimeOptions): DescribeInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstance',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstance(request: DescribeInstanceRequest): DescribeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceWithOptions(request, runtime);
}

model DescribeInstanceCreatableZoneRequest {
  instanceId?: string(name='InstanceId'),
}

model DescribeInstanceCreatableZoneResponseBody = {
  requestId?: string(name='RequestId'),
  zoneList?: [ 
    {
      isInCluster?: boolean(name='IsInCluster'),
      zone?: string(name='Zone'),
    }
  ](name='ZoneList'),
}

model DescribeInstanceCreatableZoneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceCreatableZoneResponseBody(name='body'),
}

async function describeInstanceCreatableZoneWithOptions(request: DescribeInstanceCreatableZoneRequest, runtime: Util.RuntimeOptions): DescribeInstanceCreatableZoneResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceCreatableZone',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceCreatableZone(request: DescribeInstanceCreatableZoneRequest): DescribeInstanceCreatableZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceCreatableZoneWithOptions(request, runtime);
}

model DescribeInstanceTagsRequest {
  instanceIds?: string(name='InstanceIds'),
  tags?: string(name='Tags'),
}

model DescribeInstanceTagsResponseBody = {
  requestId?: string(name='RequestId'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tag?: string(name='Tag'),
    }
  ](name='TagResources'),
}

model DescribeInstanceTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceTagsResponseBody(name='body'),
}

async function describeInstanceTagsWithOptions(request: DescribeInstanceTagsRequest, runtime: Util.RuntimeOptions): DescribeInstanceTagsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceIds)) {
    body['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.tags)) {
    body['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceTags',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceTags(request: DescribeInstanceTagsRequest): DescribeInstanceTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceTagsWithOptions(request, runtime);
}

model DescribeInstanceTenantModesRequest {
  instanceId?: string(name='InstanceId'),
}

model DescribeInstanceTenantModesResponseBody = {
  instanceModes?: [ string ](name='InstanceModes'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceTenantModesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceTenantModesResponseBody(name='body'),
}

async function describeInstanceTenantModesWithOptions(request: DescribeInstanceTenantModesRequest, runtime: Util.RuntimeOptions): DescribeInstanceTenantModesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceTenantModes',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceTenantModes(request: DescribeInstanceTenantModesRequest): DescribeInstanceTenantModesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceTenantModesWithOptions(request, runtime);
}

model DescribeInstanceTopologyRequest {
  instanceId?: string(name='InstanceId'),
}

model DescribeInstanceTopologyResponseBody = {
  instanceTopology?: {
    tenants?: [ 
      {
        primaryZoneDeployType?: string(name='PrimaryZoneDeployType'),
        tenantCpu?: float(name='TenantCpu'),
        tenantDeployType?: string(name='TenantDeployType'),
        tenantId?: string(name='TenantId'),
        tenantMemory?: float(name='TenantMemory'),
        tenantMode?: string(name='TenantMode'),
        tenantName?: string(name='TenantName'),
        tenantStatus?: string(name='TenantStatus'),
        tenantUnitNum?: int32(name='TenantUnitNum'),
        tenantZones?: [ 
          {
            isPrimaryTenantZone?: string(name='IsPrimaryTenantZone'),
            tenantZoneId?: string(name='TenantZoneId'),
            tenantZoneRole?: string(name='TenantZoneRole'),
            units?: [ 
              {
                enableCancelMigrateUnit?: boolean(name='EnableCancelMigrateUnit'),
                enableMigrateUnit?: boolean(name='EnableMigrateUnit'),
                manualMigrate?: boolean(name='ManualMigrate'),
                nodeId?: string(name='NodeId'),
                unitCpu?: float(name='UnitCpu'),
                unitDataSize?: long(name='UnitDataSize'),
                unitId?: string(name='UnitId'),
                unitMemory?: float(name='UnitMemory'),
                unitStatus?: string(name='UnitStatus'),
              }
            ](name='Units'),
          }
        ](name='TenantZones'),
      }
    ](name='Tenants'),
    zones?: [ 
      {
        nodes?: [ 
          {
            nodeCopyId?: long(name='NodeCopyId'),
            nodeId?: string(name='NodeId'),
            nodeResource?: [ 
              {
                cpu?: {
                  totalCpu?: int32(name='TotalCpu'),
                  usedCpu?: float(name='UsedCpu'),
                }(name='Cpu'),
                diskSize?: {
                  totalDiskSize?: double(name='TotalDiskSize'),
                  usedDiskSize?: double(name='UsedDiskSize'),
                }(name='DiskSize'),
                memory?: {
                  totalMemory?: long(name='TotalMemory'),
                  usedMemory?: float(name='UsedMemory'),
                }(name='Memory'),
              }
            ](name='NodeResource'),
            nodeStatus?: string(name='NodeStatus'),
          }
        ](name='Nodes'),
        region?: string(name='Region'),
        zoneDisk?: string(name='ZoneDisk'),
        zoneId?: string(name='ZoneId'),
        zoneResource?: {
          diskSize?: {
            maxDiskUsedObServer?: [ string ](name='MaxDiskUsedObServer'),
            maxDiskUsedPercent?: double(name='MaxDiskUsedPercent'),
          }(name='DiskSize'),
        }(name='ZoneResource'),
      }
    ](name='Zones'),
  }(name='InstanceTopology'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceTopologyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceTopologyResponseBody(name='body'),
}

async function describeInstanceTopologyWithOptions(request: DescribeInstanceTopologyRequest, runtime: Util.RuntimeOptions): DescribeInstanceTopologyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceTopology',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceTopology(request: DescribeInstanceTopologyRequest): DescribeInstanceTopologyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceTopologyWithOptions(request, runtime);
}

model DescribeInstancesRequest {
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  searchKey?: string(name='SearchKey'),
}

model DescribeInstancesResponseBody = {
  instances?: [ 
    {
      availableZones?: [ string ](name='AvailableZones'),
      commodityCode?: string(name='CommodityCode'),
      cpu?: int32(name='Cpu'),
      createTime?: string(name='CreateTime'),
      deployMode?: string(name='DeployMode'),
      deployType?: string(name='DeployType'),
      diskSize?: string(name='DiskSize'),
      diskType?: string(name='DiskType'),
      enableUpgradeNodes?: boolean(name='EnableUpgradeNodes'),
      expireSeconds?: int32(name='ExpireSeconds'),
      expireTime?: string(name='ExpireTime'),
      instanceClass?: string(name='InstanceClass'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      instanceType?: string(name='InstanceType'),
      maintainTime?: string(name='MaintainTime'),
      mem?: long(name='Mem'),
      payType?: string(name='PayType'),
      resource?: {
        cpu?: {
          totalCpu?: long(name='TotalCpu'),
          unitCpu?: long(name='UnitCpu'),
          usedCpu?: long(name='UsedCpu'),
        }(name='Cpu'),
        diskSize?: {
          totalDiskSize?: long(name='TotalDiskSize'),
          unitDiskSize?: long(name='UnitDiskSize'),
          usedDiskSize?: long(name='UsedDiskSize'),
        }(name='DiskSize'),
        memory?: {
          totalMemory?: long(name='TotalMemory'),
          unitMemory?: long(name='UnitMemory'),
          usedMemory?: long(name='UsedMemory'),
        }(name='Memory'),
        unitCount?: long(name='UnitCount'),
      }(name='Resource'),
      resourceGroupId?: string(name='ResourceGroupId'),
      securityIps?: [ string ](name='SecurityIps'),
      series?: string(name='Series'),
      state?: string(name='State'),
      usedDiskSize?: long(name='UsedDiskSize'),
      version?: string(name='Version'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Instances'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstancesResponseBody(name='body'),
}

async function describeInstancesWithOptions(request: DescribeInstancesRequest, runtime: Util.RuntimeOptions): DescribeInstancesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    body['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.searchKey)) {
    body['SearchKey'] = request.searchKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstances',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstances(request: DescribeInstancesRequest): DescribeInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstancesWithOptions(request, runtime);
}

model DescribeNodeMetricsRequest {
  endTime?: string(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  metrics?: string(name='Metrics'),
  nodeIdList?: string(name='NodeIdList'),
  nodeName?: string(name='NodeName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTime?: string(name='StartTime'),
  tenantId?: string(name='TenantId'),
}

model DescribeNodeMetricsResponseBody = {
  nodeMetrics?: string(name='NodeMetrics'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeNodeMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNodeMetricsResponseBody(name='body'),
}

async function describeNodeMetricsWithOptions(request: DescribeNodeMetricsRequest, runtime: Util.RuntimeOptions): DescribeNodeMetricsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.metrics)) {
    body['Metrics'] = request.metrics;
  }
  if (!Util.isUnset(request.nodeIdList)) {
    body['NodeIdList'] = request.nodeIdList;
  }
  if (!Util.isUnset(request.nodeName)) {
    body['NodeName'] = request.nodeName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNodeMetrics',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNodeMetrics(request: DescribeNodeMetricsRequest): DescribeNodeMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNodeMetricsWithOptions(request, runtime);
}

model DescribeOmsOpenAPIProjectRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  workerGradeId?: string(name='WorkerGradeId'),
}

model DescribeOmsOpenAPIProjectResponseBody = {
  advice?: string(name='Advice'),
  code?: string(name='Code'),
  cost?: string(name='Cost'),
  data?: {
    businessName?: string(name='BusinessName'),
    destConfig?: {
      enableMsgTrace?: boolean(name='EnableMsgTrace'),
      endpointId?: string(name='EndpointId'),
      endpointType?: string(name='EndpointType'),
      msgTags?: string(name='MsgTags'),
      partition?: int32(name='Partition'),
      partitionMode?: string(name='PartitionMode'),
      producerGroup?: string(name='ProducerGroup'),
      sendMsgTimeout?: long(name='SendMsgTimeout'),
      sequenceEnable?: boolean(name='SequenceEnable'),
      sequenceStartTimestamp?: long(name='SequenceStartTimestamp'),
      serializerType?: string(name='SerializerType'),
      topicType?: string(name='TopicType'),
    }(name='DestConfig'),
    labels?: [ 
      {
        count?: int32(name='Count'),
        creator?: string(name='Creator'),
        id?: string(name='Id'),
        name?: string(name='Name'),
      }
    ](name='Labels'),
    projectId?: string(name='ProjectId'),
    projectName?: string(name='ProjectName'),
    projectOwner?: string(name='ProjectOwner'),
    sourceConfig?: {
      enableMsgTrace?: boolean(name='EnableMsgTrace'),
      endpointId?: string(name='EndpointId'),
      endpointType?: string(name='EndpointType'),
      msgTags?: string(name='MsgTags'),
      partition?: int32(name='Partition'),
      partitionMode?: string(name='PartitionMode'),
      producerGroup?: string(name='ProducerGroup'),
      sendMsgTimeout?: long(name='SendMsgTimeout'),
      sequenceEnable?: boolean(name='SequenceEnable'),
      sequenceStartTimestamp?: long(name='SequenceStartTimestamp'),
      serializerType?: string(name='SerializerType'),
      topicType?: string(name='TopicType'),
    }(name='SourceConfig'),
    steps?: [ 
      {
        estimatedRemainingSeconds?: long(name='EstimatedRemainingSeconds'),
        extraInfo?: {
          errorCode?: string(name='ErrorCode'),
          errorDetails?: [ 
            {
              code?: string(name='Code'),
              level?: string(name='Level'),
              message?: string(name='Message'),
              proposal?: string(name='Proposal'),
            }
          ](name='ErrorDetails'),
          errorMsg?: string(name='ErrorMsg'),
          errorParam?: map[string]string(name='ErrorParam'),
          failedTime?: string(name='FailedTime'),
        }(name='ExtraInfo'),
        finishTime?: string(name='FinishTime'),
        interactive?: boolean(name='Interactive'),
        startTime?: string(name='StartTime'),
        stepDescription?: string(name='StepDescription'),
        stepInfo?: {
          capacity?: long(name='Capacity'),
          checkpoint?: string(name='Checkpoint'),
          connectorFullProgressOverview?: {
            estimatedRemainingTimeOfSec?: long(name='EstimatedRemainingTimeOfSec'),
            estimatedTotalCount?: long(name='EstimatedTotalCount'),
            finishedCount?: long(name='FinishedCount'),
            progress?: int32(name='Progress'),
          }(name='ConnectorFullProgressOverview'),
          deployId?: string(name='DeployId'),
          dstIops?: long(name='DstIops'),
          dstRps?: long(name='DstRps'),
          dstRpsRef?: long(name='DstRpsRef'),
          dstRt?: long(name='DstRt'),
          dstRtRef?: long(name='DstRtRef'),
          gmt?: long(name='Gmt'),
          inconsistencies?: long(name='Inconsistencies'),
          incrTimestampCheckpoint?: long(name='IncrTimestampCheckpoint'),
          jobId?: string(name='JobId'),
          processedRecords?: long(name='ProcessedRecords'),
          skipped?: boolean(name='Skipped'),
          srcIops?: long(name='SrcIops'),
          srcIopsRef?: long(name='SrcIopsRef'),
          srcRps?: long(name='SrcRps'),
          srcRpsRef?: long(name='SrcRpsRef'),
          srcRt?: long(name='SrcRt'),
          srcRtRef?: long(name='SrcRtRef'),
          validated?: boolean(name='Validated'),
        }(name='StepInfo'),
        stepName?: string(name='StepName'),
        stepOrder?: int32(name='StepOrder'),
        stepProgress?: int32(name='StepProgress'),
        stepStatus?: string(name='StepStatus'),
      }
    ](name='Steps'),
    transferMapping?: {
      databases?: [ 
        {
          databaseId?: string(name='DatabaseId'),
          databaseName?: string(name='DatabaseName'),
          mappedName?: string(name='MappedName'),
          tables?: [ 
            {
              adbTableSchema?: {
                distributedKeys?: [ string ](name='DistributedKeys'),
                partitionLifeCycle?: int32(name='PartitionLifeCycle'),
                partitionStatement?: string(name='PartitionStatement'),
                primaryKeys?: [ string ](name='PrimaryKeys'),
              }(name='AdbTableSchema'),
              filterColumns?: [ string ](name='FilterColumns'),
              mappedName?: string(name='MappedName'),
              shardColumns?: [ string ](name='ShardColumns'),
              tableId?: string(name='TableId'),
              tableName?: string(name='TableName'),
              type?: string(name='Type'),
              whereClause?: string(name='WhereClause'),
            }
          ](name='Tables'),
          tenantName?: string(name='TenantName'),
          type?: string(name='Type'),
        }
      ](name='Databases'),
      mode?: string(name='Mode'),
    }(name='TransferMapping'),
    transferStepConfig?: {
      enableFullSync?: boolean(name='EnableFullSync'),
      enableIncrSync?: boolean(name='EnableIncrSync'),
      enableStructSync?: boolean(name='EnableStructSync'),
      incrSyncStepTransferConfig?: {
        recordTypeList?: [ string ](name='RecordTypeList'),
        startTimestamp?: long(name='StartTimestamp'),
        storeLogKeptHour?: long(name='StoreLogKeptHour'),
        storeTransactionEnabled?: boolean(name='StoreTransactionEnabled'),
        transferStepType?: string(name='TransferStepType'),
      }(name='IncrSyncStepTransferConfig'),
    }(name='TransferStepConfig'),
  }(name='Data'),
  errorDetail?: {
    code?: string(name='Code'),
    level?: string(name='Level'),
    message?: string(name='Message'),
    proposal?: string(name='Proposal'),
  }(name='ErrorDetail'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model DescribeOmsOpenAPIProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeOmsOpenAPIProjectResponseBody(name='body'),
}

async function describeOmsOpenAPIProjectWithOptions(request: DescribeOmsOpenAPIProjectRequest, runtime: Util.RuntimeOptions): DescribeOmsOpenAPIProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.workerGradeId)) {
    body['WorkerGradeId'] = request.workerGradeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOmsOpenAPIProject',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeOmsOpenAPIProject(request: DescribeOmsOpenAPIProjectRequest): DescribeOmsOpenAPIProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOmsOpenAPIProjectWithOptions(request, runtime);
}

model DescribeOmsOpenAPIProjectStepsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  workerGradeId?: string(name='WorkerGradeId'),
}

model DescribeOmsOpenAPIProjectStepsResponseBody = {
  advice?: string(name='Advice'),
  code?: string(name='Code'),
  cost?: string(name='Cost'),
  data?: [ 
    {
      estimatedRemainingSeconds?: long(name='EstimatedRemainingSeconds'),
      extraInfo?: {
        errorCode?: string(name='ErrorCode'),
        errorDetails?: [ 
          {
            code?: string(name='Code'),
            level?: string(name='Level'),
            message?: string(name='Message'),
            proposal?: string(name='Proposal'),
          }
        ](name='ErrorDetails'),
        errorMsg?: string(name='ErrorMsg'),
        errorParam?: map[string]string(name='ErrorParam'),
        failedTime?: string(name='FailedTime'),
      }(name='ExtraInfo'),
      finishTime?: string(name='FinishTime'),
      interactive?: boolean(name='Interactive'),
      startTime?: string(name='StartTime'),
      stepDescription?: string(name='StepDescription'),
      stepInfo?: {
        capacity?: long(name='Capacity'),
        checkpoint?: string(name='Checkpoint'),
        connectorFullProgressOverview?: {
          estimatedRemainingTimeOfSec?: long(name='EstimatedRemainingTimeOfSec'),
          estimatedTotalCount?: long(name='EstimatedTotalCount'),
          finishedCount?: long(name='FinishedCount'),
          progress?: int32(name='Progress'),
        }(name='ConnectorFullProgressOverview'),
        deployId?: string(name='DeployId'),
        dstIops?: long(name='DstIops'),
        dstRps?: long(name='DstRps'),
        dstRpsRef?: long(name='DstRpsRef'),
        dstRt?: long(name='DstRt'),
        dstRtRef?: long(name='DstRtRef'),
        gmt?: long(name='Gmt'),
        inconsistencies?: long(name='Inconsistencies'),
        incrTimestampCheckpoint?: long(name='IncrTimestampCheckpoint'),
        jobId?: string(name='JobId'),
        processedRecords?: long(name='ProcessedRecords'),
        skipped?: boolean(name='Skipped'),
        srcIops?: long(name='SrcIops'),
        srcIopsRef?: long(name='SrcIopsRef'),
        srcRps?: long(name='SrcRps'),
        srcRpsRef?: long(name='SrcRpsRef'),
        srcRt?: long(name='SrcRt'),
        srcRtRef?: long(name='SrcRtRef'),
        validated?: boolean(name='Validated'),
      }(name='StepInfo'),
      stepName?: string(name='StepName'),
      stepOrder?: int32(name='StepOrder'),
      stepProgress?: int32(name='StepProgress'),
      stepStatus?: string(name='StepStatus'),
    }
  ](name='Data'),
  errorDetail?: {
    code?: string(name='Code'),
    level?: string(name='Level'),
    message?: string(name='Message'),
    proposal?: string(name='Proposal'),
  }(name='ErrorDetail'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model DescribeOmsOpenAPIProjectStepsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeOmsOpenAPIProjectStepsResponseBody(name='body'),
}

async function describeOmsOpenAPIProjectStepsWithOptions(request: DescribeOmsOpenAPIProjectStepsRequest, runtime: Util.RuntimeOptions): DescribeOmsOpenAPIProjectStepsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.workerGradeId)) {
    body['WorkerGradeId'] = request.workerGradeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOmsOpenAPIProjectSteps',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeOmsOpenAPIProjectSteps(request: DescribeOmsOpenAPIProjectStepsRequest): DescribeOmsOpenAPIProjectStepsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOmsOpenAPIProjectStepsWithOptions(request, runtime);
}

model DescribeOutlineBindingRequest {
  databaseName?: string(name='DatabaseName'),
  instanceId?: string(name='InstanceId'),
  isConcurrentLimit?: boolean(name='IsConcurrentLimit'),
  SQLId?: string(name='SQLId'),
  tableName?: string(name='TableName'),
  tenantId?: string(name='TenantId'),
}

model DescribeOutlineBindingResponseBody = {
  outlineBinding?: {
    bindIndex?: string(name='BindIndex'),
    bindPlan?: string(name='BindPlan'),
    maxConcurrent?: int32(name='MaxConcurrent'),
    outlineId?: long(name='OutlineId'),
  }(name='OutlineBinding'),
  requestId?: string(name='RequestId'),
}

model DescribeOutlineBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeOutlineBindingResponseBody(name='body'),
}

async function describeOutlineBindingWithOptions(request: DescribeOutlineBindingRequest, runtime: Util.RuntimeOptions): DescribeOutlineBindingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.isConcurrentLimit)) {
    body['IsConcurrentLimit'] = request.isConcurrentLimit;
  }
  if (!Util.isUnset(request.SQLId)) {
    body['SQLId'] = request.SQLId;
  }
  if (!Util.isUnset(request.tableName)) {
    body['TableName'] = request.tableName;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOutlineBinding',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeOutlineBinding(request: DescribeOutlineBindingRequest): DescribeOutlineBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOutlineBindingWithOptions(request, runtime);
}

model DescribeParametersRequest {
  dimension?: string(name='Dimension'),
  dimensionValue?: string(name='DimensionValue'),
  instanceId?: string(name='InstanceId'),
}

model DescribeParametersResponseBody = {
  parameters?: [ 
    {
      acceptableValue?: [ string ](name='AcceptableValue'),
      currentValue?: string(name='CurrentValue'),
      defaultValue?: string(name='DefaultValue'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      needReboot?: boolean(name='NeedReboot'),
      rejectedValue?: [ string ](name='RejectedValue'),
      valueType?: string(name='ValueType'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
}

model DescribeParametersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeParametersResponseBody(name='body'),
}

async function describeParametersWithOptions(request: DescribeParametersRequest, runtime: Util.RuntimeOptions): DescribeParametersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dimension)) {
    body['Dimension'] = request.dimension;
  }
  if (!Util.isUnset(request.dimensionValue)) {
    body['DimensionValue'] = request.dimensionValue;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeParameters',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeParameters(request: DescribeParametersRequest): DescribeParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParametersWithOptions(request, runtime);
}

model DescribeParametersHistoryRequest {
  dimension?: string(name='Dimension'),
  dimensionValue?: string(name='DimensionValue'),
  endTime?: string(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTime?: string(name='StartTime'),
}

model DescribeParametersHistoryResponseBody = {
  requestId?: string(name='RequestId'),
  respond?: [ 
    {
      pageNumber?: int32(name='PageNumber'),
      parameters?: [ 
        {
          createTime?: string(name='CreateTime'),
          dimensionValue?: string(name='DimensionValue'),
          name?: string(name='Name'),
          newValue?: string(name='NewValue'),
          oldValue?: string(name='OldValue'),
          status?: string(name='Status'),
          updateTime?: string(name='UpdateTime'),
        }
      ](name='Parameters'),
      totalCount?: int32(name='TotalCount'),
    }
  ](name='Respond'),
}

model DescribeParametersHistoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeParametersHistoryResponseBody(name='body'),
}

async function describeParametersHistoryWithOptions(request: DescribeParametersHistoryRequest, runtime: Util.RuntimeOptions): DescribeParametersHistoryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dimension)) {
    body['Dimension'] = request.dimension;
  }
  if (!Util.isUnset(request.dimensionValue)) {
    body['DimensionValue'] = request.dimensionValue;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeParametersHistory',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeParametersHistory(request: DescribeParametersHistoryRequest): DescribeParametersHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParametersHistoryWithOptions(request, runtime);
}

model DescribeRecommendIndexRequest {
  instanceId?: string(name='InstanceId'),
  SQLId?: string(name='SQLId'),
  tenantId?: string(name='TenantId'),
}

model DescribeRecommendIndexResponseBody = {
  recommendIndex?: {
    suggestIndex?: string(name='SuggestIndex'),
    tableList?: string(name='TableList'),
    tenantMode?: string(name='TenantMode'),
  }(name='RecommendIndex'),
  requestId?: string(name='RequestId'),
}

model DescribeRecommendIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRecommendIndexResponseBody(name='body'),
}

async function describeRecommendIndexWithOptions(request: DescribeRecommendIndexRequest, runtime: Util.RuntimeOptions): DescribeRecommendIndexResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.SQLId)) {
    body['SQLId'] = request.SQLId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRecommendIndex',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRecommendIndex(request: DescribeRecommendIndexRequest): DescribeRecommendIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecommendIndexWithOptions(request, runtime);
}

model DescribeSQLDetailsRequest {
  SQLId?: string(name='SQLId'),
  tenantId?: string(name='TenantId'),
}

model DescribeSQLDetailsResponseBody = {
  requestId?: string(name='RequestId'),
  SQLDetails?: [ 
    {
      dbName?: string(name='DbName'),
      SQLText?: string(name='SQLText'),
      userName?: string(name='UserName'),
    }
  ](name='SQLDetails'),
}

model DescribeSQLDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSQLDetailsResponseBody(name='body'),
}

async function describeSQLDetailsWithOptions(request: DescribeSQLDetailsRequest, runtime: Util.RuntimeOptions): DescribeSQLDetailsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.SQLId)) {
    body['SQLId'] = request.SQLId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSQLDetails',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSQLDetails(request: DescribeSQLDetailsRequest): DescribeSQLDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSQLDetailsWithOptions(request, runtime);
}

model DescribeSQLHistoryListRequest {
  endTime?: string(name='EndTime'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  SQLId?: string(name='SQLId'),
  startTime?: string(name='StartTime'),
  tenantId?: string(name='TenantId'),
}

model DescribeSQLHistoryListResponseBody = {
  requestId?: string(name='RequestId'),
  SQLHistoryList?: {
    count?: long(name='Count'),
    list?: [ 
      {
        affectedRows?: long(name='AffectedRows'),
        appWaitTime?: float(name='AppWaitTime'),
        blockCacheHit?: long(name='BlockCacheHit'),
        blockIndexCacheHit?: long(name='BlockIndexCacheHit'),
        bloomFilterCacheHit?: long(name='BloomFilterCacheHit'),
        clientIp?: string(name='ClientIp'),
        concurrencyWaitTime?: float(name='ConcurrencyWaitTime'),
        cpuTime?: float(name='CpuTime'),
        dbName?: string(name='DbName'),
        decodeTime?: float(name='DecodeTime'),
        diskRead?: long(name='DiskRead'),
        elapsedTime?: float(name='ElapsedTime'),
        endTime?: long(name='EndTime'),
        endTimeUTCString?: string(name='EndTimeUTCString'),
        event?: string(name='Event'),
        execPerSecond?: long(name='ExecPerSecond'),
        executeTime?: float(name='ExecuteTime'),
        executions?: long(name='Executions'),
        failTimes?: long(name='FailTimes'),
        getPlanTime?: float(name='GetPlanTime'),
        IOWaitTime?: float(name='IOWaitTime'),
        logicalRead?: long(name='LogicalRead'),
        maxCpuTime?: float(name='MaxCpuTime'),
        maxElapsedTime?: float(name='MaxElapsedTime'),
        memstoreReadRowCount?: long(name='MemstoreReadRowCount'),
        missPlans?: long(name='MissPlans'),
        netWaitTime?: float(name='NetWaitTime'),
        nodeIp?: string(name='NodeIp'),
        queueTime?: float(name='QueueTime'),
        RPCCount?: long(name='RPCCount'),
        remotePlans?: long(name='RemotePlans'),
        retryCount?: long(name='RetryCount'),
        returnRows?: long(name='ReturnRows'),
        rowCacheHit?: long(name='RowCacheHit'),
        scheduleTime?: float(name='ScheduleTime'),
        ssstoreReadRowCount?: long(name='SsstoreReadRowCount'),
        totalWaitTime?: float(name='TotalWaitTime'),
        userName?: string(name='UserName'),
      }
    ](name='List'),
  }(name='SQLHistoryList'),
}

model DescribeSQLHistoryListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSQLHistoryListResponseBody(name='body'),
}

async function describeSQLHistoryListWithOptions(request: DescribeSQLHistoryListRequest, runtime: Util.RuntimeOptions): DescribeSQLHistoryListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.SQLId)) {
    body['SQLId'] = request.SQLId;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSQLHistoryList',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSQLHistoryList(request: DescribeSQLHistoryListRequest): DescribeSQLHistoryListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSQLHistoryListWithOptions(request, runtime);
}

model DescribeSQLPlansRequest {
  SQLId?: string(name='SQLId'),
  tenantId?: string(name='TenantId'),
}

model DescribeSQLPlansResponseBody = {
  requestId?: string(name='RequestId'),
  SQLPlans?: [ 
    {
      avgExecutionMS?: float(name='AvgExecutionMS'),
      avgExecutionTimeMS?: long(name='AvgExecutionTimeMS'),
      firstLoadTime?: long(name='FirstLoadTime'),
      firstLoadTimeUTCString?: string(name='FirstLoadTimeUTCString'),
      hitCount?: int32(name='HitCount'),
      mergedVersion?: int32(name='MergedVersion'),
      nodeIp?: string(name='NodeIp'),
      outlineData?: string(name='OutlineData'),
      outlineId?: long(name='OutlineId'),
      outlineTime?: long(name='OutlineTime'),
      outlineTimeUTCString?: string(name='OutlineTimeUTCString'),
      planFull?: string(name='PlanFull'),
      planId?: int32(name='PlanId'),
      planInfo?: string(name='PlanInfo'),
      planUnionHash?: string(name='PlanUnionHash'),
      querySQL?: string(name='QuerySQL'),
    }
  ](name='SQLPlans'),
}

model DescribeSQLPlansResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSQLPlansResponseBody(name='body'),
}

async function describeSQLPlansWithOptions(request: DescribeSQLPlansRequest, runtime: Util.RuntimeOptions): DescribeSQLPlansResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.SQLId)) {
    body['SQLId'] = request.SQLId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSQLPlans',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSQLPlans(request: DescribeSQLPlansRequest): DescribeSQLPlansResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSQLPlansWithOptions(request, runtime);
}

model DescribeSecurityIpGroupsRequest {
  instanceId?: string(name='InstanceId'),
}

model DescribeSecurityIpGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  securityIpGroups?: [ 
    {
      securityIpGroupName?: string(name='SecurityIpGroupName'),
      securityIps?: string(name='SecurityIps'),
    }
  ](name='SecurityIpGroups'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSecurityIpGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSecurityIpGroupsResponseBody(name='body'),
}

async function describeSecurityIpGroupsWithOptions(request: DescribeSecurityIpGroupsRequest, runtime: Util.RuntimeOptions): DescribeSecurityIpGroupsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityIpGroups',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSecurityIpGroups(request: DescribeSecurityIpGroupsRequest): DescribeSecurityIpGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityIpGroupsWithOptions(request, runtime);
}

model DescribeSlowSQLHistoryListRequest {
  endTime?: string(name='EndTime'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  SQLId?: string(name='SQLId'),
  startTime?: string(name='StartTime'),
  tenantId?: string(name='TenantId'),
}

model DescribeSlowSQLHistoryListResponseBody = {
  requestId?: string(name='RequestId'),
  slowSQLHistoryList?: {
    count?: long(name='Count'),
    list?: [ 
      {
        affectedRows?: double(name='AffectedRows'),
        appWaitTime?: double(name='AppWaitTime'),
        blockCacheHit?: double(name='BlockCacheHit'),
        blockIndexCacheHit?: double(name='BlockIndexCacheHit'),
        bloomFilterCacheHit?: double(name='BloomFilterCacheHit'),
        clientIp?: string(name='ClientIp'),
        concurrencyWaitTime?: double(name='ConcurrencyWaitTime'),
        cpuTime?: double(name='CpuTime'),
        dbName?: string(name='DbName'),
        decodeTime?: double(name='DecodeTime'),
        diskRead?: double(name='DiskRead'),
        elapsedTime?: double(name='ElapsedTime'),
        endTimeUTCString?: string(name='EndTimeUTCString'),
        event?: string(name='Event'),
        execPerSecond?: double(name='ExecPerSecond'),
        executeTime?: double(name='ExecuteTime'),
        executions?: double(name='Executions'),
        failTimes?: double(name='FailTimes'),
        getPlanTime?: double(name='GetPlanTime'),
        IOWaitTime?: double(name='IOWaitTime'),
        logicalRead?: double(name='LogicalRead'),
        maxCpuTime?: double(name='MaxCpuTime'),
        maxElapsedTime?: double(name='MaxElapsedTime'),
        memstoreReadRowCount?: double(name='MemstoreReadRowCount'),
        missPlans?: double(name='MissPlans'),
        netWaitTime?: double(name='NetWaitTime'),
        nodeIp?: string(name='NodeIp'),
        queueTime?: double(name='QueueTime'),
        RPCCount?: double(name='RPCCount'),
        remotePlans?: double(name='RemotePlans'),
        retryCount?: double(name='RetryCount'),
        returnRows?: double(name='ReturnRows'),
        rowCacheHit?: double(name='RowCacheHit'),
        scheduleTime?: double(name='ScheduleTime'),
        sqlId?: string(name='SqlId'),
        sqlType?: string(name='SqlType'),
        ssstoreReadRowCount?: double(name='SsstoreReadRowCount'),
        tenantName?: string(name='TenantName'),
        totalWaitTime?: double(name='TotalWaitTime'),
        userName?: string(name='UserName'),
      }
    ](name='List'),
  }(name='SlowSQLHistoryList'),
}

model DescribeSlowSQLHistoryListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSlowSQLHistoryListResponseBody(name='body'),
}

async function describeSlowSQLHistoryListWithOptions(request: DescribeSlowSQLHistoryListRequest, runtime: Util.RuntimeOptions): DescribeSlowSQLHistoryListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.SQLId)) {
    body['SQLId'] = request.SQLId;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSlowSQLHistoryList',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSlowSQLHistoryList(request: DescribeSlowSQLHistoryListRequest): DescribeSlowSQLHistoryListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSlowSQLHistoryListWithOptions(request, runtime);
}

model DescribeSlowSQLListRequest {
  dbName?: string(name='DbName'),
  endTime?: string(name='EndTime'),
  filterCondition?: map[string]any(name='FilterCondition'),
  nodeIp?: string(name='NodeIp'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  SQLId?: string(name='SQLId'),
  searchKeyWord?: string(name='SearchKeyWord'),
  searchParameter?: string(name='SearchParameter'),
  searchRule?: string(name='SearchRule'),
  searchValue?: string(name='SearchValue'),
  sortColumn?: string(name='SortColumn'),
  sortOrder?: string(name='SortOrder'),
  startTime?: string(name='StartTime'),
  tenantId?: string(name='TenantId'),
}

model DescribeSlowSQLListShrinkRequest {
  dbName?: string(name='DbName'),
  endTime?: string(name='EndTime'),
  filterConditionShrink?: string(name='FilterCondition'),
  nodeIp?: string(name='NodeIp'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  SQLId?: string(name='SQLId'),
  searchKeyWord?: string(name='SearchKeyWord'),
  searchParameter?: string(name='SearchParameter'),
  searchRule?: string(name='SearchRule'),
  searchValue?: string(name='SearchValue'),
  sortColumn?: string(name='SortColumn'),
  sortOrder?: string(name='SortOrder'),
  startTime?: string(name='StartTime'),
  tenantId?: string(name='TenantId'),
}

model DescribeSlowSQLListResponseBody = {
  requestId?: string(name='RequestId'),
  slowSQLList?: [ 
    {
      affectedRows?: long(name='AffectedRows'),
      appWaitTime?: float(name='AppWaitTime'),
      blockCacheHit?: long(name='BlockCacheHit'),
      blockIndexCacheHit?: long(name='BlockIndexCacheHit'),
      bloomFilterCacheHit?: long(name='BloomFilterCacheHit'),
      clientIp?: string(name='ClientIp'),
      concurrencyWaitTime?: float(name='ConcurrencyWaitTime'),
      cpuTime?: float(name='CpuTime'),
      dbName?: string(name='DbName'),
      decodeTime?: float(name='DecodeTime'),
      diskRead?: long(name='DiskRead'),
      elapsedTime?: float(name='ElapsedTime'),
      event?: string(name='Event'),
      execPerSecond?: float(name='ExecPerSecond'),
      executeTime?: float(name='ExecuteTime'),
      executions?: long(name='Executions'),
      failTimes?: long(name='FailTimes'),
      getPlanTime?: float(name='GetPlanTime'),
      IOWaitTime?: float(name='IOWaitTime'),
      key?: long(name='Key'),
      logicalRead?: long(name='LogicalRead'),
      maxCpuTime?: float(name='MaxCpuTime'),
      maxElapsedTime?: float(name='MaxElapsedTime'),
      memstoreReadRowCount?: long(name='MemstoreReadRowCount'),
      missPlans?: long(name='MissPlans'),
      netWaitTime?: float(name='NetWaitTime'),
      nodeIp?: string(name='NodeIp'),
      queueTime?: float(name='QueueTime'),
      RPCCount?: long(name='RPCCount'),
      remotePlans?: long(name='RemotePlans'),
      retryCount?: long(name='RetryCount'),
      returnRows?: long(name='ReturnRows'),
      rowCacheHit?: long(name='RowCacheHit'),
      SQLId?: string(name='SQLId'),
      SQLText?: string(name='SQLText'),
      SQLType?: long(name='SQLType'),
      scheduleTime?: float(name='ScheduleTime'),
      ssstoreReadRowCount?: long(name='SsstoreReadRowCount'),
      totalWaitTime?: float(name='TotalWaitTime'),
      userName?: string(name='UserName'),
    }
  ](name='SlowSQLList'),
  totalCount?: long(name='TotalCount'),
}

model DescribeSlowSQLListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSlowSQLListResponseBody(name='body'),
}

async function describeSlowSQLListWithOptions(tmpReq: DescribeSlowSQLListRequest, runtime: Util.RuntimeOptions): DescribeSlowSQLListResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeSlowSQLListShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.filterCondition)) {
    request.filterConditionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterCondition, 'FilterCondition', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.dbName)) {
    body['DbName'] = request.dbName;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.filterConditionShrink)) {
    body['FilterCondition'] = request.filterConditionShrink;
  }
  if (!Util.isUnset(request.nodeIp)) {
    body['NodeIp'] = request.nodeIp;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.SQLId)) {
    body['SQLId'] = request.SQLId;
  }
  if (!Util.isUnset(request.searchKeyWord)) {
    body['SearchKeyWord'] = request.searchKeyWord;
  }
  if (!Util.isUnset(request.searchParameter)) {
    body['SearchParameter'] = request.searchParameter;
  }
  if (!Util.isUnset(request.searchRule)) {
    body['SearchRule'] = request.searchRule;
  }
  if (!Util.isUnset(request.searchValue)) {
    body['SearchValue'] = request.searchValue;
  }
  if (!Util.isUnset(request.sortColumn)) {
    body['SortColumn'] = request.sortColumn;
  }
  if (!Util.isUnset(request.sortOrder)) {
    body['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSlowSQLList',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSlowSQLList(request: DescribeSlowSQLListRequest): DescribeSlowSQLListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSlowSQLListWithOptions(request, runtime);
}

model DescribeTenantRequest {
  instanceId?: string(name='InstanceId'),
  tenantId?: string(name='TenantId'),
}

model DescribeTenantResponseBody = {
  requestId?: string(name='RequestId'),
  tenant?: {
    availableZones?: [ string ](name='AvailableZones'),
    charset?: string(name='Charset'),
    clogServiceStatus?: string(name='ClogServiceStatus'),
    collation?: string(name='Collation'),
    createTime?: string(name='CreateTime'),
    deployMode?: string(name='DeployMode'),
    deployType?: string(name='DeployType'),
    description?: string(name='Description'),
    diskType?: string(name='DiskType'),
    enableClogService?: boolean(name='EnableClogService'),
    enableInternetAddressService?: boolean(name='EnableInternetAddressService'),
    enableReadWriteSplit?: boolean(name='EnableReadWriteSplit'),
    instanceType?: string(name='InstanceType'),
    masterIntranetAddressZone?: string(name='MasterIntranetAddressZone'),
    payType?: string(name='PayType'),
    primaryZone?: string(name='PrimaryZone'),
    primaryZoneDeployType?: string(name='PrimaryZoneDeployType'),
    series?: string(name='Series'),
    status?: string(name='Status'),
    tenantConnections?: [ 
      {
        addressType?: string(name='AddressType'),
        connectionRole?: string(name='ConnectionRole'),
        connectionZones?: [ string ](name='ConnectionZones'),
        internetAddress?: string(name='InternetAddress'),
        internetAddressStatus?: string(name='InternetAddressStatus'),
        internetPort?: int32(name='InternetPort'),
        intranetAddress?: string(name='IntranetAddress'),
        intranetAddressMasterZoneId?: string(name='IntranetAddressMasterZoneId'),
        intranetAddressSlaveZoneId?: string(name='IntranetAddressSlaveZoneId'),
        intranetAddressStatus?: string(name='IntranetAddressStatus'),
        intranetPort?: int32(name='IntranetPort'),
        transactionSplit?: boolean(name='TransactionSplit'),
        vSwitchId?: string(name='VSwitchId'),
        vpcId?: string(name='VpcId'),
      }
    ](name='TenantConnections'),
    tenantId?: string(name='TenantId'),
    tenantMode?: string(name='TenantMode'),
    tenantName?: string(name='TenantName'),
    tenantResource?: {
      cpu?: {
        totalCpu?: float(name='TotalCpu'),
        unitCpu?: float(name='UnitCpu'),
        usedCpu?: float(name='UsedCpu'),
      }(name='Cpu'),
      diskSize?: {
        usedDiskSize?: float(name='UsedDiskSize'),
      }(name='DiskSize'),
      memory?: {
        totalMemory?: float(name='TotalMemory'),
        unitMemory?: float(name='UnitMemory'),
        usedMemory?: float(name='UsedMemory'),
      }(name='Memory'),
      unitNum?: int32(name='UnitNum'),
    }(name='TenantResource'),
    tenantZones?: [ 
      {
        region?: string(name='Region'),
        tenantZoneId?: string(name='TenantZoneId'),
        tenantZoneRole?: string(name='TenantZoneRole'),
      }
    ](name='TenantZones'),
    vpcId?: string(name='VpcId'),
  }(name='Tenant'),
}

model DescribeTenantResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTenantResponseBody(name='body'),
}

async function describeTenantWithOptions(request: DescribeTenantRequest, runtime: Util.RuntimeOptions): DescribeTenantResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTenant',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTenant(request: DescribeTenantRequest): DescribeTenantResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTenantWithOptions(request, runtime);
}

model DescribeTenantMetricsRequest {
  endTime?: string(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  metrics?: string(name='Metrics'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTime?: string(name='StartTime'),
  tenantId?: string(name='TenantId'),
  tenantIdList?: string(name='TenantIdList'),
  tenantName?: string(name='TenantName'),
}

model DescribeTenantMetricsResponseBody = {
  requestId?: string(name='RequestId'),
  tenantMetrics?: string(name='TenantMetrics'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeTenantMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTenantMetricsResponseBody(name='body'),
}

async function describeTenantMetricsWithOptions(request: DescribeTenantMetricsRequest, runtime: Util.RuntimeOptions): DescribeTenantMetricsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.metrics)) {
    body['Metrics'] = request.metrics;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.tenantIdList)) {
    body['TenantIdList'] = request.tenantIdList;
  }
  if (!Util.isUnset(request.tenantName)) {
    body['TenantName'] = request.tenantName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTenantMetrics',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTenantMetrics(request: DescribeTenantMetricsRequest): DescribeTenantMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTenantMetricsWithOptions(request, runtime);
}

model DescribeTenantTagsRequest {
  instanceId?: string(name='InstanceId'),
  tags?: string(name='Tags'),
  tenantIds?: string(name='TenantIds'),
}

model DescribeTenantTagsResponseBody = {
  requestId?: string(name='RequestId'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tag?: string(name='Tag'),
    }
  ](name='TagResources'),
}

model DescribeTenantTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTenantTagsResponseBody(name='body'),
}

async function describeTenantTagsWithOptions(request: DescribeTenantTagsRequest, runtime: Util.RuntimeOptions): DescribeTenantTagsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tags)) {
    body['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.tenantIds)) {
    body['TenantIds'] = request.tenantIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTenantTags',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTenantTags(request: DescribeTenantTagsRequest): DescribeTenantTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTenantTagsWithOptions(request, runtime);
}

model DescribeTenantUserRolesResponseBody = {
  requestId?: string(name='RequestId'),
  role?: [ string ](name='Role'),
}

model DescribeTenantUserRolesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTenantUserRolesResponseBody(name='body'),
}

async function describeTenantUserRolesWithOptions(runtime: Util.RuntimeOptions): DescribeTenantUserRolesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeTenantUserRoles',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTenantUserRoles(): DescribeTenantUserRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTenantUserRolesWithOptions(runtime);
}

model DescribeTenantUsersRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  searchKey?: string(name='SearchKey'),
  tenantId?: string(name='TenantId'),
  userName?: string(name='UserName'),
}

model DescribeTenantUsersResponseBody = {
  requestId?: string(name='RequestId'),
  tenantUsers?: [ 
    {
      databases?: [ 
        {
          database?: string(name='Database'),
          role?: string(name='Role'),
          table?: string(name='Table'),
        }
      ](name='Databases'),
      description?: string(name='Description'),
      userName?: string(name='UserName'),
      userStatus?: string(name='UserStatus'),
      userType?: string(name='UserType'),
    }
  ](name='TenantUsers'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeTenantUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTenantUsersResponseBody(name='body'),
}

async function describeTenantUsersWithOptions(request: DescribeTenantUsersRequest, runtime: Util.RuntimeOptions): DescribeTenantUsersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchKey)) {
    body['SearchKey'] = request.searchKey;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTenantUsers',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTenantUsers(request: DescribeTenantUsersRequest): DescribeTenantUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTenantUsersWithOptions(request, runtime);
}

model DescribeTenantZonesReadRequest {
  instanceId?: string(name='InstanceId'),
  tenantId?: string(name='TenantId'),
}

model DescribeTenantZonesReadResponseBody = {
  requestId?: string(name='RequestId'),
  tenantZones?: [ 
    {
      isElectable?: boolean(name='IsElectable'),
      isPrimary?: boolean(name='IsPrimary'),
      isReadOnlyAddressMaster?: boolean(name='IsReadOnlyAddressMaster'),
      isReadable?: string(name='IsReadable'),
      zone?: string(name='Zone'),
    }
  ](name='TenantZones'),
}

model DescribeTenantZonesReadResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTenantZonesReadResponseBody(name='body'),
}

async function describeTenantZonesReadWithOptions(request: DescribeTenantZonesReadRequest, runtime: Util.RuntimeOptions): DescribeTenantZonesReadResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTenantZonesRead',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTenantZonesRead(request: DescribeTenantZonesReadRequest): DescribeTenantZonesReadResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTenantZonesReadWithOptions(request, runtime);
}

model DescribeTenantsRequest {
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  searchKey?: string(name='SearchKey'),
  tenantId?: string(name='TenantId'),
  tenantName?: string(name='TenantName'),
}

model DescribeTenantsResponseBody = {
  requestId?: string(name='RequestId'),
  tenants?: [ 
    {
      charset?: string(name='Charset'),
      collation?: string(name='Collation'),
      cpu?: int32(name='Cpu'),
      createTime?: string(name='CreateTime'),
      deployMode?: string(name='DeployMode'),
      deployType?: string(name='DeployType'),
      description?: string(name='Description'),
      mem?: int32(name='Mem'),
      primaryZone?: string(name='PrimaryZone'),
      status?: string(name='Status'),
      tenantId?: string(name='TenantId'),
      tenantMode?: string(name='TenantMode'),
      tenantName?: string(name='TenantName'),
      unitCpu?: int32(name='UnitCpu'),
      unitMem?: int32(name='UnitMem'),
      unitNum?: int32(name='UnitNum'),
      usedDiskSize?: double(name='UsedDiskSize'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Tenants'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeTenantsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTenantsResponseBody(name='body'),
}

async function describeTenantsWithOptions(request: DescribeTenantsRequest, runtime: Util.RuntimeOptions): DescribeTenantsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchKey)) {
    body['SearchKey'] = request.searchKey;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.tenantName)) {
    body['TenantName'] = request.tenantName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTenants',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTenants(request: DescribeTenantsRequest): DescribeTenantsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTenantsWithOptions(request, runtime);
}

model DescribeTimeZonesResponseBody = {
  requestId?: string(name='RequestId'),
  timeZones?: {
    default?: string(name='Default'),
    list?: [ 
      {
        description?: string(name='Description'),
        timeZone?: string(name='TimeZone'),
      }
    ](name='List'),
  }(name='TimeZones'),
}

model DescribeTimeZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTimeZonesResponseBody(name='body'),
}

async function describeTimeZonesWithOptions(runtime: Util.RuntimeOptions): DescribeTimeZonesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeTimeZones',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTimeZones(): DescribeTimeZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTimeZonesWithOptions(runtime);
}

model DescribeTopSQLListRequest {
  dbName?: string(name='DbName'),
  endTime?: string(name='EndTime'),
  filterCondition?: map[string]any(name='FilterCondition'),
  nodeIp?: string(name='NodeIp'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  SQLId?: string(name='SQLId'),
  searchKeyWord?: string(name='SearchKeyWord'),
  searchParameter?: string(name='SearchParameter'),
  searchRule?: string(name='SearchRule'),
  searchValue?: string(name='SearchValue'),
  sortColumn?: string(name='SortColumn'),
  sortOrder?: string(name='SortOrder'),
  startTime?: string(name='StartTime'),
  tenantId?: string(name='TenantId'),
}

model DescribeTopSQLListShrinkRequest {
  dbName?: string(name='DbName'),
  endTime?: string(name='EndTime'),
  filterConditionShrink?: string(name='FilterCondition'),
  nodeIp?: string(name='NodeIp'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  SQLId?: string(name='SQLId'),
  searchKeyWord?: string(name='SearchKeyWord'),
  searchParameter?: string(name='SearchParameter'),
  searchRule?: string(name='SearchRule'),
  searchValue?: string(name='SearchValue'),
  sortColumn?: string(name='SortColumn'),
  sortOrder?: string(name='SortOrder'),
  startTime?: string(name='StartTime'),
  tenantId?: string(name='TenantId'),
}

model DescribeTopSQLListResponseBody = {
  requestId?: string(name='RequestId'),
  topSQLList?: [ 
    {
      affectedRows?: long(name='AffectedRows'),
      appWaitTime?: float(name='AppWaitTime'),
      blockCacheHit?: long(name='BlockCacheHit'),
      blockIndexCacheHit?: long(name='BlockIndexCacheHit'),
      bloomFilterCacheHit?: long(name='BloomFilterCacheHit'),
      clientIp?: string(name='ClientIp'),
      concurrencyWaitTime?: float(name='ConcurrencyWaitTime'),
      cpuTime?: float(name='CpuTime'),
      dbName?: string(name='DbName'),
      decodeTime?: float(name='DecodeTime'),
      diskRead?: long(name='DiskRead'),
      elapsedTime?: float(name='ElapsedTime'),
      event?: string(name='Event'),
      execPerSecond?: float(name='ExecPerSecond'),
      executeTime?: float(name='ExecuteTime'),
      executions?: long(name='Executions'),
      failTimes?: long(name='FailTimes'),
      getPlanTime?: float(name='GetPlanTime'),
      IOWaitTime?: float(name='IOWaitTime'),
      key?: long(name='Key'),
      logicalRead?: long(name='LogicalRead'),
      maxCpuTime?: float(name='MaxCpuTime'),
      maxElapsedTime?: float(name='MaxElapsedTime'),
      memstoreReadRowCount?: long(name='MemstoreReadRowCount'),
      missPlans?: long(name='MissPlans'),
      netWaitTime?: float(name='NetWaitTime'),
      nodeIp?: string(name='NodeIp'),
      queueTime?: float(name='QueueTime'),
      RPCCount?: long(name='RPCCount'),
      remotePlans?: long(name='RemotePlans'),
      retryCount?: long(name='RetryCount'),
      returnRows?: long(name='ReturnRows'),
      rowCacheHit?: long(name='RowCacheHit'),
      SQLId?: string(name='SQLId'),
      SQLText?: string(name='SQLText'),
      SQLType?: long(name='SQLType'),
      scheduleTime?: float(name='ScheduleTime'),
      ssstoreReadRowCount?: long(name='SsstoreReadRowCount'),
      totalWaitTime?: float(name='TotalWaitTime'),
      userName?: string(name='UserName'),
    }
  ](name='TopSQLList'),
  totalCount?: long(name='TotalCount'),
}

model DescribeTopSQLListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTopSQLListResponseBody(name='body'),
}

async function describeTopSQLListWithOptions(tmpReq: DescribeTopSQLListRequest, runtime: Util.RuntimeOptions): DescribeTopSQLListResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeTopSQLListShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.filterCondition)) {
    request.filterConditionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterCondition, 'FilterCondition', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.dbName)) {
    body['DbName'] = request.dbName;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.filterConditionShrink)) {
    body['FilterCondition'] = request.filterConditionShrink;
  }
  if (!Util.isUnset(request.nodeIp)) {
    body['NodeIp'] = request.nodeIp;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.SQLId)) {
    body['SQLId'] = request.SQLId;
  }
  if (!Util.isUnset(request.searchKeyWord)) {
    body['SearchKeyWord'] = request.searchKeyWord;
  }
  if (!Util.isUnset(request.searchParameter)) {
    body['SearchParameter'] = request.searchParameter;
  }
  if (!Util.isUnset(request.searchRule)) {
    body['SearchRule'] = request.searchRule;
  }
  if (!Util.isUnset(request.searchValue)) {
    body['SearchValue'] = request.searchValue;
  }
  if (!Util.isUnset(request.sortColumn)) {
    body['SortColumn'] = request.sortColumn;
  }
  if (!Util.isUnset(request.sortOrder)) {
    body['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTopSQLList',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTopSQLList(request: DescribeTopSQLListRequest): DescribeTopSQLListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTopSQLListWithOptions(request, runtime);
}

model DescribeZonesRequest {
  deployType?: string(name='DeployType'),
  series?: string(name='Series'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: [ 
    {
      deployType?: string(name='DeployType'),
      series?: string(name='Series'),
      zoneId?: string(name='ZoneId'),
      zoneName?: string(name='ZoneName'),
    }
  ](name='Zones'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeZonesResponseBody(name='body'),
}

async function describeZonesWithOptions(request: DescribeZonesRequest, runtime: Util.RuntimeOptions): DescribeZonesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deployType)) {
    body['DeployType'] = request.deployType;
  }
  if (!Util.isUnset(request.series)) {
    body['Series'] = request.series;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeZones',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeZonesWithOptions(request, runtime);
}

model ModifyDatabaseDescriptionRequest {
  databaseName?: string(name='DatabaseName'),
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  tenantId?: string(name='TenantId'),
}

model ModifyDatabaseDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDatabaseDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDatabaseDescriptionResponseBody(name='body'),
}

async function modifyDatabaseDescriptionWithOptions(request: ModifyDatabaseDescriptionRequest, runtime: Util.RuntimeOptions): ModifyDatabaseDescriptionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDatabaseDescription',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDatabaseDescription(request: ModifyDatabaseDescriptionRequest): ModifyDatabaseDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDatabaseDescriptionWithOptions(request, runtime);
}

model ModifyDatabaseUserRolesRequest {
  databaseName?: string(name='DatabaseName'),
  instanceId?: string(name='InstanceId'),
  tenantId?: string(name='TenantId'),
  users?: string(name='Users'),
}

model ModifyDatabaseUserRolesResponseBody = {
  requestId?: string(name='RequestId'),
  tenantUser?: {
    databaseName?: string(name='DatabaseName'),
    tenantId?: string(name='TenantId'),
    users?: [ 
      {
        role?: string(name='Role'),
        userName?: string(name='UserName'),
      }
    ](name='Users'),
  }(name='TenantUser'),
}

model ModifyDatabaseUserRolesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDatabaseUserRolesResponseBody(name='body'),
}

async function modifyDatabaseUserRolesWithOptions(request: ModifyDatabaseUserRolesRequest, runtime: Util.RuntimeOptions): ModifyDatabaseUserRolesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.databaseName)) {
    body['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.users)) {
    body['Users'] = request.users;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDatabaseUserRoles',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDatabaseUserRoles(request: ModifyDatabaseUserRolesRequest): ModifyDatabaseUserRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDatabaseUserRolesWithOptions(request, runtime);
}

model ModifyInstanceNameRequest {
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
}

model ModifyInstanceNameResponseBody = {
  instanceName?: string(name='InstanceName'),
  requestId?: string(name='RequestId'),
}

model ModifyInstanceNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceNameResponseBody(name='body'),
}

async function modifyInstanceNameWithOptions(request: ModifyInstanceNameRequest, runtime: Util.RuntimeOptions): ModifyInstanceNameResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    body['InstanceName'] = request.instanceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceName',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceName(request: ModifyInstanceNameRequest): ModifyInstanceNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceNameWithOptions(request, runtime);
}

model ModifyInstanceTagsRequest {
  instanceId?: string(name='InstanceId'),
  tags?: string(name='Tags'),
}

model ModifyInstanceTagsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ModifyInstanceTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceTagsResponseBody(name='body'),
}

async function modifyInstanceTagsWithOptions(request: ModifyInstanceTagsRequest, runtime: Util.RuntimeOptions): ModifyInstanceTagsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tags)) {
    body['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceTags',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceTags(request: ModifyInstanceTagsRequest): ModifyInstanceTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceTagsWithOptions(request, runtime);
}

model ModifyParametersRequest {
  dimension?: string(name='Dimension'),
  dimensionValue?: string(name='DimensionValue'),
  instanceId?: string(name='InstanceId'),
  parameters?: string(name='Parameters'),
}

model ModifyParametersResponseBody = {
  requestId?: string(name='RequestId'),
  results?: {
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='Results'),
}

model ModifyParametersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyParametersResponseBody(name='body'),
}

async function modifyParametersWithOptions(request: ModifyParametersRequest, runtime: Util.RuntimeOptions): ModifyParametersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dimension)) {
    body['Dimension'] = request.dimension;
  }
  if (!Util.isUnset(request.dimensionValue)) {
    body['DimensionValue'] = request.dimensionValue;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.parameters)) {
    body['Parameters'] = request.parameters;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyParameters',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyParameters(request: ModifyParametersRequest): ModifyParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyParametersWithOptions(request, runtime);
}

model ModifySecurityIpsRequest {
  instanceId?: string(name='InstanceId'),
  securityIpGroupName?: string(name='SecurityIpGroupName'),
  securityIps?: string(name='SecurityIps'),
}

model ModifySecurityIpsResponseBody = {
  requestId?: string(name='RequestId'),
  securityIpGroup?: {
    instanceId?: string(name='InstanceId'),
    securityIpGroupName?: string(name='SecurityIpGroupName'),
    securityIps?: string(name='SecurityIps'),
  }(name='SecurityIpGroup'),
}

model ModifySecurityIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySecurityIpsResponseBody(name='body'),
}

async function modifySecurityIpsWithOptions(request: ModifySecurityIpsRequest, runtime: Util.RuntimeOptions): ModifySecurityIpsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.securityIpGroupName)) {
    body['SecurityIpGroupName'] = request.securityIpGroupName;
  }
  if (!Util.isUnset(request.securityIps)) {
    body['SecurityIps'] = request.securityIps;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifySecurityIps',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySecurityIps(request: ModifySecurityIpsRequest): ModifySecurityIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySecurityIpsWithOptions(request, runtime);
}

model ModifyTenantPrimaryZoneRequest {
  instanceId?: string(name='InstanceId'),
  masterIntranetAddressZone?: string(name='MasterIntranetAddressZone'),
  modifyType?: string(name='ModifyType'),
  primaryZone?: string(name='PrimaryZone'),
  primaryZoneDeployType?: string(name='PrimaryZoneDeployType'),
  tenantId?: string(name='TenantId'),
  userVSwitchId?: string(name='UserVSwitchId'),
}

model ModifyTenantPrimaryZoneResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyTenantPrimaryZoneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyTenantPrimaryZoneResponseBody(name='body'),
}

async function modifyTenantPrimaryZoneWithOptions(request: ModifyTenantPrimaryZoneRequest, runtime: Util.RuntimeOptions): ModifyTenantPrimaryZoneResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.masterIntranetAddressZone)) {
    body['MasterIntranetAddressZone'] = request.masterIntranetAddressZone;
  }
  if (!Util.isUnset(request.modifyType)) {
    body['ModifyType'] = request.modifyType;
  }
  if (!Util.isUnset(request.primaryZone)) {
    body['PrimaryZone'] = request.primaryZone;
  }
  if (!Util.isUnset(request.primaryZoneDeployType)) {
    body['PrimaryZoneDeployType'] = request.primaryZoneDeployType;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.userVSwitchId)) {
    body['UserVSwitchId'] = request.userVSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyTenantPrimaryZone',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyTenantPrimaryZone(request: ModifyTenantPrimaryZoneRequest): ModifyTenantPrimaryZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTenantPrimaryZoneWithOptions(request, runtime);
}

model ModifyTenantResourceRequest {
  cpu?: int32(name='Cpu'),
  instanceId?: string(name='InstanceId'),
  memory?: int32(name='Memory'),
  tenantId?: string(name='TenantId'),
}

model ModifyTenantResourceResponseBody = {
  requestId?: string(name='RequestId'),
  tenantId?: string(name='TenantId'),
}

model ModifyTenantResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyTenantResourceResponseBody(name='body'),
}

async function modifyTenantResourceWithOptions(request: ModifyTenantResourceRequest, runtime: Util.RuntimeOptions): ModifyTenantResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.cpu)) {
    body['Cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.memory)) {
    body['Memory'] = request.memory;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyTenantResource',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyTenantResource(request: ModifyTenantResourceRequest): ModifyTenantResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTenantResourceWithOptions(request, runtime);
}

model ModifyTenantTagsRequest {
  instanceId?: string(name='InstanceId'),
  tags?: string(name='Tags'),
  tenantId?: string(name='TenantId'),
}

model ModifyTenantTagsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ModifyTenantTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyTenantTagsResponseBody(name='body'),
}

async function modifyTenantTagsWithOptions(request: ModifyTenantTagsRequest, runtime: Util.RuntimeOptions): ModifyTenantTagsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tags)) {
    body['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyTenantTags',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyTenantTags(request: ModifyTenantTagsRequest): ModifyTenantTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTenantTagsWithOptions(request, runtime);
}

model ModifyTenantUserDescriptionRequest {
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  tenantId?: string(name='TenantId'),
  userName?: string(name='UserName'),
}

model ModifyTenantUserDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyTenantUserDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyTenantUserDescriptionResponseBody(name='body'),
}

async function modifyTenantUserDescriptionWithOptions(request: ModifyTenantUserDescriptionRequest, runtime: Util.RuntimeOptions): ModifyTenantUserDescriptionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyTenantUserDescription',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyTenantUserDescription(request: ModifyTenantUserDescriptionRequest): ModifyTenantUserDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTenantUserDescriptionWithOptions(request, runtime);
}

model ModifyTenantUserPasswordRequest {
  instanceId?: string(name='InstanceId'),
  tenantId?: string(name='TenantId'),
  userName?: string(name='UserName'),
  userPassword?: string(name='UserPassword'),
}

model ModifyTenantUserPasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyTenantUserPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyTenantUserPasswordResponseBody(name='body'),
}

async function modifyTenantUserPasswordWithOptions(request: ModifyTenantUserPasswordRequest, runtime: Util.RuntimeOptions): ModifyTenantUserPasswordResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.userPassword)) {
    body['UserPassword'] = request.userPassword;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyTenantUserPassword',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyTenantUserPassword(request: ModifyTenantUserPasswordRequest): ModifyTenantUserPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTenantUserPasswordWithOptions(request, runtime);
}

model ModifyTenantUserRolesRequest {
  instanceId?: string(name='InstanceId'),
  modifyType?: string(name='ModifyType'),
  tenantId?: string(name='TenantId'),
  userName?: string(name='UserName'),
  userRole?: string(name='UserRole'),
}

model ModifyTenantUserRolesResponseBody = {
  requestId?: string(name='RequestId'),
  tenantUser?: {
    tenantId?: string(name='TenantId'),
    userName?: string(name='UserName'),
    userRole?: [ 
      {
        database?: string(name='Database'),
        isSuccess?: boolean(name='IsSuccess'),
        role?: string(name='Role'),
        table?: string(name='Table'),
      }
    ](name='UserRole'),
  }(name='TenantUser'),
}

model ModifyTenantUserRolesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyTenantUserRolesResponseBody(name='body'),
}

async function modifyTenantUserRolesWithOptions(request: ModifyTenantUserRolesRequest, runtime: Util.RuntimeOptions): ModifyTenantUserRolesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.modifyType)) {
    body['ModifyType'] = request.modifyType;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.userRole)) {
    body['UserRole'] = request.userRole;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyTenantUserRoles',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyTenantUserRoles(request: ModifyTenantUserRolesRequest): ModifyTenantUserRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTenantUserRolesWithOptions(request, runtime);
}

model ModifyTenantUserStatusRequest {
  instanceId?: string(name='InstanceId'),
  tenantId?: string(name='TenantId'),
  userName?: string(name='UserName'),
  userStatus?: string(name='UserStatus'),
}

model ModifyTenantUserStatusResponseBody = {
  requestId?: string(name='RequestId'),
  tenantUser?: [ 
    {
      tenantId?: string(name='TenantId'),
      userName?: string(name='UserName'),
      userStatus?: string(name='UserStatus'),
    }
  ](name='TenantUser'),
}

model ModifyTenantUserStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyTenantUserStatusResponseBody(name='body'),
}

async function modifyTenantUserStatusWithOptions(request: ModifyTenantUserStatusRequest, runtime: Util.RuntimeOptions): ModifyTenantUserStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.userStatus)) {
    body['UserStatus'] = request.userStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyTenantUserStatus',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyTenantUserStatus(request: ModifyTenantUserStatusRequest): ModifyTenantUserStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTenantUserStatusWithOptions(request, runtime);
}

model ReleaseOmsOpenAPIProjectRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  workerGradeId?: string(name='WorkerGradeId'),
}

model ReleaseOmsOpenAPIProjectResponseBody = {
  advice?: string(name='Advice'),
  code?: string(name='Code'),
  cost?: string(name='Cost'),
  data?: boolean(name='Data'),
  errorDetail?: {
    code?: string(name='Code'),
    level?: string(name='Level'),
    message?: string(name='Message'),
    proposal?: string(name='Proposal'),
  }(name='ErrorDetail'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ReleaseOmsOpenAPIProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleaseOmsOpenAPIProjectResponseBody(name='body'),
}

async function releaseOmsOpenAPIProjectWithOptions(request: ReleaseOmsOpenAPIProjectRequest, runtime: Util.RuntimeOptions): ReleaseOmsOpenAPIProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.workerGradeId)) {
    body['WorkerGradeId'] = request.workerGradeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseOmsOpenAPIProject',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseOmsOpenAPIProject(request: ReleaseOmsOpenAPIProjectRequest): ReleaseOmsOpenAPIProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseOmsOpenAPIProjectWithOptions(request, runtime);
}

model ResetOmsOpenAPIProjectRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  workerGradeId?: string(name='WorkerGradeId'),
}

model ResetOmsOpenAPIProjectResponseBody = {
  advice?: string(name='Advice'),
  code?: string(name='Code'),
  cost?: string(name='Cost'),
  data?: boolean(name='Data'),
  errorDetail?: {
    code?: string(name='Code'),
    level?: string(name='Level'),
    message?: string(name='Message'),
    proposal?: string(name='Proposal'),
  }(name='ErrorDetail'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ResetOmsOpenAPIProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetOmsOpenAPIProjectResponseBody(name='body'),
}

async function resetOmsOpenAPIProjectWithOptions(request: ResetOmsOpenAPIProjectRequest, runtime: Util.RuntimeOptions): ResetOmsOpenAPIProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.workerGradeId)) {
    body['WorkerGradeId'] = request.workerGradeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ResetOmsOpenAPIProject',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetOmsOpenAPIProject(request: ResetOmsOpenAPIProjectRequest): ResetOmsOpenAPIProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetOmsOpenAPIProjectWithOptions(request, runtime);
}

model ResumeOmsOpenAPIProjectRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  workerGradeId?: string(name='WorkerGradeId'),
}

model ResumeOmsOpenAPIProjectResponseBody = {
  advice?: string(name='Advice'),
  code?: string(name='Code'),
  cost?: string(name='Cost'),
  data?: boolean(name='Data'),
  errorDetail?: {
    code?: string(name='Code'),
    level?: string(name='Level'),
    message?: string(name='Message'),
    proposal?: string(name='Proposal'),
  }(name='ErrorDetail'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ResumeOmsOpenAPIProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResumeOmsOpenAPIProjectResponseBody(name='body'),
}

async function resumeOmsOpenAPIProjectWithOptions(request: ResumeOmsOpenAPIProjectRequest, runtime: Util.RuntimeOptions): ResumeOmsOpenAPIProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.workerGradeId)) {
    body['WorkerGradeId'] = request.workerGradeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ResumeOmsOpenAPIProject',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resumeOmsOpenAPIProject(request: ResumeOmsOpenAPIProjectRequest): ResumeOmsOpenAPIProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumeOmsOpenAPIProjectWithOptions(request, runtime);
}

model SearchOmsOpenAPIMonitorMetricRequest {
  beginTime?: long(name='BeginTime'),
  endTime?: long(name='EndTime'),
  maxPointNum?: long(name='MaxPointNum'),
  metric?: string(name='Metric'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  workerGradeId?: string(name='WorkerGradeId'),
}

model SearchOmsOpenAPIMonitorMetricResponseBody = {
  advice?: string(name='Advice'),
  code?: string(name='Code'),
  cost?: string(name='Cost'),
  data?: [ 
    {
      dataPoints?: [ 
        {
          timestamp?: long(name='Timestamp'),
          value?: double(name='Value'),
        }
      ](name='DataPoints'),
      metric?: string(name='Metric'),
      tags?: map[string]string(name='Tags'),
    }
  ](name='Data'),
  errorDetail?: {
    code?: string(name='Code'),
    level?: string(name='Level'),
    message?: string(name='Message'),
    proposal?: string(name='Proposal'),
  }(name='ErrorDetail'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model SearchOmsOpenAPIMonitorMetricResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchOmsOpenAPIMonitorMetricResponseBody(name='body'),
}

async function searchOmsOpenAPIMonitorMetricWithOptions(request: SearchOmsOpenAPIMonitorMetricRequest, runtime: Util.RuntimeOptions): SearchOmsOpenAPIMonitorMetricResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.beginTime)) {
    body['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.maxPointNum)) {
    body['MaxPointNum'] = request.maxPointNum;
  }
  if (!Util.isUnset(request.metric)) {
    body['Metric'] = request.metric;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.workerGradeId)) {
    body['WorkerGradeId'] = request.workerGradeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchOmsOpenAPIMonitorMetric',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchOmsOpenAPIMonitorMetric(request: SearchOmsOpenAPIMonitorMetricRequest): SearchOmsOpenAPIMonitorMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchOmsOpenAPIMonitorMetricWithOptions(request, runtime);
}

model SearchOmsOpenAPIProjectsRequest {
  destDbTypes?: [ string ](name='DestDbTypes'),
  labelIds?: [ string ](name='LabelIds'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  searchKey?: string(name='SearchKey'),
  sourceDbTypes?: [ string ](name='SourceDbTypes'),
  statusList?: [ string ](name='StatusList'),
  workerGradeId?: string(name='WorkerGradeId'),
}

model SearchOmsOpenAPIProjectsShrinkRequest {
  destDbTypesShrink?: string(name='DestDbTypes'),
  labelIdsShrink?: string(name='LabelIds'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  searchKey?: string(name='SearchKey'),
  sourceDbTypesShrink?: string(name='SourceDbTypes'),
  statusListShrink?: string(name='StatusList'),
  workerGradeId?: string(name='WorkerGradeId'),
}

model SearchOmsOpenAPIProjectsResponseBody = {
  advice?: string(name='Advice'),
  code?: string(name='Code'),
  cost?: string(name='Cost'),
  data?: [ 
    {
      businessName?: string(name='BusinessName'),
      destConfig?: {
        enableMsgTrace?: boolean(name='EnableMsgTrace'),
        endpointId?: string(name='EndpointId'),
        endpointType?: string(name='EndpointType'),
        msgTags?: string(name='MsgTags'),
        partition?: int32(name='Partition'),
        partitionMode?: string(name='PartitionMode'),
        producerGroup?: string(name='ProducerGroup'),
        sendMsgTimeout?: long(name='SendMsgTimeout'),
        sequenceEnable?: boolean(name='SequenceEnable'),
        sequenceStartTimestamp?: long(name='SequenceStartTimestamp'),
        serializerType?: string(name='SerializerType'),
        topicType?: string(name='TopicType'),
      }(name='DestConfig'),
      labels?: [ 
        {
          count?: int32(name='Count'),
          creator?: string(name='Creator'),
          id?: string(name='Id'),
          name?: string(name='Name'),
        }
      ](name='Labels'),
      projectId?: string(name='ProjectId'),
      projectName?: string(name='ProjectName'),
      projectOwner?: string(name='ProjectOwner'),
      sourceConfig?: {
        enableMsgTrace?: boolean(name='EnableMsgTrace'),
        endpointId?: string(name='EndpointId'),
        endpointType?: string(name='EndpointType'),
        msgTags?: string(name='MsgTags'),
        partition?: int32(name='Partition'),
        partitionMode?: string(name='PartitionMode'),
        producerGroup?: string(name='ProducerGroup'),
        sendMsgTimeout?: long(name='SendMsgTimeout'),
        sequenceEnable?: boolean(name='SequenceEnable'),
        sequenceStartTimestamp?: long(name='SequenceStartTimestamp'),
        serializerType?: string(name='SerializerType'),
        topicType?: string(name='TopicType'),
      }(name='SourceConfig'),
      steps?: [ 
        {
          estimatedRemainingSeconds?: long(name='EstimatedRemainingSeconds'),
          extraInfo?: {
            errorCode?: string(name='ErrorCode'),
            errorDetails?: [ 
              {
                code?: string(name='Code'),
                level?: string(name='Level'),
                message?: string(name='Message'),
                proposal?: string(name='Proposal'),
              }
            ](name='ErrorDetails'),
            errorMsg?: string(name='ErrorMsg'),
            errorParam?: map[string]string(name='ErrorParam'),
            failedTime?: string(name='FailedTime'),
          }(name='ExtraInfo'),
          finishTime?: string(name='FinishTime'),
          interactive?: boolean(name='Interactive'),
          startTime?: string(name='StartTime'),
          stepDescription?: string(name='StepDescription'),
          stepInfo?: {
            capacity?: long(name='Capacity'),
            checkpoint?: string(name='Checkpoint'),
            connectorFullProgressOverview?: {
              estimatedRemainingTimeOfSec?: long(name='EstimatedRemainingTimeOfSec'),
              estimatedTotalCount?: long(name='EstimatedTotalCount'),
              finishedCount?: long(name='FinishedCount'),
              progress?: int32(name='Progress'),
            }(name='ConnectorFullProgressOverview'),
            deployId?: string(name='DeployId'),
            dstIops?: long(name='DstIops'),
            dstRps?: long(name='DstRps'),
            dstRpsRef?: long(name='DstRpsRef'),
            dstRt?: long(name='DstRt'),
            dstRtRef?: long(name='DstRtRef'),
            gmt?: long(name='Gmt'),
            inconsistencies?: long(name='Inconsistencies'),
            incrTimestampCheckpoint?: long(name='IncrTimestampCheckpoint'),
            jobId?: string(name='JobId'),
            processedRecords?: long(name='ProcessedRecords'),
            skipped?: boolean(name='Skipped'),
            srcIops?: long(name='SrcIops'),
            srcIopsRef?: long(name='SrcIopsRef'),
            srcRps?: long(name='SrcRps'),
            srcRpsRef?: long(name='SrcRpsRef'),
            srcRt?: long(name='SrcRt'),
            srcRtRef?: long(name='SrcRtRef'),
            validated?: boolean(name='Validated'),
          }(name='StepInfo'),
          stepName?: string(name='StepName'),
          stepOrder?: int32(name='StepOrder'),
          stepProgress?: int32(name='StepProgress'),
          stepStatus?: string(name='StepStatus'),
        }
      ](name='Steps'),
      transferMapping?: {
        databases?: [ 
          {
            databaseId?: string(name='DatabaseId'),
            databaseName?: string(name='DatabaseName'),
            mappedName?: string(name='MappedName'),
            tables?: [ 
              {
                adbTableSchema?: {
                  distributedKeys?: [ string ](name='DistributedKeys'),
                  partitionLifeCycle?: int32(name='PartitionLifeCycle'),
                  partitionStatement?: string(name='PartitionStatement'),
                  primaryKeys?: [ string ](name='PrimaryKeys'),
                }(name='AdbTableSchema'),
                filterColumns?: [ string ](name='FilterColumns'),
                mappedName?: string(name='MappedName'),
                shardColumns?: [ string ](name='ShardColumns'),
                tableId?: string(name='TableId'),
                tableName?: string(name='TableName'),
                type?: string(name='Type'),
                whereClause?: string(name='WhereClause'),
              }
            ](name='Tables'),
            tenantName?: string(name='TenantName'),
            type?: string(name='Type'),
          }
        ](name='Databases'),
        mode?: string(name='Mode'),
      }(name='TransferMapping'),
      transferStepConfig?: {
        enableFullSync?: boolean(name='EnableFullSync'),
        enableIncrSync?: boolean(name='EnableIncrSync'),
        enableStructSync?: boolean(name='EnableStructSync'),
        incrSyncStepTransferConfig?: {
          recordTypeList?: [ string ](name='RecordTypeList'),
          startTimestamp?: long(name='StartTimestamp'),
          storeLogKeptHour?: long(name='StoreLogKeptHour'),
          storeTransactionEnabled?: boolean(name='StoreTransactionEnabled'),
          transferStepType?: string(name='TransferStepType'),
        }(name='IncrSyncStepTransferConfig'),
      }(name='TransferStepConfig'),
    }
  ](name='Data'),
  errorDetail?: {
    code?: string(name='Code'),
    level?: string(name='Level'),
    message?: string(name='Message'),
    proposal?: string(name='Proposal'),
  }(name='ErrorDetail'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model SearchOmsOpenAPIProjectsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchOmsOpenAPIProjectsResponseBody(name='body'),
}

async function searchOmsOpenAPIProjectsWithOptions(tmpReq: SearchOmsOpenAPIProjectsRequest, runtime: Util.RuntimeOptions): SearchOmsOpenAPIProjectsResponse {
  Util.validateModel(tmpReq);
  var request = new SearchOmsOpenAPIProjectsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.destDbTypes)) {
    request.destDbTypesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.destDbTypes, 'DestDbTypes', 'json');
  }
  if (!Util.isUnset(tmpReq.labelIds)) {
    request.labelIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labelIds, 'LabelIds', 'json');
  }
  if (!Util.isUnset(tmpReq.sourceDbTypes)) {
    request.sourceDbTypesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceDbTypes, 'SourceDbTypes', 'json');
  }
  if (!Util.isUnset(tmpReq.statusList)) {
    request.statusListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.statusList, 'StatusList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.destDbTypesShrink)) {
    body['DestDbTypes'] = request.destDbTypesShrink;
  }
  if (!Util.isUnset(request.labelIdsShrink)) {
    body['LabelIds'] = request.labelIdsShrink;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchKey)) {
    body['SearchKey'] = request.searchKey;
  }
  if (!Util.isUnset(request.sourceDbTypesShrink)) {
    body['SourceDbTypes'] = request.sourceDbTypesShrink;
  }
  if (!Util.isUnset(request.statusListShrink)) {
    body['StatusList'] = request.statusListShrink;
  }
  if (!Util.isUnset(request.workerGradeId)) {
    body['WorkerGradeId'] = request.workerGradeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchOmsOpenAPIProjects',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchOmsOpenAPIProjects(request: SearchOmsOpenAPIProjectsRequest): SearchOmsOpenAPIProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchOmsOpenAPIProjectsWithOptions(request, runtime);
}

model StartOmsOpenAPIProjectRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  workerGradeId?: string(name='WorkerGradeId'),
}

model StartOmsOpenAPIProjectResponseBody = {
  advice?: string(name='Advice'),
  code?: string(name='Code'),
  cost?: string(name='Cost'),
  data?: boolean(name='Data'),
  errorDetail?: {
    code?: string(name='Code'),
    level?: string(name='Level'),
    message?: string(name='Message'),
    proposal?: string(name='Proposal'),
  }(name='ErrorDetail'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model StartOmsOpenAPIProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartOmsOpenAPIProjectResponseBody(name='body'),
}

async function startOmsOpenAPIProjectWithOptions(request: StartOmsOpenAPIProjectRequest, runtime: Util.RuntimeOptions): StartOmsOpenAPIProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.workerGradeId)) {
    body['WorkerGradeId'] = request.workerGradeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartOmsOpenAPIProject',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startOmsOpenAPIProject(request: StartOmsOpenAPIProjectRequest): StartOmsOpenAPIProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return startOmsOpenAPIProjectWithOptions(request, runtime);
}

model StopOmsOpenAPIProjectRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  workerGradeId?: string(name='WorkerGradeId'),
}

model StopOmsOpenAPIProjectResponseBody = {
  advice?: string(name='Advice'),
  code?: string(name='Code'),
  cost?: string(name='Cost'),
  data?: boolean(name='Data'),
  errorDetail?: {
    code?: string(name='Code'),
    level?: string(name='Level'),
    message?: string(name='Message'),
    proposal?: string(name='Proposal'),
  }(name='ErrorDetail'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model StopOmsOpenAPIProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopOmsOpenAPIProjectResponseBody(name='body'),
}

async function stopOmsOpenAPIProjectWithOptions(request: StopOmsOpenAPIProjectRequest, runtime: Util.RuntimeOptions): StopOmsOpenAPIProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.workerGradeId)) {
    body['WorkerGradeId'] = request.workerGradeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopOmsOpenAPIProject',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopOmsOpenAPIProject(request: StopOmsOpenAPIProjectRequest): StopOmsOpenAPIProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopOmsOpenAPIProjectWithOptions(request, runtime);
}

