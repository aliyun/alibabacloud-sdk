/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('lmztest', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model UserName {
  code?: string(name='Code', description='code'),
  name?: string(name='Name', description='name'),
}

model AAbckRequest {
  clientToken3?: string(name='ClientToken3', description='幂等参数'),
  testDemo?: string(name='TestDemo', description='test'),
}

model AAbckResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AAbckResponse = {
  headers: map[string]string(name='headers'),
  body: AAbckResponseBody(name='body'),
}

async function aAbckWithOptions(request: AAbckRequest, runtime: Util.RuntimeOptions): AAbckResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AAbck',
    version = '2010-10-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function aAbck(request: AAbckRequest): AAbckResponse {
  var runtime = new Util.RuntimeOptions{};
  return aAbckWithOptions(request, runtime);
}

model AndBackRequest {
  clientToken2?: string(name='ClientToken2', description='幂等参数'),
  testDemo?: string(name='TestDemo', description='test'),
}

model AndBackResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AndBackResponse = {
  headers: map[string]string(name='headers'),
  body: AndBackResponseBody(name='body'),
}

async function andBackWithOptions(request: AndBackRequest, runtime: Util.RuntimeOptions): AndBackResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AndBack',
    version = '2010-10-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function andBack(request: AndBackRequest): AndBackResponse {
  var runtime = new Util.RuntimeOptions{};
  return andBackWithOptions(request, runtime);
}

model CreateAccountRequest {
  accountDescription?: string(name='AccountDescription'),
  accountName?: string(name='AccountName'),
  accountPassword?: string(name='AccountPassword'),
  accountPrivilege?: string(name='AccountPrivilege'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateAccountResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAccountResponseBody(name='body'),
}

async function createAccountWithOptions(request: CreateAccountRequest, runtime: Util.RuntimeOptions): CreateAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDescription)) {
    query['AccountDescription'] = request.accountDescription;
  }
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.accountPrivilege)) {
    query['AccountPrivilege'] = request.accountPrivilege;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccount',
    version = '2010-10-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAccount(request: CreateAccountRequest): CreateAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccountWithOptions(request, runtime);
}

model DataRateLimitTestResponseBody = {
  requestId?: string(name='RequestId'),
}

model DataRateLimitTestResponse = {
  headers: map[string]string(name='headers'),
  body: DataRateLimitTestResponseBody(name='body'),
}

async function dataRateLimitTestWithOptions(runtime: Util.RuntimeOptions): DataRateLimitTestResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DataRateLimitTest',
    version = '2010-10-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function dataRateLimitTest(): DataRateLimitTestResponse {
  var runtime = new Util.RuntimeOptions{};
  return dataRateLimitTestWithOptions(runtime);
}

model DemoGrayReleaseTestRequest {
  id?: string(name='Id'),
  numberCode?: int32(name='NumberCode'),
}

model DemoGrayReleaseTestResponseBody = {
  code?: map[string]string(name='Code'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DemoGrayReleaseTestResponse = {
  headers: map[string]string(name='headers'),
  body: DemoGrayReleaseTestResponseBody(name='body'),
}

async function demoGrayReleaseTestWithOptions(request: DemoGrayReleaseTestRequest, runtime: Util.RuntimeOptions): DemoGrayReleaseTestResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.numberCode)) {
    query['NumberCode'] = request.numberCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DemoGrayReleaseTest',
    version = '2010-10-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function demoGrayReleaseTest(request: DemoGrayReleaseTestRequest): DemoGrayReleaseTestResponse {
  var runtime = new Util.RuntimeOptions{};
  return demoGrayReleaseTestWithOptions(request, runtime);
}

model DemoGrayReleaseTestTwoRequest {
  code?: long(name='Code'),
  numberCode?: string(name='NumberCode', description='A short description of struct'),
}

model DemoGrayReleaseTestTwoResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DemoGrayReleaseTestTwoResponse = {
  headers: map[string]string(name='headers'),
  body: DemoGrayReleaseTestTwoResponseBody(name='body'),
}

async function demoGrayReleaseTestTwoWithOptions(request: DemoGrayReleaseTestTwoRequest, runtime: Util.RuntimeOptions): DemoGrayReleaseTestTwoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.code)) {
    query['Code'] = request.code;
  }
  if (!Util.isUnset(request.numberCode)) {
    query['NumberCode'] = request.numberCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DemoGrayReleaseTestTwo',
    version = '2010-10-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function demoGrayReleaseTestTwo(request: DemoGrayReleaseTestTwoRequest): DemoGrayReleaseTestTwoResponse {
  var runtime = new Util.RuntimeOptions{};
  return demoGrayReleaseTestTwoWithOptions(request, runtime);
}

model DemoGreyReleaseTestRequest {
  number?: long(name='Number'),
}

model DemoGreyReleaseTestResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DemoGreyReleaseTestResponse = {
  headers: map[string]string(name='headers'),
  body: DemoGreyReleaseTestResponseBody(name='body'),
}

async function demoGreyReleaseTestWithOptions(request: DemoGreyReleaseTestRequest, runtime: Util.RuntimeOptions): DemoGreyReleaseTestResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.number)) {
    query['Number'] = request.number;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DemoGreyReleaseTest',
    version = '2010-10-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function demoGreyReleaseTest(request: DemoGreyReleaseTestRequest): DemoGreyReleaseTestResponse {
  var runtime = new Util.RuntimeOptions{};
  return demoGreyReleaseTestWithOptions(request, runtime);
}

model DescribeDisksRequest {
  filter?: [
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filter'),
  additionalAttributes?: [ string ](name='AdditionalAttributes'),
  autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId'),
  category?: string(name='Category'),
  deleteAutoSnapshot?: boolean(name='DeleteAutoSnapshot'),
  deleteWithInstance?: boolean(name='DeleteWithInstance'),
  diskChargeType?: string(name='DiskChargeType'),
  diskIds?: string(name='DiskIds'),
  diskName?: string(name='DiskName'),
  diskType?: string(name='DiskType'),
  dryRun?: boolean(name='DryRun'),
  enableAutoSnapshot?: boolean(name='EnableAutoSnapshot'),
  enableAutomatedSnapshotPolicy?: boolean(name='EnableAutomatedSnapshotPolicy'),
  enableShared?: boolean(name='EnableShared'),
  encrypted?: boolean(name='Encrypted'),
  instanceId?: string(name='InstanceId'),
  KMSKeyId?: string(name='KMSKeyId'),
  lockReason?: string(name='LockReason'),
  maxResults?: int32(name='MaxResults'),
  multiAttach?: string(name='MultiAttach'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  portable?: boolean(name='Portable'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  snapshotId?: string(name='SnapshotId'),
  status?: string(name='Status'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  zoneId?: string(name='ZoneId'),
}

model DescribeDisksResponseBody = {
  disks?: {
    disk?: [ 
    {
      attachedTime?: string(name='AttachedTime'),
      attachments?: {
        attachment?: [ 
        {
          attachedTime?: string(name='AttachedTime'),
          device?: string(name='Device'),
          instanceId?: string(name='InstanceId'),
        }
      ](name='Attachment')
      }(name='Attachments'),
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId'),
      bdfId?: string(name='BdfId'),
      category?: string(name='Category'),
      creationTime?: string(name='CreationTime'),
      dedicatedBlockStorageClusterId?: string(name='DedicatedBlockStorageClusterId'),
      deleteAutoSnapshot?: boolean(name='DeleteAutoSnapshot'),
      deleteWithInstance?: boolean(name='DeleteWithInstance'),
      description?: string(name='Description'),
      detachedTime?: string(name='DetachedTime'),
      device?: string(name='Device'),
      diskChargeType?: string(name='DiskChargeType'),
      diskId?: string(name='DiskId'),
      diskName?: string(name='DiskName'),
      enableAutoSnapshot?: boolean(name='EnableAutoSnapshot'),
      enableAutomatedSnapshotPolicy?: boolean(name='EnableAutomatedSnapshotPolicy'),
      encrypted?: boolean(name='Encrypted'),
      expiredTime?: string(name='ExpiredTime'),
      IOPS?: int32(name='IOPS'),
      IOPSRead?: int32(name='IOPSRead'),
      IOPSWrite?: int32(name='IOPSWrite'),
      imageId?: string(name='ImageId'),
      instanceId?: string(name='InstanceId'),
      KMSKeyId?: string(name='KMSKeyId'),
      mountInstanceNum?: int32(name='MountInstanceNum'),
      mountInstances?: {
        mountInstance?: [ 
        {
          attachedTime?: string(name='AttachedTime'),
          device?: string(name='Device'),
          instanceId?: string(name='InstanceId'),
        }
      ](name='MountInstance')
      }(name='MountInstances'),
      multiAttach?: string(name='MultiAttach'),
      operationLocks?: {
        operationLock?: [ 
        {
          lockReason?: string(name='LockReason'),
        }
      ](name='OperationLock')
      }(name='OperationLocks'),
      performanceLevel?: string(name='PerformanceLevel'),
      portable?: boolean(name='Portable'),
      productCode?: string(name='ProductCode'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      serialNumber?: string(name='SerialNumber'),
      size?: int32(name='Size'),
      sourceSnapshotId?: string(name='SourceSnapshotId'),
      status?: string(name='Status'),
      storageSetId?: string(name='StorageSetId'),
      storageSetPartitionNumber?: int32(name='StorageSetPartitionNumber'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      type?: string(name='Type'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Disk')
  }(name='Disks'),
  nextToken?: string(name='NextToken'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDisksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDisksResponseBody(name='body'),
}

async function describeDisksWithOptions(request: DescribeDisksRequest, runtime: Util.RuntimeOptions): DescribeDisksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.additionalAttributes)) {
    query['AdditionalAttributes'] = request.additionalAttributes;
  }
  if (!Util.isUnset(request.autoSnapshotPolicyId)) {
    query['AutoSnapshotPolicyId'] = request.autoSnapshotPolicyId;
  }
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.deleteAutoSnapshot)) {
    query['DeleteAutoSnapshot'] = request.deleteAutoSnapshot;
  }
  if (!Util.isUnset(request.deleteWithInstance)) {
    query['DeleteWithInstance'] = request.deleteWithInstance;
  }
  if (!Util.isUnset(request.diskChargeType)) {
    query['DiskChargeType'] = request.diskChargeType;
  }
  if (!Util.isUnset(request.diskIds)) {
    query['DiskIds'] = request.diskIds;
  }
  if (!Util.isUnset(request.diskName)) {
    query['DiskName'] = request.diskName;
  }
  if (!Util.isUnset(request.diskType)) {
    query['DiskType'] = request.diskType;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.enableAutoSnapshot)) {
    query['EnableAutoSnapshot'] = request.enableAutoSnapshot;
  }
  if (!Util.isUnset(request.enableAutomatedSnapshotPolicy)) {
    query['EnableAutomatedSnapshotPolicy'] = request.enableAutomatedSnapshotPolicy;
  }
  if (!Util.isUnset(request.enableShared)) {
    query['EnableShared'] = request.enableShared;
  }
  if (!Util.isUnset(request.encrypted)) {
    query['Encrypted'] = request.encrypted;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.KMSKeyId)) {
    query['KMSKeyId'] = request.KMSKeyId;
  }
  if (!Util.isUnset(request.lockReason)) {
    query['LockReason'] = request.lockReason;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.multiAttach)) {
    query['MultiAttach'] = request.multiAttach;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.portable)) {
    query['Portable'] = request.portable;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDisks',
    version = '2010-10-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDisks(request: DescribeDisksRequest): DescribeDisksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDisksWithOptions(request, runtime);
}

model GrayReleaseDemoRequest {
  id?: string(name='Id'),
}

model GrayReleaseDemoResponseBody = {
  code?: string(name='Code'),
  requestId?: string(name='RequestId', description='Id of the request'),
  year?: string(name='Year'),
}

model GrayReleaseDemoResponse = {
  headers: map[string]string(name='headers'),
  body: GrayReleaseDemoResponseBody(name='body'),
}

async function grayReleaseDemoWithOptions(request: GrayReleaseDemoRequest, runtime: Util.RuntimeOptions): GrayReleaseDemoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GrayReleaseDemo',
    version = '2010-10-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function grayReleaseDemo(request: GrayReleaseDemoRequest): GrayReleaseDemoResponse {
  var runtime = new Util.RuntimeOptions{};
  return grayReleaseDemoWithOptions(request, runtime);
}

model ListProductsByPopCodeRequest {
  authKey?: string(name='AuthKey'),
  clientIp?: string(name='ClientIp'),
  env?: string(name='Env'),
  extraParams?: map[string]any(name='ExtraParams'),
  identityDTO?: map[string]any(name='IdentityDTO'),
  popCode?: string(name='PopCode'),
  requestId?: string(name='RequestId'),
  serverClientIp?: string(name='ServerClientIp'),
}

model ListProductsByPopCodeShrinkRequest {
  authKey?: string(name='AuthKey'),
  clientIp?: string(name='ClientIp'),
  env?: string(name='Env'),
  extraParamsShrink?: string(name='ExtraParams'),
  identityDTOShrink?: string(name='IdentityDTO'),
  popCode?: string(name='PopCode'),
  requestId?: string(name='RequestId'),
  serverClientIp?: string(name='ServerClientIp'),
}

model ListProductsByPopCodeResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorDetailMessage?: string(name='ErrorDetailMessage'),
  errorMessage?: string(name='ErrorMessage'),
  result?: [ 
    {
      nameSpaceExtDTO?: {
        businessOwnerList?: [ 
          {
            bucId?: string(name='BucId'),
            id?: string(name='Id'),
            name?: string(name='Name'),
          }
        ](name='BusinessOwnerList'),
        techniqueOwnerList?: [ 
          {
            bucId?: string(name='BucId'),
            id?: string(name='Id'),
            name?: string(name='Name'),
          }
        ](name='TechniqueOwnerList'),
      }(name='NameSpaceExtDTO'),
      uniqueKeyDTO?: {
        namespaceCode?: string(name='NamespaceCode'),
      }(name='UniqueKeyDTO'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListProductsByPopCodeResponse = {
  headers: map[string]string(name='headers'),
  body: ListProductsByPopCodeResponseBody(name='body'),
}

async function listProductsByPopCodeWithOptions(tmpReq: ListProductsByPopCodeRequest, runtime: Util.RuntimeOptions): ListProductsByPopCodeResponse {
  Util.validateModel(tmpReq);
  var request = new ListProductsByPopCodeShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.extraParams)) {
    request.extraParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extraParams, 'ExtraParams', 'json');
  }
  if (!Util.isUnset(tmpReq.identityDTO)) {
    request.identityDTOShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.identityDTO, 'IdentityDTO', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.authKey)) {
    query['AuthKey'] = request.authKey;
  }
  if (!Util.isUnset(request.clientIp)) {
    query['ClientIp'] = request.clientIp;
  }
  if (!Util.isUnset(request.env)) {
    query['Env'] = request.env;
  }
  if (!Util.isUnset(request.popCode)) {
    query['PopCode'] = request.popCode;
  }
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.serverClientIp)) {
    query['ServerClientIp'] = request.serverClientIp;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.extraParamsShrink)) {
    body['ExtraParams'] = request.extraParamsShrink;
  }
  if (!Util.isUnset(request.identityDTOShrink)) {
    body['IdentityDTO'] = request.identityDTOShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListProductsByPopCode',
    version = '2010-10-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProductsByPopCode(request: ListProductsByPopCodeRequest): ListProductsByPopCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProductsByPopCodeWithOptions(request, runtime);
}

model LjxTestRequest {
  id?: string(name='Id'),
}

model LjxTestResponseBody = {
  code?: int32(name='Code', description='code'),
  id?: string(name='Id', description='id'),
  longList?: [ long ](name='LongList', description='longList'),
  maps?: [ 
    {
      param0?: map[string]string(name='Param0', description='param0'),
    }
  ](name='Maps', description='maps'),
  name?: string(name='Name', description='name'),
  requestId?: string(name='RequestId'),
  stringList?: [ string ](name='StringList', description='stringList'),
}

model LjxTestResponse = {
  headers: map[string]string(name='headers'),
  body: LjxTestResponseBody(name='body'),
}

async function ljxTestWithOptions(request: LjxTestRequest, runtime: Util.RuntimeOptions): LjxTestResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'LjxTest',
    version = '2010-10-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function ljxTest(request: LjxTestRequest): LjxTestResponse {
  var runtime = new Util.RuntimeOptions{};
  return ljxTestWithOptions(request, runtime);
}

model RomeGetExecutionResultRequest {
  flowRequestId?: string(name='FlowRequestId'),
}

model RomeGetExecutionResultResponse = {
  headers: map[string]string(name='headers'),
}

async function romeGetExecutionResultWithOptions(request: RomeGetExecutionResultRequest, runtime: Util.RuntimeOptions): RomeGetExecutionResultResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RomeGetExecutionResult',
    version = '2010-10-11',
    protocol = 'HTTP',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function romeGetExecutionResult(request: RomeGetExecutionResultRequest): RomeGetExecutionResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return romeGetExecutionResultWithOptions(request, runtime);
}

model RpcHttpRequest {
  codes?: string(name='Codes'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  number?: string(name='Number'),
}

model RpcHttpResponseBody = {
  id?: string(name='Id'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RpcHttpResponse = {
  headers: map[string]string(name='headers'),
  body: RpcHttpResponseBody(name='body'),
}

async function rpcHttpWithOptions(request: RpcHttpRequest, runtime: Util.RuntimeOptions): RpcHttpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.codes)) {
    query['Codes'] = request.codes;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.number)) {
    query['Number'] = request.number;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RpcHttp',
    version = '2010-10-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rpcHttp(request: RpcHttpRequest): RpcHttpResponse {
  var runtime = new Util.RuntimeOptions{};
  return rpcHttpWithOptions(request, runtime);
}

model TestPutApiAndGetApiResponseBody = {
  requestId?: string(name='RequestId'),
}

model TestPutApiAndGetApiResponse = {
  headers: map[string]string(name='headers'),
  body: TestPutApiAndGetApiResponseBody(name='body'),
}

async function testPutApiAndGetApiWithOptions(runtime: Util.RuntimeOptions): TestPutApiAndGetApiResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'TestPutApiAndGetApi',
    version = '2010-10-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function testPutApiAndGetApi(): TestPutApiAndGetApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return testPutApiAndGetApiWithOptions(runtime);
}

model UpdateListenerRequest {
  backendPorts?: [ 
    {
      fromPort?: int32(name='FromPort'),
      toPort?: int32(name='ToPort'),
    }
  ](name='BackendPorts'),
  certificates?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Certificates'),
  clientAffinity?: string(name='ClientAffinity'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  listenerId?: string(name='ListenerId'),
  name?: string(name='Name'),
  portRanges?: [ 
    {
      fromPort?: int32(name='FromPort'),
      toPort?: int32(name='ToPort'),
    }
  ](name='PortRanges'),
  protocol?: string(name='Protocol'),
  proxyProtocol?: string(name='ProxyProtocol'),
  regionId?: string(name='RegionId'),
}

model UpdateListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateListenerResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateListenerResponseBody(name='body'),
}

async function updateListenerWithOptions(request: UpdateListenerRequest, runtime: Util.RuntimeOptions): UpdateListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backendPorts)) {
    query['BackendPorts'] = request.backendPorts;
  }
  if (!Util.isUnset(request.certificates)) {
    query['Certificates'] = request.certificates;
  }
  if (!Util.isUnset(request.clientAffinity)) {
    query['ClientAffinity'] = request.clientAffinity;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.portRanges)) {
    query['PortRanges'] = request.portRanges;
  }
  if (!Util.isUnset(request.protocol)) {
    query['Protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.proxyProtocol)) {
    query['ProxyProtocol'] = request.proxyProtocol;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateListener',
    version = '2010-10-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateListener(request: UpdateListenerRequest): UpdateListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateListenerWithOptions(request, runtime);
}

