/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'central';
  @endpointMap = {
    cn-beijing = 'adcp.cn-beijing.aliyuncs.com',
    cn-zhangjiakou = 'adcp.cn-zhangjiakou.aliyuncs.com',
    cn-hangzhou = 'adcp.cn-hangzhou.aliyuncs.com',
    cn-shanghai = 'adcp.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'adcp.cn-shenzhen.aliyuncs.com',
    cn-heyuan = 'adcp.cn-heyuan.aliyuncs.com',
    cn-hongkong = 'adcp.cn-hongkong.aliyuncs.com',
    ap-northeast-1 = 'adcp.ap-northeast-1.aliyuncs.com',
    ap-southeast-1 = 'adcp.ap-southeast-1.aliyuncs.com',
    ap-southeast-5 = 'adcp.ap-southeast-5.aliyuncs.com',
    ap-south-1 = 'adcp.ap-south-1.aliyuncs.com',
    ap-southeast-2 = 'adcp.ap-southeast-2.aliyuncs.com',
    ap-southeast-3 = 'adcp.ap-southeast-3.aliyuncs.com',
    cn-chengdu = 'adcp-vpc.cn-chengdu.aliyuncs.com',
    cn-huhehaote = 'adcp.cn-huhehaote.aliyuncs.com',
    cn-qingdao = 'adcp.cn-qingdao.aliyuncs.com',
    cn-shanghai-finance-1 = 'adcp-vpc.cn-shanghai-finance-1.aliyuncs.com',
    cn-wulanchabu = 'adcp.cn-wulanchabu.aliyuncs.com',
    eu-central-1 = 'adcp.eu-central-1.aliyuncs.com',
    eu-west-1 = 'adcp-vpc.eu-west-1.aliyuncs.com',
    me-east-1 = 'adcp.me-east-1.aliyuncs.com',
    us-east-1 = 'adcp.us-east-1.aliyuncs.com',
    us-west-1 = 'adcp.us-west-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('adcp', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AttachClusterToHubRequest {
  attachToMesh?: boolean(name='AttachToMesh'),
  clusterId?: string(name='ClusterId'),
  clusterIds?: string(name='ClusterIds'),
}

model AttachClusterToHubResponseBody = {
  clusterId?: string(name='ClusterId'),
  managedClusterIds?: [ string ](name='ManagedClusterIds'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model AttachClusterToHubResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachClusterToHubResponseBody(name='body'),
}

async function attachClusterToHubWithOptions(request: AttachClusterToHubRequest, runtime: Util.RuntimeOptions): AttachClusterToHubResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.attachToMesh)) {
    query['AttachToMesh'] = request.attachToMesh;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clusterIds)) {
    body['ClusterIds'] = request.clusterIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AttachClusterToHub',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachClusterToHub(request: AttachClusterToHubRequest): AttachClusterToHubResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachClusterToHubWithOptions(request, runtime);
}

model CreateHubClusterRequest {
  apiServerPublicEip?: boolean(name='ApiServerPublicEip'),
  auditLogEnabled?: boolean(name='AuditLogEnabled'),
  isEnterpriseSecurityGroup?: boolean(name='IsEnterpriseSecurityGroup'),
  name?: string(name='Name'),
  profile?: string(name='Profile'),
  regionId?: string(name='RegionId'),
  vSwitches?: string(name='VSwitches'),
  vpcId?: string(name='VpcId'),
}

model CreateHubClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateHubClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHubClusterResponseBody(name='body'),
}

async function createHubClusterWithOptions(request: CreateHubClusterRequest, runtime: Util.RuntimeOptions): CreateHubClusterResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apiServerPublicEip)) {
    body['ApiServerPublicEip'] = request.apiServerPublicEip;
  }
  if (!Util.isUnset(request.auditLogEnabled)) {
    body['AuditLogEnabled'] = request.auditLogEnabled;
  }
  if (!Util.isUnset(request.isEnterpriseSecurityGroup)) {
    body['IsEnterpriseSecurityGroup'] = request.isEnterpriseSecurityGroup;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.profile)) {
    body['Profile'] = request.profile;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vSwitches)) {
    body['VSwitches'] = request.vSwitches;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateHubCluster',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHubCluster(request: CreateHubClusterRequest): CreateHubClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHubClusterWithOptions(request, runtime);
}

model DeleteHubClusterRequest {
  clusterId?: string(name='ClusterId'),
  force?: boolean(name='Force'),
}

model DeleteHubClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model DeleteHubClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHubClusterResponseBody(name='body'),
}

async function deleteHubClusterWithOptions(request: DeleteHubClusterRequest, runtime: Util.RuntimeOptions): DeleteHubClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHubCluster',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHubCluster(request: DeleteHubClusterRequest): DeleteHubClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHubClusterWithOptions(request, runtime);
}

model DescribeHubClusterDetailsRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeHubClusterDetailsResponseBody = {
  cluster?: {
    apiServer?: {
      apiServerEipId?: string(name='ApiServerEipId'),
      enabledPublic?: boolean(name='EnabledPublic'),
      loadBalancerId?: string(name='LoadBalancerId'),
    }(name='ApiServer'),
    clusterInfo?: {
      clusterId?: string(name='ClusterId'),
      clusterSpec?: string(name='ClusterSpec'),
      creationTime?: string(name='CreationTime'),
      errorMessage?: string(name='ErrorMessage'),
      name?: string(name='Name'),
      profile?: string(name='Profile'),
      regionId?: string(name='RegionId'),
      state?: string(name='State'),
      updateTime?: string(name='UpdateTime'),
      version?: string(name='Version'),
    }(name='ClusterInfo'),
    conditions?: [ 
      {
        message?: string(name='Message'),
        reason?: string(name='Reason'),
        status?: string(name='Status'),
        type?: string(name='Type'),
      }
    ](name='Conditions'),
    endpoints?: {
      intranetApiServerEndpoint?: string(name='IntranetApiServerEndpoint'),
      publicApiServerEndpoint?: string(name='PublicApiServerEndpoint'),
    }(name='Endpoints'),
    logConfig?: {
      enableLog?: boolean(name='EnableLog'),
      logProject?: string(name='LogProject'),
      logStoreTTL?: string(name='LogStoreTTL'),
    }(name='LogConfig'),
    meshConfig?: {
      enableMesh?: boolean(name='EnableMesh'),
      meshId?: string(name='MeshId'),
    }(name='MeshConfig'),
    network?: {
      clusterDomain?: string(name='ClusterDomain'),
      IPStack?: string(name='IPStack'),
      securityGroupIDs?: [ string ](name='SecurityGroupIDs'),
      vSwitches?: [ string ](name='VSwitches'),
      vpcId?: string(name='VpcId'),
    }(name='Network'),
  }(name='Cluster'),
  requestId?: string(name='RequestId'),
}

model DescribeHubClusterDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHubClusterDetailsResponseBody(name='body'),
}

async function describeHubClusterDetailsWithOptions(request: DescribeHubClusterDetailsRequest, runtime: Util.RuntimeOptions): DescribeHubClusterDetailsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHubClusterDetails',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHubClusterDetails(request: DescribeHubClusterDetailsRequest): DescribeHubClusterDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHubClusterDetailsWithOptions(request, runtime);
}

model DescribeHubClusterKubeconfigRequest {
  clusterId?: string(name='ClusterId'),
  privateIpAddress?: boolean(name='PrivateIpAddress'),
}

model DescribeHubClusterKubeconfigResponseBody = {
  kubeconfig?: string(name='Kubeconfig'),
  requestId?: string(name='RequestId'),
}

model DescribeHubClusterKubeconfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHubClusterKubeconfigResponseBody(name='body'),
}

async function describeHubClusterKubeconfigWithOptions(request: DescribeHubClusterKubeconfigRequest, runtime: Util.RuntimeOptions): DescribeHubClusterKubeconfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHubClusterKubeconfig',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHubClusterKubeconfig(request: DescribeHubClusterKubeconfigRequest): DescribeHubClusterKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHubClusterKubeconfigWithOptions(request, runtime);
}

model DescribeHubClusterLogsRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeHubClusterLogsResponseBody = {
  logs?: [ 
    {
      clusterId?: string(name='ClusterId'),
      clusterLog?: string(name='ClusterLog'),
      creationTime?: string(name='CreationTime'),
      logLevel?: string(name='LogLevel'),
    }
  ](name='Logs'),
  requestId?: string(name='RequestId'),
}

model DescribeHubClusterLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHubClusterLogsResponseBody(name='body'),
}

async function describeHubClusterLogsWithOptions(request: DescribeHubClusterLogsRequest, runtime: Util.RuntimeOptions): DescribeHubClusterLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHubClusterLogs',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHubClusterLogs(request: DescribeHubClusterLogsRequest): DescribeHubClusterLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHubClusterLogsWithOptions(request, runtime);
}

model DescribeHubClustersRequest {
  profile?: string(name='Profile'),
}

model DescribeHubClustersResponseBody = {
  clusters?: [ 
    {
      apiServer?: {
        apiServerEipId?: string(name='ApiServerEipId'),
        enabledPublic?: boolean(name='EnabledPublic'),
        loadBalancerId?: string(name='LoadBalancerId'),
      }(name='ApiServer'),
      clusterInfo?: {
        clusterId?: string(name='ClusterId'),
        clusterSpec?: string(name='ClusterSpec'),
        creationTime?: string(name='CreationTime'),
        errorMessage?: string(name='ErrorMessage'),
        name?: string(name='Name'),
        profile?: string(name='Profile'),
        regionId?: string(name='RegionId'),
        state?: string(name='State'),
        updateTime?: string(name='UpdateTime'),
        version?: string(name='Version'),
      }(name='ClusterInfo'),
      conditions?: [ 
        {
          message?: string(name='Message'),
          reason?: string(name='Reason'),
          status?: string(name='Status'),
          type?: string(name='Type'),
        }
      ](name='Conditions'),
      endpoints?: {
        intranetApiServerEndpoint?: string(name='IntranetApiServerEndpoint'),
        publicApiServerEndpoint?: string(name='PublicApiServerEndpoint'),
      }(name='Endpoints'),
      logConfig?: {
        enableLog?: boolean(name='EnableLog'),
        logProject?: string(name='LogProject'),
        logStoreTTL?: string(name='LogStoreTTL'),
      }(name='LogConfig'),
      meshConfig?: {
        enableMesh?: boolean(name='EnableMesh'),
        meshId?: string(name='MeshId'),
      }(name='MeshConfig'),
      network?: {
        clusterDomain?: string(name='ClusterDomain'),
        securityGroupIDs?: [ string ](name='SecurityGroupIDs'),
        vSwitches?: [ string ](name='VSwitches'),
        vpcId?: string(name='VpcId'),
      }(name='Network'),
    }
  ](name='Clusters'),
  requestId?: string(name='RequestId'),
}

model DescribeHubClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHubClustersResponseBody(name='body'),
}

async function describeHubClustersWithOptions(request: DescribeHubClustersRequest, runtime: Util.RuntimeOptions): DescribeHubClustersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.profile)) {
    query['Profile'] = request.profile;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHubClusters',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHubClusters(request: DescribeHubClustersRequest): DescribeHubClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHubClustersWithOptions(request, runtime);
}

model DescribeManagedClustersRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeManagedClustersResponseBody = {
  clusters?: [ 
    {
      cluster?: {
        clusterID?: string(name='ClusterID'),
        clusterSpec?: string(name='ClusterSpec'),
        clusterType?: string(name='ClusterType'),
        created?: string(name='Created'),
        currentVersion?: string(name='CurrentVersion'),
        initVersion?: string(name='InitVersion'),
        name?: string(name='Name'),
        profile?: string(name='Profile'),
        region?: string(name='Region'),
        resourceGroupId?: string(name='ResourceGroupId'),
        state?: string(name='State'),
        updated?: string(name='Updated'),
        vSwitchID?: string(name='VSwitchID'),
        vpcID?: string(name='VpcID'),
      }(name='Cluster'),
      meshStatus?: {
        inMesh?: boolean(name='InMesh'),
      }(name='MeshStatus'),
      status?: {
        message?: string(name='Message'),
        state?: string(name='State'),
      }(name='Status'),
    }
  ](name='Clusters'),
  requestId?: string(name='RequestId'),
}

model DescribeManagedClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeManagedClustersResponseBody(name='body'),
}

async function describeManagedClustersWithOptions(request: DescribeManagedClustersRequest, runtime: Util.RuntimeOptions): DescribeManagedClustersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeManagedClusters',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeManagedClusters(request: DescribeManagedClustersRequest): DescribeManagedClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeManagedClustersWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  language?: string(name='Language'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DetachClusterFromHubRequest {
  clusterId?: string(name='ClusterId'),
  clusterIds?: string(name='ClusterIds'),
  detachFromMesh?: boolean(name='DetachFromMesh'),
}

model DetachClusterFromHubResponseBody = {
  clusterId?: string(name='ClusterId'),
  managedClusterIds?: [ string ](name='ManagedClusterIds'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model DetachClusterFromHubResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachClusterFromHubResponseBody(name='body'),
}

async function detachClusterFromHubWithOptions(request: DetachClusterFromHubRequest, runtime: Util.RuntimeOptions): DetachClusterFromHubResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.detachFromMesh)) {
    query['DetachFromMesh'] = request.detachFromMesh;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clusterIds)) {
    body['ClusterIds'] = request.clusterIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetachClusterFromHub',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachClusterFromHub(request: DetachClusterFromHubRequest): DetachClusterFromHubResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachClusterFromHubWithOptions(request, runtime);
}

model UpdateHubClusterFeatureRequest {
  apiServerEipId?: string(name='ApiServerEipId'),
  auditLogEnabled?: boolean(name='AuditLogEnabled'),
  clusterId?: string(name='ClusterId'),
  deletionProtection?: boolean(name='DeletionProtection'),
  enableArgoCD?: boolean(name='EnableArgoCD'),
  enableMesh?: boolean(name='EnableMesh'),
  name?: string(name='Name'),
  publicApiServerEnabled?: boolean(name='PublicApiServerEnabled'),
}

model UpdateHubClusterFeatureResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateHubClusterFeatureResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHubClusterFeatureResponseBody(name='body'),
}

async function updateHubClusterFeatureWithOptions(request: UpdateHubClusterFeatureRequest, runtime: Util.RuntimeOptions): UpdateHubClusterFeatureResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apiServerEipId)) {
    query['ApiServerEipId'] = request.apiServerEipId;
  }
  if (!Util.isUnset(request.auditLogEnabled)) {
    query['AuditLogEnabled'] = request.auditLogEnabled;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.deletionProtection)) {
    query['DeletionProtection'] = request.deletionProtection;
  }
  if (!Util.isUnset(request.enableArgoCD)) {
    query['EnableArgoCD'] = request.enableArgoCD;
  }
  if (!Util.isUnset(request.enableMesh)) {
    query['EnableMesh'] = request.enableMesh;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.publicApiServerEnabled)) {
    query['PublicApiServerEnabled'] = request.publicApiServerEnabled;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHubClusterFeature',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateHubClusterFeature(request: UpdateHubClusterFeatureRequest): UpdateHubClusterFeatureResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHubClusterFeatureWithOptions(request, runtime);
}

