/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'CS';
  @version = '2015-12-15';
  @endpointRule = 'regional';
  @endpointMap = {
    'ap-northeast-2-pop' = 'cs.aliyuncs.com',
    'cn-beijing-finance-pop' = 'cs.aliyuncs.com',
    'cn-beijing-gov-1' = 'cs.aliyuncs.com',
    'cn-beijing-nu16-b01' = 'cs.aliyuncs.com',
    'cn-edge-1' = 'cs.aliyuncs.com',
    'cn-fujian' = 'cs.aliyuncs.com',
    'cn-haidian-cm12-c01' = 'cs.aliyuncs.com',
    'cn-hangzhou-bj-b01' = 'cs.aliyuncs.com',
    'cn-hangzhou-internal-prod-1' = 'cs.aliyuncs.com',
    'cn-hangzhou-internal-test-1' = 'cs.aliyuncs.com',
    'cn-hangzhou-internal-test-2' = 'cs.aliyuncs.com',
    'cn-hangzhou-internal-test-3' = 'cs.aliyuncs.com',
    'cn-hangzhou-test-306' = 'cs.aliyuncs.com',
    'cn-hongkong-finance-pop' = 'cs.aliyuncs.com',
    'cn-qingdao-nebula' = 'cs.aliyuncs.com',
    'cn-shanghai-et15-b01' = 'cs.aliyuncs.com',
    'cn-shanghai-et2-b01' = 'cs.aliyuncs.com',
    'cn-shanghai-inner' = 'cs.aliyuncs.com',
    'cn-shanghai-internal-test-1' = 'cs.aliyuncs.com',
    'cn-shenzhen-inner' = 'cs.aliyuncs.com',
    'cn-shenzhen-st4-d01' = 'cs.aliyuncs.com',
    'cn-shenzhen-su18-b01' = 'cs.aliyuncs.com',
    'cn-wuhan' = 'cs.aliyuncs.com',
    'cn-yushanfang' = 'cs.aliyuncs.com',
    'cn-zhangbei' = 'cs.aliyuncs.com',
    'cn-zhangbei-na61-b01' = 'cs.aliyuncs.com',
    'cn-zhangjiakou-na62-a01' = 'cs.aliyuncs.com',
    'cn-zhengzhou-nebula-1' = 'cs.aliyuncs.com',
    'eu-west-1-oxs' = 'cs.aliyuncs.com',
    'rus-west-1-pop' = 'cs.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model Addon {
  config?: string(name='config', example='{\\"IngressSlbNetworkType\\":\\"internet\\"}'),
  disabled?: boolean(name='disabled', example='false'),
  name?: string(name='name', example='nginx-ingress-controller'),
  version?: string(name='version', example='v1.9.3-aliyun.1'),
}

model ContainerdConfig {
  insecureRegistries?: [ string ](name='insecureRegistries'),
  registryMirrors?: [ string ](name='registryMirrors'),
}

model DataDisk {
  autoFormat?: boolean(name='auto_format', example='true'),
  autoSnapshotPolicyId?: string(name='auto_snapshot_policy_id', example='sp-2zej1nogjvovnz4z****'),
  burstingEnabled?: boolean(name='bursting_enabled', example='true'),
  category?: string(name='category', example='cloud_ssd'),
  device?: string(name='device', example='/dev/xvdb'),
  diskName?: string(name='disk_name', example='DataDiskName'),
  encrypted?: string(name='encrypted', example='true'),
  fileSystem?: string(name='file_system', example='ext4'),
  kmsKeyId?: string(name='kms_key_id', example='0e478b7a-4262-4802-b8cb-00d3fb40****'),
  mountTarget?: string(name='mount_target', example='/mnt/path1'),
  performanceLevel?: string(name='performance_level', example='PL1'),
  provisionedIops?: long(name='provisioned_iops', example='1000'),
  size?: long(name='size', example='40'),
  snapshotId?: string(name='snapshot_id', example='s-280s7****'),
}

model InstancePatterns {
  architectures?: [ string ](name='architectures', deprecated='true'),
  burstPerformanceOption?: string(name='burst_performance_option', example='Exclude', deprecated='true'),
  core?: long(name='core', example='4', deprecated='true'),
  cores?: long(name='cores', example='4'),
  cpuArchitectures?: [ string ](name='cpu_architectures'),
  excludedInstanceTypes?: [ string ](name='excluded_instance_types'),
  instanceCategories?: [ string ](name='instance_categories'),
  instanceFamilyLevel?: string(name='instance_family_level', example='EnterpriseLevel'),
  instanceTypeFamilies?: [ string ](name='instance_type_families'),
  maxCpuCores?: long(name='max_cpu_cores', example='8'),
  maxMemorySize?: float(name='max_memory_size', example='16'),
  maxPrice?: float(name='max_price', example='2', deprecated='true'),
  maximumGpuAmount?: long(name='maximum_gpu_amount'),
  memory?: float(name='memory', example='8'),
  minCpuCores?: long(name='min_cpu_cores', example='4'),
  minMemorySize?: float(name='min_memory_size', example='8'),
  minimumEniIpv6AddressQuantity?: long(name='minimum_eni_ipv6_address_quantity'),
  minimumEniPrivateIpAddressQuantity?: long(name='minimum_eni_private_ip_address_quantity'),
  minimumEniQuantity?: long(name='minimum_eni_quantity'),
}

model KubeletConfig {
  allowedUnsafeSysctls?: [ string ](name='allowedUnsafeSysctls'),
  clusterDNS?: [ string ](name='clusterDNS'),
  containerLogMaxFiles?: long(name='containerLogMaxFiles', example='5'),
  containerLogMaxSize?: string(name='containerLogMaxSize', example='10Mi'),
  containerLogMaxWorkers?: int32(name='containerLogMaxWorkers', example='1'),
  containerLogMonitorInterval?: string(name='containerLogMonitorInterval', example='10s'),
  cpuCFSQuota?: boolean(name='cpuCFSQuota', example='true'),
  cpuCFSQuotaPeriod?: string(name='cpuCFSQuotaPeriod', example='100ms'),
  cpuManagerPolicy?: string(name='cpuManagerPolicy', example='none'),
  eventBurst?: long(name='eventBurst', example='10'),
  eventRecordQPS?: long(name='eventRecordQPS', example='5'),
  evictionHard?: map[string]any(name='evictionHard'),
  evictionSoft?: map[string]any(name='evictionSoft'),
  evictionSoftGracePeriod?: map[string]any(name='evictionSoftGracePeriod'),
  featureGates?: map[string]any(name='featureGates'),
  imageGCHighThresholdPercent?: int32(name='imageGCHighThresholdPercent', example='85'),
  imageGCLowThresholdPercent?: int32(name='imageGCLowThresholdPercent', example='80'),
  kubeAPIBurst?: long(name='kubeAPIBurst', example='10'),
  kubeAPIQPS?: long(name='kubeAPIQPS', example='5'),
  kubeReserved?: map[string]any(name='kubeReserved'),
  maxPods?: long(name='maxPods', example='110'),
  memoryManagerPolicy?: string(name='memoryManagerPolicy', example='none'),
  podPidsLimit?: long(name='podPidsLimit', example='-1'),
  readOnlyPort?: long(name='readOnlyPort', example='0'),
  registryBurst?: long(name='registryBurst', example='10'),
  registryPullQPS?: long(name='registryPullQPS', example='5'),
  reservedMemory?: [ 
    {
      limits?: map[string]any(name='limits'),
      numaNode?: int32(name='numaNode'),
    }
  ](name='reservedMemory'),
  serializeImagePulls?: boolean(name='serializeImagePulls', example='true'),
  systemReserved?: map[string]any(name='systemReserved'),
  topologyManagerPolicy?: string(name='topologyManagerPolicy', example='restricted'),
  tracing?: {
    endpoint?: string(name='endpoint', example='localhost:4317'),
    samplingRatePerMillion?: int32(name='samplingRatePerMillion'),
  }(name='tracing'),
}

model MaintenanceWindow {
  duration?: string(name='duration', example='3h'),
  enable?: boolean(name='enable', example='false'),
  maintenanceTime?: string(name='maintenance_time', example='2020-10-15T12:31:00.000+08:00'),
  recurrence?: string(name='recurrence', example='FREQ=WEEKLY;INTERVAL=4;BYDAY=MO,TU'),
  weeklyPeriod?: string(name='weekly_period', example='Monday,Thursday'),
}

model Nodepool {
  autoScaling?: {
    eipBandwidth?: long(name='eip_bandwidth', example='5', deprecated='true'),
    eipInternetChargeType?: string(name='eip_internet_charge_type', example='PayByBandwidth', deprecated='true'),
    enable: boolean(name='enable', description='This parameter is required.', example='true'),
    isBondEip?: boolean(name='is_bond_eip', example='true', deprecated='true'),
    maxInstances: long(name='max_instances', description='This parameter is required.', example='10'),
    minInstances: long(name='min_instances', description='This parameter is required.', example='0'),
    type?: string(name='type', example='cpu'),
  }(name='auto_scaling'),
  count?: long(name='count', example='1', deprecated='true'),
  interconnectConfig?: {
    bandwidth?: long(name='bandwidth', example='10', deprecated='true'),
    ccnId?: string(name='ccn_id', example='ccn-qm5i0i0q9yi*******', deprecated='true'),
    ccnRegionId?: string(name='ccn_region_id', example='cn-shanghai', deprecated='true'),
    cenId?: string(name='cen_id', example='cen-ey9k9nfhz0f*******', deprecated='true'),
    improvedPeriod?: string(name='improved_period', example='1', deprecated='true'),
  }(name='interconnect_config', deprecated='true'),
  interconnectMode?: string(name='interconnect_mode', example='basic'),
  kubernetesConfig?: {
    cmsEnabled?: boolean(name='cms_enabled', example='true'),
    cpuPolicy?: string(name='cpu_policy', example='none'),
    labels?: [
      Tag
    ](name='labels'),
    nodeNameMode?: string(name='node_name_mode', example='customized,test.,5,.com'),
    runtime: string(name='runtime', description='This parameter is required.', example='docker'),
    runtimeVersion: string(name='runtime_version', description='This parameter is required.', example='19.03.5'),
    taints?: [
      Taint
    ](name='taints'),
    userData?: string(name='user_data', example='MXM='),
  }(name='kubernetes_config'),
  management?: {
    autoRepair?: boolean(name='auto_repair', example='true'),
    autoRepairPolicy?: {
      restartNode?: boolean(name='restart_node', example='true'),
    }(name='auto_repair_policy'),
    autoUpgrade?: boolean(name='auto_upgrade', example='true'),
    autoUpgradePolicy?: {
      autoUpgradeKubelet?: boolean(name='auto_upgrade_kubelet', example='true'),
    }(name='auto_upgrade_policy'),
    autoVulFix?: boolean(name='auto_vul_fix', example='true'),
    autoVulFixPolicy?: {
      restartNode?: boolean(name='restart_node', example='true'),
      vulLevel?: string(name='vul_level', example='asap,nntf'),
    }(name='auto_vul_fix_policy'),
    enable?: boolean(name='enable', example='true'),
    upgradeConfig?: {
      autoUpgrade?: boolean(name='auto_upgrade', example='true'),
      maxUnavailable?: long(name='max_unavailable', example='1'),
      surge?: long(name='surge', example='5'),
      surgePercentage?: long(name='surge_percentage', example='50'),
    }(name='upgrade_config', deprecated='true'),
  }(name='management'),
  maxNodes?: long(name='max_nodes', example='10'),
  nodeConfig?: {
    kubeletConfiguration?: KubeletConfig(name='kubelet_configuration'),
  }(name='node_config'),
  nodepoolInfo?: {
    name: string(name='name', description='This parameter is required.', example='np-test'),
    resourceGroupId?: string(name='resource_group_id', example='rg-acfmyvw3wjm****'),
    type?: string(name='type', example='ess'),
  }(name='nodepool_info'),
  scalingGroup?: {
    autoRenew?: boolean(name='auto_renew', example='false'),
    autoRenewPeriod?: long(name='auto_renew_period', example='0'),
    compensateWithOnDemand?: boolean(name='compensate_with_on_demand', example='true'),
    dataDisks?: [
      DataDisk
    ](name='data_disks'),
    deploymentsetId?: string(name='deploymentset_id', example='ds-bp1d19mmbsv3jf6xxxxx'),
    desiredSize?: long(name='desired_size', example='2'),
    imageId?: string(name='image_id', example='aliyun_2_1903_x64_20G_alibase_20200904.vhd'),
    imageType?: string(name='image_type', example='AliyunLinux'),
    instanceChargeType: string(name='instance_charge_type', description='This parameter is required.', example='PostPaid'),
    instanceTypes: [ string ](name='instance_types', description='This parameter is required.'),
    internetChargeType?: string(name='internet_charge_type', example='PayByBandwidth'),
    internetMaxBandwidthOut?: long(name='internet_max_bandwidth_out', example='10'),
    keyPair?: string(name='key_pair', example='np-key'),
    loginAsNonRoot?: boolean(name='login_as_non_root'),
    loginPassword?: string(name='login_password', example='Hello1234,,'),
    multiAzPolicy?: string(name='multi_az_policy', example='COST_OPTIMIZED'),
    onDemandBaseCapacity?: long(name='on_demand_base_capacity', example='0'),
    onDemandPercentageAboveBaseCapacity?: long(name='on_demand_percentage_above_base_capacity', example='20'),
    period?: long(name='period', example='0'),
    periodUnit?: string(name='period_unit', example='Month'),
    platform?: string(name='platform', example='AliyunLinux', deprecated='true'),
    privatePoolOptions?: {
      id?: string(name='id'),
      matchCriteria?: string(name='match_criteria'),
    }(name='private_pool_options'),
    ramRoleName?: string(name='ram_role_name', example='example-role'),
    rdsInstances?: [ string ](name='rds_instances'),
    scalingPolicy?: string(name='scaling_policy', example='release'),
    securityGroupId?: string(name='security_group_id', example='sg-2zeihch86ooz9io4****'),
    securityGroupIds?: [ string ](name='security_group_ids'),
    spotInstancePools?: long(name='spot_instance_pools', example='5'),
    spotInstanceRemedy?: boolean(name='spot_instance_remedy', example='false'),
    spotPriceLimit?: [ 
      {
        instanceType?: string(name='instance_type', example='ecs.c6.large'),
        priceLimit?: string(name='price_limit', example='0.39'),
      }
    ](name='spot_price_limit'),
    spotStrategy?: string(name='spot_strategy', example='NoSpot'),
    systemDiskBurstingEnabled?: boolean(name='system_disk_bursting_enabled', example='true'),
    systemDiskCategories?: [ string ](name='system_disk_categories'),
    systemDiskCategory?: string(name='system_disk_category', example='cloud_efficiency'),
    systemDiskEncryptAlgorithm?: string(name='system_disk_encrypt_algorithm', example='aes-256'),
    systemDiskEncrypted?: boolean(name='system_disk_encrypted'),
    systemDiskKmsKeyId?: string(name='system_disk_kms_key_id', example='0e478b7a-4262-4802-b8cb-00d3fb40****'),
    systemDiskPerformanceLevel?: string(name='system_disk_performance_level', example='PL1'),
    systemDiskProvisionedIops?: long(name='system_disk_provisioned_iops', example='1000'),
    systemDiskSize?: long(name='system_disk_size', example='120'),
    tags?: [ 
      {
        key?: string(name='key', example='key'),
        value?: string(name='value', example='value'),
      }
    ](name='tags'),
    vswitchIds: [ string ](name='vswitch_ids', description='This parameter is required.'),
  }(name='scaling_group'),
  teeConfig?: {
    teeEnable: boolean(name='tee_enable', description='This parameter is required.', example='false'),
  }(name='tee_config'),
}

model Runtime {
  name?: string(name='name', example='docker'),
  version?: string(name='version', example='19.03.5'),
}

model Tag {
  key?: string(name='key', example='env'),
  value?: string(name='value', example='prod'),
}

model Taint {
  effect?: string(name='effect', example='NoSchedule'),
  key?: string(name='key', example='key'),
  value?: string(name='value', example='value'),
}

model AttachInstancesRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c106f377e16f34eb1808d6b9362c9****', position='Path'),
  cpuPolicy?: string(name='cpu_policy', description='The CPU management policy of the node. The following policies are supported if the Kubernetes version of the cluster is 1.12.6 or later:

*   `static`: allows pods with specific resource characteristics on the node to be granted enhanced CPU affinity and exclusivity.
*   `none`: uses default CPU affinity.

Default value: `none`

>  This parameter is not supported if you specify `nodepool_id`.', example='none', position='Body'),
  formatDisk?: boolean(name='format_disk', description='Specifies whether to store container data and images on data disks. Valid value:

*   `true`: stores container data and images on data disks.
*   `false`: does not store container data or images on data disks.

Default value: `false`.

How data disks are attached:

*   If the ECS instance is already attached with data disks and the file system of the last data disk is not initialized, the system automatically formats this data disk to ext4. Then, the system uses the disk to store the data in the /var/lib/docker and /var/lib/kubelet directories.
*   If no data disk is attached to the ECS instance, the system does not purchase a new data disk.

>  If you choose to store container data and images on data disks and a data disk is already attached to the ECS instance, the original data on this data disk is cleared. You can back up the disk to prevent data loss.', example='false', position='Body'),
  imageId?: string(name='image_id', description='The custom image ID. If you do not specify this parameter, the default system image is used.

> 

*   If you specify a custom image, the custom image is used to deploy the operating system on the system disk of the node.

*   This parameter is not supported if you specify `nodepool_id`.', example='aliyun_2_1903_x64_20G_alibase_20200529.vhd', position='Body'),
  instances: [ string ](name='instances', description='The ECS instances that you want to add.

This parameter is required.', position='Body'),
  isEdgeWorker?: boolean(name='is_edge_worker', description='Specifies whether the node that you want to add is an Edge Node Service (ENS) node. Valid value:

*   `true`: the node that you want to add is an ENS node.
*   `false`: the node that you want to add is not an ENS node.

Default value: `false`.

>  If the node that you want to add is an ENS node, you must set the value to `true`. This allows you to identify the node.', example='false', position='Body'),
  keepInstanceName?: boolean(name='keep_instance_name', description='Specifies whether to retain the instance name. Valid value:

*   `true`: retains the instance name.
*   `false`: does not retain the instance name.

Default value: `false`.', example='true', position='Body'),
  keyPair?: string(name='key_pair', description='The name of the key pair used to log on to the ECS instances. You must specify this parameter or `login_password`.

>  This parameter is not supported if you specify `nodepool_id`.', example='secrity-key', position='Body'),
  nodepoolId?: string(name='nodepool_id', description='The ID of the node pool to which the node is added. If you do not specify this parameter, the node is added to the default node pool.', example='np615c0e0966124216a0412e10afe0****', position='Body'),
  password?: string(name='password', description='The SSH logon password used to log on to the ECS instances. You must specify this parameter or `key_pair`. The password must be 8 to 30 characters in length, and must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. The password cannot contain backslashes (\\\\) or double quotation marks (").

The password is encrypted during data transfer to ensure security.', example='Hello1234', position='Body'),
  rdsInstances?: [ string ](name='rds_instances', description='A list of ApsaraDB RDS instances.', position='Body'),
  runtime?: Runtime(name='runtime', description='The container runtime.

>  This parameter is not supported if you specify `nodepool_id`.', position='Body'),
  tags?: [
    Tag
  ](name='tags', description='The labels that you want to add to the node. When you add labels to a node, the following rules apply:

*   A label is a case-sensitive key-value pair. You can add up to 20 labels.
*   The key must be unique and cannot exceed 64 characters in length. The value can be empty and cannot exceed 128 characters in length. Keys and values cannot start with `aliyun`, `acs:`, `https://`, or `http://`. For more information, see [Labels and Selectors](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set).

>  This parameter is not supported if you specify `nodepool_id`.', position='Body'),
  userData?: string(name='user_data', description='The user-defined data on the node. For more information, see [Use instance user data to automatically run commands or scripts on instance startup](https://help.aliyun.com/document_detail/49121.html).

>  This parameter is not supported if you specify `nodepool_id`.', example='IyEvdXNyL2Jpbi9iYXNoCmVjaG8gIkhlbGxvIEFDSyEi', position='Body'),
}

model AttachInstancesResponseBody = {
  list?: [ 
    {
      code?: string(name='code', description='The code that indicates the task result.', example='200'),
      instanceId?: string(name='instanceId', description='The ID of the ECS instance.', example='i-2ze0lgm3y6iylcbt****'),
      message?: string(name='message', description='Indicates whether the ECS instance is successfully added to the ACK cluster.', example='successful'),
    }
  ](name='list', description='The details of the added nodes.'),
  taskId?: string(name='task_id', description='The task ID.', example='T-5a544aff80282e39ea000039'),
}

model AttachInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AttachInstancesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AttachInstances  AttachInstancesRequest
  * @return AttachInstancesResponse
 */
async function attachInstances(request: AttachInstancesRequest): AttachInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AttachInstances', 'POST', '/clusters/{ClusterId}/attach', 'json', false, 'json', request);
}

model AttachInstancesToNodePoolRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
  nodepoolId: string(name='NodepoolId', description='The node pool ID.

This parameter is required.', example='np31da1b38983f4511b490fc62108a****', position='Path'),
  formatDisk?: boolean(name='format_disk', description='Specifies whether to store container data and images on data disks. Valid values:

*   `true`: stores container data and images on data disks.
*   `false`: does not store container data or images on data disks.

Default value: `false`.

How to mount a data disk:

*   If the ECS instances are already mounted with data disks and the file system of the last data disk is not initialized, the system automatically formats this data disk to ext4 and mounts it to /var/lib/docker and /var/lib/kubelet.
*   If no data disk is attached to the ECS instances, the system does not purchase a new data disk.

> If you choose to store container data and images on a data disk and the data disk is already mounted to the ECS instance, the existing data on the data disk will be cleared. You can back up the disk to avoid data loss.', example='false', position='Body'),
  instances?: [ string ](name='instances', description='The IDs of the instances to be added.', position='Body'),
  keepInstanceName?: boolean(name='keep_instance_name', description='Specifies whether to retain the instance name. Valid values:

*   `true`: retains the instance name.
*   `false`: does not retain the instance name.

Default value: `true`.', example='true', position='Body'),
  password?: string(name='password', description='The SSH password that is used to log on to the instance.', example='Hello1234', position='Body'),
}

model AttachInstancesToNodePoolResponseBody = {
  requestId?: string(name='request_id', description='The request ID.', example='D7631D83-6E98-1949-B665-766A62xxxxxx'),
  taskId?: string(name='task_id', description='The task ID.', example='T-5a54309c80282e39ea00002f'),
}

model AttachInstancesToNodePoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AttachInstancesToNodePoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AttachInstancesToNodePool  AttachInstancesToNodePoolRequest
  * @return AttachInstancesToNodePoolResponse
 */
async function attachInstancesToNodePool(request: AttachInstancesToNodePoolRequest): AttachInstancesToNodePoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AttachInstancesToNodePool', 'POST', '/clusters/{ClusterId}/nodepools/{NodepoolId}/attach', 'json', false, 'json', request);
}

model CancelClusterUpgradeRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c106f377e16f34eb1808d6b9362c9****', position='Path'),
}

model CancelClusterUpgradeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @deprecated OpenAPI CancelClusterUpgrade is deprecated, please use CS::2015-12-15::CancelTask instead.  * @param request  the request parameters of CancelClusterUpgrade  CancelClusterUpgradeRequest
  * @return CancelClusterUpgradeResponse
 */
// Deprecated
async function cancelClusterUpgrade(request: CancelClusterUpgradeRequest): CancelClusterUpgradeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CancelClusterUpgrade', 'POST', '/api/v2/clusters/{ClusterId}/upgrade/cancel', 'none', false, 'json', request);
}

model CancelComponentUpgradeRequest {
  clusterId: string(name='clusterId', description='The cluster ID.

This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
  componentId: string(name='componentId', description='The component ID.

This parameter is required.', example='metric-server', position='Path'),
}

model CancelComponentUpgradeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @deprecated OpenAPI CancelComponentUpgrade is deprecated, please use CS::2015-12-15::CancelTask instead.  * @param request  the request parameters of CancelComponentUpgrade  CancelComponentUpgradeRequest
  * @return CancelComponentUpgradeResponse
 */
// Deprecated
async function cancelComponentUpgrade(request: CancelComponentUpgradeRequest): CancelComponentUpgradeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CancelComponentUpgrade', 'POST', '/clusters/{clusterId}/components/{componentId}/cancel', 'none', false, 'json', request);
}

model CancelOperationPlanRequest {
  planId?: string(name='plan_id', description='The ID of the O\\&M plan.', example='P-655c9c127e0e6603ef00****', position='Path'),
}

model CancelOperationPlanResponseBody = {
  requestId?: string(name='request_id', description='The request ID.', example='db82195b-75a8-40e5-9be4-16f1829dc624'),
}

model CancelOperationPlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelOperationPlanResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CancelOperationPlan  CancelOperationPlanRequest
  * @return CancelOperationPlanResponse
 */
async function cancelOperationPlan(request: CancelOperationPlanRequest): CancelOperationPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CancelOperationPlan', 'DELETE', '/operation/plans/{plan_id}', 'json', false, 'json', request);
}

model CancelTaskRequest {
  taskId: string(name='task_id', description='The ID of the task.

This parameter is required.', example='T-62ccd14aacb8db06ca00****', position='Path'),
}

model CancelTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of CancelTask  CancelTaskRequest
  * @return CancelTaskResponse
 */
async function cancelTask(request: CancelTaskRequest): CancelTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CancelTask', 'POST', '/tasks/{task_id}/cancel', 'none', false, 'json', request);
}

model CheckControlPlaneLogEnableRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c5b5e80b0b64a4bf6939d2d8fbbc5****', position='Path'),
}

model CheckControlPlaneLogEnableResponseBody = {
  aliuid?: string(name='aliuid', description='The ID of the Alibaba Cloud account to which the resource belongs.', example='162981*****'),
  components: [ string ](name='components', description='The control plane components for which log collection is enabled.

This parameter is required.'),
  logProject?: string(name='log_project', description='The name of the Simple Log Service project that you want to use to store the logs of control plane components.

Default value: k8s-log-$Cluster ID.', example='k8s-log-c5b5e80b0b64a4bf6939d2d8fbbc5****'),
  logTtl?: string(name='log_ttl', description='The retention period of the log data stored in the Logstore. Valid values: 1 to 3000. Unit: days.

Default value: 30.', example='30'),
}

model CheckControlPlaneLogEnableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckControlPlaneLogEnableResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CheckControlPlaneLogEnable  CheckControlPlaneLogEnableRequest
  * @return CheckControlPlaneLogEnableResponse
 */
async function checkControlPlaneLogEnable(request: CheckControlPlaneLogEnableRequest): CheckControlPlaneLogEnableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CheckControlPlaneLogEnable', 'GET', '/clusters/{ClusterId}/controlplanelog', 'json', false, 'json', request);
}

model CheckServiceRoleRequest {
  roles: [ 
    {
      name: string(name='name', description='The server role name. For more information about the service roles and their permissions in ACK, see [ACK roles](https://help.aliyun.com/document_detail/86483.html).

This parameter is required.', example='AliyunCSManagedAutoScalerRole'),
    }
  ](name='roles', description='The list of service roles you want to check.

This parameter is required.', position='Body'),
}

model CheckServiceRoleResponseBody = {
  roles?: [ 
    {
      granted?: boolean(name='granted', description='Indicates whether the service role is assigned to ACK.

Valid values:

*   true: The role is assigned to ACK.
*   false: The role is not assigned to ACK.', example='true'),
      message?: string(name='message', description='The message that is displayed for a role that is not assigned to ACK.', example='The role does not exist: AliyunCSManagedAutoScalerRole'),
      name?: string(name='name', description='The name of the service role.', example='AliyunCSManagedAutoScalerRole'),
    }
  ](name='roles', description='The check results.'),
}

model CheckServiceRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckServiceRoleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CheckServiceRole  CheckServiceRoleRequest
  * @return CheckServiceRoleResponse
 */
async function checkServiceRole(request: CheckServiceRoleRequest): CheckServiceRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CheckServiceRole', 'POST', '/ram/check-service-role', 'json', false, 'json', request);
}

model CleanClusterUserPermissionsRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

This parameter is required.', example='c5b5e80b0b64a4bf6939d2d8fbbc5****', position='Path'),
  uid: string(name='Uid', description='The ID of the specified Resource Access Management (RAM) user or RAM role within the Alibaba Cloud account.

This parameter is required.', example='2xxxxxxxxxxxxxxxxxx', position='Path'),
  force?: boolean(name='Force', description='Specifies whether to forcefully delete the specified kubeconfig files. Valid values:

*   false (default): checks the cluster access records within the previous seven days before deleting the kubeconfig files. The kubeconfig files are not deleted if cluster access records are found or fail to be retrieved.
*   true: forcefully deletes the kubeconfig files without checking the cluster access records.', example='false', position='Query'),
}

model CleanClusterUserPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @description > 
  * *   To call this operation, make sure that you have the AliyunCSFullAccess permission.
  * *   You cannot revoke the permissions of an Alibaba Cloud account.
  * *   You cannot revoke the permissions of the account that you use to call this operation.
  * @param request  the request parameters of CleanClusterUserPermissions  CleanClusterUserPermissionsRequest
  * @return CleanClusterUserPermissionsResponse
 */
async function cleanClusterUserPermissions(request: CleanClusterUserPermissionsRequest): CleanClusterUserPermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CleanClusterUserPermissions', 'DELETE', '/cluster/{ClusterId}/user/{Uid}/permissions', 'none', false, 'json', request);
}

model CleanUserPermissionsRequest {
  uid: string(name='Uid', description='The ID of the specified Resource Access Management (RAM) user or RAM role within the Alibaba Cloud account.

This parameter is required.', example='26562443851650****', position='Path'),
  clusterIds?: [ string ](name='ClusterIds', description='The cluster IDs. If you specify a list of cluster IDs, only the kubeconfig files and RBAC permissions of the clusters that belong to the current user in the list are revoked.', shrink='simple', position='Query'),
  force?: boolean(name='Force', description='Specifies whether to forcefully delete the specified kubeconfig files. Valid values:

*   false (default): checks the cluster access records within the previous seven days before deleting the kubeconfig files. The kubeconfig files are not deleted if cluster access records are found or fail to be retrieved.
*   true: forcefully deletes the kubeconfig files without checking the cluster access records.', example='false', position='Query'),
}

model CleanUserPermissionsResponseBody = {
  requestId?: string(name='request_id', description='The request ID.', example='687C5BAA-D103-4993-884B-C35E4314****'),
  taskId?: string(name='task_id', description='The task ID.', example='clean-user-permissions-2085266204********-6694c16e6ae07***********'),
}

model CleanUserPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CleanUserPermissionsResponseBody(name='body'),
}

/**
  * @description > - To call this operation, make sure that you have the AliyunCSFullAccess permission.
  * > - You cannot revoke the permissions of an Alibaba Cloud account.
  * > - You cannot revoke the permissions of the account that you use to call this operation.
  * @param request  the request parameters of CleanUserPermissions  CleanUserPermissionsRequest
  * @return CleanUserPermissionsResponse
 */
async function cleanUserPermissions(request: CleanUserPermissionsRequest): CleanUserPermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CleanUserPermissions', 'DELETE', '/users/{Uid}/permissions', 'json', false, 'json', request);
}

model CreateAutoscalingConfigRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c0XXXXXXX10', position='Path'),
  coolDownDuration?: string(name='cool_down_duration', description='The waiting time before the auto scaling feature performs a scale-in activity. It is an interval between the time when the scale-in threshold is reached and the time when the scale-in activity (reducing the number of pods) starts. Unit: minutes. Default value: 10.', example='10 m', position='Body'),
  daemonsetEvictionForNodes?: boolean(name='daemonset_eviction_for_nodes', description='Specifies whether to evict pods created by DaemonSets when the cluster autoscaler performs a scale-in activity. Valid values:

*   `true`: evicts DaemonSet pods.
*   `false`: does not evict DaemonSet pods.', example='false', position='Body'),
  expander?: string(name='expander', description='The node pool scale-out policy. Valid values:

*   `least-waste`: the default policy. If multiple node pools meet the requirement, this policy selects the node pool that will have the least idle resources after the scale-out activity is completed.
*   `random`: the random policy. If multiple node pools meet the requirement, this policy selects a random node pool for the scale-out activity.
*   `priority`: the priority-based policy If multiple node pools meet the requirement, this policy selects the node pool with the highest priority for the scale-out activity. The priority setting is stored in the ConfigMap named `cluster-autoscaler-priority-expander` in the kube-system namespace. When a scale-out activity is triggered, the policy obtains the node pool priorities from the ConfigMap based on the node pool IDs and then selects the node pool with the highest priority for the scale-out activity.', example='least-waste', position='Body'),
  gpuUtilizationThreshold?: string(name='gpu_utilization_threshold', description='The scale-in threshold of GPU utilization. This threshold specifies the ratio of the GPU resources that are requested by pods to the total GPU resources on the node.

A scale-in activity is performed only when the CPU utilization, memory utilization, and GPU utilization of a GPU-accelerated node are lower than the scale-in threshold of GPU utilization.', example='0.5', position='Body'),
  maxGracefulTerminationSec?: int32(name='max_graceful_termination_sec', description='The maximum amount of time to wait for pods on a node to terminate during a scale-in activity. Unit: seconds.', example='14400s', position='Body'),
  minReplicaCount?: int32(name='min_replica_count', description='The minimum number of pods allowed in each ReplicaSet before a scale-in activity is performed.', example='0', position='Body'),
  priorities?: map[string][ string ](name='priorities', description='Auto-scaling priority configuration. After creating a node pool with elasticity enabled, you can choose whether to configure a priority strategy and priority settings through [Enabling Node Auto-scaling](https://help.aliyun.com/document_detail/119099.html). This allows you to set priorities for the specified auto-scaling node pool scaling group. The priority value range is [1, 100] and must be a positive integer.', position='Body'),
  recycleNodeDeletionEnabled?: boolean(name='recycle_node_deletion_enabled', description='Specifies whether to delete the corresponding Kubernetes node objects after nodes are removed in swift mode. For more information about the swift mode, see [Scaling mode](https://help.aliyun.com/document_detail/119099.html). Default value: false Valid values:

*   `true`: deletes the corresponding Kubernetes node objects after nodes are removed in swift mode. We recommend that you do not set the value to true because data inconsistency may occur in Kubernetes objects.
*   `false`: retains the corresponding Kubernetes node objects after nodes are removed in swift mode.', example='false', position='Body'),
  scaleDownEnabled?: boolean(name='scale_down_enabled', description='Specifies whether to allow node scale-in activities. Valid values:

*   `true`: allows node scale-in activities.
*   `false`: does not allow node scale-in activities.', example='true', position='Body'),
  scaleUpFromZero?: boolean(name='scale_up_from_zero', description='Specifies whether the cluster autoscaler performs a scale-out activity when the number of ready nodes in the cluster is 0. Default value: true. Valid values:

*   `true`: performs a scale-out activity.
*   `false`: does not perform a scale-out activity.', example='true', position='Body'),
  scalerType?: string(name='scaler_type', description='Elastic component type, default is goatscaler for cluster version 1.24 and above, and cluster-autoscaler below that. Values:

- `goatscaler`: Instant elasticity. 
- `cluster-autoscaler`: Auto-scaling.', example='goatscaler', position='Body'),
  scanInterval?: string(name='scan_interval', description='The interval at which the system scans for events that trigger scaling activities. Unit: seconds. Default value: 60.', example='30s', position='Body'),
  skipNodesWithLocalStorage?: boolean(name='skip_nodes_with_local_storage', description='Specifies whether the cluster autoscaler scales in nodes that host pods mounted with local volumes, such as EmptyDir or HostPath volumes. Valid values:

*   `true`: does not allow the cluster autoscaler to scale in these nodes.
*   `false`: allows the cluster autoscaler to scale in these nodes.', example='false', position='Body'),
  skipNodesWithSystemPods?: boolean(name='skip_nodes_with_system_pods', description='Specifies whether the cluster autoscaler scales in nodes that host pods in the kube-system namespace. This parameter does not take effect on pods created by DaemonSets and mirror pods. Valid values:

*   `true`: does not allow the cluster autoscaler to scale in these nodes.
*   `false`: allows the cluster autoscaler to scale in these nodes.', example='true', position='Body'),
  unneededDuration?: string(name='unneeded_duration', description='The cooldown period. After the autoscaler performs a scale-out activity, the autoscaler waits a cooldown period before it can perform a scale-in activity. Newly added nodes can be removed in scale-in activities only after the cooldown period ends. Unit: minutes.', example='10 m', position='Body'),
  utilizationThreshold?: string(name='utilization_threshold', description='The scale-in threshold. This threshold specifies the ratio of the resources that are requested by pods to the total resources on the node.

A scale-in activity is performed only when the CPU utilization and memory utilization of a node are lower than the scale-in threshold.', example='0.5', position='Body'),
}

model CreateAutoscalingConfigResponseBody = {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='cc212d04dfe184547bffaa596********'),
  requestId?: string(name='request_id', description='The request ID.', example='AF8BE105-C32B-1269-9774-5510********'),
  taskId?: string(name='task_id', description='The task ID.', example='T-5fd211e924e1d007********'),
}

model CreateAutoscalingConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAutoscalingConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateAutoscalingConfig  CreateAutoscalingConfigRequest
  * @return CreateAutoscalingConfigResponse
 */
async function createAutoscalingConfig(request: CreateAutoscalingConfigRequest): CreateAutoscalingConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateAutoscalingConfig', 'POST', '/cluster/{ClusterId}/autoscale/config/', 'json', false, 'json', request);
}

model CreateClusterRequest {
  accessControlList?: [ string ](name='access_control_list', description='The network access control list (ACL) rule of the SLB instance associated with the API server if the cluster is a registered cluster.', position='Body'),
  addons?: [
    Addon
  ](name='addons', description='The components that you want to install in the cluster. When you create a cluster, you can configure the `addons` parameter to specify the components that you want to install.

**Network plug-in**: required. The Flannel and Terway plug-ins are supported. Select one of the plug-ins for the cluster.

*   If you want to use the Terway component, specify the network plug-in in the [{"name":"flannel","config":""}] format.
*   If you want to use the Terway component, specify the value network plug-in in the [{"name": "terway-eniip","Config": ""}] format.

**Volume plug-in**: optional. Only the `Container Storage Interface (CSI)` plug-in is supported.

Specify the `CSI` plug-in in the following format: [{"name":"csi-plugin","config": ""},{"name": "csi-provisioner","config": ""}].

**Simple Log Service component**: optional. We recommend that you enable Simple Log Service. If Simple Log Service is disabled, you cannot use the cluster auditing feature.

*   Specify an existing `Simple Log Service project` in the following format: [{"name": "logtail-ds","config": "{"IngressDashboardEnabled":"true","sls_project_name":"your_sls_project_name"}"}].
*   To create a `Simple Log Service project`, specify the component in the following format: [{"name": "logtail-ds","config": "{"IngressDashboardEnabled":"true"}"}].

**Ingress controller**: optional. By default, the `nginx-ingress-controller` component is installed in ACK dedicated clusters.

*   To install nginx-ingress-controller and enable Internet access, specify the Ingress controller in the following format: [{"name":"nginx-ingress-controller","config":"{"IngressSlbNetworkType":"internet"}"}].
*   To disable the automatic installation of nginx-ingress-controller, specify the Ingress controller in the following format: [{"name": "nginx-ingress-controller","config": "","disabled": true}].

**Event center**: optional. By default, the event center feature is enabled.

You can use ACK event centers to store and query events and configure alerts. You can use the Logstores that are associated with ACK event centers free of charge within 90 days. For more information, see [Create and use an event center](https://help.aliyun.com/document_detail/150476.html).

To enable the event center feature, specify the event center component in the following format: [{"name":"ack-node-problem-detector","config":"{"sls_project_name":"your_sls_project_name"}"}].', position='Body'),
  apiAudiences?: string(name='api_audiences', description='Service accounts provide identities for pods when pods communicate with the `API server` of the cluster. The `api-audiences` parameter validates `tokens` and is used by the `API server` to check whether the `tokens` of requests are valid. Separate multiple values with commas (,).``

For more information about `service accounts`, see [Enable service account token volume projection](https://help.aliyun.com/document_detail/160384.html).', example='kubernetes.default.svc', position='Body'),
  autoRenew?: boolean(name='auto_renew', description='[**Deprecated**]

Specifies whether to enable auto-renewal. This parameter takes effect only when `charge_type` is set to `PrePaid`. Valid values:

*   `true`: enables auto-renewal.
*   `false`: disables auto-renewal.

Default value: `false`.

This parameter was changed on October 15, 2024. For more information, see [Announcement on changes to the parameter behavior of the CreateCluster operation](https://help.aliyun.com/document_detail/2849194.html).', example='true', deprecated='true', position='Body'),
  autoRenewPeriod?: long(name='auto_renew_period', description='[**Deprecated**]

The auto-renewal duration. This parameter takes effect only if charge_type is set to PrePaid and auto_renew is set to true. If you set `period_unit` to Month, the valid values of auto_renew_period are 1, 2, 3, 6, and 12.

Default value: 1.

This parameter was changed on October 15, 2024. For more information, see [Announcement on changes to the parameter behavior of the CreateCluster operation](https://help.aliyun.com/document_detail/2849194.html).', example='1', deprecated='true', position='Body'),
  chargeType?: string(name='charge_type', description='[**Deprecated**]

The billing method of the CLB instance that is used by the API server. Default value: PostPaid. Valid values:

*   PostPaid: pay-as-you-go.
*   PrePaid: subscription. This billing method is not supported by newly created CLB instances. Existing CLB instances are not affected.

> 

*   This parameter was changed on October 15, 2024. For more information, see [Announcement on changes to the parameter behavior of the CreateCluster operation](https://help.aliyun.com/document_detail/2849194.html).

*   Starting from December 1, 2024, newly created CLB instances no longer support the subscription billing method, and an instance fee will be charged for newly created CLB instances

For more information, see [CLB billing adjustments](https://help.aliyun.com/document_detail/2839797.html).', example='1', deprecated='true', position='Body'),
  cisEnabled?: boolean(name='cis_enabled', description='[Deprecated] When you configure the control plane, use the `security_hardening_os` parameter in the `control_plane_config` section instead. When you configure a node pool, use the `security_hardening_os` parameter of the `scaling_group` field in the `nodepool` section instead.', example='false', deprecated='true', position='Body'),
  cloudMonitorFlags?: boolean(name='cloud_monitor_flags', description='[**Deprecated**] When you configure the control plane, use the `cloud_monitor_flags` parameter in the `control_plane_config` section instead. When you configure a node pool, use the `cms_enabled` parameter of the `kubernetes_config` field in the nodepool section instead.

Specifies whether to install the CloudMonitor agent. Valid values:

*   `true`: installs the CloudMonitor agent.
*   `false`: does not install the CloudMonitor agent.

Default value: `false`.', example='true', deprecated='true', position='Body'),
  clusterDomain?: string(name='cluster_domain', description='The domain name of the cluster.

The domain name can contain one or more parts that are separated by periods (.). Each part cannot exceed 63 characters in length, and can contain lowercase letters, digits, and hyphens (-). Each part must start and end with a lowercase letter or digit.', example='cluster.local', position='Body'),
  clusterSpec?: string(name='cluster_spec', description='If you set `cluster_type` to `ManagedKubernetes` and specify `profile`, you can further specify the edition of the cluster. Valid values:

*   `ack.pro.small`: Pro Edition.
*   `ack.standard`: Basic Edition. If you leave the parameter empty, an ACK Basic cluster is created.', example='ack.pro.small', position='Body'),
  clusterType: string(name='cluster_type', description='*   `Kubernetes`: ACK dedicated cluster.
*   `ManagedKubernetes`: ACK managed cluster. ACK managed clusters include ACK Basic clusters, ACK Pro clusters, ACK Serverless clusters (Basic Edition and Pro Edition), ACK Edge clusters (Basic Edition and Pro Edition), and ACK Lingjun clusters (Pro Edition).
*   `ExternalKubernetes`: registered cluster.

This parameter is required.', example='Kubernetes', position='Body'),
  containerCidr?: string(name='container_cidr', description='The pod CIDR block. You can specify 10.0.0.0/8, 172.16-31.0.0/12-16, 192.168.0.0/16, or their subnets as the pod CIDR block. The pod CIDR block cannot overlap with the CIDR block of the VPC in which the cluster is deployed and the CIDR blocks of existing clusters in the VPC. You cannot modify the pod CIDR block after you create the cluster.

For more information about how to plan the network of an ACK cluster, see [Plan the network of an ACK cluster](https://help.aliyun.com/document_detail/86500.html).

>  This parameter is required if the cluster uses the Flannel plug-in.', example='172.20.0.0/16', position='Body'),
  controlPlaneConfig?: {
    autoRenew?: boolean(name='auto_renew', description='Specifies whether to enable auto-renewal for the node.', example='true'),
    autoRenewPeriod?: long(name='auto_renew_period', description='The auto-renewal duration for the node.', example='1'),
    chargeType?: string(name='charge_type', description='The billing method of the node.', example='PrePaid'),
    cloudMonitorFlags?: boolean(name='cloud_monitor_flags', description='Specifies whether to install CloudMonitor on the node.', example='true'),
    cpuPolicy?: string(name='cpu_policy', description='The CPU management policy of the node.', example='none'),
    deploymentsetId?: string(name='deploymentset_id', description='The ID of the deployment set.', example='ds-bp10b35imuam5amw****'),
    imageId?: string(name='image_id', description='The image ID.', example='aliyun_3_x64_20G_alibase_20240819.vhd'),
    imageType?: string(name='image_type', description='The type of the OS image.', example='AliyunLinux3'),
    instanceTypes?: [ string ](name='instance_types', description='The instance types of the nodes.'),
    keyPair?: string(name='key_pair', description='The name of the key pair. You must set this parameter or login_password.', example='ack'),
    loginPassword?: string(name='login_password', description='The SSH logon password. The password must be 8 to 30 characters in length and contain a minimum of three of the following character types: uppercase letters, lowercase letters, digits, and special characters. You must set this parameter or key_pair.', example='ack@Test'),
    nodePortRange?: string(name='node_port_range', description='The node port range.', example='30000-32767'),
    period?: long(name='period', description='The subscription duration of the node.', example='1'),
    periodUnit?: string(name='period_unit', description='The unit of the subscription duration of the node.', example='Month'),
    runtime?: string(name='runtime', description='The container runtime.', example='containerd'),
    securityHardeningOs?: boolean(name='security_hardening_os', description='Specifies whether to enable Alibaba Cloud Linux Security Hardening.', example='true'),
    size?: long(name='size', description='The number of control plane nodes.', example='3'),
    socEnabled?: boolean(name='soc_enabled', description='Specifies whether to enable MLPS security hardening.', example='true'),
    systemDiskBurstingEnabled?: boolean(name='system_disk_bursting_enabled', description='Specifies whether to enable the burst feature for the system disk.', example='true'),
    systemDiskCategory?: string(name='system_disk_category', description='The system disk category for the node.', example='cloud_essd'),
    systemDiskPerformanceLevel?: string(name='system_disk_performance_level', description='The PL of the system disk that you want to use for the node. This parameter takes effect only for ESSDs.', example='PL1'),
    systemDiskProvisionedIops?: long(name='system_disk_provisioned_iops', description='The preset read/write IOPS of the system disk.', example='1000'),
    systemDiskSize?: long(name='system_disk_size', description='The system disk size of the node. The value must be at least 40 GB.', example='120'),
    systemDiskSnapshotPolicyId?: string(name='system_disk_snapshot_policy_id', description='The automatic snapshot policy of the node.', example='sp-2zej1nogjvovnz4z****'),
  }(name='control_plane_config', description='The control plane configurations of an ACK dedicated cluster.', position='Body'),
  controlplaneLogComponents?: [ string ](name='controlplane_log_components', description='The control plane components for which you want to enable log collection.

By default, the logs of kube-apiserver, kube-controller-manager, and kube-scheduler are collected.', position='Body'),
  controlplaneLogProject?: string(name='controlplane_log_project', description='The Simple Log Service project that is used to store the logs of control plane components. You can use an existing project or create one. If you choose to create a Simple Log Service project, the created project is named in the `k8s-log-{ClusterID}` format.', example='k8s-log-xxx', position='Body'),
  controlplaneLogTtl?: string(name='controlplane_log_ttl', description='The retention period of control plane logs in days.', example='30', position='Body'),
  cpuPolicy?: string(name='cpu_policy', description='[**Deprecated**] When you configure the control plane, use the `cpu_policy` parameter in the `control_plane_config` section instead. When you configure a node pool, use the `cpu_policy` parameter of the `kubernetes_config` field in the `nodepool` section instead.

The CPU management policy of the node. The following policies are supported if the Kubernetes version of the cluster is 1.12.6 or later:

*   `static`: allows pods with specific resource characteristics on the node to be granted enhanced CPU affinity and exclusivity.
*   `none`: specifies that the default CPU affinity is used.

Default value: `none`.', example='none', deprecated='true', position='Body'),
  customSan?: string(name='custom_san', description='The custom subject alternative names (SANs) for the API server certificate to accept requests from specified IP addresses or domain names. Separate multiple IP addresses and domain names with commas (,).', example='cs.aliyun.com', position='Body'),
  deletionProtection?: boolean(name='deletion_protection', description='Specifies whether to enable cluster deletion protection. If you enable this option, the cluster cannot be deleted in the console or by calling API operations. Valid values:

*   `true`: enables cluster deletion protection.
*   `false`: disables cluster deletion protection.

Default value: `false`.', example='true', position='Body'),
  disableRollback?: boolean(name='disable_rollback', description='[**Deprecated**] By default, the system does not perform a rollback when the cluster fails to be created. You must manually delete the cluster that fails to be created.

Specifies whether to perform a rollback when the cluster fails to be created. Valid values:

*   `true`: performs a rollback when the cluster fails to be created.
*   `false`: does not perform a rollback when the cluster fails to be created.

Default value: `true`.', example='true', deprecated='true', position='Body'),
  enableRrsa?: boolean(name='enable_rrsa', description='Specifies whether to enable the RAM Roles for Service Accounts (RRSA) feature.', example='true', position='Body'),
  encryptionProviderKey?: string(name='encryption_provider_key', description='The ID of the Key Management Service (KMS) key that is used to encrypt the system disk. For more information, see [What is KMS?](https://help.aliyun.com/document_detail/28935.html)

>  The key can be used only in ACK Pro clusters.', example='0fe64791-55eb-4fc7-84c5-c6c7cdca****', position='Body'),
  endpointPublicAccess?: boolean(name='endpoint_public_access', description='Specifies whether to enable Internet access for the cluster. You can use an elastic IP address (EIP) to expose the API server. This way, you can access the cluster over the Internet. Valid values:

*   `true`: enables Internet access for the cluster.
*   `false`: disables Internet access for the cluster. If you set the value to false, the API server cannot be accessed over the Internet.

Default value: `false`.', example='true', position='Body'),
  formatDisk?: boolean(name='format_disk', description='[**Deprecated**] When you configure a node pool, you cannot add existing nodes to the cluster. If you want to add existing nodes, you must first create a node pool and then call the [AttachInstancesToNodePool](https://help.aliyun.com/document_detail/2667920.html) operation.

Specifies whether to mount a data disk to a node that is created based on an existing ECS instance. Valid values:

*   `true`: stores the data of containers and images on a data disk. The existing data stored in the data disk is lost. Back up the existing data first.
*   `false`: does not store the data of containers and images on a data disk.

Default value: `false`.

How data disks are mounted:

*   If an ECS instance has data disks mounted and the file system of the last data disk is not initialized, the system automatically formats the data disk to ext4. Then, the system mounts the data disk to /var/lib/docker and /var/lib/kubelet.
*   If no data disk is mounted to the ECS instance, the system does not purchase a new data disk.', example='false', deprecated='true', position='Body'),
  imageId?: string(name='image_id', description='[**Deprecated**] When you configure the control plane, use the `image_id` parameter in the `control_plane_config` section instead. When you configure a node pool, use the `image_id` parameter of the `scaling_group` field in the `nodepool` section instead.

The custom image for nodes. By default, the image provided by ACK is used. You can select a custom image to replace the default image. For more information, see [Use a custom image to create an ACK cluster](https://help.aliyun.com/document_detail/146647.html).', example='m-bp16z7xko3vvv8gt****', deprecated='true', position='Body'),
  imageType?: string(name='image_type', description='[**Deprecated**] When you configure the control plane, use the `image_type` parameter in the `control_plane_config` section instead. When you configure a node pool, use the `image_type` parameter of the `scaling_group` field in the `nodepool` section instead.

The type of OS distribution that you want to use. To specify the node OS, we recommend that you use this parameter. Valid values:

*   CentOS
*   AliyunLinux
*   AliyunLinux Qboot
*   AliyunLinuxUEFI
*   AliyunLinux3
*   Windows
*   WindowsCore
*   AliyunLinux3Arm64
*   ContainerOS

Default value: `CentOS`.', example='AliyunLinux', deprecated='true', position='Body'),
  instances?: [ string ](name='instances', description='[**Deprecated**] When you configure a node pool, you cannot add existing nodes to the cluster. If you want to add existing nodes, you must first create a node pool and then call the [AttachInstancesToNodePool](https://help.aliyun.com/document_detail/2667920.html) operation.

The existing ECS instances that are specified as worker nodes for the cluster.

>  This parameter is required if you create worker nodes on existing ECS instances.', deprecated='true', position='Body'),
  ipStack?: string(name='ip_stack', description='The IP stack of the cluster.', example='Optional value: ipv4 (Single stack) or ipv6 (Dual Stack)
Default value: IPV4', position='Body'),
  isEnterpriseSecurityGroup?: boolean(name='is_enterprise_security_group', description='Specifies whether to create an advanced security group. This parameter takes effect only if `security_group_id` is left empty.

>  To use a basic security group, make sure that the sum of the number of nodes in the cluster and the number of pods that use Terway does not exceed 2,000. Therefore, we recommend that you specify an advanced security group for a cluster that uses Terway.

*   `true`: creates an advanced security group.
*   `false`: does not create an advanced security group.

Default value: `true`.', example='true', position='Body'),
  keepInstanceName?: boolean(name='keep_instance_name', description='[**Deprecated**] When you configure a node pool, you cannot add existing nodes to the cluster. If you want to add existing nodes, you must first create a node pool and then call the [AttachInstancesToNodePool](https://help.aliyun.com/document_detail/2667920.html) operation.

Specifies whether to retain the names of existing ECS instances that are used in the cluster. Valid values:

*   `true`: retains the names.
*   `false`: does not retain the names. The system assigns new names.

Default value: `true`.', example='true', deprecated='true', position='Body'),
  keyPair?: string(name='key_pair', description='[**Deprecated**] When you configure the control plane, use the `key_pair` parameter in the `control_plane_config` section instead. When you configure a node pool, use the `key_pair` parameter of the `scaling_group` field in the `nodepool` section instead.

The name of the key pair. You must configure this parameter or `login_password`.', example='secrity-key', deprecated='true', position='Body'),
  kubernetesVersion?: string(name='kubernetes_version', description='The Kubernetes version of the cluster. The Kubernetes versions supported by ACK are the same as the Kubernetes versions supported by open source Kubernetes. We recommend that you specify the latest Kubernetes version. If you do not specify this parameter, the latest Kubernetes version is used.

You can create ACK clusters of the latest three Kubernetes versions in the ACK console. If you want to create clusters that run earlier Kubernetes versions, use the ACK API. For more information about the Kubernetes versions supported by ACK, see [Support for Kubernetes versions](https://help.aliyun.com/document_detail/185269.html).', example='1.16.9-aliyun.1', position='Body'),
  loadBalancerId?: string(name='load_balancer_id', description='Specifies the ID of the CLB instance for accessing the API server. If this parameter is specified, the system does not automatically create a CLB instance for the API server.

>  Make sure that the CLB instance does not have other dependencies, such as listeners and backend servers. You cannot specify shared-resource or Internet-facing CLB instances.', example='lb-wz9t256gqa3vbouk****', position='Body'),
  loadBalancerSpec?: string(name='load_balancer_spec', description='[**Deprecated**] The pay-as-you-go billing method is used by Classic Load Balancer (CLB) instances. This parameter does not take effect.

The specification of the Server Load Balancer (SLB) instance. Valid values:

*   slb.s1.small
*   slb.s2.small
*   slb.s2.medium
*   slb.s3.small
*   slb.s3.medium
*   slb.s3.large

Default value: `slb.s2.small`.', example='slb.s2.small', deprecated='true', position='Body'),
  loggingType?: string(name='logging_type', description='Enables Simple Log Service for the cluster. This parameter takes effect only for ACK Serverless clusters. Set the value to `SLS`.', example='SLS', position='Body'),
  loginPassword?: string(name='login_password', description='[**Deprecated**] When you configure the control plane, use the `login_password` parameter in the `control_plane_config` section instead. When you configure a node pool, use the `login_password` parameter of the `scaling_group` field in the `nodepool` section instead.

The password for SSH logon. You must set this parameter or `key_pair`. The password must be 8 to 30 characters in length, and must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.', example='Hello@1234', deprecated='true', position='Body'),
  maintenanceWindow?: MaintenanceWindow(name='maintenance_window', description='The configurations of the cluster maintenance window.', position='Body'),
  masterAutoRenew?: boolean(name='master_auto_renew', description='[**Deprecated**] When you configure the control plane, use the `auto-renew` parameter in the `control_plane_config` section instead.

Specifies whether to enable auto-renewal for master nodes. This parameter takes effect only when `master_instance_charge_type` is set to `PrePaid`. Valid values:

*   `true`: enables auto-renewal.
*   `false`: disables auto-renewal.

Default value: `true`.', example='true', deprecated='true', position='Body'),
  masterAutoRenewPeriod?: long(name='master_auto_renew_period', description='[**Deprecated**] When you configure the control plane, use the `auto-renew_period` parameter in the `control_plane_config` section instead.

The auto-renewal duration. This parameter takes effect and is required only when the subscription billing method is selected for master nodes.

Valid values: 1, 2, 3, 6, and 12.

Default value: 1.', example='1', deprecated='true', position='Body'),
  masterCount?: long(name='master_count', description='[**Deprecated**] When you configure the control plane, use the `size` parameter in the `control_plane_config` section instead.

The number of master nodes. Valid values: `3` and `5`.

Default value: `3`.', example='3', deprecated='true', position='Body'),
  masterInstanceChargeType?: string(name='master_instance_charge_type', description='[**Deprecated**] When you configure the control plane, use the `instance_charge_type` parameter in the `control_plane_config` section instead.

The billing method of master nodes. Valid values:

*   `PrePaid`: subscription.
*   `PostPaid`: pay-as-you-go.

Default value: `PostPaid`.', example='PrePaid', deprecated='true', position='Body'),
  masterInstanceTypes?: [ string ](name='master_instance_types', description='[**Deprecated**] When you configure the control plane, use the `instance_types` parameter in the `control_plane_config` section instead.

The instance types of master nodes. For more information, see [Overview of instance families](https://help.aliyun.com/document_detail/25378.html).', deprecated='true', position='Body'),
  masterPeriod?: long(name='master_period', description='[**Deprecated**] When you configure the control plane, use the `unit` parameter in the `control_plane_config` section instead.

The subscription duration of master nodes. This parameter takes effect and is required only when `master_instance_charge_type` is set to `PrePaid`.

Valid values: 1, 2, 3, 6, 12, 24, 36, 48, and 60.

Default value: 1.', example='1', deprecated='true', position='Body'),
  masterPeriodUnit?: string(name='master_period_unit', description='[**Deprecated**] When you configure the control plane, use the `period_unit` parameter in the `control_plane_config` section instead.

The billing cycle of the master nodes in the cluster. This parameter is required if master_instance_charge_type is set to `PrePaid`.

Valid value: `Month`, which indicates that master nodes are billed only on a monthly basis.', example='Month', deprecated='true', position='Body'),
  masterSystemDiskCategory?: string(name='master_system_disk_category', description='[**Deprecated**] When you configure the control plane, use the `system_disk_category` parameter in the `control_plane_config` section instead.

The system disk category of master nodes. Valid values:

*   `cloud_efficiency`: ultra disk.
*   `cloud_ssd`: standard SSD.
*   `cloud_essd`: Enterprise SSD (ESSD).

Default value: `cloud_ssd`. The default value may vary in different zones.', example='cloud_ssd', deprecated='true', position='Body'),
  masterSystemDiskPerformanceLevel?: string(name='master_system_disk_performance_level', description='[**Deprecated**] When you configure the control plane, use the `system_disk_performance_level` parameter in the `control_plane_config` section instead.

The performance level (PL) of the system disk that you want to use for master nodes. This parameter takes effect only for ESSDs. For more information about the relationship between disk PLs and disk sizes, see [ESSDs](https://help.aliyun.com/document_detail/122389.html).', example='PL1', deprecated='true', position='Body'),
  masterSystemDiskSize?: long(name='master_system_disk_size', description='[**Deprecated**] When you configure the control plane, use the `system_disk_disk` parameter in the `control_plane_config` section instead.

The system disk size of master nodes. Valid values: 40 to 500. Unit: GiB.

Default value: `120`.', example='120', deprecated='true', position='Body'),
  masterSystemDiskSnapshotPolicyId?: string(name='master_system_disk_snapshot_policy_id', description='[**Deprecated**] When you configure the control plane, use the `system_disk_snapshot_policy_id` parameter in the `control_plane_config` section instead.

The ID of the automatic snapshot policy that is used by the system disk specified for master nodes.', example='sp-2zej1nogjvovnz4z****', deprecated='true', position='Body'),
  masterVswitchIds?: [ string ](name='master_vswitch_ids', description='[**Deprecated**] Use the `vswitch_ids` parameter instead.

The IDs of the vSwitches that are specified for master nodes. You can specify up to three vSwitches. We recommend that you specify three vSwitches in different zones to ensure high availability.

The number of vSwitches must be the same as the value of the `master_count` parameter and also the same as the number of vSwitches specified in the `master_vswitch_ids` parameter.', deprecated='true', position='Body'),
  name: string(name='name', description='The cluster name.

The name must be 1 to 63 characters in length, and can contain digits, letters, and hyphens (-). The name cannot start with a hyphen (-).

This parameter is required.', example='cluster-demo', position='Body'),
  natGateway?: boolean(name='nat_gateway', description='[Deprecated] Use the `snat_entry` parameter instead.', example='true', position='Body'),
  nodeCidrMask?: string(name='node_cidr_mask', description='The maximum number of IP addresses that can be assigned to each node. This number is determined by the subnet mask of the specified CIDR block. This parameter takes effect only if the cluster uses the Flannel plug-in.

Default value: `26`.', example='25', position='Body'),
  nodeNameMode?: string(name='node_name_mode', description='[**Deprecated**] When you configure a node pool, use the `node_name_mode` parameter of the `kubernetes_config` field in the `nodepool` section instead.

The custom node name.

A custom node name consists of a prefix, a node IP address, and a suffix.

*   The prefix and suffix can contain multiple parts that are separated by periods (.). Each part can contain lowercase letters, digits, and hyphens (-), and must start and end with a lowercase letter or digit.
*   The IP substring length specifies the number of digits to be truncated from the end of the node IP address. The IP substring length ranges from 5 to 12.

For example, if the node IP address is 192.168.0.55, the prefix is aliyun.com, the IP substring length is 5, and the suffix is test, the node name will aliyun.com00055test.', example='aliyun.com00055test', deprecated='true', position='Body'),
  nodePortRange?: string(name='node_port_range', description='The node port range. Valid values: 30000 to 65535.

Default value: `30000-32767`.', example='30000~32767', position='Body'),
  nodepools?: [
    Nodepool
  ](name='nodepools', description='The list of node pools.', position='Body'),
  numOfNodes?: long(name='num_of_nodes', description='[**Deprecated**] When you configure a node pool, use the `desired_size` parameter of the `scaling_group` field in the `nodepool` section instead.

The number of worker nodes. Valid values: 0 to 100.', example='3', deprecated='true', position='Body'),
  operationPolicy?: {
    clusterAutoUpgrade?: {
      channel?: string(name='channel', description='The automatic update frequency. Valid values:

*   patch
*   stable
*   rapid', example='patch'),
      enabled?: boolean(name='enabled', description='Specifies whether to enable auto cluster update.', example='true'),
    }(name='cluster_auto_upgrade', description='The configurations of auto cluster upgrade.'),
  }(name='operation_policy', description='The automatic O\\&M policy of the cluster.', position='Body'),
  osType?: string(name='os_type', description='[**Deprecated**] When you configure the control plane, use the `image_type` parameter in the `control_plane_config` section instead. When you configure a node pool, use the `image_type` parameter of the `scaling_group` field in the `nodepool` section instead.

The type of OS. Valid values:

*   Windows
*   Linux

Default value: `Linux`.', example='Linux', deprecated='true', position='Body'),
  period?: long(name='period', description='[**Deprecated**]

The subscription duration. This parameter takes effect and is required only when you set charge_type to PrePaid.

Valid values: 1, 2, 3, 6, 12, 24, 36, 48, and 60.

Default value: 1.

This parameter was changed on October 15, 2024. For more information, see [Announcement on changes to the parameter behavior of the CreateCluster operation](https://help.aliyun.com/document_detail/2849194.html).', example='FY2023', deprecated='true', position='Body'),
  periodUnit?: string(name='period_unit', description='[**Deprecated**]

The billing cycle. This parameter is required if charge_type is set to PrePaid.

Valid value: Month, which indicates that resources are billed only on a monthly basis.

This parameter was changed on October 15, 2024. For more information, see [Announcement on changes to the parameter behavior of the CreateCluster operation](https://help.aliyun.com/document_detail/2849194.html).', example='Month', deprecated='true', position='Body'),
  platform?: string(name='platform', description='[**Deprecated**] When you configure a node pool, use the `platform` parameter of the `scaling_group` field in the `nodepool` section instead.

The OS distribution that is used. Valid values:

*   CentOS
*   AliyunLinux
*   QbootAliyunLinux
*   Qboot
*   Windows
*   WindowsCore

Default value: `CentOS`.', example='CentOS', deprecated='true', position='Body'),
  podVswitchIds?: [ string ](name='pod_vswitch_ids', description='If you select Terway as the network plug-in, you must allocate vSwitches to pods. For each vSwitch that allocates IP addresses to worker nodes, you must select a vSwitch in the same zone to allocate IP addresses to pods.

>  We recommend that you select pod vSwitches whose subnet masks do not exceed 19 bits in length. The maximum subnet mask length of a pod vSwitch is 25 bits. If you select a pod vSwitch whose subnet mask exceeds 25 bits in length, the IP addresses that can be allocated to pods may be insufficient.', position='Body'),
  profile?: string(name='profile', description='If you set `cluster_type` to `ManagedKubernetes`, an ACK managed cluster is created. In this case, you can further specify the cluster edition. Valid values:

*   `Default`: ACK managed cluster. ACK managed clusters include ACK Basic clusters and ACK Pro clusters.
*   `Edge`: ACK Edge cluster. ACK Edge clusters include ACK Edge Basic clusters and ACK Edge Pro clusters.
*   `Serverless`: ACK Serverless cluster. ACK Serverless clusters include ACK Serverless Basic clusters and ACK Serverless Pro clusters.
*   `Lingjun`: ACK Lingjun Pro cluster.', example='Default', position='Body'),
  proxyMode?: string(name='proxy_mode', description='The kube-proxy mode. Valid values:

*   `iptables`: a mature and stable mode that uses iptables rules to conduct service discovery and load balancing. The performance of this mode is limited by the size of the cluster. This mode is suitable for clusters that run a small number of Services.
*   `ipvs`: a mode that provides high performance and uses IP Virtual Server (IPVS) to conduct service discovery and load balancing. This mode is suitable for clusters that run a large number of Services. We recommend that you use this mode in scenarios that require high-performance load balancing.

Default value: `ipvs`.', example='ipvs', position='Body'),
  rdsInstances?: [ string ](name='rds_instances', description='[**Deprecated**] When you configure a node pool, use the `rds_instances` parameter of the `scaling_group` field in the `nodepool` section instead.

The ApsaraDB RDS instances. The pod CIDR block and node CIDR block are added to the whitelists of the ApsaraDB RDS instances. We recommend that you add the pod CIDR block and node CIDR block to the whitelists of the ApsaraDB RDS instances in the ApsaraDB RDS console. If the RDS instances are not in the Running state, new nodes cannot be added to the cluster.', deprecated='true', position='Body'),
  regionId: string(name='region_id', description='The ID of the region in which the cluster is deployed. For more information about the regions supported by ACK, see [Regions supported by ACK](https://help.aliyun.com/document_detail/216938.html).

This parameter is required.', example='cn-beijing', position='Body'),
  resourceGroupId?: string(name='resource_group_id', description='The ID of the resource group to which the cluster belongs. You can use resource groups to isolate clusters.', example='rg-acfm3mkrure****', position='Body'),
  runtime?: Runtime(name='runtime', description='The container runtime. The default container runtime is Docker. containerd and Sandboxed-Container are also supported.

For more information about how to select a proper container runtime, see [Comparison among Docker, containerd, and Sandboxed-Container](https://help.aliyun.com/document_detail/160313.html).', position='Body'),
  securityGroupId?: string(name='security_group_id', description='The ID of an existing security group. You must specify this parameter or `is_enterprise_security_group`. Cluster nodes are automatically added to the security group.', example='sg-bp1bdue0qc1g7k****', position='Body'),
  securityHardeningOs?: boolean(name='security_hardening_os', description='[**Deprecated**] When you configure the control plane, use the `security_hardening_os` parameter in the `control_plane_config` section instead. When you configure a node pool, use the `security_hardening_os` parameter of the `scaling_group` field in the `nodepool` section instead.

Specifies whether to enable Alibaba Cloud Linux Security Hardening. Valid values:

*   `true`: enables Alibaba Cloud Linux Security Hardening.
*   `false`: disables Alibaba Cloud Linux Security Hardening.

Default value: `false`.', example='false', deprecated='true', position='Body'),
  serviceAccountIssuer?: string(name='service_account_issuer', description='Service accounts provide identities for pods when pods communicate with the `API server` of the cluster. `service-account-issuer` specifies the issuer of the `serviceaccount token`, which is specified by using the `iss` field in the `token payload`.

For more information about `ServiceAccount`, see [Enable service account token volume projection](https://help.aliyun.com/document_detail/160384.html).', example='kubernetes.default.svc', position='Body'),
  serviceCidr: string(name='service_cidr', description='The Service CIDR block. Valid values: 10.0.0.0/16-24, 172.16-31.0.0/16-24, and 192.168.0.0/16-24. The Service CIDR block cannot overlap with the VPC CIDR block (10.1.0.0/21) or the CIDR blocks of existing clusters in the VPC. You cannot modify the Service CIDR block after the cluster is created.

By default, the Service CIDR block is set to 172.19.0.0/20.

This parameter is required.', example='172.21.0.0/20', position='Body'),
  serviceDiscoveryTypes?: [ string ](name='service_discovery_types', description='The methods for implementing service discovery in `ACK Serverless` clusters.

*   `CoreDNS`: a standard service discovery plug-in that is provided by open source Kubernetes. To use DNS resolution, you must provision pods. By default, two elastic container instances are used. The specification of each instance is 0.25 vCores and 512 MiB of memory.
*   `PrivateZone`: a DNS resolution service provided by Alibaba Cloud. You must activate Alibaba Cloud DNS PrivateZone before you can use it for service discovery.

By default, this parameter is not specified.', position='Body'),
  snatEntry?: boolean(name='snat_entry', description='Specifies whether to configure SNAT rules for the VPC in which your cluster is deployed. Valid values:

*   `true`: automatically creates a NAT gateway and configures SNAT rules. Set the value to `true` if nodes and applications in the cluster need to access the Internet.
*   `false`: does not create a NAT gateway or configure SNAT rules. In this case, nodes and applications in the cluster cannot access the Internet.

>  If this feature is disabled when you create the cluster, you can also manually enable this feature after you create the cluster. For more information, see [Enable an existing ACK cluster to access the Internet](https://help.aliyun.com/document_detail/178480.html).

Default value: `true`.', example='true', position='Body'),
  socEnabled?: boolean(name='soc_enabled', description='[**Deprecated**] When you configure the control plane, use the `soc_enabled` parameter in the `control_plane_config` section instead. When you configure a node pool, use the `soc_enabled` parameter of the `scaling_group` field in the `nodepool` section instead.

Specifies whether to enable Multi-Level Protection Scheme (MLPS) security hardening. For more information, see [ACK security hardening based on MLPS](https://help.aliyun.com/document_detail/196148.html).

Valid values:

*   `true`: enables MLPS security hardening.
*   `false`: disables MLPS security hardening.

Default value: `false`.', example='false', deprecated='true', position='Body'),
  sshFlags?: boolean(name='ssh_flags', description='Specifies whether to enable SSH logon. If this parameter is set to true, you can log on to master nodes in an ACK dedicated cluster over the Internet. This parameter does not take effect for ACK managed clusters. Valid values:

*   `true`: enables SSH logon.
*   `false`: disables SSH logon.

Default value: `false`.', example='true', position='Body'),
  tags?: [
    Tag
  ](name='tags', description='The labels that you want to add to nodes. You must add labels based on the following rules:

*   A label is a case-sensitive key-value pair. You can add up to 20 labels.
*   When you add a label, you must specify a unique key, but you can leave the value empty. A key cannot exceed 64 characters in length, and a value cannot exceed 128 characters in length. Keys and values cannot start with aliyun, acs:, https://, or http://. For more information, see [Labels and Selectors](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set).', position='Body'),
  taints?: [
    Taint
  ](name='taints', description='[**Deprecated**] When you configure a node pool, use the `taints` parameter of the `kubernetes_config` field in the `nodepool` section instead.

The taints that you want to add to nodes. Taints can be used together with tolerations to avoid scheduling pods to specific nodes. For more information, see [taint-and-toleration](https://kubernetes.io/zh/docs/concepts/scheduling-eviction/taint-and-toleration/).', deprecated='true', position='Body'),
  timeoutMins?: long(name='timeout_mins', description='[**Deprecated**] By default, the system does not perform a rollback when the cluster fails to be created. You must manually delete the cluster that fails to be created.

Specifies the timeout period of cluster creation. Unit: minutes.

Default value: `60`.', example='60', deprecated='true', position='Body'),
  timezone?: string(name='timezone', description='The time zone of the cluster.', example='Asia/Shanghai', position='Body'),
  userCa?: string(name='user_ca', description='The custom Certificate Authority (CA) certificate used by the cluster.', example='-----BEGIN CERTIFICATE-----****', position='Body'),
  userData?: string(name='user_data', description='The user data of nodes.', example='IyEvdXNyL2Jpbi9iYXNoCmVjaG8gIkhlbGxvIEFD****', position='Body'),
  vpcid?: string(name='vpcid', description='The virtual private cloud (VPC) in which you want to deploy the cluster. This parameter is required.', example='vpc-2zeik9h3ahvv2zz95****', position='Body'),
  vswitchIds?: [ string ](name='vswitch_ids', description='The vSwitches for nodes in the cluster. This parameter is required if you create an ACK managed cluster that does not contain nodes.', position='Body'),
  workerAutoRenew?: boolean(name='worker_auto_renew', description='[**Deprecated**] When you configure a node pool, use the `auto_renew` parameter of the `scaling_group` field in the `nodepool` section instead.

Specifies whether to enable auto-renewal for worker nodes. This parameter takes effect and is required only when `worker_instance_charge_type` is set to `PrePaid`. Valid values:

*   `true`: enables auto-renewal.
*   `false`: disables auto-renewal.

Default value: `true`.', example='true', deprecated='true', position='Body'),
  workerAutoRenewPeriod?: long(name='worker_auto_renew_period', description='[**Deprecated**] When you configure a node pool, use the `auto_renew_period` parameter of the `scaling_group` field in the `nodepool` section instead.

The auto-renewal duration of worker nodes. This parameter takes effect and is required only if the subscription billing method is selected for worker nodes.

Valid values: 1, 2, 3, 6, and 12.', example='1', deprecated='true', position='Body'),
  workerDataDisks?: [ 
    {
      category: string(name='category', description='The data disk category.

This parameter is required.', example='cloud_essd'),
      encrypted?: string(name='encrypted', description='Specifies whether to encrypt the data disk. Valid values:

*   `true`: encrypts the data disk.
*   `false`: does not encrypt the data disk.

Default value: `false`.', example='true'),
      performanceLevel?: string(name='performance_level', description='The PL of the data disk. This parameter takes effect only for ESSDs. You can specify a higher PL if you increase the size of a data disk. For more information, see [Enterprise SSDs](https://help.aliyun.com/document_detail/122389.html).', example='PL1'),
      size: string(name='size', description='The data disk size. Valid values: 40 to 32767. Unit: GiB.

This parameter is required.', example='120'),
    }
  ](name='worker_data_disks', description='[**Deprecated**] When you configure a node pool, use the `data_disks` parameter of the `scaling_group` field in the `nodepool` section instead.

The configurations of the data disks that you want to mount to worker nodes. The configurations include the disk category and disk size.', deprecated='true', position='Body'),
  workerInstanceChargeType?: string(name='worker_instance_charge_type', description='[**Deprecated**] When you configure a node pool, use the `instance_charge_type` parameter of the `scaling_group` field in the `nodepool` section instead.

The billing method of worker nodes. Valid values:

*   `PrePaid`: subscription.
*   `PostPaid`: pay-as-you-go.

Default value: PostPaid.', example='PrePaid', deprecated='true', position='Body'),
  workerInstanceTypes?: [ string ](name='worker_instance_types', description='[**Deprecated**] When you configure a node pool, use the `instance_types` parameter of the `scaling_group` field in the `nodepool` section instead.

The instance configurations of worker nodes.', deprecated='true', position='Body'),
  workerPeriod?: long(name='worker_period', description='[**Deprecated**] When you configure a node pool, use the `period` parameter of the `scaling_group` field in the `nodepool` section instead.

The subscription duration of worker nodes. This parameter takes effect and is required only when `worker_instance_charge_type` is set to `PrePaid`.

Valid values: 1, 2, 3, 6, 12, 24, 36, 48, and 60.

Default value: 1.', example='1', deprecated='true', position='Body'),
  workerPeriodUnit?: string(name='worker_period_unit', description='[**Deprecated**] When you configure a node pool, use the `period_unit` parameter of the `scaling_group` field in the `nodepool` section instead.

The billing cycle of worker nodes. This parameter is required if worker_instance_charge_type is set to `PrePaid`.

Valid value: `Month`, which indicates that worker nodes are billed only on a monthly basis.', example='Month', deprecated='true', position='Body'),
  workerSystemDiskCategory?: string(name='worker_system_disk_category', description='[**Deprecated**] When you configure a node pool, use the `system_disk_category` parameter of the `scaling_group` field in the `nodepool` section instead.

The system disk category of worker nodes. For more information, see [Elastic Block Storage devices](https://help.aliyun.com/document_detail/63136.html).

Valid values:

*   `cloud_efficiency`: ultra disk.
*   `cloud_ssd`: standard SSD.

Default value: `cloud_ssd`.', example='cloud_efficiency', deprecated='true', position='Body'),
  workerSystemDiskPerformanceLevel?: string(name='worker_system_disk_performance_level', description='[**Deprecated**] When you configure a node pool, use the `system_disk_performance_level` parameter of the `scaling_group` field in the `nodepool` section instead.

If the system disk is an ESSD, you can specify the PL of the ESSD. For more information, see [Enterprise SSDs](https://help.aliyun.com/document_detail/122389.html).

Valid values:

*   PL0
*   PL1
*   PL2
*   PL3', example='PL1', deprecated='true', position='Body'),
  workerSystemDiskSize?: long(name='worker_system_disk_size', description='[**Deprecated**] When you configure a node pool, use the `system_disk_size` parameter of the `scaling_group` field in the `nodepool` section instead.

The system disk size of worker nodes. Unit: GiB.

Valid values: 40 to 500.

The value of this parameter must be at least 40 and greater than or equal to the image size.

Default value: `120`.', example='120', deprecated='true', position='Body'),
  workerSystemDiskSnapshotPolicyId?: string(name='worker_system_disk_snapshot_policy_id', description='[**Deprecated**] When you configure a node pool, use the `system_disk_snapshot_policy_id` parameter of the `scaling_group` field in the `nodepool` section instead.

The ID of the automatic snapshot policy that is used by the system disk specified for worker nodes.', example='sp-2zej1nogjvovnz4z****', deprecated='true', position='Body'),
  workerVswitchIds?: [ string ](name='worker_vswitch_ids', description='[**Deprecated**] When you configure a node pool, use the `vswitch_ids` parameter of the `scaling_group` field in the `nodepool` section instead.

The vSwitches for worker nodes. Each worker node is allocated a vSwitch.

`worker_vswitch_ids` is optional, but `vswitch_ids` is required if you create an ACK managed cluster that does not contain nodes.', deprecated='true', position='Body'),
  zoneId?: string(name='zone_id', description='[Deprecated] Use the `zone_ids` parameter instead.

The ID of the zone to which the cluster belongs. This parameter is specific to ACK Serverless clusters.

When you create an ACK managed cluster, you must set the `zone_id` parameter if `vpc_id` and `vswitch_ids` are not specified. This way, the system automatically creates a VPC in the specified zone. This parameter is invalid if you specify the `vpc_id` and `vswitch_ids` parameters.', example='cn-beiji****', deprecated='true', position='Body'),
  zoneIds?: [ string ](name='zone_ids', description='The IDs of the zone in which the cluster is deployed. This parameter is specific to ACK managed clusters.

When you create an ACK managed cluster, you must set the `zone_id` parameter if `vpc_id` and `vswitch_ids` are not specified. This way, the system automatically creates a VPC in the specified zone. This parameter is invalid if you specify the `vpc_id` and `vswitch_ids` parameters.', position='Body'),
}

model CreateClusterResponseBody = {
  clusterId?: string(name='cluster_id', description='The ID of the cluster.', example='cb95aa626a47740afbf6aa099b650****'),
  requestId?: string(name='request_id', description='The request ID.', example='687C5BAA-D103-4993-884B-C35E4314A1E1'),
  taskId?: string(name='task_id', description='The task ID.', example='T-5a54309c80282e39ea00002f'),
}

model CreateClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateClusterResponseBody(name='body'),
}

/**
  * @description ### [](#-openapi-)Generate API request parameters through the ACK console
  * When calling the CreateCluster operation to create a cluster, if the API call fails due to invalid parameter settings, you can generate valid request parameters through the ACK console. Follow these steps:
  * 1.  Log on to the [ACK console](https://csnew.console.aliyun.com). In the left-side navigation pane, click **Clusters**.
  * 2.  On the **Clusters** page, click **Cluster Templates**.
  * 3.  In the Select Cluster Template dialog box, select the type of cluster you want to create and click Create. Then, configure the cluster parameters.
  * 4.  In the **Confirm** step, click **Generate API Request Parameters**.
  *     The API request parameters are displayed in the API Request Parameters dialog box.
  * @param request  the request parameters of CreateCluster  CreateClusterRequest
  * @return CreateClusterResponse
 */
async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateCluster', 'POST', '/clusters', 'json', false, 'json', request);
}

model CreateClusterDiagnosisRequest {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='ce0da5a1d627e4e9e9f96cae8ad07****', position='Path'),
  target?: map[string]any(name='target', description='The parameter used to specify the diagnostic object. Examples of parameters for different types of diagnostic objects:

node:

    {"name": "cn-shanghai.10.10.10.107"}

pod

    {"namespace": "kube-system", "name": "csi-plugin-2cg9f"}

network

    {"src": "10.10.10.108", "dst": "10.11.247.16", "dport": "80"}

ingress

    {"url": "https://example.com"}

memory

    {"node":"cn-hangzhou.172.16.9.240"}

service

    {"namespace": "kube-system", "name": "nginx-ingress-lb"}', example='{"namespace": "kube-system", "name": "csi-plugin-2cg9f"}', position='Body'),
  type?: string(name='type', description='The type of the diagnostic.

Valid values:

*   node
*   ingress
*   cluster
*   memory
*   pod
*   service
*   network', example='node', position='Body'),
}

model CreateClusterDiagnosisResponseBody = {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='c5cdf7e3938bc4f8eb0e44b21a80f****'),
  diagnosisId?: string(name='diagnosis_id', description='The diagnostic ID.', example='6f719f23098240818eb26fe3a37d****'),
  requestId?: string(name='request_id', description='The request ID.', example='687C5BAA-D103-4993-884B-C35E4314****'),
}

model CreateClusterDiagnosisResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateClusterDiagnosisResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateClusterDiagnosis  CreateClusterDiagnosisRequest
  * @return CreateClusterDiagnosisResponse
 */
async function createClusterDiagnosis(request: CreateClusterDiagnosisRequest): CreateClusterDiagnosisResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateClusterDiagnosis', 'POST', '/clusters/{cluster_id}/diagnosis', 'json', false, 'json', request);
}

model CreateClusterInspectConfigRequest {
  clusterId: string(name='clusterId', description='This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
  disabledCheckItems?: [ string ](name='disabledCheckItems', position='Body'),
  enabled: boolean(name='enabled', description='This parameter is required.', example='true', position='Body'),
  recurrence: string(name='recurrence', description='This parameter is required.', example='FREQ=DAILY;BYHOUR=10;BYMINUTE=15', position='Body'),
}

model CreateClusterInspectConfigResponseBody = {
  requestId?: string(name='requestId', example='873DC52C-28AA-5A5C-938C-684D3D4B****'),
}

model CreateClusterInspectConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateClusterInspectConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateClusterInspectConfig  CreateClusterInspectConfigRequest
  * @return CreateClusterInspectConfigResponse
 */
async function createClusterInspectConfig(request: CreateClusterInspectConfigRequest): CreateClusterInspectConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateClusterInspectConfig', 'POST', '/clusters/{clusterId}/inspectConfig', 'json', false, 'json', request);
}

model CreateClusterNodePoolRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

This parameter is required.', example='c61da77e8bfbc4c4c999af2b51b65****', position='Path'),
  autoScaling?: {
    eipBandwidth?: long(name='eip_bandwidth', description='This parameter is deprecated.

The maximum bandwidth of the EIP. Unit: Mbit/s.

**

**Important** This parameter is deprecated. Use the internet_charge_type and internet_max_bandwidth_out parameters instead.', example='5', deprecated='true'),
    eipInternetChargeType?: string(name='eip_internet_charge_type', description='This parameter is deprecated.

The metering method of the EIP. Valid values:

*   `PayByBandwidth`: pay-by-bandwidth.
*   `PayByTraffic`: pay-by-data-transfer.

Default value: `PayByBandwidth`.

**

**Important** This parameter is deprecated. Use the internet_charge_type and internet_max_bandwidth_out parameters instead.', example='PayByBandwidth', deprecated='true'),
    enable?: boolean(name='enable', description='Specifies whether to enable auto scaling for the node pool. Valid values:

*   `true`: enables auto scaling.
*   `false`: disables auto scaling. If you set this parameter to false, other parameters in the `auto_scaling` section do not take effect.

Default value: `false`.', example='true'),
    isBondEip?: boolean(name='is_bond_eip', description='This parameter is deprecated.

Specifies whether to associate an elastic IP address (EIP) with the node pool. Valid values:

*   `true`: associates an EIP with the node pool.
*   `false`: does not associate an EIP with the node pool.

Default value: `false`.

**

**Important** This parameter is deprecated. Use the internet_charge_type and internet_max_bandwidth_out parameters instead.', example='true', deprecated='true'),
    maxInstances?: long(name='max_instances', description='The maximum number to which the Elastic Compute Service (ECS) instances in the node pool can be scaled. The number of nodes in the node pool cannot be greater than this value. This parameter takes effect only when `enable` is set to true. Valid values: [min_instances, 2000]. Default value: 0.', example='10'),
    minInstances?: long(name='min_instances', description='The minimum number to which the ECS instances in the node pool can be scaled. The number of nodes in the node pool cannot be smaller than this value. This parameter takes effect only when `enable` is set to true. Valid values: [0, max_instances]. Default value: 0.', example='1'),
    type?: string(name='type', description='The instance type that is used for auto scaling. This parameter takes effect only when `enable` is set to true. Valid values:

*   `cpu`: regular instance.
*   `gpu`: GPU-accelerated instance.
*   `gpushare`: shared GPU-accelerated instance.
*   `spot`: preemptible instance.

Default value: `cpu`.

>  You cannot modify this parameter after the node pool is created.', example='cpu'),
  }(name='auto_scaling', description='The configurations of auto scaling.', position='Body'),
  count?: long(name='count', description='This parameter is deprecated. Use the desired_size parameter instead.

The number of nodes in the node pool.', example='1', deprecated='true', position='Body'),
  hostNetwork?: boolean(name='host_network', description='Specifies whether to set the network type of the pod to host network.

*   `true`: sets to host network.
*   `false`: sets to container network.', example='true', position='Body'),
  interconnectConfig?: {
    bandwidth?: long(name='bandwidth', description='This parameter is deprecated.

The bandwidth of the enhanced edge node pool. Unit: Mbit/s.', example='10'),
    ccnId?: string(name='ccn_id', description='This parameter is deprecated.

The ID of the Cloud Connect Network (CCN) instance that is associated with the enhanced edge node pool.', example='ccn-qm5i0i0q9yi*******'),
    ccnRegionId?: string(name='ccn_region_id', description='This parameter is deprecated.

The region to which the CCN instance that is associated with the enhanced edge node pool belongs.', example='cn-shanghai'),
    cenId?: string(name='cen_id', description='This parameter is deprecated.

The ID of the Cloud Enterprise Network (CEN) instance that is associated with the enhanced edge node pool.', example='cen-ey9k9nfhz0f*******'),
    improvedPeriod?: string(name='improved_period', description='This parameter is deprecated.

The subscription duration of the enhanced edge node pool. The duration is measured in months.', example='1'),
  }(name='interconnect_config', description='This parameter is deprecated.

The configurations of the edge node pool.', deprecated='true', position='Body'),
  interconnectMode?: string(name='interconnect_mode', description='The network type of the edge node pool. This parameter takes effect only when the `type` of the node pool is set to `edge`. Valid values:

*   `basic`: Internet.
*   `private`: private network.', example='basic', position='Body'),
  intranet?: boolean(name='intranet', description='Specifies whether all nodes in the edge node pool can communicate with each other at Layer 3.

*   `true`: The nodes in the edge node pool can communicate with each other at Layer 3.
*   `false`: The nodes in the edge node pool cannot communicate with each other at Layer 3.', example='true', position='Body'),
  kubernetesConfig?: {
    cmsEnabled?: boolean(name='cms_enabled', description='Specifies whether to install the CloudMonitor agent on ECS nodes. After the CloudMonitor agent is installed on ECS nodes, you can view monitoring information about the instances in the CloudMonitor console. We recommend that you install the CloudMonitor agent. Valid values:

*   `true`: installs the CloudMonitor agent on ECS nodes.
*   `false`: does not install the CloudMonitor agent on ECS nodes.

Default value: `false`', example='true'),
    cpuPolicy?: string(name='cpu_policy', description='The CPU management policy of nodes in the node pool. The following policies are supported if the Kubernetes version of the cluster is 1.12.6 or later:

*   `static`: allows pods with specific resource characteristics on the node to be granted with enhanced CPU affinity and exclusivity.
*   `none`: specifies that the default CPU affinity is used.

Default value: `none`.', example='none'),
    labels?: [
      Tag
    ](name='labels', description='The labels that you want to add to the nodes in the cluster.'),
    nodeNameMode?: string(name='node_name_mode', description='A custom node name consists of a prefix, a node IP address, and a suffix.

*   The prefix and the suffix can contain multiple parts that are separated by periods (.). Each part can contain lowercase letters, digits, and hyphens (-). A custom node name must start and end with a digit or lowercase letter.
*   The node IP address in a custom node name is the private IP address of the node.

Set the parameter to a value in the customized,aliyun,ip,com format. The value consists of four parts that are separated by commas (,). customized and ip are fixed content. aliyun is the prefix and com is the suffix. Example: aliyun.192.168.xxx.xxx.com.', example='customized,aliyun,ip,com'),
    preUserData?: string(name='pre_user_data', description='The user-defined data of nodes. You can specify custom scripts that are automatically executed before the nodes are initialized.', example='dGhpcyBpcyBhIGV4YW1wbGU'),
    runtime?: string(name='runtime', description='The name of the container runtime. The following types of runtime are supported by ACK:

*   containerd: containerd is the recommended runtime and supports all Kubernetes versions.
*   Sandboxed-Container.runv: The Sandbox-Container runtime provides improved isolation and supports Kubernetes 1.24 and earlier.
*   docker: The Docker runtime supports Kubernetes 1.22 and earlier.

Default value: containerd.', example='docker'),
    runtimeVersion?: string(name='runtime_version', description='The version of the container runtime.', example='19.03.5'),
    taints?: [
      Taint
    ](name='taints', description='The configurations of the taints.'),
    unschedulable?: boolean(name='unschedulable', description='Specifies whether the nodes are schedulable after a scale-out operation is performed.', example='true'),
    userData?: string(name='user_data', description='The user-defined data of nodes. You can specify custom scripts that are automatically executed after the nodes are initialized.', example='dGhpcyBpcyBhIGV4YW1wbGU='),
  }(name='kubernetes_config', description='The configurations of the cluster.', position='Body'),
  management?: {
    autoRepair?: boolean(name='auto_repair', description='Specifies whether to enable auto node repair. This parameter takes effect only when `enable` is set to true.

*   `true`: enables auto node repair.
*   `false`: disables auto node repair.

If `enable` is set to true, the default value of this parameter is `true`. If `enable` is set to false, the default value of this parameter is `false`.', example='false'),
    autoRepairPolicy?: {
      restartNode?: boolean(name='restart_node', description='Specifies whether to allow node restart. This parameter takes effect only when `auto_repair` is set to true. Valid values:

*   `true`: allows node restart.
*   `false`: does not allow node restart.

If `auto_repair` is set to true, the default value of this parameter is `true`. If `auto_repair` is set to false, the default value of this parameter is `false`.', example='true'),
    }(name='auto_repair_policy', description='The auto node repair policy.'),
    autoUpgrade?: boolean(name='auto_upgrade', description='Specifies whether to enable auto node upgrade. This parameter takes effect only when `enable` is set to true.

*   `true`: enables auto node upgrade.
*   `false`: disables auto node upgrade.

If `enable` is set to true, the default value of this parameter is `true`. If `enable` is set to false, the default value of this parameter is `false`.', example='true'),
    autoUpgradePolicy?: {
      autoUpgradeKubelet?: boolean(name='auto_upgrade_kubelet', description='Specifies whether to allow the auto upgrade of the kubelet. This parameter takes effect only when `auto_upgrade` is set to true. Valid values:

*   `true`: allows the auto upgrade of the kubelet.
*   `false`: does not allow the auto upgrade of the kubelet.

If `auto_upgrade` is set to true, the default value of this parameter is `true`. If `auto_upgrade` is set to false, the default value of this parameter is `false`.', example='true'),
      autoUpgradeOs?: boolean(name='auto_upgrade_os', description='Specifies whether to allow the auto upgrade of the OS. This parameter takes effect only when `auto_upgrade` is set to true. Valid values:

*   `true`: allows the auto upgrade of the OS.
*   `false`: does not allow the auto upgrade of the OS.

Default value: `false`.', example='false'),
      autoUpgradeRuntime?: boolean(name='auto_upgrade_runtime', description='Specifies whether to allow the auto upgrade of the runtime. This parameter takes effect only when `auto_upgrade` is set to true. Valid values:

*   `true`: allows the auto upgrade of the runtime.
*   `false`: does not allow the auto upgrade of the runtime.

Default value: `false`.', example='false'),
    }(name='auto_upgrade_policy', description='The auto node upgrade policy.'),
    autoVulFix?: boolean(name='auto_vul_fix', description='Specifies whether to enable auto Common Vulnerabilities and Exposures (CVE) patching. This parameter takes effect only when `enable` is set to true.

*   `true`: enables auto CVE patching.
*   `false`: disables auto CVE patching.

If `enable` is set to true, the default value of this parameter is `true`. If `enable` is set to false, the default value of this parameter is `false`.', example='true'),
    autoVulFixPolicy?: {
      restartNode?: boolean(name='restart_node', description='Specifies whether to allow node restart. This parameter takes effect only when `auto_vul_fix` is set to true. Valid values:

*   `true`: allows node restart.
*   `false`: does not allow node restart. If `auto_vul_fix` is set to true, the default value of this parameter is `false`. If `auto_vul_fix` is set to false, the default value of this parameter is `false`.', example='true'),
      vulLevel?: string(name='vul_level', description='The severity levels of CVEs that can be automatically patched. Separate multiple levels with commas (,). Example: `asap,later`. Valid values:

*   `asap`: high.
*   `later`: medium.
*   `nntf`: low.

If `auto_vul_fix` is set to true, the default value of this parameter is `asap`.', example='asap,nntf'),
    }(name='auto_vul_fix_policy', description='The auto CVE patching policy.'),
    enable?: boolean(name='enable', description='Specifies whether to enable the managed node pool feature. Valid values:

*   `true`: enables the managed node pool feature.
*   `false`: disables the managed node pool feature. Other parameters in this section take effect only when enable is set to true.

Default value: false.', example='false'),
    upgradeConfig?: {
      autoUpgrade?: boolean(name='auto_upgrade', description='Specifies whether to enable auto upgrade. Valid values:

*   `true`: enables auto OS upgrade.
*   `false`: disables auto OS upgrade.

**

**Caution** This parameter is deprecated. Use the preceding auto_upgrade parameter instead.', example='false', deprecated='true'),
      maxUnavailable?: long(name='max_unavailable', description='The maximum number of nodes that can be in the Unavailable state. Valid values: 1 to 1000.

Default value: 1.', example='1'),
      surge?: long(name='surge', description='The number of nodes that are temporarily added to the node pool during an auto upgrade.', example='0'),
      surgePercentage?: long(name='surge_percentage', description='The percentage of additional nodes that are temporarily added to the node pool during an auto upgrade. You must set this parameter or `surge`.', example='0'),
    }(name='upgrade_config', description='The configurations of auto upgrade. The configurations take effect only when `enable` is set to true.', deprecated='true'),
  }(name='management', description='The configurations of the managed node pool feature.', position='Body'),
  maxNodes?: long(name='max_nodes', description='This parameter is deprecated.

The maximum number of nodes that can be contained in the edge node pool.', example='10', deprecated='true', position='Body'),
  nodeConfig?: {
    kubeletConfiguration?: KubeletConfig(name='kubelet_configuration', description='The configurations of the kubelet.'),
  }(name='node_config', description='The node configurations.', position='Body'),
  nodepoolInfo?: {
    name: string(name='name', description='The name of the node pool.

This parameter is required.', example='cluster-demo'),
    resourceGroupId?: string(name='resource_group_id', description='The ID of the resource group to which the node pool belongs. Instances that are added to the node pool belong to this resource group.', example='rg-acfmyvw3wjmb****'),
    type?: string(name='type', description='The type of node pool. Valid values:

*   `ess`: regular node pool, which supports the managed node pool feature and the auto scaling feature.
*   `edge`: edge node pool.
*   `lingjun`: Lingjun node pool.', example='ess'),
  }(name='nodepool_info', description='The configurations of the node pool.', position='Body'),
  scalingGroup?: {
    autoRenew?: boolean(name='auto_renew', description='Specifies whether to enable auto-renewal for nodes in the node pool. This parameter takes effect only when you set `instance_charge_type` to `PrePaid`. Valid values:

*   `true`: enables auto-renewal.
*   `false`: disables auto-renewal.

Default value: `false`.', example='true'),
    autoRenewPeriod?: long(name='auto_renew_period', description='The auto-renewal period. Valid values:

*   Valid values when PeriodUnit is set to Week: 1, 2, and 3.
*   Valid values when PeriodUnit is set to Month: 1, 2, 3, 6, 12, 24, 36, 48, and 60.

Default value: 1.', example='1'),
    cisEnabled?: boolean(name='cis_enabled', description='This parameter is deprecated. Use security_hardening_os instead.', example='false', deprecated='true'),
    compensateWithOnDemand?: boolean(name='compensate_with_on_demand', description='Specifies whether to automatically create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created due to reasons such as the price or insufficient inventory. This parameter takes effect when you set `multi_az_policy` to `COST_OPTIMIZED`. Valid values:

*   `true`: automatically creates pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created.
*   `false`: does not create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created.', example='true'),
    dataDisks?: [
      DataDisk
    ](name='data_disks', description='The configurations of the data disks that are attached to nodes in the node pool.'),
    deploymentsetId?: string(name='deploymentset_id', description='The ID of the deployment set.', example='ds-bp1d19mmbsv3jf6xxxxx'),
    desiredSize?: long(name='desired_size', description='The expected number of nodes in the node pool.', example='0'),
    imageId?: string(name='image_id', description='The custom image ID. By default, the image provided by Container Service for Kubernetes (ACK) is used.', example='aliyun_2_1903_x64_20G_alibase_20200529.vhd'),
    imageType?: string(name='image_type', description='The type of the OS image. You must specify this parameter or `platform`. Valid values:

*   `AliyunLinux`: Alibaba Cloud Linux 2.
*   `AliyunLinuxSecurity`: Alibaba Cloud Linux 2 (UEFI).
*   `AliyunLinux3`: Alibaba Cloud Linux 3
*   `AliyunLinux3Arm64`: Alibaba Cloud Linux 3 for ARM.
*   `AliyunLinux3Security`: Alibaba Cloud Linux 3 for ARM.
*   `CentOS`: CentOS.
*   `Windows`: Windows.
*   `WindowsCore`: Windows Core.
*   `ContainerOS`: ContainerOS.
*   `AliyunLinux3ContainerOptimized`: Alibaba Cloud Linux 3 Container-optimized.', example='AliyunLinux'),
    instanceChargeType: string(name='instance_charge_type', description='The billing method of nodes in the node pool. Valid values:

*   `PrePaid`: subscription.
*   `PostPaid`: pay-as-you-go.

Default value: `PostPaid`

This parameter is required.', example='PrePaid'),
    instancePatterns?: [
      InstancePatterns
    ](name='instance_patterns', description='The instance attributes.'),
    instanceTypes: [ string ](name='instance_types', description='The instance types of nodes in the node pool. When the system adds a node to the node pool, the system selects the most appropriate one from the specified instance types for the node. You can specify 1 to 10 instance types.

>  To ensure high availability, we recommend that you specify multiple instance types.

This parameter is required.'),
    internetChargeType?: string(name='internet_charge_type', description='The metering method of the public IP address. Valid values:

*   PayByBandwidth: pay-by-bandwidth.
*   PayByTraffic: pay-by-data-transfer.', example='PayByTraffic'),
    internetMaxBandwidthOut?: long(name='internet_max_bandwidth_out', description='The maximum outbound bandwidth of the public IP address. Unit: Mbit/s. Valid values: 1 to 100.', example='5'),
    keyPair?: string(name='key_pair', description='The name of the key pair used to log on to nodes in the node pool. You must set this parameter or `login_password`.

>  If you select ContainerOS as the OS of nodes in the node pool, you must specify `key_pair`.', example='np-key-name'),
    loginAsNonRoot?: boolean(name='login_as_non_root', description='Specifies whether to allow a non-root user to log on to an ECS instance that is added to the node pool.', example='true'),
    loginPassword?: string(name='login_password', description='The password for SSH logon. You must specify this parameter or the `key_pair` parameter. The password must be 8 to 30 characters in length, and must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.', example='Hello1234'),
    multiAzPolicy?: string(name='multi_az_policy', description='The ECS instance scaling policy for the multi-zone scaling group. Valid values:

*   `PRIORITY`: ECS instances are scaled based on the value of VSwitchIds.N. If an ECS instance cannot be created in the zone where the vSwitch that has the highest priority resides, the system creates the ECS instance in the zone where the vSwitch that has the next highest priority resides.

*   `COST_OPTIMIZED`: ECS instances are created based on the vCPU unit price in ascending order. Preemptible instances are preferably created if preemptible instance types are specified in the scaling configurations. You can set the `CompensateWithOnDemand` parameter to specify whether to automatically create pay-as-you-go instances when preemptible instances cannot be created due to insufficient inventory.

    **

    **Note** `COST_OPTIMIZED` takes effect only when multiple instance types are specified or at least one preemptible instance type is specified.

*   `BALANCE`: ECS instances are evenly distributed across multiple zones for the scaling group. If ECS instances become imbalanced among multiple zones due to insufficient inventory, you can call the [RebalanceInstances](https://help.aliyun.com/document_detail/71516.html) operation of Auto Scaling to evenly distribute the ECS instances among zones.

Default value: `PRIORITY`.', example='COST_OPTIMIZED'),
    onDemandBaseCapacity?: long(name='on_demand_base_capacity', description='The minimum number of pay-as-you-go instances that must be kept in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, the system preferably creates pay-as-you-go instances.', example='0'),
    onDemandPercentageAboveBaseCapacity?: long(name='on_demand_percentage_above_base_capacity', description='The percentage of pay-as-you-go instances among the extra instances that exceed the number specified by `on_demand_base_capacity`. Valid values: 0 to 100.', example='20'),
    period?: long(name='period', description='The subscription duration of nodes in the node pool. This parameter takes effect and is required if you set `instance_charge_type` to `PrePaid`.

*   If `period_unit` is set to Week, the valid values of `period` are 1, 2, 3, and 4.
*   If `period_unit` is set to Month, the valid values of `period` are 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36, 48, and 60.', example='1'),
    periodUnit?: string(name='period_unit', description='The billing cycle of nodes in the node pool. This parameter takes effect and is required only when you set `instance_charge_type` to `PrePaid`. Valid values:

*   `Month`: The subscription duration is measured in months.
*   `Week`: The subscription duration is measured in weeks.

Default value: `Month`.', example='Month'),
    platform?: string(name='platform', description='The operating system distribution. Valid values:

*   `CentOS`
*   `AliyunLinux`
*   `Windows`
*   `WindowsCore`

Default value: `AliyunLinux`.', example='AliyunLinux', deprecated='true'),
    privatePoolOptions?: {
      id?: string(name='id', description='The ID of the private node pool.', example='eap-bp67acfmxazb4****'),
      matchCriteria?: string(name='match_criteria', description='The type of private node pool. This parameter specifies the type of private pool that you want to use to create instances. A private pool is generated when an elasticity assurance or a capacity reservation takes effect. The system selects a private pool to start instances. Valid values:

*   `Open`: uses an open private pool. The system selects an open private pool to start instances. If no matching open private pools are available, the resources in the public pool are used.
*   `Target`: uses a specified private pool. The system uses the resources of the specified private pool to start instances. If the specified private pool is unavailable, instances cannot be started.
*   `None`: no private pool is used. The resources of private pools are not used to launch the instances.', example='Open'),
    }(name='private_pool_options', description='The configurations of the private node pool.'),
    ramRoleName?: string(name='ram_role_name', description='The name of the worker RAM role.

*   If you do not specify this parameter, the default worker RAM role created by the cluster is used.
*   The specified RAM role must be a **regular service role** and the **Select Trusted Service** parameter must be set to **Elastic Compute Service**. For more information, see [Create a normal service role](https://help.aliyun.com/document_detail/116800.html). If the specified RAM role is not the default worker RAM role created by the cluster, the name of the RAM role cannot start with `KubernetesMasterRole-` or `KubernetesWorkerRole-`.

>  This parameter is available only for ACK managed clusters that run Kubernetes 1.22 or later.', example='example-role'),
    rdsInstances?: [ string ](name='rds_instances', description='The IDs of ApsaraDB RDS instances.'),
    scalingPolicy?: string(name='scaling_policy', description='The scaling mode of the scaling group. Valid values:

*   `release`: the standard mode. ECS instances are created and released based on resource usage.
*   `recycle`: the swift mode. ECS instances are created, stopped, or started during scaling events. This reduces the time required for the next scale-out event. When the instance is stopped, you are charged only for the storage service. This does not apply to ECS instances that are attached with local disks.

Default value: `release`.', example='release'),
    securityGroupId?: string(name='security_group_id', description='The ID of the security group to which you want to add the node pool. You must specify this parameter or the `security_group_ids` parameter. We recommend that you specify `security_group_ids`.', example='sg-wz9a8g2mt6x5llu0****', deprecated='true'),
    securityGroupIds?: [ string ](name='security_group_ids', description='The IDs of security groups. You must specify this parameter or `security_group_id`. We recommend that you specify `security_group_ids`. If you specify both `security_group_id` and `security_group_ids`, `security_group_ids` is used.'),
    securityHardeningOs?: boolean(name='security_hardening_os', description='Indicates whether Alibaba Cloud Linux Security Hardening is enabled. Valid values:

*   `true`: enables Alibaba Cloud Linux Security Hardening.
*   `false`: disables Alibaba Cloud Linux Security Hardening.

Default value: `false`.', example='false'),
    socEnabled?: boolean(name='soc_enabled', description='Specifies whether to enable MLPS Security Hardening. You can enable security hardening based on Multi-Level Protection Scheme (MLPS) only when Alibaba Cloud Linux 2 or Alibaba Cloud Linux 3 is installed on nodes. Alibaba Cloud provides standards for baseline checks and a scanner to ensure the compliance of Alibaba Cloud Linux 2 and Alibaba Cloud Linux 3 images with the level 3 standards of MLPS 2.0.', example='false'),
    spotInstancePools?: long(name='spot_instance_pools', description='The number of instance types that are available for creating preemptible instances. Auto Scaling creates preemptible instances of multiple instance types that are available at the lowest cost. Valid values: 1 to 10.', example='5'),
    spotInstanceRemedy?: boolean(name='spot_instance_remedy', description='Indicates whether preemptible instances can be supplemented. If you set this parameter to true, when the scaling group receives a system message indicating that a preemptible instance is to be reclaimed, the scaling group attempts to create a new instance to replace this instance. Valid values:

*   `true`: enables the supplementation of preemptible instances.
*   `false`: disables the supplementation of preemptible instances.', example='false'),
    spotPriceLimit?: [ 
      {
        instanceType?: string(name='instance_type', description='The instance type of preemptible instances.', example='ecs.c6.large'),
        priceLimit?: string(name='price_limit', description='The price cap of a preemptible instance of the type.', example='0.39'),
      }
    ](name='spot_price_limit', description='The instance type of preemptible instances and the price cap for the instance type.'),
    spotStrategy?: string(name='spot_strategy', description='The bidding policy of preemptible instances. Valid values:

*   `NoSpot`: non-preemptible.
*   `SpotWithPriceLimit`: specifies the highest bid for the preemptible instance.
*   `SpotAsPriceGo`: automatically submits bids based on the up-to-date market price.

For more information, see [Use preemptible instances](https://help.aliyun.com/document_detail/165053.html).', example='NoSpot'),
    systemDiskBurstingEnabled?: boolean(name='system_disk_bursting_enabled', description='Specifies whether to enable the burst feature for the system disk. Valid values:

*   true: enables the burst feature.
*   false: disables the burst feature.

This parameter is available only when `SystemDiskCategory` is set to `cloud_auto`. For more information, see [ESSD AutoPL disks](https://help.aliyun.com/document_detail/368372.html).', example='true'),
    systemDiskCategories?: [ string ](name='system_disk_categories', description='The categories of the system disk for nodes. The system attempts to create system disks of a disk category with a lower priority if the disk category with a higher priority is unavailable. Valid values:

*   `cloud`: basic disk.
*   `cloud_efficiency`: ultra disk.
*   `cloud_ssd`: standard SSD.
*   `cloud_essd`: ESSD.
*   `cloud_auto`: ESSD AutoPL disk.
*   `cloud_essd_entry`: ESSD Entry disk.'),
    systemDiskCategory?: string(name='system_disk_category', description='The category of the system disk. Valid values:

*   `cloud`: basic disk.
*   `cloud_efficiency`: ultra disk.
*   `cloud_ssd`: standard SSD.
*   `cloud_essd`: ESSD.
*   `cloud_auto`: ESSD AutoPL disk.
*   `cloud_essd_entry`: ESSD Entry disk.

Default value: `cloud_efficiency`.', example='cloud_efficiency'),
    systemDiskEncryptAlgorithm?: string(name='system_disk_encrypt_algorithm', description='The encryption algorithm that is used to encrypt the system disk. Set the value to aes-256.', example='aes-256'),
    systemDiskEncrypted?: boolean(name='system_disk_encrypted', description='Specifies whether to encrypt the system disk. true: encrypts the system disk. false: does not encrypt the system disk.', example='false'),
    systemDiskKmsKeyId?: string(name='system_disk_kms_key_id', description='The ID of the KMS key that is used to encrypt the system disk.', example='0e478b7a-4262-4802-b8cb-00d3fb40****'),
    systemDiskPerformanceLevel?: string(name='system_disk_performance_level', description='The PL of the system disk. This parameter takes effect only for an ESSD.

*   PL0: moderate maximum concurrent I/O performance and low I/O latency.
*   PL1: moderate maximum concurrent I/O performance and low I/O latency.
*   PL2: high maximum concurrent I/O performance and low I/O latency.
*   PL3: ultra-high maximum concurrent I/O performance and ultra-low I/O latency.

>  Alibaba Cloud disks support the preceding PLs. However, when you create a disk, the available PLs vary based on the ECS instance type that you selected. For more information, see [Overview of ECS instance families](https://help.aliyun.com/document_detail/25378.html).', example='PL1'),
    systemDiskProvisionedIops?: long(name='system_disk_provisioned_iops', description='The preset IOPS of the system disk. Valid values: 0 to min{50,000, 1,000 × Capacity - Baseline IOPS}. Baseline IOPS = min{1,800 + 50 × Capacity, 50,000}.

This parameter is supported only when `SystemDiskCategory` is set to `cloud_auto`. For more information, see [ESSD AutoPL disks](https://help.aliyun.com/document_detail/368372.html).', example='1000'),
    systemDiskSize?: long(name='system_disk_size', description='The size of the system disk. Unit: GiB.

Valid values: 20 to 20248.', example='120'),
    tags?: [ 
      {
        key?: string(name='key', description='The tag key.', example='node-k-1'),
        value?: string(name='value', description='The tag value.', example='node-v-1'),
      }
    ](name='tags', description='The tags that you want to add only to ECS instances.

The tag key must be unique and cannot exceed 128 characters in length. The tag key and value cannot start with aliyun or acs: or contain https:// or http://.'),
    vswitchIds: [ string ](name='vswitch_ids', description='The vSwitch IDs. You can specify one to eight vSwitch IDs.

>  To ensure high availability, we recommend that you select vSwitches that reside in different zones.

This parameter is required.'),
  }(name='scaling_group', description='The configurations of the scaling group that is used by the node pool.', position='Body'),
  teeConfig?: {
    teeEnable?: boolean(name='tee_enable', description='Specifies whether to enable confidential computing for the cluster.', example='true'),
  }(name='tee_config', description='The configurations of confidential computing for the cluster.', position='Body'),
}

model CreateClusterNodePoolResponseBody = {
  nodepoolId?: string(name='nodepool_id', description='The node pool ID.', example='np31da1b38983f4511b490fc62108a****'),
  requestId?: string(name='request_id', description='The request ID.', example='0527ac9a-c899-4341-a21a-****'),
  taskId?: string(name='task_id', description='The ID of the task.', example='T-613b19bbd160ad492800****'),
}

model CreateClusterNodePoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateClusterNodePoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateClusterNodePool  CreateClusterNodePoolRequest
  * @return CreateClusterNodePoolResponse
 */
async function createClusterNodePool(request: CreateClusterNodePoolRequest): CreateClusterNodePoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateClusterNodePool', 'POST', '/clusters/{ClusterId}/nodepools', 'json', false, 'json', request);
}

model CreateEdgeMachineRequest {
  hostname: string(name='hostname', description='The `hostname` of the cloud-native box.

>  After the cloud-native box is activated, the `hostname` is automatically modified. The `hostname` is prefixed with the model and the prefix is followed by a random string.

This parameter is required.', example='ACK-B-B010-****', position='Body'),
  model: string(name='model', description='The model of the cloud-native box.

This parameter is required.', example='ACK-V-B010', position='Body'),
  sn: string(name='sn', description='The serial number of the cloud-native box.

This parameter is required.', example='Q2CB5XZAFBFG****', position='Body'),
}

model CreateEdgeMachineResponseBody = {
  edgeMachineId?: string(name='edge_machine_id', description='The ID of the cloud-native box.', example='cc0725ddf688744979cd98445f67e****'),
  requestId?: string(name='request_id', description='The request ID.', example='"request_id": "6e7b377a-c5ed-4388-8026-689e1b34****",'),
}

model CreateEdgeMachineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEdgeMachineResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateEdgeMachine  CreateEdgeMachineRequest
  * @return CreateEdgeMachineResponse
 */
async function createEdgeMachine(request: CreateEdgeMachineRequest): CreateEdgeMachineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateEdgeMachine', 'POST', '/edge_machines', 'json', false, 'json', request);
}

model CreateKubernetesTriggerRequest {
  action: string(name='action', description='The action that the trigger performs. Set the value to redeploy.

`redeploy`: redeploys the resources specified by `project_id`.

This parameter is required.', example='redeploy', position='Body'),
  clusterId: string(name='cluster_id', description='The cluster ID.

This parameter is required.', example='c5cdf7e3938bc4f8eb0e44b21a80f****', position='Body'),
  projectId: string(name='project_id', description='The name of the trigger project.

The name consists of the namespace where the application is deployed and the name of the application. The format is `${namespace}/${name}`.

Example: `default/test-app`.

This parameter is required.', example='default/test-app', position='Body'),
  type?: string(name='type', description='The type of trigger. Valid values:

*   `deployment`: performs actions on Deployments.
*   `application`: performs actions on applications that are deployed in Application Center.

Default value: `deployment`.', example='deployment', position='Body'),
}

model CreateKubernetesTriggerResponseBody = {
  action?: string(name='action', description='The action that the trigger performs. For example, a value of `redeploy` indicates that the trigger redeploys the application.', example='redeploy'),
  clusterId?: string(name='cluster_id', description='The ID of the cluster.', example='c5cdf7e3938bc4f8eb0e44b21a80f****'),
  id?: string(name='id', description='The ID of the trigger.', example='111'),
  projectId?: string(name='project_id', description='The name of the trigger project.', example='default/test-app'),
  type?: string(name='type', description='The type of trigger.

Valid values:

*   `deployment`: performs actions on Deployments.
*   `application`: performs actions on applications that are deployed in Application Center.', example='deployment'),
}

model CreateKubernetesTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateKubernetesTriggerResponseBody(name='body'),
}

/**
  * @deprecated OpenAPI CreateKubernetesTrigger is deprecated, please use CS::2015-12-15::CreateTrigger instead.  * @param request  the request parameters of CreateKubernetesTrigger  CreateKubernetesTriggerRequest
  * @return CreateKubernetesTriggerResponse
 */
// Deprecated
async function createKubernetesTrigger(request: CreateKubernetesTriggerRequest): CreateKubernetesTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateKubernetesTrigger', 'POST', '/triggers', 'json', false, 'json', request);
}

model CreateTemplateRequest {
  description?: string(name='description', description='The description of the template.', example='this is test', position='Body'),
  name: string(name='name', description='The name of the orchestration template.

The name must be 1 to 63 characters in length, and can contain digits, letters, and hyphens (-). It cannot start with a hyphen (-).

This parameter is required.', example='service-account-template', position='Body'),
  tags?: string(name='tags', description='The label of the template.', example='test', position='Body'),
  template: string(name='template', description='The template content in the YAML format.

This parameter is required.', example='apiVersion: v1\\nkind: ServiceAccount\\nmetadata:\\n  name: test-sa', position='Body'),
  templateType?: string(name='template_type', description='The type of template. You can set the parameter to a custom value.

*   If the parameter is set to `kubernetes`, the template is displayed on the Templates page in the console.
*   If you set the parameter to `compose`, the template is not displayed in the console.

We recommend that you set the parameter to `kubernetes`.

Default value: `compose`.', example='kubernetes', position='Body'),
}

model CreateTemplateResponseBody = {
  templateId?: string(name='template_id', description='The ID of the orchestration template.', example='ba1fe77b-b01e-4640-b77e-8f1b80e3e3cf'),
}

model CreateTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateTemplate  CreateTemplateRequest
  * @return CreateTemplateResponse
 */
async function createTemplate(request: CreateTemplateRequest): CreateTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateTemplate', 'POST', '/templates', 'json', false, 'json', request);
}

model CreateTriggerRequest {
  clusterId: string(name='cluster_id', description='The cluster ID.

This parameter is required.', example='c68deb844dc6d480eb775be611fdf****', position='Path,Body'),
  action: string(name='action', description='The action that the trigger performs. Set the value to redeploy.

`redeploy`: redeploys the resources specified by `project_id`.

This parameter is required.', example='redeploy', position='Body'),
  projectId: string(name='project_id', description='The name of the trigger project.

The name consists of the namespace where the application is deployed and the name of the application. The format is `${namespace}/${name}`.

Example: `default/test-app`.

This parameter is required.', example='default/test-app', position='Body'),
  type?: string(name='type', description='The type of trigger. Valid values:

*   `deployment`: performs actions on Deployments.
*   `application`: performs actions on applications that are deployed in Application Center.

Default value: `deployment`.', example='deployment', position='Body'),
}

model CreateTriggerResponseBody = {
  action?: string(name='action', description='The action that the trigger performs. For example, a value of `redeploy` indicates that the trigger redeploys the application.', example='redeploy'),
  clusterId?: string(name='cluster_id', description='The ID of the cluster.', example='c93095129fc41463aa455d89444fd****'),
  id?: string(name='id', description='The ID of the trigger.', example='102536'),
  projectId?: string(name='project_id', description='The name of the trigger project.', example='default/test-app'),
  type?: string(name='type', description='The type of trigger. Default value: deployment.', example='deployment'),
}

model CreateTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTriggerResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateTrigger  CreateTriggerRequest
  * @return CreateTriggerResponse
 */
async function createTrigger(request: CreateTriggerRequest): CreateTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateTrigger', 'POST', '/clusters/{cluster_id}/triggers', 'json', false, 'json', request);
}

model DeleteAlertContactRequest {
  contactIds: [ long ](name='contact_ids', description='The list of alert contact IDs.

This parameter is required.', shrink='json', position='Query'),
}

model DeleteAlertContactResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: {
    result?: [ 
    {
      status?: boolean(name='status', description='The deletion status.

*   true: The alert contact was deleted.
*   false: The alert contact failed to be deleted.', example='true'),
      msg?: string(name='msg', description='The error message returned if the call fails.', example='Delete contact resource failed.'),
      contactId?: string(name='contact_id', description='An alert contact ID.', example='12345'),
    }
  ](name='result')
  }(name='body'),
}

/**
  * @param request  the request parameters of DeleteAlertContact  DeleteAlertContactRequest
  * @return DeleteAlertContactResponse
 */
async function deleteAlertContact(request: DeleteAlertContactRequest): DeleteAlertContactResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteAlertContact', 'DELETE', '/alert/contacts', 'array', false, 'json', request);
}

model DeleteAlertContactGroupRequest {
  contactGroupIds: [ long ](name='contact_group_ids', description='The list of alert contact group IDs.

This parameter is required.', shrink='json', position='Query'),
}

model DeleteAlertContactGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      status?: boolean(name='status', description='The deletion status.

*   true: The alert contact group was deleted.
*   false: The alert contact group failed to be deleted.', example='true'),
      msg?: string(name='msg', description='The error message returned if the call fails.', example='Delete contact group resource failed.'),
      contactGroupId?: string(name='contact_group_id', description='The alert contact group ID.', example='12345'),
    }
  ](name='body'),
}

/**
  * @param request  the request parameters of DeleteAlertContactGroup  DeleteAlertContactGroupRequest
  * @return DeleteAlertContactGroupResponse
 */
async function deleteAlertContactGroup(request: DeleteAlertContactGroupRequest): DeleteAlertContactGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteAlertContactGroup', 'DELETE', '/alert/contact_groups', 'array', false, 'json', request);
}

model DeleteClusterRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c905d1364c2dd4b6284a3f41790c4****', position='Path'),
  deleteOptions?: [ 
    {
      deleteMode?: string(name='delete_mode', description='The deletion policy for the specified type of resource. Valid values:

*   delete: deletes the specified type of resource.
*   retain: retains the specified type of resource.', example='delete'),
      resourceType?: string(name='resource_type', description='The type of the resource. Valid values:

*   SLB: SLB resources created for Services. By default, the SLB resources are automatically deleted.
*   ALB: Application Load Balancer (ALB) resources created by the ALB Ingress controller. By default, the ALB resources are retained.
*   SLS_Data: Simple Log Service projects used by the cluster logging feature. By default, the Simple Log Service projects are retained.
*   SLS_ControlPlane: Simple Log Service projects used to store the logs of control planes in ACK managed clusters. By default, the Simple Log Service projects are retained.
*   PrivateZone: PrivateZone resources created by ACK Serverless clusters. By default, the PrivateZone resources are retained.', example='SLS_Data'),
    }
  ](name='delete_options', description='The type of cluster resource that you want to delete or retain.', shrink='json', position='Query'),
  keepSlb?: boolean(name='keep_slb', description='Specifies whether to retain the Server Load Balancer (SLB) resources that are created by the cluster.

*   `true`: retains the SLB instances that are created by the cluster.
*   `false`: does not retain the SLB instances that are created by the cluster.

Default value: `false`. Set resource_type to `SLB` in the `delete_options` parameter to manage SLB instances.', example='false', deprecated='true', position='Query'),
  retainAllResources?: boolean(name='retain_all_resources', description='Specifies whether to retain all resources. If you set the parameter to `true`, the `retain_resources` parameter is ignored. The cloud resources that are created by the cluster are retained. You can call the `DescribeClusterResources` operation to query cloud resources created by the cluster. If you set the parameter to `false`, resources to be retained by default in the `delete_options` parameter are still retained. To delete these resources, set `delete_mode` to `delete` in `delete_options`.

*   `true`: retains all resources, including cloud resources created by the cluster.
*   `false`: does not retain all resources. Resources to be retained by default in the `delete_options` parameter are retained. For example, `ALB` instances are retained when this parameter is set to `false`.

Default value: `false`.', example='false', position='Query'),
  retainResources?: [ string ](name='retain_resources', description='The list of resources. To retain resources when you delete a cluster, you need to specify the IDs of the resources to be retained.', shrink='json', position='Query'),
}

model DeleteClusterResponseBody = {
  clusterId?: string(name='cluster_id', description='The ID of the cluster.', example='cb95aa626a47740afbf6aa099b650****'),
  requestId?: string(name='request_id', description='The request ID.', example='687C5BAA-D103-4993-884B-C35E4314****'),
  taskId?: string(name='task_id', description='The ID of the task.', example='T-5a54309c80282e39ea****'),
}

model DeleteClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteClusterResponseBody(name='body'),
}

/**
  * @description Warning:
  * *   Subscription ECS instances and Lingjun nodes in a cluster cannot be automatically released. To avoid unnecessary costs, we recommend that you manually release the resources. For more information, see \\<a href="{0}" target="_blank">Rules for deleting clusters and releasing nodes\\</a>.
  * *   If the SLB instance of the API server uses the subscription billing method, it cannot be automatically released. To avoid unnecessary costs, we recommend that you manually release it.
  * *   By default, virtual private clouds (VPCs), vSwitches, security groups, and RAM roles are retained if they are used by other resources. To avoid unnecessary costs, we recommend that you manually release the resources.
  * *   Elastic container instances created on virtual nodes are automatically released.
  * *   Some resources created together with a cluster are not automatically released when the cluster is deleted. After the cluster is deleted, you are still charged for the resources. Release or retain the resources based on your actual needs. The resources include Simple Log Service projects automatically created by the cluster and dynamically provisioned disks.
  * @param request  the request parameters of DeleteCluster  DeleteClusterRequest
  * @return DeleteClusterResponse
 */
async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteCluster', 'DELETE', '/clusters/{ClusterId}', 'json', false, 'json', request);
}

model DeleteClusterInspectConfigRequest {
  clusterId: string(name='clusterId', description='This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
}

model DeleteClusterInspectConfigResponseBody = {
  requestId?: string(name='requestId', example='873DC52C-28AA-5A5C-938C-684D3D4B****'),
}

model DeleteClusterInspectConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteClusterInspectConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteClusterInspectConfig  DeleteClusterInspectConfigRequest
  * @return DeleteClusterInspectConfigResponse
 */
async function deleteClusterInspectConfig(request: DeleteClusterInspectConfigRequest): DeleteClusterInspectConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteClusterInspectConfig', 'DELETE', '/clusters/{clusterId}/inspectConfig', 'json', false, 'json', request);
}

model DeleteClusterNodepoolRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c61da77e8bfbc4c4c999af2b51b65****', position='Path'),
  nodepoolId: string(name='NodepoolId', description='The node pool ID.

This parameter is required.', example='np30db56bcac7843dca90b999c8928****', position='Path'),
  force?: boolean(name='force', description='Specifies whether to forcefully delete the node pool.', example='false', position='Query'),
}

model DeleteClusterNodepoolResponseBody = {
  requestId?: string(name='request_id', description='The request ID.', example='7263C978-3DBD-4E06-B319-793B38A2F388'),
  taskId?: string(name='task_id', description='task IDs', example='T-655ace947e0e6603af000004'),
}

model DeleteClusterNodepoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteClusterNodepoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteClusterNodepool  DeleteClusterNodepoolRequest
  * @return DeleteClusterNodepoolResponse
 */
async function deleteClusterNodepool(request: DeleteClusterNodepoolRequest): DeleteClusterNodepoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteClusterNodepool', 'DELETE', '/clusters/{ClusterId}/nodepools/{NodepoolId}', 'json', false, 'json', request);
}

model DeleteClusterNodesRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c850429a2287b4d968e27e87a4921****', position='Path'),
  drainNode?: boolean(name='drain_node', description='Specifies whether to remove all pods from the nodes that you want to remove. Valid values:

*   `true`: removes all pods from the nodes that you want to remove.
*   `false`: does not remove pods from the nodes that you want to remove.

Default value: `false`.', example='true', position='Body'),
  nodes: [ string ](name='nodes', description='The list of nodes to be removed. You need to specify the name of the nodes used in the cluster, for example, `cn-hangzhou.192.168.0.70`.

This parameter is required.', position='Body'),
  releaseNode?: boolean(name='release_node', description='Specifies whether to release the Elastic Compute Service (ECS) instances. Valid values:

*   `true`: releases the ECS instances.
*   `false`: does not release the ECS instances.

Default value: `false`.

>  You cannot release subscription ECS instances.', example='true', position='Body'),
}

model DeleteClusterNodesResponseBody = {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='c104d5d5f301c4e2a8ee578c37bc****'),
  requestId?: string(name='request_id', description='The request ID.', example='A9891419-D125-4D89-AFCA-68846675E2F7'),
  taskId?: string(name='task_id', description='The task ID.', example='T-60fea8ad2e277f0879000ae9'),
}

model DeleteClusterNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteClusterNodesResponseBody(name='body'),
}

/**
  * @description *   When you remove a node, the pods that run on the node are migrated to other nodes. This may cause service interruptions. We recommend that you remove nodes during off-peak hours.
  * *   The operation may have unexpected risks. Back up the data before you perform this operation.
  * *   When you remove a node, the system sets the status of the node to Unschedulable.
  * @param request  the request parameters of DeleteClusterNodes  DeleteClusterNodesRequest
  * @return DeleteClusterNodesResponse
 */
async function deleteClusterNodes(request: DeleteClusterNodesRequest): DeleteClusterNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteClusterNodes', 'POST', '/clusters/{ClusterId}/nodes', 'json', false, 'json', request);
}

model DeleteEdgeMachineRequest {
  edgeMachineid: string(name='edge_machineid', description='The ID of the cloud-native box.

This parameter is required.', example='cc0725ddf688744979cd98445f67e****', position='Path'),
  force?: string(name='force', description='Specifies whether to forcefully delete the cloud-native box. Valid values:

*   `true`: forcefully deletes the cloud-native box.
*   `false`: does not forcefully delete the cloud-native box.

Default value: `false`.', example='true/false', position='Query'),
}

model DeleteEdgeMachineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of DeleteEdgeMachine  DeleteEdgeMachineRequest
  * @return DeleteEdgeMachineResponse
 */
async function deleteEdgeMachine(request: DeleteEdgeMachineRequest): DeleteEdgeMachineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteEdgeMachine', 'DELETE', '/edge_machines/[edge_machineid]', 'none', false, 'json', request);
}

model DeleteKubernetesTriggerRequest {
  id: string(name='Id', description='The ID of the application trigger.

This parameter is required.', example='c5cdf7e3938bc4f8eb0e44b21a80f****', position='Path'),
}

model DeleteKubernetesTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @deprecated OpenAPI DeleteKubernetesTrigger is deprecated, please use CS::2015-12-15::DeleteTrigger instead.  * @param request  the request parameters of DeleteKubernetesTrigger  DeleteKubernetesTriggerRequest
  * @return DeleteKubernetesTriggerResponse
 */
// Deprecated
async function deleteKubernetesTrigger(request: DeleteKubernetesTriggerRequest): DeleteKubernetesTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteKubernetesTrigger', 'DELETE', '/triggers/revoke/{Id}', 'none', false, 'json', request);
}

model DeletePolicyInstanceRequest {
  clusterId: string(name='cluster_id', description='The cluster ID.

This parameter is required.', example='c8155823d057948c69a****', position='Path'),
  policyName: string(name='policy_name', description='The name of the policy.

This parameter is required.', example='ACKAllowedRepos', position='Path'),
  instanceName?: string(name='instance_name', description='The ID of the policy instance.', example='allowed-repos-mqdsf', position='Query'),
}

model DeletePolicyInstanceResponseBody = {
  instances?: [ string ](name='instances', description='A list of policy instances.'),
}

model DeletePolicyInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePolicyInstanceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeletePolicyInstance  DeletePolicyInstanceRequest
  * @return DeletePolicyInstanceResponse
 */
async function deletePolicyInstance(request: DeletePolicyInstanceRequest): DeletePolicyInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeletePolicyInstance', 'DELETE', '/clusters/{cluster_id}/policies/{policy_name}', 'json', false, 'json', request);
}

model DeleteTemplateRequest {
  templateId: string(name='TemplateId', description='The ID of the orchestration template.

This parameter is required.', example='20663627-81ee-4cfe-9b69-c96fcb84a674', position='Path'),
}

model DeleteTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of DeleteTemplate  DeleteTemplateRequest
  * @return DeleteTemplateResponse
 */
async function deleteTemplate(request: DeleteTemplateRequest): DeleteTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteTemplate', 'DELETE', '/templates/{TemplateId}', 'none', false, 'json', request);
}

model DeleteTriggerRequest {
  clusterId: string(name='cluster_id', description='The cluster ID.

This parameter is required.', example='c68deb844dc6d480eb775be611fdf****', position='Path'),
  id: string(name='Id', description='The trigger ID.

This parameter is required.', example='123407', position='Path'),
}

model DeleteTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of DeleteTrigger  DeleteTriggerRequest
  * @return DeleteTriggerResponse
 */
async function deleteTrigger(request: DeleteTriggerRequest): DeleteTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteTrigger', 'DELETE', '/clusters/{cluster_id}/triggers/{Id}', 'none', false, 'json', request);
}

model DeployPolicyInstanceRequest {
  clusterId: string(name='cluster_id', description='The ID of the cluster.

This parameter is required.', example='c8155823d057948c69a****', position='Path'),
  policyName: string(name='policy_name', description='The policy name.

This parameter is required.', example='ACKNoEnvVarSecrets', position='Path'),
  action?: string(name='action', description='The action of the policy. Valid values:

*   `deny`: Deployments that match the policy are denied.
*   `warn`: Alerts are generated for Deployments that match the policy.', example='deny', position='Body'),
  namespaces?: [ string ](name='namespaces', description='The namespaces to which the policy applies. If you leave this parameter empty, the policy is applicable to all namespaces of the cluster.', position='Body'),
  parameters?: map[string]any(name='parameters', description='The parameter settings of the policy. For more information about the parameters supported by each policy, see [Predefined security policies of ACK](https://www.alibabacloud.com/help/doc-detail/359819.html).', example='{"restrictedNamespaces": [ "test" ]}', position='Body'),
}

model DeployPolicyInstanceResponseBody = {
  instances?: [ string ](name='instances', description='A list of policy instances.'),
}

model DeployPolicyInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeployPolicyInstanceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeployPolicyInstance  DeployPolicyInstanceRequest
  * @return DeployPolicyInstanceResponse
 */
async function deployPolicyInstance(request: DeployPolicyInstanceRequest): DeployPolicyInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeployPolicyInstance', 'POST', '/clusters/{cluster_id}/policies/{policy_name}', 'json', false, 'json', request);
}

model DescribeAddonRequest {
  addonName?: string(name='addon_name', description='The name of the component.', example='coredns', position='Path'),
  clusterId?: string(name='cluster_id', description='The ID of the cluster. If you specify a cluster ID, only components used in the cluster are queried. Other parameters are ignored.', example='c02b3e03be10643e8a644a843ffcb****', position='Query'),
  clusterSpec?: string(name='cluster_spec', description='The specifications of the cluster. If cluster_id is specified, this parameter is ignored. You must specify the region_id, cluster_type, profile, cluster_spec, and cluster_version parameters at the same time.', example='ack.pro.small', position='Query'),
  clusterType?: string(name='cluster_type', description='The type of the cluster. If cluster_id is specified, this parameter is ignored. You must specify the region_id, cluster_type, profile, cluster_spec, and cluster_version parameters at the same time.', example='ManagedKubernetes', position='Query'),
  clusterVersion?: string(name='cluster_version', description='The version of the cluster. If cluster_id is specified, this parameter is ignored. You must specify the region_id, cluster_type, profile, cluster_spec, and cluster_version parameters at the same time.', example='1.26.3-aliyun.1', position='Query'),
  profile?: string(name='profile', description='The subtype of the cluster. If cluster_id is specified, this parameter is ignored. You must specify the region_id, cluster_type, profile, cluster_spec, and cluster_version parameters at the same time.', example='Default', position='Query'),
  regionId?: string(name='region_id', description='The region ID. If cluster_id is specified, this parameter is ignored. You must specify the region_id, cluster_type, profile, cluster_spec, and cluster_version parameters at the same time.', example='cn-hangzhou', position='Query'),
  version?: string(name='version', description='The version of the component. If you do not specify this parameter, the latest version of the component is queried.', example='v1.9.3.10-7dfca203-aliyun', position='Query'),
}

model DescribeAddonResponseBody = {
  architecture?: [ string ](name='architecture', description='Architectures supported by the component. Valid values:

*   amd64
*   arm64'),
  category?: string(name='category', description='The category of the component.', example='network'),
  configSchema?: string(name='config_schema', description='The custom parameter schema of the component.', example='{}'),
  installByDefault?: boolean(name='install_by_default', description='Indicates whether the component is automatically installed by default.', example='true'),
  managed?: boolean(name='managed', description='Indicates whether the component is fully managed.', example='false'),
  name?: string(name='name', description='The name of the component.', example='coredns'),
  newerVersions?: [ 
    {
      minimumClusterVersion?: string(name='minimum_cluster_version', description='The minimum cluster version required by the component version.', example='1.20.4'),
      upgradable?: boolean(name='upgradable', description='Indicates whether the component can be updated to the version.', example='true'),
      version?: string(name='version', description='The version number.', example='v1.9.3.10-7dfca203-aliyun'),
    }
  ](name='newer_versions', description='The latest version of the component.'),
  supportedActions?: [ string ](name='supported_actions', description='Operations supported by the component. Valid values:

*   Install
*   Upgrade
*   Modify
*   Uninstall'),
  version?: string(name='version', description='The version of the component.', example='v1.9.3.6-32932850-aliyun'),
}

model DescribeAddonResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAddonResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeAddon  DescribeAddonRequest
  * @return DescribeAddonResponse
 */
async function describeAddon(request: DescribeAddonRequest): DescribeAddonResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeAddon', 'GET', '/addons/{addon_name}', 'json', false, 'json', request);
}

model DescribeAddonsRequest {
  clusterProfile?: string(name='cluster_profile', description='The cluster type. Valid values:

*   `Default`: ACK managed cluster
*   `Serverless`: ACK Serverless cluster
*   `Edge`: ACK Edge cluster', example='Default', position='Query'),
  clusterSpec?: string(name='cluster_spec', description='If you set `cluster_type` to `ManagedKubernetes` and specify `profile`, you can further specify the edition of the cluster. Valid values:

*   `ack.pro.small`: creates an ACK Pro cluster.
*   `ack.standard`: creates an ACK Basic cluster. If you leave the parameter empty, an ACK Basic cluster is created.', example='ack.pro.small', position='Query'),
  clusterType?: string(name='cluster_type', description='*   `Kubernetes`: ACK dedicated cluster.
*   `ManagedKubernetes`: ACK managed cluster. ACK managed clusters include ACK Basic clusters, ACK Pro clusters, ACK Serverless Basic clusters, ACK Serverless Pro clusters, ACK Edge Basic clusters, ACK Edge Pro clusters, and ACK Lingjun Pro clusters.
*   `ExternalKubernetes`: registered cluster.', example='kubernetes', position='Query'),
  clusterVersion?: string(name='cluster_version', description='The cluster version.', example='1.24.6-aliyun.1', position='Query'),
  region: string(name='region', description='The region ID of the cluster.

This parameter is required.', example='cn-beijing', position='Query'),
}

model DescribeAddonsResponseBody = {
  componentGroups?: [ 
    {
      groupName?: string(name='group_name', description='The name of the component group.', example='storage'),
      items?: [ 
        {
          name?: string(name='name', description='The name of the component.', example='flexvolume'),
        }
      ](name='items', description='The names of the components in the component group.'),
    }
  ](name='ComponentGroups', description='The list of the returned components.'),
  standardComponents?: map[string]StandardComponentsValue(name='StandardComponents', description='Standard components.'),
}

model DescribeAddonsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAddonsResponseBody(name='body'),
}

/**
  * @deprecated OpenAPI DescribeAddons is deprecated, please use CS::2015-12-15::ListAddons instead.  * @param request  the request parameters of DescribeAddons  DescribeAddonsRequest
  * @return DescribeAddonsResponse
 */
// Deprecated
async function describeAddons(request: DescribeAddonsRequest): DescribeAddonsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeAddons', 'GET', '/clusters/components/metadata', 'json', false, 'json', request);
}

model DescribeClusterAddonInstanceRequest {
  clusterID: string(name='ClusterID', description='The ID of the cluster.

This parameter is required.', example='cd06bbf8a86764a31bcac76136691****', position='Path'),
  addonName: string(name='AddonName', description='The name of the component.

This parameter is required.', example='terway-eniip', position='Path'),
}

model DescribeClusterAddonInstanceResponseBody = {
  config?: string(name='config', description='The configuration of the component.', example='{"NetworkPolicy":"true"}'),
  name?: string(name='name', description='The name of the component.', example='terway-eniip'),
  state?: string(name='state', description='The status of the component. Valid values:

*   initial: The component is being installed.
*   active: The component has been installed.
*   unhealthy: The component is in an abnormal state.
*   upgrading: The component is undergoing an upgrade.
*   updating: Component configuration changes are being applied.
*   deleting: The component is being uninstalled.
*   deleted: The component has been deleted.', example='active'),
  version?: string(name='version', description='The version of the component.', example='v1.4.3'),
}

model DescribeClusterAddonInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterAddonInstanceResponseBody(name='body'),
}

/**
  * @deprecated OpenAPI DescribeClusterAddonInstance is deprecated, please use CS::2015-12-15::GetClusterAddonInstance instead.  * @param request  the request parameters of DescribeClusterAddonInstance  DescribeClusterAddonInstanceRequest
  * @return DescribeClusterAddonInstanceResponse
 */
// Deprecated
async function describeClusterAddonInstance(request: DescribeClusterAddonInstanceRequest): DescribeClusterAddonInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusterAddonInstance', 'GET', '/clusters/{ClusterID}/components/{AddonName}/instance', 'json', false, 'json', request);
}

model DescribeClusterAddonMetadataRequest {
  clusterId: string(name='cluster_id', description='The cluster ID.

This parameter is required.', example='c71d616e629ff40d5b42d7bb87770****', position='Path'),
  componentId: string(name='component_id', description='The component ID.

This parameter is required.', example='coredns', position='Path'),
  version?: string(name='version', position='Query'),
}

model DescribeClusterAddonMetadataResponseBody = {
  configSchema?: string(name='config_schema', description='The component schema parameters.', example='{\\n  \\"$schema\\": \\"https://json-schema.org/draft-07/schema#\\",\\n  \\"properties\\": {\\n    \\"controller\\": {\\n      \\"description\\": \\"\\",\\n      \\"properties\\": {\\n        \\"resources\\": {\\n          \\"properties\\": {\\n            \\"armsPrometheusOperator\\": {\\n              \\"properties\\": {\\n                \\"resources\\": {\\n                  \\"properties\\": {\\n                    \\"limits\\": {\\n                      \\"properties\\": {\\n                        \\"memory\\": {\\n                          \\"description\\": \\"memory limit of arms prometheus operator\\",\\n                          \\"type\\": \\"string\\",\\n                          \\"pattern\\": \\"^[1-9][0-9]*(\\\\\\\\.\\\\\\\\d+)?(K|Ki|M|Mi|G|Gi|T|Ti)?$\\",\\n                          \\"default\\": \\"500m\\",\\n                          \\"x-ui-description\\": \\"<mds-key>\\",\\n                          \\"x-ui-prompt-message\\": \\"<mds-key>\\",\\n                          \\"x-ui-validation-message\\": \\"<mds-key>\\",\\n                          \\"x-ui-additional-tips\\": \\"<mds-key>\\"\\n                        },\\n                        \\"cpu\\": {\\n                          \\"description\\": \\"cpu limit of arms prometheus operator\\",\\n                          \\"type\\": \\"string\\",\\n                          \\"pattern\\": \\"^[1-9][0-9]*(m|\\\\\\\\.\\\\\\\\d+)?$\\",\\n                          \\"default\\": \\"1.0\\",\\n                          \\"x-ui-description\\": \\"<mds-key>\\",\\n                          \\"x-ui-validation-message\\": \\"<mds-key>\\"\\n                        }\\n                      },\\n                      \\"type\\": \\"object\\",\\n                      \\"additionalProperties\\": false\\n                    },\\n                    \\"requests\\": {\\n                      \\"properties\\": {\\n                        \\"memory\\": {\\n                          \\"description\\": \\"memory request of arms prometheus operator\\",\\n                          \\"type\\": \\"string\\",\\n                          \\"pattern\\": \\"^[1-9][0-9]*(\\\\\\\\.\\\\\\\\d+)?(K|Ki|M|Mi|G|Gi|T|Ti)?$\\",\\n                          \\"default\\": \\"500m\\",\\n                          \\"x-ui-description\\": \\"<mds-key>\\",\\n                          \\"x-ui-validation-message\\": \\"<mds-key>\\"\\n                        },\\n                        \\"cpu\\": {\\n                          \\"description\\": \\"cpu request of arms prometheus operator\\",\\n                          \\"type\\": \\"string\\",\\n                          \\"pattern\\": \\"^[1-9][0-9]*(m|\\\\\\\\.\\\\\\\\d+)?$\\",\\n                          \\"default\\": \\"1.0\\",\\n                          \\"x-ui-description\\": \\"<mds-key>\\",\\n                          \\"x-ui-validation-message\\": \\"<mds-key>\\"\\n                        }\\n                      },\\n                      \\"type\\": \\"object\\",\\n                      \\"additionalProperties\\": false\\n                    }\\n                  },\\n                  \\"type\\": \\"object\\",\\n                  \\"additionalProperties\\": false\\n                }\\n              },\\n              \\"type\\": \\"object\\",\\n              \\"additionalProperties\\": false\\n            }\\n          },\\n          \\"type\\": \\"object\\",\\n          \\"additionalProperties\\": false\\n        }\\n      },\\n      \\"type\\": \\"object\\",\\n      \\"additionalProperties\\": false\\n    }\\n  },\\n  \\"title\\": \\"Values\\",\\n  \\"type\\": \\"object\\",\\n  \\"additionalProperties\\": false\\n}'),
  name?: string(name='name', description='The component name.', example='coredns'),
  version?: string(name='version', description='The component version.', example='1.8.4.1'),
}

model DescribeClusterAddonMetadataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterAddonMetadataResponseBody(name='body'),
}

/**
  * @deprecated OpenAPI DescribeClusterAddonMetadata is deprecated, please use CS::2015-12-15::DescribeAddon instead.  * @param request  the request parameters of DescribeClusterAddonMetadata  DescribeClusterAddonMetadataRequest
  * @return DescribeClusterAddonMetadataResponse
 */
// Deprecated
async function describeClusterAddonMetadata(request: DescribeClusterAddonMetadataRequest): DescribeClusterAddonMetadataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusterAddonMetadata', 'GET', '/clusters/{cluster_id}/components/{component_id}/metadata', 'json', false, 'json', request);
}

model DescribeClusterAddonUpgradeStatusRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c106f377e16f34eb1808d6b9362c9****', position='Path'),
  componentId: string(name='ComponentId', description='The component ID. Example: nginx-ingress-controller, flexvolume, or metrics-server.

You can call the `DescribeAddons` API operation to query the components supported by the cluster.

This parameter is required.', example='cloud-controller-manager', position='Path'),
}

model DescribeClusterAddonUpgradeStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: map[string]any(name='body'),
}

/**
  * @deprecated OpenAPI DescribeClusterAddonUpgradeStatus is deprecated, please use CS::2015-12-15::GetClusterAddonInstance instead.  * @param request  the request parameters of DescribeClusterAddonUpgradeStatus  DescribeClusterAddonUpgradeStatusRequest
  * @return DescribeClusterAddonUpgradeStatusResponse
 */
// Deprecated
async function describeClusterAddonUpgradeStatus(request: DescribeClusterAddonUpgradeStatusRequest): DescribeClusterAddonUpgradeStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusterAddonUpgradeStatus', 'GET', '/clusters/{ClusterId}/components/{ComponentId}/upgradestatus', 'json', false, 'json', request);
}

model DescribeClusterAddonsUpgradeStatusRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c23421cfa74454bc8b37163fd19af****', position='Path'),
  componentIds: [ string ](name='componentIds', description='The list of component names.

This parameter is required.', shrink='json', position='Query'),
}

model DescribeClusterAddonsUpgradeStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: map[string]any(name='body'),
}

/**
  * @deprecated OpenAPI DescribeClusterAddonsUpgradeStatus is deprecated, please use CS::2015-12-15::ListClusterAddonInstances,CS::2015-12-15::GetClusterAddonInstance instead.  * @param request  the request parameters of DescribeClusterAddonsUpgradeStatus  DescribeClusterAddonsUpgradeStatusRequest
  * @return DescribeClusterAddonsUpgradeStatusResponse
 */
// Deprecated
async function describeClusterAddonsUpgradeStatus(request: DescribeClusterAddonsUpgradeStatusRequest): DescribeClusterAddonsUpgradeStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusterAddonsUpgradeStatus', 'GET', '/clusters/{ClusterId}/components/upgradestatus', 'json', false, 'json', request);
}

model DescribeClusterAddonsVersionRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
}

model DescribeClusterAddonsVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: map[string]any(name='body'),
}

/**
  * @deprecated OpenAPI DescribeClusterAddonsVersion is deprecated, please use CS::2015-12-15::ListClusterAddonInstances,CS::2015-12-15::GetClusterAddonInstance instead.  * @param request  the request parameters of DescribeClusterAddonsVersion  DescribeClusterAddonsVersionRequest
  * @return DescribeClusterAddonsVersionResponse
 */
// Deprecated
async function describeClusterAddonsVersion(request: DescribeClusterAddonsVersionRequest): DescribeClusterAddonsVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusterAddonsVersion', 'GET', '/clusters/{ClusterId}/components/version', 'json', false, 'json', request);
}

model DescribeClusterAttachScriptsRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ca375a93a30474552ad2a0ebe183e****', position='Path'),
  arch?: string(name='arch', description='The CPU architecture of the node. Valid values: `amd64`, `arm`, and `arm64`.

Default value: `amd64`.

>  This parameter is required if you want to add a node to an ACK Edge cluster.', example='amd64', position='Body'),
  expired?: long(name='expired', description='The expiration time of the token that is generated. The value is a UNIX timestamp. For example, a value of 1739980800 indicates 00:00:00 (UTC+8) on February 20, 2025.', example='1740037333', position='Body'),
  formatDisk?: boolean(name='format_disk', description='Specifies whether to mount data disks to an existing instance when you manually add this instance to the cluster. You can use data disks to store container data and images. Valid values:

*   `true`: mounts data disks to the instance that you want to add. After a data disk is mounted, the original data on the disk is erased. Back up data before you mount a data disk.
*   `false`: does not mount data disks to the instance.

Default value: `false`.

How a data disk is mounted:

*   If the Elastic Compute Service (ECS) instances are already mounted with data disks and the file system of the last data disk is uninitialized, the system automatically formats this data disk to ext4 and uses the disk to store the data in the /var/lib/docker and /var/lib/kubelet directories.
*   If no data disk is mounted to the ECS instance, the system does not purchase a new data disk.', example='false', position='Body'),
  keepInstanceName?: boolean(name='keep_instance_name', description='Specifies whether to retain the name of an existing instance when it is added to the cluster. If you do not retain the instance name, the instance is renamed in the `worker-k8s-for-cs-<clusterid>` format. Valid values:

*   `true`: retains the instance name.
*   `false`: does not retain the instance name.

Default value: `true`.', example='true', position='Body'),
  nodepoolId?: string(name='nodepool_id', description='The ID of the node pool to which you want to add an existing node.

>  If you do not specify a node pool ID, the node is added to the default node pool.', example='np1c9229d9be2d432c93f77a88fca0****', position='Body'),
  options?: string(name='options', description='The node configurations for the node that you want to add.

>  This parameter is required if you want to add a node to an ACK Edge cluster.', example='{\\"enableIptables\\": true,\\"manageRuntime\\": true,\\"quiet\\": true,\\"allowedClusterAddons\\": [\\"kube-proxy\\",\\"flannel\\",\\"coredns\\"]}', position='Body'),
  rdsInstances?: [ string ](name='rds_instances', description='A list of ApsaraDB RDS instances. ECS instances in the cluster are automatically added to the whitelist of the ApsaraDB RDS instances.', position='Body'),
}

model DescribeClusterAttachScriptsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: string(name='body'),
}

/**
  * @param request  the request parameters of DescribeClusterAttachScripts  DescribeClusterAttachScriptsRequest
  * @return DescribeClusterAttachScriptsResponse
 */
async function describeClusterAttachScripts(request: DescribeClusterAttachScriptsRequest): DescribeClusterAttachScriptsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusterAttachScripts', 'POST', '/clusters/{ClusterId}/attachscript', 'string', false, 'json', request);
}

model DescribeClusterDetailRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='cdde1f21ae22e483ebcb068a6eb7f****', position='Path'),
}

model DescribeClusterDetailResponseBody = {
  clusterDomain?: string(name='cluster_domain', description='The domain name of the cluster.', example='cluster.local'),
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='c82e6987e2961451182edacd74faf****'),
  clusterSpec?: string(name='cluster_spec', description='After you set `cluster_type` to `ManagedKubernetes` and configure the `profile` parameter, you can further specify the edition of the cluster.

*   `ack.pro.small`: Pro.
*   `ack.standard`: Basic. If you leave the parameter empty, the Basic edition is selected.', example='ack.pro.small'),
  clusterType?: string(name='cluster_type', description='*   `Kubernetes`: ACK dedicated cluster.
*   `ManagedKubernetes`: ACK managed cluster. ACK managed clusters include ACK Basic clusters, ACK Pro clusters, ACK Serverless clusters (Basic and Pro), ACK Edge clusters (Basic and Pro), and ACK Lingjun clusters (Pro).
*   `ExternalKubernetes`: registered cluster.', example='Kubernetes'),
  containerCidr?: string(name='container_cidr', description='The CIDR block of the pod. The configuration of the Flannel network plug-in.', example='172.20.0.0/16'),
  controlPlaneConfig?: {
    autoRenew?: boolean(name='auto_renew', description='Indicates whether auto-renewal is enabled for the nodes.', example='true'),
    autoRenewPeriod?: long(name='auto_renew_period', description='The auto-renewal duration for the nodes.', example='1'),
    chargeType?: string(name='charge_type', description='The billing method of the control plane node.', example='PrePaid'),
    cloudMonitorFlags?: boolean(name='cloud_monitor_flags', description='Indicates whether to install CloudMonitor for the node.', example='true'),
    cpuPolicy?: string(name='cpu_policy', description='The CPU management policy of nodes.', example='none'),
    deploymentsetId?: string(name='deploymentset_id', description='The ID of the deployment set.', example='ds-bp10b35imuam5amw****'),
    imageId?: string(name='image_id', description='The ID of the image.', example='aliyun_3_x64_20G_alibase_20240819.vhd'),
    imageType?: string(name='image_type', description='The type of the OS image.', example='AliyunLinux3'),
    instanceTypes?: [ string ](name='instance_types', description='The instance types of the nodes.'),
    keyPair?: string(name='key_pair', description='The name of the key pair. You must set key_pair or login_password.', example='ack'),
    nodePortRange?: string(name='node_port_range', description='The node port range.', example='30000-32767'),
    period?: long(name='period', description='The subscription duration.', example='1'),
    periodUnit?: string(name='period_unit', description='The unit of the subscription duration.', example='Month'),
    runtime?: string(name='runtime', description='The runtime.', example='containerd'),
    securityHardeningOs?: boolean(name='security_hardening_os', description='Indicates whether to enable Alibaba Cloud Linux Security Hardening.', example='true'),
    size?: long(name='size', description='The number of control plane nodes.', example='3'),
    socEnabled?: boolean(name='soc_enabled', description='Indicates whether to enable Multi-Level Protection Scheme (MLPS) security hardening.', example='false'),
    systemDiskBurstingEnabled?: boolean(name='system_disk_bursting_enabled', description='Indicates whether to enable the burst feature for the system disk.', example='true'),
    systemDiskCategory?: string(name='system_disk_category', description='The category of the system disk for nodes.', example='cloud_essd'),
    systemDiskPerformanceLevel?: string(name='system_disk_performance_level', description='The performance level (PL) of the system disk that you want to use for the node. This parameter takes effect only for ESSDs.', example='PL1'),
    systemDiskProvisionedIops?: long(name='system_disk_provisioned_iops', description='The preset read/write IOPS of the system disk.', example='1000'),
    systemDiskSize?: long(name='system_disk_size', description='The system disk size of the node. The value must be at least 40 GB.', example='120'),
    systemDiskSnapshotPolicyId?: string(name='system_disk_snapshot_policy_id', description='The automatic snapshot policy of the node.', example='sp-2zej1nogjvovnz4z****'),
  }(name='control_plane_config', description='The control plane configurations in an ACK dedicated cluster.'),
  created?: string(name='created', description='The time when the cluster was created.', example='2019-11-25T15:50:20+08:00'),
  currentVersion?: string(name='current_version', description='The current Kubernetes version of the cluster. For more information about the Kubernetes versions supported by ACK, see [Release notes for Kubernetes versions](https://help.aliyun.com/document_detail/185269.html).', example='1.16.6-aliyun.1'),
  deletionProtection?: boolean(name='deletion_protection', description='Indicates whether deletion protection is enabled for the cluster. If deletion protection is enabled, the cluster cannot be deleted in the Container Service console or by calling API operations. Valid values:

*   `true`: deletion protection is enabled for the cluster. This way, the cluster cannot be deleted in the Container Service console or by calling API operations.
*   `false`: deletion protection is disabled for the cluster. This way, the cluster can be deleted in the Container Service console or by calling API operations.', example='true'),
  dockerVersion?: string(name='docker_version', description='The Docker version that is used by the cluster.', example='19.03.5'),
  externalLoadbalancerId?: string(name='external_loadbalancer_id', description='The ID of the Server Load Balancer (SLB) instance that is created for the Ingress of the cluster.', example='lb-2zehc05z3b8dwiifh****'),
  initVersion?: string(name='init_version', description='The initial Kubernetes version of the cluster.', example='1.16.6-aliyun.1'),
  ipStack?: string(name='ip_stack', description='The IP stack of the cluster. Valid values:

*   ipv4: The cluster is an IPv4 cluster.
*   dual: The cluster is an IPv4/IPv6 dual-stack cluster.', example='ipv4'),
  maintenanceWindow?: MaintenanceWindow(name='maintenance_window', description='The maintenance window of the cluster. This feature is available only in ACK Pro clusters.'),
  masterUrl?: string(name='master_url', description='The endpoints of the cluster, including an internal endpoint and a public endpoint.', example='{\\"intranet_api_server_endpoint\\":\\"https://192.168.0.251:6443\\"***}'),
  metaData?: string(name='meta_data', description='The metadata of the cluster.', example='\\"Addons\\":***'),
  name?: string(name='name', description='The name of the cluster.

The name must be 1 to 63 characters in length, and can contain digits, letters, and hyphens (-). The name cannot start with a hyphen (-).', example='cluster-demo'),
  networkMode?: string(name='network_mode', description='The network type of the cluster. Example: Virtual Private Cloud (VPC).', example='vpc'),
  nextVersion?: string(name='next_version', description='The Kubernetes version to which the cluster can be updated.', example='1.18.8-aliyun.1'),
  nodeCidrMask?: string(name='node_cidr_mask', description='The maximum number of IP addresses that can be assigned to nodes. This number is determined by the node CIDR block. This parameter takes effect only if the cluster uses Flannel network plug-in.', example='26'),
  operationPolicy?: {
    clusterAutoUpgrade?: {
      channel?: string(name='channel', description='The frequency of auto cluster updates. For more information, see [Update frequency](https://help.aliyun.com/document_detail/2712866.html).

Valid values:

*   patch: specifies the latest patch version.
*   stable: specifies the second-latest minor version.
*   rapid: specifies the latest minor version.', example='patch'),
      enabled?: boolean(name='enabled', description='Specifies whether to enable auto cluster update.', example='true'),
    }(name='cluster_auto_upgrade', description='The configurations of auto cluster update.'),
  }(name='operation_policy', description='The automatic O\\&M policy of the cluster.'),
  parameters?: map[string]string(name='parameters', description='The Resource Orchestration Service (ROS) parameters of the cluster.'),
  privateZone?: boolean(name='private_zone', description='Indicates whether Alibaba Cloud DNS PrivateZone (PrivateZone) is enabled for the cluster. Valid values:

*   `true`: PrivateZone is enabled.
*   `false`: PrivateZone is dislabled.

Default value: false', example='false'),
  profile?: string(name='profile', description='If you set `cluster_type` to `ManagedKubernetes`, an ACK managed cluster is created. In this case, you can further specify the cluster edition.

*   `Default`. ACK managed cluster. ACK managed clusters include ACK Basic clusters and ACK Pro clusters.
*   `Edge`: ACK Edge cluster. ACK Edge clusters include ACK Edge Basic clusters and ACK Edge Pro clusters.
*   `Serverless`: ACK Serverless cluster. ACK Serverless clusters include ACK Serverless Basic clusters and ACK Serverless Pro clusters.
*   `Lingjun`: ACK Lingjun Pro cluster.', example='Default'),
  proxyMode?: string(name='proxy_mode', description='The kube-proxy mode. Valid values:

*   `iptables`: a mature and stable kube-proxy mode that uses iptables rules to conduct Service discovery and load balancing. The performance of this mode is limited by the size of the cluster. This mode is suitable for clusters that run a small number of Services.
*   `ipvs`: provides high performance and uses IP Virtual Server (IPVS). This allows you to configure service discovery and load balancing. This mode is suitable for clusters that are required to run a large number of services. We recommend that you use this mode in scenarios that require high load balancing performance.', example='ipvs'),
  regionId?: string(name='region_id', description='The region ID of the cluster.', example='cn-beijing'),
  resourceGroupId?: string(name='resource_group_id', description='The ID of the resource group to which the cluster belongs.', example='rg-acfmyvw3wjm****'),
  securityGroupId?: string(name='security_group_id', description='The ID of the security group to which the cluster belongs.', example='sg-25yq****'),
  serviceCidr: string(name='service_cidr', description='The CIDR block of the service network.

This parameter is required.', example='172.21.0.0/20'),
  size?: long(name='size', description='The number of nodes in the cluster. Master nodes and worker nodes are included.', example='5'),
  state?: string(name='state', description='The status of the cluster. Valid values:

*   `initial`: The cluster is being created.
*   `failed`: The cluster failed to be created.
*   `running`: The cluster is running.
*   `updating`: The cluster is being updated.
*   `updating_failed`: The cluster failed to be updated.
*   `scaling`: The cluster is being scaled.
*   `waiting`: The cluster is waiting for connection requests.
*   `disconnected`: The cluster is disconnected.
*   `stopped`: The cluster is stopped.
*   `deleting`: The cluster is being deleted.
*   `deleted`: The cluster is deleted.
*   `delete_failed`: The cluster failed to be deleted.', example='running'),
  subnetCidr?: string(name='subnet_cidr', description='The pod CIDR block. It must be a valid and private CIDR block, and must be one of the following CIDR blocks or their subnets:

*   10.0.0.0/8
*   172.16-31.0.0/12-16
*   192.168.0.0/16

The pod CIDR block cannot overlap with the CIDR block of the VPC in which the cluster is deployed and the CIDR blocks of existing clusters in the VPC. You cannot modify the pod CIDR block after you create the cluster.

For more information about the network planning of ACK clusters, see [Plan CIDR blocks for an ACK cluster](https://help.aliyun.com/document_detail/186964.html).', example='172.20.0.0/16', deprecated='true'),
  tags?: [
    Tag
  ](name='tags', description='The resource tags of the cluster.'),
  timezone?: string(name='timezone', description='The time zone', example='Asia/Shanghai'),
  updated?: string(name='updated', description='The time when the cluster was updated.', example='2020-01-13T23:01:03+08:00'),
  vpcId?: string(name='vpc_id', description='The ID of the VPC where the cluster is deployed. This parameter is required when you create a cluster.', example='vpc-2zecuu62b9zw7a7qn****'),
  vswitchId?: string(name='vswitch_id', description='The ID of the vSwitche. This field is deprecated. Use vswitch_ids to query the vSwitches on the control plane and vswitch_ids to query the vSwitches on the data plane.', example='vsw-2zete8s4qocqg0mf6****,vsw-2zete8s4qocqg0mf6****', deprecated='true'),
  vswitchIds?: [ string ](name='vswitch_ids', description='The vSwitch for the control plane of the cluster.'),
  workerRamRoleName?: string(name='worker_ram_role_name', description='The name of the worker Resource Access Management (RAM) role. The RAM role is assigned to the worker nodes of the cluster to allow the worker nodes to manage Elastic Compute Service (ECS) instances.', example='KubernetesWorkerRole-ec87d15b-edca-4302-933f-c8a16bf0****'),
  zoneId?: string(name='zone_id', description='The ID of the zone within the region where the cluster is located.', example='cn-beijing-a'),
}

model DescribeClusterDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterDetailResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeClusterDetail  DescribeClusterDetailRequest
  * @return DescribeClusterDetailResponse
 */
async function describeClusterDetail(request: DescribeClusterDetailRequest): DescribeClusterDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusterDetail', 'GET', '/clusters/{ClusterId}', 'json', false, 'json', request);
}

model DescribeClusterEventsRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
  pageNumber?: long(name='page_number', description='The number of the page to return.', example='1', position='Query'),
  pageSize?: long(name='page_size', description='The number of entries per page. Valid values: 1 to 50. Default value: 50.', example='50', position='Query'),
  taskId?: string(name='task_id', description='The ID of the query task.', example='T-xascadasd*****', position='Query'),
}

model DescribeClusterEventsResponseBody = {
  events?: [ 
    {
      clusterId?: string(name='cluster_id', description='The ID of the cluster.', example='c82e6987e2961451182edacd74faf****'),
      data?: {
        level?: string(name='level', description='The severity level of the event.

Valid values:

*   warning

    <!-- -->

    <!-- -->

    <!-- -->

*   error

    <!-- -->

    <!-- -->

    <!-- -->

*   info

    <!-- -->

    <!-- -->

    <!-- -->', example='info'),
        message?: string(name='message', description='The details of the event.', example='Start to upgrade NodePool nodePool/npdd89dc2b76c04f14b06774883b******'),
        reason?: string(name='reason', description='The status of the event.', example='Started'),
      }(name='data', description='The description of the event.'),
      eventId?: string(name='event_id', description='The event ID.', example='e-9ad04f72-8ee7-46bf-a02c-e4a06b39****'),
      source?: string(name='source', description='The event source.', example='cluster'),
      subject?: string(name='subject', description='The subject related to the event.', example='npdd89dc2b76c04f14b06774883b******'),
      time?: string(name='time', description='The time when the event started.', example='2020-12-01T17:31:00Z'),
      type?: string(name='type', description='The type of event. Valid values:', example='nodepool_update'),
    }
  ](name='events', description='The list of events.'),
  pageInfo?: {
    pageNumber?: long(name='page_number', description='The number of the page to return.', example='1'),
    pageSize?: long(name='page_size', description='The number of entries per page. Valid values: 1 to 50. Default value: 50.', example='50'),
    totalCount?: long(name='total_count', description='The total number of entries returned.', example='3'),
  }(name='page_info', description='The pagination information.'),
}

model DescribeClusterEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterEventsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeClusterEvents  DescribeClusterEventsRequest
  * @return DescribeClusterEventsResponse
 */
async function describeClusterEvents(request: DescribeClusterEventsRequest): DescribeClusterEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusterEvents', 'GET', '/clusters/{ClusterId}/events', 'json', false, 'json', request);
}

model DescribeClusterLogsRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c106f377e16f34eb1808d6b9362c9****', position='Path'),
}

model DescribeClusterLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      id?: long(name='ID', description='The ID of the log entry.', example='590749245'),
      clusterId?: string(name='cluster_id', description='The cluster ID.', example='c23421cfa74454bc8b37163fd19af***'),
      clusterLog?: string(name='cluster_log', description='The log content.', example='start to update cluster status to CREATE_COMPLETE'),
      created?: string(name='created', description='The time when the log entry was generated.', example='2020-09-11T10:11:51+08:00'),
      updated?: string(name='updated', description='The time when the log entry was updated.', example='2020-09-11T10:11:51+08:00'),
    }
  ](name='body'),
}

/**
  * @param request  the request parameters of DescribeClusterLogs  DescribeClusterLogsRequest
  * @return DescribeClusterLogsResponse
 */
async function describeClusterLogs(request: DescribeClusterLogsRequest): DescribeClusterLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusterLogs', 'GET', '/clusters/{ClusterId}/logs', 'array', false, 'json', request);
}

model DescribeClusterNodePoolDetailRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster that you want to query.

This parameter is required.', example='c23421cfa74454bc8b37163fd19af****', position='Path'),
  nodepoolId: string(name='NodepoolId', description='The node pool ID.

This parameter is required.', example='np31da1b38983f4511b490fc62108a****', position='Path'),
}

model DescribeClusterNodePoolDetailResponseBody = {
  autoMode?: {
    enable?: boolean(name='enable'),
  }(name='auto_mode'),
  autoScaling?: {
    eipBandwidth?: long(name='eip_bandwidth', description='The maximum bandwidth of the elastic IP address (EIP).', example='5'),
    eipInternetChargeType?: string(name='eip_internet_charge_type', description='The metering method of the EIP. Valid values:

*   `PayByBandwidth`: pay-by-bandwidth.
*   `PayByTraffic`: pay-by-data-transfer.', example='PayByBandwidth'),
    enable?: boolean(name='enable', description='Indicates whether auto scaling is enabled. Valid values:

*   `true`: auto scaling is enabled.
*   `false`: auto scaling is disabled. If this parameter is set to false, other parameters in the `auto_scaling` section do not take effect.', example='true'),
    isBondEip?: boolean(name='is_bond_eip', description='Indicates whether an EIP is associated with the node pool. Valid values:

*   `true`: An EIP is associated with the node pool.
*   `false`: No EIP is associated with the node pool.', example='true'),
    maxInstances?: long(name='max_instances', description='The maximum number of Elastic Compute Service (ECS) instances that can be created in the node pool.', example='10'),
    minInstances?: long(name='min_instances', description='The minimum number of ECS instances that must be kept in the node pool.', example='1'),
    type?: string(name='type', description='The instance types that can be used for the auto scaling of the node pool. Valid values:

*   `cpu`: regular instance.
*   `gpu`: GPU-accelerated instance.
*   `gpushare`: shared GPU-accelerated instance.
*   `spot`: preemptible instance.', example='cpu'),
  }(name='auto_scaling', description='The auto scaling configuration of the node pool.'),
  hostNetwork?: boolean(name='host_network', description='Indicates whether the pods in the edge node pool can use the host network.

`true`: sets to host network.

`false`: sets to container network.', example='true'),
  interconnectConfig?: {
    bandwidth?: long(name='bandwidth', description='The bandwidth of the enhanced edge node pool. Unit: Mbit/s.', example='10'),
    ccnId?: string(name='ccn_id', description='The ID of the Cloud Connect Network (CCN) instance that is associated with the enhanced edge node pool.', example='ccn-qm5i0i0q9yi*******'),
    ccnRegionId?: string(name='ccn_region_id', description='The region to which the CCN instance that is associated with the enhanced edge node pool belongs.', example='cn-shanghai'),
    cenId?: string(name='cen_id', description='The ID of the Cloud Enterprise Network (CEN) instance that is associated with the enhanced edge node pool.', example='cen-ey9k9nfhz0f*******'),
    improvedPeriod?: string(name='improved_period', description='The subscription duration of the enhanced edge node pool. The duration is measured in months.', example='1'),
  }(name='interconnect_config', description='The network configuration of the edge node pool. This parameter takes effect only for edge node pools.'),
  interconnectMode?: string(name='interconnect_mode', description='The network type of the edge node pool. This parameter takes effect only if you set the type parameter of the node pool to edge. Valid values:

`basic`: Internet.

`private`: private network.', example='improved'),
  intranet?: boolean(name='intranet', description='Specifies whether all nodes in the edge node pool can communicate with each other at Layer 3.

`true`: The nodes in the edge node pool can communicate with each other at Layer 3.

`false`: The nodes in the edge node pool cannot communicate with each other at Layer 3.', example='true'),
  kubernetesConfig?: {
    cmsEnabled?: boolean(name='cms_enabled', description='Indicates whether the CloudMonitor agent is installed on ECS nodes in the cluster. After the CloudMonitor agent is installed, you can view monitoring information about the ECS instances in the CloudMonitor console. Installation is recommended. Valid values:

*   `true`: The CloudMonitor agent is installed on ECS nodes.
*   `false`: The CloudMonitor agent is not installed on ECS nodes.', example='true'),
    cpuPolicy?: string(name='cpu_policy', description='The CPU management policy of the nodes in the node pool. The following policies are supported if the Kubernetes version of the cluster is 1.12.6 or later.

*   `static`: allows pods with specific resource characteristics on the node to be granted enhanced CPU affinity and exclusivity.
*   `none`: indicates that the default CPU affinity is used.', example='none'),
    labels?: [
      Tag
    ](name='labels', description='The labels that you want to add to the nodes in the cluster. You must add labels based on the following rules:

*   A label is a case-sensitive key-value pair. You can add up to 20 labels.
*   The key must be unique and cannot exceed 64 characters in length. The value can be empty and cannot exceed 128 characters in length. Keys and values cannot start with `aliyun`, `acs:`, `https://`, or `http://`. For more information, see [Labels and Selectors](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set).'),
    nodeNameMode?: string(name='node_name_mode', description='A custom node name consists of a prefix, an IP substring, and a suffix.

*   The prefix and suffix can contain multiple parts that are separated by periods (.). Each part can contain lowercase letters, digits, and hyphens (-). A custom node name must start and end with a digit or lowercase letter.
*   The IP substring length specifies the number of digits to be truncated from the end of the node IP address. The IP substring length ranges from 5 to 12.

For example, if the node IP address is 192.168.0.55, the prefix is aliyun.com, the IP substring length is 5, and the suffix is test, the node name will be aliyun.com00055test.', example='customized,test.,5,.com'),
    preUserData?: string(name='pre_user_data', description='The user-defined script that is executed before nodes are initialized. For more information, see [Generate user-defined data](https://help.aliyun.com/document_detail/49121.html).', example='dGhpcyBpcyBhIGV4YW1wbGU'),
    runtime?: string(name='runtime', description='The name of the container runtime.', example='docker'),
    runtimeVersion?: string(name='runtime_version', description='The version of the container runtime.', example='19.03.5'),
    taints?: [
      Taint
    ](name='taints', description='The taints that you want to add to nodes. Taints can be used together with tolerations to prevent pods from being scheduled to specific nodes. For more information, see [taint-and-toleration](https://kubernetes.io/zh/docs/concepts/scheduling-eviction/taint-and-toleration/).'),
    unschedulable?: boolean(name='unschedulable', description='Whether the expanded node is schedulable.', example='true'),
    userData?: string(name='user_data', description='The custom script to be executed after nodes in the node pool are initialized. For more information, see [Generate user-defined data](https://help.aliyun.com/document_detail/49121.html).', example='IyEvYmluL3NoCmVjaG8gIkhlbGxvIEFDSyEi'),
  }(name='kubernetes_config', description='The configurations of the cluster in which the node pool is deployed.'),
  management?: {
    autoRepair?: boolean(name='auto_repair', description='Indicates whether auto repair is enabled. This parameter takes effect only when `enable=true` is specified. Valid values:

*   `true`: Auto repair is enabled.
*   `false`: Auto repair is disabled.', example='true'),
    autoRepairPolicy?: {
      restartNode?: boolean(name='restart_node', description='Whether to allow restarting nodes.', example='true'),
    }(name='auto_repair_policy', description='Automatic repair node policy.'),
    autoUpgrade?: boolean(name='auto_upgrade', description='Whether to automatically upgrade.', example='true'),
    autoUpgradePolicy?: {
      autoUpgradeKubelet?: boolean(name='auto_upgrade_kubelet', description='Whether to allow automatic upgrading of kubelet.', example='true'),
    }(name='auto_upgrade_policy', description='Automatic upgrade policy.'),
    autoVulFix?: boolean(name='auto_vul_fix', description='Whether to automatically fix CVEs.', example='true'),
    autoVulFixPolicy?: {
      restartNode?: boolean(name='restart_node', description='Whether to allow restarting nodes.', example='true'),
      vulLevel?: string(name='vul_level', description='The vulnerability levels allowed for auto-fixing, separated by commas.', example='asap,nntf'),
    }(name='auto_vul_fix_policy', description='Automatically repair CVE policies.'),
    enable?: boolean(name='enable', description='Indicates whether the managed node pool feature is enabled. Valid values:

*   `true`: The managed node pool feature is enabled.
*   `false`: The managed node pool feature is disabled. Other parameters in this section take effect only when `enable=true` is specified.', example='true'),
    upgradeConfig?: {
      autoUpgrade?: boolean(name='auto_upgrade', description='Indicates whether auto update is enabled. Valid values:

*   `true`: Auto update is enabled.
*   `false`: Auto update is disabled.', example='true'),
      maxUnavailable?: long(name='max_unavailable', description='The maximum number of nodes that can be in the Unavailable state. Valid values: 1 to 1000.

Default value: 1.', example='1'),
      surge?: long(name='surge', description='The number of additional nodes.', example='5'),
      surgePercentage?: long(name='surge_percentage', description='The percentage of additional nodes to the nodes in the node pool. You must set this parameter or `surge`.', example='50'),
    }(name='upgrade_config', description='The configuration of auto update. The configuration takes effect only when `enable=true` is specified.'),
  }(name='management', description='The configuration of the managed node pool feature.'),
  maxNodes?: long(name='max_nodes', description='This parameter is deprecated.

The maximum number of nodes allowed in an edge node pool.', example='10'),
  nodeConfig?: {
    kubeletConfiguration?: KubeletConfig(name='kubelet_configuration', description='The configurations of the kubelet.'),
  }(name='node_config', description='The node configurations.'),
  nodepoolInfo?: {
    created?: string(name='created', description='The time when the node pool was created.', example='2020-09-27T19:14:09.156823496+08:00'),
    isDefault?: boolean(name='is_default', description='Indicates whether the node pool is a default node pool. A Container Service for Kubernetes (ACK) cluster usually has only one default node pool. Valid values: `true`: The node pool is a default node pool. `false`: The node pool is not a default node pool.', example='true'),
    name?: string(name='name', description='The name of the node pool.

The name must be 1 to 63 characters in length, and can contain digits, letters, and hyphens (-). It cannot start with a hyphen (-).', example='default-nodepool'),
    nodepoolId?: string(name='nodepool_id', description='The node pool ID.', example='np615c0e0966124216a0412e10afe0****'),
    regionId?: string(name='region_id', description='The region ID.', example='cn-beijing'),
    resourceGroupId?: string(name='resource_group_id', description='The ID of the resource group.', example='rg-acfmyvw3wjmb****'),
    type?: string(name='type', description='The type of node pool.', example='ess'),
    updated?: string(name='updated', description='The time when the node pool was last updated.', example='2020-09-27T20:37:46+08:00'),
  }(name='nodepool_info', description='The configuration of the node pool.'),
  scalingGroup?: {
    autoRenew?: boolean(name='auto_renew', description='Indicates whether auto-renewal is enabled for the nodes in the node pool. This parameter takes effect only when `instance_charge_type` is set to `PrePaid`. Valid values:

*   `true`: Auto-renewal is enabled.
*   `false`: Auto-renewal is disabled.', example='false'),
    autoRenewPeriod?: long(name='auto_renew_period', description='The duration of the auto-renewal. This parameter takes effect and is required only when `instance_charge_type` is set to `PrePaid`.

If you specify `PeriodUnit=Month`, the valid values are 1, 2, 3, 6, and 12.', example='1'),
    cisEnabled?: boolean(name='cis_enabled', description='[**Deprecated**] Please use the parameter security_hardening_os instead.', example='false', deprecated='true'),
    compensateWithOnDemand?: boolean(name='compensate_with_on_demand', description='Indicates whether pay-as-you-go instances are automatically created to meet the required number of ECS instances if preemptible instances cannot be created due to reasons such as cost or insufficient inventory. This parameter takes effect when `multi_az_policy` is set to `COST_OPTIMIZED`. Valid values:

*   `true`: Pay-as-you-go instances are automatically created to meet the required number of ECS instances if preemptible instances cannot be created.
*   `false`: Pay-as-you-go instances are not automatically created to meet the required number of ECS instances if preemptible instances cannot be created.', example='true'),
    dataDisks?: [
      DataDisk
    ](name='data_disks', description='The configurations of the data disks that are attached to the nodes in the node pool. The configurations include the disk category and disk size.'),
    deploymentsetId?: string(name='deploymentset_id', description='The ID of the deployment set to which the ECS instances in the node pool belong.', example='ds-bp1d19mmbsv3jf6xxxxx'),
    desiredSize?: long(name='desired_size', description='The expected number of nodes in the node pool.', example='2'),
    imageId?: string(name='image_id', description='The ID of the custom image. You can call the `DescribeKubernetesVersionMetadata` operation to query the images supported by ACK.', example='aliyun_2_1903_x64_20G_alibase_20200529.vhd'),
    imageType?: string(name='image_type', description='Operating system image type.', example='AliyunLinux'),
    instanceChargeType?: string(name='instance_charge_type', description='The billing method of the nodes in the node pool. Valid values:

*   `PrePaid`: the subscription billing method.
*   `PostPaid`: the pay-as-you-go billing method.', example='PostPaid'),
    instancePatterns?: [
      InstancePatterns
    ](name='instance_patterns', description='The instance properties.'),
    instanceTypes?: [ string ](name='instance_types', description='A list of instance types. You can select multiple instance types. When the system needs to create a node, it starts from the first instance type until the node is created. The instance type that is used to create the node varies based on the actual instance stock.'),
    internetChargeType?: string(name='internet_charge_type', description='The billing method of the public IP address of the node.', example='PayByBandwidth'),
    internetMaxBandwidthOut?: long(name='internet_max_bandwidth_out', description='The maximum outbound bandwidth of the public IP address of the node. Unit: Mbit/s. Valid values: 1 to 100.', example='10'),
    keyPair?: string(name='key_pair', description='The name of the key pair. You must set this parameter or the `login_password` parameter. You must set `key_pair` if the node pool is a managed node pool.', example='pro-nodepool'),
    loginAsNonRoot?: boolean(name='login_as_non_root', description='Whether the popped ECS instance uses a non-root user for login.', example='true'),
    loginPassword?: string(name='login_password', description='The password for SSH logon. You must set this parameter or the `key_pair` parameter. The password must be 8 to 30 characters in length, and must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.

For security purposes, the returned password is encrypted.', example='********'),
    multiAzPolicy?: string(name='multi_az_policy', description='The ECS instance scaling policy for a multi-zone scaling group. Valid values:

*   `PRIORITY`: the scaling group is scaled based on the VSwitchIds.N parameter. If an ECS instance cannot be created in the zone where the vSwitch that has the highest priority resides, Auto Scaling creates the ECS instance in the zone where the vSwitch that has the next highest priority resides.

*   `COST_OPTIMIZED`: ECS instances are created based on the vCPU unit price in ascending order. Preemptible instances are preferably created when preemptible instance types are specified in the scaling configuration. You can set the `CompensateWithOnDemand` parameter to specify whether to automatically create pay-as-you-go instances when preemptible instances cannot be created due to insufficient resources.

    **

    **Note**The `COST_OPTIMIZED` setting takes effect only when multiple instance types are specified or at least one instance type is specified for preemptible instances.

*   `BALANCE`: ECS instances are evenly distributed across multiple zones specified by the scaling group. If ECS instances become imbalanced among multiple zones due to insufficient inventory, you can call the RebalanceInstances operation of Auto Scaling to balance the instance distribution among zones. For more information, see [RebalanceInstances](https://help.aliyun.com/document_detail/71516.html).

Default value: `PRIORITY`.', example='BALANCE'),
    onDemandBaseCapacity?: long(name='on_demand_base_capacity', description='The minimum number of pay-as-you-go instances that must be kept in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferably creates pay-as-you-go instances.', example='0'),
    onDemandPercentageAboveBaseCapacity?: long(name='on_demand_percentage_above_base_capacity', description='The percentage of pay-as-you-go instances among the extra instances that exceed the number specified by `on_demand_base_capacity`. Valid values: 0 to 100.', example='20'),
    period?: long(name='period', description='The subscription duration of worker nodes. This parameter takes effect and is required only when `instance_charge_type` is set to `PrePaid`.

If `PeriodUnit=Month` is specified, the valid values are 1, 2, 3, 6, 12, 24, 36, 48, and 60.', example='0'),
    periodUnit?: string(name='period_unit', description='The billing cycle of the nodes. This parameter is required if `instance_charge_type` is set to `PrePaid`.

Valid value: `Month`.', example='Month'),
    platform?: string(name='platform', description='The release version of the operating system. Valid values:

*   `CentOS`
*   `AliyunLinux`
*   `Windows`
*   `WindowsCore`', example='AliyunLinux'),
    privatePoolOptions?: {
      id?: string(name='id', description='The ID of the private node pool.', example='eap-bp67acfmxazb4****'),
      matchCriteria?: string(name='match_criteria', description='The type of private node pool. This parameter specifies the type of private node pool that you want to use to create instances. A private node pool is generated when an elasticity assurance or a capacity reservation service takes effect. The system selects a private node pool to launch instances. Valid values:

*   `Open`: open private pool. The system selects an open private node pool to launch instances. If no matching open private node pool is available, the resources in the public node pool are used.
*   `Target`: specific private pool. The system uses the resources of the specified private node pool to launch instances. If the specified private node pool is unavailable, instances cannot be launched.
*   `None`: no private node pool is used. The resources of private node pools are not used to launch the instances.', example='Open'),
    }(name='private_pool_options', description='The configuration of the private node pool.'),
    ramPolicy?: string(name='ram_policy', description='The name of the worker Resource Access Management (RAM) role. The RAM role is assigned to the worker nodes of the cluster to allow the worker nodes to manage ECS instances.', example='KubernetesWorkerRole-021dc54f-929b-437a-8ae0-34c24d3e****'),
    ramRoleName?: string(name='ram_role_name', description='Worker RAM role name.', example='KubernetesWorkerRole-4a4fa089-80c1-48a5-b3c6-9349311f****'),
    rdsInstances?: [ string ](name='rds_instances', description='After you specify the list of RDS instances, the ECS instances in the cluster are automatically added to the whitelist of the RDS instances.'),
    scalingGroupId?: string(name='scaling_group_id', description='The ID of the scaling group.', example='asg-2zeieod8giqmov7z****'),
    scalingPolicy?: string(name='scaling_policy', description='The scaling mode of the scaling group. Valid values:

*   `release`: the standard mode. ECS instances are created and released based on resource usage.
*   `recycle`: the swift mode. ECS instances are created, stopped, or started during scaling events. This reduces the time required for the next scale-out event. When the instance is stopped, you are charged only for the storage service. This does not apply to ECS instances that are attached with local disks.', example='release'),
    securityGroupId?: string(name='security_group_id', description='The ID of the security group to which the node pool is added. If the node pool is added to multiple security groups, the first ID in the value of `security_group_ids` is returned.', example='sg-2ze60ockeekspl3d****'),
    securityGroupIds?: [ string ](name='security_group_ids', description='The IDs of the security groups to which the node pool is added.'),
    securityHardeningOs?: boolean(name='security_hardening_os', description='Alibaba Cloud OS security hardening. Values:
- `true`: Enable Alibaba Cloud OS security hardening. 
- `false`: Do not enable Alibaba Cloud OS security hardening.

Default value: `false`.', example='false'),
    socEnabled?: boolean(name='soc_enabled', description='Indicates whether to enable security reinforcement compliant with the hardening standards. This option is available only when the system image is set to Alibaba Cloud Linux 2 or Alibaba Cloud Linux 3. Alibaba Cloud provides baseline check standards and scanning programs compliant with Grade 3, Version 2.0 of the hardening standards for both Alibaba Cloud Linux 2 and Alibaba Cloud Linux 3 images.', example='false'),
    spotInstancePools?: long(name='spot_instance_pools', description='The number of instance types that are available for creating preemptible instances. Auto Scaling creates preemptible instances of multiple instance types that are available at the lowest cost. Valid values: 1 to 10.', example='5'),
    spotInstanceRemedy?: boolean(name='spot_instance_remedy', description='Indicates whether preemptible instances are supplemented when the number of preemptible instances drops below the specified minimum number. If this parameter is set to true, when the scaling group receives a system message that a preemptible instance is to be reclaimed, the scaling group attempts to create a new instance to replace this instance. Valid values: Valid values:

*   `true`: Supplementation of preemptible instances is enabled.
*   `false`: Supplementation of preemptible instances is disabled.', example='false'),
    spotPriceLimit?: [ 
      {
        instanceType?: string(name='instance_type', description='The instance type of the preemptible instances.', example='ecs.c6.large'),
        priceLimit?: string(name='price_limit', description='The price cap of a preemptible instance of the type.

Unit: USD/hour.', example='0.39'),
      }
    ](name='spot_price_limit', description='The bid configurations of preemptible instances.'),
    spotStrategy?: string(name='spot_strategy', description='The type of preemptible instance. Valid values:

*   NoSpot: a non-preemptible instance.
*   SpotWithPriceLimit: a preemptible instance that is configured with the highest bid price.
*   SpotAsPriceGo: a preemptible instance for which the system automatically bids based on the current market price.

For more information, see [Preemptible instances](https://help.aliyun.com/document_detail/157759.html).', example='NoSpot'),
    systemDiskBurstingEnabled?: boolean(name='system_disk_bursting_enabled', description='Whether to enable Burst (performance burst) for the node system disk, configured when the disk type is cloud_auto.', example='true'),
    systemDiskCategories?: [ string ](name='system_disk_categories', description='The categories of the system disk for nodes. The system attempts to create system disks of a disk category with a lower priority if the disk category with a higher priority is unavailable. Valid values: Valid values:

*   `cloud`: basic disk.
*   `cloud_efficiency`: ultra disk.
*   `cloud_ssd`: standard SSD.
*   `cloud_essd`: Enterprise SSD (ESSD).
*   `cloud_auto`: ESSD AutoPL disk.
*   `cloud_essd_entry`: ESSD Entry disk.

Default value: `cloud_efficiency`.'),
    systemDiskCategory?: string(name='system_disk_category', description='The system disk type. Valid values:

*   `cloud`: basic disk
*   `cloud_efficiency`: ultra disk
*   `cloud_ssd`: standard SSD
*   `cloud_essd`: Enterprise SSD (ESSD)
*   `cloud_auto`: ESSD AutoPL disk
*   `cloud_essd_entry`: ESSD Entry disk

Default value: `cloud_efficiency`.', example='cloud_efficiency'),
    systemDiskEncryptAlgorithm?: string(name='system_disk_encrypt_algorithm', description='The encryption algorithm that is used to encrypt the system disk. Set the value to aes-256.', example='aes-256'),
    systemDiskEncrypted?: boolean(name='system_disk_encrypted', description='Specifies whether to encrypt the system disk. Valid values: Valid values:

*   `true`: encrypts the system disk.
*   `false`: does not encrypt the system disk.', example='false'),
    systemDiskKmsKeyId?: string(name='system_disk_kms_key_id', description='System disk\\"s KMS key ID.', example='0e478b7a-4262-4802-b8cb-00d3fb40****'),
    systemDiskPerformanceLevel?: string(name='system_disk_performance_level', description='The performance level (PL) of the system disk that you want to use for the node. This parameter takes effect only for enhanced SSDs (ESSDs).', example='PL1'),
    systemDiskProvisionedIops?: long(name='system_disk_provisioned_iops', description='Pre-configured read and write IOPS for the system disk of the node, configured when the disk type is cloud_auto.', example='1000'),
    systemDiskSize?: long(name='system_disk_size', description='The system disk size of a node. Unit: GiB.

Valid values: 20 to 500.', example='120'),
    tags?: [
      Tag
    ](name='tags', description='The labels that you want to add only to ECS instances.

The label key must be unique and cannot exceed 128 characters in length. The label key and value cannot start with aliyun or acs: or contain https:// or http://.'),
    vswitchIds?: [ string ](name='vswitch_ids', description='The IDs of vSwitches. You can specify 1 to 20 vSwitches.

> We recommend that you select vSwitches in different zones to ensure high availability.'),
  }(name='scaling_group', description='The configurations of the scaling group used by the node pool.'),
  status?: {
    failedNodes?: long(name='failed_nodes', description='The number of failed nodes.', example='0'),
    healthyNodes?: long(name='healthy_nodes', description='The number of healthy nodes.', example='3'),
    initialNodes?: long(name='initial_nodes', description='The number of nodes that are being created.', example='0'),
    offlineNodes?: long(name='offline_nodes', description='The number of offline nodes.', example='0'),
    removingNodes?: long(name='removing_nodes', description='The number of nodes that are being removed.', example='0'),
    servingNodes?: long(name='serving_nodes', description='The number of running nodes.', example='3'),
    state?: string(name='state', description='The status of the node pool. Valid values:

*   `active`: The node pool is active.
*   `scaling`: The node pool is being scaled.
*   `removing`: Nodes are being removed from the node pool.
*   `deleting`: The node pool is being deleted.
*   `updating`: The node pool is being updated.', example='active'),
    totalNodes?: long(name='total_nodes', description='The total number of nodes in the node pool.', example='3'),
  }(name='status', description='The status details about the node pool.'),
  teeConfig?: {
    teeEnable?: boolean(name='tee_enable', description='Indicates whether confidential computing is enabled. Valid values:

*   `true`: Confidential computing is enabled.
*   `false`: Confidential computing is disabled.', example='false'),
  }(name='tee_config', description='The configuration of confidential computing.'),
}

model DescribeClusterNodePoolDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterNodePoolDetailResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeClusterNodePoolDetail  DescribeClusterNodePoolDetailRequest
  * @return DescribeClusterNodePoolDetailResponse
 */
async function describeClusterNodePoolDetail(request: DescribeClusterNodePoolDetailRequest): DescribeClusterNodePoolDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusterNodePoolDetail', 'GET', '/clusters/{ClusterId}/nodepools/{NodepoolId}', 'json', false, 'json', request);
}

model DescribeClusterNodePoolsRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster that you want to query.

This parameter is required.', example='cc0f87de0b8fb403f86e10e204f83****', position='Path'),
  nodepoolName?: string(name='NodepoolName', description='Node pool name.', example='nodepool-test', position='Query'),
}

model DescribeClusterNodePoolsResponseBody = {
  nodepools?: [ 
    {
      autoMode?: {
        enable?: boolean(name='enable'),
      }(name='auto_mode'),
      autoScaling?: {
        eipBandwidth?: long(name='eip_bandwidth', description='The maximum bandwidth of the elastic IP address (EIP).', example='5'),
        eipInternetChargeType?: string(name='eip_internet_charge_type', description='The billing method of the EIP. Valid values:

*   `PayByBandwidth`: pay-by-bandwidth.
*   `PayByTraffic`: pay-by-data-transfer.', example='PayByBandwidth'),
        enable?: boolean(name='enable', description='Specifies whether to enable auto scaling. Valid values:

*   `true`
*   `false`: If you set this parameter to `false`, other parameters in `auto_scaling` do not take effect.', example='true'),
        isBondEip?: boolean(name='is_bond_eip', description='Specifies whether to associate an EIP with the node pool. Valid values:

*   `true`
*   `false`', example='true'),
        maxInstances?: long(name='max_instances', description='The maximum number of Elastic Compute Service (ECS) instances that can be created in the node pool.', example='10'),
        minInstances?: long(name='min_instances', description='The minimum number of ECS instances that must be retained in the node pool.', example='2'),
        type?: string(name='type', description='The instance types that can be used for the auto scaling of the node pool. Valid values:

*   `cpu`: regular instance.
*   `gpu`: GPU-accelerated instance.
*   `gpushare`: shared GPU-accelerated instance.
*   `spot`: preemptible instance.', example='cpu'),
      }(name='auto_scaling', description='The configurations of auto scaling.'),
      interconnectConfig?: {
        bandwidth?: long(name='bandwidth', description='This parameter is discontinued.

The bandwidth of the enhanced edge node pool. Unit: Mbit/s.', example='10'),
        ccnId?: string(name='ccn_id', description='This parameter is discontinued.

The ID of the Cloud Connect Network (CCN) instance that is associated with the enhanced edge node pool.', example='ccn-qm5i0i0q9yi*******'),
        ccnRegionId?: string(name='ccn_region_id', description='This parameter is discontinued.

The region in which the CCN instance that is with the enhanced edge node pool resides.', example='cn-shanghai'),
        cenId?: string(name='cen_id', description='This parameter is discontinued.

The ID of the Cloud Enterprise Network (CEN) instance that is associated with the enhanced edge node pool.', example='cen-ey9k9nfhz0f*******'),
        improvedPeriod?: string(name='improved_period', description='This parameter is discontinued.

The subscription duration of the enhanced edge node pool. Unit: months.', example='1'),
      }(name='interconnect_config', description='This parameter is discontinued.

The network configurations of the edge node pool. This parameter takes effect only on edge node pools.'),
      interconnectMode?: string(name='interconnect_mode', description='The network type of the edge node pool. Valid values: basic and dedicated. This parameter takes effect only on edge node pools.', example='improved'),
      kubernetesConfig?: {
        cmsEnabled?: boolean(name='cms_enabled', description='Specifies whether to install the CloudMonitor agent on ECS nodes. After the CloudMonitor agent is installed on ECS nodes, you can view the monitoring information about the instances in the CloudMonitor console. We recommend that you install the CloudMonitor agent. Valid values:

*   `true`
*   `false`', example='true'),
        cpuPolicy?: string(name='cpu_policy', description='The CPU management policy of the nodes in the node pool. The following policies are supported if the version of the cluster is Kubernetes 1.12.6 or later:

*   `static`: allows pods with specific resource characteristics on the node to be granted enhanced CPU affinity and exclusivity.
*   `none`: specifies that the default CPU affinity is used.', example='none'),
        labels?: [
          Tag
        ](name='labels', description='The labels that are added to the nodes in the cluster. You must add labels based on the following rules:

*   A label is a case-sensitive key-value pair. You can add up to 20 labels.
*   The key must be unique and can be up to 64 characters in length. The value can be empty and can be up to 128 characters in length. Keys and values cannot start with `aliyun`, `acs:`, `https://`, or `http://`. For more information, see [Labels and Selectors](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set).'),
        nodeNameMode?: string(name='node_name_mode', description='The custom node name. A custom node name consists of a prefix, an IP substring, and a suffix.

*   The prefix and suffix can contain multiple parts that are separated by periods (.). Each part can contain lowercase letters, digits, and hyphens (-). A custom node name must start and end with a digit or lowercase letter.
*   The IP substring length specifies the number of digits to be truncated from the end of the node IP address. The IP substring length ranges from 5 to 12.

For example, if the node IP address is 192.168.0.55, the prefix is aliyun.com, the IP substring length is 5, and the suffix is test, the node name is aliyun.com00055test.', example='customized,test.,5,.com'),
        preUserData?: string(name='pre_user_data', description='The user-defined script that is executed before nodes are initialized. For more information, see [Generate user-defined data](https://help.aliyun.com/document_detail/49121.html).', example='IyEvYmluL3NoCmVjaG8gIkhlbGxvIEFD'),
        runtime?: string(name='runtime', description='The name of the container runtime.', example='docker'),
        runtimeVersion?: string(name='runtime_version', description='The version of the container runtime.', example='19.03.5'),
        taints?: [
          Taint
        ](name='taints', description='The taints of the nodes in the node pool. Taints can be used together with tolerations to avoid scheduling pods to specified nodes. For more information, see [taint-and-toleration](https://kubernetes.io/zh/docs/concepts/scheduling-eviction/taint-and-toleration/).'),
        unschedulable?: boolean(name='unschedulable', description='Specifies whether the nodes are schedulable after a scale-out activity is performed.', example='true'),
        userData?: string(name='user_data', description='The user-defined script that is executed after nodes are initialized. For more information, see [Generate user-defined data](https://help.aliyun.com/document_detail/49121.html).', example='IyEvYmluL3NoCmVjaG8gIkhlbGxvIEFD****'),
      }(name='kubernetes_config', description='The configurations of the cluster in which the node pool is deployed.'),
      management?: {
        autoRepair?: boolean(name='auto_repair', description='Specifies whether to enable auto repair. This parameter takes effect only if `enable` is set to true. Valid values:

*   `true`
*   `false`', example='true'),
        autoRepairPolicy?: {
          restartNode?: boolean(name='restart_node', description='Specifies whether to allow node restart.', example='true'),
        }(name='auto_repair_policy', description='The auto node repair policy.'),
        autoUpgrade?: boolean(name='auto_upgrade', description='Specifies whether to enable auto update.', example='true'),
        autoUpgradePolicy?: {
          autoUpgradeKubelet?: boolean(name='auto_upgrade_kubelet', description='Specifies whether to allow auto update of the kubelet.', example='true'),
        }(name='auto_upgrade_policy', description='The auto update policy.'),
        autoVulFix?: boolean(name='auto_vul_fix', description='Specifies whether to enable auto Common Vulnerabilities and Exposures (CVE) patching.', example='true'),
        autoVulFixPolicy?: {
          restartNode?: boolean(name='restart_node', description='Specifies whether to allow node restart.', example='true'),
          vulLevel?: string(name='vul_level', description='The severity level of CVEs that can be automatically patched. Multiple severity levels are separated by commas (,).', example='asap,nntf'),
        }(name='auto_vul_fix_policy', description='The auto CVE patching policy.'),
        enable?: boolean(name='enable', description='Specifies whether to enable the managed node pool feature. Valid values:

*   `true`
*   `false`: If you set this parameter to false, other parameters of `management` do not take effect.', example='true'),
        upgradeConfig?: {
          autoUpgrade?: boolean(name='auto_upgrade', description='Specifies whether to enable auto update. Valid values:

*   `true`
*   `false`', example='true'),
          maxUnavailable?: long(name='max_unavailable', description='The maximum number of unavailable nodes. Valid values: 1 to 1000.

Default value: 1', example='1'),
          surge?: long(name='surge', description='The number of additional nodes.', example='5'),
          surgePercentage?: long(name='surge_percentage', description='The percentage of additional nodes to the total nodes in the node pool. You must specify this parameter or the `surge` parameter.

The number of additional nodes = The percentage of additional nodes × The number of nodes in the node pool. For example, if the percentage of additional nodes is 50% and the number of nodes in the node pool is 6, the number of additional nodes is 3.', example='50'),
        }(name='upgrade_config', description='The configurations of auto update. The configurations take effect only if `enable` is set to true.'),
      }(name='management', description='The configurations of managed node pools. Managed node pools are available only in professional managed Kubernetes clusters.'),
      maxNodes?: long(name='max_nodes', description='The maximum number of nodes that can be created in the edge node pool. The value of this parameter must be greater than or equal to 0. A value of 0 indicates that the number of nodes in the node pool is limited only by the quota of nodes in the cluster. In most cases, this parameter is set to a value larger than 0 for edge node pools. This parameter is set to 0 for node pools whose types are ess or default edge node pools.', example='10'),
      nodeConfig?: {
        kubeletConfiguration?: KubeletConfig(name='kubelet_configuration', description='The parameter settings of the kubelet.'),
      }(name='node_config', description='The configurations of nodes.'),
      nodepoolInfo?: {
        created?: string(name='created', description='The time when the node pool was created.', example='2020-09-27T19:14:09.156823496+08:00'),
        isDefault?: boolean(name='is_default', description='Specifies whether the node pool is a default node pool. A Container Service for Kubernetes (ACK) cluster generally has only one default node pool. Valid values:

*   `true`
*   `false`:', example='true'),
        name?: string(name='name', description='The name of the node pool.

The name must be 1 to 63 characters in length, and can contain digits, letters, and hyphens (-). It cannot start with a hyphen (-).', example='default-nodepool'),
        nodepoolId?: string(name='nodepool_id', description='The node pool ID.', example='np615c0e0966124216a0412e10afe0****'),
        regionId?: string(name='region_id', description='The region ID.', example='cn-beijing'),
        resourceGroupId?: string(name='resource_group_id', description='The resource group ID.', example='rg-acfmyvw3wjm****'),
        type?: string(name='type', description='The type of node pool. Valid values:

*   `edge`: edge node pool.
*   `ess`: node pool in the cloud.', example='ess'),
        updated?: string(name='updated', description='The time when the node pool was last updated.', example='2020-09-27T20:37:46+08:00'),
      }(name='nodepool_info', description='The information about the node pool.'),
      scalingGroup?: {
        autoRenew?: boolean(name='auto_renew', description='Specifies whether to enable auto-renewal for the nodes in the node pool. This parameter takes effect only if `instance_charge_type` is set to `PrePaid`. Valid values:

*   `true`
*   `false`', example='false'),
        autoRenewPeriod?: long(name='auto_renew_period', description='The auto-renewal period. Valid values:

*   Valid values when PeriodUnit is set to Week: 1, 2, and 3
*   Valid values when PeriodUnit is set to Month: 1, 2, 3, 6, 12, 24, 36, 48, and 60

Default value: 1.', example='0'),
        cisEnabled?: boolean(name='cis_enabled', description='Specifies whether to enable Center for Internet Security (CIS) reinforcement. CIS reinforcement can be enabled only if Alibaba Cloud Linux 2 or Alibaba Cloud Linux 3 is installed on nodes.', example='false', deprecated='true'),
        compensateWithOnDemand?: boolean(name='compensate_with_on_demand', description='Specifies whether to automatically create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created due to reasons such as the cost or insufficient inventory. This parameter takes effect if you set `multi_az_policy` to `COST_OPTIMIZED` Valid values:

*   `true`
*   `false`', example='true'),
        dataDisks?: [
          DataDisk
        ](name='data_disks', description='The configurations of the data disks that are mounted to the nodes in the node pool. The configurations include the disk category and disk size.'),
        deploymentsetId?: string(name='deploymentset_id', description='The deployment set ID.', example='ds-bp1d19mmbsv3jf6xxxxx'),
        desiredSize?: long(name='desired_size', description='The expected number of nodes in the node pool.', example='2'),
        imageId?: string(name='image_id', description='The custom image ID. You can call the `DescribeKubernetesVersionMetadata` operation to query the images supported by ACK.', example='aliyun_2_1903_x64_20G_alibase_20200529.vhd'),
        imageType?: string(name='image_type', description='The type of the operating system image.', example='AliyunLinux'),
        instanceChargeType?: string(name='instance_charge_type', description='The billing method of the nodes in the node pool. Valid values:

*   `PrePaid`: subscription.
*   `PostPaid`: pay-as-you-go.', example='PostPaid'),
        instancePatterns?: [
          InstancePatterns
        ](name='instance_patterns', description='The attributes of an instance.'),
        instanceTypes?: [ string ](name='instance_types', description='The list of instance types. You can select multiple instance types. When the system needs to create a node, it starts from the first instance type until the node is created. The instance type that is used to create the node varies based on the inventory.', example='ecs.n4.large'),
        internetChargeType?: string(name='internet_charge_type', description='The billing method of the public IP address.', example='PayByBandwidth'),
        internetMaxBandwidthOut?: long(name='internet_max_bandwidth_out', description='The maximum outbound bandwidth of the public IP address. Unit: Mbit/s. Valid values: 1 to 100.', example='10'),
        keyPair?: string(name='key_pair', description='The name of the key pair. You must specify this parameter or the `login_password` parameter.

You must specify the `key_pair` parameter if the node pool is a managed node pool.', example='pro-nodepool'),
        loginAsNonRoot?: boolean(name='login_as_non_root', description='Specifies whether a non-root user can log on to the ECS instance added to the node pool.', example='true'),
        loginPassword?: string(name='login_password', description='The password for SSH logon. You must specify this parameter or the `key_pair` parameter. The password must be 8 to 30 characters in length, and must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.

The returned password is encrypted to ensure security.', example='******'),
        multiAzPolicy?: string(name='multi_az_policy', description='The ECS instance scaling policy for the multi-zone scaling group. Valid values:

*   `PRIORITY`: ECS instances are created based on the VSwitchIds.N parameter. If Auto Scaling fails to create an ECS instance in the zone of the vSwitch that has the highest priority, Auto Scaling attempts to create the ECS instance in the zone of the vSwitch that has a lower priority.

*   `COST_OPTIMIZED`: ECS instances are created based on the vCPU unit price in ascending order. Preemptible instances are preferably created when preemptible instance types are specified in the scaling configuration. You can specify `CompensateWithOnDemand` to specify whether to automatically create pay-as-you-go instances if preemptible instances cannot be created due to insufficient resources.

    **

    **Note** `COST_OPTIMIZED` takes effect only if multiple instance types are specified or at least one preemptible instance type is specified.

*   `BALANCE`: ECS instances are evenly distributed across multiple zones specified by the scaling group. If the distribution of ECS instances across zones is not balanced due to reasons such as insufficient inventory, you can call the `RebalanceInstances` operation to evenly distribute the ECS instances across zones. For more information, see [RebalanceInstances](https://help.aliyun.com/document_detail/71516.html).', example='COST_OPTIMIZED'),
        onDemandBaseCapacity?: long(name='on_demand_base_capacity', description='The minimum number of pay-as-you-go instances that must be kept in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is smaller than the value of this parameter, Auto Scaling preferably creates pay-as-you-go instances', example='0'),
        onDemandPercentageAboveBaseCapacity?: long(name='on_demand_percentage_above_base_capacity', description='The percentage of pay-as-you-go instances among the extra instances that exceed the number specified by `on_demand_base_capacity`. Valid values: 0 to 100.', example='20'),
        period?: long(name='period', description='The subscription duration of the nodes in the node pool. This parameter takes effect and is required if you set `instance_charge_type` to `PrePaid`.

If `period_unit` is set to Month, the valid values of period are 1, 2, 3, 6, 12, 24, 36, 48, and 60.', example='1'),
        periodUnit?: string(name='period_unit', description='The billing cycle of the nodes in the node pool. This parameter takes effect only if`instance_charge_type` is set to `PrePaid`.

Valid value: `Month`, which indicates that the subscription duration is measured in months.', example='Month'),
        platform?: string(name='platform', description='The operating system distribution. Valid values:

*   `CentOS`
*   `AliyunLinux`
*   `Windows`
*   `WindowsCore`', example='AliyunLinux'),
        privatePoolOptions?: {
          id?: string(name='id', description='The private pool ID, which is the same as the ID of the elasticity assurance or capacity reservation for which the private pool is generated.', example='eap-bp67acfmxazb4****'),
          matchCriteria?: string(name='match_criteria', description='The type of the private node pool. This parameter specifies the type of the private node pool that is used to create instances. A private node pool is generated when an elasticity assurance or a capacity reservation service takes effect. The system selects a private node pool to launch instances. Valid values:

*   `Open`: uses open private pool. The system selects an open private node pool to launch instances. If no matching open private node pool is available, the resources in the public node pool are used.
*   `Target`: uses the specified private node pool. The system uses the resources of the specified private node pool to launch instances. If the specified private node pool is unavailable, instances cannot be launched.
*   `None`: No private node pool is used. The resources of private node pools are not used to launch instances.', example='Open'),
        }(name='private_pool_options', description='The configurations of the private node pool.'),
        ramPolicy?: string(name='ram_policy', description='This field is deprecated and replaced by the ram_role_name parameter.', example='KubernetesWorkerRole-021dc54f-929b-437a-8ae0-34c24d3e****'),
        ramRoleName?: string(name='ram_role_name', description='Worker RAM role name.', example='KubernetesWorkerRole-4a4fa089-80c1-48a5-b3c6-9349311f****'),
        rdsInstances?: [ string ](name='rds_instances', description='The ApsaraDB RDS instances. If you specify the list of ApsaraDB RDS instances, ECS instances in the cluster are automatically added to the whitelist of the ApsaraDB RDS instances.'),
        scalingGroupId?: string(name='scaling_group_id', description='The scaling group ID.', example='asg-2ze8n5qw4atggut8****'),
        scalingPolicy?: string(name='scaling_policy', description='The scaling mode of the scaling group. Valid values:

*   `release`: the standard mode. ECS instances are created and released based on the resource usage.
*   `recycle`: the swift mode. ECS instances are created, stopped, or started during scaling events. This reduces the time required for the next scale-out event. When the instance is stopped, you are charged only for the storage service. This does not apply to ECS instances that are attached to local disks.', example='release'),
        securityGroupId?: string(name='security_group_id', description='The ID of the security group to which the node pool is added. If the node pool is added to multiple security groups, the first ID in the value of the `security_group_ids` parameter is returned.', example='sg-2ze1iuk12m2sb4c4****'),
        securityGroupIds?: [ string ](name='security_group_ids', description='The IDs of security groups for the node pool.'),
        securityHardeningOs?: boolean(name='security_hardening_os', description='Alibaba Cloud OS security hardening. Values:
- `true`: Enable Alibaba Cloud OS security hardening. - `false`: Do not enable Alibaba Cloud OS security hardening.
Default value: `false`.', example='false'),
        socEnabled?: boolean(name='soc_enabled', description='Specifies whether to enable reinforcement based on classified protection. You can enable reinforcement based on classified protection only if Alibaba Cloud Linux 2 or Alibaba Cloud Linux 3 is installed on nodes. Alibaba Cloud provides standards for baseline check and a scanner to ensure the compliance of Alibaba Cloud Linux 2 and Alibaba Cloud Linux 3 images with the level 3 standards of classified protection.', example='false'),
        spotInstancePools?: long(name='spot_instance_pools', description='The number of instance types that are available for creating preemptible instances. Auto Scaling creates preemptible instances of multiple instance types that are available at the lowest cost. Valid values: 1 to 10.', example='5'),
        spotInstanceRemedy?: boolean(name='spot_instance_remedy', description='Specifies whether to enable the supplementation of preemptible instances. If the supplementation of preemptible instances is enabled, when the scaling group receives a system message that a preemptible instance is to be reclaimed, the scaling group attempts to create a new instance to replace this instance. Valid values:

*   `true`
*   `false`', example='false'),
        spotPriceLimit?: [ 
          {
            instanceType?: string(name='instance_type', description='The instance type of preemptible instances.', example='ecs.c6.large'),
            priceLimit?: string(name='price_limit', description='The price cap for a single preemptible instance.

Unit: USD/hour.', example='0.39'),
          }
        ](name='spot_price_limit', description='The bid configurations of preemptible instances.'),
        spotStrategy?: string(name='spot_strategy', description='The bidding policy of preemptible instances. Valid values:

*   NoSpot: non-preemptible.
*   SpotWithPriceLimit: specifies the highest bid.
*   SpotAsPriceGo: automatically submits bids based on the up-to-date market price.

For more information, see [Create a preemptible elastic container instance](https://help.aliyun.com/document_detail/157759.html).', example='NoSpot'),
        systemDiskBurstingEnabled?: boolean(name='system_disk_bursting_enabled', description='Specifies whether to enable Burst for the system disk when the disk type is cloud_auto.', example='true'),
        systemDiskCategories?: [ string ](name='system_disk_categories', description='The categories of system disks. The system creates system disks of a disk category with a lower priority if the disk category with a higher priority is unavailable. Valid values: cloud (basic disk), cloud_efficiency (ultra disk). cloud_ssd (standard SSD), cloud_essd (Enterprise SSD).'),
        systemDiskCategory?: string(name='system_disk_category', description='The type of system disk. Valid values:

*   `cloud_efficiency`: ultra disk
*   `cloud_ssd`: SSD', example='cloud_efficiency'),
        systemDiskEncryptAlgorithm?: string(name='system_disk_encrypt_algorithm', description='The encryption algorithm that is used to encrypt the system disk. Set the value to aes-256.', example='aes-256'),
        systemDiskEncrypted?: boolean(name='system_disk_encrypted', description='Specifies whether to encrypt the system disk. Valid values:

*   true
*   false', example='false'),
        systemDiskKmsKeyId?: string(name='system_disk_kms_key_id', description='The ID of the Key Management Service (KMS) key that is used to encrypt the system disk.', example='0e478b7a-4262-4802-b8cb-00d3fb40****'),
        systemDiskPerformanceLevel?: string(name='system_disk_performance_level', description='The performance level (PL) of the system disk. This parameter takes effect only for an ESSD.', example='PL1'),
        systemDiskProvisionedIops?: long(name='system_disk_provisioned_iops', description='The predefined read and write IOPS of the system disk when the disk type is cloud_auto.', example='1000'),
        systemDiskSize?: long(name='system_disk_size', description='The size of the system disk. Unit: GiB.

Valid values: 20 to 500.', example='120'),
        tags?: [
          Tag
        ](name='tags', description='The labels that you want to add only to Elastic Compute Service (ECS) instances.

The key must be unique and cannot exceed 128 characters in length. The key and value must not start with aliyun or acs: or contain https:// or http://.'),
        vswitchIds?: [ string ](name='vswitch_ids', description='The vSwitch IDs. You can specify 1 to 20 vSwitches.

>  To ensure high availability, we recommend that you select vSwitches in different zones.'),
      }(name='scaling_group', description='The configurations of the scaling group.'),
      status?: {
        failedNodes?: long(name='failed_nodes', description='The number of failed nodes.', example='0'),
        healthyNodes?: long(name='healthy_nodes', description='The number of healthy nodes.', example='3'),
        initialNodes?: long(name='initial_nodes', description='The number of nodes that are being created.', example='0'),
        offlineNodes?: long(name='offline_nodes', description='The number of offline nodes.', example='0'),
        removingNodes?: long(name='removing_nodes', description='The number of nodes that are being removed.', example='0'),
        servingNodes?: long(name='serving_nodes', description='The number of running nodes.', example='3'),
        state?: string(name='state', description='The status of the node pool. Valid values:

*   `active`: The node pool is active.
*   `scaling`: The node pool is being scaled.
*   `removing`: The nodes are being removed from the node pool.
*   `deleting`: The node pool is being deleted.
*   `updating`: The node pool is being updated.', example='active'),
        totalNodes?: long(name='total_nodes', description='The total number of nodes in the node pool.', example='3'),
      }(name='status', description='The status details of the node pool.'),
      teeConfig?: {
        teeEnable?: boolean(name='tee_enable', description='Specifies whether to enable confidential computing for the cluster. Valid values:

*   `true`
*   `false`', example='false'),
      }(name='tee_config', description='The configurations of confidential computing.'),
    }
  ](name='nodepools', description='The node pools.'),
}

model DescribeClusterNodePoolsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterNodePoolsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeClusterNodePools  DescribeClusterNodePoolsRequest
  * @return DescribeClusterNodePoolsResponse
 */
async function describeClusterNodePools(request: DescribeClusterNodePoolsRequest): DescribeClusterNodePoolsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusterNodePools', 'GET', '/clusters/{ClusterId}/nodepools', 'json', false, 'json', request);
}

model DescribeClusterNodesRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
  instanceIds?: string(name='instanceIds', description='The IDs of the nodes that you want to query. Separate multiple node IDs with commas (,).', example='"i-bp11xjhwkj8k966u****,i-bp1dmhc2bu5igkyq****"', position='Query'),
  nodepoolId?: string(name='nodepool_id', description='The node pool ID.', example='np****', position='Query'),
  pageNumber?: string(name='pageNumber', description='The page number.

Default value: 1.', example='1', position='Query'),
  pageSize?: string(name='pageSize', description='The number of entries per page. Valid values: 1 to 100.

Default value: 10.', example='10', position='Query'),
  state?: string(name='state', description='The node state that you want to use to filter nodes. Valid values:

*   `all`: query nodes in the following four states.
*   `running`: query nodes in the running state.
*   `removing`: query nodes that are being removed.
*   `initial`: query nodes that are being initialized.
*   `failed`: query nodes that fail to be created.

Default value: `all`.', example='running', position='Query'),
}

model DescribeClusterNodesResponseBody = {
  nodes?: [ 
    {
      creationTime?: string(name='creation_time', description='The time when the node was created.', example='2020-08-25T11:25:35+08:00'),
      errorMessage?: string(name='error_message', description='The error message generated when the node was created.', example='error***'),
      expiredTime?: string(name='expired_time', description='The expiration date of the node.', example='2099-12-31T23:59:00+08:00'),
      hostName?: string(name='host_name', description='The name of the host.', example='iZ2vcckdmxp7u0urj2k****'),
      imageId?: string(name='image_id', description='The ID of the system image that is used by the node.', example='aliyun_2_1903_x64_20G_alibase_20200529.vhd'),
      instanceChargeType?: string(name='instance_charge_type', description='The billing method of the node. Valid values:

*   `PrePaid`: the subscription billing method. If the value is PrePaid, make sure that you have a sufficient balance or credit in your account. Otherwise, an `InvalidPayMethod` error is returned.
*   `PostPaid`: the pay-as-you-go billing method.', example='PostPaid'),
      instanceId?: string(name='instance_id', description='The ID of the instance.', example='i-2vcckdmxp7u0urj2****'),
      instanceName?: string(name='instance_name', description='The name of the instance on which the node is deployed.', example='worker-k8s-for-cs-c5cdf7e3938bc4f8eb0e44b21a80f****'),
      instanceRole?: string(name='instance_role', description='The role of the node. Valid values:

*   Master: master node
*   Worker: worker node', example='Worker'),
      instanceStatus?: string(name='instance_status', description='The status of the node.', example='Running'),
      instanceType?: string(name='instance_type', description='The type of the node.', example='ecs.c5.xlarge'),
      instanceTypeFamily?: string(name='instance_type_family', description='The ECS instance family of the node.', example='ecs.c5'),
      ipAddress?: [ string ](name='ip_address', description='The IP address of the node.'),
      isAliyunNode?: boolean(name='is_aliyun_node', description='Indicates whether the instance on which the node is deployed is provided by Alibaba Cloud. Valid values:

*   `true`: The instance is provided by Alibaba Cloud.
*   `false`: The instance is not provided by Alibaba Cloud.', example='true'),
      nodeName?: string(name='node_name', description='The name of the node. This name is the identifier of the node in the cluster.', example='cn-chengdu.192.168.0.36'),
      nodeStatus?: string(name='node_status', description='Indicates whether the node is ready. Valid values:

*   `Ready`: The node is ready.
*   `NotReady`: The node is not ready.
*   `Unknown`: The status of the node is unknown.
*   `Offline`: The node is offline.', example='Ready'),
      nodepoolId?: string(name='nodepool_id', description='The node pool ID.', example='np0794239424a84eb7a95327369d56****'),
      source?: string(name='source', description='Indicates how the node is initialized. A node can be manually created or created by using Resource Orchestration Service (ROS).', example='ess_attach'),
      spotStrategy?: string(name='spot_strategy', description='The type of preemptible instance. Valid values:

*   NoSpot: a non-preemptible instance.
*   SpotWithPriceLimit: a preemptible instance that is configured with the highest bid price.
*   SpotAsPriceGo: a preemptible instance for which the system automatically bids based on the current market price.', example='NoSpot'),
      state?: string(name='state', description='The status of the node. Valid values:

*   `pending`: The node is being created.
*   `running`: The node is running.
*   `starting`: The node is being started.
*   `stopping`: The node is being stopped.
*   `stopped`: The node is stopped.', example='running'),
    }
  ](name='nodes', description='The details of the nodes in the cluster.'),
  page?: {
    pageNumber?: int32(name='page_number', description='The page number.', example='1'),
    pageSize?: int32(name='page_size', description='The number of entries per page.', example='10'),
    totalCount?: int32(name='total_count', description='The total number of entries returned.', example='5'),
  }(name='page', description='The pagination information.'),
}

model DescribeClusterNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterNodesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeClusterNodes  DescribeClusterNodesRequest
  * @return DescribeClusterNodesResponse
 */
async function describeClusterNodes(request: DescribeClusterNodesRequest): DescribeClusterNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusterNodes', 'GET', '/clusters/{ClusterId}/nodes', 'json', false, 'json', request);
}

model DescribeClusterResourcesRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

For more information about how to query cluster IDs, see [View cluster information](https://help.aliyun.com/document_detail/89446.html).

You can also call the [DescribeClustersV1](https://help.aliyun.com/document_detail/183905.html) API operation to query all clusters that belong to an Alibaba Cloud account.

This parameter is required.', example='cb95aa626a47740afbf6aa099b65****', position='Path'),
  withAddonResources?: boolean(name='with_addon_resources', description='Specifies whether to query the resources created by cluster components.', example='false', position='Query'),
}

model DescribeClusterResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      clusterId?: string(name='cluster_id', description='The cluster ID.', example='cb95aa626a47740afbf6aa099b65****'),
      created?: string(name='created', description='The time when the resource was created.', example='2020-09-11T10:11:54+08:00'),
      instanceId?: string(name='instance_id', description='The resource ID.', example='lb-wz9poz4r0ymh8u0uf****'),
      resourceInfo?: string(name='resource_info', description='The resource information. For more information about how to query the source information about the resource, see [ListStackResources](https://help.aliyun.com/document_detail/133836.html).', example='{\\"Id\\":\\"k8s_master_slb\\",\\"Name\\":\\"k8s_master_slb\\",\\"Type\\":\\"ALIYUN::SLB::LoadBalancer\\",\\"Status\\":\\"CREATE_COMPLETE\\",\\"StatusReason\\":\\"state changed\\",\\"Updated\\":\\"2020-05-21T13:25:02\\",\\"PhysicalId\\":\\"lb-wz9poz4r0ymh8u0uf****\\"}'),
      resourceType?: string(name='resource_type', description='The resource type.', example='ALIYUN::SLB::LoadBalancer'),
      state?: string(name='state', description='The resource status. Valid values:

*   `CREATE_COMPLETE`: the resource is created.
*   `CREATE_FAILED`: the resource failed to be created.
*   `CREATE_IN_PROGRESS`: the resource is being created.
*   `DELETE_FAILED`: the resource failed to be deleted.
*   `DELETE_IN_PROGRESS`: the resource is being deleted.
*   `ROLLBACK_COMPLETE`: the resource is rolled back.
*   `ROLLBACK_FAILED`: the resource failed to be rolled back.
*   `ROLLBACK_IN_PROGRESS`: the resource is being rolled back.', example='CREATE_COMPLETE'),
      autoCreate?: long(name='auto_create', description='Specifies whether the resource is created by Container Service for Kubernetes (ACK). Valid values:

*   1: the resource is created by ACK.
*   0: the resource is an existing resource.', example='1'),
      dependencies?: [ 
        {
          clusterId?: string(name='cluster_id', description='The ID of the cluster to which the dependent resource is related.', example='cc5ee03f63e43425cb6f71f1a1756****'),
          resourceType?: string(name='resource_type', description='The dependent resource type.', example='ALIYUN::VPC::NatGateway'),
          instanceId?: string(name='instance_id', description='The dependent resource ID.', example='ngw-wz9sphwk42sdtjixo****'),
        }
      ](name='dependencies', description='The dependent resources.'),
      associatedObject?: {
        kind?: string(name='kind', description='The Kubernetes object type.', example='Service'),
        namespace?: string(name='namespace', description='The namespace in which the Kubernetes object resides.', example='kube-system'),
        name?: string(name='name', description='The Kubernetes object name.', example='nginx-ingress-lb'),
      }(name='associated_object', description='The Kubernetes object with which the resource is associated.'),
      deleteBehavior?: {
        deleteByDefault?: boolean(name='delete_by_default', description='Specifies whether to delete the resource by default when the cluster is deleted.', example='false'),
        changeable?: boolean(name='changeable', description='Specifies whether the default behavior returned in delete_by_default can be changed.', example='false'),
      }(name='delete_behavior', description='The deletion behavior of the resource when the cluster is deleted.'),
      creatorType?: string(name='creator_type', description='The type of the resource creator. Valid values:

*   user: The resource is created by the user.
*   system: The resource is created by the ACK management system.
*   addon: The resource is created by a cluster component.', example='addon'),
      extraInfo?: map[string]any(name='extra_info', description='The additional information about the resource.', example='{"IP": "xx.xx.xx.xx"}'),
    }
  ](name='body'),
}

/**
  * @param request  the request parameters of DescribeClusterResources  DescribeClusterResourcesRequest
  * @return DescribeClusterResourcesResponse
 */
async function describeClusterResources(request: DescribeClusterResourcesRequest): DescribeClusterResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusterResources', 'GET', '/clusters/{ClusterId}/resources', 'array', false, 'json', request);
}

model DescribeClusterTasksRequest {
  clusterId?: string(name='cluster_id', description='The ID of the cluster.', example='c23421cfa74454bc8b37163fd19af****', position='Path'),
  pageNumber?: int32(name='page_number', description='The page number.', example='1', position='Query'),
  pageSize?: int32(name='page_size', description='The number of entries per page.', example='20', position='Query'),
}

model DescribeClusterTasksResponseBody = {
  pageInfo?: {
    pageNumber?: long(name='page_number', description='The number of the page returned.', example='1'),
    pageSize?: long(name='page_size', description='The number of entries per page.', example='10'),
    totalCount?: long(name='total_count', description='The total number of entries returned.', example='10'),
  }(name='page_info', description='The pagination information.'),
  requestId?: string(name='requestId', description='The request ID.', example='0527ac9a-c899-4341-a21a-xxxxxxxxx'),
  tasks?: [ 
    {
      created?: string(name='created', description='The time when the task was created.', example='2022-08-03T10:11:33+08:00'),
      error?: {
        code?: string(name='code', description='The error code returned.', example='BadRequest'),
        message?: string(name='message', description='The error message returned.', example='Addon status not match'),
      }(name='error', description='The error returned for the task.'),
      state?: string(name='state', description='The status of the task.', example='success'),
      taskId?: string(name='task_id', description='The task ID.', example='install-addons-c3xxxxxx'),
      taskType?: string(name='task_type', description='The type of task.', example='cluster_addon_install'),
      updated?: string(name='updated', description='The time when the task was updated.', example='2022-08-03T10:12:03.482+08:00'),
    }
  ](name='tasks', description='The information about the tasks.'),
}

model DescribeClusterTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeClusterTasks  DescribeClusterTasksRequest
  * @return DescribeClusterTasksResponse
 */
async function describeClusterTasks(request: DescribeClusterTasksRequest): DescribeClusterTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusterTasks', 'GET', '/clusters/{cluster_id}/tasks', 'json', false, 'json', request);
}

model DescribeClusterUserKubeconfigRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c5b5e80b0b64a4bf6939d2d8fbbc5****', position='Path'),
  privateIpAddress?: boolean(name='PrivateIpAddress', description='Specifies whether to obtain the kubeconfig file that is used to connect to the cluster over the internal network. Valid values:

*   `true`: obtains the kubeconfig file that is used to connect to the master instance over the internal network.
*   `false`: obtains the kubeconfig file that is used to connect to the master instance over the Internet.

Default value: `false`.', example='true', position='Query'),
  temporaryDurationMinutes?: long(name='TemporaryDurationMinutes', description='The validity period of a temporary kubeconfig file. Unit: minutes. Valid values: 15 to 4320 (3 days).

>  If you do not specify this parameter, the system specifies a longer validity period. The validity period is returned in the `expiration` parameter.', example='15', position='Query'),
}

model DescribeClusterUserKubeconfigResponseBody = {
  config?: string(name='config', description='The content of the kubeconfig file. For more information about how to view the kubeconfig file, see [Configure cluster credentials](https://help.aliyun.com/document_detail/86494.html).', example='apiVersion: v1****'),
  expiration?: string(name='expiration', description='The validity period of the kubeconfig file. The value is the UTC time displayed in RFC3339 format.', example='2024-03-10T09:56:17Z'),
}

model DescribeClusterUserKubeconfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterUserKubeconfigResponseBody(name='body'),
}

/**
  * @description >  The default validity period of a kubeconfig file is 3 years. 180 days before a kubeconfig file expires, you can renew it in the Container Service for Kubernetes (ACK) console or by calling API operations. After a kubeconfig file is renewed, the kubeconfig file is valid for 3 years. The previous kubeconfig file still remains valid until expiration. We recommend that you renew your kubeconfig file at the earliest opportunity.
  * @param request  the request parameters of DescribeClusterUserKubeconfig  DescribeClusterUserKubeconfigRequest
  * @return DescribeClusterUserKubeconfigResponse
 */
async function describeClusterUserKubeconfig(request: DescribeClusterUserKubeconfigRequest): DescribeClusterUserKubeconfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusterUserKubeconfig', 'GET', '/k8s/{ClusterId}/user_config', 'json', false, 'json', request);
}

model DescribeClusterV2UserKubeconfigRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Path'),
  privateIpAddress?: boolean(name='PrivateIpAddress', position='Query'),
  temporaryDurationMinutes?: long(name='TemporaryDurationMinutes', position='Query'),
}

model DescribeClusterV2UserKubeconfigResponseBody = {
  config?: string(name='config'),
}

model DescribeClusterV2UserKubeconfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterV2UserKubeconfigResponseBody(name='body'),
}

/**
  * @deprecated OpenAPI DescribeClusterV2UserKubeconfig is deprecated, please use CS::2015-12-15::DescribeClusterUserKubeconfig instead.  * @param request  the request parameters of DescribeClusterV2UserKubeconfig  DescribeClusterV2UserKubeconfigRequest
  * @return DescribeClusterV2UserKubeconfigResponse
 */
// Deprecated
async function describeClusterV2UserKubeconfig(request: DescribeClusterV2UserKubeconfigRequest): DescribeClusterV2UserKubeconfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusterV2UserKubeconfig', 'GET', '/api/v2/k8s/{ClusterId}/user_config', 'json', false, 'json', request);
}

model DescribeClusterVulsRequest {
  clusterId?: string(name='cluster_id', description='The ID of the cluster.', example='c5cdf7e3938bc4f8eb0e44b21a80f****', position='Path'),
}

model DescribeClusterVulsResponseBody = {
  vulRecords?: [ 
    {
      cveList?: [ string ](name='cve_list', description='The CVE list.'),
      necessity?: string(name='necessity', description='The severity level of the vulnerability.

Valid values:

*   nntf: low
*   later: medium     
*   asap: high', example='asap'),
      nodeCount?: int32(name='node_count', description='The number of nodes that have the vulnerability.', example='1'),
      nodepoolId?: string(name='nodepool_id', description='The node pool ID.', example='np0156da1082b54fa987e32618dd45f5d3'),
      nodepoolName?: string(name='nodepool_name', description='The name of the node pool.', example='test'),
      vulAliasName?: string(name='vul_alias_name', description='The alias of the vulnerability.', example='CVE-2022-xxxx:rsync Security vulnerabilities'),
      vulName?: string(name='vul_name', description='The name of the vulnerability.', example='oval:com.redhat.rhsa:def:xxxxxxx'),
      vulType?: string(name='vul_type', description='The type of vulnerability.

Valid values:

*   app: application vulnerabilities
*   sca: application vulnerabilities (software component analysis)
*   cve: Linux vulnerabilities
*   cms: Web-CMS vulnerabilities
*   sys: Windows vulnerabilities
*   emg:  emergency vulnerabilities', example='cve'),
    }
  ](name='vul_records', description='An array of vulnerabilities.'),
}

model DescribeClusterVulsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClusterVulsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeClusterVuls  DescribeClusterVulsRequest
  * @return DescribeClusterVulsResponse
 */
async function describeClusterVuls(request: DescribeClusterVulsRequest): DescribeClusterVulsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusterVuls', 'GET', '/clusters/{cluster_id}/vuls', 'json', false, 'json', request);
}

model DescribeClustersRequest {
  clusterType?: string(name='clusterType', description='The cluster type.', example='ManagedKubernetes', position='Query'),
  name?: string(name='name', description='The cluster name based on which the system performs fuzzy searches among the clusters that belong to the current Alibaba Cloud account.', example='test', position='Query'),
  resourceGroupId?: string(name='resource_group_id', position='Query'),
}

model DescribeClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      clusterId?: string(name='cluster_id'),
      clusterType?: string(name='cluster_type'),
      created?: string(name='created'),
      currentVersion?: string(name='current_version'),
      dataDiskCategory?: string(name='data_disk_category'),
      dataDiskSize?: long(name='data_disk_size'),
      deletionProtection?: boolean(name='deletion_protection'),
      dockerVersion?: string(name='docker_version'),
      externalLoadbalancerId?: string(name='external_loadbalancer_id'),
      initVersion?: string(name='init_version'),
      masterUrl?: string(name='master_url'),
      metaData?: string(name='meta_data'),
      name?: string(name='name'),
      networkMode?: string(name='network_mode'),
      privateZone?: boolean(name='private_zone'),
      profile?: string(name='profile'),
      regionId?: string(name='region_id'),
      resourceGroupId?: string(name='resource_group_id'),
      securityGroupId?: string(name='security_group_id'),
      size?: long(name='size'),
      state?: string(name='state'),
      subnetCidr?: string(name='subnet_cidr'),
      tags?: [ 
        {
          key?: string(name='key'),
          value?: string(name='value'),
        }
      ](name='tags'),
      updated?: string(name='updated'),
      vpcId?: string(name='vpc_id'),
      vswitchCidr?: string(name='vswitch_cidr'),
      vswitchId?: string(name='vswitch_id'),
      workerRamRoleName?: string(name='worker_ram_role_name'),
      zoneId?: string(name='zone_id'),
    }
  ](name='body'),
}

/**
  * @deprecated OpenAPI DescribeClusters is deprecated, please use CS::2015-12-15::DescribeClustersV1 instead.  * @param request  the request parameters of DescribeClusters  DescribeClustersRequest
  * @return DescribeClustersResponse
 */
// Deprecated
async function describeClusters(request: DescribeClustersRequest): DescribeClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClusters', 'GET', '/clusters', 'array', false, 'json', request);
}

model DescribeClustersForRegionRequest {
  regionId: string(name='region_id', description='The region.

This parameter is required.', example='cn-hangzhou', position='Path'),
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='c8155823d057948c69a****', position='Query'),
  clusterSpec?: string(name='cluster_spec', description='The specification of the clusters to query. Valid values:

*   ack.pro.small: ACK Pro clusters.
*   ack.standard: ACK Basic clusters.', example='ack.standard', position='Query'),
  clusterType?: string(name='cluster_type', description='The type of the clusters to query. Valid values:

*   Kubernetes: ACK dedicated clusters.
*   ManagedKubernetes: ACK managed clusters. ACK managed clusters include ACK Basic clusters, ACK Pro clusters, ACK Serverless Basic clusters, ACK Serverless Pro clusters, ACK Edge Basic clusters, ACK Edge Pro clusters, and ACK Lingjun Pro clusters.
*   ExternalKubernetes: registered clusters.', example='Kubernetes', position='Query'),
  name?: string(name='name', description='Perform a fuzzy search by using the cluster name.', example='test-cluster', position='Query'),
  pageNumber?: long(name='page_number', description='The number of pages.', example='10', position='Query'),
  pageSize?: long(name='page_size', description='The number of records on each page.', example='3', position='Query'),
  profile?: string(name='profile', description='The subtype of the clusters to query. Valid values:

*   Default: ACK managed clusters. ACK managed clusters include ACK Basic clusters and ACK Pro clusters.
*   Edge: ACK Edge clusters. ACK Edge clusters include ACK Edge Basic clusters and ACK Edge Pro clusters.
*   Serverless: ACK Serverless clusters. ACK Serverless clusters include ACK Serverless Basic clusters and ACK Serverless Pro clusters.
*   Lingjun: ACK Lingjun Pro clusters.', example='Serverless', position='Query'),
}

model DescribeClustersForRegionResponseBody = {
  clusters?: [ 
    {
      clusterDomain?: string(name='cluster_domain', description='The domain name of the cluster.', example='cluster.local'),
      clusterId?: string(name='cluster_id', description='The cluster ID.', example='c905d1364c2dd4b6284a3f41790c4****'),
      clusterSpec?: string(name='cluster_spec', description='The types of ACK managed clusters:

*   ack.pro.small: ACK Pro cluster
*   ack.standard: ACK Basic cluster', example='ack.standard'),
      clusterType?: string(name='cluster_type', description='The type of the cluster. Valid values:

*   Kubernetes: ACK dedicated cluster
*   ManagedKubernetes: ACK managed clusters. ACK managed clusters include ACK Basic clusters, ACK Pro clusters, ACK Serverless Basic clusters, ACK Serverless Pro clusters, ACK Edge Basic clusters, ACK Edge Pro clusters, and ACK Lingjun Pro clusters.
*   ExternalKubernetes: registered cluster', example='ManagedKubernetes'),
      containerCidr?: string(name='container_cidr', description='The CIDR block of pods in the cluster.', example='172.20.0.0/16'),
      created?: string(name='created', description='The time at which the instance is created.', example='2020-12-01T20:40:40+08:00'),
      currentVersion?: string(name='current_version', description='The current Kubernetes version of the cluster.', example='1.16.6-aliyun.1'),
      deletionProtection?: boolean(name='deletion_protection', description='Specifies whether to enable cluster deletion protection. If you enable this option, the cluster cannot be deleted in the console or by calling API operations. You can obtain the terminal ID by calling one of the following operations:

*   true: enables deletion protection for the cluster. This way, the cluster cannot be deleted in the ACK console or by calling API operations.
*   false: disables deletion protection for the cluster. This way, the cluster can be deleted in the ACK console or by calling API operations.', example='false'),
      initVersion?: string(name='init_version', description='The initial Kubernetes version of the cluster.', example='1.16.6-aliyun.1'),
      ipStack?: string(name='ip_stack', description='The IP protocol stack of the cluster.', example='ipv4'),
      name?: string(name='name', description='The name of the cluster.', example='test-cluster'),
      nextVersion?: string(name='next_version', description='The Kubernetes version to which the cluster can be updated.', example='1.18.8-aliyun.1'),
      profile?: string(name='profile', description='The subtype of the clusters. Valid values:

*   Default: ACK managed clusters. ACK managed clusters include ACK Basic clusters and ACK Pro clusters.
*   Edge: ACK Edge clusters. ACK Edge clusters include ACK Edge Basic clusters and ACK Edge Pro clusters.
*   Serverless: ACK Serverless clusters. ACK Serverless clusters include ACK Serverless Basic clusters and ACK Serverless Pro clusters.
*   Lingjun: ACK Lingjun Pro clusters.', example='Default'),
      proxyMode?: string(name='proxy_mode', description='The kube-proxy mode of the cluster.

Valid value:

*   iptables: iptables.
*   ipvs: ipvs.', example='ipvs'),
      regionId?: string(name='region_id', description='The region ID.', example='cn-beijing-a'),
      resourceGroupId?: string(name='resource_group_id', description='The ID of the cluster resource group.', example='rg-acfmyvw3wjm****'),
      securityGroupId?: string(name='security_group_id', description='The ID of the security group of the cluster.', example='sg-2zeihch86ooz9io4****'),
      serviceCidr: string(name='service_cidr', description='The CIDR block of the service network.

This parameter is required.', example='172.21.0.0/20'),
      size?: long(name='size', description='The number of nodes in the ACK cluster.', example='2'),
      state?: string(name='state', description='The status of the cluster. Valid values:

*   initial: The cluster is being created.
*   failed: The cluster failed to be created.
*   running: The cluster is running.
*   Upgrading: The cluster is being updated.
*   scaling: The cluster is being scaled.
*   waiting: The cluster is waiting for connection requests.
*   disconnected: The cluster is disconnected.
*   inactive: The cluster is inactive.
*   unavailable: The cluster is unavailable.
*   deleting: The cluster is being deleted.
*   deleted: The ACK cluster is deleted.
*   delete_failed: The cluster failed to be deleted.', example='running'),
      tags?: [
        Tag
      ](name='tags', description='The list of cluster tags.'),
      timezone?: string(name='timezone', description='The time zone.', example='Asia/Shanghai'),
      updated?: string(name='updated', description='The time when the cluster was updated.', example='2020-12-08T15:37:00+08:00'),
      vpcId?: string(name='vpc_id', description='The ID of the virtual private cloud (VPC) to which the cluster belongs.', example='vpc-2zeg8nf1ukc0fcmvq****'),
      vswitchIds?: [ string ](name='vswitch_ids', description='The list of vSwitches on the control plane of the cluster.'),
    }
  ](name='clusters', description='The information about the queried clusters.'),
  pageInfo?: {
    pageNumber?: int32(name='page_number', description='The number of pages.', example='1'),
    pageSize?: int32(name='page_size', description='The number of records on each page.', example='10'),
    totalCount?: int32(name='total_count', description='The total number of entries returned.', example='10'),
  }(name='page_info', description='The pagination details.'),
}

model DescribeClustersForRegionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClustersForRegionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeClustersForRegion  DescribeClustersForRegionRequest
  * @return DescribeClustersForRegionResponse
 */
async function describeClustersForRegion(request: DescribeClustersForRegionRequest): DescribeClustersForRegionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClustersForRegion', 'GET', '/regions/{region_id}/clusters', 'json', false, 'json', request);
}

model DescribeClustersV1Request {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='ca418e5e6fa2849d78301341700axxxxx', position='Query'),
  clusterSpec?: string(name='cluster_spec', description='After you set `cluster_type` to `ManagedKubernetes` and configure the `profile` parameter, you can further specify the edition of the cluster. Valid values:

*   `ack.pro.small`: ACK Pro cluster.
*   `ack.standard`: ACK Basic cluster. If you leave the parameter empty, ACK Basic cluster is selected.', example='ack.pro.small', position='Query'),
  clusterType?: string(name='cluster_type', description='*   `Kubernetes`: ACK dedicated cluster.
*   `ManagedKubernetes`: ACK managed cluster. ACK managed clusters include ACK Basic clusters, ACK Pro clusters, ACK Serverless Basic clusters, ACK Serverless Pro clusters, ACK Edge Basic clusters, ACK Edge Pro clusters, and ACK Lingjun Pro clusters.
*   `ExternalKubernetes`: registered cluster.', example='Kubernetes', position='Query'),
  name?: string(name='name', description='The cluster name.

The name must be 1 to 63 characters in length, and can contain digits, letters, and hyphens (-). The name cannot start with a hyphen (-).', example='cluster-demo', position='Query'),
  pageNumber?: long(name='page_number', description='The page number.', example='3', position='Query'),
  pageSize?: long(name='page_size', description='The number of entries per page.', example='10', position='Query'),
  profile?: string(name='profile', description='If you set `cluster_type` to `ManagedKubernetes`, an ACK managed cluster is created. In this case, you can further specify the cluster edition. Valid values:

*   `Default`: ACK managed cluster. ACK managed clusters include ACK Basic clusters and ACK Pro clusters.
*   `Edge`: ACK Edge cluster. ACK Edge clusters include ACK Edge Basic clusters and ACK Edge Pro clusters.
*   `Serverless`: ACK Serverless cluster. ACK Serverless clusters include ACK Serverless Basic clusters and ACK Serverless Pro clusters.
*   `Lingjun`: ACK Lingjun Pro cluster.', example='Default', position='Query'),
  regionId?: string(name='region_id', description='The region ID of the clusters. You can use this parameter to query all clusters in the specified region.', example='cn-hangzhou', position='Query'),
}

model DescribeClustersV1ResponseBody = {
  clusters?: [ 
    {
      clusterDomain?: string(name='cluster_domain', description='The domain name of the cluster.', example='cluster.local'),
      clusterId?: string(name='cluster_id', description='The cluster ID.', example='c3fb96524f9274b4495df0f12a6b5****'),
      clusterSpec?: string(name='cluster_spec', description='After you set `cluster_type` to `ManagedKubernetes` and configure the `profile` parameter, you can further specify the edition of the cluster. Valid values:

*   `ack.pro.small`: ACK Pro cluster.
*   `ack.standard`: ACK Basic cluster. If you leave the parameter empty, ACK Basic cluster is selected.', example='ack.standard'),
      clusterType?: string(name='cluster_type', description='*   `Kubernetes`: ACK dedicated cluster.
*   `ManagedKubernetes`: ACK managed cluster. ACK managed clusters include ACK Basic clusters, ACK Pro clusters, ACK Serverless Basic clusters, ACK Serverless Pro clusters, ACK Edge Basic clusters, ACK Edge Pro clusters, and ACK Lingjun Pro clusters.
*   `ExternalKubernetes`: registered cluster.', example='Kubernetes'),
      containerCidr?: string(name='container_cidr', description='The pod CIDR block and the configuration of the Flannel network plug-in.', example='172.20.0.0/16'),
      created?: string(name='created', description='The time when the cluster was created.', example='2020-08-20T10:51:29+08:00'),
      currentVersion?: string(name='current_version', description='The Kubernetes version of the cluster.', example='1.16.9-aliyun.1'),
      deletionProtection?: boolean(name='deletion_protection', description='Specifies whether to enable cluster deletion protection. If this option is enabled, the cluster cannot be deleted in the ACK console or by calling API operations. Valid values:

*   `true`: enables deletion protection for the cluster. This way, the cluster cannot be deleted in the ACK console or by calling API operations.
*   `false`: disables deletion protection for the cluster. This way, the cluster can be deleted in the ACK console or by calling API operations.', example='true'),
      dockerVersion?: string(name='docker_version', description='The Docker version that is used by the cluster.', example='19.03.5'),
      externalLoadbalancerId?: string(name='external_loadbalancer_id', description='The ID of the Server Load Balancer (SLB) instance that is used by the Ingresses of the cluster.

The default SLB specification is slb.s1.small, which belongs to the high-performance instance type.', example='lb-2vcrbmlevo6kjpgch****'),
      initVersion?: string(name='init_version', description='The Kubernetes version of the cluster. The Kubernetes versions supported by ACK are the same as the Kubernetes versions supported by open source Kubernetes. We recommend that you specify the latest Kubernetes version. If you do not configure this parameter, the latest Kubernetes version is used.

You can create clusters that run the latest two Kubernetes versions in the ACK console. You can call the API operation to create clusters of other Kubernetes versions. For more information about the Kubernetes versions supported by ACK, see [Release notes for Kubernetes versions](https://help.aliyun.com/document_detail/185269.html).', example='1.16.9-aliyun.1'),
      ipStack?: string(name='ip_stack', description='The IP stack of the cluster. Valid values:

*   ipv4: The cluster is an IPv4 cluster.
*   dual: The cluster is a dual-stack cluster.', example='ipv4'),
      maintenanceWindow?: MaintenanceWindow(name='maintenance_window', description='The maintenance window of the cluster. This feature is available only for ACK managed clusters and ACK Serverless clusters.'),
      masterUrl?: string(name='master_url', description='The address of the cluster API server. It includes an internal endpoint and a public endpoint.', example='{\\"api_server_endpoint\\":\\"\\",\\"intranet_api_server_endpoint\\":\\"https://192.168.0.251:6443\\"}'),
      metaData?: string(name='meta_data', description='The metadata of the cluster.', example='{\\"Addons\\":[{\\"config\\":***}'),
      name?: string(name='name', description='The cluster name.

The name must be 1 to 63 characters in length, and can contain digits, letters, and hyphens (-). The name cannot start with a hyphen (-).', example='cluster-demo'),
      networkMode?: string(name='network_mode', description='The network mode of the cluster. Valid values:

*   `classic`: classic network.
*   `vpc`: virtual private cloud (VPC).
*   `overlay`: overlay network.
*   `calico`: network powered by Calico.', example='vpc'),
      nextVersion?: string(name='next_version', description='The Kubernetes version to which the cluster can be updated.', example='1.18.8-aliyun.1'),
      operationPolicy?: {
        clusterAutoUpgrade?: {
          channel?: string(name='channel', description='The frequency of auto cluster updates. For more information, see [Update frequency](https://help.aliyun.com/document_detail/2712866.html).

Valid values:

*   patch: the latest patch version.
*   stables: the second-latest minor version.
*   rapid: the latest minor version.', example='patch'),
          enabled?: boolean(name='enabled', description='Specifies whether to enable auto cluster update.', example='true'),
        }(name='cluster_auto_upgrade', description='The configurations of auto cluster update.'),
      }(name='operation_policy', description='The automatic O\\&M policy of the cluster.'),
      privateZone?: boolean(name='private_zone', description='Indicates whether Alibaba Cloud DNS PrivateZone is enabled. Valid values:

*   `true`: Alibaba Cloud DNS PrivateZone is enabled.
*   `false`: Alibaba Cloud DNS PrivateZone is disabled.', example='false'),
      profile?: string(name='profile', description='The cluster identifier. Valid values:

*   `Default`: ACK managed cluster. ACK managed clusters include ACK Basic clusters and ACK Pro clusters.
*   `Edge`: ACK Edge cluster. ACK Edge clusters include ACK Edge Basic clusters and ACK Edge Pro clusters.
*   `Serverless`: ACK Serverless cluster. ACK Serverless clusters include ACK Serverless Basic clusters and ACK Serverless Pro clusters.
*   `Lingjun`: ACK Lingjun Pro cluster.', example='Default'),
      proxyMode?: string(name='proxy_mode', description='The Kube-proxy mode. Valid values:

*   `iptables`: a mature and stable kube-proxy mode that uses iptables rules to conduct Service discovery and load balancing. The performance of this mode is limited by the size of the cluster. This mode is suitable for clusters that run a small number of Services.
*   `ipvs`: provides high performance and uses IP Virtual Server (IPVS). This allows you to configure service discovery and load balancing. This mode is suitable for clusters that are required to run a large number of services. We recommend that you use this mode in scenarios that require high load balancing performance.', example='ipvs'),
      regionId?: string(name='region_id', description='The region ID of the cluster.', example='cn-beijing'),
      resourceGroupId?: string(name='resource_group_id', description='The ID of the resource group to which the cluster belongs.', example='rg-acfmyvw3wjm****'),
      securityGroupId?: string(name='security_group_id', description='The ID of the security group of the cluster.', example='sg-2vcgwsrwgt5mp0yi****'),
      serviceCidr: string(name='service_cidr', description='The Service CIDR block.

This parameter is required.', example='172.21.0.0/20'),
      size?: long(name='size', description='The number of nodes in the cluster, including control planes and worker nodes.', example='5'),
      state?: string(name='state', description='The status of the cluster. Valid values:

*   `initial`: The cluster is being created.
*   `failed`: The cluster failed to be created.
*   `running`: The cluster is running.
*   `upgrading`: The cluster is undergoing an upgrade.
*   `updating`: Cluster specification changes are being applied.
*   `removing`: Nodes are being removed from the node pool.
*   `draining`: Node draining is in progress.
*   `scaling`: Auto-scaling operation is in progress for the cluster.
*   `stopped`: The cluster has stopped running.
*   `deleting`: The cluster is being deleted.
*   `deleted`: The cluster has been deleted.
*   `delete_failed`: The cluster failed to be deleted.', example='running'),
      subnetCidr?: string(name='subnet_cidr', description='Tis parameter is deprecated. Use the container_cidr parameter to obtain the pod CIDR block. The pod CIDR block. It must be a valid and private CIDR block, and must be one of the following CIDR blocks or their subnets:

*   10.0.0.0/8
*   172.16-31.0.0/12-16
*   192.168.0.0/16

The pod CIDR block cannot overlap with the CIDR block of the VPC in which the cluster is deployed and the CIDR blocks of existing clusters in the VPC. You cannot modify the pod CIDR block after you create the cluster.

For more information about the network planning of Container Service for Kubernetes (ACK) clusters, see [Plan CIDR blocks for an ACK cluster](https://help.aliyun.com/document_detail/86500.html).', example='172.21.0.0/16', deprecated='true'),
      tags?: [
        Tag
      ](name='tags', description='The resource tags of the cluster.'),
      timezone?: string(name='timezone', description='The time zone', example='Asia/Shanghai'),
      updated?: string(name='updated', description='The time when the cluster was updated.', example='2020-09-16T11:09:55+08:00'),
      vpcId?: string(name='vpc_id', description='The ID of the VPC where the cluster is deployed. This parameter is required when you create a cluster.', example='vpc-2vcg932hsxsxuqbgl****'),
      vswitchId?: string(name='vswitch_id', description='The IDs of the vSwitches. You can select one to three vSwitches when you create a cluster. To ensure the high availability of the cluster, we recommend that you select vSwitches in different zones.', example='vsw-2vc41xuumx5z2rdma****,vsw-2vc41xuumx5z2rdma****', deprecated='true'),
      vswitchIds?: [ string ](name='vswitch_ids', description='The vSwitches of the control planes.'),
      workerRamRoleName?: string(name='worker_ram_role_name', description='The name of the worker Resource Access Management (RAM) role. The RAM role is assigned to the worker nodes of the cluster to allow the worker nodes to manage ECS instances.', example='KubernetesWorkerRole-ec87d15b-edca-4302-933f-c8a16bf0****'),
      zoneId?: string(name='zone_id', description='The ID of the zone where the cluster is deployed.', example='cn-beijing-b'),
    }
  ](name='clusters', description='The queried cluster details.'),
  pageInfo?: {
    pageNumber?: int32(name='page_number', description='The page number.', example='3'),
    pageSize?: int32(name='page_size', description='The number of entries per page.', example='20'),
    totalCount?: int32(name='total_count', description='The total number of entries returned.', example='50'),
  }(name='page_info', description='The pagination information.'),
}

model DescribeClustersV1Response = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeClustersV1ResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeClustersV1  DescribeClustersV1Request
  * @return DescribeClustersV1Response
 */
async function describeClustersV1(request: DescribeClustersV1Request): DescribeClustersV1Response {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeClustersV1', 'GET', '/api/v1/clusters', 'json', false, 'json', request);
}

model DescribeEdgeMachineActiveProcessRequest {
  edgeMachineid: string(name='edge_machineid', description='The ID of the cloud-native box.

This parameter is required.', example='cc0725ddf688744979cd98445f67e****', position='Path'),
}

model DescribeEdgeMachineActiveProcessResponseBody = {
  logs?: string(name='logs', description='The activation progress list.', example='[{\\"content\\":\\"步骤 \\"颁发激活凭证\\" 执行开始\\",\\"id\\":0,\\"level\\":3,\\"timestamp\\":1625994913000},{\\"content\\":\\"步骤 \\"颁发激活凭证\\" 执行成功\\",\\"id\\":1,\\"level\\":3,\\"timestamp\\":1625994914000},{\\"content\\":\\"步骤 \\"初始化主机配置\\" 执行开始\\",\\"id\\":2,\\"level\\":3,\\"timestamp\\":1625994975000},{\\"content\\":\\"步骤 \\"初始化主机配置\\" 执行成功\\",\\"id\\":3,\\"level\\":3,\\"timestamp\\":1625994975000}]'),
  progress?: long(name='progress', description='The activation progress.', example='100'),
  requestId?: string(name='request_id', description='The request ID.', example='b62796a8-c5a6-4d3f-beb2-7650e4309cb1'),
  state?: string(name='state', description='The activation status.', example='ACTIVATED'),
  step?: string(name='step', description='The activation step.', example='步骤 \\"初始化主机配置\\" 执行成功'),
}

model DescribeEdgeMachineActiveProcessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEdgeMachineActiveProcessResponseBody(name='body'),
}

/**
  * @deprecated OpenAPI DescribeEdgeMachineActiveProcess is deprecated  * @param request  the request parameters of DescribeEdgeMachineActiveProcess  DescribeEdgeMachineActiveProcessRequest
  * @return DescribeEdgeMachineActiveProcessResponse
 */
// Deprecated
async function describeEdgeMachineActiveProcess(request: DescribeEdgeMachineActiveProcessRequest): DescribeEdgeMachineActiveProcessResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeEdgeMachineActiveProcess', 'GET', '/edge_machines/[edge_machineid]/activeprocess', 'json', false, 'json', request);
}

model DescribeEdgeMachineModelsRequest {
}

model DescribeEdgeMachineModelsResponseBody = {
  models?: [ 
    {
      cpu?: int32(name='cpu', description='The number of vCores.', example='6'),
      cpuArch?: string(name='cpu_arch', description='The CPU architecture.', example='x86_64/arm64'),
      created?: string(name='created', description='The time when the cloud-native box was created.', example='2021-07-07T20:44:00+08:00'),
      description?: string(name='description', description='The description of the cloud-native box.', example='B010'),
      manageRuntime?: int32(name='manage_runtime', description='Indicates whether the cloud-native box model manages the Docker runtime.', example='0/1'),
      memory?: int32(name='memory', description='The memory. Unit: GB.', example='8'),
      model?: string(name='model', description='The model of the cloud-native box.', example='ACK-V-B010'),
      modelId?: string(name='model_id', description='The ID of the cloud-native box.', example='c34cc753-8908-4739-bd10-ebd922a4****'),
    }
  ](name='models', description='The cloud-native box models.'),
}

model DescribeEdgeMachineModelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEdgeMachineModelsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeEdgeMachineModels  DescribeEdgeMachineModelsRequest
  * @return DescribeEdgeMachineModelsResponse
 */
async function describeEdgeMachineModels(request: DescribeEdgeMachineModelsRequest): DescribeEdgeMachineModelsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeEdgeMachineModels', 'GET', '/edge_machines/models', 'json', false, 'json', request);
}

model DescribeEdgeMachineTunnelConfigDetailRequest {
  edgeMachineid: string(name='edge_machineid', description='The ID of the cloud-native box.

This parameter is required.', example='cc0725ddf688744979cd98445f67e****', position='Path'),
}

model DescribeEdgeMachineTunnelConfigDetailResponseBody = {
  deviceName?: string(name='device_name', description='The device name.', example='TEST0621N0FF****'),
  model?: string(name='model', description='The model of the cloud-native box.', example='ACK-A-S001'),
  productKey?: string(name='product_key', description='Product Key', example='a11rXul****'),
  requestId?: string(name='request_id', description='Request ID', example='bfd12953-31cb-42f1-8a36-7b80ec345094'),
  sn?: string(name='sn', description='The serial number of the cloud-native box.', example='Q2CB5XZAFBFG****'),
  token?: string(name='token', description='Token', example='abcd****'),
  tunnelEndpoint?: string(name='tunnel_endpoint', description='The tunnel endpoint.', example='wss://frontend-iotx-r-debug.aliyun-inc.test'),
}

model DescribeEdgeMachineTunnelConfigDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEdgeMachineTunnelConfigDetailResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeEdgeMachineTunnelConfigDetail  DescribeEdgeMachineTunnelConfigDetailRequest
  * @return DescribeEdgeMachineTunnelConfigDetailResponse
 */
async function describeEdgeMachineTunnelConfigDetail(request: DescribeEdgeMachineTunnelConfigDetailRequest): DescribeEdgeMachineTunnelConfigDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeEdgeMachineTunnelConfigDetail', 'POST', '/edge_machines/[edge_machineid]/tunnelconfig', 'json', false, 'json', request);
}

model DescribeEdgeMachinesRequest {
  hostname?: string(name='hostname', description='The `hostname` of the cloud-native box.', example='ack-v-b010-ssdfw****', position='Query'),
  lifeState?: string(name='life_state', description='The lifecycle status.', example='activated/waitOnline/deleting', position='Query'),
  model?: string(name='model', description='The type of cloud-native box.', example='ACK-V-B010', position='Query'),
  onlineState?: string(name='online_state', description='The status of the cloud-native box. Valid values:

*   `offline`
*   `online`', example='offline/online', position='Query'),
  pageNumber?: long(name='page_number', description='The page number.', example='1', position='Query'),
  pageSize?: long(name='page_size', description='The number of entries per page.', example='10', position='Query'),
}

model DescribeEdgeMachinesResponseBody = {
  edgeMachines?: [ 
    {
      activeTime?: string(name='active_time', description='The time when the cloud-native box was activated.', example='2021-07-19T16:07:48+08:00'),
      created?: string(name='created', description='The time when the cloud-native box was created.', example='2021-07-07T20:44:00+08:00'),
      edgeMachineId?: string(name='edge_machine_id', description='The device ID.', example='c61083909b13f4a95b8554bda9577****'),
      hostname?: string(name='hostname', description='The `hostname` of the cloud-native box.', example='ack-v-b010-ssdfw****'),
      lifeState?: string(name='life_state', description='The lifecycle of the cloud-native box.', example='activated'),
      model?: string(name='model', description='The model of the cloud-native box.', example='ACK-V-B010'),
      name?: string(name='name', description='The machine name.', example='ack-v-b010-ssdfw****'),
      onlineState?: string(name='online_state', description='The status of the cloud-native box.', example='online'),
      sn?: string(name='sn', description='The serial number.', example='ACK9GBL31SXX****'),
      updated?: string(name='updated', description='The time when the cloud-native box was last updated.', example='2021-07-07T20:44:00+08:00'),
    }
  ](name='edge_machines', description='The list of cloud-native boxes.'),
  pageInfo?: {
    pageNumber?: int32(name='page_number', description='The page number.

Default value: 1.', example='1'),
    pageSize?: int32(name='page_size', description='The number of entries per page.

Default value: 10.', example='10'),
    totalCount?: int32(name='total_count', description='The total number of pages returned.', example='1'),
  }(name='page_info', description='The paging information.'),
}

model DescribeEdgeMachinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEdgeMachinesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeEdgeMachines  DescribeEdgeMachinesRequest
  * @return DescribeEdgeMachinesResponse
 */
async function describeEdgeMachines(request: DescribeEdgeMachinesRequest): DescribeEdgeMachinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeEdgeMachines', 'GET', '/edge_machines', 'json', false, 'json', request);
}

model DescribeEventsRequest {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='cf62854ac2130470897be7a27ed1f****', position='Query'),
  pageNumber?: long(name='page_number', description='The page number.', example='1', position='Query'),
  pageSize?: long(name='page_size', description='The number of entries per page.', example='50', position='Query'),
  type?: string(name='type', description='The event type. Valid values:

*   `cluster_create`: cluster creation.
*   `cluster_scaleout`: cluster scale-out.
*   `cluster_attach`: node addition.
*   `cluster_delete`: cluster deletion.
*   `cluster_upgrade`: cluster upgrades.
*   `cluster_migrate`: cluster migration.
*   `cluster_node_delete`: node removal.
*   `cluster_node_drain`: node draining.
*   `cluster_modify`: cluster modifications.
*   `cluster_configuration_modify`: modifications of control plane configurations.
*   `cluster_addon_install`: component installation.
*   `cluster_addon_upgrade`: component updates.
*   `cluster_addon_uninstall`: component uninstallation.
*   `runtime_upgrade`: runtime updates.
*   `nodepool_upgrade`: node pool upgrades.
*   `nodepool_update`: node pool updates.', example='nodepool_upgrade', position='Query'),
}

model DescribeEventsResponseBody = {
  events?: [ 
    {
      clusterId?: string(name='cluster_id', description='The ID of the cluster.', example='cluster-id'),
      data?: {
        level?: string(name='level', description='The severity level of the event. Valid values:

*   info
*   warning
*   error', example='info'),
        message?: string(name='message', description='The details of the event.', example='Start to upgrade NodePool nodePool/nodePool-A'),
        reason?: string(name='reason', description='The status of the event.', example='Started'),
      }(name='data', description='The description of the event.'),
      eventId?: string(name='event_id', description='The event ID.', example='A234-1234-1234'),
      source?: string(name='source', description='The source of the event.'),
      subject?: string(name='subject', description='The subject of the event.', example='nodePool-id'),
      time?: string(name='time', description='The time when the event started.', example='2022-11-23T20:48:01+08:00'),
      type?: string(name='type', description='The event type. Valid values:

*   `cluster_create`: cluster creation.
*   `cluster_scaleout`: cluster scale-out.
*   `cluster_attach`: node addition.
*   `cluster_delete`: cluster deletion.
*   `cluster_upgrade`: cluster upgrades.
*   `cluster_migrate`: cluster migration.
*   `cluster_node_delete`: node removal.
*   `cluster_node_drain`: node draining.
*   `cluster_modify`: cluster modifications.
*   `cluster_configuration_modify`: modifications of control plane configurations.
*   `cluster_addon_install`: component installation.
*   `cluster_addon_upgrade`: component updates.
*   `cluster_addon_uninstall`: component uninstallation.
*   `runtime_upgrade`: runtime updates.
*   `nodepool_upgrade`: node pool upgrades.
*   `nodepool_update`: node pool updates.', example='nodepool_upgrade'),
    }
  ](name='events', description='The details of the events.'),
  pageInfo?: {
    pageNumber?: long(name='page_number', description='The page number.', example='1'),
    pageSize?: long(name='page_size', description='The number of entries per page.', example='50'),
    totalCount?: long(name='total_count', description='The total number of entries returned.', example='3'),
  }(name='page_info', description='The pagination information.'),
}

model DescribeEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEventsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeEvents  DescribeEventsRequest
  * @return DescribeEventsResponse
 */
async function describeEvents(request: DescribeEventsRequest): DescribeEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeEvents', 'GET', '/events', 'json', false, 'json', request);
}

model DescribeEventsForRegionRequest {
  regionId: string(name='region_id', description='The region.

This parameter is required.', example='cn-hangzhou', position='Path'),
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='cf62854ac2130470897be7a27ed1f****', position='Query'),
  pageNumber?: long(name='page_number', description='The number of pages.', example='1', position='Query'),
  pageSize?: long(name='page_size', description='The number of records on each page.', example='50', position='Query'),
}

model DescribeEventsForRegionResponseBody = {
  events?: [ 
    {
      clusterId?: string(name='cluster_id', description='The cluster ID.', example='cluster-id'),
      data?: {
        level?: string(name='level', description='The severity level of the event.', example='info'),
        message?: string(name='message', description='The details of the event.', example='Start to upgrade NodePool nodePool/nodePool-A'),
        reason?: string(name='reason', description='The event status.', example='Started'),
      }(name='data', description='The description of the event.'),
      eventId?: string(name='event_id', description='The event ID.', example='A234-1234-1234'),
      source?: string(name='source', description='The event source.'),
      subject?: string(name='subject', description='The object associated with the event.', example='nodePool-id'),
      time?: string(name='time', description='The time when the event was generated.', example='2020-12-01T17:31:00Z'),
      type?: string(name='type', description='The event type.', example='nodePool_upgrade'),
    }
  ](name='events', description='The events.'),
  pageInfo?: {
    pageNumber?: long(name='page_number', description='The number of pages.', example='1'),
    pageSize?: long(name='page_size', description='The number of records on each page.', example='50'),
    totalCount?: long(name='total_count', description='The total number of entries returned.', example='3'),
  }(name='page_info', description='The pagination details.'),
}

model DescribeEventsForRegionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeEventsForRegionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeEventsForRegion  DescribeEventsForRegionRequest
  * @return DescribeEventsForRegionResponse
 */
async function describeEventsForRegion(request: DescribeEventsForRegionRequest): DescribeEventsForRegionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeEventsForRegion', 'GET', '/regions/{region_id}/events', 'json', false, 'json', request);
}

model DescribeExternalAgentRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

This parameter is required.', example='c106f377e16f34eb1808d6b9362c9****', position='Path'),
  agentMode?: string(name='AgentMode', description='The permission mode of the agent. Valid values:

admin: the admin mode, which provides full permissions. restricted: the restricted mode, which provides partial permissions. Default value: admin.', example='admin', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', description='Specifies whether to obtain the credentials that are used to access the cluster over the internal network.

*   `true`: obtains the credentials that are used to access the cluster over the internal network.
*   `false`: obtains the credentials that are used to access the cluster over the Internet.

Default value: `false`.', example='true', position='Query'),
}

model DescribeExternalAgentResponseBody = {
  config?: string(name='config', description='The agent configurations in the YAML format.', example='apiVersion: v1****'),
}

model DescribeExternalAgentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeExternalAgentResponseBody(name='body'),
}

/**
  * @deprecated OpenAPI DescribeExternalAgent is deprecated  * @description For more information, see [Register an external Kubernetes cluster](https://help.aliyun.com/document_detail/121053.html).
  * @param request  the request parameters of DescribeExternalAgent  DescribeExternalAgentRequest
  * @return DescribeExternalAgentResponse
 */
// Deprecated
async function describeExternalAgent(request: DescribeExternalAgentRequest): DescribeExternalAgentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeExternalAgent', 'GET', '/k8s/{ClusterId}/external/agent/deployment', 'json', false, 'json', request);
}

model DescribeKubernetesVersionMetadataRequest {
  clusterType: string(name='ClusterType', description='The cluster type that you want to use. Valid values:

*   `Kubernetes`: ACK dedicated cluster.
*   `ManagedKubernetes`: ACK managed cluster. ACK managed clusters include ACK Pro clusters, ACK Basic clusters, ACK Serverless Pro clusters, ACK Serverless Basic clusters, ACK Edge Pro clusters, and ACK Edge Basic clusters.
*   `ExternalKubernetes`: registered cluster.

This parameter is required.', example='Kubernetes', position='Query'),
  kubernetesVersion?: string(name='KubernetesVersion', description='The Kubernetes version of the cluster. The Kubernetes versions supported by ACK are the same as the Kubernetes versions supported by open source Kubernetes. We recommend that you specify the latest Kubernetes version. If you do not set this parameter, the latest Kubernetes version is used.

You can create ACK clusters of the latest two Kubernetes versions in the ACK console. You can call the specific ACK API operation to create clusters of other Kubernetes versions. For more information about the Kubernetes versions supported by ACK, see [Release notes for Kubernetes versions](https://help.aliyun.com/document_detail/185269.html).', example='1.16.9-aliyun.1', position='Query'),
  mode?: string(name='Mode', description='The query mode. Valid values:

*   `supported`: queries all supported Kubernetes versions.
*   `creatable`: queries only Kubernetes versions of clusters that you can create.

If you specify `KubernetesVersion`, this parameter does not take effect.

If you do not specify a query mode, Kubernetes versions of clusters that you can create are returned.', example='supported', position='Query'),
  profile?: string(name='Profile', description='The scenario where clusters are used. Valid values:

*   `Default`: non-edge computing scenarios
*   `Edge`: edge computing scenarios
*   `Serverless`: serverless scenarios.

Default value: `Default`.', example='Default', position='Query'),
  queryUpgradableVersion?: boolean(name='QueryUpgradableVersion', description='Specify whether to query the Kubernetes versions available for updates. This parameter takes effect only when the KubernetesVersion parameter is specified.', example='1.30.1-aliyun.1', position='Query'),
  region: string(name='Region', description='The region ID of the cluster.

This parameter is required.', example='cn-beijing', position='Query'),
  runtime?: string(name='runtime', description='The container runtime type that you want to use. You can specify a runtime type to query only OS images that support the runtime type. Valid values:

*   `docker`: Docker
*   `containerd`: containerd
*   `Sandboxed-Container.runv`: Sandboxed-Container

If you specify a runtime type, only the OS images that support the specified runtime type are returned.

Otherwise, all OS images are returned.', example='docker', position='Query'),
}

model DescribeKubernetesVersionMetadataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      capabilities?: map[string]any(name='capabilities', description='Features of the queried Kubernetes version.', example='{
      "AnyAZ": true,
      "ChargeType": "PostPaid"
}'),
      images?: [ 
        {
          imageId?: string(name='image_id', description='The image ID.', example='centos_7_7_x64_20G_alibase_20200426.vhd'),
          imageName?: string(name='image_name', description='The image name.', example='CentOS 7.7'),
          platform?: string(name='platform', description='The OS platform. Valid values:

*   `AliyunLinux`
*   `CentOS`
*   `Windows`
*   `WindowsCore`', example='CentOS'),
          osVersion?: string(name='os_version', description='The version of the image.', example='7.7'),
          imageType?: string(name='image_type', description='The type of OS distribution that you want to use. To specify the node OS, we recommend that you use this parameter. Valid values:

*   `CentOS`
*   `AliyunLinux`
*   `AliyunLinux Qboot`
*   `AliyunLinuxUEFI`
*   `AliyunLinux3`
*   `Windows`
*   `WindowsCore`
*   `AliyunLinux3Arm64`
*   `ContainerOS`', example='centos_7_7_20'),
          osType?: string(name='os_type', description='The type of OS. Examples:

*   `Windows`
*   `Linux`', example='Linux'),
          imageCategory?: string(name='image_category', description='The type of image. Valid values:

*   `system`: public image
*   `self`: custom image
*   `others`: shared image from other Alibaba Cloud accounts
*   `marketplace`: image from the marketplace', example='system'),
          architecture?: string(name='architecture', description='The architecture of the image.', example='x86_64'),
        }
      ](name='images', description='The OS images that are returned.'),
      metaData?: map[string]any(name='meta_data', description='The metadata of the Kubernetes version.', example='{
      "KubernetesVersion": "1.31.1-aliyun.1",
      "SubClass": "default",
      "ServiceCIDR": ""
}'),
      runtimes?: [
        Runtime
      ](name='runtimes', description='The container runtime configurations.'),
      version?: string(name='version', description='The Kubernetes version supported by ACK. For more information, see [Release notes for Kubernetes versions](https://help.aliyun.com/document_detail/185269.html).', example='1.16.9-aliyun.1'),
      releaseDate?: string(name='release_date', description='The release date of the Kubernetes version.', example='2023-04-30T00:00:00Z'),
      expirationDate?: string(name='expiration_date', description='The expiration date of the Kubernetes version.', example='2025-04-30T00:00:00Z'),
      creatable?: boolean(name='creatable', description='Indicates whether you can create clusters that run the Kubernetes version.', example='true'),
      upgradableVersions?: [ string ](name='upgradable_versions', description='The list of available versions for updates.'),
    }
  ](name='body'),
}

/**
  * @param request  the request parameters of DescribeKubernetesVersionMetadata  DescribeKubernetesVersionMetadataRequest
  * @return DescribeKubernetesVersionMetadataResponse
 */
async function describeKubernetesVersionMetadata(request: DescribeKubernetesVersionMetadataRequest): DescribeKubernetesVersionMetadataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeKubernetesVersionMetadata', 'GET', '/api/v1/metadata/versions', 'array', false, 'json', request);
}

model DescribeNodePoolVulsRequest {
  clusterId: string(name='cluster_id', description='Cluster ID.

This parameter is required.', example='c17e742cee942410486f237293d66****', position='Path'),
  nodepoolId: string(name='nodepool_id', description='Node pool ID.

This parameter is required.', example='np38f32fdbc60e4a1e957ffde77846****', position='Path'),
  necessity?: string(name='necessity', description='The priority to fix the vulnerability. Separate multiple priorities with commas (,). Valid values:

*   `asap`: high
*   `later`: medium
*   `nntf`: low', example='asap', position='Query'),
}

model DescribeNodePoolVulsResponseBody = {
  vulRecords?: [ 
    {
      instanceId?: string(name='instance_id', description='The ID of the node.', example='i-t4n2qolb0wtzt0pz****'),
      nodeName?: string(name='node_name', description='The node name. This name is the identifier of the node in the cluster.', example='cn-hangzhou.192.168.x.x'),
      vulList?: [ 
        {
          aliasName?: string(name='alias_name', description='The alias of the vulnerability.', example='RHSA-2019:3197-Important: sudo security update'),
          cveList?: [ string ](name='cve_list', description='A list of CVE names corresponding to the vulnerabilities.'),
          name?: string(name='name', description='The name of the vulnerability.', example='oval:com.redhat.rhsa:def:20193197'),
          necessity?: string(name='necessity', description='The severity level of the vulnerability.

Valid values:

*   nntf: You can ignore the vulnerability.
*   later: You can fix the vulnerability later.
*   asap: You need to fix the vulnerability at the earliest opportunity.', example='asap'),
          needReboot?: boolean(name='need_reboot', description='Indicates whether a restart is required.', example='false'),
        }
      ](name='vul_list', description='A list of vulnerabilities.'),
    }
  ](name='vul_records', description='The node pool vulnerabilities.'),
  vulsFixServicePurchased?: boolean(name='vuls_fix_service_purchased', description='Whether the Cloud Security CVE Remediation Service has been purchased', example='false'),
}

model DescribeNodePoolVulsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeNodePoolVulsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeNodePoolVuls  DescribeNodePoolVulsRequest
  * @return DescribeNodePoolVulsResponse
 */
async function describeNodePoolVuls(request: DescribeNodePoolVulsRequest): DescribeNodePoolVulsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeNodePoolVuls', 'GET', '/clusters/{cluster_id}/nodepools/{nodepool_id}/vuls', 'json', false, 'json', request);
}

model DescribePoliciesRequest {
}

model DescribePoliciesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: map[string]any(name='body'),
}

/**
  * @param request  the request parameters of DescribePolicies  DescribePoliciesRequest
  * @return DescribePoliciesResponse
 */
async function describePolicies(request: DescribePoliciesRequest): DescribePoliciesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribePolicies', 'GET', '/policies', 'json', false, 'json', request);
}

model DescribePolicyDetailsRequest {
  policyName: string(name='policy_name', description='The name of the policy.

This parameter is required.', example='ACKAllowedRepos', position='Path'),
}

model DescribePolicyDetailsResponseBody = {
  action?: string(name='action', description='The action of the policy. Valid values:

*   `enforce`: blocks deployments that match the policy.
*   `inform`: generates alerts for deployments that match the policy.', example='enforce'),
  category?: string(name='category', description='The type of the policy.', example='k8s-general'),
  description?: string(name='description', description='The description of the policy.', example='Requires container images to begin with a repo string from a specified list'),
  isDeleted?: int32(name='is_deleted', description='Indicates whether the policy is deleted. Valid values:

*   0: The policy is not deleted.
*   1: The policy is deleted.', example='0'),
  name?: string(name='name', description='The name of the policy.', example='ACKAllowedRepos'),
  noConfig?: int32(name='no_config', description='Indicates whether parameters are required. Valid values:

*   0: Parameters are required.
*   1: Parameters are optional.', example='0'),
  severity?: string(name='severity', description='The severity level of the policy. Valid values:

*   `high`
*   `medium`
*   `low`', example='high'),
  template?: string(name='template', description='The content of the policy.', example='For more information, see sample requests.'),
}

model DescribePolicyDetailsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePolicyDetailsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePolicyDetails  DescribePolicyDetailsRequest
  * @return DescribePolicyDetailsResponse
 */
async function describePolicyDetails(request: DescribePolicyDetailsRequest): DescribePolicyDetailsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribePolicyDetails', 'GET', '/policies/{policy_name}', 'json', false, 'json', request);
}

model DescribePolicyGovernanceInClusterRequest {
  clusterId: string(name='cluster_id', description='The cluster ID.

This parameter is required.', example='c8155823d057948c69a****', position='Path'),
}

model DescribePolicyGovernanceInClusterResponseBody = {
  admitLog?: {
    count?: long(name='count', description='The number of audit log entries.', example='100'),
    log?: {
      clusterId?: string(name='cluster_id', description='The cluster ID.', example='c8155823d057948c69a****'),
      constraintKind?: string(name='constraint_kind', description='The policy type.', example='ACKAllowedRepos'),
      msg?: string(name='msg', description='The message that appears when an event is generated by a policy.', example='d4hdhs*****'),
      resourceKind?: string(name='resource_kind', description='The resource type.', example='Pod'),
      resourceName?: string(name='resource_name', description='The resource name.', example='nginx-deployment-basic2-84ccb74bfc-df22p'),
      resourceNamespace?: string(name='resource_namespace', description='The namespace to which the resource belongs.', example='default'),
    }(name='log', description='The audit log content.'),
    progress?: string(name='progress', description='The status of the query. Valid values:

*   `Complete`: The query succeeded and the complete query result is returned.
*   `Incomplete`: The query succeeded but the query result is incomplete. To obtain the complete query result, you must repeat the request.', example='Complete'),
  }(name='admit_log', description='The audit logs of the policies in the cluster.'),
  onState?: [ 
    {
      enabledCount?: int32(name='enabled_count', description='The number of policies that are enabled.', example='3'),
      severity?: string(name='severity', description='The severity level of the policy.', example='high'),
      total?: int32(name='total', description='The total number of policies of the severity level.', example='8'),
    }
  ](name='on_state', description='Details about the policies of different severity levels that are enabled for the cluster.'),
  totalViolations?: {
    deny?: {
      severity?: string(name='severity', description='The severity level of the policy.', example='high'),
      violations?: long(name='violations', description='The number of blocking events that are triggered.', example='0'),
    }(name='deny', description='Details about the blocking events that are triggered by the policies of each severity level.'),
    warn?: {
      severity?: string(name='severity', description='The severity level of the policy.', example='low'),
      violations?: long(name='violations', description='The number of alerting events that are triggered.', example='5'),
    }(name='warn', description='Details about the alerting events that are triggered by the policies of each severity level.'),
  }(name='totalViolations', description='Details about the blocking and alerting events that are triggered by policies of different severity levels.'),
  violations?: {
    deny?: {
      policyDescription?: string(name='policyDescription', description='The policy description.', example='Requires container images to begin with a repo string from a specified list.'),
      policyName?: string(name='policyName', description='The policy name.', example='policy-gatekeeper-ackallowedrepos'),
      severity?: string(name='severity', description='The severity level of the policy.', example='high'),
      violations?: long(name='violations', description='The total number of blocking events that are triggered by the policy.', example='11'),
    }(name='deny', description='Details about the blocking events that are triggered by each policy.'),
    warn?: {
      policyDescription?: string(name='policyDescription', description='The policy description.', example='Controls Linux capabilities.'),
      policyName?: string(name='policyName', description='The policy name.', example='policy-gatekeeper-ackpspcapabilities'),
      severity?: string(name='severity', description='The severity level of the policy.', example='high'),
      violations?: long(name='violations', description='The total number of alerting events that are triggered by the policy.', example='81'),
    }(name='warn', description='Details about the alerting events that are triggered by the policies of each severity level.'),
  }(name='violations', description='Details about the blocking and alerting events that are triggered by different policies.'),
}

model DescribePolicyGovernanceInClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePolicyGovernanceInClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePolicyGovernanceInCluster  DescribePolicyGovernanceInClusterRequest
  * @return DescribePolicyGovernanceInClusterResponse
 */
async function describePolicyGovernanceInCluster(request: DescribePolicyGovernanceInClusterRequest): DescribePolicyGovernanceInClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribePolicyGovernanceInCluster', 'GET', '/clusters/{cluster_id}/policygovernance', 'json', false, 'json', request);
}

model DescribePolicyInstancesRequest {
  clusterId: string(name='cluster_id', description='The ID of the cluster.

This parameter is required.', example='c8155823d057948c69a****', position='Path'),
  instanceName?: string(name='instance_name', description='The name of the policy instance that you want to query.', example='allowed-repos-cz4s2', position='Query'),
  policyName?: string(name='policy_name', description='The name of the policy that you want to query.', example='ACKPSPCapabilities', position='Query'),
}

model DescribePolicyInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      aliUid?: string(name='ali_uid', description='The UID of the Alibaba Cloud account that is used to deploy the policy instance.', example='16298168****'),
      clusterId?: string(name='cluster_id', description='The ID of the cluster.', example='c8155823d057948c69a****'),
      instanceName?: string(name='instance_name', description='The name of the policy instance.', example='no-env-var-secrets-****'),
      policyName?: string(name='policy_name', description='The name of the policy.', example='ACKPSPCapabilities'),
      policyCategory?: string(name='policy_category', description='The type of the policy.', example='k8s-general'),
      policyDescription?: string(name='policy_description', description='The description of the policy template.', example='Restricts secrets used in pod envs'),
      policyParameters?: string(name='policy_parameters', description='The parameters of the policy instance.', example='"restrictedNamespaces": [ "test" ]'),
      policySeverity?: string(name='policy_severity', description='The severity level of the policy instance.', example='low'),
      policyScope?: string(name='policy_scope', description='The applicable scope of the policy instance.

A value of \\* indicates all namespaces in the cluster. This is the default value.

Multiple namespaces are separated by commas (,).', example='*'),
      policyAction?: string(name='policy_action', description='The action of the policy. Valid values:

*   `deny`: Deployments that match the policy are denied.
*   `warn`: Alerts are generated for deployments that match the policy.', example='deny'),
      created?: string(name='Created', description='The creation time of the instance. This parameter is deprecated.', example='2024-10-29T18:09:12+08:00', deprecated='true'),
      updated?: string(name='Updated', description='The update time of the instance. This parameter is deprecated.', example='2024-10-29T18:09:12+08:00', deprecated='true'),
      resourceId?: string(name='resource_id', description='The ID of the resource. This parameter is deprecated.', example='123456***', deprecated='true'),
      totalViolations?: long(name='total_violations', description='The number of violations processed in the cluster. This parameter is deprecated.', example='0', deprecated='true'),
      isDeleted?: long(name='is_deleted', description='The status of the deletion. This parameter is deprecated.', example='0', deprecated='true'),
    }
  ](name='body'),
}

/**
  * @param request  the request parameters of DescribePolicyInstances  DescribePolicyInstancesRequest
  * @return DescribePolicyInstancesResponse
 */
async function describePolicyInstances(request: DescribePolicyInstancesRequest): DescribePolicyInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribePolicyInstances', 'GET', '/clusters/{cluster_id}/policies', 'array', false, 'json', request);
}

model DescribePolicyInstancesStatusRequest {
  clusterId: string(name='cluster_id', description='The cluster ID.

This parameter is required.', example='c8155823d057948c69a****', position='Path'),
}

model DescribePolicyInstancesStatusResponseBody = {
  instancesSeverityCount?: map[string]any(name='instances_severity_count', description='The number of policy instances that are deployed in the cluster at different severity levels.', example='{ "high": 11,     "medium": 1  }'),
  policyInstances?: [ 
    {
      policyCategory?: string(name='policy_category', description='The type of the policy. For more information about different types of policies and their descriptions, see [Predefined security policies of ACK](https://help.aliyun.com/document_detail/359819.html).', example='compliance'),
      policyDescription?: string(name='policy_description', description='The description of the policy.', example='Restricts use of the cluster-admin role.'),
      policyInstancesCount?: long(name='policy_instances_count', description='The number of policy instances that are deployed. If this parameter is empty, no policy instance is deployed.', example='1'),
      policyName?: string(name='policy_name', description='The name of the policy.', example='ACKRestrictRoleBindings'),
      policySeverity?: string(name='policy_severity', description='The severity level of the policy.', example='medium'),
    }
  ](name='policy_instances', description='The number of policy instances of each policy type.'),
}

model DescribePolicyInstancesStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePolicyInstancesStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePolicyInstancesStatus  DescribePolicyInstancesStatusRequest
  * @return DescribePolicyInstancesStatusResponse
 */
async function describePolicyInstancesStatus(request: DescribePolicyInstancesStatusRequest): DescribePolicyInstancesStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribePolicyInstancesStatus', 'GET', '/clusters/{cluster_id}/policies/status', 'json', false, 'json', request);
}

model DescribeResourcesDeleteProtectionRequest {
  clusterId: string(name='ClusterId', description='The ID of the Container Service for Kubernetes (ACK) cluster.

This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
  resourceType: string(name='ResourceType', description='The type of the resource that you want to query. Valid values:

*   Namespaces
*   services

This parameter is required.', example='namespaces', position='Path'),
  namespace?: string(name='namespace', description='The namespace in which the resources that you want to query reside.

This parameter is required when you set resource_type to services. Default value: default.', example='default', position='Query'),
  resources?: string(name='resources', description='The names of the resources that you want to query. Separate multiple resource names with commas (,).

*   When you set resource_type to namespaces, you must specify namespace names. If you leave this parameter empty, all namespaces in the cluster are queried.
*   If you set resource_type to services, you must specify Service names.', example='test1,test2', position='Query'),
}

model DescribeResourcesDeleteProtectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      name: string(name='name', description='The resource name.

This parameter is required.', example='test'),
      namespace?: string(name='namespace', description='The namespace to which the resource belongs.', example='default'),
      resource?: string(name='resource', description='The type of the resource.', example='namespaces'),
      protection?: boolean(name='protection', description='Indicates whether deletion protection is enabled.

*   true: deletion protection is enabled.
*   false: deletion protection is disabled.', example='false'),
    }
  ](name='body'),
}

/**
  * @param request  the request parameters of DescribeResourcesDeleteProtection  DescribeResourcesDeleteProtectionRequest
  * @return DescribeResourcesDeleteProtectionResponse
 */
async function describeResourcesDeleteProtection(request: DescribeResourcesDeleteProtectionRequest): DescribeResourcesDeleteProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeResourcesDeleteProtection', 'GET', '/clusters/{ClusterId}/resources/{ResourceType}/protection', 'array', false, 'json', request);
}

model DescribeSubaccountK8sClusterUserConfigRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c5b5e80b0b64a4bf6939d2d8f****', position='Path'),
  uid: string(name='Uid', description='The ID of the RAM user or RAM role whose cluster kubeconfig file that you want to obtain.

This parameter is required.', example='26562443851650****', position='Path'),
  privateIpAddress?: boolean(name='PrivateIpAddress', description='Specifies whether to obtain the kubeconfig file used to connect to the cluster over the internal network. Valid values:

*   `true`: Obtain the kubeconfig file used to connect to the cluster over the internal network.
*   `false`: Obtain the kubeconfig file used to connect to the cluster over the Internet.

Default value: `false`.', example='true', position='Query'),
  temporaryDurationMinutes?: long(name='TemporaryDurationMinutes', description='The validity period of the temporary kubeconfig file. Unit: minutes.

Valid values: 15 to 4320 (three days).

> If you leave this parameter empty, the system sets a longer validity period and returns the value in the expiration parameter of the response.', example='15', position='Query'),
}

model DescribeSubaccountK8sClusterUserConfigResponseBody = {
  config: string(name='config', description='The cluster kubeconfig file. For more information about how to view the kubeconfig file content, see [Configure cluster credentials](https://help.aliyun.com/document_detail/86494.html).

This parameter is required.', example='apiVersion: v1****'),
  expiration?: string(name='expiration', description='The expiration date of the kubeconfig file. The value is the UTC time displayed in RFC3339 format.', example='2024-03-10T09:56:17Z'),
}

model DescribeSubaccountK8sClusterUserConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSubaccountK8sClusterUserConfigResponseBody(name='body'),
}

/**
  * @description You can call this operation only by using an Alibaba Cloud account.
  * @param request  the request parameters of DescribeSubaccountK8sClusterUserConfig  DescribeSubaccountK8sClusterUserConfigRequest
  * @return DescribeSubaccountK8sClusterUserConfigResponse
 */
async function describeSubaccountK8sClusterUserConfig(request: DescribeSubaccountK8sClusterUserConfigRequest): DescribeSubaccountK8sClusterUserConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeSubaccountK8sClusterUserConfig', 'GET', '/k8s/{ClusterId}/users/{Uid}/user_config', 'json', false, 'json', request);
}

model DescribeTaskInfoRequest {
  taskId: string(name='task_id', description='The task ID.

This parameter is required.', example='T-5faa48fb31b6b8078d00****', position='Path'),
}

model DescribeTaskInfoResponseBody = {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='c78592bfe92244365b3c3ad47f1de****'),
  created?: string(name='created', description='The time when the task was created.', example='2020-11-10T16:02:04+08:00'),
  currentStage?: string(name='current_stage', description='The current stage of the task.', example='DrainNodes'),
  error?: {
    code?: string(name='code', description='The error code returned.', example='400'),
    message?: string(name='message', description='The error message returned.', example='failed to xxx'),
  }(name='error', description='The error returned for the task.'),
  events?: [ 
    {
      action?: string(name='action', description='The action of the event.', example='start'),
      level?: string(name='level', description='The severity level of the event.', example='Normal'),
      message?: string(name='message', description='The message about the event.', example='start to xxx'),
      reason?: string(name='reason', description='The cause of the event.', example='NodePoolUpgradeStart'),
      source?: string(name='source', description='The source of the event.', example='ACK'),
      timestamp?: string(name='timestamp', description='The timestamp when the event was generated.', example='1669706229286'),
    }
  ](name='events', description='The event generated by the task.'),
  parameters?: map[string]any(name='parameters', description='The task parameters.'),
  stages?: [ 
    {
      endTime?: string(name='end_time', description='The end time of the stage.', example='2022-12-15 23:00:00'),
      message?: string(name='message', description='The message about the stage.', example='success to xxxxx'),
      outputs?: map[string]any(name='outputs', description='The output generated at the stage.'),
      startTime?: string(name='start_time', description='The start time of the stage.', example='2022-12-15 23:00:00'),
      state?: string(name='state', description='The status of the stage.', example='running'),
    }
  ](name='stages', description='Detailed information about the stage of the task.'),
  state?: string(name='state', description='The status of the task. Valid values:

*   `running`: The task is running.
*   `failed`: The task failed.
*   `success`: The task is complete.', example='running'),
  target?: {
    id?: string(name='id', description='The ID of the object.', example='c78592bfe92244365b3c3ad47f1de****'),
    type?: string(name='type', description='The type of the object.', example='cluster'),
  }(name='target', description='The object of the task.'),
  taskId?: string(name='task_id', description='The task ID.', example='T-5faa48fb31b6b8078d000006'),
  taskResult?: [ 
    {
      data?: string(name='data', description='The resources that are managed by the task. For a scale-out task, the value of this parameter is the ID of the instance that is added by the task.', example='i-xxx'),
      status?: string(name='status', description='The status of the scale-out task. Valid values:

*   `success`: The scale-out task is successful.
*   `success`: The scale-out task failed.
*   `initial`: The scale-out task is being initialized.', example='success'),
    }
  ](name='task_result', description='The execution details of the task.'),
  taskType?: string(name='task_type', description='The task type. A value of `cluster_scaleout` indicates a scale-out task.', example='cluster_scaleout'),
  updated?: string(name='updated', description='The time when the task was updated.', example='2020-11-10T16:03:06+08:00'),
}

model DescribeTaskInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTaskInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeTaskInfo  DescribeTaskInfoRequest
  * @return DescribeTaskInfoResponse
 */
async function describeTaskInfo(request: DescribeTaskInfoRequest): DescribeTaskInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeTaskInfo', 'GET', '/tasks/{task_id}', 'json', false, 'json', request);
}

model DescribeTemplateAttributeRequest {
  templateId: string(name='TemplateId', description='The ID of the template.

This parameter is required.', example='874ec485-e7e6-4373-8a3b-47bde8a****', position='Path'),
  templateType?: string(name='template_type', description='The type of template. The value can be a custom value.

*   If the parameter is set to `kubernetes`, the template is displayed on the Templates page in the console.
*   If the parameter is set to `compose`, the template is displayed on the Container Service - Swarm page in the console. Container Service for Swarm is deprecated.
*   If the value of the parameter is not `kubernetes`, the template is not displayed on the Templates page in the console. We recommend that you set the parameter to `kubernetes`.

Default value: `kubernetes`.', example='kubernetes', position='Query'),
}

model DescribeTemplateAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      id?: string(name='id', description='The ID of the template. When you update a template, a new template ID is generated.', example='72d20cf8-a533-4ea9-a10d-e7630d3d****'),
      acl?: string(name='acl', description='The access control policy of the template.', example='private'),
      name?: string(name='name', description='The name of the template.', example='web'),
      template?: string(name='template', description='The template content in the YAML format.', example='apiVersion: V1\\n***'),
      templateType?: string(name='template_type', description='The type of template. The value can be a custom value.

*   If the parameter is set to `kubernetes`, the template is displayed on the Templates page in the console.
*   If the parameter is set to `compose`, the template is displayed on the Container Service - Swarm page in the console. Container Service for Swarm is deprecated.
*   If the value of the parameter is not `kubernetes`, the template is not displayed on the Templates page in the console. We recommend that you set the parameter to `kubernetes`.

Default value: `kubernetes`.', example='kubernetes'),
      description?: string(name='description', description='The description of the template.', example='test template'),
      tags?: string(name='tags', description='The label of the template.', example='sa'),
      templateWithHistId?: string(name='template_with_hist_id', description='The unique ID of the template. The value remains unchanged after the template is updated.', example='874ec485-e7e6-4373-8a3b-47bde8ae****'),
      created?: string(name='created', description='The time when the template was created.', example='2020-09-16T19:21:29+08:00'),
      updated?: string(name='updated', description='The time when the template was updated.', example='2020-09-16T19:21:29+08:00'),
    }
  ](name='body'),
}

/**
  * @param request  the request parameters of DescribeTemplateAttribute  DescribeTemplateAttributeRequest
  * @return DescribeTemplateAttributeResponse
 */
async function describeTemplateAttribute(request: DescribeTemplateAttributeRequest): DescribeTemplateAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeTemplateAttribute', 'GET', '/templates/{TemplateId}', 'array', false, 'json', request);
}

model DescribeTemplatesRequest {
  pageNum?: long(name='page_num', description='The page number.

Default value: 1.', example='1', position='Query'),
  pageSize?: long(name='page_size', description='The number of entries per page.

Default value: 10.', example='10', position='Query'),
  templateType?: string(name='template_type', description='The type of template. This parameter can be set to a custom value.

*   If the parameter is set to `kubernetes`, the template is displayed on the Templates page in the console.
*   If you set the parameter to `compose`, the template is not displayed on the Templates page in the console.

Default value: `kubernetes`.', example='kubernetes', position='Query'),
}

model DescribeTemplatesResponseBody = {
  pageInfo?: {
    pageNumber?: long(name='page_number', description='The page number.', example='20'),
    pageSize?: long(name='page_size', description='The number of entries per page.', example='3'),
    totalCount?: long(name='total_count', description='The total number of entries returned.', example='50'),
  }(name='page_info', description='The pagination information.'),
  templates?: [ 
    {
      acl?: string(name='acl', description='The access control policy of the template. Valid values:

*   `private`: The template is private.
*   `public`: The template is public.
*   `shared`: The template can be shared.

Default value: `private`.', example='private'),
      created?: string(name='created', description='The time when the template was created.', example='2020-06-10T16:30:16+08:00'),
      description?: string(name='description', description='The description of the template.', example='a web server'),
      id?: string(name='id', description='The ID of the template.', example='874ec485-e7e6-4373-8a3b-47bde8ae789f'),
      name?: string(name='name', description='The name of the template.', example='webserver'),
      tags?: string(name='tags', description='The label of the template. By default, the value is the name of the template.', example='kubernetes'),
      template?: string(name='template', description='The template content in the YAML format.', example='apiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: nginx-deployment-basic\\n  labels:\\n    app: nginx\\nspec:\\n  replicas: 2\\n  selector:\\n    matchLabels:\\n      app: nginx\\n  template:\\n    metadata:\\n      labels:\\n        app: nginx\\n    spec:\\n      containers:\\n      - name: nginx\\n        image: busybox:latest\\n        ports:\\n        - containerPort: 80'),
      templateType?: string(name='template_type', description='The type of template. This parameter can be set to a custom value.

*   If the parameter is set to `kubernetes`, the template is displayed on the Templates page in the console.
*   If the parameter is set to `compose`, the template is displayed on the Container Service - Swarm page in the console. However, Container Service for Swarm is deprecated.', example='kubernetes'),
      templateWithHistId?: string(name='template_with_hist_id', description='The ID of the parent template. The value of `template_with_hist_id` is the same for each template version. This allows you to manage different template versions.', example='ad81d115-7c8b-47e7-a222-9c28d7f6e588'),
      updated?: string(name='updated', description='The time when the template was updated.', example='2020-06-10T16:30:16+08:00'),
    }
  ](name='templates', description='The list of returned templates.'),
}

model DescribeTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTemplatesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeTemplates  DescribeTemplatesRequest
  * @return DescribeTemplatesResponse
 */
async function describeTemplates(request: DescribeTemplatesRequest): DescribeTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeTemplates', 'GET', '/templates', 'json', false, 'json', request);
}

model DescribeTriggerRequest {
  clusterId: string(name='cluster_id', description='The cluster ID.

This parameter is required.', example='c5cdf7e3938bc4f8eb0e44b21a80f****', position='Path'),
  name: string(name='Name', description='The application name.

This parameter is required.', example='web-server', position='Query'),
  namespace: string(name='Namespace', description='The namespace to which the application belongs.

This parameter is required.', example='default', position='Query'),
  type?: string(name='Type', description='The type of trigger. Valid values:

*   `deployment`: performs actions on Deployments.
*   `application`: performs actions on applications that are deployed in Application Center.

Default value: `deployment`.

If you do not set this parameter, triggers are not filtered by type.', example='deployment', position='Query'),
  action?: string(name='action', description='The action that the trigger performs. Set the value to redeploy.

`redeploy`: redeploys the resources specified by `project_id`.

If you do not specify this parameter, triggers are not filtered by action.', example='redeploy', position='Query'),
}

model DescribeTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      id?: string(name='id', description='The ID of the trigger.', example='1234'),
      name?: string(name='name', description='The name of the trigger.', example='test'),
      clusterId?: string(name='cluster_id', description='The ID of the associated cluster.', example='c259f563386444ebb8d7****'),
      projectId?: string(name='project_id', description='The name of the project.

The name consists of the namespace where the application is deployed and the name of the application. The format is `${namespace}/${name}`. Example: default/test-app.', example='default/test-app'),
      type?: string(name='type', description='The type of trigger.

Valid values:

*   `deployment`: performs actions on Deployments.
*   `application`: performs actions on applications that are deployed in Application Center.

Default value: `deployment`.', example='deployment'),
      action?: string(name='action', description='The action that the trigger performs. The value is set to redeploy.

`redeploy`: redeploys the resource specified by project_id.', example='redeploy'),
      token?: string(name='token', description='The token information.', example='eyJhbGci***'),
    }
  ](name='body'),
}

/**
  * @param request  the request parameters of DescribeTrigger  DescribeTriggerRequest
  * @return DescribeTriggerResponse
 */
async function describeTrigger(request: DescribeTriggerRequest): DescribeTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeTrigger', 'GET', '/clusters/{cluster_id}/triggers', 'array', false, 'json', request);
}

model DescribeUserClusterNamespacesRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

This parameter is required.', example='c5b5e80b0b64a4bf6939d2d8fbbc5****', position='Path'),
}

model DescribeUserClusterNamespacesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ string ](name='body'),
}

/**
  * @param request  the request parameters of DescribeUserClusterNamespaces  DescribeUserClusterNamespacesRequest
  * @return DescribeUserClusterNamespacesResponse
 */
async function describeUserClusterNamespaces(request: DescribeUserClusterNamespacesRequest): DescribeUserClusterNamespacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeUserClusterNamespaces', 'GET', '/api/v2/k8s/{ClusterId}/namespaces', 'array', false, 'json', request);
}

model DescribeUserPermissionRequest {
  uid: string(name='uid', description='The ID of the RAM user or RAM role.

>  If you want to grant permissions to a RAM role, enter the ID of the RAM role.

This parameter is required.', example='21175****', position='Path'),
}

model DescribeUserPermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      resourceId?: string(name='resource_id', description='The authorization setting. Valid values:

*   `{cluster_id}` is returned if the permissions are scoped to a cluster.
*   `{cluster_id}/{namespace}` is returned if the permissions are scoped to a namespace of a cluster.
*   `all-clusters` is returned if the permissions are scoped to all clusters.', example='c1b542****'),
      resourceType?: string(name='resource_type', description='The authorization type. Valid values:

*   `cluster`: indicates that the permissions are scoped to a cluster.
*   `namespace`: indicates that the permissions are scoped to a namespace of a cluster.
*   `console`: indicates that the permissions are scoped to all clusters. This value was displayed only in the console.', example='cluster'),
      roleName?: string(name='role_name', description='The name of the custom role. If a custom role is assigned, the value is the name of the assigned custom role.', example='view'),
      roleType?: string(name='role_type', description='The type of predefined role. Valid values:

*   `admin`: administrator
*   `ops`: O\\&M engineer
*   `dev`: developer
*   `restricted`: restricted user
*   `custom`: custom role', example='admin'),
      isOwner?: long(name='is_owner', description='Indicates whether the permissions are granted to the cluster owner.

*   `0`: indicates that the permissions are not granted to the cluster owner.
*   `1`: indicates that the permissions are granted to the cluster owner. The cluster owner is the administrator.', example='1'),
      isRamRole?: long(name='is_ram_role', description='Indicates whether the permissions are granted to the RAM role. Valid values:

*   `0`: indicates that the permissions are not granted to the RAM role.
*   `1`: indicates that the permissions are granted to the RAM role.', example='1'),
    }
  ](name='body'),
}

/**
  * @description **Precautions**:
  * *   If you call this operation as a Resource Access Management (RAM) user or by assuming a RAM role, only the permissions granted on the clusters on which the current account has the role-based access control (RBAC) administrator permissions are returned. If you want to query the permissions on all clusters, you must use an account that has the RBAC administrator permissions on all clusters.
  * @param request  the request parameters of DescribeUserPermission  DescribeUserPermissionRequest
  * @return DescribeUserPermissionResponse
 */
async function describeUserPermission(request: DescribeUserPermissionRequest): DescribeUserPermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeUserPermission', 'GET', '/permissions/users/{uid}', 'array', false, 'json', request);
}

model DescribeUserQuotaRequest {
}

model DescribeUserQuotaResponseBody = {
  amkClusterQuota?: long(name='amk_cluster_quota', description='The quota of Container Service for Kubernetes (ACK) managed clusters. Default value: 20. If the default quota limit is reached, submit an application in the [Quota Center console](https://quotas.console.aliyun.com/products/csk/quotas) to increase the quota.', example='20'),
  askClusterQuota?: long(name='ask_cluster_quota', description='The quota of ACK Serverless clusters. Default value: 20. If the default quota limit is reached, submit an application in the [Quota Center console](https://quotas.console.aliyun.com/products/csk/quotas) to increase the quota.', example='3'),
  clusterNodepoolQuota?: long(name='cluster_nodepool_quota', description='The quota of node pools in an ACK cluster. Default value: 20. If the default quota limit is reached, submit an application in the [Quota Center console](https://quotas.console.aliyun.com/products/csk/quotas) to increase the quota.', example='10'),
  clusterQuota?: long(name='cluster_quota', description='The quota of clusters that belong to an Alibaba Cloud account. Default value: 50. If the default quota limit is reached, submit an application in the [Quota Center console](https://quotas.console.aliyun.com/products/csk/quotas) to increase the quota.', example='50'),
  edgeImprovedNodepoolQuota?: {
    bandwidth?: int32(name='bandwidth', description='This parameter is discontinued.

The maximum bandwidth of each enhanced edge node pool. Unit: Mbit/s.', example='10'),
    count?: int32(name='count', description='This parameter is discontinued.

The maximum number of enhanced edge node pools that you can create within an Alibaba Cloud account.', example='3'),
    period?: int32(name='period', description='This parameter is discontinued.

The maximum subscription duration of an enhanced edge node pool. Unit: months.

>  You are charged for enhanced edge node pools based on the pay-as-you-go billing method. Therefore, you can ignore this parameter.', example='3'),
  }(name='edge_improved_nodepool_quota', description='This parameter is discontinued.

The quotas of enhanced edge node pools.'),
  nodeQuota?: long(name='node_quota', description='The quota of nodes in an ACK cluster. Default value: 100. If the default quota limit is reached, submit an application in the [Quota Center console](https://quotas.console.aliyun.com/products/csk/quotas) to increase the quota.', example='100'),
  quotas?: map[string]QuotasValue(name='quotas', description='Information about the new quota.'),
}

model DescribeUserQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUserQuotaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeUserQuota  DescribeUserQuotaRequest
  * @return DescribeUserQuotaResponse
 */
async function describeUserQuota(request: DescribeUserQuotaRequest): DescribeUserQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeUserQuota', 'GET', '/quota', 'json', false, 'json', request);
}

model EdgeClusterAddEdgeMachineRequest {
  clusterid: string(name='clusterid', description='The cluster ID.

This parameter is required.', example='c35607f52179f4472a0d9723e7595****', position='Path'),
  edgeMachineid: string(name='edge_machineid', description='The ID of the cloud-native box.

This parameter is required.', example='edge_machineid', position='Path'),
  expired?: long(name='expired', description='The timeout period of sessions. Unit: seconds.', example='1024', position='Body'),
  nodepoolId: string(name='nodepool_id', description='The node pool ID.

This parameter is required.', example='c26607f52179f4472a0d9723e7595****', position='Body'),
  options?: string(name='options', description='The options that you want to configure.', example='"{\\"enableIptables\\":true,\\"quiet\\":true,\\"manageRuntime\\":true,\\"allowedClusterAddons\\":[\\"kube-proxy\\",\\"flannel\\",\\"coredns\\"]}"', position='Body'),
}

model EdgeClusterAddEdgeMachineResponseBody = {
  edgeMachineId?: string(name='edge_machine_id', description='The ID of the cloud-native box.', example='0f4bf70a-caff-4b26-a679-fb0188a1****'),
  requestId?: string(name='request_id', description='The request ID.', example='0adf3a23-6841-41e8-9f55-7b290216c980'),
}

model EdgeClusterAddEdgeMachineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EdgeClusterAddEdgeMachineResponseBody(name='body'),
}

/**
  * @deprecated OpenAPI EdgeClusterAddEdgeMachine is deprecated  * @param request  the request parameters of EdgeClusterAddEdgeMachine  EdgeClusterAddEdgeMachineRequest
  * @return EdgeClusterAddEdgeMachineResponse
 */
// Deprecated
async function edgeClusterAddEdgeMachine(request: EdgeClusterAddEdgeMachineRequest): EdgeClusterAddEdgeMachineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'EdgeClusterAddEdgeMachine', 'POST', '/clusters/[clusterid]/attachedgemachine/[edge_machineid]', 'json', false, 'json', request);
}

model FixNodePoolVulsRequest {
  clusterId: string(name='cluster_id', description='The cluster ID.

This parameter is required.', example='cf62854ac2130470897be7a27ed1f****', position='Path'),
  nodepoolId: string(name='nodepool_id', description='The node pool ID.

This parameter is required.', example='np31da1b38983f4511b490fc62108a****', position='Path'),
  autoRestart?: boolean(name='auto_restart', description='Specifies whether to allow the nodes to restart.', example='true', position='Body'),
  nodes?: [ string ](name='nodes', description='The names of the nodes to be patched.', position='Body'),
  rolloutPolicy?: {
    maxParallelism?: long(name='max_parallelism', description='The maximum concurrency for batch patching. Minimum value: 1. The maximum value equals the number of nodes in the node pool.', example='1'),
  }(name='rollout_policy', description='The batch patching policy.', position='Body'),
  vuls?: [ string ](name='vuls', description='The list of vulnerabilities.', position='Body'),
}

model FixNodePoolVulsResponseBody = {
  taskId?: string(name='task_id', description='The ID of the CVE patching task.', example='T-60fea8ad2e277f087900****'),
}

model FixNodePoolVulsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: FixNodePoolVulsResponseBody(name='body'),
}

/**
  * @description 1.  The Common Vulnerabilities and Exposures (CVE) patching feature is developed based on Security Center. To use this feature, you must purchase the Security Center Ultimate Edition that supports Container Service for Kubernetes (ACK).
  * 2.  ACK may need to restart nodes to patch certain vulnerabilities. ACK drains a node before the node restarts. Make sure that the ACK cluster has sufficient idle nodes to host the pods evicted from the trained nodes. For example, you can scale out a node pool before you patch vulnerabilities for the nodes in the node pool.
  * 3.  Security Center ensures the compatibility of CVE patches. We recommend that you check the compatibility of a CVE patch with your application before you install the patch. You can pause or cancel a CVE patching task anytime.
  * 4.  CVE patching is a progressive task that consists of multiple batches. After you pause or cancel a CVE patching task, ACK continues to process the dispatched batches. Only the batches that have not been dispatched are paused or canceled.
  * @param request  the request parameters of FixNodePoolVuls  FixNodePoolVulsRequest
  * @return FixNodePoolVulsResponse
 */
async function fixNodePoolVuls(request: FixNodePoolVulsRequest): FixNodePoolVulsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'FixNodePoolVuls', 'POST', '/clusters/{cluster_id}/nodepools/{nodepool_id}/vuls/fix', 'json', false, 'json', request);
}

model GetClusterAddonInstanceRequest {
  clusterId?: string(name='cluster_id', description='The ID of the cluster.', example='c02b3e03be10643e8a644a843ffcb****', position='Path'),
  instanceName?: string(name='instance_name', description='The name of the component instance.', example='ack-node-problem-detector', position='Path'),
}

model GetClusterAddonInstanceResponseBody = {
  config?: string(name='config', description='The custom configurations of the component.', example='{"sls_project_name":""}'),
  logging?: {
    capable?: boolean(name='capable', description='Indicates whether Simple Log Service is supported by the component.', example='false'),
    enabled?: boolean(name='enabled', description='Indicates whether Simple Log Service is enabled for the component.', example='false'),
    logProject?: string(name='log_project', description='The Simple Log Service project that is used to collect logs for the component.', example='my-log-project'),
    logstore?: string(name='logstore', description='The Simple Log Service Logstore that is used to collect logs for the component.', example='my-logstore'),
  }(name='logging', description='The status of Simple Log Service.'),
  name?: string(name='name', description='The name of the component instance.', example='ack-node-problem-detector'),
  state?: string(name='state', description='The status of the component. Valid values:

*   active: The component is installed.
*   updating: The component is being modified.
*   upgrading: The component is being updated.
*   deleting: The component is being uninstalled.', example='active'),
  version?: string(name='version', description='The version of the component instance.', example='1.2.16'),
}

model GetClusterAddonInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClusterAddonInstanceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetClusterAddonInstance  GetClusterAddonInstanceRequest
  * @return GetClusterAddonInstanceResponse
 */
async function getClusterAddonInstance(request: GetClusterAddonInstanceRequest): GetClusterAddonInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetClusterAddonInstance', 'GET', '/clusters/{cluster_id}/addon_instances/{instance_name}', 'json', false, 'json', request);
}

model GetClusterAuditProjectRequest {
  clusterid: string(name='clusterid', description='Cluster ID

This parameter is required.', example='cad1230511cbb4db4a488e58518******', position='Path'),
}

model GetClusterAuditProjectResponseBody = {
  auditEnabled?: boolean(name='audit_enabled', description='Indicates whether the cluster auditing feature is enabled for the cluster. 

* `true`: The cluster auditing feature is enabled for the cluster. 
* `false`: The cluster auditing feature is disabled for the cluster.', example='true'),
  slsProjectName?: string(name='sls_project_name', description='The SLS project in which the audit logs of the API server are stored.', example='k8s-log-cad1230511cbb4db4a488e58518******'),
}

model GetClusterAuditProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClusterAuditProjectResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetClusterAuditProject  GetClusterAuditProjectRequest
  * @return GetClusterAuditProjectResponse
 */
async function getClusterAuditProject(request: GetClusterAuditProjectRequest): GetClusterAuditProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetClusterAuditProject', 'GET', '/clusters/{clusterid}/audit', 'json', false, 'json', request);
}

model GetClusterCheckRequest {
  clusterId: string(name='cluster_id', description='The cluster ID.

This parameter is required.', example='ce0da5a1d627e4e9e9f96cae8ad07****', position='Path'),
  checkId: string(name='check_id', description='The ID of the cluster check task. You can call the [RunClusterCheck](https://help.aliyun.com/document_detail/2667902.html) operation to obtain the check_id.

This parameter is required.', example='1697100584236600453-ce0da5a1d627e4e9e9f96cae8ad07****-clustercheck-lboto', position='Path'),
}

model GetClusterCheckResponseBody = {
  checkId?: string(name='check_id', description='The ID of the cluster check task.', example='1697100584236600453-ce0da5a1d627e4e9e9f96cae8ad07****-clustercheck-lboto'),
  checkItems?: map[string][  map[string]any ](name='check_items', description='The list of check items.'),
  createdAt?: string(name='created_at', description='The time when the cluster check task was created.', example='2023-10-16T08:31:20.292030178Z'),
  finishedAt?: string(name='finished_at', description='The time when the cluster check task was completed.', example='2023-10-16T08:35:20.292030178Z'),
  message?: string(name='message', description='The message that indicates the status of the cluster check task.', example='task succeed'),
  status?: string(name='status', description='The status of the cluster check.', example='Succeeded'),
  type?: string(name='type', description='The check method.', example='ClusterUpgrade'),
}

model GetClusterCheckResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClusterCheckResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetClusterCheck  GetClusterCheckRequest
  * @return GetClusterCheckResponse
 */
async function getClusterCheck(request: GetClusterCheckRequest): GetClusterCheckResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetClusterCheck', 'GET', '/clusters/{cluster_id}/checks/{check_id}', 'json', false, 'json', request);
}

model GetClusterDiagnosisCheckItemsRequest {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='cb95aa626a47740afbf6aa099b650****', position='Path'),
  diagnosisId?: string(name='diagnosis_id', description='The diagnostic ID.', example='6f719f23098240818eb26fe3a37d****', position='Path'),
  language?: string(name='language', description='The query language.', example='zh_CN', position='Query'),
}

model GetClusterDiagnosisCheckItemsResponseBody = {
  checkItems?: [ 
    {
      desc?: string(name='desc', description='The description.', example='Check whether the node can access host dns service'),
      display?: string(name='display', description='The display name.', example='HostDNS'),
      group?: string(name='group', description='The name of the group to which the check item belongs.', example='Node'),
      level?: string(name='level', description='The severity level of the check result.

Valid values:

*   normal
*   warning
*   error', example='normal'),
      message?: string(name='message', description='The check result.', example='success'),
      name?: string(name='name', description='The name of the check item.', example='HostDNS'),
      refer?: string(name='refer', description='The reference value.', example='True'),
      value?: string(name='value', description='The value of the check item.', example='True'),
    }
  ](name='check_items', description='The check item.'),
  code?: string(name='code', description='The status code.', example='success'),
  isSuccess?: boolean(name='is_success', description='Indicates whether the check is successful.', example='true'),
  requestId?: string(name='request_id', description='The request ID.', example='1DFFD8C6-259E-582B-8B40-002C17DC****'),
}

model GetClusterDiagnosisCheckItemsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClusterDiagnosisCheckItemsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetClusterDiagnosisCheckItems  GetClusterDiagnosisCheckItemsRequest
  * @return GetClusterDiagnosisCheckItemsResponse
 */
async function getClusterDiagnosisCheckItems(request: GetClusterDiagnosisCheckItemsRequest): GetClusterDiagnosisCheckItemsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetClusterDiagnosisCheckItems', 'GET', '/clusters/{cluster_id}/diagnosis/{diagnosis_id}/check_items', 'json', false, 'json', request);
}

model GetClusterDiagnosisResultRequest {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='c8155823d057948c69a****', position='Path'),
  diagnosisId?: string(name='diagnosis_id', description='The diagnostic ID.', example='6f719f23098240818eb26fe3a37d****', position='Path'),
  language?: string(name='language', description='The query language.', example='zh_CN', position='Query'),
}

model GetClusterDiagnosisResultResponseBody = {
  code?: long(name='code', description='The code that indicates the diagnostic result. Valid values:

*   0: the diagnostic is completed.
*   1: the diagnostic failed.', example='0'),
  created?: string(name='created', description='The time when the diagnostic is initiated.', example='2024-05-28T11:29Z'),
  diagnosisId?: string(name='diagnosis_id', description='The diagnostic ID.', example='6cf6b62e334e4583bdfd26707516****'),
  finished?: string(name='finished', description='The time when the diagnostic is completed.', example='2024-05-28T11:29Z'),
  message?: string(name='message', description='The diagnostic status information.', example='success'),
  result?: string(name='result', description='The diagnostic result.', example='{"phase":5,"version":"20240101"}'),
  status?: long(name='status', description='The status of the diagnostic. Valid values:

*   0: The diagnostic is created.
*   1: The diagnostic is running.
*   2: The diagnostic is completed.', example='2'),
  target?: string(name='target', description='The diagnostic object.', example='{"name":"cn-hongkong.10.0.0.246"}'),
  type?: string(name='type', description='The type of the diagnostic.

Valid values:

*   node
*   ingress
*   cluster
*   memory
*   pod
*   service
*   network', example='Node'),
}

model GetClusterDiagnosisResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClusterDiagnosisResultResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetClusterDiagnosisResult  GetClusterDiagnosisResultRequest
  * @return GetClusterDiagnosisResultResponse
 */
async function getClusterDiagnosisResult(request: GetClusterDiagnosisResultRequest): GetClusterDiagnosisResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetClusterDiagnosisResult', 'GET', '/clusters/{cluster_id}/diagnosis/{diagnosis_id}/result', 'json', false, 'json', request);
}

model GetClusterInspectConfigRequest {
  clusterId: string(name='clusterId', description='The cluster ID.

This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
}

model GetClusterInspectConfigResponseBody = {
  disabledCheckItems?: [ string ](name='disabledCheckItems', description='The list of disabled inspection items.'),
  enabled?: boolean(name='enabled', description='Specifies whether to enable inspection.', example='true'),
  recurrence?: string(name='recurrence', description='The inspection schedule defined through the RFC5545 Recurrence Rule syntax. You must specify BYHOUR and BYMINUTE. Only FREQ=DAILY is supported. COUNT and UNTIL are not supported.', example='FREQ=DAILY;BYHOUR=10;BYMINUTE=15'),
  requestId?: string(name='requestId', description='The request ID.', example='49511F2D-D56A-5C24-B9AE-C8491E09B095'),
}

model GetClusterInspectConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClusterInspectConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetClusterInspectConfig  GetClusterInspectConfigRequest
  * @return GetClusterInspectConfigResponse
 */
async function getClusterInspectConfig(request: GetClusterInspectConfigRequest): GetClusterInspectConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetClusterInspectConfig', 'GET', '/clusters/{clusterId}/inspectConfig', 'json', false, 'json', request);
}

model GetClusterInspectReportDetailRequest {
  clusterId: string(name='clusterId', description='The ID of the cluster.

This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
  reportId: string(name='reportId', description='The ID of the inspection report.

This parameter is required.', example='782df89346054a0000562063a****', position='Path'),
  category?: string(name='category', description='The category of the inspection item. Valid values:

*   security: Security compliance
*   performance: Performance efficiency
*   stability: Business stability
*   limitation: Service limits
*   cost: Cost optimization', example='cost', position='Query'),
  enableFilter?: boolean(name='enableFilter', description='Inspection results filtering. If this parameter is set to true, only abnormal inspection items are returned.', example='true', position='Query'),
  language?: string(name='language', description='The query language.

*   zh_CN
*   en_US', example='zh_CN', position='Query'),
  level?: string(name='level', description='The level of the inspection item. Valid values:

*   advice: Suggestions
*   warning: Low severity
*   error: Medium severity
*   critical: High severity', example='error', position='Query'),
  maxResults?: int32(name='maxResults', description='The maximum number of entries per page. Maximum value: 50.', example='20', position='Query'),
  nextToken?: string(name='nextToken', description='The token that is used to display the returned tags on multiple pages.', example='bb41e2bcb47b747389dce6c0d2', position='Query'),
  targetType?: string(name='targetType', description='The type of the inspection object. Only items that meet the targetType parameter are returned.', example='NodePool', position='Query'),
}

model GetClusterInspectReportDetailResponseBody = {
  checkItemResults?: [ 
    {
      category?: string(name='category', description='The category of the inspection item. Valid values:

*   security: Security compliance
*   performance: Performance efficiency
*   stability: Business stability
*   limitation: Service limits
*   cost: Cost optimization', example='stability'),
      checkItemUid?: string(name='checkItemUid', description='The unique identifier of the inspection item.', example='APIServerClbInstanceStatus'),
      description?: string(name='description', description='The description of the inspection item.'),
      fix?: string(name='fix', description='The fixing suggestion.'),
      level?: string(name='level', description='The level of the inspection item. Valid values:

*   advice: Suggestions
*   warning: Low severity
*   error: Medium severity
*   critical: High severity', example='critical'),
      name?: string(name='name', description='The name of the inspection item.'),
      result?: string(name='result', description='The inspection results. Valid values:

*   true: The inspection item is abnormal.
*   false: The inspection item is normal.
*   disable: The inspection item is not enabled.', example='false'),
      targetType?: string(name='targetType', description='The resource type of the inspection object.', example='CLB'),
      targets?: [ string ](name='targets', description='The inspection objects.'),
    }
  ](name='checkItemResults', description='The results.'),
  endTime?: string(name='endTime', description='The completion time of the inspection report.', example='2024-12-18T19:41:12.778433+08:00'),
  nextToken?: string(name='nextToken', description='The token that is used to display the returned tags on multiple pages.', example='AK8uQQrxgFK8sbARvnCj6w9R3kPme4I3'),
  reportId?: string(name='reportId', description='The ID of the inspection report.', example='782df89346054a0000562063a****'),
  requestId?: string(name='requestId', description='The request ID.', example='49511F2D-D56A-5C24-B9AE-C8491E09B***'),
  startTime?: string(name='startTime', description='The start time of the inspection report.', example='2024-12-18T19:40:16.778333+08:00'),
  status?: string(name='status', description='The status of the inspection report. Valid values:

*   completed: The inspection report is generated.
*   running: The inspection report is generating.', example='completed'),
  summary?: {
    adviceCount?: int32(name='adviceCount', description='The number of check items whose inspection result is advice.', example='0'),
    code?: string(name='code', description='Check the status code of the inspection task.', example='warning'),
    errorCount?: int32(name='errorCount', description='The number of check items whose inspection result is error.', example='0'),
    normalCount?: int32(name='normalCount', description='The number of check items whose inspection result is normal.', example='10'),
    warnCount?: int32(name='warnCount', description='The number of check items whose inspection result is warning.', example='1'),
  }(name='summary', description='Overview of inspection reports.'),
}

model GetClusterInspectReportDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClusterInspectReportDetailResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetClusterInspectReportDetail  GetClusterInspectReportDetailRequest
  * @return GetClusterInspectReportDetailResponse
 */
async function getClusterInspectReportDetail(request: GetClusterInspectReportDetailRequest): GetClusterInspectReportDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetClusterInspectReportDetail', 'GET', '/clusters/{clusterId}/inspectReports/{reportId}', 'json', false, 'json', request);
}

model GetKubernetesTriggerRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c5cdf7e3938bc4f8eb0e44b21a80f****', position='Path'),
  name: string(name='Name', description='The application name.

This parameter is required.', example='web-server', position='Query'),
  namespace: string(name='Namespace', description='The namespace name.

This parameter is required.', example='default', position='Query'),
  type?: string(name='Type', description='The type of trigger. Valid values:

*   `deployment`: performs actions on Deployments.
*   `application`: performs actions on applications that are deployed in Application Center.

Default value: `deployment`.

If you do not set this parameter, triggers are not filtered by type.', example='deployment', position='Query'),
  action?: string(name='action', description='The action that the trigger performs. Set the value to redeploy.

`redeploy`: redeploys the resources specified by `project_id`.

If you do not specify this parameter, triggers are not filtered by action.', example='redeploy', position='Query'),
}

model GetKubernetesTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [ 
    {
      id?: string(name='id', description='The ID of the trigger.', example='1234'),
      name?: string(name='name', description='The name of the trigger.', example='test'),
      clusterId?: string(name='cluster_id', description='The ID of the associated cluster.', example='c259f563386444ebb8d7**'),
      projectId?: string(name='project_id', description='The name of the project.

The name consists of the namespace where the application is deployed and the name of the application. The format is `${namespace}/${name}`. Example: default/test-app.', example='default/test-app'),
      type?: string(name='type', description='The type of trigger.

Valid values:

*   `deployment`: performs actions on Deployments.
*   `application`: performs actions on applications that are deployed in Application Center.

Default value: `deployment`.', example='deployment'),
      action?: string(name='action', description='The action that the trigger performs. The value is set to redeploy.

`redeploy`: redeploys the resource specified by project_id.', example='redeploy'),
      token?: string(name='token', description='Token', example='eyJhbGci***'),
    }
  ](name='body'),
}

/**
  * @deprecated OpenAPI GetKubernetesTrigger is deprecated, please use CS::2015-12-15::DescribeTrigger instead.  * @param request  the request parameters of GetKubernetesTrigger  GetKubernetesTriggerRequest
  * @return GetKubernetesTriggerResponse
 */
// Deprecated
async function getKubernetesTrigger(request: GetKubernetesTriggerRequest): GetKubernetesTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetKubernetesTrigger', 'GET', '/triggers/{ClusterId}', 'array', false, 'json', request);
}

model GetUpgradeStatusRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c106f377e16f34eb1808d6b9362c9****', position='Path'),
}

model GetUpgradeStatusResponseBody = {
  errorMessage?: string(name='error_message', description='The error message returned during the update.', example='subject to actual return'),
  precheckReportId?: string(name='precheck_report_id', description='The ID of the precheck report.', example='be4c8eb72de94d459ea7ace7c811d119'),
  status?: string(name='status', description='The status of the update. Valid values:

*   `success`: The update is successful.
*   `fail`: The update failed.
*   `pause`: The update is paused.
*   `running`: The update is in progress.', example='running'),
  upgradeStep?: string(name='upgrade_step', description='The current phase of the update. Valid values:

*   `not_start`: The update is not started.
*   `prechecking`: The precheck is in progress.
*   `upgrading`: The cluster is being updated.
*   `pause`: The update is paused.
*   `success`: The update is successful.', example='prechecking'),
  upgradeTask?: {
    message?: string(name='message', description='The description of the update task.', example='subject to actual return'),
    status?: string(name='status', description='The status of the update task. Valid values:

*   `running`: The update task is being executed.
*   `Success`: The update task is successfully executed.
*   `Failed`: The update task failed.', example='running'),
  }(name='upgrade_task', description='The details of the update task.'),
}

model GetUpgradeStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUpgradeStatusResponseBody(name='body'),
}

/**
  * @deprecated OpenAPI GetUpgradeStatus is deprecated, please use CS::2015-12-15::DescribeTaskInfo instead.  * @param request  the request parameters of GetUpgradeStatus  GetUpgradeStatusRequest
  * @return GetUpgradeStatusResponse
 */
// Deprecated
async function getUpgradeStatus(request: GetUpgradeStatusRequest): GetUpgradeStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetUpgradeStatus', 'GET', '/api/v2/clusters/{ClusterId}/upgrade/status', 'json', false, 'json', request);
}

model GrantPermissionsRequest {
  uid: string(name='uid', description='The ID of the RAM user or RAM role whose permissions you want to update.

This parameter is required.', example='2367****', position='Path'),
  body?: [ 
    {
      cluster: string(name='cluster', description='The ID of the cluster on which you want to grant permissions to the RAM role or RAM role.

*   Set this parameter to an empty string if `role_type` is set to `all-clusters`.

This parameter is required.', example='c796c60***'),
      isCustom?: boolean(name='is_custom', description='Specifies whether to assign a custom role to the RAM user or RAM role. If you want to assign a custom role to the RAM user or RAM role, set `role_name` to the name of the custom role.', example='false'),
      isRamRole?: boolean(name='is_ram_role', description='Specifies whether to use a RAM role to grant permissions.', example='false'),
      namespace?: string(name='namespace', description='The namespace that you want to authorize the RAM user or RAM role to manage. This parameter is required only if you set role_type to namespace.', example='test'),
      roleName: string(name='role_name', description='The predefined role name. Valid values:

*   `admin`: administrator
*   `admin-view`: read-only administrator
*   `ops`: O\\&M engineer
*   `dev`: developer
*   `restricted`: restricted user
*   Custom role

Note:

*   You cannot grant namespace-level permissions to the `admin`, `admin-view`, and `ops` roles.
*   You cannot grant all cluster-level permissions to the `admin-view` role.

This parameter is required.', example='ops'),
      roleType: string(name='role_type', description='The authorization type. Valid values:

*   `cluster`: authorizes the RAM user or RAM role to manage the specified clusters.
*   `namespace`: authorizes the RAM user or RAM role to manage the specified namespaces.
*   `all-clusters`: authorizes the RAM user or RAM role to manage all clusters.

This parameter is required.', example='cluster'),
    }
  ](name='body', description='The request body.', position='Body'),
}

model GrantPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @description **Precautions**:
  * *   If you use a Resource Access Management (RAM) user to call the operation, make sure that the RAM user has the permissions to modify the permissions of other RAM users or RAM roles. Otherwise, the `StatusForbidden` or `ForbiddenGrantPermissions` error code is returned after you call the operation. For more information, see [Use a RAM user to grant RBAC permissions to other RAM users](https://help.aliyun.com/document_detail/119035.html).
  * *   If you update full permissions, the existing permissions of the RAM user or RAM role on the cluster are overwritten. You must specify all the permissions that you want to grant to the RAM user or RAM role in the request parameters when you call the operation.
  * @param request  the request parameters of GrantPermissions  GrantPermissionsRequest
  * @return GrantPermissionsResponse
 */
async function grantPermissions(request: GrantPermissionsRequest): GrantPermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GrantPermissions', 'POST', '/permissions/users/{uid}', 'none', false, 'json', request);
}

model InstallClusterAddonsRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
  body?: [ 
    {
      config?: string(name='config', description='The custom component settings that you want to use. The value is a JSON string.', example='{\\"IngressDashboardEnabled\\":\\"true\\",\\"sls_project_name\\":\\"your_sls_project_name\\"}"}'),
      name: string(name='name', description='The component name.

This parameter is required.', example='ags-metrics-collector'),
      version: string(name='version', description='The component version.

>  You can call the [DescribeClusterAddonsVersion](https://help.aliyun.com/document_detail/197434.html) operation to query the version of a component.

This parameter is required.', example='v1.0.0.2-cc3b2d6-aliyun'),
    }
  ](name='body', description='The request body.', example='ags-metrics-collector', position='Body'),
}

model InstallClusterAddonsResponseBody = {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='c82e6987e2961451182edacd74faf****'),
  requestId?: string(name='request_id', description='The request ID.', example='48BD70F6-A7E6-543D-9F23-08DEB764C92E'),
  taskId?: string(name='task_id', description='The task ID.', example='T-5a54309c80282e39ea00002f'),
}

model InstallClusterAddonsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallClusterAddonsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of InstallClusterAddons  InstallClusterAddonsRequest
  * @return InstallClusterAddonsResponse
 */
async function installClusterAddons(request: InstallClusterAddonsRequest): InstallClusterAddonsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InstallClusterAddons', 'POST', '/clusters/{ClusterId}/components/install', 'json', false, 'json', request);
}

model ListAddonsRequest {
  clusterId?: string(name='cluster_id', description='The cluster ID. If you specify a cluster ID, only components used in the specified cluster are queried. Other parameters are ignored.', example='c02b3e03be10643e8a644a843ffcb****', position='Query'),
  clusterSpec?: string(name='cluster_spec', description='The specifications of the cluster. If cluster_id is specified, this parameter is ignored. You must specify the region_id, cluster_type, profile, cluster_spec, and cluster_version parameters at the same time.', example='ack.pro.small', position='Query'),
  clusterType?: string(name='cluster_type', description='The type of the cluster. If cluster_id is specified, this parameter is ignored. You must specify the region_id, cluster_type, profile, cluster_spec, and cluster_version parameters at the same time.', example='ManagedKubernetes', position='Query'),
  clusterVersion?: string(name='cluster_version', description='The version of the cluster. If cluster_id is specified, this parameter is ignored. You must specify the region_id, cluster_type, profile, cluster_spec, and cluster_version parameters at the same time.', example='1.26.3-aliyun.1', position='Query'),
  profile?: string(name='profile', description='The subtype of the cluster. If cluster_id is specified, this parameter is ignored. You must specify the region_id, cluster_type, profile, cluster_spec, and cluster_version parameters at the same time.', example='Default', position='Query'),
  regionId?: string(name='region_id', description='The region of the cluster. If cluster_id is specified, this parameter is ignored. You must specify the region_id, cluster_type, profile, cluster_spec, and cluster_version parameters at the same time.', example='cn-hangzhou', position='Query'),
}

model ListAddonsResponseBody = {
  addons?: [ 
    {
      architecture?: [ string ](name='architecture', description='Architectures supported by the component. Valid values:

*   amd64
*   arm64'),
      category?: string(name='category', description='The category of the component.', example='monitor'),
      configSchema?: string(name='config_schema', description='The schema of the custom parameters of the component.', example='{}'),
      installByDefault?: boolean(name='install_by_default', description='Indicates whether the component is automatically installed by default.', example='false'),
      managed?: boolean(name='managed', description='Indicates whether the component is fully managed.', example='false'),
      name?: string(name='name', description='The component name.', example='arms-prometheus'),
      supportedActions?: [ string ](name='supported_actions', description='Operations supported by the component. Valid values:

*   Install
*   Upgrade
*   Modify
*   Uninstall'),
      version?: string(name='version', description='The version number.', example='1.1.9'),
    }
  ](name='addons', description='The list of available components.'),
}

model ListAddonsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAddonsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListAddons  ListAddonsRequest
  * @return ListAddonsResponse
 */
async function listAddons(request: ListAddonsRequest): ListAddonsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAddons', 'GET', '/addons', 'json', false, 'json', request);
}

model ListClusterAddonInstancesRequest {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='c02b3e03be10643e8a644a843ffcb****', position='Path'),
}

model ListClusterAddonInstancesResponseBody = {
  addons?: [ 
    {
      name?: string(name='name', description='The component name.', example='coredns'),
      state?: string(name='state', description='The status of the component. Valid values:

*   active: The component is installed.
*   updating: The component is being modified.
*   upgrading: The component is being updated.
*   deleting: The component is being uninstalled.', example='active'),
      version?: string(name='version', description='The version of the component.', example='v1.9.3.10-7dfca203-aliyun'),
    }
  ](name='addons', description='A list of components that are installed in the cluster.'),
}

model ListClusterAddonInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClusterAddonInstancesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListClusterAddonInstances  ListClusterAddonInstancesRequest
  * @return ListClusterAddonInstancesResponse
 */
async function listClusterAddonInstances(request: ListClusterAddonInstancesRequest): ListClusterAddonInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListClusterAddonInstances', 'GET', '/clusters/{cluster_id}/addon_instances', 'json', false, 'json', request);
}

model ListClusterChecksRequest {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='ce0da5a1d627e4e9e9f96cae8ad07****', position='Path'),
  target?: string(name='target', description='The targets to check.', example='ngw-bp19ay6nnvd4cexxxx', position='Query'),
  type?: string(name='type', description='The check method.', example='ClusterUpgrade', position='Query'),
}

model ListClusterChecksResponseBody = {
  checks?: [ 
    {
      checkId?: string(name='check_id', description='The ID of the cluster check task.', example='1697100584236600453-ce0da5a1d627e4e9e9f96cae8ad07****-clustercheck-lboto'),
      createdAt?: string(name='created_at', description='The time when the cluster check task was created.', example='2023-10-16T08:31:20.292030178Z'),
      finishedAt?: string(name='finished_at', description='The time when the cluster check task was completed.', example='2023-10-16T08:35:20.292030178Z'),
      message?: string(name='message', description='The message that indicates the status of the cluster check task.', example='task succeed'),
      status?: string(name='status', description='The status of the cluster check.', example='Succeeded'),
      type?: string(name='type', description='The check method.', example='ClusterUpgrade'),
    }
  ](name='checks', description='The list of check items.'),
}

model ListClusterChecksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClusterChecksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListClusterChecks  ListClusterChecksRequest
  * @return ListClusterChecksResponse
 */
async function listClusterChecks(request: ListClusterChecksRequest): ListClusterChecksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListClusterChecks', 'GET', '/clusters/{cluster_id}/checks', 'json', false, 'json', request);
}

model ListClusterInspectReportsRequest {
  clusterId: string(name='clusterId', description='This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
  maxResults?: int32(name='maxResults', example='20', position='Query'),
  nextToken?: string(name='nextToken', example='AK8uQQrxgFKsI3OiS5TbhUQ9R3kPme4I3', position='Query'),
}

model ListClusterInspectReportsResponseBody = {
  nextToken?: string(name='nextToken', example='405b99e5411f9a4e7148506e45'),
  reports?: [ 
    {
      endTime?: string(name='endTime', example='2024-12-18T19:40:16.778333+08:00'),
      reportId?: string(name='reportId', example='782df89346054a0000562063a6****'),
      startTime?: string(name='startTime', example='2024-12-18T19:40:16.778333+08:00'),
      status?: string(name='status', example='completed'),
      summary?: {
        adviceCount?: int32(name='adviceCount', example='0'),
        code?: string(name='code', example='warning'),
        errorCount?: int32(name='errorCount', example='0'),
        normalCount?: int32(name='normalCount', example='1'),
        warnCount?: int32(name='warnCount', example='0'),
      }(name='summary'),
    }
  ](name='reports'),
  requestId?: string(name='requestId', example='49511F2D-D56A-5C24-B9AE-C8491E09B***'),
}

model ListClusterInspectReportsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClusterInspectReportsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListClusterInspectReports  ListClusterInspectReportsRequest
  * @return ListClusterInspectReportsResponse
 */
async function listClusterInspectReports(request: ListClusterInspectReportsRequest): ListClusterInspectReportsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListClusterInspectReports', 'GET', '/clusters/{clusterId}/inspectReports', 'json', false, 'json', request);
}

model ListClusterKubeconfigStatesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='c82e6987e2961451182edacd74faf****', position='Path'),
  pageNumber?: int32(name='pageNumber', description='The page number.

*   Valid values: ≥ 1.
*   Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='pageSize', description='The number of entries per page.

*   Valid values: 10 to 50.
*   Default value: 10', example='10', position='Query'),
}

model ListClusterKubeconfigStatesResponseBody = {
  page?: {
    pageNumber?: int32(name='page_number', description='The page number.', example='1'),
    pageSize?: int32(name='page_size', description='The number of entries per page.', example='10'),
    totalCount?: int32(name='total_count', description='The total number of entries returned.', example='5'),
  }(name='page', description='The pagination information.'),
  states?: [ 
    {
      accountDisplayName?: string(name='account_display_name', description='The displayed name or role name of the RAM user.', example='tom'),
      accountId?: string(name='account_id', description='The ID of an Alibaba Cloud account, RAM user, or RAM role.', example='22855*****************'),
      accountName?: string(name='account_name', description='The logon name or role name of the RAM user.', example='tom'),
      accountState?: string(name='account_state', description='The status of the account.

*   Active: The account is active.
*   InActive: The account is locked.
*   Deleted: The account is deleted.', example='Active'),
      accountType?: string(name='account_type', description='The type of the account.

*   RootAccount: Alibaba Cloud account.
*   RamUser: RAM user.
*   RamRole: RAM role.', example='RamUser'),
      certExpireTime?: string(name='cert_expire_time', description='The expiration time of the client certificate for the kubeconfig file.', example='2027-07-15T01:32:20Z'),
      certState?: string(name='cert_state', description='The status of the client certificate for the kubeconfig file.

*   Unexpired: The certificate is not expired.
*   Expired: The certificate is expired.
*   Unknown: The status of the certificate is unknown.', example='Expired'),
      revokable?: boolean(name='revokable', description='Indicates whether the client certificate for the kubeconfig file can be revoked.', example='true'),
    }
  ](name='states', description='The status list of the kubeconfig files associated with the cluster.'),
}

model ListClusterKubeconfigStatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClusterKubeconfigStatesResponseBody(name='body'),
}

/**
  * @description > - To call this operation, make sure that you have ram:ListUsers and ram:ListRoles permissions.
  * > - To call this operation, make sure that you have the AliyunCSFullAccess permissions.
  * @param request  the request parameters of ListClusterKubeconfigStates  ListClusterKubeconfigStatesRequest
  * @return ListClusterKubeconfigStatesResponse
 */
async function listClusterKubeconfigStates(request: ListClusterKubeconfigStatesRequest): ListClusterKubeconfigStatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListClusterKubeconfigStates', 'GET', '/clusters/{ClusterId}/kubeconfig/states', 'json', false, 'json', request);
}

model ListOperationPlansRequest {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='c29ced64b3dfe4f33b57ca0aa9f68****', position='Query'),
  type?: string(name='type', description='The operation plan type.', example='cluster_upgrade', position='Query'),
}

model ListOperationPlansResponseBody = {
  plans?: [ 
    {
      clusterId?: string(name='cluster_id', description='The cluster ID.', example='c29ced64b3dfe4f33b57ca0aa9f68****'),
      created?: string(name='created', description='The time when the operation plan was created.', example='2023-11-21T20:01:22+08:00'),
      endTime?: string(name='end_time', description='The expected end time of the plan.', example='2023-11-22T18:00:00+08:00'),
      planId?: string(name='plan_id', description='The operation plan ID.', example='P-655c9c127e0e6603ef00****'),
      startTime?: string(name='start_time', description='The expected start time of the plan.', example='2023-11-22T15:18:00+08:00'),
      state?: string(name='state', description='The plan status. Valid values:

*   scheduled
*   Canceled', example='scheduled'),
      targetId?: string(name='target_id', description='The target ID.', example='c29ced64b3dfe4f33b57ca0aa9f68****'),
      targetType?: string(name='target_type', description='The target type.', example='cluster'),
      taskId?: string(name='task_id', description='The ID of the task generated by the execution plan.', example='T-6764d027be846d01310006b1'),
      type?: string(name='type', description='The plan type. Valid values:

*   cluster_upgrade', example='cluster_upgrade'),
    }
  ](name='plans', description='The list of auto O\\&M execution plans.'),
}

model ListOperationPlansResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOperationPlansResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListOperationPlans  ListOperationPlansRequest
  * @return ListOperationPlansResponse
 */
async function listOperationPlans(request: ListOperationPlansRequest): ListOperationPlansResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListOperationPlans', 'GET', '/operation/plans', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='next_token', description='The pagination token that is used in the next request to retrieve a new page of results.', example='***', position='Query'),
  regionId: string(name='region_id', description='The region ID.

This parameter is required.', example='cn-beijing', position='Query'),
  resourceIds: [ string ](name='resource_ids', description='The list of cluster IDs.

This parameter is required.', example='["xxxxx","xxxxxx"]', shrink='json', position='Query'),
  resourceType: string(name='resource_type', description='The resource type. Set the value to `CLUSTER`.

This parameter is required.', example='CLUSTER', position='Query'),
  tags?: [
    Tag
  ](name='tags', description='The list of labels that you want to query. You can specify up to 20 labels.', example='[{\\"key\\":\\"env\\",\\"value\\",\\"dev\\"},{\\"key\\":\\"dev\\", \\"value\\":\\"IT\\"}]', shrink='json', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='next_token', description='The pagination token that is used in the next request to retrieve a new page of results.', example='c374bf4864448****'),
  requestId?: string(name='request_id', description='The request ID.', example='E368C761-F8F6-4A36-9B58-BD53D5CD0CEB'),
  tagResources?: {
    tagResource?: [ 
      {
        resourceId?: string(name='resource_id', description='The ID of the resource.', example='i-xxx'),
        resourceType?: string(name='resource_type', description='The type of the resource. For more information, see [Labels](https://help.aliyun.com/document_detail/110425.html).', example='CLUSTER'),
        tagKey?: string(name='tag_key', description='The key of the label.', example='ack.aliyun.com'),
        tagValue?: string(name='tag_value', description='The value of the label.', example='c71cf3d796c374bf48644482cb0c3****'),
      }
    ](name='tag_resource', description='The resource and label.'),
  }(name='tag_resources', description='The details of the queried labels and resources.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListTagResources  ListTagResourcesRequest
  * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTagResources', 'GET', '/tags', 'json', false, 'json', request);
}

model ListUserKubeConfigStatesRequest {
  uid?: string(name='Uid', description='The ID of the specified Resource Access Management (RAM) user or RAM role within the Alibaba Cloud account.', example='2xxxxxxxxxxxxxxxxxx', position='Path'),
  pageNumber?: int32(name='page_number', description='The page number.

*   Valid values: ≥ 1.
*   Default value: 1.', example='2', position='Query'),
  pageSize?: int32(name='page_size', description='The number of entries per page.

*   Value values: 1 to 100.
*   Default value: 50.', example='10', position='Query'),
}

model ListUserKubeConfigStatesResponseBody = {
  page?: {
    pageNumber?: int32(name='page_number', description='The page number of the returned page.', example='1'),
    pageSize?: int32(name='page_size', description='The number of entries per page.', example='10'),
    totalCount?: int32(name='total_count', description='The total number of entries returned.', example='100'),
  }(name='page', description='The pagination information.'),
  states?: [ 
    {
      certExpireTime?: string(name='cert_expire_time', description='The expiration date of the certificate used in a kubeconfig file. Format: the UTC time in the RFC3339 format.', example='2026-11-30T07:41:50Z'),
      certState?: string(name='cert_state', description='The current status of the certificate used in a kubeconfig file. Valid values:

*   Expired: The certificate is expired.
*   Unexpired: The certificate is not expired.
*   Unissued: The certificate is not issued.
*   Unknown: The status of the certificate is unknown.
*   Removed: The certificate is removed. An issue record is found for the certificate.', example='Unissued'),
      clusterId?: string(name='cluster_id', description='The cluster ID.', example='c5b5e80b0b64a4bf6939d2d8fbbc5****'),
      clusterName?: string(name='cluster_name', description='The name of the cluster.

The name must be 1 to 63 characters in length, and can contain digits, underscores (_), and hyphens (-). The name must start with a letter or number.', example='cluster-demo'),
      clusterState?: string(name='cluster_state', description='The status of the cluster. Valid values:

*   `initial`: The cluster is being created.
*   `failed`: The cluster failed to be created.
*   `running`: The cluster is running.
*   `updating`: The cluster is being upgraded.
*   `updating_failed`: The cluster failed to be updated.
*   `scaling`: The cluster is being scaled.
*   `stopped`: The cluster is stopped.
*   `deleting`: The cluster is being deleted.
*   `deleted`: The cluster is deleted.
*   `delete_failed`: The cluster failed to be deleted.', example='running'),
    }
  ](name='states', description='The status of the kubeconfig files.'),
}

model ListUserKubeConfigStatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserKubeConfigStatesResponseBody(name='body'),
}

/**
  * @description >  To call this operation, make sure that you have the AliyunCSFullAccess permissions.
  * @param request  the request parameters of ListUserKubeConfigStates  ListUserKubeConfigStatesRequest
  * @return ListUserKubeConfigStatesResponse
 */
async function listUserKubeConfigStates(request: ListUserKubeConfigStatesRequest): ListUserKubeConfigStatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListUserKubeConfigStates', 'GET', '/users/{Uid}/kubeconfig/states', 'json', false, 'json', request);
}

model MigrateClusterRequest {
  clusterId: string(name='cluster_id', description='The cluster ID.

This parameter is required.', example='c21e0591548ba4c10bdb535d6572b****', position='Path'),
  ossBucketEndpoint?: string(name='oss_bucket_endpoint', description='The endpoint of the OSS bucket.', example='*******.oss-cn-hangzhou.aliyuncs.com', position='Body'),
  ossBucketName?: string(name='oss_bucket_name', description='The name of the Object Storage Service (OSS) bucket.', example='bucket-****', position='Body'),
}

model MigrateClusterResponseBody = {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='c8155823d057948c69a****'),
  requestId?: string(name='request_id', description='The request ID.', example='20758A-585D-4A41-A9B2-28DA8F4F534F'),
  taskId?: string(name='task_id', description='The task ID.', example='T-62ccd14aacb8db06ca00****'),
}

model MigrateClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MigrateClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of MigrateCluster  MigrateClusterRequest
  * @return MigrateClusterResponse
 */
async function migrateCluster(request: MigrateClusterRequest): MigrateClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'MigrateCluster', 'POST', '/clusters/{cluster_id}/migrate', 'json', false, 'json', request);
}

model ModifyClusterRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='cb95aa626a47740afbf6aa099b65****', position='Path'),
  accessControlList?: [ string ](name='access_control_list', description='The network access control list (ACL) of the SLB instance associated with the API server if the cluster is a registered cluster.', position='Body'),
  apiServerCustomCertSans?: {
    action?: string(name='action', description='Specifies whether to overwrite or add SANs. Valid values:

*   overwrite: overwrites SANs.
*   append: adds SANs.', example='append'),
    subjectAlternativeNames?: [ string ](name='subject_alternative_names', description='The list of SANs.'),
  }(name='api_server_custom_cert_sans', description='The custom subject alternative names (SANs) for the API server certificate to accept requests from specified IP addresses or domain names. This parameter is available only for ACK managed clusters.', position='Body'),
  apiServerEip?: boolean(name='api_server_eip', description='Specifies whether to associate an elastic IP address (EIP) with the cluster. This EIP is used to enable access to the API server over the Internet. Valid values:

*   `true`: associates an EIP with the cluster.
*   `false`: does not associate an EIP with the cluster.', example='true', position='Body'),
  apiServerEipId?: string(name='api_server_eip_id', description='The ID of the EIP that you want to associate with the API server of the cluster. This parameter takes effect when `api_server_eip` is set to `true`.', example='eip-wz9fnasl6dsfhmvci****', position='Body'),
  clusterName?: string(name='cluster_name', description='The cluster name.

The cluster name must be 1 to 63 characters in length, and can contain digits, letters, and hyphens (-). The cluster name cannot start with a hyphen (-).', example='cluster-new-name', position='Body'),
  controlPlaneConfig?: {
    autoRenew?: boolean(name='auto_renew', description='Specifies whether to enable auto-renewal for control plane nodes. This parameter takes effect only when `charge_type` is set to `PrePaid`. Valid values:

*   `true`: enables auto-renewal.
*   `false`: disables auto-renewal.

Default value: `false`', example='true'),
    autoRenewPeriod?: long(name='auto_renew_period', description='The auto-renewal period of control plane nodes. Valid values: 1, 2, 3, 6, and 12.

Default value: 1.', example='1'),
    chargeType?: string(name='charge_type', description='The billing method of control plane nodes. Valid values:

*   `PrePaid`: subscription.
*   `PostPaid`: pay-as-you-go.

Default value: `PostPaid`.', example='PrePaid'),
    cloudMonitorFlags?: boolean(name='cloud_monitor_flags', description='Specifies whether to install the CloudMonitor agent. Valid values:

*   `true`: installs the CloudMonitor agent.
*   `false`: does not install the CloudMonitor agent.', example='true'),
    cpuPolicy?: string(name='cpu_policy', description='The CPU management policy of nodes in the node pool. The following policies are supported if the Kubernetes version of the cluster is 1.12.6 or later:

*   `static`: allows pods with specific resource characteristics on the node to be granted with enhanced CPU affinity and exclusivity.
*   `none`: specifies that the default CPU affinity is used.

Default value: `none`.', example='none'),
    deploymentsetId?: string(name='deploymentset_id', description='The ID of the deployment set.', example='ds-bp10b35imuam5amw****'),
    imageId?: string(name='image_id', description='The custom image ID. You must configure this parameter if you use a custom image.', example='aliyun_3_x64_20G_alibase_20240819.vhd'),
    imageType?: string(name='image_type', description='The type of the OS image. Valid values:

*   `AliyunLinux3`: Alibaba Cloud Linux 3.
*   `Custom`: the custom image.', example='AliyunLinux3'),
    instanceTypes?: [ string ](name='instance_types', description='The type of instance. For more information, see [Overview of ECS instance families](https://help.aliyun.com/document_detail/25378.html).'),
    keyPair?: string(name='key_pair', description='The name of the key pair. You must configure either this parameter or the `login_password` parameter.', example='ack'),
    loginPassword?: string(name='login_password', description='The password for SSH logon. You must configure either this parameter or the `key_pair` parameter. The password must be 8 to 30 characters in length, and must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. To log on with a password, you must specify this parameter during the scale-out.', example='Ack@2000.'),
    nodePortRange?: string(name='node_port_range', description='The node port range.', example='30000-32767'),
    period?: long(name='period', description='The subscription duration of the instance. This parameter takes effect and is required only when `charge_type` is set to `PrePaid`.

If `PeriodUnit=Month` is specified, the valid values are 1, 2, 3, 6, 12, 24, 36, 48, and 60.', example='1'),
    periodUnit?: string(name='period_unit', description='The billing cycle of control plane nodes. This parameter takes effect only when `instance_charge_type` is set to `PrePaid`.

Set the value to `Month`.', example='Month'),
    runtime?: string(name='runtime', description='The type of the container runtime. Valid values:

*   `containerd`: supports all Kubernetes versions. We recommend that you set the parameter to this value.

Default value: containerd.', example='containerd'),
    securityHardeningOs?: boolean(name='security_hardening_os', description='Specifies whether to enable Alibaba Cloud Linux Security Hardening. Valid values:

*   `true`: enables Alibaba Cloud Linux Security Hardening.
*   `false`: disables Alibaba Cloud Linux Security Hardening.

Default value: `false`', example='true'),
    size?: long(name='size', description='The number of control plane nodes. If you want to scale out the control plane in an ACK dedicated cluster, set this parameter to the desired number of nodes. This parameter must be greater than the current number of nodes.', example='5'),
    socEnabled?: boolean(name='soc_enabled', description='Specifies whether to enable Multi-Level Protection Scheme (MLPS) security hardening. For more information, see [ACK security hardening based on MLPS](https://help.aliyun.com/document_detail/196148.html).

Valid values:

*   `true`: enables MLPS security hardening.
*   `false`: disables MLPS security hardening.

Default value: `false`.', example='false'),
    systemDiskBurstingEnabled?: boolean(name='system_disk_bursting_enabled', description='Specifies whether to enable the burst feature for the system disk. Valid values:

*   `true`: enables the burst feature.
*   `false`: disables the burst feature.

This parameter is effective only when `system_disk_category` is set to `cloud_auto`. For more information, see [ESSD AutoPL disks](https://help.aliyun.com/document_detail/368372.html).', example='true'),
    systemDiskCategory?: string(name='system_disk_category', description='The category of the system disk for nodes. Valid values:

*   `cloud`: basic disk.
*   `cloud_efficiency`: ultra disk.
*   `cloud_ssd`: standard SSD.
*   `cloud_essd`: Enterprise ESSD (ESSD).
*   `cloud_auto`: ESSD AutoPL disk.
*   `cloud_essd_entry`: ESSD Entry disk.', example='cloud_essd'),
    systemDiskPerformanceLevel?: string(name='system_disk_performance_level', description='The performance level (PL) of the system disk that you want to use for the node. This parameter is effective only for ESSDs. This parameter is related to the disk size. For more information, see [ESSDs](https://help.aliyun.com/document_detail/122389.html).', example='PL1'),
    systemDiskProvisionedIops?: long(name='system_disk_provisioned_iops', description='The preset read/write input/output operations per second (IOPS) of the system disk. Valid values: 0 to min{50,000, 1,000 × Capacity - Baseline IOPS}. Baseline IOPS = min{1,800 + 50 × Capacity, 50,000}.

This parameter is effective only when `system_disk_category` is set to `cloud_auto`. For more information, see [ESSD AutoPL disks](https://help.aliyun.com/document_detail/368372.html).', example='1000'),
    systemDiskSize?: long(name='system_disk_size', description='The type of the system disk. Valid values: [40,500]. Unit: GiB.', example='120'),
    systemDiskSnapshotPolicyId?: string(name='system_disk_snapshot_policy_id', description='The ID of the automatic snapshot policy applied to the node system disk.', example='sp-2zej1nogjvovnz4z****'),
  }(name='control_plane_config', description='The control plane configurations of an ACK dedicated cluster.', position='Body'),
  deletionProtection?: boolean(name='deletion_protection', description='Specifies whether to enable cluster deletion protection. If you enable this option, the cluster cannot be deleted in the console or by calling API operations. Valid values:

*   `true`: enables cluster deletion protection.
*   `false`: disables cluster deletion protection.

Default value: `false`', example='true', position='Body'),
  enableRrsa?: boolean(name='enable_rrsa', description='Specifies whether to enable the RAM Roles for Service Accounts (RRSA) feature. This parameter is available only for ACK managed clusters. Valid values:

*   `true`: enables the RRSA feature.
*   `false`: disables the RRSA feature.', example='true', position='Body'),
  ingressDomainRebinding?: boolean(name='ingress_domain_rebinding', description='Specifies whether to remap the test domain name of the cluster. Valid values:

*   `true`: remaps the test domain name of the cluster.
*   `false`: does not remap the test domain name of the cluster.

Default value: `false`', example='true', position='Body'),
  ingressLoadbalancerId?: string(name='ingress_loadbalancer_id', description='The ID of the Server Load Balancer (SLB) instance of the cluster to be modified.', example='lb-wz97kes8tnndkpodw****', position='Body'),
  instanceDeletionProtection?: boolean(name='instance_deletion_protection', description='Specifies whether to enable instance deletion protection. If you enable this option, the instance cannot be deleted in the console or by calling API operations. Valid values:

*   `true`: enables instance deletion protection.
*   `false`: disables instance deletion protection.

Default value: `false`', example='true', position='Body'),
  maintenanceWindow?: MaintenanceWindow(name='maintenance_window', description='The cluster maintenance window. This feature takes effect only for ACK Pro clusters.', position='Body'),
  operationPolicy?: {
    clusterAutoUpgrade?: {
      channel?: string(name='channel', description='The frequency of auto cluster update. For more information, see [Update frequency](https://help.aliyun.com/document_detail/2712866.html).

Valid values:

*   patch: the latest patch version.
*   stables: the second-latest minor version.
*   rapid: the latest minor version.', example='patch'),
      enabled?: boolean(name='enabled', description='Specifies whether to enable automatic update.', example='true'),
    }(name='cluster_auto_upgrade', description='The configurations of automatic update.'),
  }(name='operation_policy', description='The automatic O\\&M policy of the cluster.', position='Body'),
  resourceGroupId?: string(name='resource_group_id', description='The resource group ID of the cluster.', example='rg-acfmyvw3wjm****', position='Body'),
  securityGroupId?: string(name='security_group_id', description='The ID of the security group for the control plane. 

- If block rules are configured in the security group, ensure the security group rules allow traffic for protocols and ports required by the cluster. For recommended security group rules, see [Configure and manage security groups for an ACK cluster](https://www.alibabacloud.com/help/en/ack/ack-managed-and-ack-dedicated/user-guide/configure-security-group-rules-to-enforce-access-control-on-ack-clusters?spm=a2c63.p38356.help-menu-85222.d_2_0_4_3.43e35d09s8oSlR).

- For non-ACK dedicated clusters: 
  - During security group updates, the cluster control plane and managed components (e.g., terway-controlplane) will restart briefly. Perform this operation during off-peak hours.
  - After updating the control plane security group, the Elastic Network Interfaces (ENIs) used by the control plane and managed components will automatically join the new security group.

- For ACK dedicated clusters:
   - After updating the control plane security group, newly scaled-out master nodes will automatically apply the new security group. Existing control plane nodes remain unaffected.', example='sg-bp1h6rk3pgct2a08***', position='Body'),
  systemEventsLogging?: {
    enabled?: boolean(name='enabled', description='Specifies whether to enable system event storage.', example='true'),
    loggingProject?: string(name='logging_project', description='The name of the Simple Log Service project that stores system events.', example='k8s-log-cb95aa626a47740afbf6aa099b65****'),
  }(name='system_events_logging', description='The storage configurations of system events.', position='Body'),
  timezone?: string(name='timezone', description='The time zone configuration for the cluster.

- After modifying the time zone, cluster inspection configurations will adopt the new time zone.

- For ACK managed clusters:
   - During time zone updates, the cluster control plane and managed components (e.g., terway-controlplane) will restart briefly. Perform this operation during off-peak hours.
   - After updating the time zone:
      - Newly scaled-out nodes will automatically apply the new time zone.
      - Existing nodes remain unaffected. Reset the node to apply changes to existing nodes.

- For ACK dedicated clusters:
   - After updating the time zone:
      - Newly scaled-out nodes (including control plane nodes) automatically apply the new time zone.
      - Existing nodes (including control plane nodes) remain unaffected. Reset the node to apply changes to existing nodes.
      - For control plane nodes, perform a scale-out followed by a scale-in to apply the new time zone to all control plane nodes.', example='Asia/Shanghai', position='Body'),
  vswitchIds?: [ string ](name='vswitch_ids', description='The vSwitches of the control plane. This parameter can be used to change the vSwitches of the control plane in an ACK managed cluster. Take note of the following items:

*   This parameter overwrites the existing configuration. You must specify all vSwitches of the control plane.
*   The control plane components restarts during the change process. Exercise caution when you perform this operation.
*   Ensure that all security groups of the cluster, including the security groups of the control plane, all node pools, and container network, are allowed to access the CIDR blocks of the new vSwitches. This ensures that the nodes and containers can connect to the API server.
*   If the new vSwitches of the control plane are configured with an ACL, ensure that the ACL allows communication between the new vSwitches and CIDR blocks such as those of the cluster nodes and the container network.', position='Body'),
}

model ModifyClusterResponseBody = {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='cb95aa626a47740afbf6aa09****'),
  requestId?: string(name='request_id', description='The request ID.', example='687C5BAA-D103-4993-884B-C35E4314****'),
  taskId?: string(name='task_id', description='The task ID.', example='T-5a54309c80282e39ea00****'),
}

model ModifyClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyCluster  ModifyClusterRequest
  * @return ModifyClusterResponse
 */
async function modifyCluster(request: ModifyClusterRequest): ModifyClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyCluster', 'PUT', '/api/v2/clusters/{ClusterId}', 'json', false, 'json', request);
}

model ModifyClusterAddonRequest {
  clusterId: string(name='cluster_id', description='The cluster ID.

This parameter is required.', example='c71d616e629ff40d5b42d7bb87770****', position='Path'),
  componentId: string(name='component_id', description='The component ID.

This parameter is required.', example='coredns', position='Path'),
  config?: string(name='config', description='The custom parameter settings that you want to use.', example='{"CpuRequest":"800m"}', position='Body'),
}

model ModifyClusterAddonResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @description You can call this API operation to modify the component parameters of an ACK Basic cluster or the control plane parameters of an ACK Pro cluster:
  * *   To view the component parameters of an ACK Basic cluster, call the DescribeClusterAddonMetadata API operation. For more information, see [Query the metadata of a cluster component](https://help.aliyun.com/document_detail/2667944.html).
  * *   To view the control plane parameters of an ACK Pro cluster, see [Customize the control plane parameters of an ACK Pro cluster](https://help.aliyun.com/document_detail/199588.html).
  * After you call this operation, the component may be redeployed and restarted. We recommend that you assess the impact before you call this operation.
  * @param request  the request parameters of ModifyClusterAddon  ModifyClusterAddonRequest
  * @return ModifyClusterAddonResponse
 */
async function modifyClusterAddon(request: ModifyClusterAddonRequest): ModifyClusterAddonResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyClusterAddon', 'POST', '/clusters/{cluster_id}/components/{component_id}/config', 'none', false, 'json', request);
}

model ModifyClusterConfigurationRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='cc0f87de0b8fb403f86e10e204f83****', position='Path'),
  customizeConfig?: [ 
    {
      configs?: [ 
        {
          key?: string(name='key', description='The name of the configuration item.', example='MaxRequestsInflight'),
          value?: string(name='value', description='The value of the configuration item.', example='100'),
        }
      ](name='configs', description='The custom configurations.'),
      name?: string(name='name', description='The name of the component.', example='kube-apiserver'),
    }
  ](name='customize_config', description='The custom configurations.', position='Body'),
}

model ModifyClusterConfigurationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @deprecated OpenAPI ModifyClusterConfiguration is deprecated, please use CS::2015-12-15::ModifyClusterAddon instead.  * @param request  the request parameters of ModifyClusterConfiguration  ModifyClusterConfigurationRequest
  * @return ModifyClusterConfigurationResponse
 */
// Deprecated
async function modifyClusterConfiguration(request: ModifyClusterConfigurationRequest): ModifyClusterConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyClusterConfiguration', 'PUT', '/clusters/{ClusterId}/configuration', 'none', false, 'json', request);
}

model ModifyClusterNodePoolRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c23421cfa74454bc8b37163fd19af****', position='Path'),
  nodepoolId: string(name='NodepoolId', description='The node pool ID.

This parameter is required.', example='p31da1b38983f4511b490fc62108a****', position='Path'),
  autoScaling?: {
    eipBandwidth?: long(name='eip_bandwidth', description='The maximum bandwidth of the EIP.', example='5', deprecated='true'),
    eipInternetChargeType?: string(name='eip_internet_charge_type', description='The billing method of the EIP. Valid values:

*   `PayByBandwidth`: pay-by-bandwidth
*   `PayByTraffic`: pay-by-data-transfer

Default value: `PayByBandwidth`.', example='PayByBandwidth', deprecated='true'),
    enable?: boolean(name='enable', description='Specifies whether to enable auto scaling. Valid values:

*   `true`: enables auto scaling for the node pool.
*   `false`: disables auto scaling for the node pool. If you set this parameter to false, other parameters in `auto_scaling` do not take effect.

Default value: `false`', example='true'),
    isBondEip?: boolean(name='is_bond_eip', description='Specifies whether to associate an elastic IP address (EIP) with the node pool. Valid values:

*   `true`: An EIP is associated with the node pool.
*   `false`: No EIP is associated with the node pool.

Default value: `false`', example='true', deprecated='true'),
    maxInstances?: long(name='max_instances', description='The maximum number of instances.', example='10'),
    minInstances?: long(name='min_instances', description='The minimum number of instances.', example='2'),
    type?: string(name='type', description='The instance type that is used for auto scaling. Valid values:

*   `cpu`: regular instance
*   `gpu`: GPU-accelerated instance.
*   `gpushare`: shared GPU-accelerated instance.
*   `spot`: preemptible instance.

Default value: `cpu`.', example='cpu', deprecated='true'),
  }(name='auto_scaling', description='The configurations about auto scaling.', position='Body'),
  concurrency?: boolean(name='concurrency', description='Specifies whether concurrency is supported.', example='true', position='Body'),
  kubernetesConfig?: {
    cmsEnabled?: boolean(name='cms_enabled', description='Specifies whether to install the CloudMonitor agent on ECS nodes. After the CloudMonitor agent is installed on ECS nodes, you can view monitoring information about the instances in the CloudMonitor console. We recommend that you install the CloudMonitor agent. Valid values:

*   `true`: installs the CloudMonitor agent on ECS nodes.
*   `false`: does not install the CloudMonitor agent on ECS nodes.

Default value: `false`', example='true'),
    cpuPolicy?: string(name='cpu_policy', description='The CPU management policy of nodes in the node pool. The following policies are supported if the Kubernetes version of the cluster is 1.12.6 or later:

*   `static`: allows pods with specific resource characteristics on the node to be granted with enhanced CPU affinity and exclusivity
*   `none`: specifies that the default CPU affinity is used

Default value: `none`.', example='none'),
    labels?: [
      Tag
    ](name='labels', description='The labels of the nodes in the node pool. You can add labels to the nodes in the cluster. You must add the label based on the following rules:

*   A label is a case-sensitive key-value pair. You can add up to 20 labels.
*   The key must be unique and cannot exceed 64 characters in length. The value can be empty and cannot exceed 128 characters in length. Keys and values cannot start with `aliyun`, `acs:`, `https://`, or `http://`. For more information, see [Labels and Selectors](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set).'),
    preUserData?: string(name='pre_user_data', description='The user-defined script that is executed before nodes are initialized. For more information, see [Prepare user data](https://help.aliyun.com/document_detail/49121.html).', example='IyEvdXNyL2Jpbi9iYXNoCmVjaG8gIkhlbGxvIEFDSyEi'),
    runtime?: string(name='runtime', description='The name of the container runtime.', example='docker'),
    runtimeVersion?: string(name='runtime_version', description='The version of the container runtime.', example='19.03.5'),
    taints?: [
      Taint
    ](name='taints', description='The configurations of node taints.'),
    unschedulable?: boolean(name='unschedulable', description='Specifies whether the nodes are unschedulable after a scale-out activity is performed.', example='false'),
    userData?: string(name='user_data', description='The user-defined script that is executed after nodes are initialized. For more information, see [Prepare user data](https://help.aliyun.com/document_detail/49121.html).', example='IyEvdXNyL2Jpbi9iYXNoCmVjaG8gIkhlbGxvIEFDSyEi'),
  }(name='kubernetes_config', description='The configurations of the cluster in which the node pool is deployed.', position='Body'),
  management?: {
    autoRepair?: boolean(name='auto_repair', description='Specifies whether to enable auto repair. This parameter takes effect only when you specify `enable=true`. Valid values:

*   `true`: enables auto repair.
*   `false`: disables auto repair.

Default value: `true`.', example='true'),
    autoRepairPolicy?: {
      restartNode?: boolean(name='restart_node', description='Specifies whether ACK is allowed to automatically restart nodes after repairing the nodes. Valid values:

*   `true`: allows node restart.
*   `false`: does not allow node restart.', example='true'),
    }(name='auto_repair_policy', description='The auto node repair policy.'),
    autoUpgrade?: boolean(name='auto_upgrade', description='Indicates whether auto update is enabled. Valid values:

*   `true`: enables auto update.
*   `false`: disables auto update.', example='true'),
    autoUpgradePolicy?: {
      autoUpgradeKubelet?: boolean(name='auto_upgrade_kubelet', description='Specifies whether ACK is allowed to automatically update the kubelet. Valid values:

*   `true`: yes.
*   `false`: no.', example='true'),
      autoUpgradeOs?: boolean(name='auto_upgrade_os', description='Specifies whether ACK is allowed to automatically update the operating system. This parameter takes effect only when you specify `auto_upgrade=true`. Valid values:

*   `true`: allows the auto upgrade of the OS.
*   `false`: does not allow the auto upgrade of the OS.

Default value: `false`.', example='false'),
      autoUpgradeRuntime?: boolean(name='auto_upgrade_runtime', description='Specifies whether ACK is allowed to automatically update the runtime. This parameter takes effect only when you specify `auto_upgrade=true`. Valid values:

*   `true`: allows the auto upgrade of the runtime.
*   `false`: does not allow the auto upgrade of the runtime.

Default value: `false`.', example='false'),
    }(name='auto_upgrade_policy', description='The auto update policy.'),
    autoVulFix?: boolean(name='auto_vul_fix', description='Specifies whether ACK is allowed to automatically patch CVE vulnerabilities. Valid values:

*   `true`: eanbles auto CVE patching.
*   `true`: disables auto CVE patching.', example='true'),
    autoVulFixPolicy?: {
      restartNode?: boolean(name='restart_node', description='Specifies whether ACK is allowed to automatically restart nodes after repairing the nodes. Valid values:

*   `true`: allows node restart.
*   `false`: does not allow node restart.', example='true'),
      vulLevel?: string(name='vul_level', description='The severity levels of vulnerabilities that ACK is allowed to automatically patch. Multiple severity levels are separated by commas (,).', example='asap,nntf'),
    }(name='auto_vul_fix_policy', description='The auto CVE patching policy.'),
    enable?: boolean(name='enable', description='Specifies whether to enable the managed node pool feature. Valid values:

*   `true`: enables the managed node pool feature.
*   `false`: disables the managed node pool feature. Other parameters in this section take effect only when `enable=true` is specified.

Default value: `false`', example='true'),
    upgradeConfig?: {
      autoUpgrade?: boolean(name='auto_upgrade', description='Specifies whether to enable auto update. Valid values:

*   true: enables auto update.
*   false: disables auto update.

Default value: `true`.', example='true', deprecated='true'),
      maxUnavailable?: long(name='max_unavailable', description='The maximum number of nodes that can be in the Unavailable state.

Valid values: 1 to 1000.

Default value: 1.', example='1'),
      surge?: long(name='surge', description='The number of additional nodes that are temporarily added to the node pool during an auto update. Additional nodes are used to host the workloads of nodes that are being updated.

>  We recommend that you set the number of additional nodes to a value that does not exceed the current number of existing nodes.', example='5'),
      surgePercentage?: long(name='surge_percentage', description='The percentage of additional nodes to the nodes in the node pool. You must set this parameter or `surge`.', example='0'),
    }(name='upgrade_config', description='The configuration of auto update. The configuration takes effect only when `enable=true` is specified.', deprecated='true'),
  }(name='management', description='The configuration of the managed node pool feature.', position='Body'),
  nodepoolInfo?: {
    name?: string(name='name', description='The name of a node pool.

The name must be 1 to 63 characters in length, and can contain digits, letters, and hyphens (-). It cannot start with a hyphen (-).', example='default-nodepool'),
    resourceGroupId?: string(name='resource_group_id', description='The resource group ID to which the instance belongs.', example='rg-acfmyvw3wjm****'),
  }(name='nodepool_info', description='The configuration of the node pool.', position='Body'),
  scalingGroup?: {
    autoRenew?: boolean(name='auto_renew', description='Specifies whether to enable auto-renewal for the nodes in the node pool. This parameter takes effect only when you set `instance_charge_type` to `PrePaid`. Valid values:

*   `true`: enables auto-renewal.
*   `false`: disables auto-renewal.

Default value: `false`', example='true'),
    autoRenewPeriod?: long(name='auto_renew_period', description='The auto-renewal period. Valid value:

*   Valid values when PeriodUnit is set to Week: 1, 2, and 3.
*   Valid values when PeriodUnit is set to Month: 1, 2, 3, 6, 12, 24, 36, 48, and 60.

Default value: 1.', example='1'),
    compensateWithOnDemand?: boolean(name='compensate_with_on_demand', description='Specifies whether to automatically create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created due to reasons such as the cost or insufficient inventory. This parameter takes effect only when you set `multi_az_policy` to `COST_OPTIMIZED`. Valid values:

*   `true`: automatically creates pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created
*   `false`: does not create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created.', example='true'),
    dataDisks?: [
      DataDisk
    ](name='data_disks', description='The configurations of the data disks that are mounted to nodes in the node pool. Valid values: 0 to 10. You can mount at most 10 data disks to the nodes in the node pool.'),
    deploymentsetId?: string(name='deploymentset_id'),
    desiredSize?: long(name='desired_size', description='The expected number of nodes in the node pool.', example='2'),
    imageId?: string(name='image_id', description='The custom image ID. You can call the `DescribeKubernetesVersionMetadata` operation to query the supported images. By default, the latest image is used.', example='aliyun_2_1903_x64_20G_alibase_20200904.vhd'),
    imageType?: string(name='image_type', description='The type of operating system distribution that you want to use. We recommend that you use this parameter to specify the node operating system. Valid values:

*   `AliyunLinux`: Alibaba Cloud Linux 2.
*   `AliyunLinuxSecurity`: Alibaba Cloud Linux 2 (UEFI).
*   `AliyunLinux3`: Alibaba Cloud Linux 3
*   `AliyunLinux3Arm64`: Alibaba Cloud Linux 3 (ARM).
*   `AliyunLinux3Security`: Alibaba Cloud Linux 3 (UEFI).
*   `CentOS`: CentOS.
*   `Windows`: Windows.
*   `WindowsCore`: Windows Core.
*   `ContainerOS`: ContainerOS.
*   `AliyunLinux3ContainerOptimized`: Alibaba Cloud Linux 3 Container-optimized image.', example='AliyunLinux'),
    instanceChargeType?: string(name='instance_charge_type', description='The billing method of nodes in the node pool. Valid values:

*   `PrePaid`: subscription
*   `PostPaid`: pay-as-you-go

Default value: `PostPaid`', example='PostPaid'),
    instancePatterns?: [
      InstancePatterns
    ](name='instance_patterns', description='The instance attributes.'),
    instanceTypes?: [ string ](name='instance_types', description='The instance types. You can specify multiple instance types. A node is assigned the instance type from the first instance type of the list until the node is created. The instance type that is used to create the node varies based on the actual instance stock.'),
    internetChargeType?: string(name='internet_charge_type', description='The billing method of the public IP address. Valid values:

*   `PayByBandwidth`: pay-by-bandwidth
*   `PayByTraffic`: pay-by-data-transfer', example='PayByBandwidth'),
    internetMaxBandwidthOut?: long(name='internet_max_bandwidth_out', description='The maximum outbound bandwidth of the public IP address of the node. Unit: Mbit/s. Valid values: 1 to 100.', example='5'),
    keyPair?: string(name='key_pair', description='The name of the key pair. You must specify this parameter or `login_password`. You must specify the `key_pair` parameter if the node pool is a managed node pool.', example='pro-nodepool'),
    loginPassword?: string(name='login_password', description='The password for SSH logon. You must specify this parameter or `key_pair`. The password must be 8 to 30 characters in length, and must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.', example='Hello1234'),
    multiAzPolicy?: string(name='multi_az_policy', description='The ECS instance scaling policy for the multi-zone scaling group. Valid values:

*   `PRIORITY`: The scaling group is scaled based on the VSwitchIds.N parameter. If an ECS instance cannot be created in the zone in which the vSwitch that has the highest priority resides, Auto Scaling creates the ECS instance in the zone in which the vSwitch that has the next highest priority resides.

*   `COST_OPTIMIZED`: ECS instances are created based on the vCPU unit price in ascending order. Preemptible instances are preferably created when preemptible instance types are specified in the scaling configurations. You can specify `CompensateWithOnDemand` to specify whether to automatically create pay-as-you-go instances when preemptible instances cannot be created due to insufficient resources.

    **

    **Note** `COST_OPTIMIZED` is valid only when multiple instance types are specified or at least one preemptible instance type is specified.

*   `BALANCE`: ECS instances are evenly distributed across multiple zones specified by the scaling group. If ECS instances become imbalanced among multiple zones due to the insufficient inventory, you can call the `RebalanceInstances` operation of Auto Scaling to balance the instance distribution among zones. For more information, see [RebalanceInstances](https://help.aliyun.com/document_detail/71516.html).

Default value: `PRIORITY`.', example='BALANCE'),
    onDemandBaseCapacity?: long(name='on_demand_base_capacity', description='The minimum number of pay-as-you-go instances that must be kept in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is smaller than the value of this parameter, Auto Scaling preferably creates pay-as-you-go instances.', example='0'),
    onDemandPercentageAboveBaseCapacity?: long(name='on_demand_percentage_above_base_capacity', description='The percentage of pay-as-you-go instances among the extra instances that exceed the number specified by `on_demand_base_capacity`. Valid values: 0 to 100.', example='20'),
    period?: long(name='period', description='The subscription duration of the nodes in the node pool. This parameter takes effect and is required only when you set `instance_charge_type` to `PrePaid`.

Valid values if `period_unit` is set to Month: 1, 2, 3, 6, 12, 24, 36, 48, and 60.', example='1'),
    periodUnit?: string(name='period_unit', description='The billing cycle of the nodes in the node pool. This parameter is required if you set `instance_charge_type` to `PrePaid`. Valid values:

The billing cycle is measured only in months.

Default value: `Month`.', example='Month'),
    platform?: string(name='platform', description='The OS platform. Valid values:

*   `AliyunLinux`
*   `CentOS`
*   `Windows`
*   `WindowsCore`', example='AliyunLinux', deprecated='true'),
    privatePoolOptions?: {
      id?: string(name='id', description='The private node pool ID.', example='eap-bp67acfmxazb4****'),
      matchCriteria?: string(name='match_criteria', description='The type of private node pool. This parameter specifies the type of private node pool that you want to use to create instances. A private pool is generated when an elasticity assurance or a capacity reservation takes effect. The system selects a private pool to start instances. Valid values:

*   `Open`: uses an open private pool. The system selects an open private pool to start instances. If no matching open private pools are available, the resources in the public pool are used.
*   `Target`: uses a specified private pool. The system uses the resources of the specified private pool to start instances. If the specified private pool is unavailable, instances cannot be started.
*   `None`: does not use private pools. The resources of private node pools are not used to launch instances.', example='Open'),
    }(name='private_pool_options', description='The configuration of the private node pool.'),
    rdsInstances?: [ string ](name='rds_instances', description='The ApsaraDB RDS instances.'),
    scalingPolicy?: string(name='scaling_policy', description='The scaling mode of the scaling group. Valid values:

*   `release`: the standard mode. ECS instances are created and released based on resource usage.
*   `recycle`: the swift mode. ECS instances are created, stopped, or started during scaling events. This reduces the time required for the next scale-out event. When the instance is stopped, you are charged only for the storage service. This does not apply to ECS instances that are attached to local disks.', example='release'),
    securityGroupIds?: [ string ](name='security_group_ids'),
    spotInstancePools?: long(name='spot_instance_pools', description='The number of instance types that are available for creating preemptible instances. Auto Scaling creates preemptible instances of multiple instance types that are available at the lowest cost. Valid values: 1 to 10.', example='5'),
    spotInstanceRemedy?: boolean(name='spot_instance_remedy', description='Indicates whether preemptible instances can be supplemented. If the supplementation of preemptible instances is enabled, when the scaling group receives a system message that a preemptible instance is to be reclaimed, the scaling group attempts to create a new instance to replace this instance. Valid values:

*   `true`: supplements preemptible instances.
*   `false`: does not supplement preemptible instances.', example='false'),
    spotPriceLimit?: [ 
      {
        instanceType?: string(name='instance_type', description='The price cap of a preemptible instance.', example='ecs.c6.large'),
        priceLimit?: string(name='price_limit', description='The maximum bid price of a preemptible instance.

Unit: USD/hour.', example='0.39'),
      }
    ](name='spot_price_limit', description='The bid configurations of preemptible instances.'),
    spotStrategy?: string(name='spot_strategy', description='The bidding policy of preemptible instances. Valid values:

*   `NoSpot`: non-preemptible instance.
*   `SpotWithPriceLimit`: specifies the highest bid.
*   `SpotAsPriceGo`: automatically submits bids based on the up-to-date market price.

For more information, see [Create a preemptible elastic container instance](https://help.aliyun.com/document_detail/157759.html).', example='SpotWithPriceLimit'),
    systemDiskBurstingEnabled?: boolean(name='system_disk_bursting_enabled', description='Specifies whether to enable Burst for the system disk when the disk type is cloud_auto.', example='true'),
    systemDiskCategories?: [ string ](name='system_disk_categories', description='The system disk types. The system attempts to create system disks of a disk type with a lower priority if the disk type with a higher priority is unavailable. Valid values: cloud: disk. cloud_efficiency: Ultra disk. cloud_ssd: Standard SSD. cloud_essd: Enterprise SSD (ESSD).'),
    systemDiskCategory?: string(name='system_disk_category', description='The type of system disk. Valid values:

*   `cloud_efficiency`: ultra disk
*   `cloud_ssd`: standard SSD

Default value: `cloud_ssd`', example='cloud_efficiency'),
    systemDiskEncryptAlgorithm?: string(name='system_disk_encrypt_algorithm', description='The encryption algorithm that is used by the system disk. The value is aes-256.', example='aes-256'),
    systemDiskEncrypted?: boolean(name='system_disk_encrypted', description='Indicates whether the system disk is encrypted. Valid values: true: encrypts the system disk. false: does not encrypt the system disk.', example='false'),
    systemDiskKmsKeyId?: string(name='system_disk_kms_key_id', description='The ID of the Key Management Service (KMS) key that is used to encrypt the system disk.', example='0e478b7a-4262-4802-b8cb-00d3fb40****'),
    systemDiskPerformanceLevel?: string(name='system_disk_performance_level', description='The performance level (PL) of the system disk that you want to use for the node. This parameter takes effect only for ESSDs. You can specify a higher PL if you increase the size of the data disk. For more information, see [ESSDs](https://help.aliyun.com/document_detail/122389.html).', example='PL1'),
    systemDiskProvisionedIops?: long(name='system_disk_provisioned_iops', description='The predefined read and write IOPS of the system disk when the disk type is cloud_auto.', example='1000'),
    systemDiskSize?: long(name='system_disk_size', description='The size of the system disk in GiB.

Valid values: 20 to 500.

The value of this parameter must be at least 20 and greater than or equal to the size of the image.

Default value: the greater value between 40 and the image size.', example='120'),
    tags?: [
      Tag
    ](name='tags', description='The tags that you want to add only to ECS instances.

The label key must be unique and cannot exceed 128 characters in length. The label key and value cannot start with aliyun or acs: and cannot contain https:// or http://.'),
    vswitchIds?: [ string ](name='vswitch_ids', description='The IDs of vSwitches. You can specify 1 to 20 vSwitches.

>  To ensure high availability, we recommend that you select vSwitches that reside in different zones.'),
  }(name='scaling_group', description='The configuration of the scaling group.', position='Body'),
  teeConfig?: {
    teeEnable?: boolean(name='tee_enable', description='Specifies whether to enable confidential computing for the cluster. Valid values:

*   `true`: enables confidential computing for the cluster.
*   `false`: disables confidential computing for the cluster.

Default value: `false`.', example='false'),
  }(name='tee_config', description='The configurations about confidential computing for the cluster.', position='Body'),
  updateNodes?: boolean(name='update_nodes', description='Specifies whether to update node information, such as labels and taints.', example='true', position='Body'),
}

model ModifyClusterNodePoolResponseBody = {
  nodepoolId?: string(name='nodepool_id', description='The node pool ID.', example='np737c3ac1ac684703b9e10673aa2c****'),
  requestId?: string(name='request_id', description='The ID of the request.', example='687C5BAA-D103-4993-884B-C35E4314****'),
  taskId?: string(name='task_id', description='The task ID.', example='T-5fd211e924e1d00787000293'),
}

model ModifyClusterNodePoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyClusterNodePoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyClusterNodePool  ModifyClusterNodePoolRequest
  * @return ModifyClusterNodePoolResponse
 */
async function modifyClusterNodePool(request: ModifyClusterNodePoolRequest): ModifyClusterNodePoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyClusterNodePool', 'PUT', '/clusters/{ClusterId}/nodepools/{NodepoolId}', 'json', false, 'json', request);
}

model ModifyClusterTagsRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

This parameter is required.', example='c106f377e16f34eb1808d6b9362c9****', position='Path'),
  body?: [
    Tag
  ](name='body', description='The data of the tags that you want to modify.', position='Body'),
}

model ModifyClusterTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of ModifyClusterTags  ModifyClusterTagsRequest
  * @return ModifyClusterTagsResponse
 */
async function modifyClusterTags(request: ModifyClusterTagsRequest): ModifyClusterTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyClusterTags', 'POST', '/clusters/{ClusterId}/tags', 'none', false, 'json', request);
}

model ModifyNodePoolNodeConfigRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

This parameter is required.', example='c23421cfa74454bc8b37163fd19af****', position='Path'),
  nodepoolId: string(name='NodepoolId', description='The node pool ID.

This parameter is required.', example='np8d8c9c2cd0f64e89884f82a5fbcd****', position='Path'),
  containerdConfig?: ContainerdConfig(name='containerd_config', position='Body'),
  kubeletConfig?: KubeletConfig(name='kubelet_config', description='The kubelet configuration.', position='Body'),
  osConfig?: {
    sysctl?: map[string]any(name='sysctl', description='Configuration for sysctl kernel parameters.'),
  }(name='os_config', description='The OS configuration.', position='Body'),
  rollingPolicy?: {
    maxParallelism?: long(name='max_parallelism', description='The maximum number of unavailable nodes.', example='3'),
  }(name='rolling_policy', description='The rolling update configuration.', position='Body'),
}

model ModifyNodePoolNodeConfigResponseBody = {
  nodepoolId?: string(name='nodepool_id', description='The node pool ID.', example='np737c3ac1ac684703b9e10673aa2c****'),
  requestId?: string(name='request_id', description='The request ID.', example='D7631D83-6E98-1949-B665-766A62xxxxxx'),
  taskId?: string(name='task_id', description='The task ID.', example='T-5fd211e924e1d00787xxxxxx'),
}

model ModifyNodePoolNodeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyNodePoolNodeConfigResponseBody(name='body'),
}

/**
  * @description >  Container Service for Kubernetes (ACK) allows you to modify the kubelet configuration of nodes in a node pool. After you modify the kubelet configuration, the new configuration immediately takes effect on existing nodes in the node pool and is automatically applied to newly added nodes.
  * @param request  the request parameters of ModifyNodePoolNodeConfig  ModifyNodePoolNodeConfigRequest
  * @return ModifyNodePoolNodeConfigResponse
 */
async function modifyNodePoolNodeConfig(request: ModifyNodePoolNodeConfigRequest): ModifyNodePoolNodeConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyNodePoolNodeConfig', 'PUT', '/clusters/{ClusterId}/nodepools/{NodepoolId}/node_config', 'json', false, 'json', request);
}

model ModifyPolicyInstanceRequest {
  clusterId: string(name='cluster_id', description='The cluster ID.

This parameter is required.', example='c8155823d057948c69a****', position='Path'),
  policyName: string(name='policy_name', description='The name of the policy.

This parameter is required.', example='ACKAllowedRepos', position='Path'),
  action?: string(name='action', description='The action of the policy. Valid values:

*   `deny`: Deployments that match the policy are denied.
*   `warn`: Alerts are generated for deployments that match the policy.', example='deny', position='Body'),
  instanceName?: string(name='instance_name', description='The ID of the policy instance.', example='allowed-repos-cbhhb', position='Body'),
  namespaces?: [ string ](name='namespaces', description='The namespaces to which the policy is applied. The policy is applied to all namespaces if this parameter is left empty.', position='Body'),
  parameters?: map[string]any(name='parameters', description='The parameters of the policy instance. For more information, see [Predefined security policies of ACK](https://help.aliyun.com/document_detail/359819.html).', example='"restrictedNamespaces": [ "test" ]', position='Body'),
}

model ModifyPolicyInstanceResponseBody = {
  instances?: [ string ](name='instances', description='The list of policy instances that are updated.'),
}

model ModifyPolicyInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyPolicyInstanceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyPolicyInstance  ModifyPolicyInstanceRequest
  * @return ModifyPolicyInstanceResponse
 */
async function modifyPolicyInstance(request: ModifyPolicyInstanceRequest): ModifyPolicyInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyPolicyInstance', 'PUT', '/clusters/{cluster_id}/policies/{policy_name}', 'json', false, 'json', request);
}

model OpenAckServiceRequest {
  type?: string(name='type', description='The type of service that you want to activate. Valid values:

*   `propayasgo`: ACK clusters (including ACK managed clusters and ACK dedicated clusters), ACK Serverless clusters, and registered clusters.
*   `edgepayasgo`: ACK Edge clusters.', example='propayasgo', position='Query'),
}

model OpenAckServiceResponseBody = {
  orderId?: string(name='order_id', description='The ID of the order.', example='2067*******0374'),
  requestId?: string(name='request_id', description='The request ID.', example='20758A-585D-4A41-A9B2-28DA8F4F534F'),
}

model OpenAckServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenAckServiceResponseBody(name='body'),
}

/**
  * @description *   You can activate ACK by using Alibaba Cloud accounts.
  * *   To activate ACK by using RAM users, you need to grant the AdministratorAccess permission to the RAM users.
  * @param request  the request parameters of OpenAckService  OpenAckServiceRequest
  * @return OpenAckServiceResponse
 */
async function openAckService(request: OpenAckServiceRequest): OpenAckServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'OpenAckService', 'POST', '/service/open', 'json', false, 'json', request);
}

model PauseClusterUpgradeRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
}

model PauseClusterUpgradeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @deprecated OpenAPI PauseClusterUpgrade is deprecated, please use CS::2015-12-15::PauseTask instead.  * @param request  the request parameters of PauseClusterUpgrade  PauseClusterUpgradeRequest
  * @return PauseClusterUpgradeResponse
 */
// Deprecated
async function pauseClusterUpgrade(request: PauseClusterUpgradeRequest): PauseClusterUpgradeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PauseClusterUpgrade', 'POST', '/api/v2/clusters/{ClusterId}/upgrade/pause', 'none', false, 'json', request);
}

model PauseComponentUpgradeRequest {
  clusterid: string(name='clusterid', description='The cluster ID.

This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
  componentid: string(name='componentid', description='The component ID.

This parameter is required.', example='metric-server', position='Path'),
}

model PauseComponentUpgradeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @deprecated OpenAPI PauseComponentUpgrade is deprecated, please use CS::2015-12-15::PauseTask instead.  * @param request  the request parameters of PauseComponentUpgrade  PauseComponentUpgradeRequest
  * @return PauseComponentUpgradeResponse
 */
// Deprecated
async function pauseComponentUpgrade(request: PauseComponentUpgradeRequest): PauseComponentUpgradeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PauseComponentUpgrade', 'POST', '/clusters/{clusterid}/components/{componentid}/pause', 'none', false, 'json', request);
}

model PauseTaskRequest {
  taskId: string(name='task_id', description='The task ID.

This parameter is required.', example='T-62a944794ee141074400****', position='Path'),
}

model PauseTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of PauseTask  PauseTaskRequest
  * @return PauseTaskResponse
 */
async function pauseTask(request: PauseTaskRequest): PauseTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PauseTask', 'POST', '/tasks/{task_id}/pause', 'none', false, 'json', request);
}

model RemoveClusterNodesRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
  drainNode?: boolean(name='drain_node', description='Specifies whether to evict all pods from the nodes that you want to remove.', position='Body'),
  nodes: [ string ](name='nodes', description='The list of nodes to be removed.

This parameter is required.', position='Body'),
  releaseNode?: boolean(name='release_node', description='Specifies whether to release the Elastic Compute Service (ECS) instances when they are removed from the cluster.', position='Body'),
}

model RemoveClusterNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @deprecated OpenAPI RemoveClusterNodes is deprecated, please use CS::2015-12-15::RemoveNodePoolNodes instead.  * @description ****
  * *   When you remove a node, the pods that run on the node are migrated to other nodes. This may cause service interruptions. We recommend that you remove nodes during off-peak hours.
  * *   Unknown errors may occur when you remove nodes. Before you remove nodes, back up the data on the nodes.
  * *   Nodes remain in the Unschedulable state when they are being removed.
  * *   You can remove only worker nodes. You cannot remove master nodes.
  * @param request  the request parameters of RemoveClusterNodes  RemoveClusterNodesRequest
  * @return RemoveClusterNodesResponse
 */
// Deprecated
async function removeClusterNodes(request: RemoveClusterNodesRequest): RemoveClusterNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RemoveClusterNodes', 'POST', '/api/v2/clusters/{ClusterId}/nodes/remove', 'none', false, 'json', request);
}

model RemoveNodePoolNodesRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

This parameter is required.', example='c23421cfa74454bc8b37163fd19af****', position='Path'),
  nodepoolId: string(name='NodepoolId', description='The node pool ID.

This parameter is required.', example='np97de2cfb1ba042398dd8f5504c94****', position='Path'),
  concurrency?: boolean(name='concurrency', description='Whether to remove concurrently.', example='false', position='Query'),
  drainNode?: boolean(name='drain_node', description='Specifies whether to drain the nodes that you want to remove. Valid values:

*   true: drain the nodes that you want to remove.
*   false: do not drain the nodes that you want to remove.', example='true', position='Query'),
  instanceIds?: [ string ](name='instance_ids', description='A list of instances that you want to remove.', shrink='json', position='Query'),
  nodes?: [ string ](name='nodes', description='This parameter is deprecated.

A list of nodes that you want to remove.

>  This parameter is deprecated. Use instance_ids instead.', deprecated='true', shrink='json', position='Query'),
  releaseNode?: boolean(name='release_node', description='Specifies whether to release the nodes after they are removed. Valid values:

*   true: release the nodes after they are removed.
*   false: do not release the nodes after they are removed.', example='true', position='Query'),
}

model RemoveNodePoolNodesResponseBody = {
  requestId?: string(name='request_id', description='The request ID.', example='A9891419-D125-4D89-AFCA-68846675E2F7'),
  taskId?: string(name='task_id', description='The task ID.', example='T-62a944794ee141074400****'),
}

model RemoveNodePoolNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveNodePoolNodesResponseBody(name='body'),
}

/**
  * @description *   When you remove a node, the pods on the node are migrated to other nodes. This may cause service interruptions. We recommend that you remove nodes during off-peak hours.
  * *   The operation may have unexpected risks. Back up the data before you perform this operation.
  * *   Nodes remain in the Unschedulable state when they are being removed.
  * *   The system removes only worker nodes. It does not remove master nodes.
  * *   Even if you set the `release_node` parameter to `true`, subscription nodes are not released. You must release the subscription nodes in the [ECS console](https://ecs.console.aliyun.com/) after you remove the nodes.
  * @param request  the request parameters of RemoveNodePoolNodes  RemoveNodePoolNodesRequest
  * @return RemoveNodePoolNodesResponse
 */
async function removeNodePoolNodes(request: RemoveNodePoolNodesRequest): RemoveNodePoolNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RemoveNodePoolNodes', 'DELETE', '/clusters/{ClusterId}/nodepools/{NodepoolId}/nodes', 'json', false, 'json', request);
}

model RepairClusterNodePoolRequest {
  clusterId: string(name='cluster_id', description='The ID of the cluster.

This parameter is required.', example='c2273b7f4a30d4ef6b43e0926cdd8****', position='Path'),
  nodepoolId: string(name='nodepool_id', description='The ID of the node pool that you want to manage.

This parameter is required.', example='np613940c3593c4bea96faa8600cb9****', position='Path'),
  autoRestart?: boolean(name='auto_restart', description='Specifies whether to enable automatic instance restart.

**

**Warning** This parameter is deprecated. Any configured values will be ignored.', example='true', deprecated='true', position='Body'),
  nodes?: [ string ](name='nodes', description='The list of nodes. If not specified, all nodes in the node pool are selected.', position='Body'),
  operations?: [ 
    {
      args?: [ string ](name='args', description='The parameters of a repair operation.'),
      operationId?: string(name='operation_id', description='The ID of a repair operation.', example='remove.containerdContainer'),
    }
  ](name='operations', description='The list of repair operations to execute. If not specified, all repair operations are executed. Typically, you do not need to specify this parameter.', position='Body'),
}

model RepairClusterNodePoolResponseBody = {
  requestId?: string(name='request_id', description='The request ID.', example='db82195b-75a8-40e5-9be4-16f1829dc624'),
  taskId?: string(name='task_id', description='The ID of the task.', example='T-613b19bbd160ad4928000001'),
}

model RepairClusterNodePoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RepairClusterNodePoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RepairClusterNodePool  RepairClusterNodePoolRequest
  * @return RepairClusterNodePoolResponse
 */
async function repairClusterNodePool(request: RepairClusterNodePoolRequest): RepairClusterNodePoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RepairClusterNodePool', 'POST', '/clusters/{cluster_id}/nodepools/{nodepool_id}/repair', 'json', false, 'json', request);
}

model ResumeComponentUpgradeRequest {
  clusterid: string(name='clusterid', description='The cluster ID.

This parameter is required.', example='c5b5e80b0b64a4bf6939d2d8fbbc5****', position='Path'),
  componentid: string(name='componentid', description='The component ID.

This parameter is required.', example='metric-server', position='Path'),
}

model ResumeComponentUpgradeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @deprecated OpenAPI ResumeComponentUpgrade is deprecated, please use CS::2015-12-15::ResumeTask instead.  * @param request  the request parameters of ResumeComponentUpgrade  ResumeComponentUpgradeRequest
  * @return ResumeComponentUpgradeResponse
 */
// Deprecated
async function resumeComponentUpgrade(request: ResumeComponentUpgradeRequest): ResumeComponentUpgradeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ResumeComponentUpgrade', 'POST', '/clusters/{clusterid}/components/{componentid}/resume', 'none', false, 'json', request);
}

model ResumeTaskRequest {
  taskId: string(name='task_id', description='The task ID.

This parameter is required.', example='T-62a944794ee141074400****', position='Path'),
}

model ResumeTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of ResumeTask  ResumeTaskRequest
  * @return ResumeTaskResponse
 */
async function resumeTask(request: ResumeTaskRequest): ResumeTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ResumeTask', 'POST', '/tasks/{task_id}/resume', 'none', false, 'json', request);
}

model ResumeUpgradeClusterRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
}

model ResumeUpgradeClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @deprecated OpenAPI ResumeUpgradeCluster is deprecated, please use CS::2015-12-15::ResumeTask instead.  * @param request  the request parameters of ResumeUpgradeCluster  ResumeUpgradeClusterRequest
  * @return ResumeUpgradeClusterResponse
 */
// Deprecated
async function resumeUpgradeCluster(request: ResumeUpgradeClusterRequest): ResumeUpgradeClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ResumeUpgradeCluster', 'POST', '/api/v2/clusters/{ClusterId}/upgrade/resume', 'none', false, 'json', request);
}

model RevokeK8sClusterKubeConfigRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c5b5e80b0b64a4bf6939d2d8fbbc5****', position='Path'),
}

model RevokeK8sClusterKubeConfigResponseBody = {
}

model RevokeK8sClusterKubeConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokeK8sClusterKubeConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RevokeK8sClusterKubeConfig  RevokeK8sClusterKubeConfigRequest
  * @return RevokeK8sClusterKubeConfigResponse
 */
async function revokeK8sClusterKubeConfig(request: RevokeK8sClusterKubeConfigRequest): RevokeK8sClusterKubeConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RevokeK8sClusterKubeConfig', 'DELETE', '/k8s/{ClusterId}/certs', 'json', false, 'json', request);
}

model RunClusterCheckRequest {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='ce0da5a1d627e4e9e9f96cae8ad07****', position='Path'),
  options?: map[string]string(name='options', description='The cluster check items.', position='Body'),
  target?: string(name='target', description='The target to be checked.', example='np1f6779297c4444a3a1cdd29be8e5****', position='Body'),
  type: string(name='type', description='The check method.

This parameter is required.', example='ClusterUpgrade', position='Body'),
}

model RunClusterCheckResponseBody = {
  checkId?: string(name='check_id', description='The ID of the cluster check task.', example='1697100584236600453-ce0da5a1d627e4e9e9f96cae8ad07****-clustercheck-lboto'),
  requestId?: string(name='request_id', description='The ID of the request.', example='F04DF81D-5C12-1524-B36A-86E02526****'),
}

model RunClusterCheckResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RunClusterCheckResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RunClusterCheck  RunClusterCheckRequest
  * @return RunClusterCheckResponse
 */
async function runClusterCheck(request: RunClusterCheckRequest): RunClusterCheckResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RunClusterCheck', 'POST', '/clusters/{cluster_id}/checks', 'json', false, 'json', request);
}

model RunClusterInspectRequest {
  clusterId: string(name='clusterId', description='This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
  clientToken?: string(name='clientToken', example='c82e6987e2961451182edacd74faf', position='Body'),
}

model RunClusterInspectResponseBody = {
  reportId?: string(name='reportId', example='5d6557c983064c45bed62ab2a2119cc7'),
  requestId?: string(name='requestId', example='0AB4D067-4DD7-5471-B90A-FCC564BC3337'),
  taskId?: string(name='taskId', example='T-67d7ec016ce37c0106000***'),
}

model RunClusterInspectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RunClusterInspectResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RunClusterInspect  RunClusterInspectRequest
  * @return RunClusterInspectResponse
 */
async function runClusterInspect(request: RunClusterInspectRequest): RunClusterInspectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RunClusterInspect', 'POST', '/clusters/{clusterId}/inspectReports', 'json', false, 'json', request);
}

model ScaleClusterRequest {
  clusterId: string(name='ClusterId', description='This parameter is required.', position='Path'),
  cloudMonitorFlags?: boolean(name='cloud_monitor_flags', position='Body'),
  count?: long(name='count', position='Body'),
  cpuPolicy?: string(name='cpu_policy', position='Body'),
  disableRollback?: boolean(name='disable_rollback', position='Body'),
  keyPair?: string(name='key_pair', position='Body'),
  loginPassword?: string(name='login_password', position='Body'),
  tags?: [ 
    {
      key?: string(name='key'),
    }
  ](name='tags', position='Body'),
  taints?: [ 
    {
      effect?: string(name='effect'),
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='taints', position='Body'),
  vswitchIds?: [ string ](name='vswitch_ids', position='Body'),
  workerAutoRenew?: boolean(name='worker_auto_renew', position='Body'),
  workerAutoRenewPeriod?: long(name='worker_auto_renew_period', position='Body'),
  workerDataDisk?: boolean(name='worker_data_disk', position='Body'),
  workerDataDisks?: [ 
    {
      category?: string(name='category'),
      encrypted?: string(name='encrypted'),
      size?: string(name='size'),
    }
  ](name='worker_data_disks', position='Body'),
  workerInstanceChargeType?: string(name='worker_instance_charge_type', position='Body'),
  workerInstanceTypes?: [ string ](name='worker_instance_types', position='Body'),
  workerPeriod?: long(name='worker_period', position='Body'),
  workerPeriodUnit?: string(name='worker_period_unit', position='Body'),
  workerSystemDiskCategory?: string(name='worker_system_disk_category', position='Body'),
  workerSystemDiskSize?: long(name='worker_system_disk_size', position='Body'),
}

model ScaleClusterResponseBody = {
  clusterId?: string(name='cluster_id'),
  requestId?: string(name='request_id'),
  taskId?: string(name='task_id'),
}

model ScaleClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ScaleClusterResponseBody(name='body'),
}

/**
  * @deprecated OpenAPI ScaleCluster is deprecated, please use CS::2015-12-15::ModifyClusterNodePool instead.  * @param request  the request parameters of ScaleCluster  ScaleClusterRequest
  * @return ScaleClusterResponse
 */
// Deprecated
async function scaleCluster(request: ScaleClusterRequest): ScaleClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ScaleCluster', 'PUT', '/clusters/{ClusterId}', 'json', false, 'json', request);
}

model ScaleClusterNodePoolRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c23421cfa74454bc8b37163fd19af****', position='Path'),
  nodepoolId: string(name='NodepoolId', description='The node pool ID.

This parameter is required.', example='np31da1b38983f4511b490fc62108a****', position='Path'),
  count?: long(name='count', description='The number of worker nodes that you want to add. For example, the current node pool contains two nodes. After the two node is scaled out, the node pool contains four nodes. Due to the limit of the node quota, you can add at most 500 nodes in each request.', example='2', position='Body'),
}

model ScaleClusterNodePoolResponseBody = {
  taskId?: string(name='task_id', description='The task ID.', example='T-5faa48fb31b6b8078d00****'),
}

model ScaleClusterNodePoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ScaleClusterNodePoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ScaleClusterNodePool  ScaleClusterNodePoolRequest
  * @return ScaleClusterNodePoolResponse
 */
async function scaleClusterNodePool(request: ScaleClusterNodePoolRequest): ScaleClusterNodePoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ScaleClusterNodePool', 'POST', '/clusters/{ClusterId}/nodepools/{NodepoolId}', 'json', false, 'json', request);
}

model ScaleOutClusterRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
  cloudMonitorFlags?: boolean(name='cloud_monitor_flags', description='Specifies whether to install the CloudMonitor agent. Valid values:

*   `true`: installs the CloudMonitor agent.
*   `false`: does not install the CloudMonitor agent.

Default value: `false`.', example='true', position='Body'),
  count: long(name='count', description='The number of worker nodes that you want to add.

This parameter is required.', example='3', position='Body'),
  cpuPolicy?: string(name='cpu_policy', description='The CPU management policy of nodes in the node pool. The following policies are supported if the Kubernetes version of the cluster is 1.12.6 or later:

*   `static`: allows pods with specific resource characteristics on the node to be granted with enhanced CPU affinity and exclusivity.
*   `none`: specifies that the default CPU affinity is used.

Default value: `none`.', example='none', position='Body'),
  imageId?: string(name='image_id', description='Specifies a custom image for nodes. By default, the image provided by ACK is used. You can select a custom image to replace the default image. For more information, see [Custom images](https://help.aliyun.com/document_detail/146647.html).', example='m-bp16z7xko3vvv8gt****', position='Body'),
  keyPair: string(name='key_pair', description='The name of the key pair. You must configure this parameter or the `login_password` parameter.

This parameter is required.', example='secrity-key', position='Body'),
  loginPassword: string(name='login_password', description='The password for SSH logon. You must configure this parameter or the `key_pair` parameter. The password must be 8 to 30 characters in length, and must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.

This parameter is required.', example='Hello@1234', position='Body'),
  rdsInstances?: [ string ](name='rds_instances', description='The ApsaraDB RDS instances. If you specify a list of ApsaraDB RDS instances, ECS instances in the cluster are automatically added to the whitelist of the ApsaraDB RDS instances.', position='Body'),
  runtime?: Runtime(name='runtime', description='The container runtime.', position='Body'),
  tags?: [
    Tag
  ](name='tags', description='The labels that you want to add to the node. When you add labels to a node, the following rules apply:

*   A label is a case-sensitive key-value pair. You can add up to 20 labels.
*   The key must be unique and cannot exceed 64 characters in length. The value can be empty and cannot exceed 128 characters in length. Keys and values cannot start with aliyun, acs:, https://, or http://. For more information, see [Labels and Selectors](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set).', position='Body'),
  taints?: [
    Taint
  ](name='taints', description='The taints that you want to add to nodes. Taints can be used together with tolerations to avoid scheduling pods to specified nodes. For more information, see [taint-and-toleration](https://kubernetes.io/zh/docs/concepts/scheduling-eviction/taint-and-toleration/).', position='Body'),
  userData?: string(name='user_data', description='The user-defined data of the node pool. For more information, see [Generate user-defined data](https://help.aliyun.com/document_detail/49121.html).', example='IyEvdXNyL2Jpbi9iYXNoCmVjaG8gIkhlbGxvIEFD****', position='Body'),
  vswitchIds: [ string ](name='vswitch_ids', description='The vSwitch IDs. You can select one to three vSwitches when you create a cluster. To ensure the high availability of the cluster, we recommend that you select vSwitches in different zones.

This parameter is required.', position='Body'),
  workerAutoRenew?: boolean(name='worker_auto_renew', description='Specifies whether to enable auto-renewal for worker nodes. This parameter takes effect and is required only if `worker_instance_charge_type` is set to `PrePaid`. Valid values:

*   `true`: enables auto-renewal.
*   `false`: does not enable auto-renewal.

Default value: `true`', example='true', position='Body'),
  workerAutoRenewPeriod?: long(name='worker_auto_renew_period', description='The auto-renewal duration of worker nodes. This parameter takes effect and is required only if the subscription billing method is selected for worker nodes.

Valid values: 1, 2, 3, 6, and 12.

Default value: `1`.', example='6', position='Body'),
  workerDataDisks?: [ 
    {
      autoSnapshotPolicyId?: string(name='auto_snapshot_policy_id', description='The ID of the automatic snapshot policy. The system performs automatic backup for a cloud disk based on the specified automatic snapshot policy.

By default, this parameter is left empty, which indicates that automatic backup is disabled.', example='sp-bp14yziiuvu3s6jn****'),
      category?: string(name='category', description='The type of the data disk.', example='cloud_essd'),
      encrypted?: string(name='encrypted', description='Specifies whether to encrypt the data disks. Valid values:

*   `true`: encrypts the data disk.
*   `false`: does not encrypt the data disk.

Default value: `false`.', example='true'),
      size?: string(name='size', description='The size of the data disk. Valid values: 40 to 32767.', example='120'),
    }
  ](name='worker_data_disks', description='The configurations of the data disks that you want to mount to worker nodes. The configurations include the disk type and disk size.', position='Body'),
  workerInstanceChargeType?: string(name='worker_instance_charge_type', description='The billing method of worker nodes. Valid values:

*   `PrePaid`: subscription.
*   `PostPaid`: pay-as-you-go.

Default value: `PostPaid`.', example='PrePaid', position='Body'),
  workerInstanceTypes: [ string ](name='worker_instance_types', description='The instance configurations of worker nodes.

This parameter is required.', position='Body'),
  workerPeriod?: long(name='worker_period', description='The subscription duration of worker nodes. This parameter takes effect and is required only if `worker_instance_charge_type` is set to `PrePaid`.

Valid values: 1, 2, 3, 6, 12, 24, 36, 48, and 60.

Default value: 1.', example='1', position='Body'),
  workerPeriodUnit?: string(name='worker_period_unit', description='The billing cycle of worker nodes. This parameter is required only if worker_instance_charge_type is set to `PrePaid`.

Set the value to `Month`.', example='Month', position='Body'),
  workerSystemDiskCategory: string(name='worker_system_disk_category', description='The system disk category of worker nodes. Valid values:

*   `cloud_efficiency`: ultra disk.
*   `cloud_ssd`: standard SSD.
*   `cloud_essd`: Enterprise SSD (ESSD).

Default value: `cloud_ssd`.

This parameter is required.', example='cloud_efficiency', position='Body'),
  workerSystemDiskSize: long(name='worker_system_disk_size', description='The system disk size of worker nodes. Unit: GiB.

Valid values: 40 to 500.

Default value: `120`.

This parameter is required.', example='120', position='Body'),
}

model ScaleOutClusterResponseBody = {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='c82e6987e2961451182edacd74faf****'),
  requestId?: string(name='request_id', description='The request ID.', example='687C5BAA-D103-4993-884B-C35E4314A1E1'),
  taskId?: string(name='task_id', description='The task ID.', example='T-5a54309c80282e39ea00002f'),
}

model ScaleOutClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ScaleOutClusterResponseBody(name='body'),
}

/**
  * @description **
  * ****The ScaleOutCluster API operation is phased out. You must call the node pool-related API operations to manage nodes. If you want to add worker nodes to a Container Service for Kubernetes (ACK) cluster, call the ScaleClusterNodePool API operation. For more information, see [ScaleClusterNodePool](https://help.aliyun.com/document_detail/184928.html).
  * @param request  the request parameters of ScaleOutCluster  ScaleOutClusterRequest
  * @return ScaleOutClusterResponse
 */
async function scaleOutCluster(request: ScaleOutClusterRequest): ScaleOutClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ScaleOutCluster', 'POST', '/api/v2/clusters/{ClusterId}', 'json', false, 'json', request);
}

model ScanClusterVulsRequest {
  clusterId?: string(name='cluster_id', description='Cluster ID.', example='c259f563386444ebb8d7****', position='Path'),
}

model ScanClusterVulsResponseBody = {
  requestId?: string(name='request_id', description='Request ID.', example='687C5BAA-D103-4993-884B-C35E4314A1E1'),
  taskId?: string(name='task_id', description='Task ID.', example='T-xascadasd*****'),
}

model ScanClusterVulsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ScanClusterVulsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ScanClusterVuls  ScanClusterVulsRequest
  * @return ScanClusterVulsResponse
 */
async function scanClusterVuls(request: ScanClusterVulsRequest): ScanClusterVulsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ScanClusterVuls', 'POST', '/clusters/{cluster_id}/vuls/scan', 'json', false, 'json', request);
}

model StartAlertRequest {
  clusterId: string(name='ClusterId', description='The instance ID. You can call the ListClusters operation to query the cluster ID.

This parameter is required.', example='c245ff43c717f494489f42f5f1575e98d', position='Path'),
  alertRuleGroupName?: string(name='alert_rule_group_name', description='The name of the alert rule group.', example='sample', position='Body'),
  alertRuleName?: string(name='alert_rule_name', description='The name of the alert rule.', example='sample', position='Body'),
}

model StartAlertResponseBody = {
  msg?: string(name='msg', description='The message returned.', example='success'),
  status?: boolean(name='status', description='The status.', example='true'),
}

model StartAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartAlertResponseBody(name='body'),
}

/**
  * @param request  the request parameters of StartAlert  StartAlertRequest
  * @return StartAlertResponse
 */
async function startAlert(request: StartAlertRequest): StartAlertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StartAlert', 'POST', '/alert/{ClusterId}/alert_rule/start', 'json', false, 'json', request);
}

model StopAlertRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to obtain cluster IDs.

This parameter is required.', example='c7f9c85baee73452883b3299a0107****', position='Path'),
  alertRuleGroupName?: string(name='alert_rule_group_name', description='The name of the alert rule group.', example='sample', position='Body'),
  alertRuleName?: string(name='alert_rule_name', description='The name of the alert rule.', example='sample', position='Body'),
}

model StopAlertResponseBody = {
  msg?: string(name='msg', description='The error message returned if the call fails.', example='Success'),
  status?: boolean(name='status', description='The operation result. Valid values:

*   True: The operation is successful.
*   False: The operation failed.', example='True'),
}

model StopAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopAlertResponseBody(name='body'),
}

/**
  * @param request  the request parameters of StopAlert  StopAlertRequest
  * @return StopAlertResponse
 */
async function stopAlert(request: StopAlertRequest): StopAlertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StopAlert', 'POST', '/alert/{ClusterId}/alert_rule/stop', 'json', false, 'json', request);
}

model SyncClusterNodePoolRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c905d1364c2dd4b6284a3f41790c4****', position='Path'),
}

model SyncClusterNodePoolResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF51894XXXXX'),
}

model SyncClusterNodePoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SyncClusterNodePoolResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SyncClusterNodePool  SyncClusterNodePoolRequest
  * @return SyncClusterNodePoolResponse
 */
async function syncClusterNodePool(request: SyncClusterNodePoolRequest): SyncClusterNodePoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'SyncClusterNodePool', 'POST', '/clusters/{ClusterId}/sync_nodepools', 'json', false, 'json', request);
}

model TagResourcesRequest {
  regionId: string(name='region_id', description='The ID of the region in which the resource resides.

This parameter is required.', example='cn-hangzhou', position='Body'),
  resourceIds: [ string ](name='resource_ids', description='The list of resource IDs.

This parameter is required.', position='Body'),
  resourceType: string(name='resource_type', description='The type of resources that you want to label. Set the value to `CLUSTER`.

This parameter is required.', example='CLUSTER', position='Body'),
  tags: [
    Tag
  ](name='tags', description='The tags that you want to add to the resources in key-value pairs. You can add up to 20 key-value pairs. Note:

*   The values cannot be empty strings. A value must be 1 to 128 characters in length.
*   A key or value cannot start with `aliyun` or `acs:`.
*   A key or value cannot contain `http://` or `https://`.

This parameter is required.', position='Body'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF51894XXXXX'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of TagResources  TagResourcesRequest
  * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'TagResources', 'PUT', '/tags', 'json', false, 'json', request);
}

model UnInstallClusterAddonsRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

This parameter is required.', example='c5b5e80b0b64a4bf6939d2d8fbbc5****', position='Path'),
  addons?: [ 
    {
      cleanupCloudResources?: boolean(name='cleanup_cloud_resources', description='Specifies whether to clear cloud resources.

*   true: clears the data and cloud resources.
*   false: retains the data and cloud resources.', example='true'),
      name?: string(name='name', description='The name of the component.', example='ack-node-problem-detector'),
    }
  ](name='addons', description='The list of components that you want to uninstall. The list is an array.', position='Body'),
}

model UnInstallClusterAddonsResponseBody = {
  clusterId?: string(name='cluster_id', description='The ID of the cluster.', example='c5b5e80b0b64a4bf6939d2d8fbbc5****'),
  requestId?: string(name='request_id', description='The ID of the request.', example='74D1512F-67DA-54E8-99EA-4D50EB4898F4'),
  taskId?: string(name='task_id', description='The ID of the task.', example='T-66e39b39c0fdd001320005c0'),
}

model UnInstallClusterAddonsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnInstallClusterAddonsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UnInstallClusterAddons  UnInstallClusterAddonsRequest
  * @return UnInstallClusterAddonsResponse
 */
async function unInstallClusterAddons(request: UnInstallClusterAddonsRequest): UnInstallClusterAddonsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UnInstallClusterAddons', 'POST', '/clusters/{ClusterId}/components/uninstall', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='all', description='Specifies whether to remove all custom labels. This parameter takes effect only when `tag_keys` is left empty. Valid values:

*   `true`: Remove all custom labels.
*   `false`: Do not remove all custom labels.', example='true', position='Query'),
  regionId: string(name='region_id', description='The region ID of the resources.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceIds: [ string ](name='resource_ids', description='The list of resource IDs.

This parameter is required.', shrink='json', position='Query'),
  resourceType: string(name='resource_type', description='The type of resource. Set the value to `CLUSTER`.

This parameter is required.', example='CLUSTER', position='Query'),
  tagKeys: [ string ](name='tag_keys', description='The list of keys of the labels that you want to remove.

This parameter is required.', shrink='json', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF51894XXXXX'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UntagResources  UntagResourcesRequest
  * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UntagResources', 'DELETE', '/tags', 'json', false, 'json', request);
}

model UpdateClusterAuditLogConfigRequest {
  clusterid?: string(name='clusterid', description='The cluster ID.', example='c82e6987e2961451182edacd74faf****', position='Path'),
  disable?: boolean(name='disable', description='Enable or disable audit logging.

*   false: enables audit logging or updates the audit logging configurations.
*   true: disables audit logging.', example='false', position='Body'),
  slsProjectName?: string(name='sls_project_name', description='The [Simple Log Service project](https://help.aliyun.com/document_detail/48873.html) to which the [Logstore](https://help.aliyun.com/document_detail/48873.html) storing the cluster audit logs belongs.

*   Default value: k8s-log-{clusterid}.
*   After the cluster audit log feature is enabled, a Logstore is created in the specified Simple Log Service project to store cluster audit logs.
*   If you want to change the project after audit logging is enabled for the cluster, you can use this parameter to specify another project. You can perform this operation only in ACK managed clusters.', example='k8s-log-c82e6987e2961451182edacd74faf****', position='Body'),
}

model UpdateClusterAuditLogConfigResponseBody = {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='c93095129fc41463aa455d89444fd****'),
  requestId?: string(name='request_id', description='The ID of the request.', example='48BD70F6-A7E6-543D-9F23-08DEB764C92E'),
  taskId?: string(name='task_id', description='The ID of the task.', example='T-5faa48fb31b6b8078d00****'),
}

model UpdateClusterAuditLogConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateClusterAuditLogConfigResponseBody(name='body'),
}

/**
  * @description Before you call this operation, ensure that you understand the billing methods and pricing of [Simple Log Service](https://www.alibabacloud.com/product/log-service/pricing).
  * @param request  the request parameters of UpdateClusterAuditLogConfig  UpdateClusterAuditLogConfigRequest
  * @return UpdateClusterAuditLogConfigResponse
 */
async function updateClusterAuditLogConfig(request: UpdateClusterAuditLogConfigRequest): UpdateClusterAuditLogConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateClusterAuditLogConfig', 'PUT', '/clusters/{clusterid}/audit_log', 'json', false, 'json', request);
}

model UpdateClusterInspectConfigRequest {
  clusterId: string(name='clusterId', description='This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
  disabledCheckItems?: [ string ](name='disabledCheckItems', position='Body'),
  enabled?: boolean(name='enabled', example='true', position='Body'),
  scheduleTime?: string(name='scheduleTime', example='FREQ=DAILY;BYHOUR=10;BYMINUTE=15', position='Body'),
}

model UpdateClusterInspectConfigResponseBody = {
  requestId?: string(name='requestId', example='49511F2D-D56A-5C24-B9AE-C8491E09B***'),
}

model UpdateClusterInspectConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateClusterInspectConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateClusterInspectConfig  UpdateClusterInspectConfigRequest
  * @return UpdateClusterInspectConfigResponse
 */
async function updateClusterInspectConfig(request: UpdateClusterInspectConfigRequest): UpdateClusterInspectConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateClusterInspectConfig', 'PUT', '/clusters/{clusterId}/inspectConfig', 'json', false, 'json', request);
}

model UpdateContactGroupForAlertRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID. You can call the ListCluster operation to query the cluster ID.', example='ce7d08276f8a6422282c46272a84bxxxx', position='Path'),
  alertRuleGroupName?: string(name='alert_rule_group_name', description='The name of the alert contact group.', example='sample', position='Body'),
  contactGroupIds?: [ long ](name='contact_group_ids', description='The list of contact group IDs.', position='Body'),
  crName?: string(name='cr_name', description='The name of the container registry instance.', example='sample', position='Body'),
  namespace?: string(name='namespace', description='The namespace in which the resource resides.', example='default', position='Body'),
}

model UpdateContactGroupForAlertResponseBody = {
  msg?: string(name='msg', description='The error message returned if the call fails.', example='contact group illegal.'),
  status?: boolean(name='status', description='The update status.

*   true: The update is successful.
*   false: The update failed.', example='true'),
}

model UpdateContactGroupForAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateContactGroupForAlertResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateContactGroupForAlert  UpdateContactGroupForAlertRequest
  * @return UpdateContactGroupForAlertResponse
 */
async function updateContactGroupForAlert(request: UpdateContactGroupForAlertRequest): UpdateContactGroupForAlertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateContactGroupForAlert', 'POST', '/alert/{ClusterId}/alert_rule/contact_groups', 'json', false, 'json', request);
}

model UpdateControlPlaneLogRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c5b5e80b0b64a4bf6939d2d8fbbc5****', position='Path'),
  aliuid?: string(name='aliuid', description='The ID of the Alibaba Cloud account.', example='162981*****', position='Body'),
  components?: [ string ](name='components', description='The control plane components for which you want to enable log collection.', position='Body'),
  logProject?: string(name='log_project', description='The name of the Simple Log Service Project that you want to use to store the logs of control plane components.

Default value: k8s-log-$Cluster ID.', example='k8s-log-c5b5e80b0b64a4bf6939d2d8fbbc5****', position='Body'),
  logTtl?: string(name='log_ttl', description='The retention period of the log data stored in the Logstore. Valid values: 1 to 3000. Unit: days.

Default value: 30.', example='30', position='Body'),
}

model UpdateControlPlaneLogResponseBody = {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='cb95aa626a47740afbf6aa099b650****'),
  requestId?: string(name='request_id', description='The request ID.', example='687C5BAA-D103-4993-884B-C35E4314****'),
  taskId?: string(name='task_id', description='The task ID.', example='T-5a54309c80282e39ea00****'),
}

model UpdateControlPlaneLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateControlPlaneLogResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateControlPlaneLog  UpdateControlPlaneLogRequest
  * @return UpdateControlPlaneLogResponse
 */
async function updateControlPlaneLog(request: UpdateControlPlaneLogRequest): UpdateControlPlaneLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateControlPlaneLog', 'PUT', '/clusters/{ClusterId}/controlplanelog', 'json', false, 'json', request);
}

model UpdateK8sClusterUserConfigExpireRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

This parameter is required.', example='c5b5e80b0b64a4bf6939d2d8fbbc5****', position='Path'),
  expireHour: long(name='expire_hour', description='The validity period of the kubeconfig file. Unit: hours.

> The value of expire_hour must be greater than 0 and equal to or smaller than 876000 (100 years).

This parameter is required.', example='720', minimum=0, maximum=876000, position='Body'),
  user: string(name='user', description='The user ID.

This parameter is required.', example='The ID of the Resource Access Management (RAM) user that you use.', position='Body'),
}

model UpdateK8sClusterUserConfigExpireResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @description *   You can call this operation only with an Alibaba Cloud account.
  * *   If the kubeconfig file used by your cluster is revoked, the custom validity period of the kubeconfig file is reset. In this case, you need to call this API operation to reconfigure the validity period of the kubeconfig file.
  * @param request  the request parameters of UpdateK8sClusterUserConfigExpire  UpdateK8sClusterUserConfigExpireRequest
  * @return UpdateK8sClusterUserConfigExpireResponse
 */
async function updateK8sClusterUserConfigExpire(request: UpdateK8sClusterUserConfigExpireRequest): UpdateK8sClusterUserConfigExpireResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateK8sClusterUserConfigExpire', 'POST', '/k8s/{ClusterId}/user_config/expire', 'none', false, 'json', request);
}

model UpdateResourcesDeleteProtectionRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

This parameter is required.', example='c850429a2287b4d968e27e87a4921****', position='Path'),
  enable?: boolean(name='enable', description='Specifies whether to enable deletion protection. Set the value to true to enable deletion protection and set the value to false to disable deletion protection.', example='true', position='Body'),
  namespace?: string(name='namespace', description='The namespace to which the resource belongs.', example='default', position='Body'),
  resourceType?: string(name='resource_type', description='The type of resource for which deletion protection is enabled or disabled. You can specify namespaces or Services.', example='services', position='Body'),
  resources?: [ string ](name='resources', description='The resources list.', position='Body'),
}

model UpdateResourcesDeleteProtectionResponseBody = {
  namespace?: string(name='namespace', description='The namespace to which the resource belongs.', example='default'),
  protection?: string(name='protection', description='Indicates the status of deletion protection. A value of true indicates that deletion protection is enabled and a value of false indicates that deletion protection is disabled.', example='enable'),
  requestId?: string(name='requestId', description='Id of the request', example='0527ac9a-c899-4341-a21a-xxxxxxxxx'),
  resourceType?: string(name='resource_type', description='The type of resource for which deletion protection is enabled or disabled.', example='namespaces'),
  resources?: [ string ](name='resources', description='The list of resources whose deletion protection status is updated.'),
}

model UpdateResourcesDeleteProtectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateResourcesDeleteProtectionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateResourcesDeleteProtection  UpdateResourcesDeleteProtectionRequest
  * @return UpdateResourcesDeleteProtectionResponse
 */
async function updateResourcesDeleteProtection(request: UpdateResourcesDeleteProtectionRequest): UpdateResourcesDeleteProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateResourcesDeleteProtection', 'PUT', '/clusters/{ClusterId}/resources/protection', 'json', false, 'json', request);
}

model UpdateTemplateRequest {
  templateId: string(name='TemplateId', description='The ID of the template.

This parameter is required.', example='72d20cf8-a533-4ea9-a10d-e7630d3d2708', position='Path'),
  description?: string(name='description', description='The description of the template.', example='web server cluster', position='Body'),
  name?: string(name='name', description='The name of the template.', example='webserver01', position='Body'),
  tags?: string(name='tags', description='The label of the template.', example='web', position='Body'),
  template?: string(name='template', description='The YAML content of the template.', example='apiVersion: apps/v1\\\\nkind: Deployment\\\\nmetadata:\\\\n  name: nginx-deployment-basic\\\\n  labels:\\\\n    app: nginx\\\\nspec:\\\\n  replicas: 2\\\\n  selector:\\\\n    matchLabels:\\\\n      app: nginx\\\\n  template:\\\\n    metadata:\\\\n      labels:\\\\n        app: nginx\\\\n    spec:\\\\n      containers:\\\\n      - name: nginx\\\\n        image: busybox:latest\\\\n        ports:\\\\n        - containerPort: 8080', position='Body'),
  templateType?: string(name='template_type', description='The type of template. This parameter can be set to a custom value.

*   If the parameter is set to `kubernetes`, the template is displayed on the Templates page in the console.
*   If the parameter is set to `compose`, the template is displayed on the Container Service - Swarm page in the console. Container Service for Swarm is deprecated.', example='kubernetes', position='Body'),
}

model UpdateTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @param request  the request parameters of UpdateTemplate  UpdateTemplateRequest
  * @return UpdateTemplateResponse
 */
async function updateTemplate(request: UpdateTemplateRequest): UpdateTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateTemplate', 'PUT', '/templates/{TemplateId}', 'none', false, 'json', request);
}

model UpdateUserPermissionsRequest {
  uid?: string(name='uid', description='The ID of the RAM user or RAM role whose permissions you want to update.', example='2367****', position='Path'),
  body?: [ 
    {
      cluster?: string(name='cluster', description='The ID of the cluster on which you want to grant permissions to the RAM role or RAM role.

*   Set this parameter to an empty string if `role_type` is set to `all-clusters`.', example='c796c60***'),
      isCustom?: boolean(name='is_custom', description='Specifies whether to assign a custom role to the RAM user or RAM role. If you want to assign a custom role to the RAM user or RAM role, set `role_name` to the name of the custom role.', example='false'),
      isRamRole?: boolean(name='is_ram_role', description='Specifies whether to use a RAM role to grant permissions.', example='false'),
      namespace?: string(name='namespace', description='The namespace that you want to authorize the RAM user or RAM role to manage. This parameter is required only if you set role_type to namespace.', example='test'),
      roleName?: string(name='role_name', description='The predefined role name. Valid values:

*   `admin`: administrator
*   `admin-view`: read-only administrator
*   `ops`: O\\&M engineer
*   `dev`: developer
*   `restricted`: restricted user
*   Custom role

Note:

*   You cannot grant **namespace-level** permissions to the `admin`, `admin-view`, and `ops` roles.
*   You cannot grant **all cluster-level** permissions to the `admin-view` role.', example='ops'),
      roleType?: string(name='role_type', description='The authorization type. Valid values:

*   `cluster`: authorizes the RAM user or RAM role to manage the specified clusters.
*   `namespace`: authorizes the RAM user or RAM role to manage the specified namespaces.
*   `all-clusters`: authorizes the RAM user or RAM role to manage all clusters.', example='cluster'),
    }
  ](name='body', description='The request body.', position='Body'),
  mode?: string(name='mode', description='The authorization method. Valid values:

*   `apply`: The global update mode. Overwrites all existing permissions of the RAM user or RAM role on the cluster. You must specify all the permissions you want to grant to the RAM user or RAM role in the request parameters when you call this operation.
*   `delete`: The deletion mode. Revokes only the cluster permissions specified in the request, preserving other existing permissions of the RAM user or RAM role.
*   `patch`: The incremental mode. Adds only the cluster permissions specified in the request, preserving other existing permissions of the RAM user or RAM role.

Default value: `apply`.', example='apply', position='Query'),
}

model UpdateUserPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * @description **Precautions**:
  * *   You can update the permissions of a RAM user or RAM role on a cluster by using full update or incremental update. If you use full update, the existing permissions of the RAM user or RAM role on the cluster are overwritten. You must specify all the permissions that you want to grant to the RAM user or RAM role in the request parameters when you call the operation. If you use incremental update, you can grant permissions to or revoke permissions from the RAM user or RAM role on the cluster. In this case, only the permissions that you specify in the request parameters when you call the operation are granted or revoked, other permissions of the RAM user or RAM role on the cluster are not affected.
  * @param request  the request parameters of UpdateUserPermissions  UpdateUserPermissionsRequest
  * @return UpdateUserPermissionsResponse
 */
async function updateUserPermissions(request: UpdateUserPermissionsRequest): UpdateUserPermissionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateUserPermissions', 'POST', '/permissions/users/{uid}/update', 'none', false, 'json', request);
}

model UpgradeClusterRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster that you want to upgrade.

This parameter is required.', example='c82e6987e2961451182edacd74faf****', position='Path'),
  componentName?: string(name='component_name', description='This parameter is deprecated. No need to pass values.', example='k8s', deprecated='true', position='Body'),
  masterOnly?: boolean(name='master_only', description='Specifies whether to upgrade only master nodes. Valid values:

*   true: upgrades master nodes only.
*   false: upgrades both master and worker nodes.', example='true', position='Body'),
  nextVersion?: string(name='next_version', description='The target Kubernetes version for cluster upgrade.', example='1.16.9-aliyun.1', position='Body'),
  rollingPolicy?: {
    maxParallelism?: int32(name='max_parallelism', description='The maximum number of nodes concurrently upgraded per batch.', example='3'),
  }(name='rolling_policy', description='The rolling update configuration.', position='Body'),
  version?: string(name='version', description='This parameter is deprecated. Use next_version to specify the upgrade target Kubernetes version.', example='1.14.8-aliyun.1', deprecated='true', position='Body'),
}

model UpgradeClusterResponseBody = {
  clusterId?: string(name='cluster_id', description='Cluster ID.', example='c82e6987e2961451182edacd74faf****'),
  requestId?: string(name='request_id', description='Request ID.', example='0527ac9a-c899-4341-a21a-****'),
  taskId?: string(name='task_id', description='Task ID.', example='T-5faa48fb31b6b8078d00****'),
}

model UpgradeClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeClusterResponseBody(name='body'),
}

/**
  * @description After successfully calling the UpgradeCluster interface, this API returns the `task_id` of the upgrade task. You can manage this operation task by calling the following task APIs:
  * - [Call DescribeTaskInfo to query task details](https://help.aliyun.com/document_detail/2667985.html)
  * - [Call PauseTask to pause a running task](https://help.aliyun.com/document_detail/2667986.html) 
  * - [Call ResumeTask to resume a task that has been paused](https://help.aliyun.com/document_detail/2667987.html) 
  * - [Call CancelTask to cancel a running task](https://help.aliyun.com/document_detail/2667988.html)
  * @param request  the request parameters of UpgradeCluster  UpgradeClusterRequest
  * @return UpgradeClusterResponse
 */
async function upgradeCluster(request: UpgradeClusterRequest): UpgradeClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpgradeCluster', 'POST', '/api/v2/clusters/{ClusterId}/upgrade', 'json', false, 'json', request);
}

model UpgradeClusterAddonsRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='cf4299b79b3e34226abfdc80a4bda****', position='Path'),
  body?: [ 
    {
      componentName: string(name='component_name', description='The name of the component.

This parameter is required.', example='coredns'),
      config?: string(name='config', description='The custom component settings that you want to use. The value is a JSON string.', example='{\\"CpuRequest\\":\\"800m\\"}'),
      nextVersion: string(name='next_version', description='The version to which the component can be updated. You can call the `DescribeClusterAddonsVersion` operation to query the version to which the component can be updated.

This parameter is required.', example='1.6.7'),
      policy?: string(name='policy', description='The update policy. Valid values:

*   overwrite
*   canary', example='canary'),
      version?: string(name='version', description='The current version of the component.', example='v1.6.2'),
    }
  ](name='body', description='The request parameters.', position='Body'),
}

model UpgradeClusterAddonsResponseBody = {
  clusterId?: string(name='cluster_id', description='The cluster ID.', example='cf4299b79b3e34226abfdc80a4bda****'),
  requestId?: string(name='request_id', description='The request ID.', example='bfd12953-31cb-42f1-8a36-7b80ec345094'),
  taskId?: string(name='task_id', description='The task ID.', example='T-62a944794ee141074400****'),
}

model UpgradeClusterAddonsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeClusterAddonsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpgradeClusterAddons  UpgradeClusterAddonsRequest
  * @return UpgradeClusterAddonsResponse
 */
async function upgradeClusterAddons(request: UpgradeClusterAddonsRequest): UpgradeClusterAddonsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpgradeClusterAddons', 'POST', '/clusters/{ClusterId}/components/upgrade', 'json', false, 'json', request);
}

model UpgradeClusterNodepoolRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='c106f377e16f34eb1808d6b9362c9****', position='Path'),
  nodepoolId: string(name='NodepoolId', description='The node pool ID.

This parameter is required.', example='np31da1b38983f4511b490fc62108a****', position='Path'),
  imageId?: string(name='image_id', description='The ID of the OS image used by the nodes.', example='aliyun_2_1903_x64_20G_alibase_20200529.vhd', position='Body'),
  kubernetesVersion?: string(name='kubernetes_version', description='The Kubernetes version used by the nodes. You can call the [DescribeKubernetesVersionMetadata](https://help.aliyun.com/document_detail/2667899.html) operation and get the Kubernetes version of the current cluster in the current_version field.', example='1.22.15-aliyun.1', position='Body'),
  nodeNames?: [ string ](name='node_names', description='The nodes you want to update. If you do not specify this parameter, all nodes in the node pool are updated by default.', position='Body'),
  rollingPolicy?: {
    batchInterval?: int32(name='batch_interval', description='The update interval between batches takes effect only when the pause policy is set to NotPause. Unit: minutes. Valid values: 5 to 120.', example='5 minutes'),
    maxParallelism?: int32(name='max_parallelism', description='The maximum number of nodes per batch.', example='3'),
    pausePolicy?: string(name='pause_policy', description='The policy used to pause the update. Valid values:

*   FirstBatch: pauses after the first batch is updated.
*   EveryBatch: pauses after each batch is updated.
*   NotPause: does not pause.', example='NotPause'),
  }(name='rolling_policy', description='The rolling update configuration.', position='Body'),
  runtimeType?: string(name='runtime_type', description='The runtime type. You can call the [DescribeKubernetesVersionMetadata](https://help.aliyun.com/document_detail/2667899.html) operation and get the runtime information in the runtime field.', example='containerd', position='Body'),
  runtimeVersion?: string(name='runtime_version', description='The version of the container runtime used by the nodes. You can call the [DescribeKubernetesVersionMetadata](https://help.aliyun.com/document_detail/2667899.html) operation and get the runtime version in the runtime field.', example='1.5.10', position='Body'),
  useReplace?: boolean(name='use_replace', description='Specifies whether to perform the update by replacing the system disk. Valid values:

*   true: replaces the system disk.
*   false: does not replace the system disk.

Default value: false.', example='false', position='Body'),
}

model UpgradeClusterNodepoolResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF518944****'),
  taskId?: string(name='task_id', description='The task ID.', example='T-5fd211e924e1d0078700xxxx'),
}

model UpgradeClusterNodepoolResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeClusterNodepoolResponseBody(name='body'),
}

/**
  * @description This operation allows you to update the Kubernetes version, OS version, or container runtime version of the nodes in a node pool.
  * @param request  the request parameters of UpgradeClusterNodepool  UpgradeClusterNodepoolRequest
  * @return UpgradeClusterNodepoolResponse
 */
async function upgradeClusterNodepool(request: UpgradeClusterNodepoolRequest): UpgradeClusterNodepoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpgradeClusterNodepool', 'POST', '/clusters/{ClusterId}/nodepools/{NodepoolId}/upgrade', 'json', false, 'json', request);
}

model StandardComponentsValue = {
  name?: string(name='name', description='The name of the component.', example='ack-arena'),
  version?: string(name='version', description='The version of the component.', example='0.5.0'),
  description?: string(name='description', description='The description of the component.', example='***'),
  required?: string(name='required', description='Indicates whether the component is a required component. Valid values:

*   `true`: The component is required and must be installed when a cluster is created.
*   `false`: The component is optional. After a cluster is created, you can go to the `Add-ons` page to install the component.', example='false'),
  disabled?: boolean(name='disabled', description='Indicates whether the automatic installation of the component is disabled. By default, some optional components, such as components for logging and Ingresses, are installed when a cluster is created. You can set this parameter to disable automatic component installation. Valid values:

*   `true`: disables automatic component installation.
*   `false`: enables automatic component installation.', example='false'),
}

model QuotasValue = {
  quota?: string(name='quota', description='The value of the quota. If the quota limit is reached, submit an application in the [Quota Center console](https://quotas.console.aliyun.com/products/csk/quotas) to increase the quota.', example='1'),
  operationCode?: string(name='operation_code', description='The quota code.', example='q_Kubernetes_Cluster'),
  adjustable?: boolean(name='adjustable', description='Indicates whether the quota is adjustable.', example='true'),
  unit?: string(name='unit', description='The unit.', example='Cluster'),
}

