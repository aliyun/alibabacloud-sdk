import Util;
import ROA;
import EndpointUtil;

extends ROA;

const version = '2015-12-15';

init(config: ROA.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpointHost = getEndpoint(@productId, @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpointHost);
}


model ResumeComponentUpgradeRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model ResumeComponentUpgradeResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model ResumeComponentUpgradeResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: ResumeComponentUpgradeResponseBody(name='body', description='body'),
}

async function resumeComponentUpgradeEx(clusterid: string, componentid: string, request: ResumeComponentUpgradeRequest, runtime: Util.RuntimeOptions): ResumeComponentUpgradeResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterid}/components/${componentid}/resume`, null, request.headers, null, runtime);
}

async function resumeComponentUpgrade(clusterid: string, componentid: string, request: ResumeComponentUpgradeRequest): ResumeComponentUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumeComponentUpgradeEx(clusterid, componentid, request, runtime);
}

model PauseComponentUpgradeRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model PauseComponentUpgradeResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model PauseComponentUpgradeResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: PauseComponentUpgradeResponseBody(name='body', description='body'),
}

async function pauseComponentUpgradeEx(clusterid: string, componentid: string, request: PauseComponentUpgradeRequest, runtime: Util.RuntimeOptions): PauseComponentUpgradeResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterid}/components/${componentid}/pause`, null, request.headers, null, runtime);
}

async function pauseComponentUpgrade(clusterid: string, componentid: string, request: PauseComponentUpgradeRequest): PauseComponentUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  return pauseComponentUpgradeEx(clusterid, componentid, request, runtime);
}

model CancelComponentUpgradeRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model CancelComponentUpgradeResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model CancelComponentUpgradeResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: CancelComponentUpgradeResponseBody(name='body', description='body'),
}

async function cancelComponentUpgradeEx(clusterid: string, componentid: string, request: CancelComponentUpgradeRequest, runtime: Util.RuntimeOptions): CancelComponentUpgradeResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterid}/components/${componentid}/cancel`, null, request.headers, null, runtime);
}

async function cancelComponentUpgrade(clusterid: string, componentid: string, request: CancelComponentUpgradeRequest): CancelComponentUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelComponentUpgradeEx(clusterid, componentid, request, runtime);
}

model CancelWorkflowRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model CancelWorkflowResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function cancelWorkflowEx(workflowName: string, request: CancelWorkflowRequest, runtime: Util.RuntimeOptions): CancelWorkflowResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'PUT', 'AK', `/gs/workflow/${workflowName}`, null, request.headers, null, runtime);
}

async function cancelWorkflow(workflowName: string, request: CancelWorkflowRequest): CancelWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelWorkflowEx(workflowName, request, runtime);
}

model DescirbeWorkflowRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescirbeWorkflowResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function descirbeWorkflowEx(workflowName: string, request: DescirbeWorkflowRequest, runtime: Util.RuntimeOptions): DescirbeWorkflowResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/gs/workflow/${workflowName}`, null, request.headers, null, runtime);
}

async function descirbeWorkflow(workflowName: string, request: DescirbeWorkflowRequest): DescirbeWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return descirbeWorkflowEx(workflowName, request, runtime);
}

model RemoveWorkflowRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model RemoveWorkflowResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function removeWorkflowEx(workflowName: string, request: RemoveWorkflowRequest, runtime: Util.RuntimeOptions): RemoveWorkflowResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'DELETE', 'AK', `/gs/workflow/${workflowName}`, null, request.headers, null, runtime);
}

async function removeWorkflow(workflowName: string, request: RemoveWorkflowRequest): RemoveWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeWorkflowEx(workflowName, request, runtime);
}

model DescribeWorkflowsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeWorkflowsResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function describeWorkflowsEx(request: DescribeWorkflowsRequest, runtime: Util.RuntimeOptions): DescribeWorkflowsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/gs/workflows`, null, request.headers, null, runtime);
}

async function describeWorkflows(request: DescribeWorkflowsRequest): DescribeWorkflowsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWorkflowsEx(request, runtime);
}

model StartWorkflowRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model StartWorkflowResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function startWorkflowEx(request: StartWorkflowRequest, runtime: Util.RuntimeOptions): StartWorkflowResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/gs/workflow`, null, request.headers, null, runtime);
}

async function startWorkflow(request: StartWorkflowRequest): StartWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return startWorkflowEx(request, runtime);
}

model CreateServiceMeshRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model CreateServiceMeshResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model CreateServiceMeshResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: CreateServiceMeshResponseBody(name='body', description='body'),
}

async function createServiceMeshEx(request: CreateServiceMeshRequest, runtime: Util.RuntimeOptions): CreateServiceMeshResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/servicemesh`, null, request.headers, null, runtime);
}

async function createServiceMesh(request: CreateServiceMeshRequest): CreateServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceMeshEx(request, runtime);
}

model ServiceMeshAddClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model ServiceMeshAddClusterResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model ServiceMeshAddClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: ServiceMeshAddClusterResponseBody(name='body', description='body'),
}

async function serviceMeshAddClusterEx(serviceMeshId: string, request: ServiceMeshAddClusterRequest, runtime: Util.RuntimeOptions): ServiceMeshAddClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'PUT', 'AK', `/servicemesh/${serviceMeshId}/add/clusters`, null, request.headers, null, runtime);
}

async function serviceMeshAddCluster(serviceMeshId: string, request: ServiceMeshAddClusterRequest): ServiceMeshAddClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return serviceMeshAddClusterEx(serviceMeshId, request, runtime);
}

model ServiceMeshRemoveClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model ServiceMeshRemoveClusterResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model ServiceMeshRemoveClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: ServiceMeshRemoveClusterResponseBody(name='body', description='body'),
}

async function serviceMeshRemoveClusterEx(serviceMeshId: string, request: ServiceMeshRemoveClusterRequest, runtime: Util.RuntimeOptions): ServiceMeshRemoveClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'PUT', 'AK', `/servicemesh/${serviceMeshId}/remove/clusters`, null, request.headers, null, runtime);
}

async function serviceMeshRemoveCluster(serviceMeshId: string, request: ServiceMeshRemoveClusterRequest): ServiceMeshRemoveClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return serviceMeshRemoveClusterEx(serviceMeshId, request, runtime);
}

model UpdateServiceMeshRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model UpdateServiceMeshResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model UpdateServiceMeshResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: UpdateServiceMeshResponseBody(name='body', description='body'),
}

async function updateServiceMeshEx(serviceMeshId: string, request: UpdateServiceMeshRequest, runtime: Util.RuntimeOptions): UpdateServiceMeshResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'PUT', 'AK', `/servicemesh/${serviceMeshId}`, null, request.headers, null, runtime);
}

async function updateServiceMesh(serviceMeshId: string, request: UpdateServiceMeshRequest): UpdateServiceMeshResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateServiceMeshEx(serviceMeshId, request, runtime);
}

model ServiceMeshApiServerRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model ServiceMeshApiServerResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function serviceMeshApiServerEx(serviceMeshId: string, request: ServiceMeshApiServerRequest, runtime: Util.RuntimeOptions): ServiceMeshApiServerResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/servicemesh/${serviceMeshId}/api_proxy`, null, request.headers, null, runtime);
}

async function serviceMeshApiServer(serviceMeshId: string, request: ServiceMeshApiServerRequest): ServiceMeshApiServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return serviceMeshApiServerEx(serviceMeshId, request, runtime);
}

model UnInstallClusterAddonsBody = {
  name: string(name='name', description='name'),
}

model UnInstallClusterAddonsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: UnInstallClusterAddonsBody(name='body', description='body'),
}

model UnInstallClusterAddonsResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model UnInstallClusterAddonsResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: UnInstallClusterAddonsResponseBody(name='body', description='body'),
}

async function unInstallClusterAddonsEx(clusterId: string, request: UnInstallClusterAddonsRequest, runtime: Util.RuntimeOptions): UnInstallClusterAddonsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/components/uninstall`, null, request.headers, request.body, runtime);
}

async function unInstallClusterAddons(clusterId: string, request: UnInstallClusterAddonsRequest): UnInstallClusterAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  return unInstallClusterAddonsEx(clusterId, request, runtime);
}

model DescribeAddonsQuery = {
  region?: string(name='region', description='region'),
  clusterType?: string(name='cluster_type', description='cluster_type'),
}

model DescribeAddonsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  query?: DescribeAddonsQuery(name='query', description='query'),
}

model DescribeAddonsResponseBody = {
  componentGroups: [
    {
      groupName: string(name='group_name', description='group_name'),
      items: [
        {
          name: string(name='name', description='name'),
          config: string(name='config', description='config'),
          required: string(name='required', description='required'),
          disabled: boolean(name='disabled', description='disabled'),
          version: string(name='version', description='version'),
        }
      ](name='items', description='items'),
      default: [ string ](name='default', description='default'),
    }
  ](name='ComponentGroups', description='ComponentGroups'),
  standardComponents: {
    addonName: {
      name: string(name='name', description='name'),
      config: string(name='config', description='config'),
      required: string(name='required', description='required'),
      disabled: boolean(name='disabled', description='disabled'),
      version: string(name='version', description='version'),
    }(name='addon_name', description='addon_name'),
  }(name='StandardComponents', description='StandardComponents'),
}

model DescribeAddonsResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeAddonsResponseBody(name='body', description='body'),
}

async function describeAddonsEx(request: DescribeAddonsRequest, runtime: Util.RuntimeOptions): DescribeAddonsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/components/metadata`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeAddons(request: DescribeAddonsRequest): DescribeAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAddonsEx(request, runtime);
}

model CancelClusterUpgradeRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model CancelClusterUpgradeResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model CancelClusterUpgradeResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: CancelClusterUpgradeResponseBody(name='body', description='body'),
}

async function cancelClusterUpgradeEx(clusterId: string, request: CancelClusterUpgradeRequest, runtime: Util.RuntimeOptions): CancelClusterUpgradeResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/api/v2/clusters/${clusterId}/upgrade/cancel`, null, request.headers, null, runtime);
}

async function cancelClusterUpgrade(clusterId: string, request: CancelClusterUpgradeRequest): CancelClusterUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelClusterUpgradeEx(clusterId, request, runtime);
}

model DescribeUserQuotaRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeUserQuotaResponseBody = {
  clusterQuota: integer(name='cluster_quota', description='cluster_quota'),
  nodeQuota: integer(name='node_quota', description='node_quota'),
  askClusterQuota: integer(name='ask_cluster_quota', description='ask_cluster_quota'),
  amkClusterQuota: integer(name='amk_cluster_quota', description='amk_cluster_quota'),
}

model DescribeUserQuotaResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeUserQuotaResponseBody(name='body', description='body'),
}

async function describeUserQuotaEx(request: DescribeUserQuotaRequest, runtime: Util.RuntimeOptions): DescribeUserQuotaResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/quota`, null, request.headers, null, runtime);
}

async function describeUserQuota(request: DescribeUserQuotaRequest): DescribeUserQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserQuotaEx(request, runtime);
}

model DescribeClusterV2UserKubeconfigQuery = {
  privateIpAddress?: boolean(name='PrivateIpAddress', description='PrivateIpAddress'),
}

model DescribeClusterV2UserKubeconfigRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  query?: DescribeClusterV2UserKubeconfigQuery(name='query', description='query'),
}

model DescribeClusterV2UserKubeconfigResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model DescribeClusterV2UserKubeconfigResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterV2UserKubeconfigResponseBody(name='body', description='body'),
}

async function describeClusterV2UserKubeconfigEx(clusterId: string, request: DescribeClusterV2UserKubeconfigRequest, runtime: Util.RuntimeOptions): DescribeClusterV2UserKubeconfigResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/api/v2/k8s/${clusterId}/user_config`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeClusterV2UserKubeconfig(clusterId: string, request: DescribeClusterV2UserKubeconfigRequest): DescribeClusterV2UserKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterV2UserKubeconfigEx(clusterId, request, runtime);
}

model RemoveClusterNodesBody = {
  releaseNode?: boolean(name='release_node', description='release_node'),
  drainNode?: boolean(name='drain_node', description='drain_node'),
  nodes: [
    {
      nodeName?: string(name='node_name', description='node_name'),
    }
  ](name='nodes', description='nodes'),
}

model RemoveClusterNodesRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body?: RemoveClusterNodesBody(name='body', description='body'),
}

model RemoveClusterNodesResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function removeClusterNodesEx(clusterId: string, request: RemoveClusterNodesRequest, runtime: Util.RuntimeOptions): RemoveClusterNodesResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/api/v2/clusters/${clusterId}/nodes/remove`, null, request.headers, request.body, runtime);
}

async function removeClusterNodes(clusterId: string, request: RemoveClusterNodesRequest): RemoveClusterNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeClusterNodesEx(clusterId, request, runtime);
}

model UpgradeClusterBody = {
  version?: string(name='version', description='version'),
}

model UpgradeClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body?: UpgradeClusterBody(name='body', description='body'),
}

model UpgradeClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function upgradeClusterEx(clusterId: string, request: UpgradeClusterRequest, runtime: Util.RuntimeOptions): UpgradeClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/api/v2/clusters/${clusterId}/upgrade`, null, request.headers, request.body, runtime);
}

async function upgradeCluster(clusterId: string, request: UpgradeClusterRequest): UpgradeClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeClusterEx(clusterId, request, runtime);
}

model PauseClusterUpgradeRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model PauseClusterUpgradeResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function pauseClusterUpgradeEx(clusterId: string, request: PauseClusterUpgradeRequest, runtime: Util.RuntimeOptions): PauseClusterUpgradeResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/api/v2/clusters/${clusterId}/upgrade/pause`, null, request.headers, null, runtime);
}

async function pauseClusterUpgrade(clusterId: string, request: PauseClusterUpgradeRequest): PauseClusterUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  return pauseClusterUpgradeEx(clusterId, request, runtime);
}

model ResumeUpgradeClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model ResumeUpgradeClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function resumeUpgradeClusterEx(clusterId: string, request: ResumeUpgradeClusterRequest, runtime: Util.RuntimeOptions): ResumeUpgradeClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/api/v2/clusters/${clusterId}/upgrade/resume`, null, request.headers, null, runtime);
}

async function resumeUpgradeCluster(clusterId: string, request: ResumeUpgradeClusterRequest): ResumeUpgradeClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumeUpgradeClusterEx(clusterId, request, runtime);
}

model GetUpgradeStatusRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model GetUpgradeStatusResponseBody = {
  status: string(name='status', description='status'),
  precheckReportId: string(name='precheck_report_id', description='precheck_report_id'),
  upgradeStep: string(name='upgrade_step', description='upgrade_step'),
  errorMessage: string(name='error_message', description='error_message'),
}

model GetUpgradeStatusResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: GetUpgradeStatusResponseBody(name='body', description='body'),
}

async function getUpgradeStatusEx(clusterId: string, request: GetUpgradeStatusRequest, runtime: Util.RuntimeOptions): GetUpgradeStatusResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/api/v2/clusters/${clusterId}/upgrade/status`, null, request.headers, null, runtime);
}

async function getUpgradeStatus(clusterId: string, request: GetUpgradeStatusRequest): GetUpgradeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUpgradeStatusEx(clusterId, request, runtime);
}

model ModifyClusterBody = {
  deletionProtection?: boolean(name='deletion_protection', description='deletion_protection'),
  ingressLoadbalancerId?: string(name='ingress_loadbalancer_id', description='ingress_loadbalancer_id'),
  resourceGroupId?: string(name='resource_group_id', description='resource_group_id'),
}

model ModifyClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body?: ModifyClusterBody(name='body', description='body'),
}

model ModifyClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function modifyClusterEx(clusterId: string, request: ModifyClusterRequest, runtime: Util.RuntimeOptions): ModifyClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'PUT', 'AK', `/api/v2/clusters/${clusterId}`, null, request.headers, request.body, runtime);
}

async function modifyCluster(clusterId: string, request: ModifyClusterRequest): ModifyClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterEx(clusterId, request, runtime);
}

model InstallClusterAddonsBody = {
  name?: string(name='name', description='name'),
  version?: string(name='version', description='version'),
  disabled?: boolean(name='disabled', description='disabled'),
  required?: string(name='required', description='required'),
  config?: string(name='config', description='config'),
}

model InstallClusterAddonsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body?: InstallClusterAddonsBody(name='body', description='body'),
}

model InstallClusterAddonsResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function installClusterAddonsEx(clusterId: string, request: InstallClusterAddonsRequest, runtime: Util.RuntimeOptions): InstallClusterAddonsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/components/install`, null, request.headers, request.body, runtime);
}

async function installClusterAddons(clusterId: string, request: InstallClusterAddonsRequest): InstallClusterAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  return installClusterAddonsEx(clusterId, request, runtime);
}

model DeleteTriggerHookRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DeleteTriggerHookResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function deleteTriggerHookEx(request: DeleteTriggerHookRequest, runtime: Util.RuntimeOptions): DeleteTriggerHookResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/api/v2/hook/trigger`, null, request.headers, null, runtime);
}

async function deleteTriggerHook(request: DeleteTriggerHookRequest): DeleteTriggerHookResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTriggerHookEx(request, runtime);
}

model ModifyClusterTagsBody = {
  key: string(name='key', description='key'),
  value: string(name='value', description='value'),
}

model ModifyClusterTagsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: ModifyClusterTagsBody(name='body', description='body'),
}

model ModifyClusterTagsResponseBody = {
  requestId: string(name='requestId', description='requestId'),
}

model ModifyClusterTagsResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: ModifyClusterTagsResponseBody(name='body', description='body'),
}

async function modifyClusterTagsEx(clusterId: string, request: ModifyClusterTagsRequest, runtime: Util.RuntimeOptions): ModifyClusterTagsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/tags`, null, request.headers, request.body, runtime);
}

async function modifyClusterTags(clusterId: string, request: ModifyClusterTagsRequest): ModifyClusterTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterTagsEx(clusterId, request, runtime);
}

model DescribeExternalAgentRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeExternalAgentResponseBody = {
  config: string(name='config', description='config'),
}

model DescribeExternalAgentResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeExternalAgentResponseBody(name='body', description='body'),
}

async function describeExternalAgentEx(clusterId: string, request: DescribeExternalAgentRequest, runtime: Util.RuntimeOptions): DescribeExternalAgentResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/k8s/${clusterId}/external/agent/deployment`, null, request.headers, null, runtime);
}

async function describeExternalAgent(clusterId: string, request: DescribeExternalAgentRequest): DescribeExternalAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExternalAgentEx(clusterId, request, runtime);
}

model DescribeClusterAttachScriptsBody = {
  options: {
    flannelIface?: string(name='flannelIface', description='flannelIface'),
    enableIptables?: boolean(name='enableIptables', description='enableIptables'),
    manageRuntime?: boolean(name='manageRuntime', description='manageRuntime'),
    nodeNameStrategy?: string(name='nodeNameStrategy', description='nodeNameStrategy'),
    nodeName?: string(name='nodeName', description='nodeName'),
    nodeNamePrefix?: string(name='nodeNamePrefix', description='nodeNamePrefix'),
  }(name='options', description='options'),
}

model DescribeClusterAttachScriptsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: DescribeClusterAttachScriptsBody(name='body', description='body'),
}

model DescribeClusterAttachScriptsResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function describeClusterAttachScriptsEx(clusterId: string, request: DescribeClusterAttachScriptsRequest, runtime: Util.RuntimeOptions): DescribeClusterAttachScriptsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/attachscript`, null, request.headers, null, runtime);
}

async function describeClusterAttachScripts(clusterId: string, request: DescribeClusterAttachScriptsRequest): DescribeClusterAttachScriptsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterAttachScriptsEx(clusterId, request, runtime);
}

model ScaleOutClusterBody = {
  count: integer(name='count', description='count'),
  workerInstanceChargeType?: string(name='worker_instance_charge_type', description='worker_instance_charge_type'),
  workerPeriod?: integer(name='worker_period', description='worker_period'),
  workerPeriodUnit?: string(name='worker_period_unit', description='worker_period_unit'),
  workerAutoRenew?: boolean(name='worker_auto_renew', description='worker_auto_renew'),
  workerAutoRenewPeriod?: integer(name='worker_auto_renew_period', description='worker_auto_renew_period'),
  workerSystemDiskCategory?: string(name='worker_system_disk_category', description='worker_system_disk_category'),
  workerSystemDiskSize?: integer(name='worker_system_disk_size', description='worker_system_disk_size'),
  workerDataDisk: boolean(name='worker_data_disk', description='worker_data_disk'),
  keyPair: string(name='key_pair', description='key_pair'),
  loginPassword: string(name='login_password', description='login_password'),
  cloudMonitorFlags?: boolean(name='cloud_monitor_flags', description='cloud_monitor_flags'),
  cpuPolicy?: string(name='cpu_policy', description='cpu_policy'),
  disableRollback?: boolean(name='disable_rollback', description='disable_rollback'),
  workerDataDisks: [
    {
      category?: string(name='category', description='category'),
      size?: string(name='size', description='size'),
      encrypted?: string(name='encrypted', description='encrypted'),
    }
  ](name='worker_data_disks', description='worker_data_disks'),
  tags: [
    {
      key?: string(name='key', description='key'),
      value?: string(name='value', description='value'),
    }
  ](name='tags', description='tags'),
  taints: [
    {
      key?: string(name='key', description='key'),
      value?: string(name='value', description='value'),
      effect?: string(name='effect', description='effect'),
    }
  ](name='taints', description='taints'),
  vswitchIds: [ string ](name='vswitch_ids', description='vswitch_ids'),
  workerInstanceTypes: [ string ](name='worker_instance_types', description='worker_instance_types'),
}

model ScaleOutClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: ScaleOutClusterBody(name='body', description='body'),
}

model ScaleOutClusterResponseBody = {
  clusterId: string(name='cluster_id', description='cluster_id'),
  requestId: string(name='request_id', description='request_id'),
  taskId: string(name='task_id', description='task_id'),
  instanceId: string(name='instanceId', description='instanceId'),
}

model ScaleOutClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: ScaleOutClusterResponseBody(name='body', description='body'),
}

async function scaleOutClusterEx(clusterId: string, request: ScaleOutClusterRequest, runtime: Util.RuntimeOptions): ScaleOutClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/api/v2/clusters/${clusterId}`, null, request.headers, request.body, runtime);
}

async function scaleOutCluster(clusterId: string, request: ScaleOutClusterRequest): ScaleOutClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return scaleOutClusterEx(clusterId, request, runtime);
}

model CreateTriggerHookBody = {
  regionId?: string(name='region_id', description='region_id'),
  clusterId?: string(name='cluster_id', description='cluster_id'),
  projectId?: string(name='project_id', description='project_id'),
  action?: string(name='action', description='action'),
  triggerUrl?: string(name='trigger_url', description='trigger_url'),
}

model CreateTriggerHookRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body?: CreateTriggerHookBody(name='body', description='body'),
}

model CreateTriggerHookResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function createTriggerHookEx(request: CreateTriggerHookRequest, runtime: Util.RuntimeOptions): CreateTriggerHookResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'PUT', 'AK', `/hook/trigger`, null, request.headers, request.body, runtime);
}

async function createTriggerHook(request: CreateTriggerHookRequest): CreateTriggerHookResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTriggerHookEx(request, runtime);
}

model UpgradeClusterAddonsBody = {
  componentName?: string(name='component_name', description='component_name'),
  version?: string(name='version', description='version'),
}

model UpgradeClusterAddonsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body?: UpgradeClusterAddonsBody(name='body', description='body'),
}

model UpgradeClusterAddonsResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function upgradeClusterAddonsEx(clusterId: string, request: UpgradeClusterAddonsRequest, runtime: Util.RuntimeOptions): UpgradeClusterAddonsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/components/upgrade`, null, request.headers, request.body, runtime);
}

async function upgradeClusterAddons(clusterId: string, request: UpgradeClusterAddonsRequest): UpgradeClusterAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeClusterAddonsEx(clusterId, request, runtime);
}

model DescribeClusterAddonsVersionRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeClusterAddonsVersionResponseBody = {
  template: string(name='template', description='template'),
  nextVersion: string(name='next_version', description='next_version'),
  canUpgrade: boolean(name='can_upgrade', description='can_upgrade'),
  componentName: string(name='component_name', description='component_name'),
  version: string(name='version', description='version'),
  changed: string(name='changed', description='changed'),
  message: string(name='message', description='message'),
  required: boolean(name='required', description='required'),
}

model DescribeClusterAddonsVersionResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterAddonsVersionResponseBody(name='body', description='body'),
}

async function describeClusterAddonsVersionEx(clusterId: string, request: DescribeClusterAddonsVersionRequest, runtime: Util.RuntimeOptions): DescribeClusterAddonsVersionResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/${clusterId}/components/version`, null, request.headers, null, runtime);
}

async function describeClusterAddonsVersion(clusterId: string, request: DescribeClusterAddonsVersionRequest): DescribeClusterAddonsVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterAddonsVersionEx(clusterId, request, runtime);
}

model DescribeClusterAddonUpgradeStatusRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeClusterAddonUpgradeStatusResponseBody = {
  template: string(name='template', description='template'),
  canUpgrade: boolean(name='can_upgrade', description='can_upgrade'),
  addonInfo: {
    message: string(name='message', description='message'),
    category: string(name='category', description='category'),
    yaml: string(name='yaml', description='yaml'),
    componentName: string(name='component_name', description='component_name'),
    version: string(name='version', description='version'),
  }(name='addon_info', description='addon_info'),
}

model DescribeClusterAddonUpgradeStatusResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterAddonUpgradeStatusResponseBody(name='body', description='body'),
}

async function describeClusterAddonUpgradeStatusEx(clusterId: string, componentId: string, request: DescribeClusterAddonUpgradeStatusRequest, runtime: Util.RuntimeOptions): DescribeClusterAddonUpgradeStatusResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/${clusterId}/components/${componentId}/upgradestatus`, null, request.headers, null, runtime);
}

async function describeClusterAddonUpgradeStatus(clusterId: string, componentId: string, request: DescribeClusterAddonUpgradeStatusRequest): DescribeClusterAddonUpgradeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterAddonUpgradeStatusEx(clusterId, componentId, request, runtime);
}

model DeleteClusterNodesBody = {
  releaseNode?: string(name='release_node', description='release_node'),
  nodes: [ string ](name='nodes', description='nodes'),
}

model DeleteClusterNodesRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: DeleteClusterNodesBody(name='body', description='body'),
}

model DeleteClusterNodesResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model DeleteClusterNodesResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DeleteClusterNodesResponseBody(name='body', description='body'),
}

async function deleteClusterNodesEx(clusterId: string, request: DeleteClusterNodesRequest, runtime: Util.RuntimeOptions): DeleteClusterNodesResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/nodes`, null, request.headers, request.body, runtime);
}

async function deleteClusterNodes(clusterId: string, request: DeleteClusterNodesRequest): DeleteClusterNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterNodesEx(clusterId, request, runtime);
}

model DeleteTemplateRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DeleteTemplateResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function deleteTemplateEx(templateId: string, request: DeleteTemplateRequest, runtime: Util.RuntimeOptions): DeleteTemplateResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'DELETE', 'AK', `/templates/${templateId}`, null, request.headers, null, runtime);
}

async function deleteTemplate(templateId: string, request: DeleteTemplateRequest): DeleteTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTemplateEx(templateId, request, runtime);
}

model DescribeClusterUserKubeconfigQuery = {
  privateIpAddress?: boolean(name='PrivateIpAddress', description='PrivateIpAddress'),
}

model DescribeClusterUserKubeconfigRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  query?: DescribeClusterUserKubeconfigQuery(name='query', description='query'),
}

model DescribeClusterUserKubeconfigResponseBody = {
  config: string(name='config', description='config'),
}

model DescribeClusterUserKubeconfigResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterUserKubeconfigResponseBody(name='body', description='body'),
}

async function describeClusterUserKubeconfigEx(clusterId: string, request: DescribeClusterUserKubeconfigRequest, runtime: Util.RuntimeOptions): DescribeClusterUserKubeconfigResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/k8s/${clusterId}/user_config`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeClusterUserKubeconfig(clusterId: string, request: DescribeClusterUserKubeconfigRequest): DescribeClusterUserKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterUserKubeconfigEx(clusterId, request, runtime);
}

model DescribeClusterNodesQuery = {
  pageSize?: string(name='pageSize', description='pageSize'),
  pageNumber?: string(name='pageNumber', description='pageNumber'),
  nodepoolId?: string(name='nodepool_id', description='nodepool_id'),
  state?: string(name='state', description='state'),
}

model DescribeClusterNodesRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  query?: DescribeClusterNodesQuery(name='query', description='query'),
}

model DescribeClusterNodesResponseBody = {
  nodes: {
    nodes: [
      {
        instanceId: string(name='instance_id', description='instance_id'),
        instanceRole: string(name='instance_role', description='instance_role'),
        instanceName: string(name='instance_name', description='instance_name'),
        hostName: string(name='host_name', description='host_name'),
        nodeName: string(name='node_name', description='node_name'),
        instanceType: string(name='instance_type', description='instance_type'),
        instanceChargeType: string(name='instance_charge_type', description='instance_charge_type'),
        imageId: string(name='image_id', description='image_id'),
        instanceTypeFamily: string(name='instance_type_family', description='instance_type_family'),
        dockerVersion: string(name='docker_version', description='docker_version'),
        agentVersion: string(name='agent_version', description='agent_version'),
        isLeader: boolean(name='is_leader', description='is_leader'),
        containers: integer(name='containers', description='containers'),
        isAliyunNode: boolean(name='is_aliyun_node', description='is_aliyun_node'),
        state: string(name='state', description='state'),
        nodepoolId: string(name='nodepool_id', description='nodepool_id'),
        errorMessage: string(name='error_message', description='error_message'),
        ipAddress: {
          ip: [ string ](name='ip', description='ip'),
        }(name='ip_address', description='ip_address'),
      }
    ](name='nodes', description='nodes'),
  }(name='nodes', description='nodes'),
  page: {
    totalCount: integer(name='total_count', description='total_count'),
    pageNumber: integer(name='page_number', description='page_number'),
    pageSize: integer(name='page_size', description='page_size'),
  }(name='page', description='page'),
}

model DescribeClusterNodesResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterNodesResponseBody(name='body', description='body'),
}

async function describeClusterNodesEx(clusterId: string, request: DescribeClusterNodesRequest, runtime: Util.RuntimeOptions): DescribeClusterNodesResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/${clusterId}/nodes`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeClusterNodes(clusterId: string, request: DescribeClusterNodesRequest): DescribeClusterNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterNodesEx(clusterId, request, runtime);
}

model DescribeClusterLogsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeClusterLogsResponseBody = {
  clusterId: string(name='cluster_id', description='cluster_id'),
  clusterLog: string(name='cluster_log', description='cluster_log'),
  logLevel: string(name='log_level', description='log_level'),
  created: string(name='created', description='created'),
}

model DescribeClusterLogsResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterLogsResponseBody(name='body', description='body'),
}

async function describeClusterLogsEx(clusterId: string, request: DescribeClusterLogsRequest, runtime: Util.RuntimeOptions): DescribeClusterLogsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/${clusterId}/logs`, null, request.headers, null, runtime);
}

async function describeClusterLogs(clusterId: string, request: DescribeClusterLogsRequest): DescribeClusterLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterLogsEx(clusterId, request, runtime);
}

model AttachInstancesBody = {
  formatDisk?: boolean(name='format_disk', description='format_disk'),
  keepInstanceName?: boolean(name='keep_instance_name', description='keep_instance_name'),
  cpuPolicy?: string(name='cpu_policy', description='cpu_policy'),
  keyPair: string(name='key_pair', description='key_pair'),
  password: string(name='password', description='password'),
  tags: [
    {
      key?: string(name='key', description='key'),
      value?: string(name='value', description='value'),
    }
  ](name='tags', description='tags'),
  instances: [ string ](name='instances', description='instances'),
}

model AttachInstancesRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: AttachInstancesBody(name='body', description='body'),
}

model AttachInstancesResponseBody = {
  taskId: string(name='task_id', description='task_id'),
  list: [
    {
      code: string(name='code', description='code'),
      instanceId: string(name='instanceId', description='instanceId'),
      message: string(name='message', description='message'),
    }
  ](name='list', description='list'),
}

model AttachInstancesResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: AttachInstancesResponseBody(name='body', description='body'),
}

async function attachInstancesEx(clusterId: string, request: AttachInstancesRequest, runtime: Util.RuntimeOptions): AttachInstancesResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/attach`, null, request.headers, request.body, runtime);
}

async function attachInstances(clusterId: string, request: AttachInstancesRequest): AttachInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachInstancesEx(clusterId, request, runtime);
}

model DescribeTemplatesQuery = {
  templateType?: string(name='template_type', description='template_type'),
}

model DescribeTemplatesRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  query?: DescribeTemplatesQuery(name='query', description='query'),
}

model DescribeTemplatesResponseBody = {
  template: string(name='template', description='template'),
  acl: string(name='acl', description='acl'),
  name: string(name='name', description='name'),
  tags: string(name='tags', description='tags'),
  templateType: string(name='template_type', description='template_type'),
  description: string(name='description', description='description'),
}

model DescribeTemplatesResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeTemplatesResponseBody(name='body', description='body'),
}

async function describeTemplatesEx(request: DescribeTemplatesRequest, runtime: Util.RuntimeOptions): DescribeTemplatesResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/templates`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeTemplates(request: DescribeTemplatesRequest): DescribeTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTemplatesEx(request, runtime);
}

model CreateTemplateBody = {
  name: string(name='name', description='name'),
  template: string(name='template', description='template'),
  tags?: string(name='tags', description='tags'),
  templateType?: string(name='template_type', description='template_type'),
}

model CreateTemplateRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: CreateTemplateBody(name='body', description='body'),
}

model CreateTemplateResponseBody = {
  templateId: string(name='template_id', description='template_id'),
}

model CreateTemplateResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: CreateTemplateResponseBody(name='body', description='body'),
}

async function createTemplateEx(request: CreateTemplateRequest, runtime: Util.RuntimeOptions): CreateTemplateResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/templates`, null, request.headers, request.body, runtime);
}

async function createTemplate(request: CreateTemplateRequest): CreateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTemplateEx(request, runtime);
}

model CreateClusterBody = {
  clusterType: string(name='cluster_type', description='cluster_type'),
  name: string(name='name', description='name'),
  regionId: string(name='region_id', description='region_id'),
  kubernetesVersion?: string(name='kubernetes_version', description='kubernetes_version'),
  snatEntry: boolean(name='snat_entry', description='snat_entry'),
  endpointPublicAccess?: boolean(name='endpoint_public_access', description='endpoint_public_access'),
  sshFlags?: boolean(name='ssh_flags', description='ssh_flags'),
  cloudMonitorFlags?: boolean(name='cloud_monitor_flags', description='cloud_monitor_flags'),
  deletionProtection?: boolean(name='deletion_protection', description='deletion_protection'),
  nodeCidrMask?: string(name='node_cidr_mask', description='node_cidr_mask'),
  proxyMode?: string(name='proxy_mode', description='proxy_mode'),
  osType?: string(name='os_type', description='os_type'),
  platform?: string(name='platform', description='platform'),
  nodePortRange?: string(name='node_port_range', description='node_port_range'),
  keyPair: string(name='key_pair', description='key_pair'),
  loginPassword: string(name='login_password', description='login_password'),
  masterInstanceChargeType?: string(name='master_instance_charge_type', description='master_instance_charge_type'),
  workerInstanceChargeType?: string(name='worker_instance_charge_type', description='worker_instance_charge_type'),
  masterPeriod?: integer(name='master_period', description='master_period'),
  workerPeriod?: integer(name='worker_period', description='worker_period'),
  masterPeriodUnit?: string(name='master_period_unit', description='master_period_unit'),
  workerPeriodUnit?: string(name='worker_period_unit', description='worker_period_unit'),
  masterAutoRenew?: boolean(name='master_auto_renew', description='master_auto_renew'),
  masterAutoRenewPeriod?: integer(name='master_auto_renew_period', description='master_auto_renew_period'),
  workerAutoRenew?: boolean(name='worker_auto_renew', description='worker_auto_renew'),
  workerAutoRenewPeriod?: integer(name='worker_auto_renew_period', description='worker_auto_renew_period'),
  cpuPolicy?: string(name='cpu_policy', description='cpu_policy'),
  masterCount?: integer(name='master_count', description='master_count'),
  masterSystemDiskCategory: string(name='master_system_disk_category', description='master_system_disk_category'),
  masterSystemDiskSize: integer(name='master_system_disk_size', description='master_system_disk_size'),
  runtime?: map[string]any(name='runtime', description='runtime'),
  numOfNodes: integer(name='num_of_nodes', description='num_of_nodes'),
  workerSystemDiskCategory: string(name='worker_system_disk_category', description='worker_system_disk_category'),
  workerSystemDiskSize: integer(name='worker_system_disk_size', description='worker_system_disk_size'),
  workerDataDisk?: boolean(name='worker_data_disk', description='worker_data_disk'),
  vpcid?: string(name='vpcid', description='vpcid'),
  securityGroupId?: string(name='security_group_id', description='security_group_id'),
  containerCidr?: string(name='container_cidr', description='container_cidr'),
  serviceCidr?: string(name='service_cidr', description='service_cidr'),
  disableRollback?: boolean(name='disable_rollback', description='disable_rollback'),
  timeoutMins?: integer(name='timeout_mins', description='timeout_mins'),
  tags: [
    {
      key?: string(name='key', description='key'),
      value?: string(name='value', description='value'),
    }
  ](name='tags', description='tags'),
  addons: [
    {
      name?: string(name='name', description='name'),
      config?: string(name='config', description='config'),
    }
  ](name='addons', description='addons'),
  taints: [
    {
      key?: string(name='key', description='key'),
      value?: string(name='value', description='value'),
      effect?: string(name='effect', description='effect'),
    }
  ](name='taints', description='taints'),
  workerDataDisks: [
    {
      category?: string(name='category', description='category'),
      size?: string(name='size', description='size'),
      encrypted?: string(name='encrypted', description='encrypted'),
    }
  ](name='worker_data_disks', description='worker_data_disks'),
  masterVswitchIds: [ string ](name='master_vswitch_ids', description='master_vswitch_ids'),
  masterInstanceTypes: [ string ](name='master_instance_types', description='master_instance_types'),
  workerInstanceTypes: [ string ](name='worker_instance_types', description='worker_instance_types'),
  workerVswitchIds: [ string ](name='worker_vswitch_ids', description='worker_vswitch_ids'),
}

model CreateClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: CreateClusterBody(name='body', description='body'),
}

model CreateClusterResponseBody = {
  clusterId: string(name='cluster_id', description='cluster_id'),
  requestId: string(name='request_id', description='request_id'),
  taskId: string(name='task_id', description='task_id'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: CreateClusterResponseBody(name='body', description='body'),
}

async function createClusterEx(request: CreateClusterRequest, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters`, null, request.headers, request.body, runtime);
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterEx(request, runtime);
}

model ScaleClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model ScaleClusterResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model ScaleClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: ScaleClusterResponseBody(name='body', description='body'),
}

async function scaleClusterEx(clusterId: string, request: ScaleClusterRequest, runtime: Util.RuntimeOptions): ScaleClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'PUT', 'AK', `/clusters/${clusterId}`, null, request.headers, null, runtime);
}

async function scaleCluster(clusterId: string, request: ScaleClusterRequest): ScaleClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return scaleClusterEx(clusterId, request, runtime);
}

model DescribeClustersQuery = {
  name?: string(name='name', description='name'),
  clusterType?: string(name='clusterType', description='clusterType'),
}

model DescribeClustersRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  query?: DescribeClustersQuery(name='query', description='query'),
}

model DescribeClustersResponseBody = {
  name: string(name='name', description='name'),
  clusterId: string(name='cluster_id', description='cluster_id'),
  regionId: string(name='region_id', description='region_id'),
  state: string(name='state', description='state'),
  clusterType: string(name='cluster_type', description='cluster_type'),
  currentVersion: string(name='current_version', description='current_version'),
  metaData: string(name='meta_data', description='meta_data'),
  resourceGroupId: string(name='resource_group_id', description='resource_group_id'),
  vpcId: string(name='vpc_id', description='vpc_id'),
  vswitchId: string(name='vswitch_id', description='vswitch_id'),
  vswitchCidr: string(name='vswitch_cidr', description='vswitch_cidr'),
  dataDiskSize: integer(name='data_disk_size', description='data_disk_size'),
  dataDiskCategory: string(name='data_disk_category', description='data_disk_category'),
  securityGroupId: string(name='security_group_id', description='security_group_id'),
  zoneId: string(name='zone_id', description='zone_id'),
  networkMode: string(name='network_mode', description='network_mode'),
  masterUrl: string(name='master_url', description='master_url'),
  dockerVersion: string(name='docker_version', description='docker_version'),
  deletionProtection: boolean(name='deletion_protection', description='deletion_protection'),
  tags: [
    {
      key: string(name='key', description='key'),
      value: string(name='value', description='value'),
    }
  ](name='tags', description='tags'),
}

model DescribeClustersResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: [ DescribeClustersResponseBody ](name='body', description='body'),
}

async function describeClustersEx(request: DescribeClustersRequest, runtime: Util.RuntimeOptions): DescribeClustersResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeClusters(request: DescribeClustersRequest): DescribeClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClustersEx(request, runtime);
}

model DescribeClusterDetailRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeClusterDetailResponseBody = {
  name: string(name='name', description='name'),
  clusterId: string(name='cluster_id', description='cluster_id'),
  regionId: string(name='region_id', description='region_id'),
  state: string(name='state', description='state'),
  clusterType: string(name='cluster_type', description='cluster_type'),
  currentVersion: string(name='current_version', description='current_version'),
  metaData: string(name='meta_data', description='meta_data'),
  resourceGroupId: string(name='resource_group_id', description='resource_group_id'),
  instanceType: string(name='instance_type', description='instance_type'),
  vpcId: string(name='vpc_id', description='vpc_id'),
  vswitchId: string(name='vswitch_id', description='vswitch_id'),
  vswitchCidr: string(name='vswitch_cidr', description='vswitch_cidr'),
  dataDiskSize: integer(name='data_disk_size', description='data_disk_size'),
  dataDiskCategory: string(name='data_disk_category', description='data_disk_category'),
  securityGroupId: string(name='security_group_id', description='security_group_id'),
  zoneId: string(name='zone_id', description='zone_id'),
  networkMode: string(name='network_mode', description='network_mode'),
  dockerVersion: string(name='docker_version', description='docker_version'),
  deletionProtection: boolean(name='deletion_protection', description='deletion_protection'),
  tags: [
    {
      key: string(name='key', description='key'),
      value: string(name='value', description='value'),
    }
  ](name='tags', description='tags'),
}

model DescribeClusterDetailResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterDetailResponseBody(name='body', description='body'),
}

async function describeClusterDetailEx(clusterId: string, request: DescribeClusterDetailRequest, runtime: Util.RuntimeOptions): DescribeClusterDetailResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/${clusterId}`, null, request.headers, null, runtime);
}

async function describeClusterDetail(clusterId: string, request: DescribeClusterDetailRequest): DescribeClusterDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterDetailEx(clusterId, request, runtime);
}

model DeleteClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DeleteClusterResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DeleteClusterResponseBody(name='body', description='body'),
}

async function deleteClusterEx(clusterId: string, request: DeleteClusterRequest, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'DELETE', 'AK', `/clusters/${clusterId}`, null, request.headers, null, runtime);
}

async function deleteCluster(clusterId: string, request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterEx(clusterId, request, runtime);
}

model DescribeApiVersionRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeApiVersionResponseBody = {
  version: string(name='version', description='version'),
  build: string(name='build', description='build'),
  dockerVersion: string(name='docker_version', description='docker_version'),
  dockerRegionVersions: string(name='docker_region_versions', description='docker_region_versions'),
}

model DescribeApiVersionResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeApiVersionResponseBody(name='body', description='body'),
}

async function describeApiVersionEx(request: DescribeApiVersionRequest, runtime: Util.RuntimeOptions): DescribeApiVersionResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/version`, null, request.headers, null, runtime);
}

async function describeApiVersion(request: DescribeApiVersionRequest): DescribeApiVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeApiVersionEx(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
