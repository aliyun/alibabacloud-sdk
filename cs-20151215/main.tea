/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'cs.aliyuncs.com',
    cn-beijing-finance-1 = 'cs.aliyuncs.com',
    cn-beijing-finance-pop = 'cs.aliyuncs.com',
    cn-beijing-gov-1 = 'cs.aliyuncs.com',
    cn-beijing-nu16-b01 = 'cs.aliyuncs.com',
    cn-edge-1 = 'cs.aliyuncs.com',
    cn-fujian = 'cs.aliyuncs.com',
    cn-haidian-cm12-c01 = 'cs.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'cs.aliyuncs.com',
    cn-hangzhou-finance = 'cs-vpc.cn-hangzhou-finance.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'cs.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'cs.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'cs.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'cs.aliyuncs.com',
    cn-hangzhou-test-306 = 'cs.aliyuncs.com',
    cn-hongkong-finance-pop = 'cs.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'cs.aliyuncs.com',
    cn-qingdao-nebula = 'cs.aliyuncs.com',
    cn-shanghai-et15-b01 = 'cs.aliyuncs.com',
    cn-shanghai-et2-b01 = 'cs.aliyuncs.com',
    cn-shanghai-finance-1 = 'cs-vpc.cn-shanghai-finance-1.aliyuncs.com',
    cn-shanghai-inner = 'cs.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'cs.aliyuncs.com',
    cn-shenzhen-finance-1 = 'cs-vpc.cn-shenzhen-finance-1.aliyuncs.com',
    cn-shenzhen-inner = 'cs.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'cs.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'cs.aliyuncs.com',
    cn-wuhan = 'cs.aliyuncs.com',
    cn-yushanfang = 'cs.aliyuncs.com',
    cn-zhangbei = 'cs.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'cs.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'cs.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'cs.aliyuncs.com',
    eu-west-1-oxs = 'cs.aliyuncs.com',
    rus-west-1-pop = 'cs.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('cs', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model Addon {
  config?: string(name='config', description='插件配置参数。'),
  disabled?: boolean(name='disabled', description='是否禁止默认安装。true | false。'),
  name?: string(name='name', description='插件名称。'),
}

model DataDisk {
  autoSnapshotPolicyId?: string(name='auto_snapshot_policy_id', description='开启云盘备份时的自动备份策略。'),
  category?: string(name='category', description='数据盘类型'),
  encrypted?: string(name='encrypted', description='是否对数据盘加密。'),
  performanceLevel?: string(name='performance_level', description='数据盘磁盘性能，只针对ESSD磁盘生效'),
  size?: long(name='size', description='数据盘大小，取值范围：40～32767'),
}

model MaintenanceWindow {
  duration?: string(name='duration', description='维护时长。取值范围1～24，单位为小时。 默认值：3h。'),
  enable?: boolean(name='enable', description='是否开启维护窗口。默认值false。'),
  maintenanceTime?: string(name='maintenance_time', description='维护起始时间。Golang标准时间格式"15:04:05Z"。'),
  weeklyPeriod?: string(name='weekly_period', description='维护周期。取值范围为:Monday~Sunday，多个值用逗号分隔。 默认值：Thursday。'),
}

model Runtime {
  name?: string(name='name', description='容器运行时名称'),
  version?: string(name='version', description='容器运行时版本'),
}

model Tag {
  key?: string(name='key', description='key值。'),
  value?: string(name='value', description='value值。'),
}

model Taint {
  effect?: string(name='effect', description='污点生效策略。'),
  key?: string(name='key', description='key值。'),
  value?: string(name='value', description='value值。'),
}

model AttachInstancesRequest {
  cpuPolicy?: string(name='cpu_policy', description='CPU亲和策略。'),
  formatDisk?: boolean(name='format_disk', description='是否格式化数据盘。'),
  imageId?: string(name='image_id', description='自定义镜像ID。'),
  instances?: [ string ](name='instances', description='实例列表。'),
  isEdgeWorker?: boolean(name='is_edge_worker', description='是否为边缘节点。'),
  keepInstanceName?: boolean(name='keep_instance_name', description='是否保留实例名称。'),
  keyPair?: string(name='key_pair', description='key_pair名称，与login_password二选一'),
  nodepoolId?: string(name='nodepool_id', description='节点池ID，欲将节点添加到哪个节点池中。。'),
  password?: string(name='password', description='password，与key_pair二选一。'),
  rdsInstances?: [ string ](name='rds_instances', description='RDS实例列表。'),
  runtime?: Runtime(name='runtime'),
  tags?: [
    Tag
  ](name='tags', description='节点标签。'),
  userData?: string(name='user_data', description='节点自定义数据。'),
}

model AttachInstancesResponseBody = {
  list?: [ 
    {
      code?: string(name='code', description='状态码。'),
      instanceId?: string(name='instanceId', description='实例ID。'),
      message?: string(name='message', description='添加结果描述。'),
    }
  ](name='list', description='节点信息列表。'),
  taskId?: string(name='task_id', description='任务ID。'),
}

model AttachInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: AttachInstancesResponseBody(name='body'),
}

async function attachInstances(ClusterId: string, request: AttachInstancesRequest): AttachInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return attachInstancesWithOptions(ClusterId, request, headers, runtime);
}

async function attachInstancesWithOptions(ClusterId: string, request: AttachInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AttachInstancesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.cpuPolicy)) {
    body['cpu_policy'] = request.cpuPolicy;
  }
  if (!Util.isUnset(request.formatDisk)) {
    body['format_disk'] = request.formatDisk;
  }
  if (!Util.isUnset(request.imageId)) {
    body['image_id'] = request.imageId;
  }
  if (!Util.isUnset(request.instances)) {
    body['instances'] = request.instances;
  }
  if (!Util.isUnset(request.isEdgeWorker)) {
    body['is_edge_worker'] = request.isEdgeWorker;
  }
  if (!Util.isUnset(request.keepInstanceName)) {
    body['keep_instance_name'] = request.keepInstanceName;
  }
  if (!Util.isUnset(request.keyPair)) {
    body['key_pair'] = request.keyPair;
  }
  if (!Util.isUnset(request.nodepoolId)) {
    body['nodepool_id'] = request.nodepoolId;
  }
  if (!Util.isUnset(request.password)) {
    body['password'] = request.password;
  }
  if (!Util.isUnset(request.rdsInstances)) {
    body['rds_instances'] = request.rdsInstances;
  }
  if (!Util.isUnset(request.runtime)) {
    body['runtime'] = request.runtime;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.userData)) {
    body['user_data'] = request.userData;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AttachInstances',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/attach`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CancelClusterUpgradeResponse = {
  headers: map[string]string(name='headers'),
}

async function cancelClusterUpgrade(ClusterId: string): CancelClusterUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelClusterUpgradeWithOptions(ClusterId, headers, runtime);
}

async function cancelClusterUpgradeWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): CancelClusterUpgradeResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CancelClusterUpgrade',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/clusters/${ClusterId}/upgrade/cancel`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model CancelComponentUpgradeResponse = {
  headers: map[string]string(name='headers'),
}

async function cancelComponentUpgrade(clusterId: string, componentId: string): CancelComponentUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelComponentUpgradeWithOptions(clusterId, componentId, headers, runtime);
}

async function cancelComponentUpgradeWithOptions(clusterId: string, componentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): CancelComponentUpgradeResponse {
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  componentId = OpenApiUtil.getEncodeParam(componentId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CancelComponentUpgrade',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/components/${componentId}/cancel`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model CancelWorkflowRequest {
  action?: string(name='action', description='执行的操作，目前只支持cancel。'),
}

model CancelWorkflowResponse = {
  headers: map[string]string(name='headers'),
}

async function cancelWorkflow(workflowName: string, request: CancelWorkflowRequest): CancelWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelWorkflowWithOptions(workflowName, request, headers, runtime);
}

async function cancelWorkflowWithOptions(workflowName: string, request: CancelWorkflowRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelWorkflowResponse {
  Util.validateModel(request);
  workflowName = OpenApiUtil.getEncodeParam(workflowName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.action)) {
    body['action'] = request.action;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CancelWorkflow',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/gs/workflow/${workflowName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model CreateAutoscalingConfigRequest {
  coolDownDuration?: string(name='cool_down_duration', description='静默时间，扩容出的节点，在静默时间过后，方可进入缩容判断'),
  gpuUtilizationThreshold?: string(name='gpu_utilization_threshold', description='GPU缩容阈值，节点上 Request 的资源与总资源量的比值'),
  scanInterval?: string(name='scan_interval', description='弹性灵敏度，判断伸缩的间隔时间'),
  unneededDuration?: string(name='unneeded_duration', description='缩容触发时延，节点缩容时需要连续满足触发时延所设定的时间，方可进行缩容'),
  utilizationThreshold?: string(name='utilization_threshold', description='缩容阈值，节点上 Request 的资源与总资源量的比值'),
}

model CreateAutoscalingConfigResponse = {
  headers: map[string]string(name='headers'),
}

async function createAutoscalingConfig(ClusterId: string, request: CreateAutoscalingConfigRequest): CreateAutoscalingConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAutoscalingConfigWithOptions(ClusterId, request, headers, runtime);
}

async function createAutoscalingConfigWithOptions(ClusterId: string, request: CreateAutoscalingConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAutoscalingConfigResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.coolDownDuration)) {
    body['cool_down_duration'] = request.coolDownDuration;
  }
  if (!Util.isUnset(request.gpuUtilizationThreshold)) {
    body['gpu_utilization_threshold'] = request.gpuUtilizationThreshold;
  }
  if (!Util.isUnset(request.scanInterval)) {
    body['scan_interval'] = request.scanInterval;
  }
  if (!Util.isUnset(request.unneededDuration)) {
    body['unneeded_duration'] = request.unneededDuration;
  }
  if (!Util.isUnset(request.utilizationThreshold)) {
    body['utilization_threshold'] = request.utilizationThreshold;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAutoscalingConfig',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/cluster/${ClusterId}/autoscale/config/`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model CreateClusterRequest {
  addons?: [
    Addon
  ](name='addons', description='集群组件配置'),
  apiAudiences?: string(name='api_audiences', description='合法的请求token身份，用于apiserver服务端认证请求token是否合法。'),
  cisEnabled?: boolean(name='cis_enabled', description='CIS安全加固'),
  cloudMonitorFlags?: boolean(name='cloud_monitor_flags', description='为ECS安装云监控'),
  clusterDomain?: string(name='cluster_domain', description='集群本地域名'),
  clusterSpec?: string(name='cluster_spec', description='托管版集群类型'),
  clusterType?: string(name='cluster_type', description='集群类型'),
  containerCidr?: string(name='container_cidr', description='POD网络网段'),
  controlplaneLogComponents?: [ string ](name='controlplane_log_components', description='需要采集日志的组件'),
  controlplaneLogProject?: string(name='controlplane_log_project', description='使用已有log project时，需要指定log project'),
  controlplaneLogTtl?: string(name='controlplane_log_ttl', description='控制平面日志'),
  cpuPolicy?: string(name='cpu_policy', description='CPU策略'),
  customSan?: string(name='custom_san', description='自定义证书SAN'),
  deletionProtection?: boolean(name='deletion_protection', description='集群删除保护'),
  disableRollback?: boolean(name='disable_rollback', description='失败回滚'),
  enableRrsa?: boolean(name='enable_rrsa', description='启用 RRSA 功能'),
  encryptionProviderKey?: string(name='encryption_provider_key', description='Secret落盘加密'),
  endpointPublicAccess?: boolean(name='endpoint_public_access', description='使用EIP暴露apiServer'),
  formatDisk?: boolean(name='format_disk', description='使用已有节点创建集群时，是否格式化已有实例的磁盘'),
  imageId?: string(name='image_id', description='自定义镜像'),
  imageType?: string(name='image_type', description='操作系统镜像类型'),
  instances?: [ string ](name='instances', description='使用已有节点创建集群时，已有实例列表'),
  isEnterpriseSecurityGroup?: boolean(name='is_enterprise_security_group', description='自动创建企业安全组'),
  keepInstanceName?: boolean(name='keep_instance_name', description='使用已有节点创建集群时，是否保留实例名称。'),
  keyPair?: string(name='key_pair', description='密钥对名称，和login_password二选一。'),
  kubernetesVersion?: string(name='kubernetes_version', description='集群版本'),
  loadBalancerSpec?: string(name='load_balancer_spec', description='负载均衡规格'),
  loggingType?: string(name='logging_type', description='ASK 集群开启日志服务'),
  loginPassword?: string(name='login_password', description='SSH登录密码。密码规则为8~30 个字符，且至少同时包含三项（大小写字母、数字和特殊符号），和key_pair二选一。'),
  masterAutoRenew?: boolean(name='master_auto_renew', description='集群Master节点是否自动续费'),
  masterAutoRenewPeriod?: long(name='master_auto_renew_period', description='集群Master节点自动续费时长'),
  masterCount?: long(name='master_count', description='集群Master节点数量'),
  masterInstanceChargeType?: string(name='master_instance_charge_type', description='集群Master节点付费类型'),
  masterInstanceTypes?: [ string ](name='master_instance_types', description='集群Master节点类型'),
  masterPeriod?: long(name='master_period', description='集群Master节点包年包月时长'),
  masterPeriodUnit?: string(name='master_period_unit', description='集群Master节点包年包月周期'),
  masterSystemDiskCategory?: string(name='master_system_disk_category', description='集群Master节点系统盘类型'),
  masterSystemDiskPerformanceLevel?: string(name='master_system_disk_performance_level', description='Master节点系统盘磁盘性能，只针对ESSD磁盘生效'),
  masterSystemDiskSize?: long(name='master_system_disk_size', description='集群Master节点系统盘大小，至少40'),
  masterSystemDiskSnapshotPolicyId?: string(name='master_system_disk_snapshot_policy_id', description='集群Master节点自动快照备份策略'),
  masterVswitchIds?: [ string ](name='master_vswitch_ids', description='集群Master节点使用的虚拟交换机'),
  name?: string(name='name', description='集群名称。'),
  natGateway?: boolean(name='nat_gateway', description='使用自动创建专有网络创建ASK集群时，是否在vpc中创建Nat网关并配置SNAT规则。'),
  nodeCidrMask?: string(name='node_cidr_mask', description='节点IP数量'),
  nodeNameMode?: string(name='node_name_mode', description='自定义节点名称'),
  nodePortRange?: string(name='node_port_range', description='节点服务端口范围'),
  numOfNodes?: long(name='num_of_nodes', description='集群Worker节点数量'),
  osType?: string(name='os_type', description='操作系统平台类型'),
  platform?: string(name='platform', description='操作系统发行版'),
  podVswitchIds?: [ string ](name='pod_vswitch_ids', description='创建Terway网络类型的集群时，需要为pod指定单独的虚拟交换机'),
  profile?: string(name='profile', description='面向场景时的集群类型。  Default：非边缘场景集群。 Edge：边缘场景集群。'),
  proxyMode?: string(name='proxy_mode', description='Proxy代理模式，ipvs|iptables'),
  rdsInstances?: [ string ](name='rds_instances', description='RDS白名单'),
  regionId?: string(name='region_id', description='地域ID'),
  runtime?: Runtime(name='runtime'),
  securityGroupId?: string(name='security_group_id', description='安全组ID，和is_enterprise_security_group二选一'),
  serviceAccountIssuer?: string(name='service_account_issuer', description='serviceaccount token中的签发身份，即token payload中的iss字段。'),
  serviceCidr?: string(name='service_cidr', description='服务网络网段'),
  serviceDiscoveryTypes?: [ string ](name='service_discovery_types', description='创建ASK集群时，服务发现类型'),
  snatEntry?: boolean(name='snat_entry', description='若您集群内的节点、应用等需要访问公网，勾选该项后我们将为您创建 NAT 网关并自动配置 SNAT 规则'),
  socEnabled?: boolean(name='soc_enabled', description='等保安全加固'),
  sshFlags?: boolean(name='ssh_flags', description='允许公网ssh登录'),
  tags?: [
    Tag
  ](name='tags', description='集群标签'),
  taints?: [
    Taint
  ](name='taints', description='节点污点信息'),
  timeoutMins?: long(name='timeout_mins', description='集群创建超时时间'),
  timezone?: string(name='timezone', description='时区'),
  userCa?: string(name='user_ca', description='自定义集群CA'),
  userData?: string(name='user_data', description='节点自定义数据'),
  vpcid?: string(name='vpcid', description='集群专有网络ID。'),
  vswitchIds?: [ string ](name='vswitch_ids', description='集群节点所在虚拟交换机。'),
  workerAutoRenew?: boolean(name='worker_auto_renew', description='集群Worker节点到期是否自动续费'),
  workerAutoRenewPeriod?: long(name='worker_auto_renew_period', description='集群Worker节点自动续费时长'),
  workerDataDisks?: [ 
    {
      category?: string(name='category', description='集群Worker节点数据盘类型'),
      encrypted?: string(name='encrypted', description='集群Worker节点数据盘是否加密'),
      performanceLevel?: string(name='performance_level', description='集群Worker节点数据盘磁盘性能等级，仅对ESSD磁盘生效'),
      size?: string(name='size', description='集群Worker节点数据盘大小'),
    }
  ](name='worker_data_disks', description='集群Worker节点数据盘配置'),
  workerInstanceChargeType?: string(name='worker_instance_charge_type', description='集群Worker节点付费类型'),
  workerInstanceTypes?: [ string ](name='worker_instance_types', description='集群Worker节点类型'),
  workerPeriod?: long(name='worker_period', description='集群Worker节点包年包月时长'),
  workerPeriodUnit?: string(name='worker_period_unit', description='集群Worker节点包年包月周期'),
  workerSystemDiskCategory?: string(name='worker_system_disk_category', description='集群Worker节点系统盘类型'),
  workerSystemDiskPerformanceLevel?: string(name='worker_system_disk_performance_level', description='集群Worker节点磁盘性能，只对ESSD类型磁盘生效'),
  workerSystemDiskSize?: long(name='worker_system_disk_size', description='集群Worker节点系统盘大小'),
  workerSystemDiskSnapshotPolicyId?: string(name='worker_system_disk_snapshot_policy_id', description='集群Worker节点系统盘快照备份策略'),
  workerVswitchIds?: [ string ](name='worker_vswitch_ids', description='集群Worker节点所在虚拟交换机'),
  zoneId?: string(name='zone_id', description='使用自动创建专有网络创建ASK集群时，需要指定专有网络的可用区'),
}

model CreateClusterResponseBody = {
  clusterId?: string(name='cluster_id', description='集群ID。'),
  requestId?: string(name='request_id', description='请求ID。'),
  taskId?: string(name='task_id', description='任务ID。'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterResponseBody(name='body'),
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createClusterWithOptions(request, headers, runtime);
}

async function createClusterWithOptions(request: CreateClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.addons)) {
    body['addons'] = request.addons;
  }
  if (!Util.isUnset(request.apiAudiences)) {
    body['api_audiences'] = request.apiAudiences;
  }
  if (!Util.isUnset(request.cisEnabled)) {
    body['cis_enabled'] = request.cisEnabled;
  }
  if (!Util.isUnset(request.cloudMonitorFlags)) {
    body['cloud_monitor_flags'] = request.cloudMonitorFlags;
  }
  if (!Util.isUnset(request.clusterDomain)) {
    body['cluster_domain'] = request.clusterDomain;
  }
  if (!Util.isUnset(request.clusterSpec)) {
    body['cluster_spec'] = request.clusterSpec;
  }
  if (!Util.isUnset(request.clusterType)) {
    body['cluster_type'] = request.clusterType;
  }
  if (!Util.isUnset(request.containerCidr)) {
    body['container_cidr'] = request.containerCidr;
  }
  if (!Util.isUnset(request.controlplaneLogComponents)) {
    body['controlplane_log_components'] = request.controlplaneLogComponents;
  }
  if (!Util.isUnset(request.controlplaneLogProject)) {
    body['controlplane_log_project'] = request.controlplaneLogProject;
  }
  if (!Util.isUnset(request.controlplaneLogTtl)) {
    body['controlplane_log_ttl'] = request.controlplaneLogTtl;
  }
  if (!Util.isUnset(request.cpuPolicy)) {
    body['cpu_policy'] = request.cpuPolicy;
  }
  if (!Util.isUnset(request.customSan)) {
    body['custom_san'] = request.customSan;
  }
  if (!Util.isUnset(request.deletionProtection)) {
    body['deletion_protection'] = request.deletionProtection;
  }
  if (!Util.isUnset(request.disableRollback)) {
    body['disable_rollback'] = request.disableRollback;
  }
  if (!Util.isUnset(request.enableRrsa)) {
    body['enable_rrsa'] = request.enableRrsa;
  }
  if (!Util.isUnset(request.encryptionProviderKey)) {
    body['encryption_provider_key'] = request.encryptionProviderKey;
  }
  if (!Util.isUnset(request.endpointPublicAccess)) {
    body['endpoint_public_access'] = request.endpointPublicAccess;
  }
  if (!Util.isUnset(request.formatDisk)) {
    body['format_disk'] = request.formatDisk;
  }
  if (!Util.isUnset(request.imageId)) {
    body['image_id'] = request.imageId;
  }
  if (!Util.isUnset(request.imageType)) {
    body['image_type'] = request.imageType;
  }
  if (!Util.isUnset(request.instances)) {
    body['instances'] = request.instances;
  }
  if (!Util.isUnset(request.isEnterpriseSecurityGroup)) {
    body['is_enterprise_security_group'] = request.isEnterpriseSecurityGroup;
  }
  if (!Util.isUnset(request.keepInstanceName)) {
    body['keep_instance_name'] = request.keepInstanceName;
  }
  if (!Util.isUnset(request.keyPair)) {
    body['key_pair'] = request.keyPair;
  }
  if (!Util.isUnset(request.kubernetesVersion)) {
    body['kubernetes_version'] = request.kubernetesVersion;
  }
  if (!Util.isUnset(request.loadBalancerSpec)) {
    body['load_balancer_spec'] = request.loadBalancerSpec;
  }
  if (!Util.isUnset(request.loggingType)) {
    body['logging_type'] = request.loggingType;
  }
  if (!Util.isUnset(request.loginPassword)) {
    body['login_password'] = request.loginPassword;
  }
  if (!Util.isUnset(request.masterAutoRenew)) {
    body['master_auto_renew'] = request.masterAutoRenew;
  }
  if (!Util.isUnset(request.masterAutoRenewPeriod)) {
    body['master_auto_renew_period'] = request.masterAutoRenewPeriod;
  }
  if (!Util.isUnset(request.masterCount)) {
    body['master_count'] = request.masterCount;
  }
  if (!Util.isUnset(request.masterInstanceChargeType)) {
    body['master_instance_charge_type'] = request.masterInstanceChargeType;
  }
  if (!Util.isUnset(request.masterInstanceTypes)) {
    body['master_instance_types'] = request.masterInstanceTypes;
  }
  if (!Util.isUnset(request.masterPeriod)) {
    body['master_period'] = request.masterPeriod;
  }
  if (!Util.isUnset(request.masterPeriodUnit)) {
    body['master_period_unit'] = request.masterPeriodUnit;
  }
  if (!Util.isUnset(request.masterSystemDiskCategory)) {
    body['master_system_disk_category'] = request.masterSystemDiskCategory;
  }
  if (!Util.isUnset(request.masterSystemDiskPerformanceLevel)) {
    body['master_system_disk_performance_level'] = request.masterSystemDiskPerformanceLevel;
  }
  if (!Util.isUnset(request.masterSystemDiskSize)) {
    body['master_system_disk_size'] = request.masterSystemDiskSize;
  }
  if (!Util.isUnset(request.masterSystemDiskSnapshotPolicyId)) {
    body['master_system_disk_snapshot_policy_id'] = request.masterSystemDiskSnapshotPolicyId;
  }
  if (!Util.isUnset(request.masterVswitchIds)) {
    body['master_vswitch_ids'] = request.masterVswitchIds;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.natGateway)) {
    body['nat_gateway'] = request.natGateway;
  }
  if (!Util.isUnset(request.nodeCidrMask)) {
    body['node_cidr_mask'] = request.nodeCidrMask;
  }
  if (!Util.isUnset(request.nodeNameMode)) {
    body['node_name_mode'] = request.nodeNameMode;
  }
  if (!Util.isUnset(request.nodePortRange)) {
    body['node_port_range'] = request.nodePortRange;
  }
  if (!Util.isUnset(request.numOfNodes)) {
    body['num_of_nodes'] = request.numOfNodes;
  }
  if (!Util.isUnset(request.osType)) {
    body['os_type'] = request.osType;
  }
  if (!Util.isUnset(request.platform)) {
    body['platform'] = request.platform;
  }
  if (!Util.isUnset(request.podVswitchIds)) {
    body['pod_vswitch_ids'] = request.podVswitchIds;
  }
  if (!Util.isUnset(request.profile)) {
    body['profile'] = request.profile;
  }
  if (!Util.isUnset(request.proxyMode)) {
    body['proxy_mode'] = request.proxyMode;
  }
  if (!Util.isUnset(request.rdsInstances)) {
    body['rds_instances'] = request.rdsInstances;
  }
  if (!Util.isUnset(request.regionId)) {
    body['region_id'] = request.regionId;
  }
  if (!Util.isUnset(request.runtime)) {
    body['runtime'] = request.runtime;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    body['security_group_id'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.serviceAccountIssuer)) {
    body['service_account_issuer'] = request.serviceAccountIssuer;
  }
  if (!Util.isUnset(request.serviceCidr)) {
    body['service_cidr'] = request.serviceCidr;
  }
  if (!Util.isUnset(request.serviceDiscoveryTypes)) {
    body['service_discovery_types'] = request.serviceDiscoveryTypes;
  }
  if (!Util.isUnset(request.snatEntry)) {
    body['snat_entry'] = request.snatEntry;
  }
  if (!Util.isUnset(request.socEnabled)) {
    body['soc_enabled'] = request.socEnabled;
  }
  if (!Util.isUnset(request.sshFlags)) {
    body['ssh_flags'] = request.sshFlags;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.taints)) {
    body['taints'] = request.taints;
  }
  if (!Util.isUnset(request.timeoutMins)) {
    body['timeout_mins'] = request.timeoutMins;
  }
  if (!Util.isUnset(request.timezone)) {
    body['timezone'] = request.timezone;
  }
  if (!Util.isUnset(request.userCa)) {
    body['user_ca'] = request.userCa;
  }
  if (!Util.isUnset(request.userData)) {
    body['user_data'] = request.userData;
  }
  if (!Util.isUnset(request.vpcid)) {
    body['vpcid'] = request.vpcid;
  }
  if (!Util.isUnset(request.vswitchIds)) {
    body['vswitch_ids'] = request.vswitchIds;
  }
  if (!Util.isUnset(request.workerAutoRenew)) {
    body['worker_auto_renew'] = request.workerAutoRenew;
  }
  if (!Util.isUnset(request.workerAutoRenewPeriod)) {
    body['worker_auto_renew_period'] = request.workerAutoRenewPeriod;
  }
  if (!Util.isUnset(request.workerDataDisks)) {
    body['worker_data_disks'] = request.workerDataDisks;
  }
  if (!Util.isUnset(request.workerInstanceChargeType)) {
    body['worker_instance_charge_type'] = request.workerInstanceChargeType;
  }
  if (!Util.isUnset(request.workerInstanceTypes)) {
    body['worker_instance_types'] = request.workerInstanceTypes;
  }
  if (!Util.isUnset(request.workerPeriod)) {
    body['worker_period'] = request.workerPeriod;
  }
  if (!Util.isUnset(request.workerPeriodUnit)) {
    body['worker_period_unit'] = request.workerPeriodUnit;
  }
  if (!Util.isUnset(request.workerSystemDiskCategory)) {
    body['worker_system_disk_category'] = request.workerSystemDiskCategory;
  }
  if (!Util.isUnset(request.workerSystemDiskPerformanceLevel)) {
    body['worker_system_disk_performance_level'] = request.workerSystemDiskPerformanceLevel;
  }
  if (!Util.isUnset(request.workerSystemDiskSize)) {
    body['worker_system_disk_size'] = request.workerSystemDiskSize;
  }
  if (!Util.isUnset(request.workerSystemDiskSnapshotPolicyId)) {
    body['worker_system_disk_snapshot_policy_id'] = request.workerSystemDiskSnapshotPolicyId;
  }
  if (!Util.isUnset(request.workerVswitchIds)) {
    body['worker_vswitch_ids'] = request.workerVswitchIds;
  }
  if (!Util.isUnset(request.zoneId)) {
    body['zone_id'] = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateClusterNodePoolRequest {
  autoScaling?: {
    eipBandwidth?: long(name='eip_bandwidth', description='带宽峰值。'),
    eipInternetChargeType?: string(name='eip_internet_charge_type', description='EIP实例规格。'),
    enable?: boolean(name='enable', description='是否开启自动伸缩。'),
    isBondEip?: boolean(name='is_bond_eip', description='是否绑定EIP。'),
    maxInstances?: long(name='max_instances', description='最大实例数。'),
    minInstances?: long(name='min_instances', description='最小实例数。'),
    type?: string(name='type', description='扩容节点类型。'),
  }(name='auto_scaling', description='自动伸缩节点池配置。'),
  count?: long(name='count', description='节点数量。'),
  interconnectConfig?: {
    bandwidth?: long(name='bandwidth', description='边缘增强型节点池的网络带宽，单位M。'),
    ccnId?: string(name='ccn_id', description='边缘增强型节点池绑定的云连接网实例ID(CCNID)'),
    ccnRegionId?: string(name='ccn_region_id', description='边缘增强型节点池绑定的云连接网实例所属的区域'),
    cenId?: string(name='cen_id', description='边缘增强型节点池绑定的云企业网实例ID(CENID)'),
    improvedPeriod?: string(name='improved_period', description='边缘增强型节点池的购买时长，单位月'),
  }(name='interconnect_config', description='边缘节点池网络相关的配置。该值只对edge类型的节点池有意义'),
  interconnectMode?: string(name='interconnect_mode', description='边缘节点池的网络类型。basic：基础型；improved：增强型。该值只对edge类型的节点池有意义。'),
  kubernetesConfig?: {
    cmsEnabled?: boolean(name='cms_enabled', description='是否开启云监控。'),
    cpuPolicy?: string(name='cpu_policy', description='CPU管理策略。'),
    labels?: [
      Tag
    ](name='labels', description='节点标签。'),
    nodeNameMode?: string(name='node_name_mode', description='自定义节点名称'),
    runtime?: string(name='runtime', description='容器运行时。'),
    runtimeVersion?: string(name='runtime_version', description='容器运行时版本。'),
    taints?: [
      Taint
    ](name='taints', description='污点信息。'),
    userData?: string(name='user_data', description='节点自定义数据。'),
  }(name='kubernetes_config', description='集群配置'),
  management?: {
    autoRepair?: boolean(name='auto_repair', description='是否启用自动修复。'),
    enable?: boolean(name='enable', description='是否启用托管节点池。'),
    upgradeConfig?: {
      autoUpgrade?: boolean(name='auto_upgrade', description='是否启用自动升级'),
      maxUnavailable?: long(name='max_unavailable', description='最大不可用节点数量。'),
      surge?: long(name='surge', description='额外节点数量。'),
      surgePercentage?: long(name='surge_percentage', description='额外节点比例。和surge二选一。'),
    }(name='upgrade_config', description='自动升级配置。'),
  }(name='management', description='托管节点池配置。'),
  maxNodes?: long(name='max_nodes', description='边缘节点池允许容纳的最大节点数量. 节点池内可以容纳的最大节点数量，该参数大于等于0。0表示无额外限制(仅受限于集群整体可以容纳的节点数，节点池本身无额外限制)。边缘节点池该参数值往往大于0；ess类型节点池和默认的edge类型节点池该参数值为0'),
  nodepoolInfo?: {
    name?: string(name='name', description='节点池名称'),
    resourceGroupId?: string(name='resource_group_id', description='资源组ID。'),
    type?: string(name='type', description='节点池类型，对于边缘节点池来说，类型为"edge"'),
  }(name='nodepool_info', description='节点池配置'),
  scalingGroup?: {
    autoRenew?: boolean(name='auto_renew', description='节点是否开启自动续费'),
    autoRenewPeriod?: long(name='auto_renew_period', description='节点自动续费周期'),
    compensateWithOnDemand?: boolean(name='compensate_with_on_demand', description='当MultiAZPolicy取值为COST_OPTIMIZED时，如果因价格、库存等原因无法创建足够的抢占式实例，是否允许自动尝试创建按量实例满足ECS实例数量要求。取值范围：true：允许。false：不允许。默认值：true'),
    dataDisks?: [
      DataDisk
    ](name='data_disks', description='数据盘配置。'),
    deploymentsetId?: string(name='deploymentset_id', description='部署集ID。'),
    imageId?: string(name='image_id', description='自定义镜像。'),
    imageType?: string(name='image_type', description='操作系统镜像类型，和platform二选一'),
    instanceChargeType?: string(name='instance_charge_type', description='节点付费类型'),
    instanceTypes?: [ string ](name='instance_types', description='实例规格。'),
    internetChargeType?: string(name='internet_charge_type', description='节点公网IP网络计费类型'),
    internetMaxBandwidthOut?: long(name='internet_max_bandwidth_out', description='节点公网IP出带宽最大值，单位为Mbps（Mega bit per second），取值范围：1~100'),
    keyPair?: string(name='key_pair', description='密钥对名称，和login_password二选一。'),
    loginPassword?: string(name='login_password', description='SSH登录密码。'),
    multiAzPolicy?: string(name='multi_az_policy', description='多可用区伸缩组ECS实例扩缩容策略'),
    onDemandBaseCapacity?: long(name='on_demand_base_capacity', description='伸缩组所需要按量实例个数的最小值，取值范围：0~1000。当按量实例个数少于该值时，将优先创建按量实例。'),
    onDemandPercentageAboveBaseCapacity?: long(name='on_demand_percentage_above_base_capacity', description='伸缩组满足最小按量实例数（OnDemandBaseCapacity）要求后，超出的实例中按量实例应占的比例，取值范围：0～100。'),
    period?: long(name='period', description='节点包年包月时长。'),
    periodUnit?: string(name='period_unit', description='节点包年包月周期。'),
    platform?: string(name='platform', description='操作系统发行版，和image_type二选一'),
    rdsInstances?: [ string ](name='rds_instances', description='RDS实例列表。'),
    scalingPolicy?: string(name='scaling_policy', description='自动伸缩。'),
    securityGroupId?: string(name='security_group_id', description='安全组ID。'),
    securityGroupIds?: [ string ](name='security_group_ids', description='多安全组ID'),
    spotInstancePools?: long(name='spot_instance_pools', description='指定可用实例规格的个数，伸缩组将按成本最低的多个规格均衡创建抢占式实例。取值范围：1~10。'),
    spotInstanceRemedy?: boolean(name='spot_instance_remedy', description='是否开启补齐抢占式实例。开启后，当收到抢占式实例将被回收的系统消息时，伸缩组将尝试创建新的实例，替换掉将被回收的抢占式实例。'),
    spotPriceLimit?: [ 
      {
        instanceType?: string(name='instance_type', description='抢占实例规格。'),
        priceLimit?: string(name='price_limit', description='抢占实例单价。'),
      }
    ](name='spot_price_limit', description='抢占实例价格上限配置。'),
    spotStrategy?: string(name='spot_strategy', description='抢占式实例类型'),
    systemDiskCategory?: string(name='system_disk_category', description='节点系统盘类型。'),
    systemDiskPerformanceLevel?: string(name='system_disk_performance_level', description='节点系统盘磁盘性能，只针对ESSD磁盘生效'),
    systemDiskSize?: long(name='system_disk_size', description='节点系统盘大小。'),
    tags?: [ 
      {
        key?: string(name='key', description='key'),
        value?: string(name='value', description='value'),
      }
    ](name='tags', description='ECS标签'),
    vswitchIds?: [ string ](name='vswitch_ids', description='虚拟交换机ID。'),
  }(name='scaling_group', description='伸缩组配置'),
  teeConfig?: {
    teeEnable?: boolean(name='tee_enable', description='是否为加密计算节点池。'),
  }(name='tee_config', description='加密计算节点池配置。'),
}

model CreateClusterNodePoolResponseBody = {
  nodepoolId?: string(name='nodepool_id', description='节点池ID'),
}

model CreateClusterNodePoolResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterNodePoolResponseBody(name='body'),
}

async function createClusterNodePool(ClusterId: string, request: CreateClusterNodePoolRequest): CreateClusterNodePoolResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createClusterNodePoolWithOptions(ClusterId, request, headers, runtime);
}

async function createClusterNodePoolWithOptions(ClusterId: string, request: CreateClusterNodePoolRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateClusterNodePoolResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.autoScaling)) {
    body['auto_scaling'] = request.autoScaling;
  }
  if (!Util.isUnset(request.count)) {
    body['count'] = request.count;
  }
  if (!Util.isUnset(request.interconnectConfig)) {
    body['interconnect_config'] = request.interconnectConfig;
  }
  if (!Util.isUnset(request.interconnectMode)) {
    body['interconnect_mode'] = request.interconnectMode;
  }
  if (!Util.isUnset(request.kubernetesConfig)) {
    body['kubernetes_config'] = request.kubernetesConfig;
  }
  if (!Util.isUnset(request.management)) {
    body['management'] = request.management;
  }
  if (!Util.isUnset(request.maxNodes)) {
    body['max_nodes'] = request.maxNodes;
  }
  if (!Util.isUnset(request.nodepoolInfo)) {
    body['nodepool_info'] = request.nodepoolInfo;
  }
  if (!Util.isUnset(request.scalingGroup)) {
    body['scaling_group'] = request.scalingGroup;
  }
  if (!Util.isUnset(request.teeConfig)) {
    body['tee_config'] = request.teeConfig;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateClusterNodePool',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/nodepools`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateEdgeMachineRequest {
  hostname?: string(name='hostname', description='hostname'),
  model?: string(name='model', description='model'),
  sn?: string(name='sn', description='sn'),
}

model CreateEdgeMachineResponseBody = {
  edgeMachineId?: string(name='edge_machine_id', description='edge machine id'),
  requestId?: string(name='request_id', description='Id of the request'),
}

model CreateEdgeMachineResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEdgeMachineResponseBody(name='body'),
}

async function createEdgeMachine(request: CreateEdgeMachineRequest): CreateEdgeMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createEdgeMachineWithOptions(request, headers, runtime);
}

async function createEdgeMachineWithOptions(request: CreateEdgeMachineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateEdgeMachineResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.hostname)) {
    body['hostname'] = request.hostname;
  }
  if (!Util.isUnset(request.model)) {
    body['model'] = request.model;
  }
  if (!Util.isUnset(request.sn)) {
    body['sn'] = request.sn;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEdgeMachine',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/edge_machines`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateKubernetesTriggerRequest {
  action?: string(name='action', description='触发器行为'),
  clusterId?: string(name='cluster_id', description='集群ID。'),
  projectId?: string(name='project_id', description='项目名称。'),
  type?: string(name='type', description='触发器类型。默认deployment。'),
}

model CreateKubernetesTriggerResponseBody = {
  action?: string(name='action', description='触发器行为。'),
  clusterId?: string(name='cluster_id', description='集群ID。'),
  id?: string(name='id', description='触发器ID。'),
  projectId?: string(name='project_id', description='触发器项目名称。'),
  type?: string(name='type', description='触发器类型。默认值为 deployment 。'),
}

model CreateKubernetesTriggerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateKubernetesTriggerResponseBody(name='body'),
}

async function createKubernetesTrigger(request: CreateKubernetesTriggerRequest): CreateKubernetesTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createKubernetesTriggerWithOptions(request, headers, runtime);
}

async function createKubernetesTriggerWithOptions(request: CreateKubernetesTriggerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateKubernetesTriggerResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.action)) {
    body['action'] = request.action;
  }
  if (!Util.isUnset(request.clusterId)) {
    body['cluster_id'] = request.clusterId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['project_id'] = request.projectId;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateKubernetesTrigger',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/triggers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateTemplateRequest {
  description?: string(name='description', description='模板描述。'),
  name?: string(name='name', description='模板名称。'),
  tags?: string(name='tags', description='模板标签。'),
  template?: string(name='template', description='YAML格式的模板内容。'),
  templateType?: string(name='template_type', description='模板类型。默认值：kubernetes'),
}

model CreateTemplateResponseBody = {
  templateId?: string(name='template_id', description='模板ID。'),
}

model CreateTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTemplateResponseBody(name='body'),
}

async function createTemplate(request: CreateTemplateRequest): CreateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTemplateWithOptions(request, headers, runtime);
}

async function createTemplateWithOptions(request: CreateTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTemplateResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.template)) {
    body['template'] = request.template;
  }
  if (!Util.isUnset(request.templateType)) {
    body['template_type'] = request.templateType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTemplate',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/templates`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateTriggerRequest {
  action?: string(name='action', description='触发器行为'),
  clusterId?: string(name='cluster_id', description='集群ID。'),
  projectId?: string(name='project_id', description='项目名称。'),
  type?: string(name='type', description='触发器类型。默认deployment。'),
}

model CreateTriggerResponseBody = {
  action?: string(name='action', description='触发器行为。'),
  clusterId?: string(name='cluster_id', description='集群ID。'),
  id?: string(name='id', description='触发器ID。'),
  projectId?: string(name='project_id', description='触发器项目名称。'),
  type?: string(name='type', description='触发器类型。默认值为 deployment 。'),
}

model CreateTriggerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTriggerResponseBody(name='body'),
}

async function createTrigger(clusterId: string, request: CreateTriggerRequest): CreateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTriggerWithOptions(clusterId, request, headers, runtime);
}

async function createTriggerWithOptions(clusterId: string, request: CreateTriggerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTriggerResponse {
  Util.validateModel(request);
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.action)) {
    body['action'] = request.action;
  }
  if (!Util.isUnset(request.clusterId)) {
    body['cluster_id'] = request.clusterId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['project_id'] = request.projectId;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTrigger',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/triggers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteClusterRequest {
  keepSlb?: boolean(name='keep_slb', description='是否保留SLB。  true：保留 false：不保留 默认值：false。'),
  retainAllResources?: boolean(name='retain_all_resources', description='是否保留所有资源,如果设置了该值，将会忽略retain_resources。  true：保留 false：不保留 默认值：fase。'),
  retainResources?: [ string ](name='retain_resources', description='要保留的资源列表。'),
}

model DeleteClusterShrinkRequest {
  keepSlb?: boolean(name='keep_slb', description='是否保留SLB。  true：保留 false：不保留 默认值：false。'),
  retainAllResources?: boolean(name='retain_all_resources', description='是否保留所有资源,如果设置了该值，将会忽略retain_resources。  true：保留 false：不保留 默认值：fase。'),
  retainResourcesShrink?: string(name='retain_resources', description='要保留的资源列表。'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteCluster(ClusterId: string, request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteClusterWithOptions(ClusterId, request, headers, runtime);
}

async function deleteClusterWithOptions(ClusterId: string, tmpReq: DeleteClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(tmpReq);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var request = new DeleteClusterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.retainResources)) {
    request.retainResourcesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.retainResources, 'retain_resources', 'json');
  }
  var query : map[string]any= {};
  if (!Util.isUnset(request.keepSlb)) {
    query['keep_slb'] = request.keepSlb;
  }
  if (!Util.isUnset(request.retainAllResources)) {
    query['retain_all_resources'] = request.retainAllResources;
  }
  if (!Util.isUnset(request.retainResourcesShrink)) {
    query['retain_resources'] = request.retainResourcesShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteClusterNodepoolResponseBody = {
  requestId?: string(name='request_id', description='请求ID'),
}

model DeleteClusterNodepoolResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterNodepoolResponseBody(name='body'),
}

async function deleteClusterNodepool(ClusterId: string, NodepoolId: string): DeleteClusterNodepoolResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteClusterNodepoolWithOptions(ClusterId, NodepoolId, headers, runtime);
}

async function deleteClusterNodepoolWithOptions(ClusterId: string, NodepoolId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteClusterNodepoolResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  NodepoolId = OpenApiUtil.getEncodeParam(NodepoolId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteClusterNodepool',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/nodepools/${NodepoolId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteClusterNodesRequest {
  drainNode?: boolean(name='drain_node', description='是否自动排空节点上的Pod。'),
  nodes?: [ string ](name='nodes', description='移除节点列表。'),
  releaseNode?: boolean(name='release_node', description='是否同时释放 ECS'),
}

model DeleteClusterNodesResponseBody = {
  clusterId?: string(name='cluster_id', description='集群ID'),
  requestId?: string(name='request_id', description='请求ID'),
  taskId?: string(name='task_id', description='任务ID'),
}

model DeleteClusterNodesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterNodesResponseBody(name='body'),
}

async function deleteClusterNodes(ClusterId: string, request: DeleteClusterNodesRequest): DeleteClusterNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteClusterNodesWithOptions(ClusterId, request, headers, runtime);
}

async function deleteClusterNodesWithOptions(ClusterId: string, request: DeleteClusterNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteClusterNodesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.drainNode)) {
    body['drain_node'] = request.drainNode;
  }
  if (!Util.isUnset(request.nodes)) {
    body['nodes'] = request.nodes;
  }
  if (!Util.isUnset(request.releaseNode)) {
    body['release_node'] = request.releaseNode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteClusterNodes',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/nodes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteEdgeMachineRequest {
  force?: string(name='force', description='whether force delete'),
}

model DeleteEdgeMachineResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteEdgeMachine(edgeMachineid: string, request: DeleteEdgeMachineRequest): DeleteEdgeMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEdgeMachineWithOptions(edgeMachineid, request, headers, runtime);
}

async function deleteEdgeMachineWithOptions(edgeMachineid: string, request: DeleteEdgeMachineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteEdgeMachineResponse {
  Util.validateModel(request);
  edgeMachineid = OpenApiUtil.getEncodeParam(edgeMachineid);
  var query : map[string]any= {};
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEdgeMachine',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/edge_machines/[edge_machineid]`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteKubernetesTriggerResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteKubernetesTrigger(Id: string): DeleteKubernetesTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteKubernetesTriggerWithOptions(Id, headers, runtime);
}

async function deleteKubernetesTriggerWithOptions(Id: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteKubernetesTriggerResponse {
  Id = OpenApiUtil.getEncodeParam(Id);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteKubernetesTrigger',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/triggers/revoke/${Id}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeletePolicyInstanceRequest {
  instanceName?: string(name='instance_name', description='策略规则实例id'),
}

model DeletePolicyInstanceResponseBody = {
  instances?: [ string ](name='instances', description='策略实例列表'),
}

model DeletePolicyInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePolicyInstanceResponseBody(name='body'),
}

async function deletePolicyInstance(clusterId: string, policyName: string, request: DeletePolicyInstanceRequest): DeletePolicyInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePolicyInstanceWithOptions(clusterId, policyName, request, headers, runtime);
}

async function deletePolicyInstanceWithOptions(clusterId: string, policyName: string, request: DeletePolicyInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePolicyInstanceResponse {
  Util.validateModel(request);
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  policyName = OpenApiUtil.getEncodeParam(policyName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceName)) {
    query['instance_name'] = request.instanceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePolicyInstance',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/policies/${policyName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteTemplateResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteTemplate(TemplateId: string): DeleteTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTemplateWithOptions(TemplateId, headers, runtime);
}

async function deleteTemplateWithOptions(TemplateId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTemplateResponse {
  TemplateId = OpenApiUtil.getEncodeParam(TemplateId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteTemplate',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/templates/${TemplateId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteTriggerResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteTrigger(clusterId: string, Id: string): DeleteTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTriggerWithOptions(clusterId, Id, headers, runtime);
}

async function deleteTriggerWithOptions(clusterId: string, Id: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTriggerResponse {
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  Id = OpenApiUtil.getEncodeParam(Id);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteTrigger',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/[cluster_id]/triggers/[Id]`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeployPolicyInstanceRequest {
  action?: string(name='action', description='规则治理动作'),
  namespace?: string(name='namespace', description='策略实例实施范围'),
  parameters?: map[string]any(name='parameters', description='当前规则实例的配置参数'),
}

model DeployPolicyInstanceResponseBody = {
  instances?: [ string ](name='instances', description='策略实例列表'),
}

model DeployPolicyInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeployPolicyInstanceResponseBody(name='body'),
}

async function deployPolicyInstance(clusterId: string, policyName: string, request: DeployPolicyInstanceRequest): DeployPolicyInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deployPolicyInstanceWithOptions(clusterId, policyName, request, headers, runtime);
}

async function deployPolicyInstanceWithOptions(clusterId: string, policyName: string, request: DeployPolicyInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeployPolicyInstanceResponse {
  Util.validateModel(request);
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  policyName = OpenApiUtil.getEncodeParam(policyName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.action)) {
    body['action'] = request.action;
  }
  if (!Util.isUnset(request.namespace)) {
    body['namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.parameters)) {
    body['parameters'] = request.parameters;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeployPolicyInstance',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/policies/${policyName}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescirbeWorkflowResponseBody = {
  createTime?: string(name='create_time', description='工作流创建时间。'),
  duration?: string(name='duration', description='工作流经过时长。'),
  finishTime?: string(name='finish_time', description='任务结束时间。'),
  inputDataSize?: string(name='input_data_size', description='输入数据大小。'),
  jobName?: string(name='job_name', description='工作流名称。'),
  jobNamespace?: string(name='job_namespace', description='工作流所在命名空间。'),
  outputDataSize?: string(name='output_data_size', description='输出数据大小。'),
  status?: string(name='status', description='工作流当前状态。'),
  totalBases?: string(name='total_bases', description='碱基对个数。'),
  totalReads?: string(name='total_reads', description='Reads个数。'),
  userInputData?: string(name='user_input_data', description='用户输入参数。'),
}

model DescirbeWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: DescirbeWorkflowResponseBody(name='body'),
}

async function descirbeWorkflow(workflowName: string): DescirbeWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return descirbeWorkflowWithOptions(workflowName, headers, runtime);
}

async function descirbeWorkflowWithOptions(workflowName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescirbeWorkflowResponse {
  workflowName = OpenApiUtil.getEncodeParam(workflowName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescirbeWorkflow',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/gs/workflow/${workflowName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeAddonsRequest {
  clusterType?: string(name='cluster_type', description='集群类型。  - Kubernetes: 专有版集群。 - ManagedKubernetes：托管版集群。 - Ask：Serverless 集群。 - ExternalKubernetes：注册到ACK的外部集群。'),
  region?: string(name='region', description='地域ID。'),
}

model DescribeAddonsResponseBody = {
  componentGroups?: [ 
    {
      groupName?: string(name='group_name', description='组件组名称。'),
      items?: [ 
        {
          name?: string(name='name', description='组件名称。'),
        }
      ](name='items', description='组件列表'),
    }
  ](name='ComponentGroups', description='组件分组信息，例如：存储类组件，网络组件等。'),
  standardComponents?: map[string]StandardComponentsValue(name='StandardComponents', description='标准组件信息，包含各个组件的描述信息。'),
}

model DescribeAddonsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAddonsResponseBody(name='body'),
}

async function describeAddons(request: DescribeAddonsRequest): DescribeAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeAddonsWithOptions(request, headers, runtime);
}

async function describeAddonsWithOptions(request: DescribeAddonsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeAddonsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterType)) {
    query['cluster_type'] = request.clusterType;
  }
  if (!Util.isUnset(request.region)) {
    query['region'] = request.region;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAddons',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/components/metadata`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterAddonMetadataResponseBody = {
  configSchema?: string(name='config_schema', description='组件参数Schema'),
  name?: string(name='name', description='组件名称'),
  version?: string(name='version', description='组件版本'),
}

model DescribeClusterAddonMetadataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterAddonMetadataResponseBody(name='body'),
}

async function describeClusterAddonMetadata(clusterId: string, componentId: string, version: string): DescribeClusterAddonMetadataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterAddonMetadataWithOptions(clusterId, componentId, version, headers, runtime);
}

async function describeClusterAddonMetadataWithOptions(clusterId: string, componentId: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterAddonMetadataResponse {
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  componentId = OpenApiUtil.getEncodeParam(componentId);
  version = OpenApiUtil.getEncodeParam(version);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterAddonMetadata',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/components/${componentId}/metadata`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterAddonUpgradeStatusResponse = {
  headers: map[string]string(name='headers'),
  body: object(name='body'),
}

async function describeClusterAddonUpgradeStatus(ClusterId: string, ComponentId: string): DescribeClusterAddonUpgradeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterAddonUpgradeStatusWithOptions(ClusterId, ComponentId, headers, runtime);
}

async function describeClusterAddonUpgradeStatusWithOptions(ClusterId: string, ComponentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterAddonUpgradeStatusResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ComponentId = OpenApiUtil.getEncodeParam(ComponentId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterAddonUpgradeStatus',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/components/${ComponentId}/upgradestatus`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterAddonsUpgradeStatusRequest {
  componentIds?: [ string ](name='componentIds', description='组件名称列表。'),
}

model DescribeClusterAddonsUpgradeStatusShrinkRequest {
  componentIdsShrink?: string(name='componentIds', description='组件名称列表。'),
}

model DescribeClusterAddonsUpgradeStatusResponse = {
  headers: map[string]string(name='headers'),
  body: object(name='body'),
}

async function describeClusterAddonsUpgradeStatus(ClusterId: string, request: DescribeClusterAddonsUpgradeStatusRequest): DescribeClusterAddonsUpgradeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterAddonsUpgradeStatusWithOptions(ClusterId, request, headers, runtime);
}

async function describeClusterAddonsUpgradeStatusWithOptions(ClusterId: string, tmpReq: DescribeClusterAddonsUpgradeStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterAddonsUpgradeStatusResponse {
  Util.validateModel(tmpReq);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var request = new DescribeClusterAddonsUpgradeStatusShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.componentIds)) {
    request.componentIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.componentIds, 'componentIds', 'json');
  }
  var query : map[string]any= {};
  if (!Util.isUnset(request.componentIdsShrink)) {
    query['componentIds'] = request.componentIdsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterAddonsUpgradeStatus',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/components/upgradestatus`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterAddonsVersionResponse = {
  headers: map[string]string(name='headers'),
  body: object(name='body'),
}

async function describeClusterAddonsVersion(ClusterId: string): DescribeClusterAddonsVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterAddonsVersionWithOptions(ClusterId, headers, runtime);
}

async function describeClusterAddonsVersionWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterAddonsVersionResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterAddonsVersion',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/components/version`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterAttachScriptsRequest {
  arch?: string(name='arch', description='节点CPU架构,支持amd64、arm、arm64。边缘托管集群专有字段。'),
  formatDisk?: boolean(name='format_disk', description='数据盘挂载'),
  keepInstanceName?: boolean(name='keep_instance_name', description='保留实例名称'),
  nodepoolId?: string(name='nodepool_id', description='节点池ID。将节点加入指定节点池。'),
  options?: string(name='options', description='边缘托管版集群节点的接入配置。'),
  rdsInstances?: [ string ](name='rds_instances', description='RDS白名单'),
}

model DescribeClusterAttachScriptsResponse = {
  headers: map[string]string(name='headers'),
  body: string(name='body'),
}

async function describeClusterAttachScripts(ClusterId: string, request: DescribeClusterAttachScriptsRequest): DescribeClusterAttachScriptsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterAttachScriptsWithOptions(ClusterId, request, headers, runtime);
}

async function describeClusterAttachScriptsWithOptions(ClusterId: string, request: DescribeClusterAttachScriptsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterAttachScriptsResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.arch)) {
    body['arch'] = request.arch;
  }
  if (!Util.isUnset(request.formatDisk)) {
    body['format_disk'] = request.formatDisk;
  }
  if (!Util.isUnset(request.keepInstanceName)) {
    body['keep_instance_name'] = request.keepInstanceName;
  }
  if (!Util.isUnset(request.nodepoolId)) {
    body['nodepool_id'] = request.nodepoolId;
  }
  if (!Util.isUnset(request.options)) {
    body['options'] = request.options;
  }
  if (!Util.isUnset(request.rdsInstances)) {
    body['rds_instances'] = request.rdsInstances;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterAttachScripts',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/attachscript`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'string',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterDetailResponseBody = {
  clusterId?: string(name='cluster_id', description='集群ID。'),
  clusterSpec?: string(name='cluster_spec', description='托管版集群类型，面向托管集群。  ack.pro.small：专业托管集群。 ack.standard ：标准托管集群。'),
  clusterType?: string(name='cluster_type', description='集群类型。'),
  created?: string(name='created', description='集群创建时间。'),
  currentVersion?: string(name='current_version', description='集群当前版本。'),
  deletionProtection?: boolean(name='deletion_protection', description='集群是否开启删除保护。'),
  dockerVersion?: string(name='docker_version', description='集群内Docker版本。'),
  externalLoadbalancerId?: string(name='external_loadbalancer_id', description='集群Ingress LB实例ID。'),
  initVersion?: string(name='init_version', description='集群初始化版本。'),
  maintenanceWindow?: MaintenanceWindow(name='maintenance_window'),
  masterUrl?: string(name='master_url', description='集群访问地址。'),
  metaData?: string(name='meta_data', description='集群元数据。'),
  name?: string(name='name', description='集群名称。'),
  networkMode?: string(name='network_mode', description='集群采用的网络类型，例如：VPC网络。'),
  nextVersion?: string(name='next_version', description='集群可升级版本。'),
  privateZone?: boolean(name='private_zone', description='集群是否启用用PrivateZone。  true：启用 false：不启用 默认值：false。'),
  profile?: string(name='profile', description='面向场景时的集群类型。  Default：非边缘场景集群。 Edge：边缘场景集群。'),
  regionId?: string(name='region_id', description='集群所在地域ID。'),
  resourceGroupId?: string(name='resource_group_id', description='集群资源组ID。'),
  securityGroupId?: string(name='security_group_id', description='集群安全组ID。'),
  size?: long(name='size', description='集群节点数量。'),
  state?: string(name='state', description='集群运行状态。'),
  subnetCidr?: string(name='subnet_cidr', description='Pod网络地址段，必须是有效的私有网段，即以下网段及其子网：10.0.0.0/8，172.16-31.0.0/12-16，192.168.0.0/16。不能与 VPC 及VPC 内已有 Kubernetes 集群使用的网段重复，创建成功后不能修改。  有关集群网络规划，请参见：[VPC下 Kubernetes 的网络地址段规划](https://help.aliyun.com/document_detail/～～86500～～)。'),
  tags?: [
    Tag
  ](name='tags', description='集群标签。'),
  updated?: string(name='updated', description='集群更新时间。'),
  vpcId?: string(name='vpc_id', description='集群使用的VPC ID。'),
  vswitchId?: string(name='vswitch_id', description='集群节点使用的虚拟交换机列表。'),
  workerRamRoleName?: string(name='worker_ram_role_name', description='Worker节点RAM角色名称。'),
  zoneId?: string(name='zone_id', description='集群所在地域内的可用区ID。'),
}

model DescribeClusterDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterDetailResponseBody(name='body'),
}

async function describeClusterDetail(ClusterId: string): DescribeClusterDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterDetailWithOptions(ClusterId, headers, runtime);
}

async function describeClusterDetailWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterDetailResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterDetail',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterLogsResponse = {
  headers: map[string]string(name='headers'),
  body: [ 
    {
      ID?: long(name='ID', description='日志ID。'),
      clusterId?: string(name='cluster_id', description='集群ID。'),
      clusterLog?: string(name='cluster_log', description='日志内容。'),
      logLevel?: string(name='log_level', description='日志等级。'),
      created?: string(name='created', description='日志创建时间。'),
      updated?: string(name='updated', description='日志更新时间。'),
    }
  ](name='body'),
}

async function describeClusterLogs(ClusterId: string): DescribeClusterLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterLogsWithOptions(ClusterId, headers, runtime);
}

async function describeClusterLogsWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterLogsResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterLogs',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/logs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterNamespacesResponse = {
  headers: map[string]string(name='headers'),
  body: [ string ](name='body'),
}

async function describeClusterNamespaces(ClusterId: string): DescribeClusterNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterNamespacesWithOptions(ClusterId, headers, runtime);
}

async function describeClusterNamespacesWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterNamespacesResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterNamespaces',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/k8s/${ClusterId}/namespaces`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterNodePoolDetailResponseBody = {
  autoScaling?: {
    eipBandwidth?: long(name='eip_bandwidth', description='EIP带宽峰值。'),
    eipInternetChargeType?: string(name='eip_internet_charge_type', description='EIP实例付费类型。'),
    enable?: boolean(name='enable', description='是否启用自动伸缩。'),
    isBondEip?: boolean(name='is_bond_eip', description='是否绑定EIP。'),
    maxInstances?: long(name='max_instances', description='最大实例数。'),
    minInstances?: long(name='min_instances', description='最小实例数。'),
    type?: string(name='type', description='扩容组类型'),
  }(name='auto_scaling', description='节点池自动伸缩信息。'),
  interconnectConfig?: {
    bandwidth?: long(name='bandwidth', description='边缘增强型节点池的网络带宽，单位M'),
    ccnId?: string(name='ccn_id', description='边缘增强型节点池绑定的云连接网实例ID(CCNID)'),
    ccnRegionId?: string(name='ccn_region_id', description='边缘增强型节点池绑定的云连接网实例所属的区域'),
    cenId?: string(name='cen_id', description='边缘增强型节点池绑定的云企业网实例ID(CENID)'),
    improvedPeriod?: string(name='improved_period', description='边缘增强型节点池的购买时长，单位月'),
  }(name='interconnect_config', description='边缘节点池网络相关的配置。该值只对edge类型的节点池有意义'),
  interconnectMode?: string(name='interconnect_mode', description='边缘节点池的网络类型。basic：基础型；improved：增强型。该值只对edge类型的节点池有意义'),
  kubernetesConfig?: {
    cmsEnabled?: boolean(name='cms_enabled', description='是否开启云监控'),
    cpuPolicy?: string(name='cpu_policy', description='CPU管理策略'),
    labels?: [
      Tag
    ](name='labels', description='节点标签。'),
    nodeNameMode?: string(name='node_name_mode', description='自定义节点名称'),
    runtime?: string(name='runtime', description='容器运行时'),
    runtimeVersion?: string(name='runtime_version', description='容器运行时版本。'),
    taints?: [
      Taint
    ](name='taints', description='污点配置。'),
    userData?: string(name='user_data', description='节点自定义数据'),
  }(name='kubernetes_config', description='节点池所属集群配置。'),
  management?: {
    autoRepair?: boolean(name='auto_repair', description='自动修复。'),
    enable?: boolean(name='enable', description='是否开启托管版节点池。'),
    upgradeConfig?: {
      autoUpgrade?: boolean(name='auto_upgrade', description='是否启用自动升级，自修复。'),
      maxUnavailable?: long(name='max_unavailable', description='最大不可用节点数量。'),
      surge?: long(name='surge', description='额外节点数量。'),
      surgePercentage?: long(name='surge_percentage', description='额外节点比例， 和surge 二选一。'),
    }(name='upgrade_config', description='自动升级配置。'),
  }(name='management', description='托管版节点池配置。'),
  maxNodes?: long(name='max_nodes', description='边缘节点池允许容纳的最大节点数量. 节点池内可以容纳的最大节点数量，该参数大于等于0。0表示无额外限制(仅受限于集群整体可以容纳的节点数，节点池本身无额外限制)。边缘节点池该参数值往往大于0；ess类型节点池和默认的edge类型节点池该参数值为0'),
  nodepoolInfo?: {
    created?: string(name='created', description='节点池创建时间。'),
    isDefault?: boolean(name='is_default', description='是否为默认节点池。'),
    name?: string(name='name', description='节点池名称。'),
    nodepoolId?: string(name='nodepool_id', description='节点池ID。'),
    regionId?: string(name='region_id', description='节点池所属地域ID。'),
    resourceGroupId?: string(name='resource_group_id', description='节点池所属资源组ID。'),
    type?: string(name='type', description='节点池类型。'),
    updated?: string(name='updated', description='节点池更新时间。'),
  }(name='nodepool_info', description='节点池详情。'),
  scalingGroup?: {
    autoRenew?: boolean(name='auto_renew', description='节点是否开启自动续费。'),
    autoRenewPeriod?: long(name='auto_renew_period', description='节点自动续费周期。'),
    compensateWithOnDemand?: boolean(name='compensate_with_on_demand', description='当MultiAZPolicy取值为COST_OPTIMIZED时，如果因价格、库存等原因无法创建足够的抢占式实例，是否允许自动尝试创建按量实例满足ECS实例数量要求。取值范围：true：允许。false：不允许。默认值：true'),
    dataDisks?: [
      DataDisk
    ](name='data_disks', description='数据盘配置。'),
    deploymentsetId?: string(name='deploymentset_id', description='部署集ID。'),
    imageId?: string(name='image_id', description='自定义镜像ID。'),
    instanceChargeType?: string(name='instance_charge_type', description='节点付费类型。'),
    instanceTypes?: [ string ](name='instance_types', description='节点ECS规格类型。'),
    internetChargeType?: string(name='internet_charge_type', description='节点公网IP网络计费类型'),
    internetMaxBandwidthOut?: long(name='internet_max_bandwidth_out', description='节点公网IP出带宽最大值，单位为Mbps（Mega bit per second），取值范围：1~100'),
    keyPair?: string(name='key_pair', description='密钥对名称'),
    loginPassword?: string(name='login_password', description='登录密码'),
    multiAzPolicy?: string(name='multi_az_policy', description='多可用区伸缩组ECS实例扩缩容策略'),
    onDemandBaseCapacity?: long(name='on_demand_base_capacity', description='伸缩组所需要按量实例个数的最小值，取值范围：0~1000。当按量实例个数少于该值时，将优先创建按量实例。'),
    onDemandPercentageAboveBaseCapacity?: long(name='on_demand_percentage_above_base_capacity', description='伸缩组满足最小按量实例数（OnDemandBaseCapacity）要求后，超出的实例中按量实例应占的比例，取值范围：0～100。'),
    period?: long(name='period', description='节点包年包月时长。'),
    periodUnit?: string(name='period_unit', description='节点付费周期。'),
    platform?: string(name='platform', description='操作系统发行版。取值： CentOS，AliyunLinux，Windows，WindowsCore。'),
    ramPolicy?: string(name='ram_policy', description='节点RAM 角色名称。'),
    rdsInstances?: [ string ](name='rds_instances', description='RDS实例列表。'),
    scalingGroupId?: string(name='scaling_group_id', description='扩容组ID。'),
    scalingPolicy?: string(name='scaling_policy', description='扩容策略。'),
    securityGroupId?: string(name='security_group_id', description='节点所属安全组ID。'),
    securityGroupIds?: [ string ](name='security_group_ids', description='节点池所属安全组ID列表。'),
    spotInstancePools?: long(name='spot_instance_pools', description='指定可用实例规格的个数，伸缩组将按成本最低的多个规格均衡创建抢占式实例。取值范围：1~10。'),
    spotInstanceRemedy?: boolean(name='spot_instance_remedy', description='是否开启补齐抢占式实例。开启后，当收到抢占式实例将被回收的系统消息时，伸缩组将尝试创建新的实例，替换掉将被回收的抢占式实例。'),
    spotPriceLimit?: [ 
      {
        instanceType?: string(name='instance_type', description='抢占式实例规格。'),
        priceLimit?: string(name='price_limit', description='单台实例上限价格，单位：元/小时。'),
      }
    ](name='spot_price_limit', description='抢占式实例价格上限配置。'),
    spotStrategy?: string(name='spot_strategy', description='抢占式实例类型'),
    systemDiskCategory?: string(name='system_disk_category', description='系统盘类型'),
    systemDiskPerformanceLevel?: string(name='system_disk_performance_level', description='节点系统盘磁盘性能，只针对ESSD磁盘生效'),
    systemDiskSize?: long(name='system_disk_size', description='系统盘大小'),
    tags?: [
      Tag
    ](name='tags', description='ECS标签'),
    vswitchIds?: [ string ](name='vswitch_ids', description='虚拟交换机ID。'),
  }(name='scaling_group', description='节点池扩容组信息。'),
  status?: {
    failedNodes?: long(name='failed_nodes', description='失败节点数。'),
    healthyNodes?: long(name='healthy_nodes', description='处于健康状态节点数。'),
    initialNodes?: long(name='initial_nodes', description='正在初始化节点数。'),
    offlineNodes?: long(name='offline_nodes', description='离线节点数量。'),
    removingNodes?: long(name='removing_nodes', description='正在被移除节点数。'),
    servingNodes?: long(name='serving_nodes', description='工作节点数量。'),
    state?: string(name='state', description='节点池状态。'),
    totalNodes?: long(name='total_nodes', description='总节点数。'),
  }(name='status', description='节点池状态。'),
  teeConfig?: {
    teeEnable?: boolean(name='tee_enable', description='是否为加密计算节点池。'),
  }(name='tee_config', description='加密计算节点池信息。'),
}

model DescribeClusterNodePoolDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterNodePoolDetailResponseBody(name='body'),
}

async function describeClusterNodePoolDetail(ClusterId: string, NodepoolId: string): DescribeClusterNodePoolDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterNodePoolDetailWithOptions(ClusterId, NodepoolId, headers, runtime);
}

async function describeClusterNodePoolDetailWithOptions(ClusterId: string, NodepoolId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterNodePoolDetailResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  NodepoolId = OpenApiUtil.getEncodeParam(NodepoolId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterNodePoolDetail',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/nodepools/${NodepoolId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterNodePoolsResponseBody = {
  nodepools?: [ 
    {
      autoScaling?: {
        eipBandwidth?: long(name='eip_bandwidth', description='EIP带宽峰值'),
        eipInternetChargeType?: string(name='eip_internet_charge_type', description='EIP实例计费方式'),
        enable?: boolean(name='enable', description='自动伸缩'),
        isBondEip?: boolean(name='is_bond_eip', description='是否绑定EIP'),
        maxInstances?: long(name='max_instances', description='最大节点数	'),
        minInstances?: long(name='min_instances', description='最小节点数	'),
        type?: string(name='type', description='扩容组类型'),
      }(name='auto_scaling', description='自动伸缩配置详情'),
      interconnectConfig?: {
        bandwidth?: long(name='bandwidth', description='边缘增强型节点池的网络带宽，单位M'),
        ccnId?: string(name='ccn_id', description='边缘增强型节点池绑定的云连接网实例ID(CCNID)'),
        ccnRegionId?: string(name='ccn_region_id', description='边缘增强型节点池绑定的云连接网实例所属的区域'),
        cenId?: string(name='cen_id', description='边缘增强型节点池绑定的云企业网实例ID(CENID)'),
        improvedPeriod?: string(name='improved_period', description='边缘增强型节点池的购买时长，单位月'),
      }(name='interconnect_config', description='边缘节点池网络相关的配置。该值只对edge类型的节点池有意义'),
      interconnectMode?: string(name='interconnect_mode', description='边缘节点池的网络类型。basic：基础型；improved：增强型。该值只对edge类型的节点池有意义'),
      kubernetesConfig?: {
        cmsEnabled?: boolean(name='cms_enabled', description='是否开启云监控	'),
        cpuPolicy?: string(name='cpu_policy', description='CPU管理策略	'),
        labels?: [
          Tag
        ](name='labels', description='ECS标签'),
        nodeNameMode?: string(name='node_name_mode', description='自定义节点名称'),
        runtime?: string(name='runtime', description='容器运行时	'),
        runtimeVersion?: string(name='runtime_version', description='容器运行时版本	'),
        taints?: [
          Taint
        ](name='taints', description='污点配置'),
        userData?: string(name='user_data', description='节点自定义数据'),
      }(name='kubernetes_config', description='集群配置信息'),
      management?: {
        autoRepair?: boolean(name='auto_repair', description='是否启用自动修复'),
        enable?: boolean(name='enable', description='是否开启托管版节点池'),
        upgradeConfig?: {
          autoUpgrade?: boolean(name='auto_upgrade', description='是否启用自动升级，自修复'),
          maxUnavailable?: long(name='max_unavailable', description='最大不可用节点数量'),
          surge?: long(name='surge', description='额外节点数量'),
          surgePercentage?: long(name='surge_percentage', description='额外节点比例， 和surge 二选一'),
        }(name='upgrade_config', description='是否启用自动修复'),
      }(name='management', description='托管节点池配置'),
      maxNodes?: long(name='max_nodes', description='边缘节点池允许容纳的最大节点数量. 节点池内可以容纳的最大节点数量，该参数大于等于0。0表示无额外限制(仅受限于集群整体可以容纳的节点数，节点池本身无额外限制)。边缘节点池该参数值往往大于0；ess类型节点池和默认的edge类型节点池该参数值为0'),
      nodepoolInfo?: {
        created?: string(name='created', description='节点池创建时间'),
        isDefault?: boolean(name='is_default', description='是否为默认节点池'),
        name?: string(name='name', description='节点池名称'),
        nodepoolId?: string(name='nodepool_id', description='节点池ID'),
        regionId?: string(name='region_id', description='节点池所在地域ID'),
        resourceGroupId?: string(name='resource_group_id', description='资源组ID'),
        type?: string(name='type', description='节点池类型'),
        updated?: string(name='updated', description='节点池更新时间'),
      }(name='nodepool_info', description='节点池配置详情'),
      scalingGroup?: {
        autoRenew?: boolean(name='auto_renew', description='自动续费	'),
        autoRenewPeriod?: long(name='auto_renew_period', description='自动付费时长	'),
        compensateWithOnDemand?: boolean(name='compensate_with_on_demand', description='当MultiAZPolicy取值为COST_OPTIMIZED时，如果因价格、库存等原因无法创建足够的抢占式实例，是否允许自动尝试创建按量实例满足ECS实例数量要求。取值范围：true：允许。false：不允许。默认值：true'),
        dataDisks?: [
          DataDisk
        ](name='data_disks', description='数据盘配置	'),
        deploymentsetId?: string(name='deploymentset_id', description='部署集ID。'),
        imageId?: string(name='image_id', description='镜像ID	'),
        instanceChargeType?: string(name='instance_charge_type', description='节点付费类型	'),
        instanceTypes?: [ string ](name='instance_types', description='节点类型	'),
        internetChargeType?: string(name='internet_charge_type', description='节点公网IP网络计费类型'),
        internetMaxBandwidthOut?: long(name='internet_max_bandwidth_out', description='节点公网IP出带宽最大值，单位为Mbps（Mega bit per second），取值范围：1~100'),
        keyPair?: string(name='key_pair', description='密钥对名称，和login_password二选一。'),
        loginPassword?: string(name='login_password', description='登录密码，返回结果是加密的。'),
        multiAzPolicy?: string(name='multi_az_policy', description='多可用区伸缩组ECS实例扩缩容策略'),
        onDemandBaseCapacity?: long(name='on_demand_base_capacity', description='伸缩组所需要按量实例个数的最小值，取值范围：0~1000。当按量实例个数少于该值时，将优先创建按量实例'),
        onDemandPercentageAboveBaseCapacity?: long(name='on_demand_percentage_above_base_capacity', description='伸缩组满足最小按量实例数（OnDemandBaseCapacity）要求后，超出的实例中按量实例应占的比例，取值范围：0～100'),
        period?: long(name='period', description='包年包月时长	'),
        periodUnit?: string(name='period_unit', description='自动付费周期	'),
        platform?: string(name='platform', description='操作系统发行版。取值： CentOS，AliyunLinux，Windows，WindowsCore'),
        ramPolicy?: string(name='ram_policy', description='RAM 角色名称	'),
        rdsInstances?: [ string ](name='rds_instances', description='RDS列表	'),
        scalingGroupId?: string(name='scaling_group_id', description='扩容组ID	'),
        scalingPolicy?: string(name='scaling_policy', description='扩容节点策略	'),
        securityGroupId?: string(name='security_group_id', description='安全组ID。'),
        securityGroupIds?: [ string ](name='security_group_ids', description='安全组ID列表'),
        spotInstancePools?: long(name='spot_instance_pools', description='指定可用实例规格的个数，伸缩组将按成本最低的多个规格均衡创建抢占式实例。取值范围：1~10'),
        spotInstanceRemedy?: boolean(name='spot_instance_remedy', description='是否开启补齐抢占式实例。开启后，当收到抢占式实例将被回收的系统消息时，伸缩组将尝试创建新的实例，替换掉将被回收的抢占式实例'),
        spotPriceLimit?: [ 
          {
            instanceType?: string(name='instance_type', description='抢占式实例规格'),
            priceLimit?: string(name='price_limit', description='单台实例上限价格，单位：元/小时'),
          }
        ](name='spot_price_limit', description='抢占实例价格上限配置'),
        spotStrategy?: string(name='spot_strategy', description='抢占式实例类型'),
        systemDiskCategory?: string(name='system_disk_category', description='系统盘类型。	'),
        systemDiskPerformanceLevel?: string(name='system_disk_performance_level', description='节点系统盘磁盘性能，只针对ESSD磁盘生效'),
        systemDiskSize?: long(name='system_disk_size', description='系统盘大小	'),
        tags?: [
          Tag
        ](name='tags', description='节点标签	'),
        vswitchIds?: [ string ](name='vswitch_ids', description='虚拟交换机ID'),
      }(name='scaling_group', description='扩容组配置详情'),
      status?: {
        failedNodes?: long(name='failed_nodes', description='失败的节点数	'),
        healthyNodes?: long(name='healthy_nodes', description='处于健康状态的节点数	'),
        initialNodes?: long(name='initial_nodes', description='正在创建的节点数	'),
        offlineNodes?: long(name='offline_nodes', description='离线节点数	'),
        removingNodes?: long(name='removing_nodes', description='正在被移除的节点数'),
        servingNodes?: long(name='serving_nodes', description='正在工作节点数	'),
        state?: string(name='state', description='节点池状态	'),
        totalNodes?: long(name='total_nodes', description='节点总数	'),
      }(name='status', description='节点池状态详情'),
      teeConfig?: {
        teeEnable?: boolean(name='tee_enable', description='是否为加密计算节点池	'),
      }(name='tee_config', description='加密计算配置详情'),
    }
  ](name='nodepools', description='节点池列表'),
}

model DescribeClusterNodePoolsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterNodePoolsResponseBody(name='body'),
}

async function describeClusterNodePools(ClusterId: string): DescribeClusterNodePoolsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterNodePoolsWithOptions(ClusterId, headers, runtime);
}

async function describeClusterNodePoolsWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterNodePoolsResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterNodePools',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/nodepools`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterNodesRequest {
  instanceIds?: string(name='instanceIds', description='节点实例ID，按照实例ID进行过滤。  节点池ID不为空时会忽略此字段。多节点用逗号分割'),
  nodepoolId?: string(name='nodepool_id', description='节点池ID。'),
  pageNumber?: string(name='pageNumber', description='分页数量'),
  pageSize?: string(name='pageSize', description='每页大小。'),
  state?: string(name='state', description='节点状态。默认值：all。'),
}

model DescribeClusterNodesResponseBody = {
  nodes?: [ 
    {
      creationTime?: string(name='creation_time', description='节点创建时间。'),
      errorMessage?: string(name='error_message', description='错误信息说明。'),
      expiredTime?: string(name='expired_time', description='节点过期时间。'),
      hostName?: string(name='host_name', description='节点主机名。'),
      imageId?: string(name='image_id', description='节点使用的镜像ID。'),
      instanceChargeType?: string(name='instance_charge_type', description='节点付费类型。'),
      instanceId?: string(name='instance_id', description='节点实例ID。'),
      instanceName?: string(name='instance_name', description='节点名称。'),
      instanceRole?: string(name='instance_role', description='节点实例角色类型，Master或Worker。'),
      instanceStatus?: string(name='instance_status', description='节点实例状态，'),
      instanceType?: string(name='instance_type', description='节点实例类型。'),
      instanceTypeFamily?: string(name='instance_type_family', description='节点实例所属ECS实例簇名称。'),
      ipAddress?: [ string ](name='ip_address', description='节点IP地址。'),
      isAliyunNode?: boolean(name='is_aliyun_node', description='节点是否为aliyun实例。'),
      nodeName?: string(name='node_name', description='节点名称，该名称是k8s专用名称。'),
      nodeStatus?: string(name='node_status', description='节点状态，是否Ready。'),
      nodepoolId?: string(name='nodepool_id', description='节点池ID。'),
      source?: string(name='source', description='节点通过什么方式创建出来的，例如：ROS。'),
      spotStrategy?: string(name='spot_strategy', description='抢占时实例类型'),
      state?: string(name='state', description='ECS运行状态，例如：Running。'),
    }
  ](name='nodes', description='节点信息列表。'),
  page?: {
    pageNumber?: int32(name='page_number', description='总页数。'),
    pageSize?: int32(name='page_size', description='单页展示结果数量。'),
    totalCount?: int32(name='total_count', description='结果总条数。'),
  }(name='page', description='分页信息。'),
}

model DescribeClusterNodesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterNodesResponseBody(name='body'),
}

async function describeClusterNodes(ClusterId: string, request: DescribeClusterNodesRequest): DescribeClusterNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterNodesWithOptions(ClusterId, request, headers, runtime);
}

async function describeClusterNodesWithOptions(ClusterId: string, request: DescribeClusterNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterNodesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceIds)) {
    query['instanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.nodepoolId)) {
    query['nodepool_id'] = request.nodepoolId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.state)) {
    query['state'] = request.state;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterNodes',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/nodes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: [ 
    {
      clusterId?: string(name='cluster_id', description='集群ID。'),
      created?: string(name='created', description='资源创建时间。'),
      instanceId?: string(name='instance_id', description='资源实例ID。'),
      resourceInfo?: string(name='resource_info', description='资源元信息。'),
      resourceType?: string(name='resource_type', description='资源类型。'),
      state?: string(name='state', description='资源状态。'),
    }
  ](name='body'),
}

async function describeClusterResources(ClusterId: string): DescribeClusterResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterResourcesWithOptions(ClusterId, headers, runtime);
}

async function describeClusterResourcesWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterResourcesResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterResources',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/resources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterUserKubeconfigRequest {
  privateIpAddress?: boolean(name='PrivateIpAddress', description='ApiServer是否为内网地址。'),
  temporaryDurationMinutes?: long(name='TemporaryDurationMinutes', description='临时kubeconfig有效期，单位：分钟。  最小值：15（15分钟）  最大值：4320（3天）。'),
}

model DescribeClusterUserKubeconfigResponseBody = {
  config?: string(name='config', description='kubeconfig内容。'),
  expiration?: string(name='expiration', description='kubeconfig过期时间。格式：RFC3339 格式的 UTC 时间。'),
}

model DescribeClusterUserKubeconfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterUserKubeconfigResponseBody(name='body'),
}

async function describeClusterUserKubeconfig(ClusterId: string, request: DescribeClusterUserKubeconfigRequest): DescribeClusterUserKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterUserKubeconfigWithOptions(ClusterId, request, headers, runtime);
}

async function describeClusterUserKubeconfigWithOptions(ClusterId: string, request: DescribeClusterUserKubeconfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterUserKubeconfigResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.temporaryDurationMinutes)) {
    query['TemporaryDurationMinutes'] = request.temporaryDurationMinutes;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterUserKubeconfig',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/k8s/${ClusterId}/user_config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterV2UserKubeconfigRequest {
  privateIpAddress?: boolean(name='PrivateIpAddress', description='是否为内网访问。'),
}

model DescribeClusterV2UserKubeconfigResponseBody = {
  config?: string(name='config', description='kubeconfig内容。'),
}

model DescribeClusterV2UserKubeconfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterV2UserKubeconfigResponseBody(name='body'),
}

async function describeClusterV2UserKubeconfig(ClusterId: string, request: DescribeClusterV2UserKubeconfigRequest): DescribeClusterV2UserKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterV2UserKubeconfigWithOptions(ClusterId, request, headers, runtime);
}

async function describeClusterV2UserKubeconfigWithOptions(ClusterId: string, request: DescribeClusterV2UserKubeconfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterV2UserKubeconfigResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterV2UserKubeconfig',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/k8s/${ClusterId}/user_config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClustersRequest {
  clusterType?: string(name='clusterType', description='集群类型。'),
  name?: string(name='name', description='集群名称。'),
}

model DescribeClustersResponse = {
  headers: map[string]string(name='headers'),
  body: [ 
    {
      clusterId?: string(name='cluster_id', description='集群ID。'),
      clusterType?: string(name='cluster_type', description='集群类型。'),
      created?: string(name='created', description='集群创建时间。'),
      currentVersion?: string(name='current_version', description='集群当前版本。'),
      dataDiskCategory?: string(name='data_disk_category', description='节点系统盘类型。'),
      dataDiskSize?: long(name='data_disk_size', description='节点系统盘大小。'),
      deletionProtection?: boolean(name='deletion_protection', description='集群是否开启删除保护。'),
      dockerVersion?: string(name='docker_version', description='容器运行时版本。'),
      externalLoadbalancerId?: string(name='external_loadbalancer_id', description='集群Ingerss SLB实例的ID。'),
      initVersion?: string(name='init_version', description='集群创建时版本。'),
      masterUrl?: string(name='master_url', description='集群的endpoint地址。'),
      metaData?: string(name='meta_data', description='集群元数据。'),
      name?: string(name='name', description='集群名称。'),
      networkMode?: string(name='network_mode', description='集群使用的网络类型。'),
      privateZone?: boolean(name='private_zone', description='集群是否开启Private Zone，默认false。'),
      profile?: string(name='profile', description='集群标识，区分是否为边缘托管版。'),
      regionId?: string(name='region_id', description='集群所在地域ID。'),
      resourceGroupId?: string(name='resource_group_id', description='集群资源组ID。'),
      securityGroupId?: string(name='security_group_id', description='集群安全组ID。'),
      size?: long(name='size', description='集群内实例数量。'),
      state?: string(name='state', description='集群运行状态。'),
      subnetCidr?: string(name='subnet_cidr', description='POD网络。'),
      tags?: [ 
        {
          key?: string(name='key', description='标签名。'),
          value?: string(name='value', description='标签值。'),
        }
      ](name='tags', description='集群标签。'),
      updated?: string(name='updated', description='集群更新时间。'),
      vpcId?: string(name='vpc_id', description='集群使用的VPC ID。'),
      vswitchCidr?: string(name='vswitch_cidr', description='虚拟交换机网络ID。'),
      vswitchId?: string(name='vswitch_id', description='节点使用的Vswitch ID。'),
      workerRamRoleName?: string(name='worker_ram_role_name', description='集群Worker节点RAM角色名称。'),
      zoneId?: string(name='zone_id', description='集群所在Region内的区域ID。'),
    }
  ](name='body'),
}

async function describeClusters(request: DescribeClustersRequest): DescribeClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClustersWithOptions(request, headers, runtime);
}

async function describeClustersWithOptions(request: DescribeClustersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClustersResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterType)) {
    query['clusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusters',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model DescribeClustersV1Request {
  clusterSpec?: string(name='cluster_spec', description='集群规格。'),
  clusterType?: string(name='cluster_type', description='集群类型。'),
  name?: string(name='name', description='通过集群名称进行模糊查询。'),
  pageNumber?: long(name='page_number', description='分页数。'),
  pageSize?: long(name='page_size', description='单页大小。'),
  profile?: string(name='profile', description='集群标识。'),
}

model DescribeClustersV1ResponseBody = {
  clusters?: [ 
    {
      clusterId?: string(name='cluster_id', description='集群ID。'),
      clusterSpec?: string(name='cluster_spec', description='托管版集群类型，面向托管集群。 • ack.pro.small：专业托管集群。 • ack.standard ：标准托管集群。'),
      clusterType?: string(name='cluster_type', description='集群类型。'),
      created?: string(name='created', description='集群初始化时间。'),
      currentVersion?: string(name='current_version', description='集群当前版本。'),
      deletionProtection?: boolean(name='deletion_protection', description='集群是否开启删除保护。'),
      dockerVersion?: string(name='docker_version', description='集群使用的Docker版本。'),
      externalLoadbalancerId?: string(name='external_loadbalancer_id', description='集群负载均衡服务的ID。'),
      initVersion?: string(name='init_version', description='集群初始化版本。'),
      maintenanceWindow?: MaintenanceWindow(name='maintenance_window'),
      masterUrl?: string(name='master_url', description='集群访问地址列表。'),
      metaData?: string(name='meta_data', description='集群元数据信息。'),
      name?: string(name='name', description='集群名称。'),
      networkMode?: string(name='network_mode', description='集群使用的网络类型，例如：VPC网络。'),
      nextVersion?: string(name='next_version', description='集群可升级版本。'),
      privateZone?: boolean(name='private_zone', description='集群是否开启Private Zone。'),
      profile?: string(name='profile', description='边缘集群表示，用于区分边缘托管版集群。'),
      regionId?: string(name='region_id', description='地域ID。'),
      resourceGroupId?: string(name='resource_group_id', description='集群资源组ID。'),
      securityGroupId?: string(name='security_group_id', description='集群安全组ID。'),
      size?: long(name='size', description='集群节点数。'),
      state?: string(name='state', description='集群运行状态。'),
      subnetCidr?: string(name='subnet_cidr', description='POD网段地址。'),
      tags?: [
        Tag
      ](name='tags', description='集群标签。'),
      updated?: string(name='updated', description='集群更新时间。'),
      vpcId?: string(name='vpc_id', description='集群所在的VPC ID。'),
      vswitchId?: string(name='vswitch_id', description='集群使用的虚拟交换ID。'),
      workerRamRoleName?: string(name='worker_ram_role_name', description='集群Worker RAM角色。'),
      zoneId?: string(name='zone_id', description='可用区ID。'),
    }
  ](name='clusters', description='集群详情列表。'),
  pageInfo?: {
    pageNumber?: int32(name='page_number', description='分页数。'),
    pageSize?: int32(name='page_size', description='单页大小。'),
    totalCount?: int32(name='total_count', description='结果总数。'),
  }(name='page_info', description='分页信息。'),
}

model DescribeClustersV1Response = {
  headers: map[string]string(name='headers'),
  body: DescribeClustersV1ResponseBody(name='body'),
}

async function describeClustersV1(request: DescribeClustersV1Request): DescribeClustersV1Response {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClustersV1WithOptions(request, headers, runtime);
}

async function describeClustersV1WithOptions(request: DescribeClustersV1Request, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClustersV1Response {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterSpec)) {
    query['cluster_spec'] = request.clusterSpec;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['cluster_type'] = request.clusterType;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.profile)) {
    query['profile'] = request.profile;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClustersV1',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v1/clusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeEdgeMachineActiveProcessResponseBody = {
  logs?: string(name='logs', description='logs of activate'),
  progress?: long(name='progress', description='process of activate'),
  requestId?: string(name='request_id', description='Id of the request'),
  state?: string(name='state', description='state of activate'),
  step?: string(name='step', description='step of activate'),
}

model DescribeEdgeMachineActiveProcessResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEdgeMachineActiveProcessResponseBody(name='body'),
}

async function describeEdgeMachineActiveProcess(edgeMachineid: string): DescribeEdgeMachineActiveProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeEdgeMachineActiveProcessWithOptions(edgeMachineid, headers, runtime);
}

async function describeEdgeMachineActiveProcessWithOptions(edgeMachineid: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeEdgeMachineActiveProcessResponse {
  edgeMachineid = OpenApiUtil.getEncodeParam(edgeMachineid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeEdgeMachineActiveProcess',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/edge_machines/[edge_machineid]/activeprocess`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeEdgeMachineModelsResponseBody = {
  models?: [ 
    {
      cpu?: int32(name='cpu', description='cpu'),
      cpuArch?: string(name='cpu_arch', description='cpu arch'),
      created?: string(name='created', description='created'),
      description?: string(name='description', description='description'),
      manageRuntime?: int32(name='manage_runtime', description='manage runtime'),
      memory?: int32(name='memory', description='memory'),
      model?: string(name='model', description='model'),
      modelId?: string(name='model_id', description='model id'),
    }
  ](name='models', description='Id of the request'),
}

model DescribeEdgeMachineModelsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEdgeMachineModelsResponseBody(name='body'),
}

async function describeEdgeMachineModels(): DescribeEdgeMachineModelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeEdgeMachineModelsWithOptions(headers, runtime);
}

async function describeEdgeMachineModelsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeEdgeMachineModelsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeEdgeMachineModels',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/edge_machines/models`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeEdgeMachineTunnelConfigDetailResponseBody = {
  deviceName?: string(name='device_name', description='device name'),
  model?: string(name='model', description='Id of the request'),
  productKey?: string(name='product_key', description='product key'),
  requestId?: string(name='request_id', description='request id'),
  sn?: string(name='sn', description='sn'),
  token?: string(name='token', description='token'),
  tunnelEndpoint?: string(name='tunnel_endpoint', description='tunnel endpoint'),
}

model DescribeEdgeMachineTunnelConfigDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEdgeMachineTunnelConfigDetailResponseBody(name='body'),
}

async function describeEdgeMachineTunnelConfigDetail(edgeMachineid: string): DescribeEdgeMachineTunnelConfigDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeEdgeMachineTunnelConfigDetailWithOptions(edgeMachineid, headers, runtime);
}

async function describeEdgeMachineTunnelConfigDetailWithOptions(edgeMachineid: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeEdgeMachineTunnelConfigDetailResponse {
  edgeMachineid = OpenApiUtil.getEncodeParam(edgeMachineid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeEdgeMachineTunnelConfigDetail',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/edge_machines/[edge_machineid]/tunnelconfig`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeEdgeMachinesRequest {
  hostname?: string(name='hostname', description='host name'),
  lifeState?: string(name='life_state', description='life state'),
  model?: string(name='model', description='model'),
  onlineState?: string(name='online_state', description='online state'),
  pageNumber?: long(name='page_number', description='page number'),
  pageSize?: long(name='page_size', description='page size'),
}

model DescribeEdgeMachinesResponseBody = {
  edgeMachines?: [ 
    {
      activeTime?: string(name='active_time', description='actvite time'),
      created?: string(name='created', description='created time'),
      edgeMachineId?: string(name='edge_machine_id', description='edge machine id'),
      hostname?: string(name='hostname', description='hostname'),
      lifeState?: string(name='life_state', description='life state'),
      model?: string(name='model', description='model'),
      name?: string(name='name', description='name of edgemachine'),
      onlineState?: string(name='online_state', description='online state'),
      sn?: string(name='sn', description='sn'),
      updated?: string(name='updated', description='update time'),
    }
  ](name='edge_machines', description='Id of the request'),
  pageInfo?: {
    pageNumber?: int32(name='page_number', description='page number'),
    pageSize?: int32(name='page_size', description='page size'),
    totalCount?: int32(name='total_count', description='total count'),
  }(name='page_info', description='page info'),
}

model DescribeEdgeMachinesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEdgeMachinesResponseBody(name='body'),
}

async function describeEdgeMachines(request: DescribeEdgeMachinesRequest): DescribeEdgeMachinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeEdgeMachinesWithOptions(request, headers, runtime);
}

async function describeEdgeMachinesWithOptions(request: DescribeEdgeMachinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeEdgeMachinesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.hostname)) {
    query['hostname'] = request.hostname;
  }
  if (!Util.isUnset(request.lifeState)) {
    query['life_state'] = request.lifeState;
  }
  if (!Util.isUnset(request.model)) {
    query['model'] = request.model;
  }
  if (!Util.isUnset(request.onlineState)) {
    query['online_state'] = request.onlineState;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEdgeMachines',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/edge_machines`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeEventsRequest {
  clusterId?: string(name='cluster_id', description='集群ID'),
  pageNumber?: long(name='page_number', description='没页记录数量'),
  pageSize?: long(name='page_size', description='页数'),
  type?: string(name='type', description='事件类型'),
}

model DescribeEventsResponseBody = {
  events?: [ 
    {
      clusterId?: string(name='cluster_id', description='集群ID'),
      data?: {
        level?: string(name='level', description='事件级别'),
        message?: string(name='message', description='事件详情'),
        reason?: string(name='reason', description='事件状态'),
      }(name='data', description='事件描述'),
      eventId?: string(name='event_id', description='事件ID'),
      source?: string(name='source', description='事件源'),
      subject?: string(name='subject', description='事件'),
      time?: string(name='time', description='事件开始事件'),
      type?: string(name='type', description='事件类型'),
    }
  ](name='events'),
  pageInfo?: {
    pageNumber?: long(name='page_number', description='每页记录数量'),
    pageSize?: long(name='page_size', description='页数'),
    totalCount?: long(name='total_count', description='结果总数'),
  }(name='page_info'),
}

model DescribeEventsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEventsResponseBody(name='body'),
}

async function describeEvents(request: DescribeEventsRequest): DescribeEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeEventsWithOptions(request, headers, runtime);
}

async function describeEventsWithOptions(request: DescribeEventsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeEventsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterId)) {
    query['cluster_id'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEvents',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/events`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeExternalAgentRequest {
  privateIpAddress?: string(name='PrivateIpAddress', description='是否获取内网访问凭据。  true：获取内网连接凭据 false：获取公网连接凭据 默认值：false。'),
}

model DescribeExternalAgentResponseBody = {
  config?: string(name='config', description='代理配置。'),
}

model DescribeExternalAgentResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeExternalAgentResponseBody(name='body'),
}

async function describeExternalAgent(ClusterId: string, request: DescribeExternalAgentRequest): DescribeExternalAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeExternalAgentWithOptions(ClusterId, request, headers, runtime);
}

async function describeExternalAgentWithOptions(ClusterId: string, request: DescribeExternalAgentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeExternalAgentResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExternalAgent',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/k8s/${ClusterId}/external/agent/deployment`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeKubernetesVersionMetadataRequest {
  clusterType?: string(name='ClusterType', description='集群类型。'),
  kubernetesVersion?: string(name='KubernetesVersion', description='要查询的版本，如果为空则查所有版本。'),
  profile?: string(name='Profile', description='边缘集群标识，用于区分边缘集群，取值：Default或Edge。'),
  region?: string(name='Region', description='地域ID。'),
  runtime?: string(name='runtime', description='运行时。'),
}

model DescribeKubernetesVersionMetadataResponse = {
  headers: map[string]string(name='headers'),
  body: [ 
    {
      capabilities?: map[string]any(name='capabilities', description='Kubernetes版本特性。	'),
      images?: [ 
        {
          imageId?: string(name='image_id', description='镜像ID。	'),
          imageName?: string(name='image_name', description='镜像名称。	'),
          platform?: string(name='platform', description='操作系统发行版。取值范围： CentOS,AliyunLinux,Windows,WindowsCore。'),
          osVersion?: string(name='os_version', description='镜像版本。'),
          imageType?: string(name='image_type', description='镜像类型。	'),
          osType?: string(name='os_type', description='操作系统发行版本号。'),
          imageCategory?: string(name='image_category', description='镜像分类'),
        }
      ](name='images', description='ECS系统镜像列表。	'),
      metaData?: map[string]any(name='meta_data', description='Kubernetes版本元数据信息。	'),
      runtimes?: [
        Runtime
      ](name='runtimes', description='容器运行时详情。	'),
      version?: string(name='version', description='Kubernetes版本。	'),
      multiAz?: string(name='multi_az', description='是否为多可用区。'),
    }
  ](name='body'),
}

async function describeKubernetesVersionMetadata(request: DescribeKubernetesVersionMetadataRequest): DescribeKubernetesVersionMetadataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeKubernetesVersionMetadataWithOptions(request, headers, runtime);
}

async function describeKubernetesVersionMetadataWithOptions(request: DescribeKubernetesVersionMetadataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeKubernetesVersionMetadataResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.kubernetesVersion)) {
    query['KubernetesVersion'] = request.kubernetesVersion;
  }
  if (!Util.isUnset(request.profile)) {
    query['Profile'] = request.profile;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.runtime)) {
    query['runtime'] = request.runtime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeKubernetesVersionMetadata',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v1/metadata/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model DescribePoliciesResponse = {
  headers: map[string]string(name='headers'),
  body: object(name='body'),
}

async function describePolicies(): DescribePoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePoliciesWithOptions(headers, runtime);
}

async function describePoliciesWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribePoliciesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribePolicies',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/policies`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribePolicyDetailsResponseBody = {
  action?: string(name='action', description='规则治理动作 ● enforce: 拦截违规部署 ● inform：告警'),
  category?: string(name='category', description='规则模板类型'),
  description?: string(name='description', description='规则模板描述'),
  isDeleted?: int32(name='is_deleted', description='软删除标志：0表示未删除 1表示删除'),
  name?: string(name='name', description='策略治理规则名称'),
  noConfig?: int32(name='no_config', description='是否需要配置策略： 0表示需要参数配置 1表示无需参数配置'),
  severity?: string(name='severity', description='规则治理等级'),
  template?: string(name='template', description='规则模板详情'),
}

model DescribePolicyDetailsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePolicyDetailsResponseBody(name='body'),
}

async function describePolicyDetails(policyName: string): DescribePolicyDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePolicyDetailsWithOptions(policyName, headers, runtime);
}

async function describePolicyDetailsWithOptions(policyName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribePolicyDetailsResponse {
  policyName = OpenApiUtil.getEncodeParam(policyName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribePolicyDetails',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/policies/${policyName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribePolicyGovernanceInClusterResponseBody = {
  admitLog?: {
    count?: long(name='count', description='当前查询到的日志总数'),
    log?: {
      clusterId?: string(name='cluster_id', description='目标集群ID'),
      constraintKind?: string(name='constraint_kind', description='策略类型名称'),
      msg?: string(name='msg', description='策略治理审计日志信息'),
      resourceKind?: string(name='resource_kind', description='目标资源类型'),
      resourceName?: string(name='resource_name', description='目标资源名称'),
      resourceNamespace?: string(name='resource_namespace', description='目标资源命名空间'),
    }(name='log', description='策略治理审计日志内容'),
    progress?: string(name='progress', description='查询结果的状态'),
  }(name='admit_log', description='集群当前策略治理审计日志'),
  onState?: [ 
    {
      enabledCount?: int32(name='enabled_count', description='当前开启的策略种类计数'),
      severity?: string(name='severity', description='策略治理等级'),
      total?: int32(name='total', description='该等级下策略种类总数'),
    }
  ](name='on_state', description='当前集群中开启的不同等级策略计数统计'),
  totalViolations?: {
    deny?: {
      severity?: string(name='severity', description='策略治理等级'),
      violations?: long(name='violations', description='被拦截的事件计数'),
    }(name='deny', description='被拦截的不同治理等级的违规计数统计'),
    warn?: {
      severity?: string(name='severity', description='策略治理等级'),
      violations?: long(name='violations', description='告警的事件计数'),
    }(name='warn', description='告警模式下不同治理等级的违规计数统计'),
  }(name='totalViolations', description='集群中当前被拦截和告警两种处理类型下不同治理等级的违规计数。'),
  violations?: {
    deny?: {
      policyDescription?: string(name='policyDescription', description='策略描述'),
      policyName?: string(name='policyName', description='策略名称'),
      severity?: string(name='severity', description='策略治理等级'),
      violations?: long(name='violations', description='对应规则的事件计数'),
    }(name='deny', description='被拦截的不同策略类型的审计计数'),
    warn?: {
      policyDescription?: string(name='policyDescription', description='策略描述'),
      policyName?: string(name='policyName', description='策略名称'),
      severity?: string(name='severity', description='策略治理等级'),
      violations?: long(name='violations', description='对应规则的事件计数'),
    }(name='warn', description='告警的不同策略类型审计计数'),
  }(name='violations', description='集群中针对不同策略类型的拦截和告警的审计计数统计列表'),
}

model DescribePolicyGovernanceInClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePolicyGovernanceInClusterResponseBody(name='body'),
}

async function describePolicyGovernanceInCluster(clusterId: string): DescribePolicyGovernanceInClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePolicyGovernanceInClusterWithOptions(clusterId, headers, runtime);
}

async function describePolicyGovernanceInClusterWithOptions(clusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribePolicyGovernanceInClusterResponse {
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribePolicyGovernanceInCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/policygovernance`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribePolicyInstancesRequest {
  instanceName?: string(name='instance_name', description='策略实例名称'),
  policyName?: string(name='policy_name', description='策略类型'),
}

model DescribePolicyInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: [ 
    {
      aliUid?: string(name='ali_uid', description='策略实例实施者UID'),
      clusterId?: string(name='cluster_id', description='目标集群ID'),
      instanceName?: string(name='instance_name', description='规则实例名称'),
      policyName?: string(name='policy_name', description='策略治理规则名称'),
      policyCategory?: string(name='policy_category', description='策略类型名称'),
      policyDescription?: string(name='policy_description', description='规则模板描述'),
      policyParameters?: string(name='policy_parameters', description='当前规则实例的配置参数'),
      policySeverity?: string(name='policy_severity', description='规则实例治理等级'),
      policyScope?: string(name='policy_scope', description='策略实例实施范围： 默认"*"代表集群所有ns 否则返回作用namespaces名称，多个namespaces以逗号分隔'),
      policyAction?: string(name='policy_action', description='规则治理动作  deny: 拦截违规部署  warn：告警'),
    }
  ](name='body'),
}

async function describePolicyInstances(clusterId: string, request: DescribePolicyInstancesRequest): DescribePolicyInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePolicyInstancesWithOptions(clusterId, request, headers, runtime);
}

async function describePolicyInstancesWithOptions(clusterId: string, request: DescribePolicyInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribePolicyInstancesResponse {
  Util.validateModel(request);
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceName)) {
    query['instance_name'] = request.instanceName;
  }
  if (!Util.isUnset(request.policyName)) {
    query['policy_name'] = request.policyName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePolicyInstances',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/policies`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model DescribePolicyInstancesStatusResponseBody = {
  instancesSeverityCount?: map[string]any(name='instances_severity_count'),
  policyInstances?: [ 
    {
      policyCategory?: string(name='policy_category'),
      policyDescription?: string(name='policy_description'),
      policyInstancesCount?: long(name='policy_instances_count'),
      policyName?: string(name='policy_name'),
      policySeverity?: string(name='policy_severity'),
    }
  ](name='policy_instances', description='不同策略类型下的策略实例计数列表'),
}

model DescribePolicyInstancesStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePolicyInstancesStatusResponseBody(name='body'),
}

async function describePolicyInstancesStatus(clusterId: string): DescribePolicyInstancesStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePolicyInstancesStatusWithOptions(clusterId, headers, runtime);
}

async function describePolicyInstancesStatusWithOptions(clusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribePolicyInstancesStatusResponse {
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribePolicyInstancesStatus',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/policies/status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeTaskInfoResponseBody = {
  clusterId?: string(name='cluster_id', description='集群ID。'),
  created?: string(name='created', description='任务创建时间。'),
  state?: string(name='state', description='任务当前状态。'),
  taskId?: string(name='task_id', description='任务ID。'),
  taskResult?: [ 
    {
      data?: string(name='data', description='操作的资源，例如：实例ID。'),
      status?: string(name='status', description='资源的状态。'),
    }
  ](name='task_result', description='任务执行详情。'),
  taskType?: string(name='task_type', description='当前任务类型。'),
  updated?: string(name='updated', description='任务更新时间。'),
}

model DescribeTaskInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTaskInfoResponseBody(name='body'),
}

async function describeTaskInfo(taskId: string): DescribeTaskInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeTaskInfoWithOptions(taskId, headers, runtime);
}

async function describeTaskInfoWithOptions(taskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeTaskInfoResponse {
  taskId = OpenApiUtil.getEncodeParam(taskId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeTaskInfo',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/tasks/${taskId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeTemplateAttributeRequest {
  templateType?: string(name='template_type', description='模板类型，值为创建部署模板时指定的模板类型。'),
}

model DescribeTemplateAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: [ 
    {
      id?: string(name='id', description='编排模板ID，模板每次修改，这个ID都会改变。	'),
      acl?: string(name='acl', description='编排模板权限。取值：private，public，shared。'),
      name?: string(name='name', description='编排模板名称。	'),
      template?: string(name='template', description='编排模板内容。	'),
      templateType?: string(name='template_type', description='编排模板类型'),
      description?: string(name='description', description='编排模板描述。'),
      tags?: string(name='tags', description='部署模板的标签。'),
      templateWithHistId?: string(name='template_with_hist_id', description='编排模板ID，该ID唯一不随更新而改变。	'),
      created?: string(name='created', description='编排模板创建时间。'),
      updated?: string(name='updated', description='编排模板修改时间。	'),
    }
  ](name='body'),
}

async function describeTemplateAttribute(TemplateId: string, request: DescribeTemplateAttributeRequest): DescribeTemplateAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeTemplateAttributeWithOptions(TemplateId, request, headers, runtime);
}

async function describeTemplateAttributeWithOptions(TemplateId: string, request: DescribeTemplateAttributeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeTemplateAttributeResponse {
  Util.validateModel(request);
  TemplateId = OpenApiUtil.getEncodeParam(TemplateId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.templateType)) {
    query['template_type'] = request.templateType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTemplateAttribute',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/templates/${TemplateId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model DescribeTemplatesRequest {
  pageNum?: long(name='page_num', description='对查询结果进行分页处理，指定返回第几页的数据。  默认值为 1'),
  pageSize?: long(name='page_size', description='对查询结果进行分页处理，指定每页包含的数据条数。  默认值为 10'),
  templateType?: string(name='template_type', description='模板类型，部署模板类型，目前一共有2种类型，取值为：kubernetes或compose。'),
}

model DescribeTemplatesResponseBody = {
  pageInfo?: {
    pageNumber?: long(name='page_number', description='当前页数。'),
    pageSize?: long(name='page_size', description='单页最大数据条数。'),
    totalCount?: long(name='total_count', description='结果总数。'),
  }(name='page_info', description='分页信息。'),
  templates?: [ 
    {
      acl?: string(name='acl', description='模板访问权限，取值为：private、pubilc或shared。。'),
      created?: string(name='created', description='模板创建时间。'),
      description?: string(name='description', description='模板描述信息。'),
      id?: string(name='id', description='模板ID。会模板随着更新而变化。'),
      name?: string(name='name', description='模板名称。'),
      tags?: string(name='tags', description='模板标签，如果不显式指定了，默认为模板名称。'),
      template?: string(name='template', description='模板详情。'),
      templateType?: string(name='template_type', description='部署模板类型。'),
      templateWithHistId?: string(name='template_with_hist_id', description='模板唯一ID。'),
      updated?: string(name='updated', description='模板修改时间。'),
    }
  ](name='templates', description='模板列表。'),
}

model DescribeTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTemplatesResponseBody(name='body'),
}

async function describeTemplates(request: DescribeTemplatesRequest): DescribeTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeTemplatesWithOptions(request, headers, runtime);
}

async function describeTemplatesWithOptions(request: DescribeTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeTemplatesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNum)) {
    query['page_num'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.templateType)) {
    query['template_type'] = request.templateType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTemplates',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/templates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeTriggerRequest {
  name?: string(name='Name', description='应用名称。'),
  namespace?: string(name='Namespace', description='应用所属命名空间。'),
  type?: string(name='Type', description='应用类型。'),
  action?: string(name='action', description='触发器行为。'),
}

model DescribeTriggerResponse = {
  headers: map[string]string(name='headers'),
  body: [ 
    {
      id?: string(name='id', description='触发器ID。'),
      name?: string(name='name', description='触发器名称。'),
      clusterId?: string(name='cluster_id', description='集群ID'),
      projectId?: string(name='project_id', description='触发器项目名称'),
      type?: string(name='type', description='触发器类型。'),
      action?: string(name='action', description='触发器行为'),
      token?: string(name='token', description='Token'),
    }
  ](name='body'),
}

async function describeTrigger(clusterId: string, request: DescribeTriggerRequest): DescribeTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeTriggerWithOptions(clusterId, request, headers, runtime);
}

async function describeTriggerWithOptions(clusterId: string, request: DescribeTriggerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeTriggerResponse {
  Util.validateModel(request);
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.action)) {
    query['action'] = request.action;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTrigger',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/[cluster_id]/triggers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model DescribeUserPermissionResponse = {
  headers: map[string]string(name='headers'),
  body: [ 
    {
      resourceId?: string(name='resource_id', description='集群访问配置'),
      resourceType?: string(name='resource_type', description='授权类型'),
      roleName?: string(name='role_name', description='自定义角色名称'),
      roleType?: string(name='role_type', description='预置的角色类型'),
      isOwner?: long(name='is_owner', description='是否为集群 owner 的授权'),
      isRamRole?: long(name='is_ram_role', description='是否为ram 角色授权'),
    }
  ](name='body'),
}

async function describeUserPermission(uid: string): DescribeUserPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeUserPermissionWithOptions(uid, headers, runtime);
}

async function describeUserPermissionWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeUserPermissionResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserPermission',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/permissions/users/${uid}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model DescribeUserQuotaResponseBody = {
  amkClusterQuota?: long(name='amk_cluster_quota', description='托管版集群配额。'),
  askClusterQuota?: long(name='ask_cluster_quota', description='Serverless集群配额。'),
  clusterNodepoolQuota?: long(name='cluster_nodepool_quota', description='集群节点池配额。'),
  clusterQuota?: long(name='cluster_quota', description='专有版集群托管版集群的总配额。'),
  nodeQuota?: long(name='node_quota', description='单集群的节点配额。'),
}

model DescribeUserQuotaResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUserQuotaResponseBody(name='body'),
}

async function describeUserQuota(): DescribeUserQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeUserQuotaWithOptions(headers, runtime);
}

async function describeUserQuotaWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeUserQuotaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserQuota',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/quota`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeWorkflowsResponseBody = {
  jobs?: [ 
    {
      clusterId?: string(name='cluster_id', description='集群ID。'),
      createTime?: string(name='create_time', description='工作流创建时间。'),
      jobName?: string(name='job_name', description='工作流名称。'),
    }
  ](name='jobs', description='job信息'),
}

model DescribeWorkflowsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeWorkflowsResponseBody(name='body'),
}

async function describeWorkflows(): DescribeWorkflowsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeWorkflowsWithOptions(headers, runtime);
}

async function describeWorkflowsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeWorkflowsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeWorkflows',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/gs/workflows`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model EdgeClusterAddEdgeMachineRequest {
  expired?: long(name='expired', description='expired'),
  nodepoolId?: string(name='nodepool_id', description='nodepool_id'),
  options?: string(name='options', description='options'),
}

model EdgeClusterAddEdgeMachineResponseBody = {
  edgeMachineId?: string(name='edge_machine_id', description='edge machine id'),
  requestId?: string(name='request_id', description='Id of the request'),
}

model EdgeClusterAddEdgeMachineResponse = {
  headers: map[string]string(name='headers'),
  body: EdgeClusterAddEdgeMachineResponseBody(name='body'),
}

async function edgeClusterAddEdgeMachine(clusterid: string, edgeMachineid: string, request: EdgeClusterAddEdgeMachineRequest): EdgeClusterAddEdgeMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return edgeClusterAddEdgeMachineWithOptions(clusterid, edgeMachineid, request, headers, runtime);
}

async function edgeClusterAddEdgeMachineWithOptions(clusterid: string, edgeMachineid: string, request: EdgeClusterAddEdgeMachineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EdgeClusterAddEdgeMachineResponse {
  Util.validateModel(request);
  clusterid = OpenApiUtil.getEncodeParam(clusterid);
  edgeMachineid = OpenApiUtil.getEncodeParam(edgeMachineid);
  var body : map[string]any= {};
  if (!Util.isUnset(request.expired)) {
    body['expired'] = request.expired;
  }
  if (!Util.isUnset(request.nodepoolId)) {
    body['nodepool_id'] = request.nodepoolId;
  }
  if (!Util.isUnset(request.options)) {
    body['options'] = request.options;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EdgeClusterAddEdgeMachine',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/[clusterid]/attachedgemachine/[edge_machineid]`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetKubernetesTriggerRequest {
  name?: string(name='Name', description='应用名称。'),
  namespace?: string(name='Namespace', description='应用所属命名空间。'),
  type?: string(name='Type', description='应用类型。'),
  action?: string(name='action', description='触发器行为。'),
}

model GetKubernetesTriggerResponse = {
  headers: map[string]string(name='headers'),
  body: [ 
    {
      id?: string(name='id', description='触发器ID。'),
      name?: string(name='name', description='触发器名称。'),
      clusterId?: string(name='cluster_id', description='集群ID'),
      projectId?: string(name='project_id', description='触发器项目名称'),
      type?: string(name='type', description='触发器类型。'),
      action?: string(name='action', description='触发器行为'),
      token?: string(name='token', description='Token'),
    }
  ](name='body'),
}

async function getKubernetesTrigger(ClusterId: string, request: GetKubernetesTriggerRequest): GetKubernetesTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getKubernetesTriggerWithOptions(ClusterId, request, headers, runtime);
}

async function getKubernetesTriggerWithOptions(ClusterId: string, request: GetKubernetesTriggerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetKubernetesTriggerResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.action)) {
    query['action'] = request.action;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetKubernetesTrigger',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/triggers/${ClusterId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model GetUpgradeStatusResponseBody = {
  errorMessage?: string(name='error_message', description='错误信息描述。'),
  precheckReportId?: string(name='precheck_report_id', description='预检查返回ID。'),
  status?: string(name='status', description='升级状态。'),
  upgradeStep?: string(name='upgrade_step', description='升级任务执行到哪一步了。'),
  upgradeTask?: {
    message?: string(name='message', description='任务描述信息。'),
    status?: string(name='status', description='任务状态：  emptry、running、success、failed'),
  }(name='upgrade_task', description='升级任务详情。'),
}

model GetUpgradeStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetUpgradeStatusResponseBody(name='body'),
}

async function getUpgradeStatus(ClusterId: string): GetUpgradeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUpgradeStatusWithOptions(ClusterId, headers, runtime);
}

async function getUpgradeStatusWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetUpgradeStatusResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetUpgradeStatus',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/clusters/${ClusterId}/upgrade/status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GrantPermissionsRequest {
  body?: [ 
    {
      cluster?: string(name='cluster', description='授权目标集群id'),
      isCustom?: boolean(name='is_custom', description='该授权是否是自定义授权'),
      isRamRole?: boolean(name='is_ram_role', description='是否是 RAM 角色授权'),
      namespace?: string(name='namespace', description='命名空间名称'),
      roleName?: string(name='role_name', description='预置的角色名称'),
      roleType?: string(name='role_type', description='授权类型'),
    }
  ](name='body', description='请求体参数'),
}

model GrantPermissionsResponse = {
  headers: map[string]string(name='headers'),
}

async function grantPermissions(uid: string, request: GrantPermissionsRequest): GrantPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return grantPermissionsWithOptions(uid, request, headers, runtime);
}

async function grantPermissionsWithOptions(uid: string, request: GrantPermissionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GrantPermissionsResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'GrantPermissions',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/permissions/users/${uid}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model InstallClusterAddonsRequest {
  body?: [ 
    {
      config?: string(name='config', description='组件配置信息。'),
      name?: string(name='name', description='组件名称。'),
      version?: string(name='version', description='组件版本号。'),
    }
  ](name='body', description='Addon列表。'),
}

model InstallClusterAddonsResponse = {
  headers: map[string]string(name='headers'),
}

async function installClusterAddons(ClusterId: string, request: InstallClusterAddonsRequest): InstallClusterAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installClusterAddonsWithOptions(ClusterId, request, headers, runtime);
}

async function installClusterAddonsWithOptions(ClusterId: string, request: InstallClusterAddonsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallClusterAddonsResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'InstallClusterAddons',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/components/install`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='next_token', description='下一次查询Token。'),
  regionId?: string(name='region_id', description='地域ID'),
  resourceIds?: [ string ](name='resource_ids', description='集群ID列表。'),
  resourceType?: string(name='resource_type', description='资源类型，只支持Cluster'),
  tags?: [
    Tag
  ](name='tags', description='按标签查找。'),
}

model ListTagResourcesShrinkRequest {
  nextToken?: string(name='next_token', description='下一次查询Token。'),
  regionId?: string(name='region_id', description='地域ID'),
  resourceIdsShrink?: string(name='resource_ids', description='集群ID列表。'),
  resourceType?: string(name='resource_type', description='资源类型，只支持Cluster'),
  tagsShrink?: string(name='tags', description='按标签查找。'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='next_token', description='下一个查询开始Token，为空说明没有下一个'),
  requestId?: string(name='request_id', description='请求ID。'),
  tagResources?: {
    tagResource?: [ 
      {
        resourceId?: string(name='resource_id', description='资源ID。'),
        resourceType?: string(name='resource_type', description='资源类型。'),
        tagKey?: string(name='tag_key', description='标签key。'),
        tagValue?: string(name='tag_value', description='标签值。'),
      }
    ](name='tag_resource', description='资源标签。'),
  }(name='tag_resources', description='资源标签列表。'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

async function listTagResourcesWithOptions(tmpReq: ListTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceIds)) {
    request.resourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceIds, 'resource_ids', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'tags', 'json');
  }
  var query : map[string]any= {};
  if (!Util.isUnset(request.nextToken)) {
    query['next_token'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['region_id'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceIdsShrink)) {
    query['resource_ids'] = request.resourceIdsShrink;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resource_type'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['tags'] = request.tagsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model MigrateClusterResponse = {
  headers: map[string]string(name='headers'),
}

async function migrateCluster(clusterId: string): MigrateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return migrateClusterWithOptions(clusterId, headers, runtime);
}

async function migrateClusterWithOptions(clusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): MigrateClusterResponse {
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'MigrateCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/migrate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ModifyClusterRequest {
  apiServerEip?: boolean(name='api_server_eip', description='集群是否绑定EIP，用于公网访问API Server。 true | false'),
  apiServerEipId?: string(name='api_server_eip_id', description='集群API Server 公网连接端点。'),
  deletionProtection?: boolean(name='deletion_protection', description='集群是否开启删除保护。默认值false。'),
  enableRrsa?: boolean(name='enable_rrsa', description='启用或禁用 RRSA 功能。true: 启用，false: 禁用'),
  ingressDomainRebinding?: string(name='ingress_domain_rebinding', description='域名是否重新绑定到Ingress的SLB地址。'),
  ingressLoadbalancerId?: string(name='ingress_loadbalancer_id', description='集群的Ingress SLB的ID。'),
  instanceDeletionProtection?: boolean(name='instance_deletion_protection', description='实例删除保护，防止通过控制台或API误删除释放节点。'),
  maintenanceWindow?: MaintenanceWindow(name='maintenance_window'),
  resourceGroupId?: string(name='resource_group_id', description='集群资源组ID。'),
}

model ModifyClusterResponseBody = {
  clusterId?: string(name='cluster_id', description='集群ID。'),
  requestId?: string(name='request_id', description='请求ID。'),
  taskId?: string(name='task_id', description='任务ID。'),
}

model ModifyClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterResponseBody(name='body'),
}

async function modifyCluster(ClusterId: string, request: ModifyClusterRequest): ModifyClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyClusterWithOptions(ClusterId, request, headers, runtime);
}

async function modifyClusterWithOptions(ClusterId: string, request: ModifyClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyClusterResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.apiServerEip)) {
    body['api_server_eip'] = request.apiServerEip;
  }
  if (!Util.isUnset(request.apiServerEipId)) {
    body['api_server_eip_id'] = request.apiServerEipId;
  }
  if (!Util.isUnset(request.deletionProtection)) {
    body['deletion_protection'] = request.deletionProtection;
  }
  if (!Util.isUnset(request.enableRrsa)) {
    body['enable_rrsa'] = request.enableRrsa;
  }
  if (!Util.isUnset(request.ingressDomainRebinding)) {
    body['ingress_domain_rebinding'] = request.ingressDomainRebinding;
  }
  if (!Util.isUnset(request.ingressLoadbalancerId)) {
    body['ingress_loadbalancer_id'] = request.ingressLoadbalancerId;
  }
  if (!Util.isUnset(request.instanceDeletionProtection)) {
    body['instance_deletion_protection'] = request.instanceDeletionProtection;
  }
  if (!Util.isUnset(request.maintenanceWindow)) {
    body['maintenance_window'] = request.maintenanceWindow;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resource_group_id'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/clusters/${ClusterId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyClusterAddonRequest {
  config?: string(name='config', description='自定义参数设置'),
}

model ModifyClusterAddonResponse = {
  headers: map[string]string(name='headers'),
}

async function modifyClusterAddon(clusterId: string, componentId: string, request: ModifyClusterAddonRequest): ModifyClusterAddonResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyClusterAddonWithOptions(clusterId, componentId, request, headers, runtime);
}

async function modifyClusterAddonWithOptions(clusterId: string, componentId: string, request: ModifyClusterAddonRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyClusterAddonResponse {
  Util.validateModel(request);
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  componentId = OpenApiUtil.getEncodeParam(componentId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.config)) {
    body['config'] = request.config;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterAddon',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/components/${componentId}/config`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ModifyClusterConfigurationRequest {
  customizeConfig?: [ 
    {
      configs?: [ 
        {
          key?: string(name='key', description='key值。'),
          value?: string(name='value', description='value值。'),
        }
      ](name='configs', description='组件配置。'),
      name?: string(name='name', description='组件名称。'),
    }
  ](name='customize_config', description='自定义配置。'),
}

model ModifyClusterConfigurationResponse = {
  headers: map[string]string(name='headers'),
}

async function modifyClusterConfiguration(ClusterId: string, request: ModifyClusterConfigurationRequest): ModifyClusterConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyClusterConfigurationWithOptions(ClusterId, request, headers, runtime);
}

async function modifyClusterConfigurationWithOptions(ClusterId: string, request: ModifyClusterConfigurationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyClusterConfigurationResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.customizeConfig)) {
    body['customize_config'] = request.customizeConfig;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterConfiguration',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/configuration`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ModifyClusterNodePoolRequest {
  autoScaling?: {
    eipBandwidth?: long(name='eip_bandwidth', description='带宽峰值。'),
    eipInternetChargeType?: string(name='eip_internet_charge_type', description='EIP计费类型。'),
    enable?: boolean(name='enable', description='是否开启自动伸缩。'),
    isBondEip?: boolean(name='is_bond_eip', description='是否绑定EIP。'),
    maxInstances?: long(name='max_instances', description='最大实例数。'),
    minInstances?: long(name='min_instances', description='最小实例数。'),
    type?: string(name='type', description='自动伸缩节点类型。'),
  }(name='auto_scaling', description='自动伸缩节点池配置。'),
  kubernetesConfig?: {
    cmsEnabled?: boolean(name='cms_enabled', description='是否开启云监控。'),
    cpuPolicy?: string(name='cpu_policy', description='CPU管理策略。'),
    labels?: [
      Tag
    ](name='labels', description='节点标签。'),
    runtime?: string(name='runtime', description='容器运行时。'),
    runtimeVersion?: string(name='runtime_version', description='容器运行时版本。'),
    taints?: [
      Taint
    ](name='taints', description='污点配置。'),
    userData?: string(name='user_data', description='实例自定义数据。'),
  }(name='kubernetes_config', description='集群配置。'),
  management?: {
    autoRepair?: boolean(name='auto_repair', description='是否开启自动修复。'),
    enable?: boolean(name='enable', description='是否启用托管节点池。'),
    upgradeConfig?: {
      autoUpgrade?: boolean(name='auto_upgrade', description='是否启用自动升级，自修复。'),
      maxUnavailable?: long(name='max_unavailable', description='最大不可用节点数量。'),
      surge?: long(name='surge', description='额外节点数量。'),
      surgePercentage?: long(name='surge_percentage', description='额外节点比例， 和surge 二选一。'),
    }(name='upgrade_config', description='自动升级配置。'),
  }(name='management', description='托管版节点池配置。'),
  nodepoolInfo?: {
    name?: string(name='name', description='节点池名称。'),
    resourceGroupId?: string(name='resource_group_id', description='资源组ID。'),
  }(name='nodepool_info', description='节点池配置。'),
  scalingGroup?: {
    autoRenew?: boolean(name='auto_renew', description='节点池节点是启用自动续费'),
    autoRenewPeriod?: long(name='auto_renew_period', description='节点池节点自动续费周期'),
    compensateWithOnDemand?: boolean(name='compensate_with_on_demand', description='当MultiAZPolicy取值为COST_OPTIMIZED时，如果因价格、库存等原因无法创建足够的抢占式实例，是否允许自动尝试创建按量实例满足ECS实例数量要求。取值范围：true：允许。false：不允许。默认值：true'),
    dataDisks?: [
      DataDisk
    ](name='data_disks', description='数据盘配置。'),
    imageId?: string(name='image_id', description='自定义镜像'),
    instanceChargeType?: string(name='instance_charge_type', description='节点付费类型。'),
    instanceTypes?: [ string ](name='instance_types', description='节点实例规格。'),
    internetChargeType?: string(name='internet_charge_type', description='节点公网IP网络计费类型'),
    internetMaxBandwidthOut?: long(name='internet_max_bandwidth_out', description='节点公网IP出带宽最大值，单位为Mbps（Mega bit per second），取值范围：1~100'),
    keyPair?: string(name='key_pair', description='密钥对名称，和login_password二选一。'),
    loginPassword?: string(name='login_password', description='SSH登录密码，和key_pari二选一。'),
    multiAzPolicy?: string(name='multi_az_policy', description='多可用区伸缩组ECS实例扩缩容策略'),
    onDemandBaseCapacity?: long(name='on_demand_base_capacity', description='伸缩组所需要按量实例个数的最小值，取值范围：0~1000。当按量实例个数少于该值时，将优先创建按量实例。'),
    onDemandPercentageAboveBaseCapacity?: long(name='on_demand_percentage_above_base_capacity', description='伸缩组满足最小按量实例数（OnDemandBaseCapacity）要求后，超出的实例中按量实例应占的比例，取值范围：0～100。'),
    period?: long(name='period', description='包年包月时长'),
    periodUnit?: string(name='period_unit', description='付费周期'),
    platform?: string(name='platform', description='操作系统发行版。'),
    rdsInstances?: [ string ](name='rds_instances', description='RDS实例列表。'),
    scalingPolicy?: string(name='scaling_policy', description='扩容策略。'),
    spotInstancePools?: long(name='spot_instance_pools', description='指定可用实例规格的个数，伸缩组将按成本最低的多个规格均衡创建抢占式实例。取值范围：1~10。'),
    spotInstanceRemedy?: boolean(name='spot_instance_remedy', description='是否开启补齐抢占式实例。开启后，当收到抢占式实例将被回收的系统消息时，伸缩组将尝试创建新的实例，替换掉将被回收的抢占式实例。'),
    spotPriceLimit?: [ 
      {
        instanceType?: string(name='instance_type', description='抢占式实例规格'),
        priceLimit?: string(name='price_limit', description='单台实例上限价格，单位：元/小时。'),
      }
    ](name='spot_price_limit', description='抢占实例价格上限配置'),
    spotStrategy?: string(name='spot_strategy', description='抢占式实例类型'),
    systemDiskCategory?: string(name='system_disk_category', description='节点系统盘类型。'),
    systemDiskPerformanceLevel?: string(name='system_disk_performance_level', description='节点系统盘磁盘性能，只针对ESSD磁盘生效'),
    systemDiskSize?: long(name='system_disk_size', description='节点系统盘大小。'),
    tags?: [
      Tag
    ](name='tags', description='ECS标签。'),
    vswitchIds?: [ string ](name='vswitch_ids', description='节点使用的虚拟交换机ID。'),
  }(name='scaling_group', description='扩容组配置。'),
  teeConfig?: {
    teeEnable?: boolean(name='tee_enable', description='是否为加密计算节点池。'),
  }(name='tee_config', description='加密计算配置。'),
  updateNodes?: boolean(name='update_nodes', description='是否同步更新节点标签及污点。'),
}

model ModifyClusterNodePoolResponseBody = {
  nodepoolId?: string(name='nodepool_id', description='节点池ID。'),
  taskId?: string(name='task_id', description='任务ID。'),
}

model ModifyClusterNodePoolResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterNodePoolResponseBody(name='body'),
}

async function modifyClusterNodePool(ClusterId: string, NodepoolId: string, request: ModifyClusterNodePoolRequest): ModifyClusterNodePoolResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyClusterNodePoolWithOptions(ClusterId, NodepoolId, request, headers, runtime);
}

async function modifyClusterNodePoolWithOptions(ClusterId: string, NodepoolId: string, request: ModifyClusterNodePoolRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyClusterNodePoolResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  NodepoolId = OpenApiUtil.getEncodeParam(NodepoolId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.autoScaling)) {
    body['auto_scaling'] = request.autoScaling;
  }
  if (!Util.isUnset(request.kubernetesConfig)) {
    body['kubernetes_config'] = request.kubernetesConfig;
  }
  if (!Util.isUnset(request.management)) {
    body['management'] = request.management;
  }
  if (!Util.isUnset(request.nodepoolInfo)) {
    body['nodepool_info'] = request.nodepoolInfo;
  }
  if (!Util.isUnset(request.scalingGroup)) {
    body['scaling_group'] = request.scalingGroup;
  }
  if (!Util.isUnset(request.teeConfig)) {
    body['tee_config'] = request.teeConfig;
  }
  if (!Util.isUnset(request.updateNodes)) {
    body['update_nodes'] = request.updateNodes;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterNodePool',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/nodepools/${NodepoolId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyClusterTagsRequest {
  body?: [
    Tag
  ](name='body', description='集群标签列表。'),
}

model ModifyClusterTagsResponse = {
  headers: map[string]string(name='headers'),
}

async function modifyClusterTags(ClusterId: string, request: ModifyClusterTagsRequest): ModifyClusterTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyClusterTagsWithOptions(ClusterId, request, headers, runtime);
}

async function modifyClusterTagsWithOptions(ClusterId: string, request: ModifyClusterTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyClusterTagsResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterTags',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/tags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ModifyPolicyInstanceRequest {
  action?: string(name='action', description='规则治理动作'),
  instanceName?: string(name='instance_name', description='策略规则实例id'),
  namespace?: string(name='namespace', description='策略实例实施范围'),
  parameters?: map[string]any(name='parameters', description='当前规则实例的配置参数'),
}

model ModifyPolicyInstanceResponseBody = {
  instances?: [ string ](name='instances'),
}

model ModifyPolicyInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPolicyInstanceResponseBody(name='body'),
}

async function modifyPolicyInstance(clusterId: string, policyName: string, request: ModifyPolicyInstanceRequest): ModifyPolicyInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyPolicyInstanceWithOptions(clusterId, policyName, request, headers, runtime);
}

async function modifyPolicyInstanceWithOptions(clusterId: string, policyName: string, request: ModifyPolicyInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyPolicyInstanceResponse {
  Util.validateModel(request);
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  policyName = OpenApiUtil.getEncodeParam(policyName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.action)) {
    body['action'] = request.action;
  }
  if (!Util.isUnset(request.instanceName)) {
    body['instance_name'] = request.instanceName;
  }
  if (!Util.isUnset(request.namespace)) {
    body['namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.parameters)) {
    body['parameters'] = request.parameters;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPolicyInstance',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/policies/${policyName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model OpenAckServiceRequest {
  type?: string(name='type', description='要开通的服务类型'),
}

model OpenAckServiceResponseBody = {
  orderId?: string(name='order_id', description='开通服务的订单号。'),
  requestId?: string(name='request_id', description='请求ID'),
}

model OpenAckServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenAckServiceResponseBody(name='body'),
}

async function openAckService(request: OpenAckServiceRequest): OpenAckServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return openAckServiceWithOptions(request, headers, runtime);
}

async function openAckServiceWithOptions(request: OpenAckServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): OpenAckServiceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenAckService',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/service/open`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PauseClusterUpgradeResponse = {
  headers: map[string]string(name='headers'),
}

async function pauseClusterUpgrade(ClusterId: string): PauseClusterUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return pauseClusterUpgradeWithOptions(ClusterId, headers, runtime);
}

async function pauseClusterUpgradeWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): PauseClusterUpgradeResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'PauseClusterUpgrade',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/clusters/${ClusterId}/upgrade/pause`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model PauseComponentUpgradeResponse = {
  headers: map[string]string(name='headers'),
}

async function pauseComponentUpgrade(clusterid: string, componentid: string): PauseComponentUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return pauseComponentUpgradeWithOptions(clusterid, componentid, headers, runtime);
}

async function pauseComponentUpgradeWithOptions(clusterid: string, componentid: string, headers: map[string]string, runtime: Util.RuntimeOptions): PauseComponentUpgradeResponse {
  clusterid = OpenApiUtil.getEncodeParam(clusterid);
  componentid = OpenApiUtil.getEncodeParam(componentid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'PauseComponentUpgrade',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterid}/components/${componentid}/pause`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model RemoveClusterNodesRequest {
  drainNode?: boolean(name='drain_node', description='是否排空节点上的Pod。'),
  nodes?: [ string ](name='nodes', description='要移除的Node列表。'),
  releaseNode?: boolean(name='release_node', description='是否同时释放ECS。'),
}

model RemoveClusterNodesResponse = {
  headers: map[string]string(name='headers'),
}

async function removeClusterNodes(ClusterId: string, request: RemoveClusterNodesRequest): RemoveClusterNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeClusterNodesWithOptions(ClusterId, request, headers, runtime);
}

async function removeClusterNodesWithOptions(ClusterId: string, request: RemoveClusterNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveClusterNodesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.drainNode)) {
    body['drain_node'] = request.drainNode;
  }
  if (!Util.isUnset(request.nodes)) {
    body['nodes'] = request.nodes;
  }
  if (!Util.isUnset(request.releaseNode)) {
    body['release_node'] = request.releaseNode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveClusterNodes',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/clusters/${ClusterId}/nodes/remove`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model RemoveWorkflowResponse = {
  headers: map[string]string(name='headers'),
}

async function removeWorkflow(workflowName: string): RemoveWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeWorkflowWithOptions(workflowName, headers, runtime);
}

async function removeWorkflowWithOptions(workflowName: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveWorkflowResponse {
  workflowName = OpenApiUtil.getEncodeParam(workflowName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveWorkflow',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/gs/workflow/${workflowName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ResumeComponentUpgradeResponse = {
  headers: map[string]string(name='headers'),
}

async function resumeComponentUpgrade(clusterid: string, componentid: string): ResumeComponentUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resumeComponentUpgradeWithOptions(clusterid, componentid, headers, runtime);
}

async function resumeComponentUpgradeWithOptions(clusterid: string, componentid: string, headers: map[string]string, runtime: Util.RuntimeOptions): ResumeComponentUpgradeResponse {
  clusterid = OpenApiUtil.getEncodeParam(clusterid);
  componentid = OpenApiUtil.getEncodeParam(componentid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ResumeComponentUpgrade',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterid}/components/${componentid}/resume`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ResumeUpgradeClusterResponse = {
  headers: map[string]string(name='headers'),
}

async function resumeUpgradeCluster(ClusterId: string): ResumeUpgradeClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resumeUpgradeClusterWithOptions(ClusterId, headers, runtime);
}

async function resumeUpgradeClusterWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ResumeUpgradeClusterResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ResumeUpgradeCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/clusters/${ClusterId}/upgrade/resume`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ScaleClusterRequest {
  cloudMonitorFlags?: boolean(name='cloud_monitor_flags', description='节点是否安装云监控插件。'),
  count?: long(name='count', description='扩容节点数。'),
  cpuPolicy?: string(name='cpu_policy', description='节点CPU策略。'),
  disableRollback?: boolean(name='disable_rollback', description='失败是否回滚。'),
  keyPair?: string(name='key_pair', description='keypair名称，和login_password二选一。'),
  loginPassword?: string(name='login_password', description='SSH登录密码。和keypair二选一。'),
  tags?: [ 
    {
      key?: string(name='key', description='标签值。'),
    }
  ](name='tags', description='集群标签。'),
  taints?: [ 
    {
      effect?: string(name='effect', description='污点生效策略。'),
      key?: string(name='key', description='污点键。'),
      value?: string(name='value', description='污点值。'),
    }
  ](name='taints', description='节点污点标记。'),
  vswitchIds?: [ string ](name='vswitch_ids', description='节点交换机ID列表。'),
  workerAutoRenew?: boolean(name='worker_auto_renew', description='节点是否开启Worker节点自动续费。'),
  workerAutoRenewPeriod?: long(name='worker_auto_renew_period', description='自动续费周期。'),
  workerDataDisk?: boolean(name='worker_data_disk', description='是否挂载数据盘。'),
  workerDataDisks?: [ 
    {
      category?: string(name='category', description='数据盘类型。'),
      encrypted?: string(name='encrypted', description='是否对数据盘加密。'),
      size?: string(name='size', description='数据盘大小。'),
    }
  ](name='worker_data_disks', description='Worker数据盘类型、大小等配置的组合。'),
  workerInstanceChargeType?: string(name='worker_instance_charge_type', description='节点付费类型。'),
  workerInstanceTypes?: [ string ](name='worker_instance_types', description='Worker节点ECS规格类型。'),
  workerPeriod?: long(name='worker_period', description='节点包年包月时长。'),
  workerPeriodUnit?: string(name='worker_period_unit', description='当指定为PrePaid的时候需要指定周期。'),
  workerSystemDiskCategory?: string(name='worker_system_disk_category', description='节点系统盘类型。'),
  workerSystemDiskSize?: long(name='worker_system_disk_size', description='节点系统盘大小'),
}

model ScaleClusterResponseBody = {
  clusterId?: string(name='cluster_id', description='集群ID。'),
  requestId?: string(name='request_id', description='请求ID。'),
  taskId?: string(name='task_id', description='任务ID。'),
}

model ScaleClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ScaleClusterResponseBody(name='body'),
}

async function scaleCluster(ClusterId: string, request: ScaleClusterRequest): ScaleClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleClusterWithOptions(ClusterId, request, headers, runtime);
}

async function scaleClusterWithOptions(ClusterId: string, request: ScaleClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleClusterResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.cloudMonitorFlags)) {
    body['cloud_monitor_flags'] = request.cloudMonitorFlags;
  }
  if (!Util.isUnset(request.count)) {
    body['count'] = request.count;
  }
  if (!Util.isUnset(request.cpuPolicy)) {
    body['cpu_policy'] = request.cpuPolicy;
  }
  if (!Util.isUnset(request.disableRollback)) {
    body['disable_rollback'] = request.disableRollback;
  }
  if (!Util.isUnset(request.keyPair)) {
    body['key_pair'] = request.keyPair;
  }
  if (!Util.isUnset(request.loginPassword)) {
    body['login_password'] = request.loginPassword;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.taints)) {
    body['taints'] = request.taints;
  }
  if (!Util.isUnset(request.vswitchIds)) {
    body['vswitch_ids'] = request.vswitchIds;
  }
  if (!Util.isUnset(request.workerAutoRenew)) {
    body['worker_auto_renew'] = request.workerAutoRenew;
  }
  if (!Util.isUnset(request.workerAutoRenewPeriod)) {
    body['worker_auto_renew_period'] = request.workerAutoRenewPeriod;
  }
  if (!Util.isUnset(request.workerDataDisk)) {
    body['worker_data_disk'] = request.workerDataDisk;
  }
  if (!Util.isUnset(request.workerDataDisks)) {
    body['worker_data_disks'] = request.workerDataDisks;
  }
  if (!Util.isUnset(request.workerInstanceChargeType)) {
    body['worker_instance_charge_type'] = request.workerInstanceChargeType;
  }
  if (!Util.isUnset(request.workerInstanceTypes)) {
    body['worker_instance_types'] = request.workerInstanceTypes;
  }
  if (!Util.isUnset(request.workerPeriod)) {
    body['worker_period'] = request.workerPeriod;
  }
  if (!Util.isUnset(request.workerPeriodUnit)) {
    body['worker_period_unit'] = request.workerPeriodUnit;
  }
  if (!Util.isUnset(request.workerSystemDiskCategory)) {
    body['worker_system_disk_category'] = request.workerSystemDiskCategory;
  }
  if (!Util.isUnset(request.workerSystemDiskSize)) {
    body['worker_system_disk_size'] = request.workerSystemDiskSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ScaleCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ScaleClusterNodePoolRequest {
  count?: long(name='count', description='扩容节点数量'),
}

model ScaleClusterNodePoolResponseBody = {
  taskId?: string(name='task_id', description='任务ID。'),
}

model ScaleClusterNodePoolResponse = {
  headers: map[string]string(name='headers'),
  body: ScaleClusterNodePoolResponseBody(name='body'),
}

async function scaleClusterNodePool(ClusterId: string, NodepoolId: string, request: ScaleClusterNodePoolRequest): ScaleClusterNodePoolResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleClusterNodePoolWithOptions(ClusterId, NodepoolId, request, headers, runtime);
}

async function scaleClusterNodePoolWithOptions(ClusterId: string, NodepoolId: string, request: ScaleClusterNodePoolRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleClusterNodePoolResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  NodepoolId = OpenApiUtil.getEncodeParam(NodepoolId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.count)) {
    body['count'] = request.count;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ScaleClusterNodePool',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/nodepools/${NodepoolId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ScaleOutClusterRequest {
  cloudMonitorFlags?: boolean(name='cloud_monitor_flags', description='在节点上安装云监控'),
  count?: long(name='count', description='扩容节点数'),
  cpuPolicy?: string(name='cpu_policy', description='CPU亲和性策略'),
  imageId?: string(name='image_id', description='自定义镜像'),
  keyPair?: string(name='key_pair', description='keypair名称，和login_password二选一。'),
  loginPassword?: string(name='login_password', description='SSH登录密码，和key_pair二选一。'),
  rdsInstances?: [ string ](name='rds_instances', description='RDS白名单'),
  runtime?: Runtime(name='runtime'),
  tags?: [
    Tag
  ](name='tags', description='节点标签'),
  taints?: [
    Taint
  ](name='taints', description='节点污点信息'),
  userData?: string(name='user_data', description='节点自定义数据'),
  vswitchIds?: [ string ](name='vswitch_ids', description='虚拟交换机'),
  workerAutoRenew?: boolean(name='worker_auto_renew', description='Worker节点到期是否自动续费'),
  workerAutoRenewPeriod?: long(name='worker_auto_renew_period', description='Worker节点自动续费时长'),
  workerDataDisks?: [ 
    {
      autoSnapshotPolicyId?: string(name='auto_snapshot_policy_id', description='自动快照策略ID，云盘会按照快照策略自动备份。'),
      category?: string(name='category', description='数据盘类型,默认值：cloud_efficiency'),
      encrypted?: string(name='encrypted', description='是否对数据盘加密'),
      size?: string(name='size', description='数据盘大小，单位为GiB。  取值范围：[40,32768]'),
    }
  ](name='worker_data_disks', description='Worker节点数据盘配置'),
  workerInstanceChargeType?: string(name='worker_instance_charge_type', description='Worker节点付费类型'),
  workerInstanceTypes?: [ string ](name='worker_instance_types', description='Worker节点实例规格'),
  workerPeriod?: long(name='worker_period', description='Worker节点包年包月时长'),
  workerPeriodUnit?: string(name='worker_period_unit', description='Worker节点包年包月周期'),
  workerSystemDiskCategory?: string(name='worker_system_disk_category', description='Worker节点系统盘类型'),
  workerSystemDiskSize?: long(name='worker_system_disk_size', description='Worker节点系统盘大小'),
}

model ScaleOutClusterResponseBody = {
  clusterId?: string(name='cluster_id', description='集群ID。'),
  requestId?: string(name='request_id', description='请求ID。'),
  taskId?: string(name='task_id', description='任务ID。'),
}

model ScaleOutClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ScaleOutClusterResponseBody(name='body'),
}

async function scaleOutCluster(ClusterId: string, request: ScaleOutClusterRequest): ScaleOutClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleOutClusterWithOptions(ClusterId, request, headers, runtime);
}

async function scaleOutClusterWithOptions(ClusterId: string, request: ScaleOutClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleOutClusterResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.cloudMonitorFlags)) {
    body['cloud_monitor_flags'] = request.cloudMonitorFlags;
  }
  if (!Util.isUnset(request.count)) {
    body['count'] = request.count;
  }
  if (!Util.isUnset(request.cpuPolicy)) {
    body['cpu_policy'] = request.cpuPolicy;
  }
  if (!Util.isUnset(request.imageId)) {
    body['image_id'] = request.imageId;
  }
  if (!Util.isUnset(request.keyPair)) {
    body['key_pair'] = request.keyPair;
  }
  if (!Util.isUnset(request.loginPassword)) {
    body['login_password'] = request.loginPassword;
  }
  if (!Util.isUnset(request.rdsInstances)) {
    body['rds_instances'] = request.rdsInstances;
  }
  if (!Util.isUnset(request.runtime)) {
    body['runtime'] = request.runtime;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.taints)) {
    body['taints'] = request.taints;
  }
  if (!Util.isUnset(request.userData)) {
    body['user_data'] = request.userData;
  }
  if (!Util.isUnset(request.vswitchIds)) {
    body['vswitch_ids'] = request.vswitchIds;
  }
  if (!Util.isUnset(request.workerAutoRenew)) {
    body['worker_auto_renew'] = request.workerAutoRenew;
  }
  if (!Util.isUnset(request.workerAutoRenewPeriod)) {
    body['worker_auto_renew_period'] = request.workerAutoRenewPeriod;
  }
  if (!Util.isUnset(request.workerDataDisks)) {
    body['worker_data_disks'] = request.workerDataDisks;
  }
  if (!Util.isUnset(request.workerInstanceChargeType)) {
    body['worker_instance_charge_type'] = request.workerInstanceChargeType;
  }
  if (!Util.isUnset(request.workerInstanceTypes)) {
    body['worker_instance_types'] = request.workerInstanceTypes;
  }
  if (!Util.isUnset(request.workerPeriod)) {
    body['worker_period'] = request.workerPeriod;
  }
  if (!Util.isUnset(request.workerPeriodUnit)) {
    body['worker_period_unit'] = request.workerPeriodUnit;
  }
  if (!Util.isUnset(request.workerSystemDiskCategory)) {
    body['worker_system_disk_category'] = request.workerSystemDiskCategory;
  }
  if (!Util.isUnset(request.workerSystemDiskSize)) {
    body['worker_system_disk_size'] = request.workerSystemDiskSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ScaleOutCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/clusters/${ClusterId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StartWorkflowRequest {
  mappingBamOutFilename?: string(name='mapping_bam_out_filename', description='bam文件输出名称。'),
  mappingBamOutPath?: string(name='mapping_bam_out_path', description='bam文件输出路径。'),
  mappingBucketName?: string(name='mapping_bucket_name', description='存放mapping的bucket名称。'),
  mappingFastqFirstFilename?: string(name='mapping_fastq_first_filename', description='mapping的第一个fastq文件名。'),
  mappingFastqPath?: string(name='mapping_fastq_path', description='mapping的fastq文件路径。'),
  mappingFastqSecondFilename?: string(name='mapping_fastq_second_filename', description='mapping的第二个fastq文件名。'),
  mappingIsMarkDup?: string(name='mapping_is_mark_dup', description='是否进行dup。'),
  mappingOssRegion?: string(name='mapping_oss_region', description='mapping oss数据的存放region。'),
  mappingReferencePath?: string(name='mapping_reference_path', description='mapping的reference文件位置。'),
  service?: string(name='service', description='SLA类型，可选值：s、g、p。 白银级（s）：超过90 Gbp的部分，按1.5 Gbp/min计算增加的时间。 黄金级（g）：超过90 Gbp的部分，按2 Gbp/min计算增加的时间。 铂金级（p）：超过90 Gbp的部分，按3 Gbp/min计算增加的时间。'),
  wgsBucketName?: string(name='wgs_bucket_name', description='存放wgs的bucket名称。'),
  wgsFastqFirstFilename?: string(name='wgs_fastq_first_filename', description='wgs的第一个fastq文件名。'),
  wgsFastqPath?: string(name='wgs_fastq_path', description='wgs的fastq文件路径。'),
  wgsFastqSecondFilename?: string(name='wgs_fastq_second_filename', description='wgs的第二个fastq文件名。'),
  wgsOssRegion?: string(name='wgs_oss_region', description='wgs oss数据的存放region。'),
  wgsReferencePath?: string(name='wgs_reference_path', description='wgs的reference文件路径。'),
  wgsVcfOutFilename?: string(name='wgs_vcf_out_filename', description='wgs的vcf输出文件名称。'),
  wgsVcfOutPath?: string(name='wgs_vcf_out_path', description='wgs的vcf输出路径。'),
  workflowType?: string(name='workflow_type', description='工作流类型，可选值：wgs或mapping。'),
}

model StartWorkflowResponseBody = {
  jobName?: string(name='JobName', description='工作流名称'),
}

model StartWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: StartWorkflowResponseBody(name='body'),
}

async function startWorkflow(request: StartWorkflowRequest): StartWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startWorkflowWithOptions(request, headers, runtime);
}

async function startWorkflowWithOptions(request: StartWorkflowRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StartWorkflowResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.mappingBamOutFilename)) {
    body['mapping_bam_out_filename'] = request.mappingBamOutFilename;
  }
  if (!Util.isUnset(request.mappingBamOutPath)) {
    body['mapping_bam_out_path'] = request.mappingBamOutPath;
  }
  if (!Util.isUnset(request.mappingBucketName)) {
    body['mapping_bucket_name'] = request.mappingBucketName;
  }
  if (!Util.isUnset(request.mappingFastqFirstFilename)) {
    body['mapping_fastq_first_filename'] = request.mappingFastqFirstFilename;
  }
  if (!Util.isUnset(request.mappingFastqPath)) {
    body['mapping_fastq_path'] = request.mappingFastqPath;
  }
  if (!Util.isUnset(request.mappingFastqSecondFilename)) {
    body['mapping_fastq_second_filename'] = request.mappingFastqSecondFilename;
  }
  if (!Util.isUnset(request.mappingIsMarkDup)) {
    body['mapping_is_mark_dup'] = request.mappingIsMarkDup;
  }
  if (!Util.isUnset(request.mappingOssRegion)) {
    body['mapping_oss_region'] = request.mappingOssRegion;
  }
  if (!Util.isUnset(request.mappingReferencePath)) {
    body['mapping_reference_path'] = request.mappingReferencePath;
  }
  if (!Util.isUnset(request.service)) {
    body['service'] = request.service;
  }
  if (!Util.isUnset(request.wgsBucketName)) {
    body['wgs_bucket_name'] = request.wgsBucketName;
  }
  if (!Util.isUnset(request.wgsFastqFirstFilename)) {
    body['wgs_fastq_first_filename'] = request.wgsFastqFirstFilename;
  }
  if (!Util.isUnset(request.wgsFastqPath)) {
    body['wgs_fastq_path'] = request.wgsFastqPath;
  }
  if (!Util.isUnset(request.wgsFastqSecondFilename)) {
    body['wgs_fastq_second_filename'] = request.wgsFastqSecondFilename;
  }
  if (!Util.isUnset(request.wgsOssRegion)) {
    body['wgs_oss_region'] = request.wgsOssRegion;
  }
  if (!Util.isUnset(request.wgsReferencePath)) {
    body['wgs_reference_path'] = request.wgsReferencePath;
  }
  if (!Util.isUnset(request.wgsVcfOutFilename)) {
    body['wgs_vcf_out_filename'] = request.wgsVcfOutFilename;
  }
  if (!Util.isUnset(request.wgsVcfOutPath)) {
    body['wgs_vcf_out_path'] = request.wgsVcfOutPath;
  }
  if (!Util.isUnset(request.workflowType)) {
    body['workflow_type'] = request.workflowType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartWorkflow',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/gs/workflow`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model TagResourcesRequest {
  regionId?: string(name='region_id', description='资源所属的地域ID'),
  resourceIds?: [ string ](name='resource_ids', description='资源ID列表'),
  resourceType?: string(name='resource_type', description='资源类型定义。取值范围：  只支持CLUSTER这一种资源类型'),
  tags?: [
    Tag
  ](name='tags', description='资源的标签键值对。数组长度范围：1~20。一旦传值，则不允许为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含http://或者https://。'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='请求id。'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(request, headers, runtime);
}

async function tagResourcesWithOptions(request: TagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.regionId)) {
    body['region_id'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceIds)) {
    body['resource_ids'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['resource_type'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/tags`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UnInstallClusterAddonsRequest {
  addons?: [ 
    {
      name?: string(name='name', description='组件名称。'),
    }
  ](name='addons', description='卸载组件列表。'),
}

model UnInstallClusterAddonsResponse = {
  headers: map[string]string(name='headers'),
}

async function unInstallClusterAddons(ClusterId: string, request: UnInstallClusterAddonsRequest): UnInstallClusterAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unInstallClusterAddonsWithOptions(ClusterId, request, headers, runtime);
}

async function unInstallClusterAddonsWithOptions(ClusterId: string, request: UnInstallClusterAddonsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UnInstallClusterAddonsResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.addons),
  };
  var params = new OpenApi.Params{
    action = 'UnInstallClusterAddons',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/components/uninstall`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='all', description='是否删除全部自定义标签，仅当tag_keys为空时生效，取值：[true,false]。'),
  regionId?: string(name='region_id', description='资源所属的地域ID'),
  resourceIds?: [ string ](name='resource_ids', description='资源ID。数组长度取值范围为：1~50'),
  resourceType?: string(name='resource_type', description='资源类型定义。取值范围： 只支持CLUSTER这一种资源类型'),
  tagKeys?: [ string ](name='tag_keys', description='资源的标签键。N的取值范围：1~20'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='请求id。'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourcesWithOptions(request, headers, runtime);
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.all)) {
    query['all'] = request.all;
  }
  if (!Util.isUnset(request.regionId)) {
    query['region_id'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['resource_ids'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resource_type'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKeys)) {
    query['tag_keys'] = request.tagKeys;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/tags`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateK8sClusterUserConfigExpireResponse = {
  headers: map[string]string(name='headers'),
}

async function updateK8sClusterUserConfigExpire(ClusterId: string): UpdateK8sClusterUserConfigExpireResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateK8sClusterUserConfigExpireWithOptions(ClusterId, headers, runtime);
}

async function updateK8sClusterUserConfigExpireWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateK8sClusterUserConfigExpireResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UpdateK8sClusterUserConfigExpire',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/k8s/${ClusterId}/user_config/expire`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UpdateTemplateRequest {
  description?: string(name='description', description='部署模板描述信息。'),
  name?: string(name='name', description='部署模板名称。'),
  tags?: string(name='tags', description='部署模板标签'),
  template?: string(name='template', description='部署模板yaml。'),
  templateType?: string(name='template_type', description='部署模板类型。'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
}

async function updateTemplate(TemplateId: string, request: UpdateTemplateRequest): UpdateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTemplateWithOptions(TemplateId, request, headers, runtime);
}

async function updateTemplateWithOptions(TemplateId: string, request: UpdateTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTemplateResponse {
  Util.validateModel(request);
  TemplateId = OpenApiUtil.getEncodeParam(TemplateId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.template)) {
    body['template'] = request.template;
  }
  if (!Util.isUnset(request.templateType)) {
    body['template_type'] = request.templateType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTemplate',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/templates/${TemplateId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UpgradeClusterRequest {
  componentName?: string(name='component_name', description='组件名称，集群升级时取值"k8s"。'),
  nextVersion?: string(name='next_version', description='目标版本。'),
  version?: string(name='version', description='当前版本。'),
}

model UpgradeClusterResponse = {
  headers: map[string]string(name='headers'),
}

async function upgradeCluster(ClusterId: string, request: UpgradeClusterRequest): UpgradeClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return upgradeClusterWithOptions(ClusterId, request, headers, runtime);
}

async function upgradeClusterWithOptions(ClusterId: string, request: UpgradeClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpgradeClusterResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.componentName)) {
    body['component_name'] = request.componentName;
  }
  if (!Util.isUnset(request.nextVersion)) {
    body['next_version'] = request.nextVersion;
  }
  if (!Util.isUnset(request.version)) {
    body['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/clusters/${ClusterId}/upgrade`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UpgradeClusterAddonsRequest {
  body?: [ 
    {
      componentName?: string(name='component_name', description='组件名称'),
      nextVersion?: string(name='next_version', description='可升级版本'),
      version?: string(name='version', description='当前版本'),
    }
  ](name='body', description='Request body，类型是对象数组'),
}

model UpgradeClusterAddonsResponse = {
  headers: map[string]string(name='headers'),
}

async function upgradeClusterAddons(ClusterId: string, request: UpgradeClusterAddonsRequest): UpgradeClusterAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return upgradeClusterAddonsWithOptions(ClusterId, request, headers, runtime);
}

async function upgradeClusterAddonsWithOptions(ClusterId: string, request: UpgradeClusterAddonsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpgradeClusterAddonsResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeClusterAddons',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/components/upgrade`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model StandardComponentsValue = {
  name?: string(name='name', description='组件名称。'),
  version?: string(name='version', description='组件版本。'),
  description?: string(name='description', description='组件描述信息。'),
  required?: string(name='required', description='是否为必需组件。'),
  disabled?: boolean(name='disabled', description='是否禁止默认安装。'),
}

