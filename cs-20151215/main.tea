import Util;
import ROA;
import EndpointUtil;

extends ROA;

const version = '2015-12-15';

init(config: ROA.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpointHost = getEndpoint(@productId, @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpointHost);
}


model ResumeComponentUpgradeRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model ResumeComponentUpgradeResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model ResumeComponentUpgradeResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: ResumeComponentUpgradeResponseBody(name='body', description='body'),
}

async function resumeComponentUpgrade(clusterid: string, componentid: string, request: ResumeComponentUpgradeRequest, runtime: Util.RuntimeOptions): ResumeComponentUpgradeResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterid}/components/${componentid}/resume`, null, request.headers, null, runtime);
}

model PauseComponentUpgradeRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model PauseComponentUpgradeResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model PauseComponentUpgradeResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: PauseComponentUpgradeResponseBody(name='body', description='body'),
}

async function pauseComponentUpgrade(clusterid: string, componentid: string, request: PauseComponentUpgradeRequest, runtime: Util.RuntimeOptions): PauseComponentUpgradeResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterid}/components/${componentid}/pause`, null, request.headers, null, runtime);
}

model CancelComponentUpgradeRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model CancelComponentUpgradeResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model CancelComponentUpgradeResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: CancelComponentUpgradeResponseBody(name='body', description='body'),
}

async function cancelComponentUpgrade(clusterid: string, componentid: string, request: CancelComponentUpgradeRequest, runtime: Util.RuntimeOptions): CancelComponentUpgradeResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterid}/components/${componentid}/cancel`, null, request.headers, null, runtime);
}

model CancelWorkflowRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model CancelWorkflowResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function cancelWorkflow(workflowName: string, request: CancelWorkflowRequest, runtime: Util.RuntimeOptions): CancelWorkflowResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'PUT', 'AK', `/gs/workflow/${workflowName}`, null, request.headers, null, runtime);
}

model DescirbeWorkflowRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescirbeWorkflowResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function descirbeWorkflow(workflowName: string, request: DescirbeWorkflowRequest, runtime: Util.RuntimeOptions): DescirbeWorkflowResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/gs/workflow/${workflowName}`, null, request.headers, null, runtime);
}

model RemoveWorkflowRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model RemoveWorkflowResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function removeWorkflow(workflowName: string, request: RemoveWorkflowRequest, runtime: Util.RuntimeOptions): RemoveWorkflowResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'DELETE', 'AK', `/gs/workflow/${workflowName}`, null, request.headers, null, runtime);
}

model DescribeWorkflowsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeWorkflowsResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function describeWorkflows(request: DescribeWorkflowsRequest, runtime: Util.RuntimeOptions): DescribeWorkflowsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/gs/workflows`, null, request.headers, null, runtime);
}

model StartWorkflowRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model StartWorkflowResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function startWorkflow(request: StartWorkflowRequest, runtime: Util.RuntimeOptions): StartWorkflowResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/gs/workflow`, null, request.headers, null, runtime);
}

model CreateServiceMeshRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model CreateServiceMeshResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model CreateServiceMeshResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: CreateServiceMeshResponseBody(name='body', description='body'),
}

async function createServiceMesh(request: CreateServiceMeshRequest, runtime: Util.RuntimeOptions): CreateServiceMeshResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/servicemesh`, null, request.headers, null, runtime);
}

model ServiceMeshAddClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model ServiceMeshAddClusterResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model ServiceMeshAddClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: ServiceMeshAddClusterResponseBody(name='body', description='body'),
}

async function serviceMeshAddCluster(serviceMeshId: string, request: ServiceMeshAddClusterRequest, runtime: Util.RuntimeOptions): ServiceMeshAddClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'PUT', 'AK', `/servicemesh/${serviceMeshId}/add/clusters`, null, request.headers, null, runtime);
}

model ServiceMeshRemoveClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model ServiceMeshRemoveClusterResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model ServiceMeshRemoveClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: ServiceMeshRemoveClusterResponseBody(name='body', description='body'),
}

async function serviceMeshRemoveCluster(serviceMeshId: string, request: ServiceMeshRemoveClusterRequest, runtime: Util.RuntimeOptions): ServiceMeshRemoveClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'PUT', 'AK', `/servicemesh/${serviceMeshId}/remove/clusters`, null, request.headers, null, runtime);
}

model UpdateServiceMeshRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model UpdateServiceMeshResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model UpdateServiceMeshResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: UpdateServiceMeshResponseBody(name='body', description='body'),
}

async function updateServiceMesh(serviceMeshId: string, request: UpdateServiceMeshRequest, runtime: Util.RuntimeOptions): UpdateServiceMeshResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'PUT', 'AK', `/servicemesh/${serviceMeshId}`, null, request.headers, null, runtime);
}

model ServiceMeshApiServerRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model ServiceMeshApiServerResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function serviceMeshApiServer(serviceMeshId: string, request: ServiceMeshApiServerRequest, runtime: Util.RuntimeOptions): ServiceMeshApiServerResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/servicemesh/${serviceMeshId}/api_proxy`, null, request.headers, null, runtime);
}

model UnInstallClusterAddonsBody = {
  name: string(name='name', description='name'),
}

model UnInstallClusterAddonsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: UnInstallClusterAddonsBody(name='body', description='body'),
}

model UnInstallClusterAddonsResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model UnInstallClusterAddonsResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: UnInstallClusterAddonsResponseBody(name='body', description='body'),
}

async function unInstallClusterAddons(clusterId: string, request: UnInstallClusterAddonsRequest, runtime: Util.RuntimeOptions): UnInstallClusterAddonsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/components/uninstall`, null, request.headers, request.body, runtime);
}

model DescribeAddonsQuery = {
  region: string(name='region', description='region'),
}

model DescribeAddonsRequest = {
  query: DescribeAddonsQuery(name='query', description='query'),
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeAddonsResponseBody = {
  componentGroups: [
    {
      groupName: string(name='group_name', description='group_name'),
      items: [
        {
          name: string(name='name', description='name'),
          config: string(name='config', description='config'),
          required: string(name='required', description='required'),
          disabled: boolean(name='disabled', description='disabled'),
          version: string(name='version', description='version'),
        }
      ](name='items', description='items'),
      default: [ string ](name='default', description='default'),
    }
  ](name='ComponentGroups', description='ComponentGroups'),
  standardComponents: {
    addonName: {
      name: string(name='name', description='name'),
      config: string(name='config', description='config'),
      required: string(name='required', description='required'),
      disabled: boolean(name='disabled', description='disabled'),
      version: string(name='version', description='version'),
    }(name='addon_name', description='addon_name'),
  }(name='StandardComponents', description='StandardComponents'),
}

model DescribeAddonsResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeAddonsResponseBody(name='body', description='body'),
}

async function describeAddons(request: DescribeAddonsRequest, runtime: Util.RuntimeOptions): DescribeAddonsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/components/metadata`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

model UpdateK8sClusterUserConfigExpireRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model UpdateK8sClusterUserConfigExpireResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model UpdateK8sClusterUserConfigExpireResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: UpdateK8sClusterUserConfigExpireResponseBody(name='body', description='body'),
}

async function updateK8sClusterUserConfigExpire(clusterId: string, request: UpdateK8sClusterUserConfigExpireRequest, runtime: Util.RuntimeOptions): UpdateK8sClusterUserConfigExpireResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/k8s/${clusterId}/user_config/expire`, null, request.headers, null, runtime);
}

model DescribeClusterV2UserKubeconfigQuery = {
  privateIpAddress: boolean(name='PrivateIpAddress', description='PrivateIpAddress'),
}

model DescribeClusterV2UserKubeconfigRequest = {
  query: DescribeClusterV2UserKubeconfigQuery(name='query', description='query'),
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeClusterV2UserKubeconfigResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model DescribeClusterV2UserKubeconfigResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterV2UserKubeconfigResponseBody(name='body', description='body'),
}

async function describeClusterV2UserKubeconfig(clusterId: string, request: DescribeClusterV2UserKubeconfigRequest, runtime: Util.RuntimeOptions): DescribeClusterV2UserKubeconfigResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/api/v2/k8s/${clusterId}/user_config`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

model ModifyClusterTagsBody = {
  key: string(name='key', description='key'),
  value: string(name='value', description='value'),
}

model ModifyClusterTagsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: ModifyClusterTagsBody(name='body', description='body'),
}

model ModifyClusterTagsResponseBody = {
  requestId: string(name='requestId', description='requestId'),
}

model ModifyClusterTagsResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: ModifyClusterTagsResponseBody(name='body', description='body'),
}

async function modifyClusterTags(clusterId: string, request: ModifyClusterTagsRequest, runtime: Util.RuntimeOptions): ModifyClusterTagsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/tags`, null, request.headers, request.body, runtime);
}

model ScaleOutClusterBody = {
  count: integer(name='count', description='count'),
  workerInstanceChargeType: string(name='worker_instance_charge_type', description='worker_instance_charge_type'),
  workerPeriod: integer(name='worker_period', description='worker_period'),
  workerPeriodUnit: string(name='worker_period_unit', description='worker_period_unit'),
  workerAutoRenew: boolean(name='worker_auto_renew', description='worker_auto_renew'),
  workerAutoRenewPeriod: integer(name='worker_auto_renew_period', description='worker_auto_renew_period'),
  workerSystemDiskCategory: string(name='worker_system_disk_category', description='worker_system_disk_category'),
  workerSystemDiskSize: integer(name='worker_system_disk_size', description='worker_system_disk_size'),
  workerDataDisk: boolean(name='worker_data_disk', description='worker_data_disk'),
  keyPair: string(name='key_pair', description='key_pair'),
  loginPassword: string(name='login_password', description='login_password'),
  cloudMonitorFlags: boolean(name='cloud_monitor_flags', description='cloud_monitor_flags'),
  cpuPolicy: string(name='cpu_policy', description='cpu_policy'),
  disableRollback: boolean(name='disable_rollback', description='disable_rollback'),
  workerDataDisks: [
    {
      category: string(name='category', description='category'),
      size: string(name='size', description='size'),
      encrypted: string(name='encrypted', description='encrypted'),
    }
  ](name='worker_data_disks', description='worker_data_disks'),
  tags: [
    {
      key: string(name='key', description='key'),
      value: string(name='value', description='value'),
    }
  ](name='tags', description='tags'),
  taints: [
    {
      key: string(name='key', description='key'),
      value: string(name='value', description='value'),
      effect: string(name='effect', description='effect'),
    }
  ](name='taints', description='taints'),
  vswitchIds: [ string ](name='vswitch_ids', description='vswitch_ids'),
  workerInstanceTypes: [ string ](name='worker_instance_types', description='worker_instance_types'),
}

model ScaleOutClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: ScaleOutClusterBody(name='body', description='body'),
}

model ScaleOutClusterResponseBody = {
  clusterId: string(name='cluster_id', description='cluster_id'),
  requestId: string(name='request_id', description='request_id'),
  taskId: string(name='task_id', description='task_id'),
  instanceId: string(name='instanceId', description='instanceId'),
}

model ScaleOutClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: ScaleOutClusterResponseBody(name='body', description='body'),
}

async function scaleOutCluster(clusterId: string, request: ScaleOutClusterRequest, runtime: Util.RuntimeOptions): ScaleOutClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/api/v2/clusters/${clusterId}`, null, request.headers, request.body, runtime);
}

model DescribeClusterAddonsVersionRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeClusterAddonsVersionResponseBody = {
  template: string(name='template', description='template'),
  readyToUpgrade: string(name='ready_to_upgrade', description='ready_to_upgrade'),
  nextVersion: string(name='next_version', description='next_version'),
  canUpgrade: boolean(name='can_upgrade', description='can_upgrade'),
  componentName: string(name='component_name', description='component_name'),
  version: string(name='version', description='version'),
  changed: string(name='changed', description='changed'),
  message: string(name='message', description='message'),
  policy: string(name='policy', description='policy'),
  force: boolean(name='force', description='force'),
  required: boolean(name='required', description='required'),
  exist: boolean(name='exist', description='exist'),
}

model DescribeClusterAddonsVersionResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterAddonsVersionResponseBody(name='body', description='body'),
}

async function describeClusterAddonsVersion(clusterId: string, request: DescribeClusterAddonsVersionRequest, runtime: Util.RuntimeOptions): DescribeClusterAddonsVersionResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/${clusterId}/components/version`, null, request.headers, null, runtime);
}

model DescribeClusterAddonUpgradeStatusRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeClusterAddonUpgradeStatusResponseBody = {
  componentId: {
    template: string(name='template', description='template'),
    canUpgrade: boolean(name='can_upgrade', description='can_upgrade'),
    changed: string(name='changed', description='changed'),
    addonInfo: {
      componentName: string(name='component_name', description='component_name'),
      readyToUpgrade: string(name='ready_to_upgrade', description='ready_to_upgrade'),
      message: string(name='message', description='message'),
      version: string(name='version', description='version'),
      yaml: string(name='yaml', description='yaml'),
    }(name='addon_info', description='addon_info'),
    tasks: {
      finishedAt: string(name='finished_at', description='finished_at'),
      masterUrl: string(name='master_url', description='master_url'),
      createdAt: string(name='created_at', description='created_at'),
      status: string(name='status', description='status'),
    }(name='tasks', description='tasks'),
  }(name='ComponentId', description='ComponentId'),
}

model DescribeClusterAddonUpgradeStatusResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterAddonUpgradeStatusResponseBody(name='body', description='body'),
}

async function describeClusterAddonUpgradeStatus(clusterId: string, componentId: string, request: DescribeClusterAddonUpgradeStatusRequest, runtime: Util.RuntimeOptions): DescribeClusterAddonUpgradeStatusResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/${clusterId}/components/${componentId}/upgradestatus`, null, request.headers, null, runtime);
}

model DescribeEdgeClusterAttachScriptsQuery = {
  namePrefix: string(name='NamePrefix', description='NamePrefix'),
}

model DescribeEdgeClusterAttachScriptsBody = {
  options: {
    enableIptables: boolean(name='enableIptables', description='enableIptables'),
    flannelIface: string(name='flannelIface', description='flannelIface'),
    gpuVersion: string(name='gpuVersion', description='gpuVersion'),
    manageRuntime: boolean(name='manageRuntime', description='manageRuntime'),
    nodeName: string(name='nodeName', description='nodeName'),
    nodeNamePrefix: string(name='nodeNamePrefix', description='nodeNamePrefix'),
    nodeNameStrategy: boolean(name='nodeNameStrategy', description='nodeNameStrategy'),
  }(name='options', description='options'),
}

model DescribeEdgeClusterAttachScriptsRequest = {
  query: DescribeEdgeClusterAttachScriptsQuery(name='query', description='query'),
  headers?: map[string]string(name='headers', description='headers'),
  body: DescribeEdgeClusterAttachScriptsBody(name='body', description='body'),
}

model DescribeEdgeClusterAttachScriptsResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
  config: string(name='config', description='config'),
}

model DescribeEdgeClusterAttachScriptsResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeEdgeClusterAttachScriptsResponseBody(name='body', description='body'),
}

async function describeEdgeClusterAttachScripts(clusterId: string, request: DescribeEdgeClusterAttachScriptsRequest, runtime: Util.RuntimeOptions): DescribeEdgeClusterAttachScriptsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/${clusterId}/attachscript`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

model DeleteClusterNodesBody = {
  releaseNode: string(name='release_node', description='release_node'),
  nodes: [ string ](name='nodes', description='nodes'),
}

model DeleteClusterNodesRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: DeleteClusterNodesBody(name='body', description='body'),
}

model DeleteClusterNodesResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model DeleteClusterNodesResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DeleteClusterNodesResponseBody(name='body', description='body'),
}

async function deleteClusterNodes(clusterId: string, request: DeleteClusterNodesRequest, runtime: Util.RuntimeOptions): DeleteClusterNodesResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/nodes`, null, request.headers, request.body, runtime);
}

model DescribeClusterUserKubeconfigQuery = {
  privateIpAddress: boolean(name='PrivateIpAddress', description='PrivateIpAddress'),
}

model DescribeClusterUserKubeconfigRequest = {
  query: DescribeClusterUserKubeconfigQuery(name='query', description='query'),
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeClusterUserKubeconfigResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
  config: string(name='config', description='config'),
}

model DescribeClusterUserKubeconfigResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterUserKubeconfigResponseBody(name='body', description='body'),
}

async function describeClusterUserKubeconfig(clusterId: string, request: DescribeClusterUserKubeconfigRequest, runtime: Util.RuntimeOptions): DescribeClusterUserKubeconfigResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/k8s/${clusterId}/user_config`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

model AttachInstancesBody = {
  formatDisk: boolean(name='format_disk', description='format_disk'),
  keepInstanceName: boolean(name='keep_instance_name', description='keep_instance_name'),
  cpuPolicy: string(name='cpu_policy', description='cpu_policy'),
  keyPair: string(name='key_pair', description='key_pair'),
  password: string(name='password', description='password'),
  tags: [
    {
      key: string(name='key', description='key'),
      value: string(name='value', description='value'),
    }
  ](name='tags', description='tags'),
  instances: [ string ](name='instances', description='instances'),
}

model AttachInstancesRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: AttachInstancesBody(name='body', description='body'),
}

model AttachInstancesResponseBody = {
  taskId: string(name='task_id', description='task_id'),
  list: {
    list: [
      {
        code: string(name='code', description='code'),
        instanceId: string(name='instanceId', description='instanceId'),
        message: string(name='message', description='message'),
      }
    ](name='list', description='list'),
  }(name='list', description='list'),
}

model AttachInstancesResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: AttachInstancesResponseBody(name='body', description='body'),
}

async function attachInstances(clusterId: string, request: AttachInstancesRequest, runtime: Util.RuntimeOptions): AttachInstancesResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/attach`, null, request.headers, request.body, runtime);
}

model CreateClusterBody = {
  clusterType: string(name='cluster_type', description='cluster_type'),
  name: string(name='name', description='name'),
  regionId: string(name='region_id', description='region_id'),
  kubernetesVersion: string(name='kubernetes_version', description='kubernetes_version'),
  snatEntry: boolean(name='snat_entry', description='snat_entry'),
  endpointPublicAccess: boolean(name='endpoint_public_access', description='endpoint_public_access'),
  sshFlags: boolean(name='ssh_flags', description='ssh_flags'),
  cloudMonitorFlags: boolean(name='cloud_monitor_flags', description='cloud_monitor_flags'),
  deletionProtection: boolean(name='deletion_protection', description='deletion_protection'),
  nodeCidrMask: string(name='node_cidr_mask', description='node_cidr_mask'),
  proxyMode: string(name='proxy_mode', description='proxy_mode'),
  osType: string(name='os_type', description='os_type'),
  platform: string(name='platform', description='platform'),
  nodePortRange: string(name='node_port_range', description='node_port_range'),
  keyPair: string(name='key_pair', description='key_pair'),
  loginPassword: string(name='login_password', description='login_password'),
  masterInstanceChargeType: string(name='master_instance_charge_type', description='master_instance_charge_type'),
  workerInstanceChargeType: string(name='worker_instance_charge_type', description='worker_instance_charge_type'),
  masterPeriod: integer(name='master_period', description='master_period'),
  workerPeriod: integer(name='worker_period', description='worker_period'),
  masterPeriodUnit: string(name='master_period_unit', description='master_period_unit'),
  workerPeriodUnit: string(name='worker_period_unit', description='worker_period_unit'),
  masterAutoRenew: boolean(name='master_auto_renew', description='master_auto_renew'),
  masterAutoRenewPeriod: integer(name='master_auto_renew_period', description='master_auto_renew_period'),
  workerAutoRenew: boolean(name='worker_auto_renew', description='worker_auto_renew'),
  workerAutoRenewPeriod: integer(name='worker_auto_renew_period', description='worker_auto_renew_period'),
  cpuPolicy: string(name='cpu_policy', description='cpu_policy'),
  masterCount: integer(name='master_count', description='master_count'),
  masterSystemDiskCategory: string(name='master_system_disk_category', description='master_system_disk_category'),
  masterSystemDiskSize: integer(name='master_system_disk_size', description='master_system_disk_size'),
  runtime: map[string]any(name='runtime', description='runtime'),
  numOfNodes: integer(name='num_of_nodes', description='num_of_nodes'),
  workerSystemDiskCategory: string(name='worker_system_disk_category', description='worker_system_disk_category'),
  workerSystemDiskSize: integer(name='worker_system_disk_size', description='worker_system_disk_size'),
  workerDataDisk: boolean(name='worker_data_disk', description='worker_data_disk'),
  vpcid: string(name='vpcid', description='vpcid'),
  securityGroupId: string(name='security_group_id', description='security_group_id'),
  containerCidr: string(name='container_cidr', description='container_cidr'),
  serviceCidr: string(name='service_cidr', description='service_cidr'),
  disableRollback: boolean(name='disable_rollback', description='disable_rollback'),
  timeoutMins: integer(name='timeout_mins', description='timeout_mins'),
  tags: [
    {
      key: string(name='key', description='key'),
      value: string(name='value', description='value'),
    }
  ](name='tags', description='tags'),
  addons: [
    {
      name: string(name='name', description='name'),
      config: string(name='config', description='config'),
    }
  ](name='addons', description='addons'),
  taints: [
    {
      key: string(name='key', description='key'),
      value: string(name='value', description='value'),
      effect: string(name='effect', description='effect'),
    }
  ](name='taints', description='taints'),
  workerDataDisks: [
    {
      category: string(name='category', description='category'),
      size: string(name='size', description='size'),
      encrypted: string(name='encrypted', description='encrypted'),
    }
  ](name='worker_data_disks', description='worker_data_disks'),
  masterVswitchIds: [ string ](name='master_vswitch_ids', description='master_vswitch_ids'),
  masterInstanceTypes: [ string ](name='master_instance_types', description='master_instance_types'),
  workerInstanceTypes: [ string ](name='worker_instance_types', description='worker_instance_types'),
  workerVswitchIds: [ string ](name='worker_vswitch_ids', description='worker_vswitch_ids'),
}

model CreateClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: CreateClusterBody(name='body', description='body'),
}

model CreateClusterResponseBody = {
  clusterId: string(name='cluster_id', description='cluster_id'),
  requestId: string(name='request_id', description='request_id'),
  taskId: string(name='task_id', description='task_id'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: CreateClusterResponseBody(name='body', description='body'),
}

async function createCluster(request: CreateClusterRequest, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters`, null, request.headers, request.body, runtime);
}

model ScaleClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model ScaleClusterResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model ScaleClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: ScaleClusterResponseBody(name='body', description='body'),
}

async function scaleCluster(clusterId: string, request: ScaleClusterRequest, runtime: Util.RuntimeOptions): ScaleClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'PUT', 'AK', `/clusters/${clusterId}`, null, request.headers, null, runtime);
}

model DescribeClustersQuery = {
  name: string(name='name', description='name'),
  clusterType: string(name='clusterType', description='clusterType'),
}

model DescribeClustersRequest = {
  query: DescribeClustersQuery(name='query', description='query'),
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeClustersResponseBody = {
  clusters: [
    {
      name: string(name='name', description='name'),
      clusterId: string(name='cluster_id', description='cluster_id'),
      size: integer(name='size', description='size'),
      regionId: string(name='region_id', description='region_id'),
      state: string(name='state', description='state'),
      clusterType: string(name='cluster_type', description='cluster_type'),
      created: string(name='created', description='created'),
      updated: string(name='updated', description='updated'),
      initVersion: string(name='init_version', description='init_version'),
      currentVersion: string(name='current_version', description='current_version'),
      metaData: string(name='meta_data', description='meta_data'),
      resourceGroupId: string(name='resource_group_id', description='resource_group_id'),
      instanceType: string(name='instance_type', description='instance_type'),
      vpcId: string(name='vpc_id', description='vpc_id'),
      vswitchId: string(name='vswitch_id', description='vswitch_id'),
      vswitchCidr: string(name='vswitch_cidr', description='vswitch_cidr'),
      dataDiskSize: integer(name='data_disk_size', description='data_disk_size'),
      dataDiskCategory: string(name='data_disk_category', description='data_disk_category'),
      securityGroupId: string(name='security_group_id', description='security_group_id'),
      zoneId: string(name='zone_id', description='zone_id'),
      networkMode: string(name='network_mode', description='network_mode'),
      subnetCidr: string(name='subnet_cidr', description='subnet_cidr'),
      masterUrl: string(name='master_url', description='master_url'),
      externalLoadbalancerId: string(name='external_loadbalancer_id', description='external_loadbalancer_id'),
      port: integer(name='port', description='port'),
      nodeStatus: string(name='node_status', description='node_status'),
      clusterHealthy: string(name='cluster_healthy', description='cluster_healthy'),
      dockerVersion: string(name='docker_version', description='docker_version'),
      swarmMode: boolean(name='swarm_mode', description='swarm_mode'),
      gwBridge: string(name='gw_bridge', description='gw_bridge'),
      privateZone: boolean(name='private_zone', description='private_zone'),
      profile: string(name='profile', description='profile'),
      deletionProtection: boolean(name='deletion_protection', description='deletion_protection'),
      capabilities: string(name='capabilities', description='capabilities'),
      enabledMigration: boolean(name='enabled_migration', description='enabled_migration'),
      needUpdateAgent: boolean(name='need_update_agent', description='need_update_agent'),
      tags: [
        {
          key: string(name='key', description='key'),
          value: string(name='value', description='value'),
        }
      ](name='tags', description='tags'),
      outputs: [
        {
          description: string(name='Description', description='Description'),
          outputKey: string(name='OutputKey', description='OutputKey'),
          outputValue: string(name='OutputValue', description='OutputValue'),
        }
      ](name='outputs', description='outputs'),
      upgradeComponents: {
        kubernetes: {
          componentName: string(name='component_name', description='component_name'),
          version: string(name='version', description='version'),
          nextVersion: string(name='next_version', description='next_version'),
          changed: string(name='changed', description='changed'),
          canUpgrade: boolean(name='can_upgrade', description='can_upgrade'),
          force: boolean(name='force', description='force'),
          policy: string(name='policy', description='policy'),
          extraVars: string(name='ExtraVars', description='ExtraVars'),
          readyToUpgrade: string(name='ready_to_upgrade', description='ready_to_upgrade'),
          message: string(name='message', description='message'),
          exist: boolean(name='exist', description='exist'),
          required: boolean(name='required', description='required'),
          template: string(name='template', description='template'),
        }(name='Kubernetes', description='Kubernetes'),
      }(name='upgrade_components', description='upgrade_components'),
      parameters: {
        adjustmentType: string(name='AdjustmentType', description='AdjustmentType'),
        auditFlags: string(name='AuditFlags', description='AuditFlags'),
        betaVersion: string(name='BetaVersion', description='BetaVersion'),
        CA: string(name='CA', description='CA'),
        clientCA: string(name='ClientCA', description='ClientCA'),
        cloudMonitorFlags: string(name='CloudMonitorFlags', description='CloudMonitorFlags'),
        cloudMonitorVersion: string(name='CloudMonitorVersion', description='CloudMonitorVersion'),
        containerCIDR: string(name='ContainerCIDR', description='ContainerCIDR'),
        disableAddons: string(name='DisableAddons', description='DisableAddons'),
        dockerVersion: string(name='DockerVersion', description='DockerVersion'),
        ESSDeletionProtection: string(name='ESSDeletionProtection', description='ESSDeletionProtection'),
        eip: string(name='Eip', description='Eip'),
        eipAddress: string(name='EipAddress', description='EipAddress'),
        elasticSearchHost: string(name='ElasticSearchHost', description='ElasticSearchHost'),
        elasticSearchPass: string(name='ElasticSearchPass', description='ElasticSearchPass'),
        elasticSearchPort: string(name='ElasticSearchPort', description='ElasticSearchPort'),
        elasticSearchUser: string(name='ElasticSearchUser', description='ElasticSearchUser'),
        etcdVersion: string(name='EtcdVersion', description='EtcdVersion'),
        executeVersion: string(name='ExecuteVersion', description='ExecuteVersion'),
        GPUFlags: string(name='GPUFlags', description='GPUFlags'),
        healthCheckType: string(name='HealthCheckType', description='HealthCheckType'),
        imageId: string(name='ImageId', description='ImageId'),
        k8SMasterPolicyDocument: string(name='K8SMasterPolicyDocument', description='K8SMasterPolicyDocument'),
        k8sWorkerPolicyDocument: string(name='K8sWorkerPolicyDocument', description='K8sWorkerPolicyDocument'),
        key: string(name='Key', description='Key'),
        keyPair: string(name='KeyPair', description='KeyPair'),
        kubernetesVersion: string(name='KubernetesVersion', description='KubernetesVersion'),
        loggingType: string(name='LoggingType', description='LoggingType'),
        masterAmounts: string(name='MasterAmounts', description='MasterAmounts'),
        masterAutoRenew: string(name='MasterAutoRenew', description='MasterAutoRenew'),
        masterAutoRenewPeriod: string(name='MasterAutoRenewPeriod', description='MasterAutoRenewPeriod'),
        masterCount: string(name='MasterCount', description='MasterCount'),
        masterDataDisk: string(name='MasterDataDisk', description='MasterDataDisk'),
        masterDataDisks: string(name='MasterDataDisks', description='MasterDataDisks'),
        masterDeletionProtection: string(name='MasterDeletionProtection', description='MasterDeletionProtection'),
        masterDeploymentSetId: string(name='MasterDeploymentSetId', description='MasterDeploymentSetId'),
        masterHpcClusterId: string(name='MasterHpcClusterId', description='MasterHpcClusterId'),
        masterImageId: string(name='MasterImageId', description='MasterImageId'),
        masterInstanceChargeType: string(name='MasterInstanceChargeType', description='MasterInstanceChargeType'),
        masterInstanceTypes: string(name='MasterInstanceTypes', description='MasterInstanceTypes'),
        masterKeyPair: string(name='MasterKeyPair', description='MasterKeyPair'),
        masterLoginPassword: string(name='MasterLoginPassword', description='MasterLoginPassword'),
        masterPeriod: string(name='MasterPeriod', description='MasterPeriod'),
        masterPeriodUnit: string(name='MasterPeriodUnit', description='MasterPeriodUnit'),
        masterSlbSShHealthCheck: string(name='MasterSlbSShHealthCheck', description='MasterSlbSShHealthCheck'),
        masterSnapshotPolicyId: string(name='MasterSnapshotPolicyId', description='MasterSnapshotPolicyId'),
        masterSystemDiskCategory: string(name='MasterSystemDiskCategory', description='MasterSystemDiskCategory'),
        masterSystemDiskSize: string(name='MasterSystemDiskSize', description='MasterSystemDiskSize'),
        masterVSwitchIds: string(name='MasterVSwitchIds', description='MasterVSwitchIds'),
        natGateway: string(name='NatGateway', description='NatGateway'),
        natGatewayId: string(name='NatGatewayId', description='NatGatewayId'),
        network: string(name='Network', description='Network'),
        nodeCIDRMask: string(name='NodeCIDRMask', description='NodeCIDRMask'),
        nodeNameMode: string(name='NodeNameMode', description='NodeNameMode'),
        numOfNodes: string(name='NumOfNodes', description='NumOfNodes'),
        password: string(name='Password', description='Password'),
        podVswitchIds: string(name='PodVswitchIds', description='PodVswitchIds'),
        protectedInstances: string(name='ProtectedInstances', description='ProtectedInstances'),
        proxyMode: string(name='ProxyMode', description='ProxyMode'),
        publicSLB: string(name='PublicSLB', description='PublicSLB'),
        removeInstanceIds: string(name='RemoveInstanceIds', description='RemoveInstanceIds'),
        resourceGroupId: string(name='ResourceGroupId', description='ResourceGroupId'),
        SLBDeletionProtection: string(name='SLBDeletionProtection', description='SLBDeletionProtection'),
        SLSProjectName: string(name='SLSProjectName', description='SLSProjectName'),
        SNatEntry: string(name='SNatEntry', description='SNatEntry'),
        SSHFlags: string(name='SSHFlags', description='SSHFlags'),
        securityGroupId: string(name='SecurityGroupId', description='SecurityGroupId'),
        serviceCIDR: string(name='ServiceCIDR', description='ServiceCIDR'),
        setUpArgs: string(name='SetUpArgs', description='SetUpArgs'),
        snatTableId: string(name='SnatTableId', description='SnatTableId'),
        tags: string(name='Tags', description='Tags'),
        userCA: string(name='UserCA', description='UserCA'),
        userData: string(name='UserData', description='UserData'),
        vpcId: string(name='VpcId', description='VpcId'),
        willReplace: string(name='WillReplace', description='WillReplace'),
        workerAutoRenew: string(name='WorkerAutoRenew', description='WorkerAutoRenew'),
        workerAutoRenewPeriod: string(name='WorkerAutoRenewPeriod', description='WorkerAutoRenewPeriod'),
        workerDataDisk: string(name='WorkerDataDisk', description='WorkerDataDisk'),
        workerDataDisks: string(name='WorkerDataDisks', description='WorkerDataDisks'),
        workerDeletionProtection: string(name='WorkerDeletionProtection', description='WorkerDeletionProtection'),
        workerDeploymentSetId: string(name='WorkerDeploymentSetId', description='WorkerDeploymentSetId'),
        workerHpcClusterId: string(name='WorkerHpcClusterId', description='WorkerHpcClusterId'),
        workerImageId: string(name='WorkerImageId', description='WorkerImageId'),
        workerInstanceChargeType: string(name='WorkerInstanceChargeType', description='WorkerInstanceChargeType'),
        workerInstanceTypes: string(name='WorkerInstanceTypes', description='WorkerInstanceTypes'),
        workerKeyPair: string(name='WorkerKeyPair', description='WorkerKeyPair'),
        workerLoginPassword: string(name='WorkerLoginPassword', description='WorkerLoginPassword'),
        workerPeriod: string(name='WorkerPeriod', description='WorkerPeriod'),
        workerPeriodUnit: string(name='WorkerPeriodUnit', description='WorkerPeriodUnit'),
        workerSnapshotPolicyId: string(name='WorkerSnapshotPolicyId', description='WorkerSnapshotPolicyId'),
        workerSystemDiskCategory: string(name='WorkerSystemDiskCategory', description='WorkerSystemDiskCategory'),
        workerSystemDiskSize: string(name='WorkerSystemDiskSize', description='WorkerSystemDiskSize'),
        workerVSwitchIds: string(name='WorkerVSwitchIds', description='WorkerVSwitchIds'),
        zoneId: string(name='ZoneId', description='ZoneId'),
      }(name='parameters', description='parameters'),
    }
  ](name='clusters', description='clusters'),
}

model DescribeClustersResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClustersResponseBody(name='body', description='body'),
}

async function describeClusters(request: DescribeClustersRequest, runtime: Util.RuntimeOptions): DescribeClustersResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

model DescribeClusterDetailRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeClusterDetailResponseBody = {
  name: string(name='name', description='name'),
  clusterId: string(name='cluster_id', description='cluster_id'),
  size: integer(name='size', description='size'),
  regionId: string(name='region_id', description='region_id'),
  state: string(name='state', description='state'),
  clusterType: string(name='cluster_type', description='cluster_type'),
  created: string(name='created', description='created'),
  updated: string(name='updated', description='updated'),
  initVersion: string(name='init_version', description='init_version'),
  currentVersion: string(name='current_version', description='current_version'),
  metaData: string(name='meta_data', description='meta_data'),
  resourceGroupId: string(name='resource_group_id', description='resource_group_id'),
  instanceType: string(name='instance_type', description='instance_type'),
  vpcId: string(name='vpc_id', description='vpc_id'),
  vswitchId: string(name='vswitch_id', description='vswitch_id'),
  vswitchCidr: string(name='vswitch_cidr', description='vswitch_cidr'),
  dataDiskSize: integer(name='data_disk_size', description='data_disk_size'),
  dataDiskCategory: string(name='data_disk_category', description='data_disk_category'),
  securityGroupId: string(name='security_group_id', description='security_group_id'),
  zoneId: string(name='zone_id', description='zone_id'),
  networkMode: string(name='network_mode', description='network_mode'),
  subnetCidr: string(name='subnet_cidr', description='subnet_cidr'),
  masterUrl: string(name='master_url', description='master_url'),
  externalLoadbalancerId: string(name='external_loadbalancer_id', description='external_loadbalancer_id'),
  port: integer(name='port', description='port'),
  nodeStatus: string(name='node_status', description='node_status'),
  clusterHealthy: string(name='cluster_healthy', description='cluster_healthy'),
  dockerVersion: string(name='docker_version', description='docker_version'),
  swarmMode: boolean(name='swarm_mode', description='swarm_mode'),
  gwBridge: string(name='gw_bridge', description='gw_bridge'),
  privateZone: boolean(name='private_zone', description='private_zone'),
  profile: string(name='profile', description='profile'),
  deletionProtection: boolean(name='deletion_protection', description='deletion_protection'),
  capabilities: string(name='capabilities', description='capabilities'),
  enabledMigration: boolean(name='enabled_migration', description='enabled_migration'),
  needUpdateAgent: boolean(name='need_update_agent', description='need_update_agent'),
  tags: [
    {
      key: string(name='key', description='key'),
      value: string(name='value', description='value'),
    }
  ](name='tags', description='tags'),
  outputs: [
    {
      description: string(name='Description', description='Description'),
      outputKey: string(name='OutputKey', description='OutputKey'),
      outputValue: string(name='OutputValue', description='OutputValue'),
    }
  ](name='outputs', description='outputs'),
  upgradeComponents: {
    kubernetes: {
      componentName: string(name='component_name', description='component_name'),
      version: string(name='version', description='version'),
      nextVersion: string(name='next_version', description='next_version'),
      changed: string(name='changed', description='changed'),
      canUpgrade: boolean(name='can_upgrade', description='can_upgrade'),
      force: boolean(name='force', description='force'),
      policy: string(name='policy', description='policy'),
      extraVars: string(name='ExtraVars', description='ExtraVars'),
      readyToUpgrade: string(name='ready_to_upgrade', description='ready_to_upgrade'),
      message: string(name='message', description='message'),
      exist: boolean(name='exist', description='exist'),
      required: boolean(name='required', description='required'),
      template: string(name='template', description='template'),
    }(name='Kubernetes', description='Kubernetes'),
  }(name='upgrade_components', description='upgrade_components'),
  parameters: {
    adjustmentType: string(name='AdjustmentType', description='AdjustmentType'),
    auditFlags: string(name='AuditFlags', description='AuditFlags'),
    betaVersion: string(name='BetaVersion', description='BetaVersion'),
    CA: string(name='CA', description='CA'),
    clientCA: string(name='ClientCA', description='ClientCA'),
    cloudMonitorFlags: string(name='CloudMonitorFlags', description='CloudMonitorFlags'),
    cloudMonitorVersion: string(name='CloudMonitorVersion', description='CloudMonitorVersion'),
    containerCIDR: string(name='ContainerCIDR', description='ContainerCIDR'),
    disableAddons: string(name='DisableAddons', description='DisableAddons'),
    dockerVersion: string(name='DockerVersion', description='DockerVersion'),
    ESSDeletionProtection: string(name='ESSDeletionProtection', description='ESSDeletionProtection'),
    eip: string(name='Eip', description='Eip'),
    eipAddress: string(name='EipAddress', description='EipAddress'),
    elasticSearchHost: string(name='ElasticSearchHost', description='ElasticSearchHost'),
    elasticSearchPass: string(name='ElasticSearchPass', description='ElasticSearchPass'),
    elasticSearchPort: string(name='ElasticSearchPort', description='ElasticSearchPort'),
    elasticSearchUser: string(name='ElasticSearchUser', description='ElasticSearchUser'),
    etcdVersion: string(name='EtcdVersion', description='EtcdVersion'),
    executeVersion: string(name='ExecuteVersion', description='ExecuteVersion'),
    GPUFlags: string(name='GPUFlags', description='GPUFlags'),
    healthCheckType: string(name='HealthCheckType', description='HealthCheckType'),
    imageId: string(name='ImageId', description='ImageId'),
    k8SMasterPolicyDocument: string(name='K8SMasterPolicyDocument', description='K8SMasterPolicyDocument'),
    k8sWorkerPolicyDocument: string(name='K8sWorkerPolicyDocument', description='K8sWorkerPolicyDocument'),
    key: string(name='Key', description='Key'),
    keyPair: string(name='KeyPair', description='KeyPair'),
    kubernetesVersion: string(name='KubernetesVersion', description='KubernetesVersion'),
    loggingType: string(name='LoggingType', description='LoggingType'),
    masterAmounts: string(name='MasterAmounts', description='MasterAmounts'),
    masterAutoRenew: string(name='MasterAutoRenew', description='MasterAutoRenew'),
    masterAutoRenewPeriod: string(name='MasterAutoRenewPeriod', description='MasterAutoRenewPeriod'),
    masterCount: string(name='MasterCount', description='MasterCount'),
    masterDataDisk: string(name='MasterDataDisk', description='MasterDataDisk'),
    masterDataDisks: string(name='MasterDataDisks', description='MasterDataDisks'),
    masterDeletionProtection: string(name='MasterDeletionProtection', description='MasterDeletionProtection'),
    masterDeploymentSetId: string(name='MasterDeploymentSetId', description='MasterDeploymentSetId'),
    masterHpcClusterId: string(name='MasterHpcClusterId', description='MasterHpcClusterId'),
    masterImageId: string(name='MasterImageId', description='MasterImageId'),
    masterInstanceChargeType: string(name='MasterInstanceChargeType', description='MasterInstanceChargeType'),
    masterInstanceTypes: string(name='MasterInstanceTypes', description='MasterInstanceTypes'),
    masterKeyPair: string(name='MasterKeyPair', description='MasterKeyPair'),
    masterLoginPassword: string(name='MasterLoginPassword', description='MasterLoginPassword'),
    masterPeriod: string(name='MasterPeriod', description='MasterPeriod'),
    masterPeriodUnit: string(name='MasterPeriodUnit', description='MasterPeriodUnit'),
    masterSlbSShHealthCheck: string(name='MasterSlbSShHealthCheck', description='MasterSlbSShHealthCheck'),
    masterSnapshotPolicyId: string(name='MasterSnapshotPolicyId', description='MasterSnapshotPolicyId'),
    masterSystemDiskCategory: string(name='MasterSystemDiskCategory', description='MasterSystemDiskCategory'),
    masterSystemDiskSize: string(name='MasterSystemDiskSize', description='MasterSystemDiskSize'),
    masterVSwitchIds: string(name='MasterVSwitchIds', description='MasterVSwitchIds'),
    natGateway: string(name='NatGateway', description='NatGateway'),
    natGatewayId: string(name='NatGatewayId', description='NatGatewayId'),
    network: string(name='Network', description='Network'),
    nodeCIDRMask: string(name='NodeCIDRMask', description='NodeCIDRMask'),
    nodeNameMode: string(name='NodeNameMode', description='NodeNameMode'),
    numOfNodes: string(name='NumOfNodes', description='NumOfNodes'),
    password: string(name='Password', description='Password'),
    podVswitchIds: string(name='PodVswitchIds', description='PodVswitchIds'),
    protectedInstances: string(name='ProtectedInstances', description='ProtectedInstances'),
    proxyMode: string(name='ProxyMode', description='ProxyMode'),
    publicSLB: string(name='PublicSLB', description='PublicSLB'),
    removeInstanceIds: string(name='RemoveInstanceIds', description='RemoveInstanceIds'),
    resourceGroupId: string(name='ResourceGroupId', description='ResourceGroupId'),
    SLBDeletionProtection: string(name='SLBDeletionProtection', description='SLBDeletionProtection'),
    SLSProjectName: string(name='SLSProjectName', description='SLSProjectName'),
    SNatEntry: string(name='SNatEntry', description='SNatEntry'),
    SSHFlags: string(name='SSHFlags', description='SSHFlags'),
    securityGroupId: string(name='SecurityGroupId', description='SecurityGroupId'),
    serviceCIDR: string(name='ServiceCIDR', description='ServiceCIDR'),
    setUpArgs: string(name='SetUpArgs', description='SetUpArgs'),
    snatTableId: string(name='SnatTableId', description='SnatTableId'),
    tags: string(name='Tags', description='Tags'),
    userCA: string(name='UserCA', description='UserCA'),
    userData: string(name='UserData', description='UserData'),
    vpcId: string(name='VpcId', description='VpcId'),
    willReplace: string(name='WillReplace', description='WillReplace'),
    workerAutoRenew: string(name='WorkerAutoRenew', description='WorkerAutoRenew'),
    workerAutoRenewPeriod: string(name='WorkerAutoRenewPeriod', description='WorkerAutoRenewPeriod'),
    workerDataDisk: string(name='WorkerDataDisk', description='WorkerDataDisk'),
    workerDataDisks: string(name='WorkerDataDisks', description='WorkerDataDisks'),
    workerDeletionProtection: string(name='WorkerDeletionProtection', description='WorkerDeletionProtection'),
    workerDeploymentSetId: string(name='WorkerDeploymentSetId', description='WorkerDeploymentSetId'),
    workerHpcClusterId: string(name='WorkerHpcClusterId', description='WorkerHpcClusterId'),
    workerImageId: string(name='WorkerImageId', description='WorkerImageId'),
    workerInstanceChargeType: string(name='WorkerInstanceChargeType', description='WorkerInstanceChargeType'),
    workerInstanceTypes: string(name='WorkerInstanceTypes', description='WorkerInstanceTypes'),
    workerKeyPair: string(name='WorkerKeyPair', description='WorkerKeyPair'),
    workerLoginPassword: string(name='WorkerLoginPassword', description='WorkerLoginPassword'),
    workerPeriod: string(name='WorkerPeriod', description='WorkerPeriod'),
    workerPeriodUnit: string(name='WorkerPeriodUnit', description='WorkerPeriodUnit'),
    workerSnapshotPolicyId: string(name='WorkerSnapshotPolicyId', description='WorkerSnapshotPolicyId'),
    workerSystemDiskCategory: string(name='WorkerSystemDiskCategory', description='WorkerSystemDiskCategory'),
    workerSystemDiskSize: string(name='WorkerSystemDiskSize', description='WorkerSystemDiskSize'),
    workerVSwitchIds: string(name='WorkerVSwitchIds', description='WorkerVSwitchIds'),
    zoneId: string(name='ZoneId', description='ZoneId'),
  }(name='parameters', description='parameters'),
}

model DescribeClusterDetailResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterDetailResponseBody(name='body', description='body'),
}

async function describeClusterDetail(clusterId: string, request: DescribeClusterDetailRequest, runtime: Util.RuntimeOptions): DescribeClusterDetailResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/${clusterId}`, null, request.headers, null, runtime);
}

model DeleteClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DeleteClusterResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DeleteClusterResponseBody(name='body', description='body'),
}

async function deleteCluster(clusterId: string, request: DeleteClusterRequest, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'DELETE', 'AK', `/clusters/${clusterId}`, null, request.headers, null, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
