import Util;
import ROA;
import EndpointUtil;

extends ROA;

const version = '2015-12-15';

init(config: ROA.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'cs.aliyuncs.com',
    cn-beijing-finance-1 = 'cs.aliyuncs.com',
    cn-beijing-finance-pop = 'cs.aliyuncs.com',
    cn-beijing-gov-1 = 'cs.aliyuncs.com',
    cn-beijing-nu16-b01 = 'cs.aliyuncs.com',
    cn-edge-1 = 'cs.aliyuncs.com',
    cn-fujian = 'cs.aliyuncs.com',
    cn-haidian-cm12-c01 = 'cs.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'cs.aliyuncs.com',
    cn-hangzhou-finance = 'cs.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'cs.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'cs.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'cs.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'cs.aliyuncs.com',
    cn-hangzhou-test-306 = 'cs.aliyuncs.com',
    cn-hongkong-finance-pop = 'cs.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'cs.aliyuncs.com',
    cn-qingdao-nebula = 'cs.aliyuncs.com',
    cn-shanghai-et15-b01 = 'cs.aliyuncs.com',
    cn-shanghai-et2-b01 = 'cs.aliyuncs.com',
    cn-shanghai-finance-1 = 'cs.aliyuncs.com',
    cn-shanghai-inner = 'cs.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'cs.aliyuncs.com',
    cn-shenzhen-finance-1 = 'cs.aliyuncs.com',
    cn-shenzhen-inner = 'cs.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'cs.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'cs.aliyuncs.com',
    cn-wuhan = 'cs.aliyuncs.com',
    cn-wulanchabu = 'cs.aliyuncs.com',
    cn-yushanfang = 'cs.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'cs.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'cs.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'cs.aliyuncs.com',
    eu-west-1-oxs = 'cs.aliyuncs.com',
    rus-west-1-pop = 'cs.aliyuncs.com',
  };

  checkConfig(config);
  @endpointHost = getEndpoint('cs', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpointHost);
}


model ResumeComponentUpgradeRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model ResumeComponentUpgradeResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model ResumeComponentUpgradeResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: ResumeComponentUpgradeResponseBody(name='body', description='body'),
}

async function resumeComponentUpgradeWithOptions(clusterid: string, componentid: string, request: ResumeComponentUpgradeRequest, runtime: Util.RuntimeOptions): ResumeComponentUpgradeResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterid}/components/${componentid}/resume`, null, request.headers, null, runtime);
}

async function resumeComponentUpgrade(clusterid: string, componentid: string, request: ResumeComponentUpgradeRequest): ResumeComponentUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumeComponentUpgradeWithOptions(clusterid, componentid, request, runtime);
}

model PauseComponentUpgradeRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model PauseComponentUpgradeResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model PauseComponentUpgradeResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: PauseComponentUpgradeResponseBody(name='body', description='body'),
}

async function pauseComponentUpgradeWithOptions(clusterid: string, componentid: string, request: PauseComponentUpgradeRequest, runtime: Util.RuntimeOptions): PauseComponentUpgradeResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterid}/components/${componentid}/pause`, null, request.headers, null, runtime);
}

async function pauseComponentUpgrade(clusterid: string, componentid: string, request: PauseComponentUpgradeRequest): PauseComponentUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  return pauseComponentUpgradeWithOptions(clusterid, componentid, request, runtime);
}

model CancelComponentUpgradeRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model CancelComponentUpgradeResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model CancelComponentUpgradeResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: CancelComponentUpgradeResponseBody(name='body', description='body'),
}

async function cancelComponentUpgradeWithOptions(clusterid: string, componentid: string, request: CancelComponentUpgradeRequest, runtime: Util.RuntimeOptions): CancelComponentUpgradeResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterid}/components/${componentid}/cancel`, null, request.headers, null, runtime);
}

async function cancelComponentUpgrade(clusterid: string, componentid: string, request: CancelComponentUpgradeRequest): CancelComponentUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelComponentUpgradeWithOptions(clusterid, componentid, request, runtime);
}

model CancelWorkflowRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model CancelWorkflowResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function cancelWorkflowWithOptions(workflowName: string, request: CancelWorkflowRequest, runtime: Util.RuntimeOptions): CancelWorkflowResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'PUT', 'AK', `/gs/workflow/${workflowName}`, null, request.headers, null, runtime);
}

async function cancelWorkflow(workflowName: string, request: CancelWorkflowRequest): CancelWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelWorkflowWithOptions(workflowName, request, runtime);
}

model DescirbeWorkflowRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescirbeWorkflowResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function descirbeWorkflowWithOptions(workflowName: string, request: DescirbeWorkflowRequest, runtime: Util.RuntimeOptions): DescirbeWorkflowResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/gs/workflow/${workflowName}`, null, request.headers, null, runtime);
}

async function descirbeWorkflow(workflowName: string, request: DescirbeWorkflowRequest): DescirbeWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return descirbeWorkflowWithOptions(workflowName, request, runtime);
}

model RemoveWorkflowRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model RemoveWorkflowResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function removeWorkflowWithOptions(workflowName: string, request: RemoveWorkflowRequest, runtime: Util.RuntimeOptions): RemoveWorkflowResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'DELETE', 'AK', `/gs/workflow/${workflowName}`, null, request.headers, null, runtime);
}

async function removeWorkflow(workflowName: string, request: RemoveWorkflowRequest): RemoveWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeWorkflowWithOptions(workflowName, request, runtime);
}

model DescribeWorkflowsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeWorkflowsResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function describeWorkflowsWithOptions(request: DescribeWorkflowsRequest, runtime: Util.RuntimeOptions): DescribeWorkflowsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/gs/workflows`, null, request.headers, null, runtime);
}

async function describeWorkflows(request: DescribeWorkflowsRequest): DescribeWorkflowsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWorkflowsWithOptions(request, runtime);
}

model StartWorkflowRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model StartWorkflowResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function startWorkflowWithOptions(request: StartWorkflowRequest, runtime: Util.RuntimeOptions): StartWorkflowResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/gs/workflow`, null, request.headers, null, runtime);
}

async function startWorkflow(request: StartWorkflowRequest): StartWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return startWorkflowWithOptions(request, runtime);
}

model UnInstallClusterAddonsBody = {
  name: string(name='name', description='name'),
}

model UnInstallClusterAddonsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: UnInstallClusterAddonsBody(name='body', description='body'),
}

model UnInstallClusterAddonsResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model UnInstallClusterAddonsResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: UnInstallClusterAddonsResponseBody(name='body', description='body'),
}

async function unInstallClusterAddonsWithOptions(clusterId: string, request: UnInstallClusterAddonsRequest, runtime: Util.RuntimeOptions): UnInstallClusterAddonsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/components/uninstall`, null, request.headers, request.body, runtime);
}

async function unInstallClusterAddons(clusterId: string, request: UnInstallClusterAddonsRequest): UnInstallClusterAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  return unInstallClusterAddonsWithOptions(clusterId, request, runtime);
}

model DescribeAddonsQuery = {
  region?: string(name='region', description='region'),
  clusterType?: string(name='cluster_type', description='cluster_type'),
}

model DescribeAddonsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  query?: DescribeAddonsQuery(name='query', description='query'),
}

model DescribeAddonsResponseBody = {
  componentGroups: [
    {
      groupName: string(name='group_name', description='group_name'),
      items: [
        {
          name: string(name='name', description='name'),
          config: string(name='config', description='config'),
          required: string(name='required', description='required'),
          disabled: boolean(name='disabled', description='disabled'),
          version: string(name='version', description='version'),
        }
      ](name='items', description='items'),
      default: [ string ](name='default', description='default'),
    }
  ](name='ComponentGroups', description='ComponentGroups'),
  standardComponents: {
    addonName: {
      name: string(name='name', description='name'),
      config: string(name='config', description='config'),
      required: string(name='required', description='required'),
      disabled: boolean(name='disabled', description='disabled'),
      version: string(name='version', description='version'),
    }(name='addon_name', description='addon_name'),
  }(name='StandardComponents', description='StandardComponents'),
}

model DescribeAddonsResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeAddonsResponseBody(name='body', description='body'),
}

async function describeAddonsWithOptions(request: DescribeAddonsRequest, runtime: Util.RuntimeOptions): DescribeAddonsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/components/metadata`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeAddons(request: DescribeAddonsRequest): DescribeAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAddonsWithOptions(request, runtime);
}

model UpdateK8sClusterUserConfigExpireRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model UpdateK8sClusterUserConfigExpireResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function updateK8sClusterUserConfigExpireWithOptions(clusterId: string, request: UpdateK8sClusterUserConfigExpireRequest, runtime: Util.RuntimeOptions): UpdateK8sClusterUserConfigExpireResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/k8s/${clusterId}/user_config/expire`, null, request.headers, null, runtime);
}

async function updateK8sClusterUserConfigExpire(clusterId: string, request: UpdateK8sClusterUserConfigExpireRequest): UpdateK8sClusterUserConfigExpireResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateK8sClusterUserConfigExpireWithOptions(clusterId, request, runtime);
}

model CancelClusterUpgradeRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model CancelClusterUpgradeResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model CancelClusterUpgradeResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: CancelClusterUpgradeResponseBody(name='body', description='body'),
}

async function cancelClusterUpgradeWithOptions(clusterId: string, request: CancelClusterUpgradeRequest, runtime: Util.RuntimeOptions): CancelClusterUpgradeResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/api/v2/clusters/${clusterId}/upgrade/cancel`, null, request.headers, null, runtime);
}

async function cancelClusterUpgrade(clusterId: string, request: CancelClusterUpgradeRequest): CancelClusterUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelClusterUpgradeWithOptions(clusterId, request, runtime);
}

model DescribeUserQuotaRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeUserQuotaResponseBody = {
  clusterQuota: integer(name='cluster_quota', description='cluster_quota'),
  nodeQuota: integer(name='node_quota', description='node_quota'),
  askClusterQuota: integer(name='ask_cluster_quota', description='ask_cluster_quota'),
  amkClusterQuota: integer(name='amk_cluster_quota', description='amk_cluster_quota'),
}

model DescribeUserQuotaResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeUserQuotaResponseBody(name='body', description='body'),
}

async function describeUserQuotaWithOptions(request: DescribeUserQuotaRequest, runtime: Util.RuntimeOptions): DescribeUserQuotaResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/quota`, null, request.headers, null, runtime);
}

async function describeUserQuota(request: DescribeUserQuotaRequest): DescribeUserQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserQuotaWithOptions(request, runtime);
}

model DescribeClusterV2UserKubeconfigQuery = {
  privateIpAddress?: boolean(name='PrivateIpAddress', description='PrivateIpAddress'),
}

model DescribeClusterV2UserKubeconfigRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  query?: DescribeClusterV2UserKubeconfigQuery(name='query', description='query'),
}

model DescribeClusterV2UserKubeconfigResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model DescribeClusterV2UserKubeconfigResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterV2UserKubeconfigResponseBody(name='body', description='body'),
}

async function describeClusterV2UserKubeconfigWithOptions(clusterId: string, request: DescribeClusterV2UserKubeconfigRequest, runtime: Util.RuntimeOptions): DescribeClusterV2UserKubeconfigResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/api/v2/k8s/${clusterId}/user_config`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeClusterV2UserKubeconfig(clusterId: string, request: DescribeClusterV2UserKubeconfigRequest): DescribeClusterV2UserKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterV2UserKubeconfigWithOptions(clusterId, request, runtime);
}

model RemoveClusterNodesBody = {
  releaseNode?: boolean(name='release_node', description='release_node'),
  drainNode?: boolean(name='drain_node', description='drain_node'),
  nodes?: [
    {
      nodeName?: string(name='node_name', description='node_name'),
    }
  ](name='nodes', description='nodes'),
}

model RemoveClusterNodesRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body?: RemoveClusterNodesBody(name='body', description='body'),
}

model RemoveClusterNodesResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function removeClusterNodesWithOptions(clusterId: string, request: RemoveClusterNodesRequest, runtime: Util.RuntimeOptions): RemoveClusterNodesResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/api/v2/clusters/${clusterId}/nodes/remove`, null, request.headers, request.body, runtime);
}

async function removeClusterNodes(clusterId: string, request: RemoveClusterNodesRequest): RemoveClusterNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeClusterNodesWithOptions(clusterId, request, runtime);
}

model UpgradeClusterBody = {
  version?: string(name='version', description='version'),
}

model UpgradeClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body?: UpgradeClusterBody(name='body', description='body'),
}

model UpgradeClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function upgradeClusterWithOptions(clusterId: string, request: UpgradeClusterRequest, runtime: Util.RuntimeOptions): UpgradeClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/api/v2/clusters/${clusterId}/upgrade`, null, request.headers, request.body, runtime);
}

async function upgradeCluster(clusterId: string, request: UpgradeClusterRequest): UpgradeClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeClusterWithOptions(clusterId, request, runtime);
}

model PauseClusterUpgradeRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model PauseClusterUpgradeResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function pauseClusterUpgradeWithOptions(clusterId: string, request: PauseClusterUpgradeRequest, runtime: Util.RuntimeOptions): PauseClusterUpgradeResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/api/v2/clusters/${clusterId}/upgrade/pause`, null, request.headers, null, runtime);
}

async function pauseClusterUpgrade(clusterId: string, request: PauseClusterUpgradeRequest): PauseClusterUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  return pauseClusterUpgradeWithOptions(clusterId, request, runtime);
}

model ResumeUpgradeClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model ResumeUpgradeClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function resumeUpgradeClusterWithOptions(clusterId: string, request: ResumeUpgradeClusterRequest, runtime: Util.RuntimeOptions): ResumeUpgradeClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/api/v2/clusters/${clusterId}/upgrade/resume`, null, request.headers, null, runtime);
}

async function resumeUpgradeCluster(clusterId: string, request: ResumeUpgradeClusterRequest): ResumeUpgradeClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumeUpgradeClusterWithOptions(clusterId, request, runtime);
}

model GetUpgradeStatusRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model GetUpgradeStatusResponseBody = {
  status: string(name='status', description='status'),
  precheckReportId: string(name='precheck_report_id', description='precheck_report_id'),
  upgradeStep: string(name='upgrade_step', description='upgrade_step'),
  errorMessage: string(name='error_message', description='error_message'),
}

model GetUpgradeStatusResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: GetUpgradeStatusResponseBody(name='body', description='body'),
}

async function getUpgradeStatusWithOptions(clusterId: string, request: GetUpgradeStatusRequest, runtime: Util.RuntimeOptions): GetUpgradeStatusResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/api/v2/clusters/${clusterId}/upgrade/status`, null, request.headers, null, runtime);
}

async function getUpgradeStatus(clusterId: string, request: GetUpgradeStatusRequest): GetUpgradeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUpgradeStatusWithOptions(clusterId, request, runtime);
}

model ModifyClusterBody = {
  deletionProtection: boolean(name='deletion_protection', description='deletion_protection'),
  ingressLoadbalancerId: string(name='ingress_loadbalancer_id', description='ingress_loadbalancer_id'),
  apiServerEip: boolean(name='api_server_eip', description='api_server_eip'),
  apiServerEipId: string(name='api_server_eip_id', description='api_server_eip_id'),
  resourceGroupId: string(name='resource_group_id', description='resource_group_id'),
}

model ModifyClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: ModifyClusterBody(name='body', description='body'),
}

model ModifyClusterResponseBody = {
  clusterId: string(name='cluster_id', description='cluster_id'),
  requestId: string(name='request_id', description='request_id'),
  taskId: string(name='task_id', description='task_id'),
  instanceId: string(name='instanceId', description='instanceId'),
}

model ModifyClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: ModifyClusterResponseBody(name='body', description='body'),
}

async function modifyClusterWithOptions(clusterId: string, request: ModifyClusterRequest, runtime: Util.RuntimeOptions): ModifyClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'PUT', 'AK', `/api/v2/clusters/${clusterId}`, null, request.headers, request.body, runtime);
}

async function modifyCluster(clusterId: string, request: ModifyClusterRequest): ModifyClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterWithOptions(clusterId, request, runtime);
}

model InstallClusterAddonsBody = {
  name?: string(name='name', description='name'),
  version?: string(name='version', description='version'),
  disabled?: boolean(name='disabled', description='disabled'),
  required?: string(name='required', description='required'),
  config?: string(name='config', description='config'),
}

model InstallClusterAddonsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body?: InstallClusterAddonsBody(name='body', description='body'),
}

model InstallClusterAddonsResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function installClusterAddonsWithOptions(clusterId: string, request: InstallClusterAddonsRequest, runtime: Util.RuntimeOptions): InstallClusterAddonsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/components/install`, null, request.headers, request.body, runtime);
}

async function installClusterAddons(clusterId: string, request: InstallClusterAddonsRequest): InstallClusterAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  return installClusterAddonsWithOptions(clusterId, request, runtime);
}

model DeleteTriggerHookRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DeleteTriggerHookResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function deleteTriggerHookWithOptions(request: DeleteTriggerHookRequest, runtime: Util.RuntimeOptions): DeleteTriggerHookResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/api/v2/hook/trigger`, null, request.headers, null, runtime);
}

async function deleteTriggerHook(request: DeleteTriggerHookRequest): DeleteTriggerHookResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTriggerHookWithOptions(request, runtime);
}

model ModifyClusterTagsBody = {
  key: string(name='key', description='key'),
  value: string(name='value', description='value'),
}

model ModifyClusterTagsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: ModifyClusterTagsBody(name='body', description='body'),
}

model ModifyClusterTagsResponseBody = {
  requestId: string(name='requestId', description='requestId'),
}

model ModifyClusterTagsResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: ModifyClusterTagsResponseBody(name='body', description='body'),
}

async function modifyClusterTagsWithOptions(clusterId: string, request: ModifyClusterTagsRequest, runtime: Util.RuntimeOptions): ModifyClusterTagsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/tags`, null, request.headers, request.body, runtime);
}

async function modifyClusterTags(clusterId: string, request: ModifyClusterTagsRequest): ModifyClusterTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterTagsWithOptions(clusterId, request, runtime);
}

model DescribeExternalAgentRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeExternalAgentResponseBody = {
  config: string(name='config', description='config'),
}

model DescribeExternalAgentResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeExternalAgentResponseBody(name='body', description='body'),
}

async function describeExternalAgentWithOptions(clusterId: string, request: DescribeExternalAgentRequest, runtime: Util.RuntimeOptions): DescribeExternalAgentResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/k8s/${clusterId}/external/agent/deployment`, null, request.headers, null, runtime);
}

async function describeExternalAgent(clusterId: string, request: DescribeExternalAgentRequest): DescribeExternalAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExternalAgentWithOptions(clusterId, request, runtime);
}

model DescribeClusterAttachScriptsBody = {
  options?: {
    flannelIface?: string(name='flannelIface', description='flannelIface'),
    enableIptables?: boolean(name='enableIptables', description='enableIptables'),
    manageRuntime?: boolean(name='manageRuntime', description='manageRuntime'),
    nodeNameStrategy?: string(name='nodeNameStrategy', description='nodeNameStrategy'),
    nodeName?: string(name='nodeName', description='nodeName'),
    nodeNamePrefix?: string(name='nodeNamePrefix', description='nodeNamePrefix'),
  }(name='options', description='options'),
}

model DescribeClusterAttachScriptsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: DescribeClusterAttachScriptsBody(name='body', description='body'),
}

model DescribeClusterAttachScriptsResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function describeClusterAttachScriptsWithOptions(clusterId: string, request: DescribeClusterAttachScriptsRequest, runtime: Util.RuntimeOptions): DescribeClusterAttachScriptsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/attachscript`, null, request.headers, null, runtime);
}

async function describeClusterAttachScripts(clusterId: string, request: DescribeClusterAttachScriptsRequest): DescribeClusterAttachScriptsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterAttachScriptsWithOptions(clusterId, request, runtime);
}

model ScaleOutClusterBody = {
  count: integer(name='count', description='count'),
  workerInstanceChargeType?: string(name='worker_instance_charge_type', description='worker_instance_charge_type'),
  workerPeriod?: integer(name='worker_period', description='worker_period'),
  workerPeriodUnit?: string(name='worker_period_unit', description='worker_period_unit'),
  workerAutoRenew?: boolean(name='worker_auto_renew', description='worker_auto_renew'),
  workerAutoRenewPeriod?: integer(name='worker_auto_renew_period', description='worker_auto_renew_period'),
  workerSystemDiskCategory?: string(name='worker_system_disk_category', description='worker_system_disk_category'),
  workerSystemDiskSize?: integer(name='worker_system_disk_size', description='worker_system_disk_size'),
  workerDataDisk: boolean(name='worker_data_disk', description='worker_data_disk'),
  keyPair: string(name='key_pair', description='key_pair'),
  loginPassword: string(name='login_password', description='login_password'),
  cloudMonitorFlags?: boolean(name='cloud_monitor_flags', description='cloud_monitor_flags'),
  cpuPolicy?: string(name='cpu_policy', description='cpu_policy'),
  disableRollback?: boolean(name='disable_rollback', description='disable_rollback'),
  workerDataDisks?: [
    {
      category?: string(name='category', description='category'),
      size?: string(name='size', description='size'),
      encrypted?: string(name='encrypted', description='encrypted'),
    }
  ](name='worker_data_disks', description='worker_data_disks'),
  tags?: [
    {
      key?: string(name='key', description='key'),
      value?: string(name='value', description='value'),
    }
  ](name='tags', description='tags'),
  taints?: [
    {
      key?: string(name='key', description='key'),
      value?: string(name='value', description='value'),
      effect?: string(name='effect', description='effect'),
    }
  ](name='taints', description='taints'),
  vswitchIds?: [ string ](name='vswitch_ids', description='vswitch_ids'),
  workerInstanceTypes?: [ string ](name='worker_instance_types', description='worker_instance_types'),
}

model ScaleOutClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: ScaleOutClusterBody(name='body', description='body'),
}

model ScaleOutClusterResponseBody = {
  clusterId: string(name='cluster_id', description='cluster_id'),
  requestId: string(name='request_id', description='request_id'),
  taskId: string(name='task_id', description='task_id'),
  instanceId: string(name='instanceId', description='instanceId'),
}

model ScaleOutClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: ScaleOutClusterResponseBody(name='body', description='body'),
}

async function scaleOutClusterWithOptions(clusterId: string, request: ScaleOutClusterRequest, runtime: Util.RuntimeOptions): ScaleOutClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/api/v2/clusters/${clusterId}`, null, request.headers, request.body, runtime);
}

async function scaleOutCluster(clusterId: string, request: ScaleOutClusterRequest): ScaleOutClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return scaleOutClusterWithOptions(clusterId, request, runtime);
}

model DescribeClusterResourcesRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeClusterResourcesResponseBody = {
  instanceId: string(name='instance_id', description='instance_id'),
  resourceType: string(name='resource_type', description='resource_type'),
  resourceInfo: string(name='resource_info', description='resource_info'),
  state: string(name='state', description='state'),
}

model DescribeClusterResourcesResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: [ DescribeClusterResourcesResponseBody ](name='body', description='body'),
}

async function describeClusterResourcesWithOptions(clusterId: string, request: DescribeClusterResourcesRequest, runtime: Util.RuntimeOptions): DescribeClusterResourcesResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/${clusterId}/resources`, null, request.headers, null, runtime);
}

async function describeClusterResources(clusterId: string, request: DescribeClusterResourcesRequest): DescribeClusterResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterResourcesWithOptions(clusterId, request, runtime);
}

model CreateTriggerHookBody = {
  regionId?: string(name='region_id', description='region_id'),
  clusterId?: string(name='cluster_id', description='cluster_id'),
  projectId?: string(name='project_id', description='project_id'),
  action?: string(name='action', description='action'),
  triggerUrl?: string(name='trigger_url', description='trigger_url'),
}

model CreateTriggerHookRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body?: CreateTriggerHookBody(name='body', description='body'),
}

model CreateTriggerHookResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function createTriggerHookWithOptions(request: CreateTriggerHookRequest, runtime: Util.RuntimeOptions): CreateTriggerHookResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'PUT', 'AK', `/hook/trigger`, null, request.headers, request.body, runtime);
}

async function createTriggerHook(request: CreateTriggerHookRequest): CreateTriggerHookResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTriggerHookWithOptions(request, runtime);
}

model UpgradeClusterAddonsBody = {
  componentName?: string(name='component_name', description='component_name'),
  version?: string(name='version', description='version'),
}

model UpgradeClusterAddonsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body?: UpgradeClusterAddonsBody(name='body', description='body'),
}

model UpgradeClusterAddonsResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function upgradeClusterAddonsWithOptions(clusterId: string, request: UpgradeClusterAddonsRequest, runtime: Util.RuntimeOptions): UpgradeClusterAddonsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/components/upgrade`, null, request.headers, request.body, runtime);
}

async function upgradeClusterAddons(clusterId: string, request: UpgradeClusterAddonsRequest): UpgradeClusterAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeClusterAddonsWithOptions(clusterId, request, runtime);
}

model DescribeClusterAddonsVersionRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeClusterAddonsVersionResponseBody = {
  template: string(name='template', description='template'),
  nextVersion: string(name='next_version', description='next_version'),
  canUpgrade: boolean(name='can_upgrade', description='can_upgrade'),
  componentName: string(name='component_name', description='component_name'),
  version: string(name='version', description='version'),
  changed: string(name='changed', description='changed'),
  message: string(name='message', description='message'),
  required: boolean(name='required', description='required'),
}

model DescribeClusterAddonsVersionResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterAddonsVersionResponseBody(name='body', description='body'),
}

async function describeClusterAddonsVersionWithOptions(clusterId: string, request: DescribeClusterAddonsVersionRequest, runtime: Util.RuntimeOptions): DescribeClusterAddonsVersionResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/${clusterId}/components/version`, null, request.headers, null, runtime);
}

async function describeClusterAddonsVersion(clusterId: string, request: DescribeClusterAddonsVersionRequest): DescribeClusterAddonsVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterAddonsVersionWithOptions(clusterId, request, runtime);
}

model DescribeClusterAddonUpgradeStatusRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeClusterAddonUpgradeStatusResponseBody = {
  template: string(name='template', description='template'),
  canUpgrade: boolean(name='can_upgrade', description='can_upgrade'),
  addonInfo: {
    message: string(name='message', description='message'),
    category: string(name='category', description='category'),
    yaml: string(name='yaml', description='yaml'),
    componentName: string(name='component_name', description='component_name'),
    version: string(name='version', description='version'),
  }(name='addon_info', description='addon_info'),
}

model DescribeClusterAddonUpgradeStatusResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterAddonUpgradeStatusResponseBody(name='body', description='body'),
}

async function describeClusterAddonUpgradeStatusWithOptions(clusterId: string, componentId: string, request: DescribeClusterAddonUpgradeStatusRequest, runtime: Util.RuntimeOptions): DescribeClusterAddonUpgradeStatusResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/${clusterId}/components/${componentId}/upgradestatus`, null, request.headers, null, runtime);
}

async function describeClusterAddonUpgradeStatus(clusterId: string, componentId: string, request: DescribeClusterAddonUpgradeStatusRequest): DescribeClusterAddonUpgradeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterAddonUpgradeStatusWithOptions(clusterId, componentId, request, runtime);
}

model DeleteClusterNodesBody = {
  releaseNode?: string(name='release_node', description='release_node'),
  nodes?: [ string ](name='nodes', description='nodes'),
}

model DeleteClusterNodesRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: DeleteClusterNodesBody(name='body', description='body'),
}

model DeleteClusterNodesResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model DeleteClusterNodesResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DeleteClusterNodesResponseBody(name='body', description='body'),
}

async function deleteClusterNodesWithOptions(clusterId: string, request: DeleteClusterNodesRequest, runtime: Util.RuntimeOptions): DeleteClusterNodesResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/nodes`, null, request.headers, request.body, runtime);
}

async function deleteClusterNodes(clusterId: string, request: DeleteClusterNodesRequest): DeleteClusterNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterNodesWithOptions(clusterId, request, runtime);
}

model DeleteTemplateRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DeleteTemplateResponse = {
  headers: map[string]string(name='headers', description='headers'),
}

async function deleteTemplateWithOptions(templateId: string, request: DeleteTemplateRequest, runtime: Util.RuntimeOptions): DeleteTemplateResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'DELETE', 'AK', `/templates/${templateId}`, null, request.headers, null, runtime);
}

async function deleteTemplate(templateId: string, request: DeleteTemplateRequest): DeleteTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTemplateWithOptions(templateId, request, runtime);
}

model DescribeClusterUserKubeconfigQuery = {
  privateIpAddress?: boolean(name='PrivateIpAddress', description='PrivateIpAddress'),
}

model DescribeClusterUserKubeconfigRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  query?: DescribeClusterUserKubeconfigQuery(name='query', description='query'),
}

model DescribeClusterUserKubeconfigResponseBody = {
  config: string(name='config', description='config'),
}

model DescribeClusterUserKubeconfigResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterUserKubeconfigResponseBody(name='body', description='body'),
}

async function describeClusterUserKubeconfigWithOptions(clusterId: string, request: DescribeClusterUserKubeconfigRequest, runtime: Util.RuntimeOptions): DescribeClusterUserKubeconfigResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/k8s/${clusterId}/user_config`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeClusterUserKubeconfig(clusterId: string, request: DescribeClusterUserKubeconfigRequest): DescribeClusterUserKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterUserKubeconfigWithOptions(clusterId, request, runtime);
}

model DescribeClusterNodesQuery = {
  pageSize?: string(name='pageSize', description='pageSize'),
  pageNumber?: string(name='pageNumber', description='pageNumber'),
  nodepoolId?: string(name='nodepool_id', description='nodepool_id'),
  state?: string(name='state', description='state'),
}

model DescribeClusterNodesRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  query?: DescribeClusterNodesQuery(name='query', description='query'),
}

model DescribeClusterNodesResponseBody = {
  nodes: [
    {
      instanceType: string(name='instance_type', description='instance_type'),
      instanceRole: string(name='instance_role', description='instance_role'),
      expiredTime: string(name='expired_time', description='expired_time'),
      state: string(name='state', description='state'),
      instanceName: string(name='instance_name', description='instance_name'),
      isAliyunNode: boolean(name='is_aliyun_node', description='is_aliyun_node'),
      hostName: string(name='host_name', description='host_name'),
      imageId: string(name='image_id', description='image_id'),
      instanceStatus: string(name='instance_status', description='instance_status'),
      instanceChargeType: string(name='instance_charge_type', description='instance_charge_type'),
      source: string(name='source', description='source'),
      errorMessage: string(name='error_message', description='error_message'),
      nodeStatus: string(name='node_status', description='node_status'),
      creationTime: string(name='creation_time', description='creation_time'),
      nodeName: string(name='node_name', description='node_name'),
      instanceTypeFamily: string(name='instance_type_family', description='instance_type_family'),
      nodepoolId: string(name='nodepool_id', description='nodepool_id'),
      instanceId: string(name='instance_id', description='instance_id'),
      ipAddress: [ string ](name='ip_address', description='ip_address'),
    }
  ](name='nodes', description='nodes'),
  page: {
    pageSize: integer(name='page_size', description='page_size'),
    pageNumber: integer(name='page_number', description='page_number'),
    totalCount: integer(name='total_count', description='total_count'),
  }(name='page', description='page'),
}

model DescribeClusterNodesResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterNodesResponseBody(name='body', description='body'),
}

async function describeClusterNodesWithOptions(clusterId: string, request: DescribeClusterNodesRequest, runtime: Util.RuntimeOptions): DescribeClusterNodesResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/${clusterId}/nodes`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeClusterNodes(clusterId: string, request: DescribeClusterNodesRequest): DescribeClusterNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterNodesWithOptions(clusterId, request, runtime);
}

model DescribeClusterLogsRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeClusterLogsResponseBody = {
  clusterId: string(name='cluster_id', description='cluster_id'),
  clusterLog: string(name='cluster_log', description='cluster_log'),
  logLevel: string(name='log_level', description='log_level'),
  created: string(name='created', description='created'),
}

model DescribeClusterLogsResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterLogsResponseBody(name='body', description='body'),
}

async function describeClusterLogsWithOptions(clusterId: string, request: DescribeClusterLogsRequest, runtime: Util.RuntimeOptions): DescribeClusterLogsResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/${clusterId}/logs`, null, request.headers, null, runtime);
}

async function describeClusterLogs(clusterId: string, request: DescribeClusterLogsRequest): DescribeClusterLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterLogsWithOptions(clusterId, request, runtime);
}

model AttachInstancesBody = {
  formatDisk?: boolean(name='format_disk', description='format_disk'),
  keepInstanceName?: boolean(name='keep_instance_name', description='keep_instance_name'),
  cpuPolicy?: string(name='cpu_policy', description='cpu_policy'),
  keyPair: string(name='key_pair', description='key_pair'),
  password: string(name='password', description='password'),
  tags?: [
    {
      key?: string(name='key', description='key'),
      value?: string(name='value', description='value'),
    }
  ](name='tags', description='tags'),
  instances?: [ string ](name='instances', description='instances'),
}

model AttachInstancesRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: AttachInstancesBody(name='body', description='body'),
}

model AttachInstancesResponseBody = {
  taskId: string(name='task_id', description='task_id'),
  list: [
    {
      code: string(name='code', description='code'),
      instanceId: string(name='instanceId', description='instanceId'),
      message: string(name='message', description='message'),
    }
  ](name='list', description='list'),
}

model AttachInstancesResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: AttachInstancesResponseBody(name='body', description='body'),
}

async function attachInstancesWithOptions(clusterId: string, request: AttachInstancesRequest, runtime: Util.RuntimeOptions): AttachInstancesResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters/${clusterId}/attach`, null, request.headers, request.body, runtime);
}

async function attachInstances(clusterId: string, request: AttachInstancesRequest): AttachInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachInstancesWithOptions(clusterId, request, runtime);
}

model DescribeTemplatesQuery = {
  templateType?: string(name='template_type', description='template_type'),
}

model DescribeTemplatesRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  query?: DescribeTemplatesQuery(name='query', description='query'),
}

model DescribeTemplatesResponseBody = {
  template: string(name='template', description='template'),
  acl: string(name='acl', description='acl'),
  name: string(name='name', description='name'),
  tags: string(name='tags', description='tags'),
  templateType: string(name='template_type', description='template_type'),
  description: string(name='description', description='description'),
}

model DescribeTemplatesResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeTemplatesResponseBody(name='body', description='body'),
}

async function describeTemplatesWithOptions(request: DescribeTemplatesRequest, runtime: Util.RuntimeOptions): DescribeTemplatesResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/templates`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeTemplates(request: DescribeTemplatesRequest): DescribeTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTemplatesWithOptions(request, runtime);
}

model CreateTemplateBody = {
  name: string(name='name', description='name'),
  template: string(name='template', description='template'),
  tags?: string(name='tags', description='tags'),
  templateType?: string(name='template_type', description='template_type'),
}

model CreateTemplateRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: CreateTemplateBody(name='body', description='body'),
}

model CreateTemplateResponseBody = {
  templateId: string(name='template_id', description='template_id'),
}

model CreateTemplateResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: CreateTemplateResponseBody(name='body', description='body'),
}

async function createTemplateWithOptions(request: CreateTemplateRequest, runtime: Util.RuntimeOptions): CreateTemplateResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/templates`, null, request.headers, request.body, runtime);
}

async function createTemplate(request: CreateTemplateRequest): CreateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTemplateWithOptions(request, runtime);
}

model CreateClusterBody = {
  clusterType: string(name='cluster_type', description='cluster_type'),
  name: string(name='name', description='name'),
  regionId: string(name='region_id', description='region_id'),
  kubernetesVersion?: string(name='kubernetes_version', description='kubernetes_version'),
  snatEntry: boolean(name='snat_entry', description='snat_entry'),
  endpointPublicAccess?: boolean(name='endpoint_public_access', description='endpoint_public_access'),
  sshFlags?: boolean(name='ssh_flags', description='ssh_flags'),
  cloudMonitorFlags?: boolean(name='cloud_monitor_flags', description='cloud_monitor_flags'),
  deletionProtection?: boolean(name='deletion_protection', description='deletion_protection'),
  nodeCidrMask?: string(name='node_cidr_mask', description='node_cidr_mask'),
  proxyMode?: string(name='proxy_mode', description='proxy_mode'),
  osType?: string(name='os_type', description='os_type'),
  platform?: string(name='platform', description='platform'),
  nodePortRange?: string(name='node_port_range', description='node_port_range'),
  keyPair: string(name='key_pair', description='key_pair'),
  loginPassword: string(name='login_password', description='login_password'),
  masterInstanceChargeType?: string(name='master_instance_charge_type', description='master_instance_charge_type'),
  workerInstanceChargeType?: string(name='worker_instance_charge_type', description='worker_instance_charge_type'),
  masterPeriod?: integer(name='master_period', description='master_period'),
  workerPeriod?: integer(name='worker_period', description='worker_period'),
  masterPeriodUnit?: string(name='master_period_unit', description='master_period_unit'),
  workerPeriodUnit?: string(name='worker_period_unit', description='worker_period_unit'),
  masterAutoRenew?: boolean(name='master_auto_renew', description='master_auto_renew'),
  masterAutoRenewPeriod?: integer(name='master_auto_renew_period', description='master_auto_renew_period'),
  workerAutoRenew?: boolean(name='worker_auto_renew', description='worker_auto_renew'),
  workerAutoRenewPeriod?: integer(name='worker_auto_renew_period', description='worker_auto_renew_period'),
  cpuPolicy?: string(name='cpu_policy', description='cpu_policy'),
  masterCount?: integer(name='master_count', description='master_count'),
  masterSystemDiskCategory: string(name='master_system_disk_category', description='master_system_disk_category'),
  masterSystemDiskSize: integer(name='master_system_disk_size', description='master_system_disk_size'),
  runtime?: map[string]any(name='runtime', description='runtime'),
  numOfNodes: integer(name='num_of_nodes', description='num_of_nodes'),
  workerSystemDiskCategory: string(name='worker_system_disk_category', description='worker_system_disk_category'),
  workerSystemDiskSize: integer(name='worker_system_disk_size', description='worker_system_disk_size'),
  workerDataDisk?: boolean(name='worker_data_disk', description='worker_data_disk'),
  vpcid?: string(name='vpcid', description='vpcid'),
  securityGroupId?: string(name='security_group_id', description='security_group_id'),
  containerCidr?: string(name='container_cidr', description='container_cidr'),
  serviceCidr?: string(name='service_cidr', description='service_cidr'),
  disableRollback?: boolean(name='disable_rollback', description='disable_rollback'),
  timeoutMins?: integer(name='timeout_mins', description='timeout_mins'),
  tags?: [
    {
      key?: string(name='key', description='key'),
      value?: string(name='value', description='value'),
    }
  ](name='tags', description='tags'),
  addons?: [
    {
      name?: string(name='name', description='name'),
      config?: string(name='config', description='config'),
    }
  ](name='addons', description='addons'),
  taints?: [
    {
      key?: string(name='key', description='key'),
      value?: string(name='value', description='value'),
      effect?: string(name='effect', description='effect'),
    }
  ](name='taints', description='taints'),
  workerDataDisks?: [
    {
      category?: string(name='category', description='category'),
      size?: string(name='size', description='size'),
      encrypted?: string(name='encrypted', description='encrypted'),
    }
  ](name='worker_data_disks', description='worker_data_disks'),
  masterVswitchIds?: [ string ](name='master_vswitch_ids', description='master_vswitch_ids'),
  masterInstanceTypes?: [ string ](name='master_instance_types', description='master_instance_types'),
  workerInstanceTypes?: [ string ](name='worker_instance_types', description='worker_instance_types'),
  workerVswitchIds?: [ string ](name='worker_vswitch_ids', description='worker_vswitch_ids'),
}

model CreateClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  body: CreateClusterBody(name='body', description='body'),
}

model CreateClusterResponseBody = {
  clusterId: string(name='cluster_id', description='cluster_id'),
  requestId: string(name='request_id', description='request_id'),
  taskId: string(name='task_id', description='task_id'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: CreateClusterResponseBody(name='body', description='body'),
}

async function createClusterWithOptions(request: CreateClusterRequest, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'POST', 'AK', `/clusters`, null, request.headers, request.body, runtime);
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterWithOptions(request, runtime);
}

model ScaleClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model ScaleClusterResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model ScaleClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: ScaleClusterResponseBody(name='body', description='body'),
}

async function scaleClusterWithOptions(clusterId: string, request: ScaleClusterRequest, runtime: Util.RuntimeOptions): ScaleClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'PUT', 'AK', `/clusters/${clusterId}`, null, request.headers, null, runtime);
}

async function scaleCluster(clusterId: string, request: ScaleClusterRequest): ScaleClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return scaleClusterWithOptions(clusterId, request, runtime);
}

model DescribeClustersQuery = {
  name?: string(name='name', description='name'),
  clusterType?: string(name='clusterType', description='clusterType'),
}

model DescribeClustersRequest = {
  headers?: map[string]string(name='headers', description='headers'),
  query?: DescribeClustersQuery(name='query', description='query'),
}

model DescribeClustersResponseBody = {
  name: string(name='name', description='name'),
  clusterId: string(name='cluster_id', description='cluster_id'),
  regionId: string(name='region_id', description='region_id'),
  state: string(name='state', description='state'),
  clusterType: string(name='cluster_type', description='cluster_type'),
  currentVersion: string(name='current_version', description='current_version'),
  metaData: string(name='meta_data', description='meta_data'),
  resourceGroupId: string(name='resource_group_id', description='resource_group_id'),
  vpcId: string(name='vpc_id', description='vpc_id'),
  vswitchId: string(name='vswitch_id', description='vswitch_id'),
  vswitchCidr: string(name='vswitch_cidr', description='vswitch_cidr'),
  dataDiskSize: integer(name='data_disk_size', description='data_disk_size'),
  dataDiskCategory: string(name='data_disk_category', description='data_disk_category'),
  securityGroupId: string(name='security_group_id', description='security_group_id'),
  zoneId: string(name='zone_id', description='zone_id'),
  networkMode: string(name='network_mode', description='network_mode'),
  masterUrl: string(name='master_url', description='master_url'),
  dockerVersion: string(name='docker_version', description='docker_version'),
  deletionProtection: boolean(name='deletion_protection', description='deletion_protection'),
  tags: [
    {
      key: string(name='key', description='key'),
      value: string(name='value', description='value'),
    }
  ](name='tags', description='tags'),
}

model DescribeClustersResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: [ DescribeClustersResponseBody ](name='body', description='body'),
}

async function describeClustersWithOptions(request: DescribeClustersRequest, runtime: Util.RuntimeOptions): DescribeClustersResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters`, Util.stringifyMapValue(request.query), request.headers, null, runtime);
}

async function describeClusters(request: DescribeClustersRequest): DescribeClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClustersWithOptions(request, runtime);
}

model DescribeClusterDetailRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeClusterDetailResponseBody = {
  name: string(name='name', description='name'),
  clusterId: string(name='cluster_id', description='cluster_id'),
  regionId: string(name='region_id', description='region_id'),
  state: string(name='state', description='state'),
  clusterType: string(name='cluster_type', description='cluster_type'),
  currentVersion: string(name='current_version', description='current_version'),
  metaData: string(name='meta_data', description='meta_data'),
  resourceGroupId: string(name='resource_group_id', description='resource_group_id'),
  instanceType: string(name='instance_type', description='instance_type'),
  vpcId: string(name='vpc_id', description='vpc_id'),
  vswitchId: string(name='vswitch_id', description='vswitch_id'),
  vswitchCidr: string(name='vswitch_cidr', description='vswitch_cidr'),
  dataDiskSize: integer(name='data_disk_size', description='data_disk_size'),
  dataDiskCategory: string(name='data_disk_category', description='data_disk_category'),
  securityGroupId: string(name='security_group_id', description='security_group_id'),
  zoneId: string(name='zone_id', description='zone_id'),
  networkMode: string(name='network_mode', description='network_mode'),
  dockerVersion: string(name='docker_version', description='docker_version'),
  deletionProtection: boolean(name='deletion_protection', description='deletion_protection'),
  tags: [
    {
      key: string(name='key', description='key'),
      value: string(name='value', description='value'),
    }
  ](name='tags', description='tags'),
}

model DescribeClusterDetailResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeClusterDetailResponseBody(name='body', description='body'),
}

async function describeClusterDetailWithOptions(clusterId: string, request: DescribeClusterDetailRequest, runtime: Util.RuntimeOptions): DescribeClusterDetailResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/clusters/${clusterId}`, null, request.headers, null, runtime);
}

async function describeClusterDetail(clusterId: string, request: DescribeClusterDetailRequest): DescribeClusterDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterDetailWithOptions(clusterId, request, runtime);
}

model DeleteClusterRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DeleteClusterResponseBody = {
  requestId: string(name='RequestId', description='RequestId'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DeleteClusterResponseBody(name='body', description='body'),
}

async function deleteClusterWithOptions(clusterId: string, request: DeleteClusterRequest, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'DELETE', 'AK', `/clusters/${clusterId}`, null, request.headers, null, runtime);
}

async function deleteCluster(clusterId: string, request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterWithOptions(clusterId, request, runtime);
}

model DescribeApiVersionRequest = {
  headers?: map[string]string(name='headers', description='headers'),
}

model DescribeApiVersionResponseBody = {
  version: string(name='version', description='version'),
  build: string(name='build', description='build'),
  dockerVersion: string(name='docker_version', description='docker_version'),
  dockerRegionVersions: string(name='docker_region_versions', description='docker_region_versions'),
}

model DescribeApiVersionResponse = {
  headers: map[string]string(name='headers', description='headers'),
  body: DescribeApiVersionResponseBody(name='body', description='body'),
}

async function describeApiVersionWithOptions(request: DescribeApiVersionRequest, runtime: Util.RuntimeOptions): DescribeApiVersionResponse {
  Util.validateModel(request);
  return doRequest('2015-12-15', 'HTTPS', 'GET', 'AK', `/version`, null, request.headers, null, runtime);
}

async function describeApiVersion(request: DescribeApiVersionRequest): DescribeApiVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeApiVersionWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
