/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'cs.aliyuncs.com',
    cn-beijing-finance-1 = 'cs.aliyuncs.com',
    cn-beijing-finance-pop = 'cs.aliyuncs.com',
    cn-beijing-gov-1 = 'cs.aliyuncs.com',
    cn-beijing-nu16-b01 = 'cs.aliyuncs.com',
    cn-edge-1 = 'cs.aliyuncs.com',
    cn-fujian = 'cs.aliyuncs.com',
    cn-haidian-cm12-c01 = 'cs.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'cs.aliyuncs.com',
    cn-hangzhou-finance = 'cs-vpc.cn-hangzhou-finance.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'cs.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'cs.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'cs.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'cs.aliyuncs.com',
    cn-hangzhou-test-306 = 'cs.aliyuncs.com',
    cn-hongkong-finance-pop = 'cs.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'cs.aliyuncs.com',
    cn-qingdao-nebula = 'cs.aliyuncs.com',
    cn-shanghai-et15-b01 = 'cs.aliyuncs.com',
    cn-shanghai-et2-b01 = 'cs.aliyuncs.com',
    cn-shanghai-finance-1 = 'cs-vpc.cn-shanghai-finance-1.aliyuncs.com',
    cn-shanghai-inner = 'cs.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'cs.aliyuncs.com',
    cn-shenzhen-finance-1 = 'cs-vpc.cn-shenzhen-finance-1.aliyuncs.com',
    cn-shenzhen-inner = 'cs.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'cs.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'cs.aliyuncs.com',
    cn-wuhan = 'cs.aliyuncs.com',
    cn-yushanfang = 'cs.aliyuncs.com',
    cn-zhangbei = 'cs.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'cs.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'cs.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'cs.aliyuncs.com',
    eu-west-1-oxs = 'cs.aliyuncs.com',
    rus-west-1-pop = 'cs.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('cs', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model Addon {
  config?: string(name='config'),
  disabled?: boolean(name='disabled'),
  name?: string(name='name'),
}

model DataDisk {
  autoSnapshotPolicyId?: string(name='auto_snapshot_policy_id'),
  category?: string(name='category'),
  encrypted?: string(name='encrypted'),
  performanceLevel?: string(name='performance_level'),
  size?: long(name='size'),
}

model MaintenanceWindow {
  duration?: string(name='duration'),
  enable?: boolean(name='enable'),
  maintenanceTime?: string(name='maintenance_time'),
  weeklyPeriod?: string(name='weekly_period'),
}

model Runtime {
  name?: string(name='name'),
  version?: string(name='version'),
}

model Tag {
  key?: string(name='key'),
  value?: string(name='value'),
}

model Taint {
  effect?: string(name='effect'),
  key?: string(name='key'),
  value?: string(name='value'),
}

model AttachInstancesRequest {
  cpuPolicy?: string(name='cpu_policy'),
  formatDisk?: boolean(name='format_disk'),
  imageId?: string(name='image_id'),
  instances?: [ string ](name='instances'),
  isEdgeWorker?: boolean(name='is_edge_worker'),
  keepInstanceName?: boolean(name='keep_instance_name'),
  keyPair?: string(name='key_pair'),
  nodepoolId?: string(name='nodepool_id'),
  password?: string(name='password'),
  rdsInstances?: [ string ](name='rds_instances'),
  runtime?: Runtime(name='runtime'),
  tags?: [
    Tag
  ](name='tags'),
  userData?: string(name='user_data'),
}

model AttachInstancesResponseBody = {
  list?: [ 
    {
      code?: string(name='code'),
      instanceId?: string(name='instanceId'),
      message?: string(name='message'),
    }
  ](name='list'),
  taskId?: string(name='task_id'),
}

model AttachInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachInstancesResponseBody(name='body'),
}

async function attachInstances(ClusterId: string, request: AttachInstancesRequest): AttachInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return attachInstancesWithOptions(ClusterId, request, headers, runtime);
}

async function attachInstancesWithOptions(ClusterId: string, request: AttachInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AttachInstancesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.cpuPolicy)) {
    body['cpu_policy'] = request.cpuPolicy;
  }
  if (!Util.isUnset(request.formatDisk)) {
    body['format_disk'] = request.formatDisk;
  }
  if (!Util.isUnset(request.imageId)) {
    body['image_id'] = request.imageId;
  }
  if (!Util.isUnset(request.instances)) {
    body['instances'] = request.instances;
  }
  if (!Util.isUnset(request.isEdgeWorker)) {
    body['is_edge_worker'] = request.isEdgeWorker;
  }
  if (!Util.isUnset(request.keepInstanceName)) {
    body['keep_instance_name'] = request.keepInstanceName;
  }
  if (!Util.isUnset(request.keyPair)) {
    body['key_pair'] = request.keyPair;
  }
  if (!Util.isUnset(request.nodepoolId)) {
    body['nodepool_id'] = request.nodepoolId;
  }
  if (!Util.isUnset(request.password)) {
    body['password'] = request.password;
  }
  if (!Util.isUnset(request.rdsInstances)) {
    body['rds_instances'] = request.rdsInstances;
  }
  if (!Util.isUnset(request.runtime)) {
    body['runtime'] = request.runtime;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.userData)) {
    body['user_data'] = request.userData;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AttachInstances',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/attach`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CancelClusterUpgradeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function cancelClusterUpgrade(ClusterId: string): CancelClusterUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelClusterUpgradeWithOptions(ClusterId, headers, runtime);
}

async function cancelClusterUpgradeWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): CancelClusterUpgradeResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CancelClusterUpgrade',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/clusters/${ClusterId}/upgrade/cancel`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model CancelComponentUpgradeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function cancelComponentUpgrade(clusterId: string, componentId: string): CancelComponentUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelComponentUpgradeWithOptions(clusterId, componentId, headers, runtime);
}

async function cancelComponentUpgradeWithOptions(clusterId: string, componentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): CancelComponentUpgradeResponse {
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  componentId = OpenApiUtil.getEncodeParam(componentId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CancelComponentUpgrade',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/components/${componentId}/cancel`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model CancelTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function cancelTask(taskId: string): CancelTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelTaskWithOptions(taskId, headers, runtime);
}

async function cancelTaskWithOptions(taskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): CancelTaskResponse {
  taskId = OpenApiUtil.getEncodeParam(taskId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CancelTask',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/tasks/${taskId}/cancel`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model CancelWorkflowRequest {
  action?: string(name='action'),
}

model CancelWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function cancelWorkflow(workflowName: string, request: CancelWorkflowRequest): CancelWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelWorkflowWithOptions(workflowName, request, headers, runtime);
}

async function cancelWorkflowWithOptions(workflowName: string, request: CancelWorkflowRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelWorkflowResponse {
  Util.validateModel(request);
  workflowName = OpenApiUtil.getEncodeParam(workflowName);
  var body : map[string]any = {};
  if (!Util.isUnset(request.action)) {
    body['action'] = request.action;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CancelWorkflow',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/gs/workflow/${workflowName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model CreateAutoscalingConfigRequest {
  coolDownDuration?: string(name='cool_down_duration'),
  expander?: string(name='expander'),
  gpuUtilizationThreshold?: string(name='gpu_utilization_threshold'),
  scaleDownEnabled?: boolean(name='scale_down_enabled'),
  scanInterval?: string(name='scan_interval'),
  unneededDuration?: string(name='unneeded_duration'),
  utilizationThreshold?: string(name='utilization_threshold'),
}

model CreateAutoscalingConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createAutoscalingConfig(ClusterId: string, request: CreateAutoscalingConfigRequest): CreateAutoscalingConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAutoscalingConfigWithOptions(ClusterId, request, headers, runtime);
}

async function createAutoscalingConfigWithOptions(ClusterId: string, request: CreateAutoscalingConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAutoscalingConfigResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.coolDownDuration)) {
    body['cool_down_duration'] = request.coolDownDuration;
  }
  if (!Util.isUnset(request.expander)) {
    body['expander'] = request.expander;
  }
  if (!Util.isUnset(request.gpuUtilizationThreshold)) {
    body['gpu_utilization_threshold'] = request.gpuUtilizationThreshold;
  }
  if (!Util.isUnset(request.scaleDownEnabled)) {
    body['scale_down_enabled'] = request.scaleDownEnabled;
  }
  if (!Util.isUnset(request.scanInterval)) {
    body['scan_interval'] = request.scanInterval;
  }
  if (!Util.isUnset(request.unneededDuration)) {
    body['unneeded_duration'] = request.unneededDuration;
  }
  if (!Util.isUnset(request.utilizationThreshold)) {
    body['utilization_threshold'] = request.utilizationThreshold;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAutoscalingConfig',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/cluster/${ClusterId}/autoscale/config/`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model CreateClusterRequest {
  addons?: [
    Addon
  ](name='addons'),
  apiAudiences?: string(name='api_audiences'),
  chargeType?: string(name='charge_type'),
  cisEnabled?: boolean(name='cis_enabled'),
  cloudMonitorFlags?: boolean(name='cloud_monitor_flags'),
  clusterDomain?: string(name='cluster_domain'),
  clusterSpec?: string(name='cluster_spec'),
  clusterType?: string(name='cluster_type'),
  containerCidr?: string(name='container_cidr'),
  controlplaneLogComponents?: [ string ](name='controlplane_log_components'),
  controlplaneLogProject?: string(name='controlplane_log_project'),
  controlplaneLogTtl?: string(name='controlplane_log_ttl'),
  cpuPolicy?: string(name='cpu_policy'),
  customSan?: string(name='custom_san'),
  deletionProtection?: boolean(name='deletion_protection'),
  disableRollback?: boolean(name='disable_rollback'),
  enableRrsa?: boolean(name='enable_rrsa'),
  encryptionProviderKey?: string(name='encryption_provider_key'),
  endpointPublicAccess?: boolean(name='endpoint_public_access'),
  formatDisk?: boolean(name='format_disk'),
  imageId?: string(name='image_id'),
  imageType?: string(name='image_type'),
  instances?: [ string ](name='instances'),
  isEnterpriseSecurityGroup?: boolean(name='is_enterprise_security_group'),
  keepInstanceName?: boolean(name='keep_instance_name'),
  keyPair?: string(name='key_pair'),
  kubernetesVersion?: string(name='kubernetes_version'),
  loadBalancerSpec?: string(name='load_balancer_spec'),
  loggingType?: string(name='logging_type'),
  loginPassword?: string(name='login_password'),
  masterAutoRenew?: boolean(name='master_auto_renew'),
  masterAutoRenewPeriod?: long(name='master_auto_renew_period'),
  masterCount?: long(name='master_count'),
  masterInstanceChargeType?: string(name='master_instance_charge_type'),
  masterInstanceTypes?: [ string ](name='master_instance_types'),
  masterPeriod?: long(name='master_period'),
  masterPeriodUnit?: string(name='master_period_unit'),
  masterSystemDiskCategory?: string(name='master_system_disk_category'),
  masterSystemDiskPerformanceLevel?: string(name='master_system_disk_performance_level'),
  masterSystemDiskSize?: long(name='master_system_disk_size'),
  masterSystemDiskSnapshotPolicyId?: string(name='master_system_disk_snapshot_policy_id'),
  masterVswitchIds?: [ string ](name='master_vswitch_ids'),
  name?: string(name='name'),
  natGateway?: boolean(name='nat_gateway'),
  nodeCidrMask?: string(name='node_cidr_mask'),
  nodeNameMode?: string(name='node_name_mode'),
  nodePortRange?: string(name='node_port_range'),
  numOfNodes?: long(name='num_of_nodes'),
  osType?: string(name='os_type'),
  period?: long(name='period'),
  periodUnit?: string(name='period_unit'),
  platform?: string(name='platform'),
  podVswitchIds?: [ string ](name='pod_vswitch_ids'),
  profile?: string(name='profile'),
  proxyMode?: string(name='proxy_mode'),
  rdsInstances?: [ string ](name='rds_instances'),
  regionId?: string(name='region_id'),
  resourceGroupId?: string(name='resource_group_id'),
  runtime?: Runtime(name='runtime'),
  securityGroupId?: string(name='security_group_id'),
  serviceAccountIssuer?: string(name='service_account_issuer'),
  serviceCidr?: string(name='service_cidr'),
  serviceDiscoveryTypes?: [ string ](name='service_discovery_types'),
  snatEntry?: boolean(name='snat_entry'),
  socEnabled?: boolean(name='soc_enabled'),
  sshFlags?: boolean(name='ssh_flags'),
  tags?: [
    Tag
  ](name='tags'),
  taints?: [
    Taint
  ](name='taints'),
  timeoutMins?: long(name='timeout_mins'),
  timezone?: string(name='timezone'),
  userCa?: string(name='user_ca'),
  userData?: string(name='user_data'),
  vpcid?: string(name='vpcid'),
  vswitchIds?: [ string ](name='vswitch_ids'),
  workerAutoRenew?: boolean(name='worker_auto_renew'),
  workerAutoRenewPeriod?: long(name='worker_auto_renew_period'),
  workerDataDisks?: [ 
    {
      category?: string(name='category'),
      encrypted?: string(name='encrypted'),
      performanceLevel?: string(name='performance_level'),
      size?: string(name='size'),
    }
  ](name='worker_data_disks'),
  workerInstanceChargeType?: string(name='worker_instance_charge_type'),
  workerInstanceTypes?: [ string ](name='worker_instance_types'),
  workerPeriod?: long(name='worker_period'),
  workerPeriodUnit?: string(name='worker_period_unit'),
  workerSystemDiskCategory?: string(name='worker_system_disk_category'),
  workerSystemDiskPerformanceLevel?: string(name='worker_system_disk_performance_level'),
  workerSystemDiskSize?: long(name='worker_system_disk_size'),
  workerSystemDiskSnapshotPolicyId?: string(name='worker_system_disk_snapshot_policy_id'),
  workerVswitchIds?: [ string ](name='worker_vswitch_ids'),
  zoneId?: string(name='zone_id'),
}

model CreateClusterResponseBody = {
  clusterId?: string(name='cluster_id'),
  requestId?: string(name='request_id'),
  taskId?: string(name='task_id'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateClusterResponseBody(name='body'),
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createClusterWithOptions(request, headers, runtime);
}

async function createClusterWithOptions(request: CreateClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.addons)) {
    body['addons'] = request.addons;
  }
  if (!Util.isUnset(request.apiAudiences)) {
    body['api_audiences'] = request.apiAudiences;
  }
  if (!Util.isUnset(request.chargeType)) {
    body['charge_type'] = request.chargeType;
  }
  if (!Util.isUnset(request.cisEnabled)) {
    body['cis_enabled'] = request.cisEnabled;
  }
  if (!Util.isUnset(request.cloudMonitorFlags)) {
    body['cloud_monitor_flags'] = request.cloudMonitorFlags;
  }
  if (!Util.isUnset(request.clusterDomain)) {
    body['cluster_domain'] = request.clusterDomain;
  }
  if (!Util.isUnset(request.clusterSpec)) {
    body['cluster_spec'] = request.clusterSpec;
  }
  if (!Util.isUnset(request.clusterType)) {
    body['cluster_type'] = request.clusterType;
  }
  if (!Util.isUnset(request.containerCidr)) {
    body['container_cidr'] = request.containerCidr;
  }
  if (!Util.isUnset(request.controlplaneLogComponents)) {
    body['controlplane_log_components'] = request.controlplaneLogComponents;
  }
  if (!Util.isUnset(request.controlplaneLogProject)) {
    body['controlplane_log_project'] = request.controlplaneLogProject;
  }
  if (!Util.isUnset(request.controlplaneLogTtl)) {
    body['controlplane_log_ttl'] = request.controlplaneLogTtl;
  }
  if (!Util.isUnset(request.cpuPolicy)) {
    body['cpu_policy'] = request.cpuPolicy;
  }
  if (!Util.isUnset(request.customSan)) {
    body['custom_san'] = request.customSan;
  }
  if (!Util.isUnset(request.deletionProtection)) {
    body['deletion_protection'] = request.deletionProtection;
  }
  if (!Util.isUnset(request.disableRollback)) {
    body['disable_rollback'] = request.disableRollback;
  }
  if (!Util.isUnset(request.enableRrsa)) {
    body['enable_rrsa'] = request.enableRrsa;
  }
  if (!Util.isUnset(request.encryptionProviderKey)) {
    body['encryption_provider_key'] = request.encryptionProviderKey;
  }
  if (!Util.isUnset(request.endpointPublicAccess)) {
    body['endpoint_public_access'] = request.endpointPublicAccess;
  }
  if (!Util.isUnset(request.formatDisk)) {
    body['format_disk'] = request.formatDisk;
  }
  if (!Util.isUnset(request.imageId)) {
    body['image_id'] = request.imageId;
  }
  if (!Util.isUnset(request.imageType)) {
    body['image_type'] = request.imageType;
  }
  if (!Util.isUnset(request.instances)) {
    body['instances'] = request.instances;
  }
  if (!Util.isUnset(request.isEnterpriseSecurityGroup)) {
    body['is_enterprise_security_group'] = request.isEnterpriseSecurityGroup;
  }
  if (!Util.isUnset(request.keepInstanceName)) {
    body['keep_instance_name'] = request.keepInstanceName;
  }
  if (!Util.isUnset(request.keyPair)) {
    body['key_pair'] = request.keyPair;
  }
  if (!Util.isUnset(request.kubernetesVersion)) {
    body['kubernetes_version'] = request.kubernetesVersion;
  }
  if (!Util.isUnset(request.loadBalancerSpec)) {
    body['load_balancer_spec'] = request.loadBalancerSpec;
  }
  if (!Util.isUnset(request.loggingType)) {
    body['logging_type'] = request.loggingType;
  }
  if (!Util.isUnset(request.loginPassword)) {
    body['login_password'] = request.loginPassword;
  }
  if (!Util.isUnset(request.masterAutoRenew)) {
    body['master_auto_renew'] = request.masterAutoRenew;
  }
  if (!Util.isUnset(request.masterAutoRenewPeriod)) {
    body['master_auto_renew_period'] = request.masterAutoRenewPeriod;
  }
  if (!Util.isUnset(request.masterCount)) {
    body['master_count'] = request.masterCount;
  }
  if (!Util.isUnset(request.masterInstanceChargeType)) {
    body['master_instance_charge_type'] = request.masterInstanceChargeType;
  }
  if (!Util.isUnset(request.masterInstanceTypes)) {
    body['master_instance_types'] = request.masterInstanceTypes;
  }
  if (!Util.isUnset(request.masterPeriod)) {
    body['master_period'] = request.masterPeriod;
  }
  if (!Util.isUnset(request.masterPeriodUnit)) {
    body['master_period_unit'] = request.masterPeriodUnit;
  }
  if (!Util.isUnset(request.masterSystemDiskCategory)) {
    body['master_system_disk_category'] = request.masterSystemDiskCategory;
  }
  if (!Util.isUnset(request.masterSystemDiskPerformanceLevel)) {
    body['master_system_disk_performance_level'] = request.masterSystemDiskPerformanceLevel;
  }
  if (!Util.isUnset(request.masterSystemDiskSize)) {
    body['master_system_disk_size'] = request.masterSystemDiskSize;
  }
  if (!Util.isUnset(request.masterSystemDiskSnapshotPolicyId)) {
    body['master_system_disk_snapshot_policy_id'] = request.masterSystemDiskSnapshotPolicyId;
  }
  if (!Util.isUnset(request.masterVswitchIds)) {
    body['master_vswitch_ids'] = request.masterVswitchIds;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.natGateway)) {
    body['nat_gateway'] = request.natGateway;
  }
  if (!Util.isUnset(request.nodeCidrMask)) {
    body['node_cidr_mask'] = request.nodeCidrMask;
  }
  if (!Util.isUnset(request.nodeNameMode)) {
    body['node_name_mode'] = request.nodeNameMode;
  }
  if (!Util.isUnset(request.nodePortRange)) {
    body['node_port_range'] = request.nodePortRange;
  }
  if (!Util.isUnset(request.numOfNodes)) {
    body['num_of_nodes'] = request.numOfNodes;
  }
  if (!Util.isUnset(request.osType)) {
    body['os_type'] = request.osType;
  }
  if (!Util.isUnset(request.period)) {
    body['period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    body['period_unit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.platform)) {
    body['platform'] = request.platform;
  }
  if (!Util.isUnset(request.podVswitchIds)) {
    body['pod_vswitch_ids'] = request.podVswitchIds;
  }
  if (!Util.isUnset(request.profile)) {
    body['profile'] = request.profile;
  }
  if (!Util.isUnset(request.proxyMode)) {
    body['proxy_mode'] = request.proxyMode;
  }
  if (!Util.isUnset(request.rdsInstances)) {
    body['rds_instances'] = request.rdsInstances;
  }
  if (!Util.isUnset(request.regionId)) {
    body['region_id'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resource_group_id'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.runtime)) {
    body['runtime'] = request.runtime;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    body['security_group_id'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.serviceAccountIssuer)) {
    body['service_account_issuer'] = request.serviceAccountIssuer;
  }
  if (!Util.isUnset(request.serviceCidr)) {
    body['service_cidr'] = request.serviceCidr;
  }
  if (!Util.isUnset(request.serviceDiscoveryTypes)) {
    body['service_discovery_types'] = request.serviceDiscoveryTypes;
  }
  if (!Util.isUnset(request.snatEntry)) {
    body['snat_entry'] = request.snatEntry;
  }
  if (!Util.isUnset(request.socEnabled)) {
    body['soc_enabled'] = request.socEnabled;
  }
  if (!Util.isUnset(request.sshFlags)) {
    body['ssh_flags'] = request.sshFlags;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.taints)) {
    body['taints'] = request.taints;
  }
  if (!Util.isUnset(request.timeoutMins)) {
    body['timeout_mins'] = request.timeoutMins;
  }
  if (!Util.isUnset(request.timezone)) {
    body['timezone'] = request.timezone;
  }
  if (!Util.isUnset(request.userCa)) {
    body['user_ca'] = request.userCa;
  }
  if (!Util.isUnset(request.userData)) {
    body['user_data'] = request.userData;
  }
  if (!Util.isUnset(request.vpcid)) {
    body['vpcid'] = request.vpcid;
  }
  if (!Util.isUnset(request.vswitchIds)) {
    body['vswitch_ids'] = request.vswitchIds;
  }
  if (!Util.isUnset(request.workerAutoRenew)) {
    body['worker_auto_renew'] = request.workerAutoRenew;
  }
  if (!Util.isUnset(request.workerAutoRenewPeriod)) {
    body['worker_auto_renew_period'] = request.workerAutoRenewPeriod;
  }
  if (!Util.isUnset(request.workerDataDisks)) {
    body['worker_data_disks'] = request.workerDataDisks;
  }
  if (!Util.isUnset(request.workerInstanceChargeType)) {
    body['worker_instance_charge_type'] = request.workerInstanceChargeType;
  }
  if (!Util.isUnset(request.workerInstanceTypes)) {
    body['worker_instance_types'] = request.workerInstanceTypes;
  }
  if (!Util.isUnset(request.workerPeriod)) {
    body['worker_period'] = request.workerPeriod;
  }
  if (!Util.isUnset(request.workerPeriodUnit)) {
    body['worker_period_unit'] = request.workerPeriodUnit;
  }
  if (!Util.isUnset(request.workerSystemDiskCategory)) {
    body['worker_system_disk_category'] = request.workerSystemDiskCategory;
  }
  if (!Util.isUnset(request.workerSystemDiskPerformanceLevel)) {
    body['worker_system_disk_performance_level'] = request.workerSystemDiskPerformanceLevel;
  }
  if (!Util.isUnset(request.workerSystemDiskSize)) {
    body['worker_system_disk_size'] = request.workerSystemDiskSize;
  }
  if (!Util.isUnset(request.workerSystemDiskSnapshotPolicyId)) {
    body['worker_system_disk_snapshot_policy_id'] = request.workerSystemDiskSnapshotPolicyId;
  }
  if (!Util.isUnset(request.workerVswitchIds)) {
    body['worker_vswitch_ids'] = request.workerVswitchIds;
  }
  if (!Util.isUnset(request.zoneId)) {
    body['zone_id'] = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateClusterNodePoolRequest {
  autoScaling?: {
    eipBandwidth?: long(name='eip_bandwidth'),
    eipInternetChargeType?: string(name='eip_internet_charge_type'),
    enable?: boolean(name='enable'),
    isBondEip?: boolean(name='is_bond_eip'),
    maxInstances?: long(name='max_instances'),
    minInstances?: long(name='min_instances'),
    type?: string(name='type'),
  }(name='auto_scaling'),
  count?: long(name='count'),
  interconnectConfig?: {
    bandwidth?: long(name='bandwidth'),
    ccnId?: string(name='ccn_id'),
    ccnRegionId?: string(name='ccn_region_id'),
    cenId?: string(name='cen_id'),
    improvedPeriod?: string(name='improved_period'),
  }(name='interconnect_config'),
  interconnectMode?: string(name='interconnect_mode'),
  kubernetesConfig?: {
    cmsEnabled?: boolean(name='cms_enabled'),
    cpuPolicy?: string(name='cpu_policy'),
    labels?: [
      Tag
    ](name='labels'),
    nodeNameMode?: string(name='node_name_mode'),
    runtime?: string(name='runtime'),
    runtimeVersion?: string(name='runtime_version'),
    taints?: [
      Taint
    ](name='taints'),
    userData?: string(name='user_data'),
  }(name='kubernetes_config'),
  management?: {
    autoRepair?: boolean(name='auto_repair'),
    enable?: boolean(name='enable'),
    upgradeConfig?: {
      autoUpgrade?: boolean(name='auto_upgrade'),
      maxUnavailable?: long(name='max_unavailable'),
      surge?: long(name='surge'),
      surgePercentage?: long(name='surge_percentage'),
    }(name='upgrade_config'),
  }(name='management'),
  maxNodes?: long(name='max_nodes'),
  nodepoolInfo?: {
    name?: string(name='name'),
    resourceGroupId?: string(name='resource_group_id'),
    type?: string(name='type'),
  }(name='nodepool_info'),
  scalingGroup?: {
    autoRenew?: boolean(name='auto_renew'),
    autoRenewPeriod?: long(name='auto_renew_period'),
    compensateWithOnDemand?: boolean(name='compensate_with_on_demand'),
    dataDisks?: [
      DataDisk
    ](name='data_disks'),
    deploymentsetId?: string(name='deploymentset_id'),
    desiredSize?: long(name='desired_size'),
    imageId?: string(name='image_id'),
    imageType?: string(name='image_type'),
    instanceChargeType?: string(name='instance_charge_type'),
    instanceTypes?: [ string ](name='instance_types'),
    internetChargeType?: string(name='internet_charge_type'),
    internetMaxBandwidthOut?: long(name='internet_max_bandwidth_out'),
    keyPair?: string(name='key_pair'),
    loginPassword?: string(name='login_password'),
    multiAzPolicy?: string(name='multi_az_policy'),
    onDemandBaseCapacity?: long(name='on_demand_base_capacity'),
    onDemandPercentageAboveBaseCapacity?: long(name='on_demand_percentage_above_base_capacity'),
    period?: long(name='period'),
    periodUnit?: string(name='period_unit'),
    platform?: string(name='platform'),
    rdsInstances?: [ string ](name='rds_instances'),
    scalingPolicy?: string(name='scaling_policy'),
    securityGroupId?: string(name='security_group_id'),
    securityGroupIds?: [ string ](name='security_group_ids'),
    spotInstancePools?: long(name='spot_instance_pools'),
    spotInstanceRemedy?: boolean(name='spot_instance_remedy'),
    spotPriceLimit?: [ 
      {
        instanceType?: string(name='instance_type'),
        priceLimit?: string(name='price_limit'),
      }
    ](name='spot_price_limit'),
    spotStrategy?: string(name='spot_strategy'),
    systemDiskCategory?: string(name='system_disk_category'),
    systemDiskPerformanceLevel?: string(name='system_disk_performance_level'),
    systemDiskSize?: long(name='system_disk_size'),
    tags?: [ 
      {
        key?: string(name='key'),
        value?: string(name='value'),
      }
    ](name='tags'),
    vswitchIds?: [ string ](name='vswitch_ids'),
  }(name='scaling_group'),
  teeConfig?: {
    teeEnable?: boolean(name='tee_enable'),
  }(name='tee_config'),
}

model CreateClusterNodePoolResponseBody = {
  nodepoolId?: string(name='nodepool_id'),
}

model CreateClusterNodePoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateClusterNodePoolResponseBody(name='body'),
}

async function createClusterNodePool(ClusterId: string, request: CreateClusterNodePoolRequest): CreateClusterNodePoolResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createClusterNodePoolWithOptions(ClusterId, request, headers, runtime);
}

async function createClusterNodePoolWithOptions(ClusterId: string, request: CreateClusterNodePoolRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateClusterNodePoolResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoScaling)) {
    body['auto_scaling'] = request.autoScaling;
  }
  if (!Util.isUnset(request.count)) {
    body['count'] = request.count;
  }
  if (!Util.isUnset(request.interconnectConfig)) {
    body['interconnect_config'] = request.interconnectConfig;
  }
  if (!Util.isUnset(request.interconnectMode)) {
    body['interconnect_mode'] = request.interconnectMode;
  }
  if (!Util.isUnset(request.kubernetesConfig)) {
    body['kubernetes_config'] = request.kubernetesConfig;
  }
  if (!Util.isUnset(request.management)) {
    body['management'] = request.management;
  }
  if (!Util.isUnset(request.maxNodes)) {
    body['max_nodes'] = request.maxNodes;
  }
  if (!Util.isUnset(request.nodepoolInfo)) {
    body['nodepool_info'] = request.nodepoolInfo;
  }
  if (!Util.isUnset(request.scalingGroup)) {
    body['scaling_group'] = request.scalingGroup;
  }
  if (!Util.isUnset(request.teeConfig)) {
    body['tee_config'] = request.teeConfig;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateClusterNodePool',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/nodepools`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateEdgeMachineRequest {
  hostname?: string(name='hostname'),
  model?: string(name='model'),
  sn?: string(name='sn'),
}

model CreateEdgeMachineResponseBody = {
  edgeMachineId?: string(name='edge_machine_id'),
  requestId?: string(name='request_id'),
}

model CreateEdgeMachineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEdgeMachineResponseBody(name='body'),
}

async function createEdgeMachine(request: CreateEdgeMachineRequest): CreateEdgeMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createEdgeMachineWithOptions(request, headers, runtime);
}

async function createEdgeMachineWithOptions(request: CreateEdgeMachineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateEdgeMachineResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.hostname)) {
    body['hostname'] = request.hostname;
  }
  if (!Util.isUnset(request.model)) {
    body['model'] = request.model;
  }
  if (!Util.isUnset(request.sn)) {
    body['sn'] = request.sn;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEdgeMachine',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/edge_machines`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateKubernetesTriggerRequest {
  action?: string(name='action'),
  clusterId?: string(name='cluster_id'),
  projectId?: string(name='project_id'),
  type?: string(name='type'),
}

model CreateKubernetesTriggerResponseBody = {
  action?: string(name='action'),
  clusterId?: string(name='cluster_id'),
  id?: string(name='id'),
  projectId?: string(name='project_id'),
  type?: string(name='type'),
}

model CreateKubernetesTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateKubernetesTriggerResponseBody(name='body'),
}

async function createKubernetesTrigger(request: CreateKubernetesTriggerRequest): CreateKubernetesTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createKubernetesTriggerWithOptions(request, headers, runtime);
}

async function createKubernetesTriggerWithOptions(request: CreateKubernetesTriggerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateKubernetesTriggerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.action)) {
    body['action'] = request.action;
  }
  if (!Util.isUnset(request.clusterId)) {
    body['cluster_id'] = request.clusterId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['project_id'] = request.projectId;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateKubernetesTrigger',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/triggers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateTemplateRequest {
  description?: string(name='description'),
  name?: string(name='name'),
  tags?: string(name='tags'),
  template?: string(name='template'),
  templateType?: string(name='template_type'),
}

model CreateTemplateResponseBody = {
  templateId?: string(name='template_id'),
}

model CreateTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTemplateResponseBody(name='body'),
}

async function createTemplate(request: CreateTemplateRequest): CreateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTemplateWithOptions(request, headers, runtime);
}

async function createTemplateWithOptions(request: CreateTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTemplateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.template)) {
    body['template'] = request.template;
  }
  if (!Util.isUnset(request.templateType)) {
    body['template_type'] = request.templateType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTemplate',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/templates`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateTriggerRequest {
  action?: string(name='action'),
  clusterId?: string(name='cluster_id'),
  projectId?: string(name='project_id'),
  type?: string(name='type'),
}

model CreateTriggerResponseBody = {
  action?: string(name='action'),
  clusterId?: string(name='cluster_id'),
  id?: string(name='id'),
  projectId?: string(name='project_id'),
  type?: string(name='type'),
}

model CreateTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTriggerResponseBody(name='body'),
}

async function createTrigger(clusterId: string, request: CreateTriggerRequest): CreateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTriggerWithOptions(clusterId, request, headers, runtime);
}

async function createTriggerWithOptions(clusterId: string, request: CreateTriggerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTriggerResponse {
  Util.validateModel(request);
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.action)) {
    body['action'] = request.action;
  }
  if (!Util.isUnset(request.clusterId)) {
    body['cluster_id'] = request.clusterId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['project_id'] = request.projectId;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTrigger',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/triggers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteAlertContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteAlertContact(): DeleteAlertContactResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAlertContactWithOptions(headers, runtime);
}

async function deleteAlertContactWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAlertContactResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlertContact',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/alert/contacts`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteAlertContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteAlertContactGroup(): DeleteAlertContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAlertContactGroupWithOptions(headers, runtime);
}

async function deleteAlertContactGroupWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAlertContactGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlertContactGroup',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/alert/contact_groups`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteClusterRequest {
  keepSlb?: boolean(name='keep_slb'),
  retainAllResources?: boolean(name='retain_all_resources'),
  retainResources?: [ string ](name='retain_resources'),
}

model DeleteClusterShrinkRequest {
  keepSlb?: boolean(name='keep_slb'),
  retainAllResources?: boolean(name='retain_all_resources'),
  retainResourcesShrink?: string(name='retain_resources'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteCluster(ClusterId: string, request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteClusterWithOptions(ClusterId, request, headers, runtime);
}

async function deleteClusterWithOptions(ClusterId: string, tmpReq: DeleteClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(tmpReq);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var request = new DeleteClusterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.retainResources)) {
    request.retainResourcesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.retainResources, 'retain_resources', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.keepSlb)) {
    query['keep_slb'] = request.keepSlb;
  }
  if (!Util.isUnset(request.retainAllResources)) {
    query['retain_all_resources'] = request.retainAllResources;
  }
  if (!Util.isUnset(request.retainResourcesShrink)) {
    query['retain_resources'] = request.retainResourcesShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteClusterNodepoolRequest {
  force?: boolean(name='force'),
}

model DeleteClusterNodepoolResponseBody = {
  requestId?: string(name='request_id'),
}

model DeleteClusterNodepoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteClusterNodepoolResponseBody(name='body'),
}

async function deleteClusterNodepool(ClusterId: string, NodepoolId: string, request: DeleteClusterNodepoolRequest): DeleteClusterNodepoolResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteClusterNodepoolWithOptions(ClusterId, NodepoolId, request, headers, runtime);
}

async function deleteClusterNodepoolWithOptions(ClusterId: string, NodepoolId: string, request: DeleteClusterNodepoolRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteClusterNodepoolResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  NodepoolId = OpenApiUtil.getEncodeParam(NodepoolId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteClusterNodepool',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/nodepools/${NodepoolId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteClusterNodesRequest {
  drainNode?: boolean(name='drain_node'),
  nodes?: [ string ](name='nodes'),
  releaseNode?: boolean(name='release_node'),
}

model DeleteClusterNodesResponseBody = {
  clusterId?: string(name='cluster_id'),
  requestId?: string(name='request_id'),
  taskId?: string(name='task_id'),
}

model DeleteClusterNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteClusterNodesResponseBody(name='body'),
}

async function deleteClusterNodes(ClusterId: string, request: DeleteClusterNodesRequest): DeleteClusterNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteClusterNodesWithOptions(ClusterId, request, headers, runtime);
}

async function deleteClusterNodesWithOptions(ClusterId: string, request: DeleteClusterNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteClusterNodesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.drainNode)) {
    body['drain_node'] = request.drainNode;
  }
  if (!Util.isUnset(request.nodes)) {
    body['nodes'] = request.nodes;
  }
  if (!Util.isUnset(request.releaseNode)) {
    body['release_node'] = request.releaseNode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteClusterNodes',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/nodes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteEdgeMachineRequest {
  force?: string(name='force'),
}

model DeleteEdgeMachineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteEdgeMachine(edgeMachineid: string, request: DeleteEdgeMachineRequest): DeleteEdgeMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEdgeMachineWithOptions(edgeMachineid, request, headers, runtime);
}

async function deleteEdgeMachineWithOptions(edgeMachineid: string, request: DeleteEdgeMachineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteEdgeMachineResponse {
  Util.validateModel(request);
  edgeMachineid = OpenApiUtil.getEncodeParam(edgeMachineid);
  var query : map[string]any = {};
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEdgeMachine',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/edge_machines/[edge_machineid]`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteKubernetesTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteKubernetesTrigger(Id: string): DeleteKubernetesTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteKubernetesTriggerWithOptions(Id, headers, runtime);
}

async function deleteKubernetesTriggerWithOptions(Id: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteKubernetesTriggerResponse {
  Id = OpenApiUtil.getEncodeParam(Id);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteKubernetesTrigger',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/triggers/revoke/${Id}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeletePolicyInstanceRequest {
  instanceName?: string(name='instance_name'),
}

model DeletePolicyInstanceResponseBody = {
  instances?: [ string ](name='instances'),
}

model DeletePolicyInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePolicyInstanceResponseBody(name='body'),
}

async function deletePolicyInstance(clusterId: string, policyName: string, request: DeletePolicyInstanceRequest): DeletePolicyInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePolicyInstanceWithOptions(clusterId, policyName, request, headers, runtime);
}

async function deletePolicyInstanceWithOptions(clusterId: string, policyName: string, request: DeletePolicyInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePolicyInstanceResponse {
  Util.validateModel(request);
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  policyName = OpenApiUtil.getEncodeParam(policyName);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceName)) {
    query['instance_name'] = request.instanceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePolicyInstance',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/policies/${policyName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteTemplate(TemplateId: string): DeleteTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTemplateWithOptions(TemplateId, headers, runtime);
}

async function deleteTemplateWithOptions(TemplateId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTemplateResponse {
  TemplateId = OpenApiUtil.getEncodeParam(TemplateId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteTemplate',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/templates/${TemplateId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteTrigger(clusterId: string, Id: string): DeleteTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTriggerWithOptions(clusterId, Id, headers, runtime);
}

async function deleteTriggerWithOptions(clusterId: string, Id: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTriggerResponse {
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  Id = OpenApiUtil.getEncodeParam(Id);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteTrigger',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/[cluster_id]/triggers/[Id]`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeployPolicyInstanceRequest {
  action?: string(name='action'),
  namespaces?: [ string ](name='namespaces'),
  parameters?: map[string]any(name='parameters'),
}

model DeployPolicyInstanceResponseBody = {
  instances?: [ string ](name='instances'),
}

model DeployPolicyInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeployPolicyInstanceResponseBody(name='body'),
}

async function deployPolicyInstance(clusterId: string, policyName: string, request: DeployPolicyInstanceRequest): DeployPolicyInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deployPolicyInstanceWithOptions(clusterId, policyName, request, headers, runtime);
}

async function deployPolicyInstanceWithOptions(clusterId: string, policyName: string, request: DeployPolicyInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeployPolicyInstanceResponse {
  Util.validateModel(request);
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  policyName = OpenApiUtil.getEncodeParam(policyName);
  var body : map[string]any = {};
  if (!Util.isUnset(request.action)) {
    body['action'] = request.action;
  }
  if (!Util.isUnset(request.namespaces)) {
    body['namespaces'] = request.namespaces;
  }
  if (!Util.isUnset(request.parameters)) {
    body['parameters'] = request.parameters;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeployPolicyInstance',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/policies/${policyName}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescirbeWorkflowResponseBody = {
  createTime?: string(name='create_time'),
  duration?: string(name='duration'),
  finishTime?: string(name='finish_time'),
  inputDataSize?: string(name='input_data_size'),
  jobName?: string(name='job_name'),
  jobNamespace?: string(name='job_namespace'),
  outputDataSize?: string(name='output_data_size'),
  status?: string(name='status'),
  totalBases?: string(name='total_bases'),
  totalReads?: string(name='total_reads'),
  userInputData?: string(name='user_input_data'),
}

model DescirbeWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescirbeWorkflowResponseBody(name='body'),
}

async function descirbeWorkflow(workflowName: string): DescirbeWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return descirbeWorkflowWithOptions(workflowName, headers, runtime);
}

async function descirbeWorkflowWithOptions(workflowName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescirbeWorkflowResponse {
  workflowName = OpenApiUtil.getEncodeParam(workflowName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescirbeWorkflow',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/gs/workflow/${workflowName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeAddonsRequest {
  clusterType?: string(name='cluster_type'),
  region?: string(name='region'),
}

model DescribeAddonsResponseBody = {
  componentGroups?: [ 
    {
      groupName?: string(name='group_name'),
      items?: [ 
        {
          name?: string(name='name'),
        }
      ](name='items'),
    }
  ](name='ComponentGroups'),
  standardComponents?: map[string]StandardComponentsValue(name='StandardComponents'),
}

model DescribeAddonsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAddonsResponseBody(name='body'),
}

async function describeAddons(request: DescribeAddonsRequest): DescribeAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeAddonsWithOptions(request, headers, runtime);
}

async function describeAddonsWithOptions(request: DescribeAddonsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeAddonsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterType)) {
    query['cluster_type'] = request.clusterType;
  }
  if (!Util.isUnset(request.region)) {
    query['region'] = request.region;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAddons',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/components/metadata`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterAddonMetadataResponseBody = {
  configSchema?: string(name='config_schema'),
  name?: string(name='name'),
  version?: string(name='version'),
}

model DescribeClusterAddonMetadataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterAddonMetadataResponseBody(name='body'),
}

async function describeClusterAddonMetadata(clusterId: string, componentId: string, version: string): DescribeClusterAddonMetadataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterAddonMetadataWithOptions(clusterId, componentId, version, headers, runtime);
}

async function describeClusterAddonMetadataWithOptions(clusterId: string, componentId: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterAddonMetadataResponse {
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  componentId = OpenApiUtil.getEncodeParam(componentId);
  version = OpenApiUtil.getEncodeParam(version);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterAddonMetadata',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/components/${componentId}/metadata`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterAddonUpgradeStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: object(name='body'),
}

async function describeClusterAddonUpgradeStatus(ClusterId: string, ComponentId: string): DescribeClusterAddonUpgradeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterAddonUpgradeStatusWithOptions(ClusterId, ComponentId, headers, runtime);
}

async function describeClusterAddonUpgradeStatusWithOptions(ClusterId: string, ComponentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterAddonUpgradeStatusResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  ComponentId = OpenApiUtil.getEncodeParam(ComponentId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterAddonUpgradeStatus',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/components/${ComponentId}/upgradestatus`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterAddonsUpgradeStatusRequest {
  componentIds?: [ string ](name='componentIds'),
}

model DescribeClusterAddonsUpgradeStatusShrinkRequest {
  componentIdsShrink?: string(name='componentIds'),
}

model DescribeClusterAddonsUpgradeStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: object(name='body'),
}

async function describeClusterAddonsUpgradeStatus(ClusterId: string, request: DescribeClusterAddonsUpgradeStatusRequest): DescribeClusterAddonsUpgradeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterAddonsUpgradeStatusWithOptions(ClusterId, request, headers, runtime);
}

async function describeClusterAddonsUpgradeStatusWithOptions(ClusterId: string, tmpReq: DescribeClusterAddonsUpgradeStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterAddonsUpgradeStatusResponse {
  Util.validateModel(tmpReq);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var request = new DescribeClusterAddonsUpgradeStatusShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.componentIds)) {
    request.componentIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.componentIds, 'componentIds', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.componentIdsShrink)) {
    query['componentIds'] = request.componentIdsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterAddonsUpgradeStatus',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/components/upgradestatus`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterAddonsVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: object(name='body'),
}

async function describeClusterAddonsVersion(ClusterId: string): DescribeClusterAddonsVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterAddonsVersionWithOptions(ClusterId, headers, runtime);
}

async function describeClusterAddonsVersionWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterAddonsVersionResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterAddonsVersion',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/components/version`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterAttachScriptsRequest {
  arch?: string(name='arch'),
  formatDisk?: boolean(name='format_disk'),
  keepInstanceName?: boolean(name='keep_instance_name'),
  nodepoolId?: string(name='nodepool_id'),
  options?: string(name='options'),
  rdsInstances?: [ string ](name='rds_instances'),
}

model DescribeClusterAttachScriptsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: string(name='body'),
}

async function describeClusterAttachScripts(ClusterId: string, request: DescribeClusterAttachScriptsRequest): DescribeClusterAttachScriptsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterAttachScriptsWithOptions(ClusterId, request, headers, runtime);
}

async function describeClusterAttachScriptsWithOptions(ClusterId: string, request: DescribeClusterAttachScriptsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterAttachScriptsResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.arch)) {
    body['arch'] = request.arch;
  }
  if (!Util.isUnset(request.formatDisk)) {
    body['format_disk'] = request.formatDisk;
  }
  if (!Util.isUnset(request.keepInstanceName)) {
    body['keep_instance_name'] = request.keepInstanceName;
  }
  if (!Util.isUnset(request.nodepoolId)) {
    body['nodepool_id'] = request.nodepoolId;
  }
  if (!Util.isUnset(request.options)) {
    body['options'] = request.options;
  }
  if (!Util.isUnset(request.rdsInstances)) {
    body['rds_instances'] = request.rdsInstances;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterAttachScripts',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/attachscript`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'string',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterDetailResponseBody = {
  clusterId?: string(name='cluster_id'),
  clusterSpec?: string(name='cluster_spec'),
  clusterType?: string(name='cluster_type'),
  created?: string(name='created'),
  currentVersion?: string(name='current_version'),
  deletionProtection?: boolean(name='deletion_protection'),
  dockerVersion?: string(name='docker_version'),
  externalLoadbalancerId?: string(name='external_loadbalancer_id'),
  initVersion?: string(name='init_version'),
  maintenanceWindow?: MaintenanceWindow(name='maintenance_window'),
  masterUrl?: string(name='master_url'),
  metaData?: string(name='meta_data'),
  name?: string(name='name'),
  networkMode?: string(name='network_mode'),
  nextVersion?: string(name='next_version'),
  privateZone?: boolean(name='private_zone'),
  profile?: string(name='profile'),
  regionId?: string(name='region_id'),
  resourceGroupId?: string(name='resource_group_id'),
  securityGroupId?: string(name='security_group_id'),
  size?: long(name='size'),
  state?: string(name='state'),
  subnetCidr?: string(name='subnet_cidr'),
  tags?: [
    Tag
  ](name='tags'),
  updated?: string(name='updated'),
  vpcId?: string(name='vpc_id'),
  vswitchId?: string(name='vswitch_id'),
  workerRamRoleName?: string(name='worker_ram_role_name'),
  zoneId?: string(name='zone_id'),
}

model DescribeClusterDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterDetailResponseBody(name='body'),
}

async function describeClusterDetail(ClusterId: string): DescribeClusterDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterDetailWithOptions(ClusterId, headers, runtime);
}

async function describeClusterDetailWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterDetailResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterDetail',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterEventsRequest {
  pageNumber?: long(name='page_number'),
  pageSize?: long(name='page_size'),
  taskId?: long(name='task_id'),
}

model DescribeClusterEventsResponseBody = {
  events?: [ 
    {
      clusterId?: string(name='cluster_id'),
      data?: {
        level?: string(name='level'),
        message?: string(name='message'),
        reason?: string(name='reason'),
      }(name='data'),
      eventId?: string(name='event_id'),
      source?: string(name='source'),
      subject?: string(name='subject'),
      time?: string(name='time'),
      type?: string(name='type'),
    }
  ](name='events'),
  pageInfo?: {
    pageNumber?: long(name='page_number'),
    pageSize?: long(name='page_size'),
    totalCount?: long(name='total_count'),
  }(name='page_info'),
}

model DescribeClusterEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterEventsResponseBody(name='body'),
}

async function describeClusterEvents(ClusterId: string, request: DescribeClusterEventsRequest): DescribeClusterEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterEventsWithOptions(ClusterId, request, headers, runtime);
}

async function describeClusterEventsWithOptions(ClusterId: string, request: DescribeClusterEventsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterEventsResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskId)) {
    query['task_id'] = request.taskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterEvents',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/events`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [ 
    {
      ID?: long(name='ID'),
      clusterId?: string(name='cluster_id'),
      clusterLog?: string(name='cluster_log'),
      created?: string(name='created'),
      updated?: string(name='updated'),
    }
  ](name='body'),
}

async function describeClusterLogs(ClusterId: string): DescribeClusterLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterLogsWithOptions(ClusterId, headers, runtime);
}

async function describeClusterLogsWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterLogsResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterLogs',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/logs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterNodePoolDetailResponseBody = {
  autoScaling?: {
    eipBandwidth?: long(name='eip_bandwidth'),
    eipInternetChargeType?: string(name='eip_internet_charge_type'),
    enable?: boolean(name='enable'),
    isBondEip?: boolean(name='is_bond_eip'),
    maxInstances?: long(name='max_instances'),
    minInstances?: long(name='min_instances'),
    type?: string(name='type'),
  }(name='auto_scaling'),
  interconnectConfig?: {
    bandwidth?: long(name='bandwidth'),
    ccnId?: string(name='ccn_id'),
    ccnRegionId?: string(name='ccn_region_id'),
    cenId?: string(name='cen_id'),
    improvedPeriod?: string(name='improved_period'),
  }(name='interconnect_config'),
  interconnectMode?: string(name='interconnect_mode'),
  kubernetesConfig?: {
    cmsEnabled?: boolean(name='cms_enabled'),
    cpuPolicy?: string(name='cpu_policy'),
    labels?: [
      Tag
    ](name='labels'),
    nodeNameMode?: string(name='node_name_mode'),
    runtime?: string(name='runtime'),
    runtimeVersion?: string(name='runtime_version'),
    taints?: [
      Taint
    ](name='taints'),
    userData?: string(name='user_data'),
  }(name='kubernetes_config'),
  management?: {
    autoRepair?: boolean(name='auto_repair'),
    enable?: boolean(name='enable'),
    upgradeConfig?: {
      autoUpgrade?: boolean(name='auto_upgrade'),
      maxUnavailable?: long(name='max_unavailable'),
      surge?: long(name='surge'),
      surgePercentage?: long(name='surge_percentage'),
    }(name='upgrade_config'),
  }(name='management'),
  maxNodes?: long(name='max_nodes'),
  nodepoolInfo?: {
    created?: string(name='created'),
    isDefault?: boolean(name='is_default'),
    name?: string(name='name'),
    nodepoolId?: string(name='nodepool_id'),
    regionId?: string(name='region_id'),
    resourceGroupId?: string(name='resource_group_id'),
    type?: string(name='type'),
    updated?: string(name='updated'),
  }(name='nodepool_info'),
  scalingGroup?: {
    autoRenew?: boolean(name='auto_renew'),
    autoRenewPeriod?: long(name='auto_renew_period'),
    compensateWithOnDemand?: boolean(name='compensate_with_on_demand'),
    dataDisks?: [
      DataDisk
    ](name='data_disks'),
    deploymentsetId?: string(name='deploymentset_id'),
    desiredSize?: long(name='desired_size'),
    imageId?: string(name='image_id'),
    instanceChargeType?: string(name='instance_charge_type'),
    instanceTypes?: [ string ](name='instance_types'),
    internetChargeType?: string(name='internet_charge_type'),
    internetMaxBandwidthOut?: long(name='internet_max_bandwidth_out'),
    keyPair?: string(name='key_pair'),
    loginPassword?: string(name='login_password'),
    multiAzPolicy?: string(name='multi_az_policy'),
    onDemandBaseCapacity?: long(name='on_demand_base_capacity'),
    onDemandPercentageAboveBaseCapacity?: long(name='on_demand_percentage_above_base_capacity'),
    period?: long(name='period'),
    periodUnit?: string(name='period_unit'),
    platform?: string(name='platform'),
    ramPolicy?: string(name='ram_policy'),
    rdsInstances?: [ string ](name='rds_instances'),
    scalingGroupId?: string(name='scaling_group_id'),
    scalingPolicy?: string(name='scaling_policy'),
    securityGroupId?: string(name='security_group_id'),
    securityGroupIds?: [ string ](name='security_group_ids'),
    spotInstancePools?: long(name='spot_instance_pools'),
    spotInstanceRemedy?: boolean(name='spot_instance_remedy'),
    spotPriceLimit?: [ 
      {
        instanceType?: string(name='instance_type'),
        priceLimit?: string(name='price_limit'),
      }
    ](name='spot_price_limit'),
    spotStrategy?: string(name='spot_strategy'),
    systemDiskCategory?: string(name='system_disk_category'),
    systemDiskPerformanceLevel?: string(name='system_disk_performance_level'),
    systemDiskSize?: long(name='system_disk_size'),
    tags?: [
      Tag
    ](name='tags'),
    vswitchIds?: [ string ](name='vswitch_ids'),
  }(name='scaling_group'),
  status?: {
    failedNodes?: long(name='failed_nodes'),
    healthyNodes?: long(name='healthy_nodes'),
    initialNodes?: long(name='initial_nodes'),
    offlineNodes?: long(name='offline_nodes'),
    removingNodes?: long(name='removing_nodes'),
    servingNodes?: long(name='serving_nodes'),
    state?: string(name='state'),
    totalNodes?: long(name='total_nodes'),
  }(name='status'),
  teeConfig?: {
    teeEnable?: boolean(name='tee_enable'),
  }(name='tee_config'),
}

model DescribeClusterNodePoolDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterNodePoolDetailResponseBody(name='body'),
}

async function describeClusterNodePoolDetail(ClusterId: string, NodepoolId: string): DescribeClusterNodePoolDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterNodePoolDetailWithOptions(ClusterId, NodepoolId, headers, runtime);
}

async function describeClusterNodePoolDetailWithOptions(ClusterId: string, NodepoolId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterNodePoolDetailResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  NodepoolId = OpenApiUtil.getEncodeParam(NodepoolId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterNodePoolDetail',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/nodepools/${NodepoolId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterNodePoolsResponseBody = {
  nodepools?: [ 
    {
      autoScaling?: {
        eipBandwidth?: long(name='eip_bandwidth'),
        eipInternetChargeType?: string(name='eip_internet_charge_type'),
        enable?: boolean(name='enable'),
        isBondEip?: boolean(name='is_bond_eip'),
        maxInstances?: long(name='max_instances'),
        minInstances?: long(name='min_instances'),
        type?: string(name='type'),
      }(name='auto_scaling'),
      interconnectConfig?: {
        bandwidth?: long(name='bandwidth'),
        ccnId?: string(name='ccn_id'),
        ccnRegionId?: string(name='ccn_region_id'),
        cenId?: string(name='cen_id'),
        improvedPeriod?: string(name='improved_period'),
      }(name='interconnect_config'),
      interconnectMode?: string(name='interconnect_mode'),
      kubernetesConfig?: {
        cmsEnabled?: boolean(name='cms_enabled'),
        cpuPolicy?: string(name='cpu_policy'),
        labels?: [
          Tag
        ](name='labels'),
        nodeNameMode?: string(name='node_name_mode'),
        runtime?: string(name='runtime'),
        runtimeVersion?: string(name='runtime_version'),
        taints?: [
          Taint
        ](name='taints'),
        userData?: string(name='user_data'),
      }(name='kubernetes_config'),
      management?: {
        autoRepair?: boolean(name='auto_repair'),
        enable?: boolean(name='enable'),
        upgradeConfig?: {
          autoUpgrade?: boolean(name='auto_upgrade'),
          maxUnavailable?: long(name='max_unavailable'),
          surge?: long(name='surge'),
          surgePercentage?: long(name='surge_percentage'),
        }(name='upgrade_config'),
      }(name='management'),
      maxNodes?: long(name='max_nodes'),
      nodepoolInfo?: {
        created?: string(name='created'),
        isDefault?: boolean(name='is_default'),
        name?: string(name='name'),
        nodepoolId?: string(name='nodepool_id'),
        regionId?: string(name='region_id'),
        resourceGroupId?: string(name='resource_group_id'),
        type?: string(name='type'),
        updated?: string(name='updated'),
      }(name='nodepool_info'),
      scalingGroup?: {
        autoRenew?: boolean(name='auto_renew'),
        autoRenewPeriod?: long(name='auto_renew_period'),
        compensateWithOnDemand?: boolean(name='compensate_with_on_demand'),
        dataDisks?: [
          DataDisk
        ](name='data_disks'),
        deploymentsetId?: string(name='deploymentset_id'),
        desiredSize?: long(name='desired_size'),
        imageId?: string(name='image_id'),
        instanceChargeType?: string(name='instance_charge_type'),
        instanceTypes?: [ string ](name='instance_types'),
        internetChargeType?: string(name='internet_charge_type'),
        internetMaxBandwidthOut?: long(name='internet_max_bandwidth_out'),
        keyPair?: string(name='key_pair'),
        loginPassword?: string(name='login_password'),
        multiAzPolicy?: string(name='multi_az_policy'),
        onDemandBaseCapacity?: long(name='on_demand_base_capacity'),
        onDemandPercentageAboveBaseCapacity?: long(name='on_demand_percentage_above_base_capacity'),
        period?: long(name='period'),
        periodUnit?: string(name='period_unit'),
        platform?: string(name='platform'),
        ramPolicy?: string(name='ram_policy'),
        rdsInstances?: [ string ](name='rds_instances'),
        scalingGroupId?: string(name='scaling_group_id'),
        scalingPolicy?: string(name='scaling_policy'),
        securityGroupId?: string(name='security_group_id'),
        securityGroupIds?: [ string ](name='security_group_ids'),
        spotInstancePools?: long(name='spot_instance_pools'),
        spotInstanceRemedy?: boolean(name='spot_instance_remedy'),
        spotPriceLimit?: [ 
          {
            instanceType?: string(name='instance_type'),
            priceLimit?: string(name='price_limit'),
          }
        ](name='spot_price_limit'),
        spotStrategy?: string(name='spot_strategy'),
        systemDiskCategory?: string(name='system_disk_category'),
        systemDiskPerformanceLevel?: string(name='system_disk_performance_level'),
        systemDiskSize?: long(name='system_disk_size'),
        tags?: [
          Tag
        ](name='tags'),
        vswitchIds?: [ string ](name='vswitch_ids'),
      }(name='scaling_group'),
      status?: {
        failedNodes?: long(name='failed_nodes'),
        healthyNodes?: long(name='healthy_nodes'),
        initialNodes?: long(name='initial_nodes'),
        offlineNodes?: long(name='offline_nodes'),
        removingNodes?: long(name='removing_nodes'),
        servingNodes?: long(name='serving_nodes'),
        state?: string(name='state'),
        totalNodes?: long(name='total_nodes'),
      }(name='status'),
      teeConfig?: {
        teeEnable?: boolean(name='tee_enable'),
      }(name='tee_config'),
    }
  ](name='nodepools'),
}

model DescribeClusterNodePoolsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterNodePoolsResponseBody(name='body'),
}

async function describeClusterNodePools(ClusterId: string): DescribeClusterNodePoolsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterNodePoolsWithOptions(ClusterId, headers, runtime);
}

async function describeClusterNodePoolsWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterNodePoolsResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterNodePools',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/nodepools`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterNodesRequest {
  instanceIds?: string(name='instanceIds'),
  nodepoolId?: string(name='nodepool_id'),
  pageNumber?: string(name='pageNumber'),
  pageSize?: string(name='pageSize'),
  state?: string(name='state'),
}

model DescribeClusterNodesResponseBody = {
  nodes?: [ 
    {
      creationTime?: string(name='creation_time'),
      errorMessage?: string(name='error_message'),
      expiredTime?: string(name='expired_time'),
      hostName?: string(name='host_name'),
      imageId?: string(name='image_id'),
      instanceChargeType?: string(name='instance_charge_type'),
      instanceId?: string(name='instance_id'),
      instanceName?: string(name='instance_name'),
      instanceRole?: string(name='instance_role'),
      instanceStatus?: string(name='instance_status'),
      instanceType?: string(name='instance_type'),
      instanceTypeFamily?: string(name='instance_type_family'),
      ipAddress?: [ string ](name='ip_address'),
      isAliyunNode?: boolean(name='is_aliyun_node'),
      nodeName?: string(name='node_name'),
      nodeStatus?: string(name='node_status'),
      nodepoolId?: string(name='nodepool_id'),
      source?: string(name='source'),
      spotStrategy?: string(name='spot_strategy'),
      state?: string(name='state'),
    }
  ](name='nodes'),
  page?: {
    pageNumber?: int32(name='page_number'),
    pageSize?: int32(name='page_size'),
    totalCount?: int32(name='total_count'),
  }(name='page'),
}

model DescribeClusterNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterNodesResponseBody(name='body'),
}

async function describeClusterNodes(ClusterId: string, request: DescribeClusterNodesRequest): DescribeClusterNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterNodesWithOptions(ClusterId, request, headers, runtime);
}

async function describeClusterNodesWithOptions(ClusterId: string, request: DescribeClusterNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterNodesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['instanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.nodepoolId)) {
    query['nodepool_id'] = request.nodepoolId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.state)) {
    query['state'] = request.state;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterNodes',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/nodes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [ 
    {
      clusterId?: string(name='cluster_id'),
      created?: string(name='created'),
      instanceId?: string(name='instance_id'),
      resourceInfo?: string(name='resource_info'),
      resourceType?: string(name='resource_type'),
      state?: string(name='state'),
      autoCreate?: long(name='auto_create'),
    }
  ](name='body'),
}

async function describeClusterResources(ClusterId: string): DescribeClusterResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterResourcesWithOptions(ClusterId, headers, runtime);
}

async function describeClusterResourcesWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterResourcesResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterResources',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/resources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterTasksResponseBody = {
  pageInfo?: {
    pageNumber?: long(name='page_number'),
    pageSize?: long(name='page_size'),
    totalCount?: long(name='total_count'),
  }(name='page_info'),
  requestId?: string(name='requestId'),
  tasks?: [ 
    {
      created?: string(name='created'),
      error?: {
        code?: string(name='code'),
        message?: string(name='message'),
      }(name='error'),
      state?: string(name='state'),
      taskId?: string(name='task_id'),
      taskType?: string(name='task_type'),
      updated?: string(name='updated'),
    }
  ](name='tasks'),
}

model DescribeClusterTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterTasksResponseBody(name='body'),
}

async function describeClusterTasks(clusterId: string): DescribeClusterTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterTasksWithOptions(clusterId, headers, runtime);
}

async function describeClusterTasksWithOptions(clusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterTasksResponse {
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterTasks',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterUserKubeconfigRequest {
  privateIpAddress?: boolean(name='PrivateIpAddress'),
  temporaryDurationMinutes?: long(name='TemporaryDurationMinutes'),
}

model DescribeClusterUserKubeconfigResponseBody = {
  config?: string(name='config'),
  expiration?: string(name='expiration'),
}

model DescribeClusterUserKubeconfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterUserKubeconfigResponseBody(name='body'),
}

async function describeClusterUserKubeconfig(ClusterId: string, request: DescribeClusterUserKubeconfigRequest): DescribeClusterUserKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterUserKubeconfigWithOptions(ClusterId, request, headers, runtime);
}

async function describeClusterUserKubeconfigWithOptions(ClusterId: string, request: DescribeClusterUserKubeconfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterUserKubeconfigResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.temporaryDurationMinutes)) {
    query['TemporaryDurationMinutes'] = request.temporaryDurationMinutes;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterUserKubeconfig',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/k8s/${ClusterId}/user_config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClusterV2UserKubeconfigRequest {
  privateIpAddress?: boolean(name='PrivateIpAddress'),
}

model DescribeClusterV2UserKubeconfigResponseBody = {
  config?: string(name='config'),
}

model DescribeClusterV2UserKubeconfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterV2UserKubeconfigResponseBody(name='body'),
}

async function describeClusterV2UserKubeconfig(ClusterId: string, request: DescribeClusterV2UserKubeconfigRequest): DescribeClusterV2UserKubeconfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClusterV2UserKubeconfigWithOptions(ClusterId, request, headers, runtime);
}

async function describeClusterV2UserKubeconfigWithOptions(ClusterId: string, request: DescribeClusterV2UserKubeconfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClusterV2UserKubeconfigResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterV2UserKubeconfig',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/k8s/${ClusterId}/user_config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeClustersRequest {
  clusterType?: string(name='clusterType'),
  name?: string(name='name'),
}

model DescribeClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [ 
    {
      clusterId?: string(name='cluster_id'),
      clusterType?: string(name='cluster_type'),
      created?: string(name='created'),
      currentVersion?: string(name='current_version'),
      dataDiskCategory?: string(name='data_disk_category'),
      dataDiskSize?: long(name='data_disk_size'),
      deletionProtection?: boolean(name='deletion_protection'),
      dockerVersion?: string(name='docker_version'),
      externalLoadbalancerId?: string(name='external_loadbalancer_id'),
      initVersion?: string(name='init_version'),
      masterUrl?: string(name='master_url'),
      metaData?: string(name='meta_data'),
      name?: string(name='name'),
      networkMode?: string(name='network_mode'),
      privateZone?: boolean(name='private_zone'),
      profile?: string(name='profile'),
      regionId?: string(name='region_id'),
      resourceGroupId?: string(name='resource_group_id'),
      securityGroupId?: string(name='security_group_id'),
      size?: long(name='size'),
      state?: string(name='state'),
      subnetCidr?: string(name='subnet_cidr'),
      tags?: [ 
        {
          key?: string(name='key'),
          value?: string(name='value'),
        }
      ](name='tags'),
      updated?: string(name='updated'),
      vpcId?: string(name='vpc_id'),
      vswitchCidr?: string(name='vswitch_cidr'),
      vswitchId?: string(name='vswitch_id'),
      workerRamRoleName?: string(name='worker_ram_role_name'),
      zoneId?: string(name='zone_id'),
    }
  ](name='body'),
}

async function describeClusters(request: DescribeClustersRequest): DescribeClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClustersWithOptions(request, headers, runtime);
}

async function describeClustersWithOptions(request: DescribeClustersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClustersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterType)) {
    query['clusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusters',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model DescribeClustersV1Request {
  clusterSpec?: string(name='cluster_spec'),
  clusterType?: string(name='cluster_type'),
  name?: string(name='name'),
  pageNumber?: long(name='page_number'),
  pageSize?: long(name='page_size'),
  profile?: string(name='profile'),
  regionId?: string(name='region_id'),
}

model DescribeClustersV1ResponseBody = {
  clusters?: [ 
    {
      clusterId?: string(name='cluster_id'),
      clusterSpec?: string(name='cluster_spec'),
      clusterType?: string(name='cluster_type'),
      created?: string(name='created'),
      currentVersion?: string(name='current_version'),
      deletionProtection?: boolean(name='deletion_protection'),
      dockerVersion?: string(name='docker_version'),
      externalLoadbalancerId?: string(name='external_loadbalancer_id'),
      initVersion?: string(name='init_version'),
      maintenanceWindow?: MaintenanceWindow(name='maintenance_window'),
      masterUrl?: string(name='master_url'),
      metaData?: string(name='meta_data'),
      name?: string(name='name'),
      networkMode?: string(name='network_mode'),
      nextVersion?: string(name='next_version'),
      privateZone?: boolean(name='private_zone'),
      profile?: string(name='profile'),
      regionId?: string(name='region_id'),
      resourceGroupId?: string(name='resource_group_id'),
      securityGroupId?: string(name='security_group_id'),
      size?: long(name='size'),
      state?: string(name='state'),
      subnetCidr?: string(name='subnet_cidr'),
      tags?: [
        Tag
      ](name='tags'),
      updated?: string(name='updated'),
      vpcId?: string(name='vpc_id'),
      vswitchId?: string(name='vswitch_id'),
      workerRamRoleName?: string(name='worker_ram_role_name'),
      zoneId?: string(name='zone_id'),
    }
  ](name='clusters'),
  pageInfo?: {
    pageNumber?: int32(name='page_number'),
    pageSize?: int32(name='page_size'),
    totalCount?: int32(name='total_count'),
  }(name='page_info'),
}

model DescribeClustersV1Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClustersV1ResponseBody(name='body'),
}

async function describeClustersV1(request: DescribeClustersV1Request): DescribeClustersV1Response {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeClustersV1WithOptions(request, headers, runtime);
}

async function describeClustersV1WithOptions(request: DescribeClustersV1Request, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeClustersV1Response {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterSpec)) {
    query['cluster_spec'] = request.clusterSpec;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['cluster_type'] = request.clusterType;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.profile)) {
    query['profile'] = request.profile;
  }
  if (!Util.isUnset(request.regionId)) {
    query['region_id'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClustersV1',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v1/clusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeEdgeMachineActiveProcessResponseBody = {
  logs?: string(name='logs'),
  progress?: long(name='progress'),
  requestId?: string(name='request_id'),
  state?: string(name='state'),
  step?: string(name='step'),
}

model DescribeEdgeMachineActiveProcessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEdgeMachineActiveProcessResponseBody(name='body'),
}

async function describeEdgeMachineActiveProcess(edgeMachineid: string): DescribeEdgeMachineActiveProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeEdgeMachineActiveProcessWithOptions(edgeMachineid, headers, runtime);
}

async function describeEdgeMachineActiveProcessWithOptions(edgeMachineid: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeEdgeMachineActiveProcessResponse {
  edgeMachineid = OpenApiUtil.getEncodeParam(edgeMachineid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeEdgeMachineActiveProcess',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/edge_machines/[edge_machineid]/activeprocess`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeEdgeMachineModelsResponseBody = {
  models?: [ 
    {
      cpu?: int32(name='cpu'),
      cpuArch?: string(name='cpu_arch'),
      created?: string(name='created'),
      description?: string(name='description'),
      manageRuntime?: int32(name='manage_runtime'),
      memory?: int32(name='memory'),
      model?: string(name='model'),
      modelId?: string(name='model_id'),
    }
  ](name='models'),
}

model DescribeEdgeMachineModelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEdgeMachineModelsResponseBody(name='body'),
}

async function describeEdgeMachineModels(): DescribeEdgeMachineModelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeEdgeMachineModelsWithOptions(headers, runtime);
}

async function describeEdgeMachineModelsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeEdgeMachineModelsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeEdgeMachineModels',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/edge_machines/models`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeEdgeMachineTunnelConfigDetailResponseBody = {
  deviceName?: string(name='device_name'),
  model?: string(name='model'),
  productKey?: string(name='product_key'),
  requestId?: string(name='request_id'),
  sn?: string(name='sn'),
  token?: string(name='token'),
  tunnelEndpoint?: string(name='tunnel_endpoint'),
}

model DescribeEdgeMachineTunnelConfigDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEdgeMachineTunnelConfigDetailResponseBody(name='body'),
}

async function describeEdgeMachineTunnelConfigDetail(edgeMachineid: string): DescribeEdgeMachineTunnelConfigDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeEdgeMachineTunnelConfigDetailWithOptions(edgeMachineid, headers, runtime);
}

async function describeEdgeMachineTunnelConfigDetailWithOptions(edgeMachineid: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeEdgeMachineTunnelConfigDetailResponse {
  edgeMachineid = OpenApiUtil.getEncodeParam(edgeMachineid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeEdgeMachineTunnelConfigDetail',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/edge_machines/[edge_machineid]/tunnelconfig`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeEdgeMachinesRequest {
  hostname?: string(name='hostname'),
  lifeState?: string(name='life_state'),
  model?: string(name='model'),
  onlineState?: string(name='online_state'),
  pageNumber?: long(name='page_number'),
  pageSize?: long(name='page_size'),
}

model DescribeEdgeMachinesResponseBody = {
  edgeMachines?: [ 
    {
      activeTime?: string(name='active_time'),
      created?: string(name='created'),
      edgeMachineId?: string(name='edge_machine_id'),
      hostname?: string(name='hostname'),
      lifeState?: string(name='life_state'),
      model?: string(name='model'),
      name?: string(name='name'),
      onlineState?: string(name='online_state'),
      sn?: string(name='sn'),
      updated?: string(name='updated'),
    }
  ](name='edge_machines'),
  pageInfo?: {
    pageNumber?: int32(name='page_number'),
    pageSize?: int32(name='page_size'),
    totalCount?: int32(name='total_count'),
  }(name='page_info'),
}

model DescribeEdgeMachinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEdgeMachinesResponseBody(name='body'),
}

async function describeEdgeMachines(request: DescribeEdgeMachinesRequest): DescribeEdgeMachinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeEdgeMachinesWithOptions(request, headers, runtime);
}

async function describeEdgeMachinesWithOptions(request: DescribeEdgeMachinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeEdgeMachinesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.hostname)) {
    query['hostname'] = request.hostname;
  }
  if (!Util.isUnset(request.lifeState)) {
    query['life_state'] = request.lifeState;
  }
  if (!Util.isUnset(request.model)) {
    query['model'] = request.model;
  }
  if (!Util.isUnset(request.onlineState)) {
    query['online_state'] = request.onlineState;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEdgeMachines',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/edge_machines`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeEventsRequest {
  clusterId?: string(name='cluster_id'),
  pageNumber?: long(name='page_number'),
  pageSize?: long(name='page_size'),
  type?: string(name='type'),
}

model DescribeEventsResponseBody = {
  events?: [ 
    {
      clusterId?: string(name='cluster_id'),
      data?: {
        level?: string(name='level'),
        message?: string(name='message'),
        reason?: string(name='reason'),
      }(name='data'),
      eventId?: string(name='event_id'),
      source?: string(name='source'),
      subject?: string(name='subject'),
      time?: string(name='time'),
      type?: string(name='type'),
    }
  ](name='events'),
  pageInfo?: {
    pageNumber?: long(name='page_number'),
    pageSize?: long(name='page_size'),
    totalCount?: long(name='total_count'),
  }(name='page_info'),
}

model DescribeEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEventsResponseBody(name='body'),
}

async function describeEvents(request: DescribeEventsRequest): DescribeEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeEventsWithOptions(request, headers, runtime);
}

async function describeEventsWithOptions(request: DescribeEventsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeEventsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterId)) {
    query['cluster_id'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEvents',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/events`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeExternalAgentRequest {
  privateIpAddress?: string(name='PrivateIpAddress'),
}

model DescribeExternalAgentResponseBody = {
  config?: string(name='config'),
}

model DescribeExternalAgentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeExternalAgentResponseBody(name='body'),
}

async function describeExternalAgent(ClusterId: string, request: DescribeExternalAgentRequest): DescribeExternalAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeExternalAgentWithOptions(ClusterId, request, headers, runtime);
}

async function describeExternalAgentWithOptions(ClusterId: string, request: DescribeExternalAgentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeExternalAgentResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExternalAgent',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/k8s/${ClusterId}/external/agent/deployment`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeKubernetesVersionMetadataRequest {
  clusterType?: string(name='ClusterType'),
  kubernetesVersion?: string(name='KubernetesVersion'),
  profile?: string(name='Profile'),
  region?: string(name='Region'),
  runtime?: string(name='runtime'),
}

model DescribeKubernetesVersionMetadataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [ 
    {
      capabilities?: map[string]any(name='capabilities'),
      images?: [ 
        {
          imageId?: string(name='image_id'),
          imageName?: string(name='image_name'),
          platform?: string(name='platform'),
          osVersion?: string(name='os_version'),
          imageType?: string(name='image_type'),
          osType?: string(name='os_type'),
          imageCategory?: string(name='image_category'),
        }
      ](name='images'),
      metaData?: map[string]any(name='meta_data'),
      runtimes?: [
        Runtime
      ](name='runtimes'),
      version?: string(name='version'),
      multiAz?: string(name='multi_az'),
    }
  ](name='body'),
}

async function describeKubernetesVersionMetadata(request: DescribeKubernetesVersionMetadataRequest): DescribeKubernetesVersionMetadataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeKubernetesVersionMetadataWithOptions(request, headers, runtime);
}

async function describeKubernetesVersionMetadataWithOptions(request: DescribeKubernetesVersionMetadataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeKubernetesVersionMetadataResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.kubernetesVersion)) {
    query['KubernetesVersion'] = request.kubernetesVersion;
  }
  if (!Util.isUnset(request.profile)) {
    query['Profile'] = request.profile;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.runtime)) {
    query['runtime'] = request.runtime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeKubernetesVersionMetadata',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v1/metadata/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model DescribeNodePoolVulsResponseBody = {
  vulRecords?: [ 
    {
      instanceId?: string(name='instance_id'),
      vulList?: [ 
        {
          aliasName?: string(name='alias_name'),
          cveList?: [ string ](name='cve_list'),
          name?: string(name='name'),
          necessity?: string(name='necessity'),
        }
      ](name='vul_list'),
    }
  ](name='vul_records'),
}

model DescribeNodePoolVulsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNodePoolVulsResponseBody(name='body'),
}

async function describeNodePoolVuls(clusterId: string, nodepoolId: string): DescribeNodePoolVulsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeNodePoolVulsWithOptions(clusterId, nodepoolId, headers, runtime);
}

async function describeNodePoolVulsWithOptions(clusterId: string, nodepoolId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeNodePoolVulsResponse {
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  nodepoolId = OpenApiUtil.getEncodeParam(nodepoolId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeNodePoolVuls',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/nodepools/${nodepoolId}/vuls`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribePoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: object(name='body'),
}

async function describePolicies(): DescribePoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePoliciesWithOptions(headers, runtime);
}

async function describePoliciesWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribePoliciesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribePolicies',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/policies`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribePolicyDetailsResponseBody = {
  action?: string(name='action'),
  category?: string(name='category'),
  description?: string(name='description'),
  isDeleted?: int32(name='is_deleted'),
  name?: string(name='name'),
  noConfig?: int32(name='no_config'),
  severity?: string(name='severity'),
  template?: string(name='template'),
}

model DescribePolicyDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePolicyDetailsResponseBody(name='body'),
}

async function describePolicyDetails(policyName: string): DescribePolicyDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePolicyDetailsWithOptions(policyName, headers, runtime);
}

async function describePolicyDetailsWithOptions(policyName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribePolicyDetailsResponse {
  policyName = OpenApiUtil.getEncodeParam(policyName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribePolicyDetails',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/policies/${policyName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribePolicyGovernanceInClusterResponseBody = {
  admitLog?: {
    count?: long(name='count'),
    log?: {
      clusterId?: string(name='cluster_id'),
      constraintKind?: string(name='constraint_kind'),
      msg?: string(name='msg'),
      resourceKind?: string(name='resource_kind'),
      resourceName?: string(name='resource_name'),
      resourceNamespace?: string(name='resource_namespace'),
    }(name='log'),
    progress?: string(name='progress'),
  }(name='admit_log'),
  onState?: [ 
    {
      enabledCount?: int32(name='enabled_count'),
      severity?: string(name='severity'),
      total?: int32(name='total'),
    }
  ](name='on_state'),
  totalViolations?: {
    deny?: {
      severity?: string(name='severity'),
      violations?: long(name='violations'),
    }(name='deny'),
    warn?: {
      severity?: string(name='severity'),
      violations?: long(name='violations'),
    }(name='warn'),
  }(name='totalViolations'),
  violations?: {
    deny?: {
      policyDescription?: string(name='policyDescription'),
      policyName?: string(name='policyName'),
      severity?: string(name='severity'),
      violations?: long(name='violations'),
    }(name='deny'),
    warn?: {
      policyDescription?: string(name='policyDescription'),
      policyName?: string(name='policyName'),
      severity?: string(name='severity'),
      violations?: long(name='violations'),
    }(name='warn'),
  }(name='violations'),
}

model DescribePolicyGovernanceInClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePolicyGovernanceInClusterResponseBody(name='body'),
}

async function describePolicyGovernanceInCluster(clusterId: string): DescribePolicyGovernanceInClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePolicyGovernanceInClusterWithOptions(clusterId, headers, runtime);
}

async function describePolicyGovernanceInClusterWithOptions(clusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribePolicyGovernanceInClusterResponse {
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribePolicyGovernanceInCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/policygovernance`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribePolicyInstancesRequest {
  instanceName?: string(name='instance_name'),
  policyName?: string(name='policy_name'),
}

model DescribePolicyInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [ 
    {
      aliUid?: string(name='ali_uid'),
      clusterId?: string(name='cluster_id'),
      instanceName?: string(name='instance_name'),
      policyName?: string(name='policy_name'),
      policyCategory?: string(name='policy_category'),
      policyDescription?: string(name='policy_description'),
      policyParameters?: string(name='policy_parameters'),
      policySeverity?: string(name='policy_severity'),
      policyScope?: string(name='policy_scope'),
      policyAction?: string(name='policy_action'),
    }
  ](name='body'),
}

async function describePolicyInstances(clusterId: string, request: DescribePolicyInstancesRequest): DescribePolicyInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePolicyInstancesWithOptions(clusterId, request, headers, runtime);
}

async function describePolicyInstancesWithOptions(clusterId: string, request: DescribePolicyInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribePolicyInstancesResponse {
  Util.validateModel(request);
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceName)) {
    query['instance_name'] = request.instanceName;
  }
  if (!Util.isUnset(request.policyName)) {
    query['policy_name'] = request.policyName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePolicyInstances',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/policies`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model DescribePolicyInstancesStatusResponseBody = {
  instancesSeverityCount?: map[string]any(name='instances_severity_count'),
  policyInstances?: [ 
    {
      policyCategory?: string(name='policy_category'),
      policyDescription?: string(name='policy_description'),
      policyInstancesCount?: long(name='policy_instances_count'),
      policyName?: string(name='policy_name'),
      policySeverity?: string(name='policy_severity'),
    }
  ](name='policy_instances'),
}

model DescribePolicyInstancesStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePolicyInstancesStatusResponseBody(name='body'),
}

async function describePolicyInstancesStatus(clusterId: string): DescribePolicyInstancesStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePolicyInstancesStatusWithOptions(clusterId, headers, runtime);
}

async function describePolicyInstancesStatusWithOptions(clusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribePolicyInstancesStatusResponse {
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribePolicyInstancesStatus',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/policies/status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeTaskInfoResponseBody = {
  clusterId?: string(name='cluster_id'),
  created?: string(name='created'),
  currentStage?: string(name='current_stage'),
  error?: {
    code?: string(name='code'),
    message?: string(name='message'),
  }(name='error'),
  events?: [ 
    {
      action?: string(name='action'),
      level?: string(name='level'),
      message?: string(name='message'),
      reason?: string(name='reason'),
      source?: string(name='source'),
      timestamp?: string(name='timestamp'),
    }
  ](name='events'),
  parameters?: map[string]any(name='parameters'),
  stages?: [ 
    {
      endTime?: string(name='end_time'),
      message?: string(name='message'),
      outputs?: map[string]any(name='outputs'),
      startTime?: string(name='start_time'),
      state?: string(name='state'),
    }
  ](name='stages'),
  state?: string(name='state'),
  target?: {
    id?: string(name='id'),
    type?: string(name='type'),
  }(name='target'),
  taskId?: string(name='task_id'),
  taskResult?: [ 
    {
      data?: string(name='data'),
      status?: string(name='status'),
    }
  ](name='task_result'),
  taskType?: string(name='task_type'),
  updated?: string(name='updated'),
}

model DescribeTaskInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTaskInfoResponseBody(name='body'),
}

async function describeTaskInfo(taskId: string): DescribeTaskInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeTaskInfoWithOptions(taskId, headers, runtime);
}

async function describeTaskInfoWithOptions(taskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeTaskInfoResponse {
  taskId = OpenApiUtil.getEncodeParam(taskId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeTaskInfo',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/tasks/${taskId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeTemplateAttributeRequest {
  templateType?: string(name='template_type'),
}

model DescribeTemplateAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [ 
    {
      id?: string(name='id'),
      acl?: string(name='acl'),
      name?: string(name='name'),
      template?: string(name='template'),
      templateType?: string(name='template_type'),
      description?: string(name='description'),
      tags?: string(name='tags'),
      templateWithHistId?: string(name='template_with_hist_id'),
      created?: string(name='created'),
      updated?: string(name='updated'),
    }
  ](name='body'),
}

async function describeTemplateAttribute(TemplateId: string, request: DescribeTemplateAttributeRequest): DescribeTemplateAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeTemplateAttributeWithOptions(TemplateId, request, headers, runtime);
}

async function describeTemplateAttributeWithOptions(TemplateId: string, request: DescribeTemplateAttributeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeTemplateAttributeResponse {
  Util.validateModel(request);
  TemplateId = OpenApiUtil.getEncodeParam(TemplateId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.templateType)) {
    query['template_type'] = request.templateType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTemplateAttribute',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/templates/${TemplateId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model DescribeTemplatesRequest {
  pageNum?: long(name='page_num'),
  pageSize?: long(name='page_size'),
  templateType?: string(name='template_type'),
}

model DescribeTemplatesResponseBody = {
  pageInfo?: {
    pageNumber?: long(name='page_number'),
    pageSize?: long(name='page_size'),
    totalCount?: long(name='total_count'),
  }(name='page_info'),
  templates?: [ 
    {
      acl?: string(name='acl'),
      created?: string(name='created'),
      description?: string(name='description'),
      id?: string(name='id'),
      name?: string(name='name'),
      tags?: string(name='tags'),
      template?: string(name='template'),
      templateType?: string(name='template_type'),
      templateWithHistId?: string(name='template_with_hist_id'),
      updated?: string(name='updated'),
    }
  ](name='templates'),
}

model DescribeTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTemplatesResponseBody(name='body'),
}

async function describeTemplates(request: DescribeTemplatesRequest): DescribeTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeTemplatesWithOptions(request, headers, runtime);
}

async function describeTemplatesWithOptions(request: DescribeTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeTemplatesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNum)) {
    query['page_num'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.templateType)) {
    query['template_type'] = request.templateType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTemplates',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/templates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeTriggerRequest {
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  type?: string(name='Type'),
  action?: string(name='action'),
}

model DescribeTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [ 
    {
      id?: string(name='id'),
      name?: string(name='name'),
      clusterId?: string(name='cluster_id'),
      projectId?: string(name='project_id'),
      type?: string(name='type'),
      action?: string(name='action'),
      token?: string(name='token'),
    }
  ](name='body'),
}

async function describeTrigger(clusterId: string, request: DescribeTriggerRequest): DescribeTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeTriggerWithOptions(clusterId, request, headers, runtime);
}

async function describeTriggerWithOptions(clusterId: string, request: DescribeTriggerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeTriggerResponse {
  Util.validateModel(request);
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.action)) {
    query['action'] = request.action;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTrigger',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/[cluster_id]/triggers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model DescribeUserPermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [ 
    {
      resourceId?: string(name='resource_id'),
      resourceType?: string(name='resource_type'),
      roleName?: string(name='role_name'),
      roleType?: string(name='role_type'),
      isOwner?: long(name='is_owner'),
      isRamRole?: long(name='is_ram_role'),
    }
  ](name='body'),
}

async function describeUserPermission(uid: string): DescribeUserPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeUserPermissionWithOptions(uid, headers, runtime);
}

async function describeUserPermissionWithOptions(uid: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeUserPermissionResponse {
  uid = OpenApiUtil.getEncodeParam(uid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserPermission',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/permissions/users/${uid}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model DescribeUserQuotaResponseBody = {
  amkClusterQuota?: long(name='amk_cluster_quota'),
  askClusterQuota?: long(name='ask_cluster_quota'),
  clusterNodepoolQuota?: long(name='cluster_nodepool_quota'),
  clusterQuota?: long(name='cluster_quota'),
  nodeQuota?: long(name='node_quota'),
}

model DescribeUserQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUserQuotaResponseBody(name='body'),
}

async function describeUserQuota(): DescribeUserQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeUserQuotaWithOptions(headers, runtime);
}

async function describeUserQuotaWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeUserQuotaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserQuota',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/quota`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeWorkflowsResponseBody = {
  jobs?: [ 
    {
      clusterId?: string(name='cluster_id'),
      createTime?: string(name='create_time'),
      jobName?: string(name='job_name'),
    }
  ](name='jobs'),
}

model DescribeWorkflowsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWorkflowsResponseBody(name='body'),
}

async function describeWorkflows(): DescribeWorkflowsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeWorkflowsWithOptions(headers, runtime);
}

async function describeWorkflowsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeWorkflowsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeWorkflows',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/gs/workflows`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model EdgeClusterAddEdgeMachineRequest {
  expired?: long(name='expired'),
  nodepoolId?: string(name='nodepool_id'),
  options?: string(name='options'),
}

model EdgeClusterAddEdgeMachineResponseBody = {
  edgeMachineId?: string(name='edge_machine_id'),
  requestId?: string(name='request_id'),
}

model EdgeClusterAddEdgeMachineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EdgeClusterAddEdgeMachineResponseBody(name='body'),
}

async function edgeClusterAddEdgeMachine(clusterid: string, edgeMachineid: string, request: EdgeClusterAddEdgeMachineRequest): EdgeClusterAddEdgeMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return edgeClusterAddEdgeMachineWithOptions(clusterid, edgeMachineid, request, headers, runtime);
}

async function edgeClusterAddEdgeMachineWithOptions(clusterid: string, edgeMachineid: string, request: EdgeClusterAddEdgeMachineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EdgeClusterAddEdgeMachineResponse {
  Util.validateModel(request);
  clusterid = OpenApiUtil.getEncodeParam(clusterid);
  edgeMachineid = OpenApiUtil.getEncodeParam(edgeMachineid);
  var body : map[string]any = {};
  if (!Util.isUnset(request.expired)) {
    body['expired'] = request.expired;
  }
  if (!Util.isUnset(request.nodepoolId)) {
    body['nodepool_id'] = request.nodepoolId;
  }
  if (!Util.isUnset(request.options)) {
    body['options'] = request.options;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EdgeClusterAddEdgeMachine',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/[clusterid]/attachedgemachine/[edge_machineid]`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model FixNodePoolVulsRequest {
  nodes?: [ string ](name='nodes'),
  rolloutPolicy?: {
    maxParallelism?: long(name='max_parallelism'),
  }(name='rollout_policy'),
  vulList?: [ string ](name='vul_list'),
}

model FixNodePoolVulsResponseBody = {
  taskId?: string(name='task_id'),
}

model FixNodePoolVulsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FixNodePoolVulsResponseBody(name='body'),
}

async function fixNodePoolVuls(clusterId: string, nodepoolId: string, request: FixNodePoolVulsRequest): FixNodePoolVulsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fixNodePoolVulsWithOptions(clusterId, nodepoolId, request, headers, runtime);
}

async function fixNodePoolVulsWithOptions(clusterId: string, nodepoolId: string, request: FixNodePoolVulsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FixNodePoolVulsResponse {
  Util.validateModel(request);
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  nodepoolId = OpenApiUtil.getEncodeParam(nodepoolId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.nodes)) {
    body['nodes'] = request.nodes;
  }
  if (!Util.isUnset(request.rolloutPolicy)) {
    body['rollout_policy'] = request.rolloutPolicy;
  }
  if (!Util.isUnset(request.vulList)) {
    body['vul_list'] = request.vulList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FixNodePoolVuls',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/nodepools/${nodepoolId}/vuls/fix`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetKubernetesTriggerRequest {
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  type?: string(name='Type'),
  action?: string(name='action'),
}

model GetKubernetesTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [ 
    {
      id?: string(name='id'),
      name?: string(name='name'),
      clusterId?: string(name='cluster_id'),
      projectId?: string(name='project_id'),
      type?: string(name='type'),
      action?: string(name='action'),
      token?: string(name='token'),
    }
  ](name='body'),
}

async function getKubernetesTrigger(ClusterId: string, request: GetKubernetesTriggerRequest): GetKubernetesTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getKubernetesTriggerWithOptions(ClusterId, request, headers, runtime);
}

async function getKubernetesTriggerWithOptions(ClusterId: string, request: GetKubernetesTriggerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetKubernetesTriggerResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.action)) {
    query['action'] = request.action;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetKubernetesTrigger',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/triggers/${ClusterId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model GetUpgradeStatusResponseBody = {
  errorMessage?: string(name='error_message'),
  precheckReportId?: string(name='precheck_report_id'),
  status?: string(name='status'),
  upgradeStep?: string(name='upgrade_step'),
  upgradeTask?: {
    message?: string(name='message'),
    status?: string(name='status'),
  }(name='upgrade_task'),
}

model GetUpgradeStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUpgradeStatusResponseBody(name='body'),
}

async function getUpgradeStatus(ClusterId: string): GetUpgradeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUpgradeStatusWithOptions(ClusterId, headers, runtime);
}

async function getUpgradeStatusWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetUpgradeStatusResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetUpgradeStatus',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/clusters/${ClusterId}/upgrade/status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GrantPermissionsRequest {
  body?: [ 
    {
      cluster?: string(name='cluster'),
      isCustom?: boolean(name='is_custom'),
      isRamRole?: boolean(name='is_ram_role'),
      namespace?: string(name='namespace'),
      roleName?: string(name='role_name'),
      roleType?: string(name='role_type'),
    }
  ](name='body'),
}

model GrantPermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function grantPermissions(uid: string, request: GrantPermissionsRequest): GrantPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return grantPermissionsWithOptions(uid, request, headers, runtime);
}

async function grantPermissionsWithOptions(uid: string, request: GrantPermissionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GrantPermissionsResponse {
  Util.validateModel(request);
  uid = OpenApiUtil.getEncodeParam(uid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'GrantPermissions',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/permissions/users/${uid}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model InstallClusterAddonsRequest {
  body?: [ 
    {
      config?: string(name='config'),
      name?: string(name='name'),
      version?: string(name='version'),
    }
  ](name='body'),
}

model InstallClusterAddonsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function installClusterAddons(ClusterId: string, request: InstallClusterAddonsRequest): InstallClusterAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installClusterAddonsWithOptions(ClusterId, request, headers, runtime);
}

async function installClusterAddonsWithOptions(ClusterId: string, request: InstallClusterAddonsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallClusterAddonsResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'InstallClusterAddons',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/components/install`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='next_token'),
  regionId?: string(name='region_id'),
  resourceIds?: [ string ](name='resource_ids'),
  resourceType?: string(name='resource_type'),
  tags?: [
    Tag
  ](name='tags'),
}

model ListTagResourcesShrinkRequest {
  nextToken?: string(name='next_token'),
  regionId?: string(name='region_id'),
  resourceIdsShrink?: string(name='resource_ids'),
  resourceType?: string(name='resource_type'),
  tagsShrink?: string(name='tags'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='next_token'),
  requestId?: string(name='request_id'),
  tagResources?: {
    tagResource?: [ 
      {
        resourceId?: string(name='resource_id'),
        resourceType?: string(name='resource_type'),
        tagKey?: string(name='tag_key'),
        tagValue?: string(name='tag_value'),
      }
    ](name='tag_resource'),
  }(name='tag_resources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

async function listTagResourcesWithOptions(tmpReq: ListTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceIds)) {
    request.resourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceIds, 'resource_ids', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'tags', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.nextToken)) {
    query['next_token'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['region_id'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceIdsShrink)) {
    query['resource_ids'] = request.resourceIdsShrink;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resource_type'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['tags'] = request.tagsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model MigrateClusterRequest {
  ossBucketEndpoint?: string(name='oss_bucket_endpoint'),
  ossBucketName?: string(name='oss_bucket_name'),
}

model MigrateClusterResponseBody = {
  clusterId?: string(name='cluster_id'),
  requestId?: string(name='request_id'),
  taskId?: string(name='task_id'),
}

model MigrateClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MigrateClusterResponseBody(name='body'),
}

async function migrateCluster(clusterId: string, request: MigrateClusterRequest): MigrateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return migrateClusterWithOptions(clusterId, request, headers, runtime);
}

async function migrateClusterWithOptions(clusterId: string, request: MigrateClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MigrateClusterResponse {
  Util.validateModel(request);
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ossBucketEndpoint)) {
    body['oss_bucket_endpoint'] = request.ossBucketEndpoint;
  }
  if (!Util.isUnset(request.ossBucketName)) {
    body['oss_bucket_name'] = request.ossBucketName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'MigrateCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/migrate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyClusterRequest {
  apiServerEip?: boolean(name='api_server_eip'),
  apiServerEipId?: string(name='api_server_eip_id'),
  deletionProtection?: boolean(name='deletion_protection'),
  enableRrsa?: boolean(name='enable_rrsa'),
  ingressDomainRebinding?: string(name='ingress_domain_rebinding'),
  ingressLoadbalancerId?: string(name='ingress_loadbalancer_id'),
  instanceDeletionProtection?: boolean(name='instance_deletion_protection'),
  maintenanceWindow?: MaintenanceWindow(name='maintenance_window'),
  resourceGroupId?: string(name='resource_group_id'),
}

model ModifyClusterResponseBody = {
  clusterId?: string(name='cluster_id'),
  requestId?: string(name='request_id'),
  taskId?: string(name='task_id'),
}

model ModifyClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyClusterResponseBody(name='body'),
}

async function modifyCluster(ClusterId: string, request: ModifyClusterRequest): ModifyClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyClusterWithOptions(ClusterId, request, headers, runtime);
}

async function modifyClusterWithOptions(ClusterId: string, request: ModifyClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyClusterResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apiServerEip)) {
    body['api_server_eip'] = request.apiServerEip;
  }
  if (!Util.isUnset(request.apiServerEipId)) {
    body['api_server_eip_id'] = request.apiServerEipId;
  }
  if (!Util.isUnset(request.deletionProtection)) {
    body['deletion_protection'] = request.deletionProtection;
  }
  if (!Util.isUnset(request.enableRrsa)) {
    body['enable_rrsa'] = request.enableRrsa;
  }
  if (!Util.isUnset(request.ingressDomainRebinding)) {
    body['ingress_domain_rebinding'] = request.ingressDomainRebinding;
  }
  if (!Util.isUnset(request.ingressLoadbalancerId)) {
    body['ingress_loadbalancer_id'] = request.ingressLoadbalancerId;
  }
  if (!Util.isUnset(request.instanceDeletionProtection)) {
    body['instance_deletion_protection'] = request.instanceDeletionProtection;
  }
  if (!Util.isUnset(request.maintenanceWindow)) {
    body['maintenance_window'] = request.maintenanceWindow;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resource_group_id'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/clusters/${ClusterId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyClusterAddonRequest {
  config?: string(name='config'),
}

model ModifyClusterAddonResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function modifyClusterAddon(clusterId: string, componentId: string, request: ModifyClusterAddonRequest): ModifyClusterAddonResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyClusterAddonWithOptions(clusterId, componentId, request, headers, runtime);
}

async function modifyClusterAddonWithOptions(clusterId: string, componentId: string, request: ModifyClusterAddonRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyClusterAddonResponse {
  Util.validateModel(request);
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  componentId = OpenApiUtil.getEncodeParam(componentId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.config)) {
    body['config'] = request.config;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterAddon',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/components/${componentId}/config`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ModifyClusterConfigurationRequest {
  customizeConfig?: [ 
    {
      configs?: [ 
        {
          key?: string(name='key'),
          value?: string(name='value'),
        }
      ](name='configs'),
      name?: string(name='name'),
    }
  ](name='customize_config'),
}

model ModifyClusterConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function modifyClusterConfiguration(ClusterId: string, request: ModifyClusterConfigurationRequest): ModifyClusterConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyClusterConfigurationWithOptions(ClusterId, request, headers, runtime);
}

async function modifyClusterConfigurationWithOptions(ClusterId: string, request: ModifyClusterConfigurationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyClusterConfigurationResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.customizeConfig)) {
    body['customize_config'] = request.customizeConfig;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterConfiguration',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/configuration`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ModifyClusterNodePoolRequest {
  autoScaling?: {
    eipBandwidth?: long(name='eip_bandwidth'),
    eipInternetChargeType?: string(name='eip_internet_charge_type'),
    enable?: boolean(name='enable'),
    isBondEip?: boolean(name='is_bond_eip'),
    maxInstances?: long(name='max_instances'),
    minInstances?: long(name='min_instances'),
    type?: string(name='type'),
  }(name='auto_scaling'),
  kubernetesConfig?: {
    cmsEnabled?: boolean(name='cms_enabled'),
    cpuPolicy?: string(name='cpu_policy'),
    labels?: [
      Tag
    ](name='labels'),
    runtime?: string(name='runtime'),
    runtimeVersion?: string(name='runtime_version'),
    taints?: [
      Taint
    ](name='taints'),
    userData?: string(name='user_data'),
  }(name='kubernetes_config'),
  management?: {
    autoRepair?: boolean(name='auto_repair'),
    enable?: boolean(name='enable'),
    upgradeConfig?: {
      autoUpgrade?: boolean(name='auto_upgrade'),
      maxUnavailable?: long(name='max_unavailable'),
      surge?: long(name='surge'),
      surgePercentage?: long(name='surge_percentage'),
    }(name='upgrade_config'),
  }(name='management'),
  nodepoolInfo?: {
    name?: string(name='name'),
    resourceGroupId?: string(name='resource_group_id'),
  }(name='nodepool_info'),
  scalingGroup?: {
    autoRenew?: boolean(name='auto_renew'),
    autoRenewPeriod?: long(name='auto_renew_period'),
    compensateWithOnDemand?: boolean(name='compensate_with_on_demand'),
    dataDisks?: [
      DataDisk
    ](name='data_disks'),
    desiredSize?: long(name='desired_size'),
    imageId?: string(name='image_id'),
    instanceChargeType?: string(name='instance_charge_type'),
    instanceTypes?: [ string ](name='instance_types'),
    internetChargeType?: string(name='internet_charge_type'),
    internetMaxBandwidthOut?: long(name='internet_max_bandwidth_out'),
    keyPair?: string(name='key_pair'),
    loginPassword?: string(name='login_password'),
    multiAzPolicy?: string(name='multi_az_policy'),
    onDemandBaseCapacity?: long(name='on_demand_base_capacity'),
    onDemandPercentageAboveBaseCapacity?: long(name='on_demand_percentage_above_base_capacity'),
    period?: long(name='period'),
    periodUnit?: string(name='period_unit'),
    platform?: string(name='platform'),
    rdsInstances?: [ string ](name='rds_instances'),
    scalingPolicy?: string(name='scaling_policy'),
    spotInstancePools?: long(name='spot_instance_pools'),
    spotInstanceRemedy?: boolean(name='spot_instance_remedy'),
    spotPriceLimit?: [ 
      {
        instanceType?: string(name='instance_type'),
        priceLimit?: string(name='price_limit'),
      }
    ](name='spot_price_limit'),
    spotStrategy?: string(name='spot_strategy'),
    systemDiskCategory?: string(name='system_disk_category'),
    systemDiskPerformanceLevel?: string(name='system_disk_performance_level'),
    systemDiskSize?: long(name='system_disk_size'),
    tags?: [
      Tag
    ](name='tags'),
    vswitchIds?: [ string ](name='vswitch_ids'),
  }(name='scaling_group'),
  teeConfig?: {
    teeEnable?: boolean(name='tee_enable'),
  }(name='tee_config'),
  updateNodes?: boolean(name='update_nodes'),
}

model ModifyClusterNodePoolResponseBody = {
  nodepoolId?: string(name='nodepool_id'),
  taskId?: string(name='task_id'),
}

model ModifyClusterNodePoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyClusterNodePoolResponseBody(name='body'),
}

async function modifyClusterNodePool(ClusterId: string, NodepoolId: string, request: ModifyClusterNodePoolRequest): ModifyClusterNodePoolResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyClusterNodePoolWithOptions(ClusterId, NodepoolId, request, headers, runtime);
}

async function modifyClusterNodePoolWithOptions(ClusterId: string, NodepoolId: string, request: ModifyClusterNodePoolRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyClusterNodePoolResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  NodepoolId = OpenApiUtil.getEncodeParam(NodepoolId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoScaling)) {
    body['auto_scaling'] = request.autoScaling;
  }
  if (!Util.isUnset(request.kubernetesConfig)) {
    body['kubernetes_config'] = request.kubernetesConfig;
  }
  if (!Util.isUnset(request.management)) {
    body['management'] = request.management;
  }
  if (!Util.isUnset(request.nodepoolInfo)) {
    body['nodepool_info'] = request.nodepoolInfo;
  }
  if (!Util.isUnset(request.scalingGroup)) {
    body['scaling_group'] = request.scalingGroup;
  }
  if (!Util.isUnset(request.teeConfig)) {
    body['tee_config'] = request.teeConfig;
  }
  if (!Util.isUnset(request.updateNodes)) {
    body['update_nodes'] = request.updateNodes;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterNodePool',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/nodepools/${NodepoolId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyClusterTagsRequest {
  body?: [
    Tag
  ](name='body'),
}

model ModifyClusterTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function modifyClusterTags(ClusterId: string, request: ModifyClusterTagsRequest): ModifyClusterTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyClusterTagsWithOptions(ClusterId, request, headers, runtime);
}

async function modifyClusterTagsWithOptions(ClusterId: string, request: ModifyClusterTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyClusterTagsResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterTags',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/tags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ModifyNodePoolNodeConfigRequest {
  kubeletConfig?: {
    cpuManagerPolicy?: string(name='cpuManagerPolicy'),
    eventBurst?: long(name='eventBurst'),
    eventRecordQPS?: long(name='eventRecordQPS'),
    evictionHard?: map[string]any(name='evictionHard'),
    evictionSoft?: map[string]any(name='evictionSoft'),
    evictionSoftGracePeriod?: map[string]any(name='evictionSoftGracePeriod'),
    kubeAPIBurst?: long(name='kubeAPIBurst'),
    kubeAPIQPS?: long(name='kubeAPIQPS'),
    kubeReserved?: map[string]any(name='kubeReserved'),
    registryBurst?: long(name='registryBurst'),
    registryPullQPS?: long(name='registryPullQPS'),
    serializeImagePulls?: boolean(name='serializeImagePulls'),
    systemReserved?: map[string]any(name='systemReserved'),
  }(name='kubelet_config'),
  rollingPolicy?: {
    maxParallelism?: long(name='max_parallelism'),
  }(name='rolling_policy'),
}

model ModifyNodePoolNodeConfigResponseBody = {
  nodepoolId?: string(name='nodepool_id'),
  requestId?: string(name='request_id'),
  taskId?: string(name='task_id'),
}

model ModifyNodePoolNodeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyNodePoolNodeConfigResponseBody(name='body'),
}

async function modifyNodePoolNodeConfig(ClusterId: string, NodepoolId: string, request: ModifyNodePoolNodeConfigRequest): ModifyNodePoolNodeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyNodePoolNodeConfigWithOptions(ClusterId, NodepoolId, request, headers, runtime);
}

async function modifyNodePoolNodeConfigWithOptions(ClusterId: string, NodepoolId: string, request: ModifyNodePoolNodeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyNodePoolNodeConfigResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  NodepoolId = OpenApiUtil.getEncodeParam(NodepoolId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.kubeletConfig)) {
    body['kubelet_config'] = request.kubeletConfig;
  }
  if (!Util.isUnset(request.rollingPolicy)) {
    body['rolling_policy'] = request.rollingPolicy;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNodePoolNodeConfig',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/nodepools/${NodepoolId}/node_config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyPolicyInstanceRequest {
  action?: string(name='action'),
  instanceName?: string(name='instance_name'),
  namespaces?: [ string ](name='namespaces'),
  parameters?: map[string]any(name='parameters'),
}

model ModifyPolicyInstanceResponseBody = {
  instances?: [ string ](name='instances'),
}

model ModifyPolicyInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyPolicyInstanceResponseBody(name='body'),
}

async function modifyPolicyInstance(clusterId: string, policyName: string, request: ModifyPolicyInstanceRequest): ModifyPolicyInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyPolicyInstanceWithOptions(clusterId, policyName, request, headers, runtime);
}

async function modifyPolicyInstanceWithOptions(clusterId: string, policyName: string, request: ModifyPolicyInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyPolicyInstanceResponse {
  Util.validateModel(request);
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  policyName = OpenApiUtil.getEncodeParam(policyName);
  var body : map[string]any = {};
  if (!Util.isUnset(request.action)) {
    body['action'] = request.action;
  }
  if (!Util.isUnset(request.instanceName)) {
    body['instance_name'] = request.instanceName;
  }
  if (!Util.isUnset(request.namespaces)) {
    body['namespaces'] = request.namespaces;
  }
  if (!Util.isUnset(request.parameters)) {
    body['parameters'] = request.parameters;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPolicyInstance',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/policies/${policyName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model OpenAckServiceRequest {
  type?: string(name='type'),
}

model OpenAckServiceResponseBody = {
  orderId?: string(name='order_id'),
  requestId?: string(name='request_id'),
}

model OpenAckServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenAckServiceResponseBody(name='body'),
}

async function openAckService(request: OpenAckServiceRequest): OpenAckServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return openAckServiceWithOptions(request, headers, runtime);
}

async function openAckServiceWithOptions(request: OpenAckServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): OpenAckServiceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenAckService',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/service/open`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PauseClusterUpgradeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function pauseClusterUpgrade(ClusterId: string): PauseClusterUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return pauseClusterUpgradeWithOptions(ClusterId, headers, runtime);
}

async function pauseClusterUpgradeWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): PauseClusterUpgradeResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'PauseClusterUpgrade',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/clusters/${ClusterId}/upgrade/pause`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model PauseComponentUpgradeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function pauseComponentUpgrade(clusterid: string, componentid: string): PauseComponentUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return pauseComponentUpgradeWithOptions(clusterid, componentid, headers, runtime);
}

async function pauseComponentUpgradeWithOptions(clusterid: string, componentid: string, headers: map[string]string, runtime: Util.RuntimeOptions): PauseComponentUpgradeResponse {
  clusterid = OpenApiUtil.getEncodeParam(clusterid);
  componentid = OpenApiUtil.getEncodeParam(componentid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'PauseComponentUpgrade',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterid}/components/${componentid}/pause`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model PauseTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function pauseTask(taskId: string): PauseTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return pauseTaskWithOptions(taskId, headers, runtime);
}

async function pauseTaskWithOptions(taskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): PauseTaskResponse {
  taskId = OpenApiUtil.getEncodeParam(taskId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'PauseTask',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/tasks/${taskId}/pause`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model RemoveClusterNodesRequest {
  drainNode?: boolean(name='drain_node'),
  nodes?: [ string ](name='nodes'),
  releaseNode?: boolean(name='release_node'),
}

model RemoveClusterNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function removeClusterNodes(ClusterId: string, request: RemoveClusterNodesRequest): RemoveClusterNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeClusterNodesWithOptions(ClusterId, request, headers, runtime);
}

async function removeClusterNodesWithOptions(ClusterId: string, request: RemoveClusterNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveClusterNodesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.drainNode)) {
    body['drain_node'] = request.drainNode;
  }
  if (!Util.isUnset(request.nodes)) {
    body['nodes'] = request.nodes;
  }
  if (!Util.isUnset(request.releaseNode)) {
    body['release_node'] = request.releaseNode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveClusterNodes',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/clusters/${ClusterId}/nodes/remove`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model RemoveWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function removeWorkflow(workflowName: string): RemoveWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeWorkflowWithOptions(workflowName, headers, runtime);
}

async function removeWorkflowWithOptions(workflowName: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveWorkflowResponse {
  workflowName = OpenApiUtil.getEncodeParam(workflowName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveWorkflow',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/gs/workflow/${workflowName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model RepairClusterNodePoolRequest {
  nodes?: [ string ](name='nodes'),
}

model RepairClusterNodePoolResponseBody = {
  requestId?: string(name='request_id'),
  taskId?: string(name='task_id'),
}

model RepairClusterNodePoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RepairClusterNodePoolResponseBody(name='body'),
}

async function repairClusterNodePool(clusterId: string, nodepoolId: string, request: RepairClusterNodePoolRequest): RepairClusterNodePoolResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return repairClusterNodePoolWithOptions(clusterId, nodepoolId, request, headers, runtime);
}

async function repairClusterNodePoolWithOptions(clusterId: string, nodepoolId: string, request: RepairClusterNodePoolRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RepairClusterNodePoolResponse {
  Util.validateModel(request);
  clusterId = OpenApiUtil.getEncodeParam(clusterId);
  nodepoolId = OpenApiUtil.getEncodeParam(nodepoolId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.nodes)) {
    body['nodes'] = request.nodes;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RepairClusterNodePool',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterId}/nodepools/${nodepoolId}/repair`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ResumeComponentUpgradeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function resumeComponentUpgrade(clusterid: string, componentid: string): ResumeComponentUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resumeComponentUpgradeWithOptions(clusterid, componentid, headers, runtime);
}

async function resumeComponentUpgradeWithOptions(clusterid: string, componentid: string, headers: map[string]string, runtime: Util.RuntimeOptions): ResumeComponentUpgradeResponse {
  clusterid = OpenApiUtil.getEncodeParam(clusterid);
  componentid = OpenApiUtil.getEncodeParam(componentid);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ResumeComponentUpgrade',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${clusterid}/components/${componentid}/resume`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ResumeTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function resumeTask(taskId: string): ResumeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resumeTaskWithOptions(taskId, headers, runtime);
}

async function resumeTaskWithOptions(taskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ResumeTaskResponse {
  taskId = OpenApiUtil.getEncodeParam(taskId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ResumeTask',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/tasks/${taskId}/resume`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ResumeUpgradeClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function resumeUpgradeCluster(ClusterId: string): ResumeUpgradeClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resumeUpgradeClusterWithOptions(ClusterId, headers, runtime);
}

async function resumeUpgradeClusterWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ResumeUpgradeClusterResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ResumeUpgradeCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/clusters/${ClusterId}/upgrade/resume`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ScaleClusterRequest {
  cloudMonitorFlags?: boolean(name='cloud_monitor_flags'),
  count?: long(name='count'),
  cpuPolicy?: string(name='cpu_policy'),
  disableRollback?: boolean(name='disable_rollback'),
  keyPair?: string(name='key_pair'),
  loginPassword?: string(name='login_password'),
  tags?: [ 
    {
      key?: string(name='key'),
    }
  ](name='tags'),
  taints?: [ 
    {
      effect?: string(name='effect'),
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='taints'),
  vswitchIds?: [ string ](name='vswitch_ids'),
  workerAutoRenew?: boolean(name='worker_auto_renew'),
  workerAutoRenewPeriod?: long(name='worker_auto_renew_period'),
  workerDataDisk?: boolean(name='worker_data_disk'),
  workerDataDisks?: [ 
    {
      category?: string(name='category'),
      encrypted?: string(name='encrypted'),
      size?: string(name='size'),
    }
  ](name='worker_data_disks'),
  workerInstanceChargeType?: string(name='worker_instance_charge_type'),
  workerInstanceTypes?: [ string ](name='worker_instance_types'),
  workerPeriod?: long(name='worker_period'),
  workerPeriodUnit?: string(name='worker_period_unit'),
  workerSystemDiskCategory?: string(name='worker_system_disk_category'),
  workerSystemDiskSize?: long(name='worker_system_disk_size'),
}

model ScaleClusterResponseBody = {
  clusterId?: string(name='cluster_id'),
  requestId?: string(name='request_id'),
  taskId?: string(name='task_id'),
}

model ScaleClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ScaleClusterResponseBody(name='body'),
}

async function scaleCluster(ClusterId: string, request: ScaleClusterRequest): ScaleClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleClusterWithOptions(ClusterId, request, headers, runtime);
}

async function scaleClusterWithOptions(ClusterId: string, request: ScaleClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleClusterResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.cloudMonitorFlags)) {
    body['cloud_monitor_flags'] = request.cloudMonitorFlags;
  }
  if (!Util.isUnset(request.count)) {
    body['count'] = request.count;
  }
  if (!Util.isUnset(request.cpuPolicy)) {
    body['cpu_policy'] = request.cpuPolicy;
  }
  if (!Util.isUnset(request.disableRollback)) {
    body['disable_rollback'] = request.disableRollback;
  }
  if (!Util.isUnset(request.keyPair)) {
    body['key_pair'] = request.keyPair;
  }
  if (!Util.isUnset(request.loginPassword)) {
    body['login_password'] = request.loginPassword;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.taints)) {
    body['taints'] = request.taints;
  }
  if (!Util.isUnset(request.vswitchIds)) {
    body['vswitch_ids'] = request.vswitchIds;
  }
  if (!Util.isUnset(request.workerAutoRenew)) {
    body['worker_auto_renew'] = request.workerAutoRenew;
  }
  if (!Util.isUnset(request.workerAutoRenewPeriod)) {
    body['worker_auto_renew_period'] = request.workerAutoRenewPeriod;
  }
  if (!Util.isUnset(request.workerDataDisk)) {
    body['worker_data_disk'] = request.workerDataDisk;
  }
  if (!Util.isUnset(request.workerDataDisks)) {
    body['worker_data_disks'] = request.workerDataDisks;
  }
  if (!Util.isUnset(request.workerInstanceChargeType)) {
    body['worker_instance_charge_type'] = request.workerInstanceChargeType;
  }
  if (!Util.isUnset(request.workerInstanceTypes)) {
    body['worker_instance_types'] = request.workerInstanceTypes;
  }
  if (!Util.isUnset(request.workerPeriod)) {
    body['worker_period'] = request.workerPeriod;
  }
  if (!Util.isUnset(request.workerPeriodUnit)) {
    body['worker_period_unit'] = request.workerPeriodUnit;
  }
  if (!Util.isUnset(request.workerSystemDiskCategory)) {
    body['worker_system_disk_category'] = request.workerSystemDiskCategory;
  }
  if (!Util.isUnset(request.workerSystemDiskSize)) {
    body['worker_system_disk_size'] = request.workerSystemDiskSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ScaleCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ScaleClusterNodePoolRequest {
  count?: long(name='count'),
}

model ScaleClusterNodePoolResponseBody = {
  taskId?: string(name='task_id'),
}

model ScaleClusterNodePoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ScaleClusterNodePoolResponseBody(name='body'),
}

async function scaleClusterNodePool(ClusterId: string, NodepoolId: string, request: ScaleClusterNodePoolRequest): ScaleClusterNodePoolResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleClusterNodePoolWithOptions(ClusterId, NodepoolId, request, headers, runtime);
}

async function scaleClusterNodePoolWithOptions(ClusterId: string, NodepoolId: string, request: ScaleClusterNodePoolRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleClusterNodePoolResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  NodepoolId = OpenApiUtil.getEncodeParam(NodepoolId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    body['count'] = request.count;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ScaleClusterNodePool',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/nodepools/${NodepoolId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ScaleOutClusterRequest {
  cloudMonitorFlags?: boolean(name='cloud_monitor_flags'),
  count?: long(name='count'),
  cpuPolicy?: string(name='cpu_policy'),
  imageId?: string(name='image_id'),
  keyPair?: string(name='key_pair'),
  loginPassword?: string(name='login_password'),
  rdsInstances?: [ string ](name='rds_instances'),
  runtime?: Runtime(name='runtime'),
  tags?: [
    Tag
  ](name='tags'),
  taints?: [
    Taint
  ](name='taints'),
  userData?: string(name='user_data'),
  vswitchIds?: [ string ](name='vswitch_ids'),
  workerAutoRenew?: boolean(name='worker_auto_renew'),
  workerAutoRenewPeriod?: long(name='worker_auto_renew_period'),
  workerDataDisks?: [ 
    {
      autoSnapshotPolicyId?: string(name='auto_snapshot_policy_id'),
      category?: string(name='category'),
      encrypted?: string(name='encrypted'),
      size?: string(name='size'),
    }
  ](name='worker_data_disks'),
  workerInstanceChargeType?: string(name='worker_instance_charge_type'),
  workerInstanceTypes?: [ string ](name='worker_instance_types'),
  workerPeriod?: long(name='worker_period'),
  workerPeriodUnit?: string(name='worker_period_unit'),
  workerSystemDiskCategory?: string(name='worker_system_disk_category'),
  workerSystemDiskSize?: long(name='worker_system_disk_size'),
}

model ScaleOutClusterResponseBody = {
  clusterId?: string(name='cluster_id'),
  requestId?: string(name='request_id'),
  taskId?: string(name='task_id'),
}

model ScaleOutClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ScaleOutClusterResponseBody(name='body'),
}

async function scaleOutCluster(ClusterId: string, request: ScaleOutClusterRequest): ScaleOutClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scaleOutClusterWithOptions(ClusterId, request, headers, runtime);
}

async function scaleOutClusterWithOptions(ClusterId: string, request: ScaleOutClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScaleOutClusterResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.cloudMonitorFlags)) {
    body['cloud_monitor_flags'] = request.cloudMonitorFlags;
  }
  if (!Util.isUnset(request.count)) {
    body['count'] = request.count;
  }
  if (!Util.isUnset(request.cpuPolicy)) {
    body['cpu_policy'] = request.cpuPolicy;
  }
  if (!Util.isUnset(request.imageId)) {
    body['image_id'] = request.imageId;
  }
  if (!Util.isUnset(request.keyPair)) {
    body['key_pair'] = request.keyPair;
  }
  if (!Util.isUnset(request.loginPassword)) {
    body['login_password'] = request.loginPassword;
  }
  if (!Util.isUnset(request.rdsInstances)) {
    body['rds_instances'] = request.rdsInstances;
  }
  if (!Util.isUnset(request.runtime)) {
    body['runtime'] = request.runtime;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.taints)) {
    body['taints'] = request.taints;
  }
  if (!Util.isUnset(request.userData)) {
    body['user_data'] = request.userData;
  }
  if (!Util.isUnset(request.vswitchIds)) {
    body['vswitch_ids'] = request.vswitchIds;
  }
  if (!Util.isUnset(request.workerAutoRenew)) {
    body['worker_auto_renew'] = request.workerAutoRenew;
  }
  if (!Util.isUnset(request.workerAutoRenewPeriod)) {
    body['worker_auto_renew_period'] = request.workerAutoRenewPeriod;
  }
  if (!Util.isUnset(request.workerDataDisks)) {
    body['worker_data_disks'] = request.workerDataDisks;
  }
  if (!Util.isUnset(request.workerInstanceChargeType)) {
    body['worker_instance_charge_type'] = request.workerInstanceChargeType;
  }
  if (!Util.isUnset(request.workerInstanceTypes)) {
    body['worker_instance_types'] = request.workerInstanceTypes;
  }
  if (!Util.isUnset(request.workerPeriod)) {
    body['worker_period'] = request.workerPeriod;
  }
  if (!Util.isUnset(request.workerPeriodUnit)) {
    body['worker_period_unit'] = request.workerPeriodUnit;
  }
  if (!Util.isUnset(request.workerSystemDiskCategory)) {
    body['worker_system_disk_category'] = request.workerSystemDiskCategory;
  }
  if (!Util.isUnset(request.workerSystemDiskSize)) {
    body['worker_system_disk_size'] = request.workerSystemDiskSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ScaleOutCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/clusters/${ClusterId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StartWorkflowRequest {
  mappingBamOutFilename?: string(name='mapping_bam_out_filename'),
  mappingBamOutPath?: string(name='mapping_bam_out_path'),
  mappingBucketName?: string(name='mapping_bucket_name'),
  mappingFastqFirstFilename?: string(name='mapping_fastq_first_filename'),
  mappingFastqPath?: string(name='mapping_fastq_path'),
  mappingFastqSecondFilename?: string(name='mapping_fastq_second_filename'),
  mappingIsMarkDup?: string(name='mapping_is_mark_dup'),
  mappingOssRegion?: string(name='mapping_oss_region'),
  mappingReferencePath?: string(name='mapping_reference_path'),
  service?: string(name='service'),
  wgsBucketName?: string(name='wgs_bucket_name'),
  wgsFastqFirstFilename?: string(name='wgs_fastq_first_filename'),
  wgsFastqPath?: string(name='wgs_fastq_path'),
  wgsFastqSecondFilename?: string(name='wgs_fastq_second_filename'),
  wgsOssRegion?: string(name='wgs_oss_region'),
  wgsReferencePath?: string(name='wgs_reference_path'),
  wgsVcfOutFilename?: string(name='wgs_vcf_out_filename'),
  wgsVcfOutPath?: string(name='wgs_vcf_out_path'),
  workflowType?: string(name='workflow_type'),
}

model StartWorkflowResponseBody = {
  jobName?: string(name='JobName'),
}

model StartWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartWorkflowResponseBody(name='body'),
}

async function startWorkflow(request: StartWorkflowRequest): StartWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startWorkflowWithOptions(request, headers, runtime);
}

async function startWorkflowWithOptions(request: StartWorkflowRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StartWorkflowResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.mappingBamOutFilename)) {
    body['mapping_bam_out_filename'] = request.mappingBamOutFilename;
  }
  if (!Util.isUnset(request.mappingBamOutPath)) {
    body['mapping_bam_out_path'] = request.mappingBamOutPath;
  }
  if (!Util.isUnset(request.mappingBucketName)) {
    body['mapping_bucket_name'] = request.mappingBucketName;
  }
  if (!Util.isUnset(request.mappingFastqFirstFilename)) {
    body['mapping_fastq_first_filename'] = request.mappingFastqFirstFilename;
  }
  if (!Util.isUnset(request.mappingFastqPath)) {
    body['mapping_fastq_path'] = request.mappingFastqPath;
  }
  if (!Util.isUnset(request.mappingFastqSecondFilename)) {
    body['mapping_fastq_second_filename'] = request.mappingFastqSecondFilename;
  }
  if (!Util.isUnset(request.mappingIsMarkDup)) {
    body['mapping_is_mark_dup'] = request.mappingIsMarkDup;
  }
  if (!Util.isUnset(request.mappingOssRegion)) {
    body['mapping_oss_region'] = request.mappingOssRegion;
  }
  if (!Util.isUnset(request.mappingReferencePath)) {
    body['mapping_reference_path'] = request.mappingReferencePath;
  }
  if (!Util.isUnset(request.service)) {
    body['service'] = request.service;
  }
  if (!Util.isUnset(request.wgsBucketName)) {
    body['wgs_bucket_name'] = request.wgsBucketName;
  }
  if (!Util.isUnset(request.wgsFastqFirstFilename)) {
    body['wgs_fastq_first_filename'] = request.wgsFastqFirstFilename;
  }
  if (!Util.isUnset(request.wgsFastqPath)) {
    body['wgs_fastq_path'] = request.wgsFastqPath;
  }
  if (!Util.isUnset(request.wgsFastqSecondFilename)) {
    body['wgs_fastq_second_filename'] = request.wgsFastqSecondFilename;
  }
  if (!Util.isUnset(request.wgsOssRegion)) {
    body['wgs_oss_region'] = request.wgsOssRegion;
  }
  if (!Util.isUnset(request.wgsReferencePath)) {
    body['wgs_reference_path'] = request.wgsReferencePath;
  }
  if (!Util.isUnset(request.wgsVcfOutFilename)) {
    body['wgs_vcf_out_filename'] = request.wgsVcfOutFilename;
  }
  if (!Util.isUnset(request.wgsVcfOutPath)) {
    body['wgs_vcf_out_path'] = request.wgsVcfOutPath;
  }
  if (!Util.isUnset(request.workflowType)) {
    body['workflow_type'] = request.workflowType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartWorkflow',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/gs/workflow`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model TagResourcesRequest {
  regionId?: string(name='region_id'),
  resourceIds?: [ string ](name='resource_ids'),
  resourceType?: string(name='resource_type'),
  tags?: [
    Tag
  ](name='tags'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(request, headers, runtime);
}

async function tagResourcesWithOptions(request: TagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    body['region_id'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceIds)) {
    body['resource_ids'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['resource_type'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/tags`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UnInstallClusterAddonsRequest {
  addons?: [ 
    {
      name?: string(name='name'),
    }
  ](name='addons'),
}

model UnInstallClusterAddonsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function unInstallClusterAddons(ClusterId: string, request: UnInstallClusterAddonsRequest): UnInstallClusterAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unInstallClusterAddonsWithOptions(ClusterId, request, headers, runtime);
}

async function unInstallClusterAddonsWithOptions(ClusterId: string, request: UnInstallClusterAddonsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UnInstallClusterAddonsResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.addons),
  };
  var params = new OpenApi.Params{
    action = 'UnInstallClusterAddons',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/components/uninstall`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='all'),
  regionId?: string(name='region_id'),
  resourceIds?: [ string ](name='resource_ids'),
  resourceType?: string(name='resource_type'),
  tagKeys?: [ string ](name='tag_keys'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourcesWithOptions(request, headers, runtime);
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    query['all'] = request.all;
  }
  if (!Util.isUnset(request.regionId)) {
    query['region_id'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['resource_ids'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resource_type'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKeys)) {
    query['tag_keys'] = request.tagKeys;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/tags`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateContactGroupForAlertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateContactGroupForAlert(ClusterId: string): UpdateContactGroupForAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateContactGroupForAlertWithOptions(ClusterId, headers, runtime);
}

async function updateContactGroupForAlertWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateContactGroupForAlertResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UpdateContactGroupForAlert',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/alert/${ClusterId}/alert_rule/contact_groups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UpdateK8sClusterUserConfigExpireRequest {
  expireHour?: long(name='expire_hour'),
  user?: string(name='user'),
}

model UpdateK8sClusterUserConfigExpireResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateK8sClusterUserConfigExpire(ClusterId: string, request: UpdateK8sClusterUserConfigExpireRequest): UpdateK8sClusterUserConfigExpireResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateK8sClusterUserConfigExpireWithOptions(ClusterId, request, headers, runtime);
}

async function updateK8sClusterUserConfigExpireWithOptions(ClusterId: string, request: UpdateK8sClusterUserConfigExpireRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateK8sClusterUserConfigExpireResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.expireHour)) {
    body['expire_hour'] = request.expireHour;
  }
  if (!Util.isUnset(request.user)) {
    body['user'] = request.user;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateK8sClusterUserConfigExpire',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/k8s/${ClusterId}/user_config/expire`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UpdateTemplateRequest {
  description?: string(name='description'),
  name?: string(name='name'),
  tags?: string(name='tags'),
  template?: string(name='template'),
  templateType?: string(name='template_type'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateTemplate(TemplateId: string, request: UpdateTemplateRequest): UpdateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTemplateWithOptions(TemplateId, request, headers, runtime);
}

async function updateTemplateWithOptions(TemplateId: string, request: UpdateTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTemplateResponse {
  Util.validateModel(request);
  TemplateId = OpenApiUtil.getEncodeParam(TemplateId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.template)) {
    body['template'] = request.template;
  }
  if (!Util.isUnset(request.templateType)) {
    body['template_type'] = request.templateType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTemplate',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/templates/${TemplateId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UpgradeClusterRequest {
  componentName?: string(name='component_name'),
  nextVersion?: string(name='next_version'),
  version?: string(name='version'),
}

model UpgradeClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function upgradeCluster(ClusterId: string, request: UpgradeClusterRequest): UpgradeClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return upgradeClusterWithOptions(ClusterId, request, headers, runtime);
}

async function upgradeClusterWithOptions(ClusterId: string, request: UpgradeClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpgradeClusterResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.componentName)) {
    body['component_name'] = request.componentName;
  }
  if (!Util.isUnset(request.nextVersion)) {
    body['next_version'] = request.nextVersion;
  }
  if (!Util.isUnset(request.version)) {
    body['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeCluster',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/api/v2/clusters/${ClusterId}/upgrade`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UpgradeClusterAddonsRequest {
  body?: [ 
    {
      componentName?: string(name='component_name'),
      config?: string(name='config'),
      nextVersion?: string(name='next_version'),
      version?: string(name='version'),
    }
  ](name='body'),
}

model UpgradeClusterAddonsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function upgradeClusterAddons(ClusterId: string, request: UpgradeClusterAddonsRequest): UpgradeClusterAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return upgradeClusterAddonsWithOptions(ClusterId, request, headers, runtime);
}

async function upgradeClusterAddonsWithOptions(ClusterId: string, request: UpgradeClusterAddonsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpgradeClusterAddonsResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeClusterAddons',
    version = '2015-12-15',
    protocol = 'HTTPS',
    pathname = `/clusters/${ClusterId}/components/upgrade`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model StandardComponentsValue = {
  name?: string(name='name'),
  version?: string(name='version'),
  description?: string(name='description'),
  required?: string(name='required'),
  disabled?: boolean(name='disabled'),
}

