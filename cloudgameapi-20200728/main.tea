/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('cloudgameapi', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model BatchDispatchGameSlotRequest {
  queueUserList?: string(name='QueueUserList'),
}

model BatchDispatchGameSlotResponseBody = {
  queueResultList?: [ 
    {
      regionName?: string(name='RegionName'),
      gameSession?: string(name='GameSession'),
      userId?: string(name='UserId'),
      queueState?: int32(name='QueueState'),
      message?: string(name='Message'),
      gameId?: string(name='GameId'),
      queueCode?: int32(name='QueueCode'),
    }
  ](name='QueueResultList'),
  requestId?: string(name='RequestId'),
}

model BatchDispatchGameSlotResponse = {
  headers: map[string]string(name='headers'),
  body: BatchDispatchGameSlotResponseBody(name='body'),
}

async function batchDispatchGameSlotWithOptions(request: BatchDispatchGameSlotRequest, runtime: Util.RuntimeOptions): BatchDispatchGameSlotResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('BatchDispatchGameSlot', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function batchDispatchGameSlot(request: BatchDispatchGameSlotRequest): BatchDispatchGameSlotResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDispatchGameSlotWithOptions(request, runtime);
}

model BatchStopGameSessionsRequest {
  projectId?: string(name='ProjectId'),
  gameId?: string(name='GameId'),
  token?: string(name='Token'),
  reason?: string(name='Reason'),
  trackInfo?: string(name='TrackInfo'),
}

model BatchStopGameSessionsResponseBody = {
  requestId?: string(name='RequestId'),
  queueState?: int32(name='QueueState'),
  message?: string(name='Message'),
  trackInfo?: string(name='TrackInfo'),
  projectId?: string(name='ProjectId'),
  success?: boolean(name='Success'),
  gameId?: string(name='GameId'),
}

model BatchStopGameSessionsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchStopGameSessionsResponseBody(name='body'),
}

async function batchStopGameSessionsWithOptions(request: BatchStopGameSessionsRequest, runtime: Util.RuntimeOptions): BatchStopGameSessionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('BatchStopGameSessions', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function batchStopGameSessions(request: BatchStopGameSessionsRequest): BatchStopGameSessionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchStopGameSessionsWithOptions(request, runtime);
}

model CloseOrderRequest {
  buyerAccountId?: string(name='BuyerAccountId'),
  orderId?: string(name='OrderId'),
  accountDomain?: string(name='AccountDomain'),
}

model CloseOrderResponseBody = {
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
}

model CloseOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CloseOrderResponseBody(name='body'),
}

async function closeOrderWithOptions(request: CloseOrderRequest, runtime: Util.RuntimeOptions): CloseOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CloseOrder', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function closeOrder(request: CloseOrderRequest): CloseOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return closeOrderWithOptions(request, runtime);
}

model CreateOrderRequest {
  buyerAccountId?: string(name='BuyerAccountId'),
  itemId?: string(name='ItemId'),
  skuId?: string(name='SkuId'),
  originPrice?: long(name='OriginPrice'),
  settlementPrice?: long(name='SettlementPrice'),
  amount?: long(name='Amount'),
  idempotentCode?: string(name='IdempotentCode'),
  accountDomain?: string(name='AccountDomain'),
}

model CreateOrderResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    finishTime?: long(name='FinishTime'),
    createTime?: long(name='CreateTime'),
    autoUnlockTime?: long(name='AutoUnlockTime'),
    applyDeliveryTime?: long(name='ApplyDeliveryTime'),
    itemId?: string(name='ItemId'),
    originPrice?: long(name='OriginPrice'),
    buyerAccountId?: string(name='BuyerAccountId'),
    amount?: long(name='Amount'),
    skuId?: string(name='SkuId'),
    settlementPrice?: long(name='SettlementPrice'),
    orderId?: string(name='OrderId'),
    accountDomain?: string(name='AccountDomain'),
  }(name='Data'),
}

model CreateOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOrderResponseBody(name='body'),
}

async function createOrderWithOptions(request: CreateOrderRequest, runtime: Util.RuntimeOptions): CreateOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateOrder', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createOrder(request: CreateOrderRequest): CreateOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrderWithOptions(request, runtime);
}

model CreateTokenRequest {
  session?: string(name='Session'),
  currentToken?: string(name='CurrentToken'),
  clientToken?: string(name='ClientToken'),
}

model CreateTokenResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    token?: string(name='Token'),
  }(name='Data'),
}

model CreateTokenResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTokenResponseBody(name='body'),
}

async function createTokenWithOptions(request: CreateTokenRequest, runtime: Util.RuntimeOptions): CreateTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateToken', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createToken(request: CreateTokenRequest): CreateTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTokenWithOptions(request, runtime);
}

model DeliveryOrderRequest {
  buyerAccountId?: string(name='BuyerAccountId'),
  orderId?: string(name='OrderId'),
  accountDomain?: string(name='AccountDomain'),
}

model DeliveryOrderResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    deliveryStatus?: string(name='DeliveryStatus'),
  }(name='Data'),
}

model DeliveryOrderResponse = {
  headers: map[string]string(name='headers'),
  body: DeliveryOrderResponseBody(name='body'),
}

async function deliveryOrderWithOptions(request: DeliveryOrderRequest, runtime: Util.RuntimeOptions): DeliveryOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeliveryOrder', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deliveryOrder(request: DeliveryOrderRequest): DeliveryOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return deliveryOrderWithOptions(request, runtime);
}

model DispatchGameSlotRequest {
  gameId?: string(name='GameId'),
  accessKey?: string(name='AccessKey'),
  regionName?: string(name='RegionName'),
  userId?: string(name='UserId'),
  bizParam?: string(name='BizParam'),
  cancel?: boolean(name='Cancel'),
  gameSession?: string(name='GameSession'),
  gameStartParam?: string(name='GameStartParam'),
  gameCommand?: string(name='GameCommand'),
  systemInfo?: string(name='SystemInfo'),
  clientIp?: string(name='ClientIp'),
  reconnect?: boolean(name='Reconnect'),
}

model DispatchGameSlotResponseBody = {
  gameSession?: string(name='GameSession'),
  queueCode?: int32(name='QueueCode'),
  requestId?: string(name='RequestId'),
  queueState?: int32(name='QueueState'),
  message?: string(name='Message'),
  regionName?: string(name='RegionName'),
  userId?: string(name='UserId'),
  gameId?: string(name='GameId'),
}

model DispatchGameSlotResponse = {
  headers: map[string]string(name='headers'),
  body: DispatchGameSlotResponseBody(name='body'),
}

async function dispatchGameSlotWithOptions(request: DispatchGameSlotRequest, runtime: Util.RuntimeOptions): DispatchGameSlotResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DispatchGameSlot', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function dispatchGameSlot(request: DispatchGameSlotRequest): DispatchGameSlotResponse {
  var runtime = new Util.RuntimeOptions{};
  return dispatchGameSlotWithOptions(request, runtime);
}

model GetGameCcuRequest {
  gameId?: string(name='GameId'),
  regionName?: string(name='RegionName'),
  accessKey?: string(name='AccessKey'),
}

model GetGameCcuResponseBody = {
  dataList?: [ 
    {
      gameId?: string(name='GameId'),
      ccu?: long(name='Ccu'),
      regionId?: string(name='RegionId'),
    }
  ](name='DataList'),
  requestId?: string(name='RequestId'),
}

model GetGameCcuResponse = {
  headers: map[string]string(name='headers'),
  body: GetGameCcuResponseBody(name='body'),
}

async function getGameCcuWithOptions(request: GetGameCcuRequest, runtime: Util.RuntimeOptions): GetGameCcuResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetGameCcu', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getGameCcu(request: GetGameCcuRequest): GetGameCcuResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGameCcuWithOptions(request, runtime);
}

model GetItemRequest {
  itemId?: string(name='ItemId'),
}

model GetItemResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    status?: int32(name='Status'),
    createTime?: long(name='CreateTime'),
    games?: [ 
      {
        gameId?: string(name='GameId'),
        name?: string(name='Name'),
      }
    ](name='Games'),
    sellerId?: string(name='SellerId'),
    itemId?: string(name='ItemId'),
    salePrice?: long(name='SalePrice'),
    originPrice?: long(name='OriginPrice'),
    supplier?: string(name='Supplier'),
    description?: string(name='Description'),
    categoryId?: long(name='CategoryId'),
    skus?: [ 
      {
        status?: int32(name='Status'),
        createTime?: long(name='CreateTime'),
        skuId?: string(name='SkuId'),
        saleProps?: [ 
          {
            value?: string(name='Value'),
            valueId?: long(name='ValueId'),
            propertyId?: long(name='PropertyId'),
            propertyName?: string(name='PropertyName'),
          }
        ](name='SaleProps'),
        itemId?: string(name='ItemId'),
        salePrice?: long(name='SalePrice'),
        originPrice?: long(name='OriginPrice'),
        modifyTime?: long(name='ModifyTime'),
      }
    ](name='Skus'),
    title?: string(name='Title'),
    modifyTime?: long(name='ModifyTime'),
  }(name='Data'),
}

model GetItemResponse = {
  headers: map[string]string(name='headers'),
  body: GetItemResponseBody(name='body'),
}

async function getItemWithOptions(request: GetItemRequest, runtime: Util.RuntimeOptions): GetItemResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetItem', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getItem(request: GetItemRequest): GetItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return getItemWithOptions(request, runtime);
}

model GetOutAccountBindDetailRequest {
  outAccountType?: string(name='OutAccountType'),
  accountId?: string(name='AccountId'),
  accountDomain?: string(name='AccountDomain'),
}

model GetOutAccountBindDetailResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    outAccountId?: string(name='OutAccountId'),
    token?: string(name='Token'),
    bindStatus?: int32(name='BindStatus'),
    outAccountType?: string(name='OutAccountType'),
    tokenExpireTime?: long(name='TokenExpireTime'),
  }(name='Data'),
}

model GetOutAccountBindDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetOutAccountBindDetailResponseBody(name='body'),
}

async function getOutAccountBindDetailWithOptions(request: GetOutAccountBindDetailRequest, runtime: Util.RuntimeOptions): GetOutAccountBindDetailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetOutAccountBindDetail', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getOutAccountBindDetail(request: GetOutAccountBindDetailRequest): GetOutAccountBindDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOutAccountBindDetailWithOptions(request, runtime);
}

model GetSessionRequest {
  token?: string(name='Token'),
}

model GetSessionResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    session?: string(name='Session'),
  }(name='Data'),
}

model GetSessionResponse = {
  headers: map[string]string(name='headers'),
  body: GetSessionResponseBody(name='body'),
}

async function getSessionWithOptions(request: GetSessionRequest, runtime: Util.RuntimeOptions): GetSessionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetSession', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getSession(request: GetSessionRequest): GetSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSessionWithOptions(request, runtime);
}

model GetStopGameTokenRequest {
  gameId?: string(name='GameId'),
  accessKey?: string(name='AccessKey'),
}

model GetStopGameTokenResponseBody = {
  requestId?: string(name='RequestId'),
  token?: string(name='Token'),
  expireTime?: long(name='ExpireTime'),
}

model GetStopGameTokenResponse = {
  headers: map[string]string(name='headers'),
  body: GetStopGameTokenResponseBody(name='body'),
}

async function getStopGameTokenWithOptions(request: GetStopGameTokenRequest, runtime: Util.RuntimeOptions): GetStopGameTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetStopGameToken', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getStopGameToken(request: GetStopGameTokenRequest): GetStopGameTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStopGameTokenWithOptions(request, runtime);
}

model ListBoughtGamesRequest {
  accountId?: string(name='AccountId'),
  accountDomain?: string(name='AccountDomain'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListBoughtGamesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  items?: [ 
    {
      endTime?: long(name='EndTime'),
      startTime?: long(name='StartTime'),
      gameId?: string(name='GameId'),
      gameName?: string(name='GameName'),
    }
  ](name='Items'),
}

model ListBoughtGamesResponse = {
  headers: map[string]string(name='headers'),
  body: ListBoughtGamesResponseBody(name='body'),
}

async function listBoughtGamesWithOptions(request: ListBoughtGamesRequest, runtime: Util.RuntimeOptions): ListBoughtGamesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListBoughtGames', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listBoughtGames(request: ListBoughtGamesRequest): ListBoughtGamesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBoughtGamesWithOptions(request, runtime);
}

model QueryGameRequest {
  projectId?: long(name='ProjectId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  tenantId?: long(name='TenantId'),
}

model QueryGameResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: [ 
    {
      version?: string(name='Version'),
      projectId?: long(name='ProjectId'),
      gmtCreate?: string(name='GmtCreate'),
      gameId?: long(name='GameId'),
      name?: string(name='Name'),
      tenantId?: long(name='TenantId'),
    }
  ](name='Data'),
}

model QueryGameResponse = {
  headers: map[string]string(name='headers'),
  body: QueryGameResponseBody(name='body'),
}

async function queryGameWithOptions(request: QueryGameRequest, runtime: Util.RuntimeOptions): QueryGameResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryGame', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryGame(request: QueryGameRequest): QueryGameResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGameWithOptions(request, runtime);
}

model QueryItemsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model QueryItemsResponseBody = {
  requestId?: string(name='RequestId'),
  httpStatusCode?: long(name='HttpStatusCode'),
  data?: {
    items?: [ 
      {
        status?: int32(name='Status'),
        createTime?: long(name='CreateTime'),
        games?: [ 
          {
            gameId?: string(name='GameId'),
            name?: string(name='Name'),
          }
        ](name='Games'),
        sellerId?: string(name='SellerId'),
        itemId?: string(name='ItemId'),
        salePrice?: long(name='SalePrice'),
        originPrice?: long(name='OriginPrice'),
        supplier?: string(name='Supplier'),
        description?: string(name='Description'),
        categoryId?: long(name='CategoryId'),
        skus?: [ 
          {
            status?: int32(name='Status'),
            createTime?: long(name='CreateTime'),
            skuId?: string(name='SkuId'),
            saleProps?: [ 
              {
                value?: string(name='Value'),
                valueId?: long(name='ValueId'),
                propertyName?: string(name='PropertyName'),
                propertyId?: long(name='PropertyId'),
              }
            ](name='SaleProps'),
            itemId?: string(name='ItemId'),
            salePrice?: long(name='SalePrice'),
            originPrice?: long(name='OriginPrice'),
            modifyTime?: long(name='ModifyTime'),
          }
        ](name='Skus'),
        title?: string(name='Title'),
        modifyTime?: long(name='ModifyTime'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  success?: boolean(name='Success'),
}

model QueryItemsResponse = {
  headers: map[string]string(name='headers'),
  body: QueryItemsResponseBody(name='body'),
}

async function queryItemsWithOptions(request: QueryItemsRequest, runtime: Util.RuntimeOptions): QueryItemsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryItems', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryItems(request: QueryItemsRequest): QueryItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryItemsWithOptions(request, runtime);
}

model QueryOrderRequest {
  buyerAccountId?: string(name='BuyerAccountId'),
  orderId?: string(name='OrderId'),
  accountDomain?: string(name='AccountDomain'),
}

model QueryOrderResponseBody = {
  requestId?: string(name='RequestId'),
  refundStatus?: string(name='RefundStatus'),
  deliveryStatus?: string(name='DeliveryStatus'),
  data?: {
    status?: string(name='Status'),
    finishTime?: long(name='FinishTime'),
    createTime?: long(name='CreateTime'),
    autoUnlockTime?: long(name='AutoUnlockTime'),
    applyDeliveryTime?: long(name='ApplyDeliveryTime'),
    itemId?: string(name='ItemId'),
    originPrice?: long(name='OriginPrice'),
    buyerAccountId?: string(name='BuyerAccountId'),
    amount?: long(name='Amount'),
    skuId?: string(name='SkuId'),
    settlementPrice?: long(name='SettlementPrice'),
    orderId?: string(name='OrderId'),
    accountDomain?: string(name='AccountDomain'),
  }(name='Data'),
}

model QueryOrderResponse = {
  headers: map[string]string(name='headers'),
  body: QueryOrderResponseBody(name='body'),
}

async function queryOrderWithOptions(request: QueryOrderRequest, runtime: Util.RuntimeOptions): QueryOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryOrder', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryOrder(request: QueryOrderRequest): QueryOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOrderWithOptions(request, runtime);
}

model QueryOutAccountBindStatusRequest {
  accountId?: string(name='AccountId'),
  gameId?: string(name='GameId'),
  accountDomain?: string(name='AccountDomain'),
}

model QueryOutAccountBindStatusResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    bindStatus?: int32(name='BindStatus'),
  }(name='Data'),
}

model QueryOutAccountBindStatusResponse = {
  headers: map[string]string(name='headers'),
  body: QueryOutAccountBindStatusResponseBody(name='body'),
}

async function queryOutAccountBindStatusWithOptions(request: QueryOutAccountBindStatusRequest, runtime: Util.RuntimeOptions): QueryOutAccountBindStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryOutAccountBindStatus', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryOutAccountBindStatus(request: QueryOutAccountBindStatusRequest): QueryOutAccountBindStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOutAccountBindStatusWithOptions(request, runtime);
}

model QueryProjectRequest {
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId'),
  tenantId?: long(name='TenantId'),
}

model QueryProjectResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: [ 
    {
      name?: string(name='Name'),
      id?: long(name='Id'),
      tenantId?: long(name='TenantId'),
    }
  ](name='Data'),
}

model QueryProjectResponse = {
  headers: map[string]string(name='headers'),
  body: QueryProjectResponseBody(name='body'),
}

async function queryProjectWithOptions(request: QueryProjectRequest, runtime: Util.RuntimeOptions): QueryProjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryProject', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryProject(request: QueryProjectRequest): QueryProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryProjectWithOptions(request, runtime);
}

model QueryTenantRequest {
  param?: string(name='Param'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
}

model QueryTenantResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: [ 
    {
      gmtCreate?: string(name='GmtCreate'),
      name?: string(name='Name'),
      tenantId?: long(name='TenantId'),
    }
  ](name='Data'),
}

model QueryTenantResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTenantResponseBody(name='body'),
}

async function queryTenantWithOptions(request: QueryTenantRequest, runtime: Util.RuntimeOptions): QueryTenantResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTenant', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTenant(request: QueryTenantRequest): QueryTenantResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTenantWithOptions(request, runtime);
}

model SkipTrialPolicyRequest {
  gameSessionId?: string(name='GameSessionId'),
}

model SkipTrialPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    skipResult?: int32(name='SkipResult'),
  }(name='Data'),
}

model SkipTrialPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: SkipTrialPolicyResponseBody(name='body'),
}

async function skipTrialPolicyWithOptions(request: SkipTrialPolicyRequest, runtime: Util.RuntimeOptions): SkipTrialPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SkipTrialPolicy', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function skipTrialPolicy(request: SkipTrialPolicyRequest): SkipTrialPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return skipTrialPolicyWithOptions(request, runtime);
}

model StopGameSessionRequest {
  gameId?: string(name='GameId'),
  accessKey?: string(name='AccessKey'),
  userId?: string(name='UserId'),
  bizParam?: string(name='BizParam'),
  gameSession?: string(name='GameSession'),
  reason?: string(name='Reason'),
}

model StopGameSessionResponseBody = {
  gameSession?: string(name='GameSession'),
  queueCode?: int32(name='QueueCode'),
  requestId?: string(name='RequestId'),
  queueState?: int32(name='QueueState'),
  message?: string(name='Message'),
  success?: boolean(name='Success'),
  gameId?: string(name='GameId'),
}

model StopGameSessionResponse = {
  headers: map[string]string(name='headers'),
  body: StopGameSessionResponseBody(name='body'),
}

async function stopGameSessionWithOptions(request: StopGameSessionRequest, runtime: Util.RuntimeOptions): StopGameSessionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('StopGameSession', '2020-07-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function stopGameSession(request: StopGameSessionRequest): StopGameSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopGameSessionWithOptions(request, runtime);
}

