/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('cloudgameapi', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AdaptGameVersionRequest {
  frameRate?: string(name='FrameRate', description='帧率'),
  resolution?: string(name='Resolution', description='分辨率'),
  versionId?: string(name='VersionId', description='游戏版本ID'),
}

model AdaptGameVersionResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  taskId?: string(name='TaskId', description='Id of the task'),
}

model AdaptGameVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AdaptGameVersionResponseBody(name='body'),
}

async function adaptGameVersionWithOptions(request: AdaptGameVersionRequest, runtime: Util.RuntimeOptions): AdaptGameVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.frameRate)) {
    query['FrameRate'] = request.frameRate;
  }
  if (!Util.isUnset(request.resolution)) {
    query['Resolution'] = request.resolution;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AdaptGameVersion',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function adaptGameVersion(request: AdaptGameVersionRequest): AdaptGameVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return adaptGameVersionWithOptions(request, runtime);
}

model AddGameToProjectRequest {
  gameId?: string(name='GameId', description='游戏iD'),
  projectId?: string(name='ProjectId', description='项目ID'),
}

model AddGameToProjectResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AddGameToProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGameToProjectResponseBody(name='body'),
}

async function addGameToProjectWithOptions(request: AddGameToProjectRequest, runtime: Util.RuntimeOptions): AddGameToProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.gameId)) {
    query['GameId'] = request.gameId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGameToProject',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGameToProject(request: AddGameToProjectRequest): AddGameToProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGameToProjectWithOptions(request, runtime);
}

model BatchDispatchGameSlotRequest {
  queueUserList?: string(name='QueueUserList'),
}

model BatchDispatchGameSlotResponseBody = {
  queueResultList?: [ 
    {
      gameId?: string(name='GameId'),
      gameSession?: string(name='GameSession'),
      message?: string(name='Message'),
      queueCode?: int32(name='QueueCode'),
      queueState?: int32(name='QueueState'),
      regionName?: string(name='RegionName'),
      userId?: string(name='UserId'),
    }
  ](name='QueueResultList'),
  requestId?: string(name='RequestId'),
}

model BatchDispatchGameSlotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchDispatchGameSlotResponseBody(name='body'),
}

async function batchDispatchGameSlotWithOptions(request: BatchDispatchGameSlotRequest, runtime: Util.RuntimeOptions): BatchDispatchGameSlotResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.queueUserList)) {
    body['QueueUserList'] = request.queueUserList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDispatchGameSlot',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchDispatchGameSlot(request: BatchDispatchGameSlotRequest): BatchDispatchGameSlotResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDispatchGameSlotWithOptions(request, runtime);
}

model BatchStopGameSessionsRequest {
  gameId?: string(name='GameId'),
  projectId?: string(name='ProjectId'),
  reason?: string(name='Reason'),
  tags?: string(name='Tags'),
  token?: string(name='Token'),
  trackInfo?: string(name='TrackInfo'),
}

model BatchStopGameSessionsResponseBody = {
  gameId?: string(name='GameId'),
  message?: string(name='Message'),
  projectId?: string(name='ProjectId'),
  queueState?: int32(name='QueueState'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  trackInfo?: string(name='TrackInfo'),
}

model BatchStopGameSessionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchStopGameSessionsResponseBody(name='body'),
}

async function batchStopGameSessionsWithOptions(request: BatchStopGameSessionsRequest, runtime: Util.RuntimeOptions): BatchStopGameSessionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.gameId)) {
    query['GameId'] = request.gameId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  if (!Util.isUnset(request.trackInfo)) {
    query['TrackInfo'] = request.trackInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchStopGameSessions',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchStopGameSessions(request: BatchStopGameSessionsRequest): BatchStopGameSessionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchStopGameSessionsWithOptions(request, runtime);
}

model CancelGameHangRequest {
  accessKey?: string(name='AccessKey'),
  gameSession?: string(name='GameSession'),
}

model CancelGameHangResponseBody = {
  code?: string(name='Code'),
  gameSession?: string(name='GameSession'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model CancelGameHangResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelGameHangResponseBody(name='body'),
}

async function cancelGameHangWithOptions(request: CancelGameHangRequest, runtime: Util.RuntimeOptions): CancelGameHangResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.accessKey)) {
    body['AccessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.gameSession)) {
    body['GameSession'] = request.gameSession;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CancelGameHang',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelGameHang(request: CancelGameHangRequest): CancelGameHangResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelGameHangWithOptions(request, runtime);
}

model CloseOrderRequest {
  accountDomain?: string(name='AccountDomain'),
  buyerAccountId?: string(name='BuyerAccountId'),
  orderId?: string(name='OrderId'),
}

model CloseOrderResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model CloseOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloseOrderResponseBody(name='body'),
}

async function closeOrderWithOptions(request: CloseOrderRequest, runtime: Util.RuntimeOptions): CloseOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDomain)) {
    query['AccountDomain'] = request.accountDomain;
  }
  if (!Util.isUnset(request.buyerAccountId)) {
    query['BuyerAccountId'] = request.buyerAccountId;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloseOrder',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function closeOrder(request: CloseOrderRequest): CloseOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return closeOrderWithOptions(request, runtime);
}

model CreateGameRequest {
  clientToken?: string(name='ClientToken', description='幂等参数，1-64位建议使用uuid'),
  gameName?: string(name='GameName', description='游戏名称'),
  platformType?: long(name='PlatformType', description='平台类型'),
}

model CreateGameResponseBody = {
  gameId?: string(name='GameId', description='游戏ID'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model CreateGameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGameResponseBody(name='body'),
}

async function createGameWithOptions(request: CreateGameRequest, runtime: Util.RuntimeOptions): CreateGameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.gameName)) {
    query['GameName'] = request.gameName;
  }
  if (!Util.isUnset(request.platformType)) {
    query['PlatformType'] = request.platformType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGame',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGame(request: CreateGameRequest): CreateGameResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGameWithOptions(request, runtime);
}

model CreateGameDeployWorkflowRequest {
  downloadType?: string(name='DownloadType'),
  fileType?: string(name='FileType'),
  frameRate?: string(name='FrameRate'),
  gameId?: string(name='GameId'),
  gameVersion?: string(name='GameVersion'),
  hash?: string(name='Hash'),
  instance?: string(name='Instance'),
  projectId?: string(name='ProjectId'),
  resolution?: string(name='Resolution'),
  versionName?: string(name='VersionName'),
}

model CreateGameDeployWorkflowResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  taskId?: string(name='TaskId', description='任务id'),
}

model CreateGameDeployWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGameDeployWorkflowResponseBody(name='body'),
}

async function createGameDeployWorkflowWithOptions(request: CreateGameDeployWorkflowRequest, runtime: Util.RuntimeOptions): CreateGameDeployWorkflowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.downloadType)) {
    query['DownloadType'] = request.downloadType;
  }
  if (!Util.isUnset(request.fileType)) {
    query['FileType'] = request.fileType;
  }
  if (!Util.isUnset(request.frameRate)) {
    query['FrameRate'] = request.frameRate;
  }
  if (!Util.isUnset(request.gameId)) {
    query['GameId'] = request.gameId;
  }
  if (!Util.isUnset(request.gameVersion)) {
    query['GameVersion'] = request.gameVersion;
  }
  if (!Util.isUnset(request.hash)) {
    query['Hash'] = request.hash;
  }
  if (!Util.isUnset(request.instance)) {
    query['Instance'] = request.instance;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.resolution)) {
    query['Resolution'] = request.resolution;
  }
  if (!Util.isUnset(request.versionName)) {
    query['VersionName'] = request.versionName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGameDeployWorkflow',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGameDeployWorkflow(request: CreateGameDeployWorkflowRequest): CreateGameDeployWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGameDeployWorkflowWithOptions(request, runtime);
}

model CreateOrderRequest {
  accountDomain?: string(name='AccountDomain'),
  amount?: long(name='Amount'),
  buyerAccountId?: string(name='BuyerAccountId'),
  idempotentCode?: string(name='IdempotentCode'),
  itemId?: string(name='ItemId'),
  originPrice?: long(name='OriginPrice'),
  settlementPrice?: long(name='SettlementPrice'),
  skuId?: string(name='SkuId'),
}

model CreateOrderResponseBody = {
  data?: {
    accountDomain?: string(name='AccountDomain'),
    amount?: long(name='Amount'),
    applyDeliveryTime?: long(name='ApplyDeliveryTime'),
    autoUnlockTime?: long(name='AutoUnlockTime'),
    buyerAccountId?: string(name='BuyerAccountId'),
    createTime?: long(name='CreateTime'),
    finishTime?: long(name='FinishTime'),
    itemId?: string(name='ItemId'),
    orderId?: string(name='OrderId'),
    originPrice?: long(name='OriginPrice'),
    settlementPrice?: long(name='SettlementPrice'),
    skuId?: string(name='SkuId'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrderResponseBody(name='body'),
}

async function createOrderWithOptions(request: CreateOrderRequest, runtime: Util.RuntimeOptions): CreateOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDomain)) {
    query['AccountDomain'] = request.accountDomain;
  }
  if (!Util.isUnset(request.amount)) {
    query['Amount'] = request.amount;
  }
  if (!Util.isUnset(request.buyerAccountId)) {
    query['BuyerAccountId'] = request.buyerAccountId;
  }
  if (!Util.isUnset(request.idempotentCode)) {
    query['IdempotentCode'] = request.idempotentCode;
  }
  if (!Util.isUnset(request.itemId)) {
    query['ItemId'] = request.itemId;
  }
  if (!Util.isUnset(request.originPrice)) {
    query['OriginPrice'] = request.originPrice;
  }
  if (!Util.isUnset(request.settlementPrice)) {
    query['SettlementPrice'] = request.settlementPrice;
  }
  if (!Util.isUnset(request.skuId)) {
    query['SkuId'] = request.skuId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrder',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrder(request: CreateOrderRequest): CreateOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrderWithOptions(request, runtime);
}

model CreateProjectRequest {
  clientToken?: string(name='ClientToken', description='幂等参数，1-64位建议使用uuid'),
  projectName?: string(name='ProjectName', description='项目名称'),
}

model CreateProjectResponseBody = {
  projectId?: string(name='ProjectId', description='项目ID'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProjectResponseBody(name='body'),
}

async function createProjectWithOptions(request: CreateProjectRequest, runtime: Util.RuntimeOptions): CreateProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateProject',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProjectWithOptions(request, runtime);
}

model CreateTokenRequest {
  clientToken?: string(name='ClientToken'),
  currentToken?: string(name='CurrentToken'),
  session?: string(name='Session'),
}

model CreateTokenResponseBody = {
  data?: {
    token?: string(name='Token'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTokenResponseBody(name='body'),
}

async function createTokenWithOptions(request: CreateTokenRequest, runtime: Util.RuntimeOptions): CreateTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.currentToken)) {
    query['CurrentToken'] = request.currentToken;
  }
  if (!Util.isUnset(request.session)) {
    query['Session'] = request.session;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateToken',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createToken(request: CreateTokenRequest): CreateTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTokenWithOptions(request, runtime);
}

model DeleteGameRequest {
  gameId?: string(name='GameId', description='游戏ID'),
}

model DeleteGameResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteGameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGameResponseBody(name='body'),
}

async function deleteGameWithOptions(request: DeleteGameRequest, runtime: Util.RuntimeOptions): DeleteGameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.gameId)) {
    query['GameId'] = request.gameId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGame',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGame(request: DeleteGameRequest): DeleteGameResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGameWithOptions(request, runtime);
}

model DeleteGameVersionRequest {
  versionId?: string(name='VersionId', description='游戏版本ID'),
}

model DeleteGameVersionResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteGameVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGameVersionResponseBody(name='body'),
}

async function deleteGameVersionWithOptions(request: DeleteGameVersionRequest, runtime: Util.RuntimeOptions): DeleteGameVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGameVersion',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGameVersion(request: DeleteGameVersionRequest): DeleteGameVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGameVersionWithOptions(request, runtime);
}

model DeleteProjectRequest {
  projectId?: string(name='ProjectId', description='项目ID'),
}

model DeleteProjectResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProjectResponseBody(name='body'),
}

async function deleteProjectWithOptions(request: DeleteProjectRequest, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProject',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProject(request: DeleteProjectRequest): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProjectWithOptions(request, runtime);
}

model DeliveryOrderRequest {
  accountDomain?: string(name='AccountDomain'),
  buyerAccountId?: string(name='BuyerAccountId'),
  orderId?: string(name='OrderId'),
}

model DeliveryOrderResponseBody = {
  data?: {
    deliveryStatus?: string(name='DeliveryStatus'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeliveryOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeliveryOrderResponseBody(name='body'),
}

async function deliveryOrderWithOptions(request: DeliveryOrderRequest, runtime: Util.RuntimeOptions): DeliveryOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDomain)) {
    query['AccountDomain'] = request.accountDomain;
  }
  if (!Util.isUnset(request.buyerAccountId)) {
    query['BuyerAccountId'] = request.buyerAccountId;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeliveryOrder',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deliveryOrder(request: DeliveryOrderRequest): DeliveryOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return deliveryOrderWithOptions(request, runtime);
}

model DispatchGameSlotRequest {
  accessKey?: string(name='AccessKey'),
  bizParam?: string(name='BizParam'),
  cancel?: boolean(name='Cancel'),
  clientIp?: string(name='ClientIp'),
  gameCommand?: string(name='GameCommand'),
  gameId?: string(name='GameId'),
  gameSession?: string(name='GameSession'),
  gameStartParam?: string(name='GameStartParam'),
  reconnect?: boolean(name='Reconnect'),
  regionName?: string(name='RegionName'),
  systemInfo?: string(name='SystemInfo'),
  tags?: string(name='Tags'),
  userId?: string(name='UserId'),
  userLevel?: int32(name='UserLevel'),
}

model DispatchGameSlotResponseBody = {
  gameId?: string(name='GameId'),
  gameSession?: string(name='GameSession'),
  message?: string(name='Message'),
  queueCode?: int32(name='QueueCode'),
  queueState?: int32(name='QueueState'),
  regionName?: string(name='RegionName'),
  requestId?: string(name='RequestId'),
  userId?: string(name='UserId'),
}

model DispatchGameSlotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DispatchGameSlotResponseBody(name='body'),
}

async function dispatchGameSlotWithOptions(request: DispatchGameSlotRequest, runtime: Util.RuntimeOptions): DispatchGameSlotResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.accessKey)) {
    body['AccessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.bizParam)) {
    body['BizParam'] = request.bizParam;
  }
  if (!Util.isUnset(request.cancel)) {
    body['Cancel'] = request.cancel;
  }
  if (!Util.isUnset(request.clientIp)) {
    body['ClientIp'] = request.clientIp;
  }
  if (!Util.isUnset(request.gameCommand)) {
    body['GameCommand'] = request.gameCommand;
  }
  if (!Util.isUnset(request.gameId)) {
    body['GameId'] = request.gameId;
  }
  if (!Util.isUnset(request.gameSession)) {
    body['GameSession'] = request.gameSession;
  }
  if (!Util.isUnset(request.gameStartParam)) {
    body['GameStartParam'] = request.gameStartParam;
  }
  if (!Util.isUnset(request.reconnect)) {
    body['Reconnect'] = request.reconnect;
  }
  if (!Util.isUnset(request.regionName)) {
    body['RegionName'] = request.regionName;
  }
  if (!Util.isUnset(request.systemInfo)) {
    body['SystemInfo'] = request.systemInfo;
  }
  if (!Util.isUnset(request.tags)) {
    body['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userLevel)) {
    body['UserLevel'] = request.userLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DispatchGameSlot',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function dispatchGameSlot(request: DispatchGameSlotRequest): DispatchGameSlotResponse {
  var runtime = new Util.RuntimeOptions{};
  return dispatchGameSlotWithOptions(request, runtime);
}

model GetGameCcuRequest {
  accessKey?: string(name='AccessKey'),
  gameId?: string(name='GameId'),
  regionName?: string(name='RegionName'),
}

model GetGameCcuResponseBody = {
  dataList?: [ 
    {
      ccu?: long(name='Ccu'),
      gameId?: string(name='GameId'),
      regionId?: string(name='RegionId'),
    }
  ](name='DataList'),
  requestId?: string(name='RequestId'),
}

model GetGameCcuResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGameCcuResponseBody(name='body'),
}

async function getGameCcuWithOptions(request: GetGameCcuRequest, runtime: Util.RuntimeOptions): GetGameCcuResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessKey)) {
    query['AccessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.gameId)) {
    query['GameId'] = request.gameId;
  }
  if (!Util.isUnset(request.regionName)) {
    query['RegionName'] = request.regionName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGameCcu',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGameCcu(request: GetGameCcuRequest): GetGameCcuResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGameCcuWithOptions(request, runtime);
}

model GetGameStatusRequest {
  gameSession?: string(name='GameSession'),
}

model GetGameStatusResponseBody = {
  data?: {
    gameId?: string(name='GameId'),
    gameSession?: string(name='GameSession'),
    gameStartAt?: long(name='GameStartAt'),
    playingCount?: int32(name='PlayingCount'),
    playingUsers?: [ 
      {
        accountId?: string(name='AccountId'),
        startPlayTime?: long(name='StartPlayTime'),
      }
    ](name='PlayingUsers'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetGameStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGameStatusResponseBody(name='body'),
}

async function getGameStatusWithOptions(request: GetGameStatusRequest, runtime: Util.RuntimeOptions): GetGameStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.gameSession)) {
    query['GameSession'] = request.gameSession;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGameStatus',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGameStatus(request: GetGameStatusRequest): GetGameStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGameStatusWithOptions(request, runtime);
}

model GetGameStockRequest {
  accessKey?: string(name='AccessKey'),
  gameId?: string(name='GameId'),
}

model GetGameStockResponseBody = {
  availableTotal?: long(name='AvailableTotal'),
  gameId?: string(name='GameId'),
  instanceStockList?: [ 
    {
      availableSlots?: long(name='AvailableSlots'),
      instanceId?: string(name='InstanceId'),
      quotaSlots?: long(name='QuotaSlots'),
      reginName?: string(name='ReginName'),
      usedSlots?: long(name='UsedSlots'),
      userLevel?: long(name='UserLevel'),
    }
  ](name='InstanceStockList'),
  message?: string(name='Message'),
  quotaTotal?: long(name='QuotaTotal'),
  requestId?: string(name='RequestId'),
  usedTotal?: long(name='UsedTotal'),
}

model GetGameStockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGameStockResponseBody(name='body'),
}

async function getGameStockWithOptions(request: GetGameStockRequest, runtime: Util.RuntimeOptions): GetGameStockResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessKey)) {
    query['AccessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.gameId)) {
    query['GameId'] = request.gameId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGameStock',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGameStock(request: GetGameStockRequest): GetGameStockResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGameStockWithOptions(request, runtime);
}

model GetGameTrialSurplusDurationRequest {
  accountId?: string(name='AccountId', description='账号ID'),
  gameId?: string(name='GameId', description='游戏ID'),
  projectId?: string(name='ProjectId', description='项目ID'),
}

model GetGameTrialSurplusDurationResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  status?: float(name='Status', description='状态'),
  surplusDuration?: double(name='SurplusDuration', description='剩余试玩时长'),
}

model GetGameTrialSurplusDurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGameTrialSurplusDurationResponseBody(name='body'),
}

async function getGameTrialSurplusDurationWithOptions(request: GetGameTrialSurplusDurationRequest, runtime: Util.RuntimeOptions): GetGameTrialSurplusDurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountId)) {
    query['AccountId'] = request.accountId;
  }
  if (!Util.isUnset(request.gameId)) {
    query['GameId'] = request.gameId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGameTrialSurplusDuration',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGameTrialSurplusDuration(request: GetGameTrialSurplusDurationRequest): GetGameTrialSurplusDurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGameTrialSurplusDurationWithOptions(request, runtime);
}

model GetGameVersionRequest {
  versionId?: string(name='VersionId', description='版本ID'),
}

model GetGameVersionResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  versionId?: string(name='VersionId', description='版本ID'),
  versionName?: string(name='VersionName', description='版本名称'),
  versionNumber?: string(name='VersionNumber', description='版本号'),
}

model GetGameVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGameVersionResponseBody(name='body'),
}

async function getGameVersionWithOptions(request: GetGameVersionRequest, runtime: Util.RuntimeOptions): GetGameVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGameVersion',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGameVersion(request: GetGameVersionRequest): GetGameVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGameVersionWithOptions(request, runtime);
}

model GetGameVersionProgressRequest {
  taskId?: string(name='TaskId', description='任务id'),
}

model GetGameVersionProgressResponseBody = {
  description?: string(name='Description'),
  event?: string(name='Event'),
  extra?: map[string]any(name='Extra'),
  requestId?: string(name='RequestId', description='Id of the request'),
  status?: string(name='Status'),
}

model GetGameVersionProgressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGameVersionProgressResponseBody(name='body'),
}

async function getGameVersionProgressWithOptions(request: GetGameVersionProgressRequest, runtime: Util.RuntimeOptions): GetGameVersionProgressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGameVersionProgress',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGameVersionProgress(request: GetGameVersionProgressRequest): GetGameVersionProgressResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGameVersionProgressWithOptions(request, runtime);
}

model GetItemRequest {
  itemId?: string(name='ItemId'),
}

model GetItemResponseBody = {
  data?: {
    categoryId?: long(name='CategoryId'),
    createTime?: long(name='CreateTime'),
    description?: string(name='Description'),
    games?: [ 
      {
        gameId?: string(name='GameId'),
        name?: string(name='Name'),
      }
    ](name='Games'),
    itemId?: string(name='ItemId'),
    modifyTime?: long(name='ModifyTime'),
    originPrice?: long(name='OriginPrice'),
    salePrice?: long(name='SalePrice'),
    sellerId?: string(name='SellerId'),
    skus?: [ 
      {
        createTime?: long(name='CreateTime'),
        itemId?: string(name='ItemId'),
        modifyTime?: long(name='ModifyTime'),
        originPrice?: long(name='OriginPrice'),
        salePrice?: long(name='SalePrice'),
        saleProps?: [ 
          {
            propertyId?: long(name='PropertyId'),
            propertyName?: string(name='PropertyName'),
            value?: string(name='Value'),
            valueId?: long(name='ValueId'),
          }
        ](name='SaleProps'),
        skuId?: string(name='SkuId'),
        status?: int32(name='Status'),
      }
    ](name='Skus'),
    status?: int32(name='Status'),
    supplier?: string(name='Supplier'),
    title?: string(name='Title'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetItemResponseBody(name='body'),
}

async function getItemWithOptions(request: GetItemRequest, runtime: Util.RuntimeOptions): GetItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.itemId)) {
    query['ItemId'] = request.itemId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetItem',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getItem(request: GetItemRequest): GetItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return getItemWithOptions(request, runtime);
}

model GetOutAccountBindDetailRequest {
  accountDomain?: string(name='AccountDomain'),
  accountId?: string(name='AccountId'),
  outAccountType?: string(name='OutAccountType'),
}

model GetOutAccountBindDetailResponseBody = {
  data?: {
    bindStatus?: int32(name='BindStatus'),
    outAccountId?: string(name='OutAccountId'),
    outAccountType?: string(name='OutAccountType'),
    token?: string(name='Token'),
    tokenExpireTime?: long(name='TokenExpireTime'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetOutAccountBindDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOutAccountBindDetailResponseBody(name='body'),
}

async function getOutAccountBindDetailWithOptions(request: GetOutAccountBindDetailRequest, runtime: Util.RuntimeOptions): GetOutAccountBindDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDomain)) {
    query['AccountDomain'] = request.accountDomain;
  }
  if (!Util.isUnset(request.accountId)) {
    query['AccountId'] = request.accountId;
  }
  if (!Util.isUnset(request.outAccountType)) {
    query['OutAccountType'] = request.outAccountType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOutAccountBindDetail',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOutAccountBindDetail(request: GetOutAccountBindDetailRequest): GetOutAccountBindDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOutAccountBindDetailWithOptions(request, runtime);
}

model GetQueuingSizeRequest {
  gameId?: string(name='GameId'),
  projectId?: string(name='ProjectId'),
  userLevel?: int32(name='UserLevel'),
}

model GetQueuingSizeResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  size?: long(name='Size'),
}

model GetQueuingSizeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetQueuingSizeResponseBody(name='body'),
}

async function getQueuingSizeWithOptions(request: GetQueuingSizeRequest, runtime: Util.RuntimeOptions): GetQueuingSizeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.gameId)) {
    query['GameId'] = request.gameId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.userLevel)) {
    query['UserLevel'] = request.userLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetQueuingSize',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getQueuingSize(request: GetQueuingSizeRequest): GetQueuingSizeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQueuingSizeWithOptions(request, runtime);
}

model GetSessionRequest {
  token?: string(name='Token'),
}

model GetSessionResponseBody = {
  data?: {
    session?: string(name='Session'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetSessionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSessionResponseBody(name='body'),
}

async function getSessionWithOptions(request: GetSessionRequest, runtime: Util.RuntimeOptions): GetSessionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSession',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSession(request: GetSessionRequest): GetSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSessionWithOptions(request, runtime);
}

model GetStopGameTokenRequest {
  accessKey?: string(name='AccessKey'),
  gameId?: string(name='GameId'),
}

model GetStopGameTokenResponseBody = {
  expireTime?: long(name='ExpireTime'),
  requestId?: string(name='RequestId'),
  token?: string(name='Token'),
}

model GetStopGameTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetStopGameTokenResponseBody(name='body'),
}

async function getStopGameTokenWithOptions(request: GetStopGameTokenRequest, runtime: Util.RuntimeOptions): GetStopGameTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessKey)) {
    query['AccessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.gameId)) {
    query['GameId'] = request.gameId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetStopGameToken',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getStopGameToken(request: GetStopGameTokenRequest): GetStopGameTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStopGameTokenWithOptions(request, runtime);
}

model KickPlayerRequest {
  gameSession?: string(name='GameSession'),
  kickedAccountId?: string(name='KickedAccountId'),
}

model KickPlayerResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model KickPlayerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: KickPlayerResponseBody(name='body'),
}

async function kickPlayerWithOptions(request: KickPlayerRequest, runtime: Util.RuntimeOptions): KickPlayerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.gameSession)) {
    query['GameSession'] = request.gameSession;
  }
  if (!Util.isUnset(request.kickedAccountId)) {
    query['KickedAccountId'] = request.kickedAccountId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'KickPlayer',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function kickPlayer(request: KickPlayerRequest): KickPlayerResponse {
  var runtime = new Util.RuntimeOptions{};
  return kickPlayerWithOptions(request, runtime);
}

model ListBoughtGamesRequest {
  accountDomain?: string(name='AccountDomain'),
  accountId?: string(name='AccountId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListBoughtGamesResponseBody = {
  items?: [ 
    {
      endTime?: long(name='EndTime'),
      gameId?: string(name='GameId'),
      gameName?: string(name='GameName'),
      startTime?: long(name='StartTime'),
    }
  ](name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListBoughtGamesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBoughtGamesResponseBody(name='body'),
}

async function listBoughtGamesWithOptions(request: ListBoughtGamesRequest, runtime: Util.RuntimeOptions): ListBoughtGamesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDomain)) {
    query['AccountDomain'] = request.accountDomain;
  }
  if (!Util.isUnset(request.accountId)) {
    query['AccountId'] = request.accountId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBoughtGames',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBoughtGames(request: ListBoughtGamesRequest): ListBoughtGamesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBoughtGamesWithOptions(request, runtime);
}

model ListContainerStatusRequest {
  gameSessionIdList?: [ 
    {
      gameSessionId?: string(name='GameSessionId'),
    }
  ](name='GameSessionIdList'),
}

model ListContainerStatusResponseBody = {
  dataList?: [ 
    {
      accountId?: string(name='AccountId'),
      containerQuitTime?: long(name='ContainerQuitTime'),
      containerStartTime?: long(name='ContainerStartTime'),
      containerState?: string(name='ContainerState'),
      gameId?: string(name='GameId'),
      gameSessionId?: string(name='GameSessionId'),
      playerDetailList?: [ 
        {
          accountId?: string(name='AccountId'),
          isInitiator?: boolean(name='IsInitiator'),
          startTime?: long(name='StartTime'),
        }
      ](name='PlayerDetailList'),
      projectId?: string(name='ProjectId'),
      tags?: string(name='Tags'),
      timestamp?: long(name='Timestamp', description='系统时间戳'),
    }
  ](name='DataList'),
  requestId?: string(name='RequestId'),
}

model ListContainerStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListContainerStatusResponseBody(name='body'),
}

async function listContainerStatusWithOptions(request: ListContainerStatusRequest, runtime: Util.RuntimeOptions): ListContainerStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.gameSessionIdList)) {
    query['GameSessionIdList'] = request.gameSessionIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListContainerStatus',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listContainerStatus(request: ListContainerStatusRequest): ListContainerStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listContainerStatusWithOptions(request, runtime);
}

model ListDeployableInstancesRequest {
  pageNumber?: long(name='PageNumber', description='页码'),
  pageSize?: long(name='PageSize', description='每页大小'),
  projectId?: string(name='ProjectId', description='项目ID'),
  versionId?: string(name='VersionId', description='游戏版本ID'),
}

model ListDeployableInstancesResponseBody = {
  dataList?: [ 
    {
      cloudGameInstanceId?: string(name='CloudGameInstanceId', description='实例ID'),
      cloudGameInstanceName?: string(name='CloudGameInstanceName', description='实例名称'),
    }
  ](name='DataList', description='数据列表'),
  pageNumber?: int32(name='PageNumber', description='表示当前调用返回读取到的位置，空代表数据已经读取完毕'),
  pageSize?: int32(name='PageSize', description='MaxResults本次请求所返回的最大记录条数'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount', description='TotalCount本次请求条件下的数据总量，此参数为可选参数，默认可不返回'),
}

model ListDeployableInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeployableInstancesResponseBody(name='body'),
}

async function listDeployableInstancesWithOptions(request: ListDeployableInstancesRequest, runtime: Util.RuntimeOptions): ListDeployableInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeployableInstances',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDeployableInstances(request: ListDeployableInstancesRequest): ListDeployableInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDeployableInstancesWithOptions(request, runtime);
}

model ListGameServerIpRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListGameServerIpResponseBody = {
  items?: [ string ](name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize', description='MaxResults本次请求所返回的最大记录条数'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount', description='TotalCount本次请求条件下的数据总量，此参数为可选参数，默认可不返回'),
}

model ListGameServerIpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGameServerIpResponseBody(name='body'),
}

async function listGameServerIpWithOptions(request: ListGameServerIpRequest, runtime: Util.RuntimeOptions): ListGameServerIpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGameServerIp',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGameServerIp(request: ListGameServerIpRequest): ListGameServerIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGameServerIpWithOptions(request, runtime);
}

model ListGameVersionsRequest {
  gameId?: string(name='GameId', description='游戏ID'),
  maxResults?: int32(name='MaxResults', description='本次读取的最大数据记录数量'),
  nextToken?: string(name='NextToken', description='标记当前开始读取的位置，置空表示从头开始'),
}

model ListGameVersionsResponseBody = {
  count?: long(name='Count', description='总记录数'),
  dataList?: [ 
    {
      versionId?: string(name='VersionId', description='版本ID'),
      versionName?: string(name='VersionName', description='版本名称'),
      versionNumber?: string(name='VersionNumber', description='版本号'),
    }
  ](name='DataList', description='数据列表'),
  maxResults?: int32(name='MaxResults', description='本次请求所返回的最大记录条数'),
  nextToken?: string(name='NextToken', description='表示当前调用返回读取到的位置，空代表数据已经读取完毕'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListGameVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGameVersionsResponseBody(name='body'),
}

async function listGameVersionsWithOptions(request: ListGameVersionsRequest, runtime: Util.RuntimeOptions): ListGameVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.gameId)) {
    query['GameId'] = request.gameId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGameVersions',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGameVersions(request: ListGameVersionsRequest): ListGameVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGameVersionsWithOptions(request, runtime);
}

model ListGamesRequest {
  maxResults?: int32(name='MaxResults', description='本次读取的最大数据记录数量'),
  nextToken?: string(name='NextToken', description='标记当前开始读取的位置，置空表示从头开始'),
}

model ListGamesResponseBody = {
  count?: long(name='Count', description='总记录数'),
  dataList?: [ 
    {
      gameId?: string(name='GameId', description='游戏ID'),
      gameName?: string(name='GameName', description='游戏名称'),
      platformType?: long(name='PlatformType', description='平台类型'),
    }
  ](name='DataList', description='数据列表'),
  maxResults?: int32(name='MaxResults', description='本次请求所返回的最大记录条数'),
  nextToken?: string(name='NextToken', description='表示当前调用返回读取到的位置，空代表数据已经读取完毕'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListGamesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGamesResponseBody(name='body'),
}

async function listGamesWithOptions(request: ListGamesRequest, runtime: Util.RuntimeOptions): ListGamesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGames',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGames(request: ListGamesRequest): ListGamesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGamesWithOptions(request, runtime);
}

model ListHistoryContainerStatusRequest {
  endTime?: long(name='EndTime', description='结束时间（Linux时间戳，单位毫秒）'),
  lastGameSessionId?: string(name='LastGameSessionId', description='上一个游戏会话ID'),
  pageSize?: long(name='PageSize', description='每页数量'),
  projectId?: string(name='ProjectId', description='项目ID'),
  startTime?: long(name='StartTime', description='开始时间（Linux时间戳，单位毫秒）'),
}

model ListHistoryContainerStatusResponseBody = {
  dataList?: [ 
    {
      accountId?: string(name='AccountId', description='主机账号ID'),
      containerQuitTime?: long(name='ContainerQuitTime', description='容器退出时间（Linux时间戳，单位毫秒）'),
      containerStartTime?: long(name='ContainerStartTime', description='容器启动时间（Linux时间戳，单位毫秒）'),
      containerState?: string(name='ContainerState', description='容器状态'),
      gameId?: string(name='GameId', description='游戏ID'),
      gameSessionId?: string(name='GameSessionId', description='游戏会话ID'),
      playerDetailList?: [ 
        {
          accountId?: string(name='AccountId', description='账号ID'),
          isInitiator?: boolean(name='IsInitiator', description='是否主机'),
          startTime?: long(name='StartTime', description='玩家进入游戏时间'),
        }
      ](name='PlayerDetailList', description='玩家信息集合'),
      projectId?: string(name='ProjectId', description='项目ID'),
      tags?: string(name='Tags', description='自定义标识'),
      timestamp?: long(name='Timestamp', description='系统时间戳'),
    }
  ](name='DataList', description='容器状态信息集合'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListHistoryContainerStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListHistoryContainerStatusResponseBody(name='body'),
}

async function listHistoryContainerStatusWithOptions(request: ListHistoryContainerStatusRequest, runtime: Util.RuntimeOptions): ListHistoryContainerStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.lastGameSessionId)) {
    query['LastGameSessionId'] = request.lastGameSessionId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHistoryContainerStatus',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHistoryContainerStatus(request: ListHistoryContainerStatusRequest): ListHistoryContainerStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHistoryContainerStatusWithOptions(request, runtime);
}

model ListProjectsRequest {
  maxResults?: int32(name='MaxResults', description='本次读取的最大数据记录数量'),
  nextToken?: string(name='NextToken', description='标记当前开始读取的位置，置空表示从头开始'),
}

model ListProjectsResponseBody = {
  count?: long(name='Count', description='总记录数'),
  dataList?: [ 
    {
      projectId?: string(name='ProjectId', description='项目ID'),
      projectName?: string(name='ProjectName', description='项目名称'),
    }
  ](name='DataList', description='数据列表'),
  maxResults?: int32(name='MaxResults', description='本次请求所返回的最大记录条数'),
  nextToken?: string(name='NextToken', description='表示当前调用返回读取到的位置，空代表数据已经读取完毕'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListProjectsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProjectsResponseBody(name='body'),
}

async function listProjectsWithOptions(request: ListProjectsRequest, runtime: Util.RuntimeOptions): ListProjectsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProjects',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProjects(request: ListProjectsRequest): ListProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectsWithOptions(request, runtime);
}

model QueryGameRequest {
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId'),
  tenantId?: long(name='TenantId'),
}

model QueryGameResponseBody = {
  data?: [ 
    {
      gameId?: long(name='GameId'),
      gmtCreate?: string(name='GmtCreate'),
      name?: string(name='Name'),
      projectId?: long(name='ProjectId'),
      tenantId?: long(name='TenantId'),
      version?: string(name='Version'),
    }
  ](name='Data'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model QueryGameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryGameResponseBody(name='body'),
}

async function queryGameWithOptions(request: QueryGameRequest, runtime: Util.RuntimeOptions): QueryGameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.tenantId)) {
    query['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryGame',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryGame(request: QueryGameRequest): QueryGameResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGameWithOptions(request, runtime);
}

model QueryGameHangRequest {
  accessKey?: string(name='AccessKey'),
  gameSession?: string(name='GameSession'),
}

model QueryGameHangResponseBody = {
  code?: string(name='Code'),
  duration?: long(name='Duration'),
  gameSession?: string(name='GameSession'),
  hanging?: boolean(name='Hanging'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  startHangTimestamp?: long(name='StartHangTimestamp'),
  success?: boolean(name='Success'),
}

model QueryGameHangResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryGameHangResponseBody(name='body'),
}

async function queryGameHangWithOptions(request: QueryGameHangRequest, runtime: Util.RuntimeOptions): QueryGameHangResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.accessKey)) {
    body['AccessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.gameSession)) {
    body['GameSession'] = request.gameSession;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryGameHang',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryGameHang(request: QueryGameHangRequest): QueryGameHangResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGameHangWithOptions(request, runtime);
}

model QueryItemsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model QueryItemsResponseBody = {
  data?: {
    items?: [ 
      {
        categoryId?: long(name='CategoryId'),
        createTime?: long(name='CreateTime'),
        description?: string(name='Description'),
        games?: [ 
          {
            gameId?: string(name='GameId'),
            name?: string(name='Name'),
          }
        ](name='Games'),
        itemId?: string(name='ItemId'),
        modifyTime?: long(name='ModifyTime'),
        originPrice?: long(name='OriginPrice'),
        salePrice?: long(name='SalePrice'),
        sellerId?: string(name='SellerId'),
        skus?: [ 
          {
            createTime?: long(name='CreateTime'),
            itemId?: string(name='ItemId'),
            modifyTime?: long(name='ModifyTime'),
            originPrice?: long(name='OriginPrice'),
            salePrice?: long(name='SalePrice'),
            saleProps?: [ 
              {
                propertyId?: long(name='PropertyId'),
                propertyName?: string(name='PropertyName'),
                value?: string(name='Value'),
                valueId?: long(name='ValueId'),
              }
            ](name='SaleProps'),
            skuId?: string(name='SkuId'),
            status?: int32(name='Status'),
          }
        ](name='Skus'),
        status?: int32(name='Status'),
        supplier?: string(name='Supplier'),
        title?: string(name='Title'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  httpStatusCode?: long(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryItemsResponseBody(name='body'),
}

async function queryItemsWithOptions(request: QueryItemsRequest, runtime: Util.RuntimeOptions): QueryItemsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryItems',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryItems(request: QueryItemsRequest): QueryItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryItemsWithOptions(request, runtime);
}

model QueryOrderRequest {
  accountDomain?: string(name='AccountDomain'),
  buyerAccountId?: string(name='BuyerAccountId'),
  orderId?: string(name='OrderId'),
}

model QueryOrderResponseBody = {
  data?: {
    accountDomain?: string(name='AccountDomain'),
    amount?: long(name='Amount'),
    applyDeliveryTime?: long(name='ApplyDeliveryTime'),
    autoUnlockTime?: long(name='AutoUnlockTime'),
    buyerAccountId?: string(name='BuyerAccountId'),
    createTime?: long(name='CreateTime'),
    finishTime?: long(name='FinishTime'),
    itemId?: string(name='ItemId'),
    orderId?: string(name='OrderId'),
    originPrice?: long(name='OriginPrice'),
    settlementPrice?: long(name='SettlementPrice'),
    skuId?: string(name='SkuId'),
    status?: string(name='Status'),
  }(name='Data'),
  deliveryStatus?: string(name='DeliveryStatus'),
  refundStatus?: string(name='RefundStatus'),
  requestId?: string(name='RequestId'),
}

model QueryOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryOrderResponseBody(name='body'),
}

async function queryOrderWithOptions(request: QueryOrderRequest, runtime: Util.RuntimeOptions): QueryOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDomain)) {
    query['AccountDomain'] = request.accountDomain;
  }
  if (!Util.isUnset(request.buyerAccountId)) {
    query['BuyerAccountId'] = request.buyerAccountId;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryOrder',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryOrder(request: QueryOrderRequest): QueryOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOrderWithOptions(request, runtime);
}

model QueryOutAccountBindStatusRequest {
  accountDomain?: string(name='AccountDomain'),
  accountId?: string(name='AccountId'),
  gameId?: string(name='GameId'),
}

model QueryOutAccountBindStatusResponseBody = {
  data?: {
    bindStatus?: int32(name='BindStatus'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryOutAccountBindStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryOutAccountBindStatusResponseBody(name='body'),
}

async function queryOutAccountBindStatusWithOptions(request: QueryOutAccountBindStatusRequest, runtime: Util.RuntimeOptions): QueryOutAccountBindStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDomain)) {
    query['AccountDomain'] = request.accountDomain;
  }
  if (!Util.isUnset(request.accountId)) {
    query['AccountId'] = request.accountId;
  }
  if (!Util.isUnset(request.gameId)) {
    query['GameId'] = request.gameId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryOutAccountBindStatus',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryOutAccountBindStatus(request: QueryOutAccountBindStatusRequest): QueryOutAccountBindStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOutAccountBindStatusWithOptions(request, runtime);
}

model QueryProjectRequest {
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  projectId?: long(name='ProjectId'),
  tenantId?: long(name='TenantId'),
}

model QueryProjectResponseBody = {
  data?: [ 
    {
      id?: long(name='Id'),
      name?: string(name='Name'),
      tenantId?: long(name='TenantId'),
    }
  ](name='Data'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model QueryProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryProjectResponseBody(name='body'),
}

async function queryProjectWithOptions(request: QueryProjectRequest, runtime: Util.RuntimeOptions): QueryProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.tenantId)) {
    query['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryProject',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryProject(request: QueryProjectRequest): QueryProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryProjectWithOptions(request, runtime);
}

model QueryTenantRequest {
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  param?: string(name='Param'),
}

model QueryTenantResponseBody = {
  data?: [ 
    {
      gmtCreate?: string(name='GmtCreate'),
      name?: string(name='Name'),
      tenantId?: long(name='TenantId'),
    }
  ](name='Data'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model QueryTenantResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTenantResponseBody(name='body'),
}

async function queryTenantWithOptions(request: QueryTenantRequest, runtime: Util.RuntimeOptions): QueryTenantResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.param)) {
    query['Param'] = request.param;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTenant',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTenant(request: QueryTenantRequest): QueryTenantResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTenantWithOptions(request, runtime);
}

model RemoveGameFromProjectRequest {
  gameId?: string(name='GameId', description='游戏iD'),
  projectId?: string(name='ProjectId', description='项目ID'),
}

model RemoveGameFromProjectResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RemoveGameFromProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveGameFromProjectResponseBody(name='body'),
}

async function removeGameFromProjectWithOptions(request: RemoveGameFromProjectRequest, runtime: Util.RuntimeOptions): RemoveGameFromProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.gameId)) {
    query['GameId'] = request.gameId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveGameFromProject',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeGameFromProject(request: RemoveGameFromProjectRequest): RemoveGameFromProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeGameFromProjectWithOptions(request, runtime);
}

model SetGameAliveRequest {
  accessKey?: string(name='AccessKey'),
  gameSession?: string(name='GameSession'),
  keepAlive?: long(name='KeepAlive'),
}

model SetGameAliveResponseBody = {
  code?: string(name='Code'),
  gameSession?: string(name='GameSession'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model SetGameAliveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetGameAliveResponseBody(name='body'),
}

async function setGameAliveWithOptions(request: SetGameAliveRequest, runtime: Util.RuntimeOptions): SetGameAliveResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.accessKey)) {
    body['AccessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.gameSession)) {
    body['GameSession'] = request.gameSession;
  }
  if (!Util.isUnset(request.keepAlive)) {
    body['KeepAlive'] = request.keepAlive;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SetGameAlive',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setGameAlive(request: SetGameAliveRequest): SetGameAliveResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGameAliveWithOptions(request, runtime);
}

model SetGameHangRequest {
  accessKey?: string(name='AccessKey'),
  duration?: long(name='Duration'),
  gameSession?: string(name='GameSession'),
}

model SetGameHangResponseBody = {
  code?: string(name='Code'),
  duration?: long(name='Duration'),
  gameSession?: string(name='GameSession'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  startHangTimestamp?: long(name='StartHangTimestamp'),
  success?: boolean(name='Success'),
}

model SetGameHangResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetGameHangResponseBody(name='body'),
}

async function setGameHangWithOptions(request: SetGameHangRequest, runtime: Util.RuntimeOptions): SetGameHangResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.accessKey)) {
    body['AccessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.duration)) {
    body['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.gameSession)) {
    body['GameSession'] = request.gameSession;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SetGameHang',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setGameHang(request: SetGameHangRequest): SetGameHangResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGameHangWithOptions(request, runtime);
}

model SkipTrialPolicyRequest {
  gameSessionId?: string(name='GameSessionId'),
}

model SkipTrialPolicyResponseBody = {
  data?: {
    skipResult?: int32(name='SkipResult'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model SkipTrialPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SkipTrialPolicyResponseBody(name='body'),
}

async function skipTrialPolicyWithOptions(request: SkipTrialPolicyRequest, runtime: Util.RuntimeOptions): SkipTrialPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.gameSessionId)) {
    query['GameSessionId'] = request.gameSessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SkipTrialPolicy',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function skipTrialPolicy(request: SkipTrialPolicyRequest): SkipTrialPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return skipTrialPolicyWithOptions(request, runtime);
}

model StartGameLiveRequest {
  extension?: map[string]string(name='Extension'),
  gameSession?: string(name='GameSession'),
  videoPushAddress?: string(name='VideoPushAddress'),
}

model StartGameLiveShrinkRequest {
  extensionShrink?: string(name='Extension'),
  gameSession?: string(name='GameSession'),
  videoPushAddress?: string(name='VideoPushAddress'),
}

model StartGameLiveResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model StartGameLiveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartGameLiveResponseBody(name='body'),
}

async function startGameLiveWithOptions(tmpReq: StartGameLiveRequest, runtime: Util.RuntimeOptions): StartGameLiveResponse {
  Util.validateModel(tmpReq);
  var request = new StartGameLiveShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.extension)) {
    request.extensionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extension, 'Extension', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.extensionShrink)) {
    query['Extension'] = request.extensionShrink;
  }
  if (!Util.isUnset(request.gameSession)) {
    query['GameSession'] = request.gameSession;
  }
  if (!Util.isUnset(request.videoPushAddress)) {
    query['VideoPushAddress'] = request.videoPushAddress;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartGameLive',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startGameLive(request: StartGameLiveRequest): StartGameLiveResponse {
  var runtime = new Util.RuntimeOptions{};
  return startGameLiveWithOptions(request, runtime);
}

model StopGameLiveRequest {
  gameSession?: string(name='GameSession'),
}

model StopGameLiveResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model StopGameLiveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopGameLiveResponseBody(name='body'),
}

async function stopGameLiveWithOptions(request: StopGameLiveRequest, runtime: Util.RuntimeOptions): StopGameLiveResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.gameSession)) {
    query['GameSession'] = request.gameSession;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopGameLive',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopGameLive(request: StopGameLiveRequest): StopGameLiveResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopGameLiveWithOptions(request, runtime);
}

model StopGameSessionRequest {
  accessKey?: string(name='AccessKey'),
  bizParam?: string(name='BizParam'),
  gameId?: string(name='GameId'),
  gameSession?: string(name='GameSession'),
  reason?: string(name='Reason'),
  userId?: string(name='UserId'),
}

model StopGameSessionResponseBody = {
  gameId?: string(name='GameId'),
  gameSession?: string(name='GameSession'),
  message?: string(name='Message'),
  queueCode?: int32(name='QueueCode'),
  queueState?: int32(name='QueueState'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StopGameSessionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopGameSessionResponseBody(name='body'),
}

async function stopGameSessionWithOptions(request: StopGameSessionRequest, runtime: Util.RuntimeOptions): StopGameSessionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.accessKey)) {
    body['AccessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.bizParam)) {
    body['BizParam'] = request.bizParam;
  }
  if (!Util.isUnset(request.gameId)) {
    body['GameId'] = request.gameId;
  }
  if (!Util.isUnset(request.gameSession)) {
    body['GameSession'] = request.gameSession;
  }
  if (!Util.isUnset(request.reason)) {
    body['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopGameSession',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopGameSession(request: StopGameSessionRequest): StopGameSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopGameSessionWithOptions(request, runtime);
}

model SubmitDeploymentRequest {
  cloudGameInstanceIds?: string(name='CloudGameInstanceIds', description='实例ID列表'),
  gameId?: string(name='GameId', description='游戏iD'),
  operationType?: string(name='OperationType', description='操作类型'),
  projectId?: string(name='ProjectId', description='项目ID'),
  versionId?: string(name='VersionId', description='游戏版本ID'),
}

model SubmitDeploymentResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  taskId?: string(name='TaskId', description='任务ID'),
}

model SubmitDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitDeploymentResponseBody(name='body'),
}

async function submitDeploymentWithOptions(request: SubmitDeploymentRequest, runtime: Util.RuntimeOptions): SubmitDeploymentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cloudGameInstanceIds)) {
    query['CloudGameInstanceIds'] = request.cloudGameInstanceIds;
  }
  if (!Util.isUnset(request.gameId)) {
    query['GameId'] = request.gameId;
  }
  if (!Util.isUnset(request.operationType)) {
    query['OperationType'] = request.operationType;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitDeployment',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitDeployment(request: SubmitDeploymentRequest): SubmitDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitDeploymentWithOptions(request, runtime);
}

model SubmitInternalPurchaseChargeDataRequest {
  activeUserRetentionRateOneDay?: float(name='ActiveUserRetentionRateOneDay'),
  activeUserRetentionRateSevenDay?: float(name='ActiveUserRetentionRateSevenDay'),
  activeUserRetentionRateThirtyDay?: float(name='ActiveUserRetentionRateThirtyDay'),
  arpu?: float(name='Arpu'),
  chargeDate?: string(name='ChargeDate'),
  dau?: long(name='Dau'),
  gameId?: string(name='GameId'),
  mau?: long(name='Mau'),
  newUserRetentionRateOneDay?: float(name='NewUserRetentionRateOneDay'),
  newUserRetentionRateSevenDay?: float(name='NewUserRetentionRateSevenDay'),
  newUserRetentionRateThirtyDay?: float(name='NewUserRetentionRateThirtyDay'),
  paymentConversionRate?: float(name='PaymentConversionRate'),
  playTimeAverageOneDay?: float(name='PlayTimeAverageOneDay'),
  playTimeAverageThirtyDay?: float(name='PlayTimeAverageThirtyDay'),
  playTimeNinetyPointsOneDay?: float(name='PlayTimeNinetyPointsOneDay'),
  playTimeNinetyPointsThirtyDay?: float(name='PlayTimeNinetyPointsThirtyDay'),
  playTimeRangeOneDay?: string(name='PlayTimeRangeOneDay'),
  playTimeRangeThirtyDay?: string(name='PlayTimeRangeThirtyDay'),
  userActivationRate?: float(name='UserActivationRate'),
}

model SubmitInternalPurchaseChargeDataResponseBody = {
  data?: {
    message?: string(name='Message'),
    status?: int32(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model SubmitInternalPurchaseChargeDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitInternalPurchaseChargeDataResponseBody(name='body'),
}

async function submitInternalPurchaseChargeDataWithOptions(request: SubmitInternalPurchaseChargeDataRequest, runtime: Util.RuntimeOptions): SubmitInternalPurchaseChargeDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.activeUserRetentionRateOneDay)) {
    query['ActiveUserRetentionRateOneDay'] = request.activeUserRetentionRateOneDay;
  }
  if (!Util.isUnset(request.activeUserRetentionRateSevenDay)) {
    query['ActiveUserRetentionRateSevenDay'] = request.activeUserRetentionRateSevenDay;
  }
  if (!Util.isUnset(request.activeUserRetentionRateThirtyDay)) {
    query['ActiveUserRetentionRateThirtyDay'] = request.activeUserRetentionRateThirtyDay;
  }
  if (!Util.isUnset(request.arpu)) {
    query['Arpu'] = request.arpu;
  }
  if (!Util.isUnset(request.chargeDate)) {
    query['ChargeDate'] = request.chargeDate;
  }
  if (!Util.isUnset(request.dau)) {
    query['Dau'] = request.dau;
  }
  if (!Util.isUnset(request.gameId)) {
    query['GameId'] = request.gameId;
  }
  if (!Util.isUnset(request.mau)) {
    query['Mau'] = request.mau;
  }
  if (!Util.isUnset(request.newUserRetentionRateOneDay)) {
    query['NewUserRetentionRateOneDay'] = request.newUserRetentionRateOneDay;
  }
  if (!Util.isUnset(request.newUserRetentionRateSevenDay)) {
    query['NewUserRetentionRateSevenDay'] = request.newUserRetentionRateSevenDay;
  }
  if (!Util.isUnset(request.newUserRetentionRateThirtyDay)) {
    query['NewUserRetentionRateThirtyDay'] = request.newUserRetentionRateThirtyDay;
  }
  if (!Util.isUnset(request.paymentConversionRate)) {
    query['PaymentConversionRate'] = request.paymentConversionRate;
  }
  if (!Util.isUnset(request.playTimeAverageOneDay)) {
    query['PlayTimeAverageOneDay'] = request.playTimeAverageOneDay;
  }
  if (!Util.isUnset(request.playTimeAverageThirtyDay)) {
    query['PlayTimeAverageThirtyDay'] = request.playTimeAverageThirtyDay;
  }
  if (!Util.isUnset(request.playTimeNinetyPointsOneDay)) {
    query['PlayTimeNinetyPointsOneDay'] = request.playTimeNinetyPointsOneDay;
  }
  if (!Util.isUnset(request.playTimeNinetyPointsThirtyDay)) {
    query['PlayTimeNinetyPointsThirtyDay'] = request.playTimeNinetyPointsThirtyDay;
  }
  if (!Util.isUnset(request.playTimeRangeOneDay)) {
    query['PlayTimeRangeOneDay'] = request.playTimeRangeOneDay;
  }
  if (!Util.isUnset(request.playTimeRangeThirtyDay)) {
    query['PlayTimeRangeThirtyDay'] = request.playTimeRangeThirtyDay;
  }
  if (!Util.isUnset(request.userActivationRate)) {
    query['UserActivationRate'] = request.userActivationRate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitInternalPurchaseChargeData',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitInternalPurchaseChargeData(request: SubmitInternalPurchaseChargeDataRequest): SubmitInternalPurchaseChargeDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitInternalPurchaseChargeDataWithOptions(request, runtime);
}

model SubmitInternalPurchaseOrdersRequest {
  orderList?: [ 
    {
      batchNumber?: string(name='BatchNumber'),
      finalPrice?: long(name='FinalPrice'),
      finishTime?: long(name='FinishTime'),
      gameId?: string(name='GameId'),
      orderId?: string(name='OrderId'),
      roleId?: string(name='RoleId'),
      userId?: string(name='UserId'),
    }
  ](name='OrderList'),
}

model SubmitInternalPurchaseOrdersResponseBody = {
  data?: {
    message?: string(name='Message'),
    status?: int32(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model SubmitInternalPurchaseOrdersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitInternalPurchaseOrdersResponseBody(name='body'),
}

async function submitInternalPurchaseOrdersWithOptions(request: SubmitInternalPurchaseOrdersRequest, runtime: Util.RuntimeOptions): SubmitInternalPurchaseOrdersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderList)) {
    query['OrderList'] = request.orderList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitInternalPurchaseOrders',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitInternalPurchaseOrders(request: SubmitInternalPurchaseOrdersRequest): SubmitInternalPurchaseOrdersResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitInternalPurchaseOrdersWithOptions(request, runtime);
}

model SubmitInternalPurchaseReadyFlagRequest {
  batchInfoList?: [ 
    {
      batchNumbers?: string(name='BatchNumbers'),
      batchSize?: int32(name='BatchSize'),
    }
  ](name='BatchInfoList'),
  chargeDate?: string(name='ChargeDate'),
  gameId?: string(name='GameId'),
  orderTotalCount?: int32(name='OrderTotalCount'),
  status?: int32(name='Status'),
}

model SubmitInternalPurchaseReadyFlagResponseBody = {
  data?: {
    message?: string(name='Message'),
    missingBatchNumbers?: string(name='MissingBatchNumbers'),
    status?: int32(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model SubmitInternalPurchaseReadyFlagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitInternalPurchaseReadyFlagResponseBody(name='body'),
}

async function submitInternalPurchaseReadyFlagWithOptions(request: SubmitInternalPurchaseReadyFlagRequest, runtime: Util.RuntimeOptions): SubmitInternalPurchaseReadyFlagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.batchInfoList)) {
    query['BatchInfoList'] = request.batchInfoList;
  }
  if (!Util.isUnset(request.chargeDate)) {
    query['ChargeDate'] = request.chargeDate;
  }
  if (!Util.isUnset(request.gameId)) {
    query['GameId'] = request.gameId;
  }
  if (!Util.isUnset(request.orderTotalCount)) {
    query['OrderTotalCount'] = request.orderTotalCount;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitInternalPurchaseReadyFlag',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitInternalPurchaseReadyFlag(request: SubmitInternalPurchaseReadyFlagRequest): SubmitInternalPurchaseReadyFlagResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitInternalPurchaseReadyFlagWithOptions(request, runtime);
}

model UploadGameVersionByDownloadRequest {
  downloadType?: string(name='DownloadType'),
  fileType?: string(name='FileType'),
  gameId?: string(name='GameId'),
  gameVersion?: string(name='GameVersion'),
  hash?: string(name='Hash'),
  versionName?: string(name='VersionName'),
}

model UploadGameVersionByDownloadResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  taskId?: string(name='TaskId', description='任务id'),
}

model UploadGameVersionByDownloadResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadGameVersionByDownloadResponseBody(name='body'),
}

async function uploadGameVersionByDownloadWithOptions(request: UploadGameVersionByDownloadRequest, runtime: Util.RuntimeOptions): UploadGameVersionByDownloadResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.downloadType)) {
    query['DownloadType'] = request.downloadType;
  }
  if (!Util.isUnset(request.fileType)) {
    query['FileType'] = request.fileType;
  }
  if (!Util.isUnset(request.gameId)) {
    query['GameId'] = request.gameId;
  }
  if (!Util.isUnset(request.gameVersion)) {
    query['GameVersion'] = request.gameVersion;
  }
  if (!Util.isUnset(request.hash)) {
    query['Hash'] = request.hash;
  }
  if (!Util.isUnset(request.versionName)) {
    query['VersionName'] = request.versionName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadGameVersionByDownload',
    version = '2020-07-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadGameVersionByDownload(request: UploadGameVersionByDownloadRequest): UploadGameVersionByDownloadResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadGameVersionByDownloadWithOptions(request, runtime);
}

